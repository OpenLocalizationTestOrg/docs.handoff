{"content":"---\ntitle: \"Garbage Collection and Performance | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"garbage collection, troubleshooting\"\n  - \"garbage collection, performance\"\nms.assetid: c203467b-e95c-4ccf-b30b-953eb3463134\ncaps.latest.revision: 35\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Garbage Collection and Performance\n<a name=\"top\"></a> This topic describes issues related to garbage collection and memory usage. It addresses issues that pertain to the managed heap and explains how to minimize the effect of garbage collection on your applications. Each issue has links to procedures that you can use to investigate problems.  \n  \n This topic contains the following sections:  \n  \n-   [Performance Analysis Tools](#performance_analysis_tools)  \n  \n-   [Troubleshooting Performance Issues](#troubleshooting_performance_issues)  \n  \n-   [Troubleshooting Guidelines](#troubleshooting_guidelines)  \n  \n-   [Performance Check Procedures](#performance_check_procedures)  \n  \n<a name=\"performance_analysis_tools\"></a>   \n## Performance Analysis Tools  \n The following sections describe the tools that are available for investigating memory usage and garbage collection issues. The [procedures](#performance_check_procedures) provided later in this topic refer to these tools.  \n  \n<a name=\"perf_counters\"></a>   \n### Memory Performance Counters  \n You can use performance counters to gather performance data. For instructions, see [Runtime Profiling](../../../docs/framework/debug-trace-profile/runtime-profiling.md). The .NET CLR Memory category of performance counters, as described in [Performance Counters in the .NET Framework](../../../docs/framework/debug-trace-profile/performance-counters.md), provides information about the garbage collector.  \n  \n<a name=\"sos\"></a>   \n### Debugging with SOS  \n You can use the [Windows Debugger (WinDbg)](http://go.microsoft.com/fwlink/?LinkId=186482) to inspect objects on the managed heap.  \n  \n To install WinDbg, install Debugging Tools for Windows from the [WDK and Developer Tools Web site](http://go.microsoft.com/fwlink/?LinkID=103787).  \n  \n<a name=\"etw\"></a>   \n### Garbage Collection ETW Events  \n Event tracing for Windows (ETW) is a tracing system that supplements the profiling and debugging support provided by the .NET Framework. Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], [garbage collection ETW events](../../../docs/framework/performance/garbage-collection-etw-events.md) capture useful information for analyzing the managed heap from a statistical point of view. For example, the `GCStart_V1` event, which is raised when a garbage collection is about to occur, provides the following information:  \n  \n-   Which generation of objects is being collected.  \n  \n-   What triggered the garbage collection.  \n  \n-   Type of garbage collection (concurrent or not concurrent).  \n  \n ETW event logging is efficient and will not mask any performance problems associated with garbage collection. A process can provide its own events in conjunction with ETW events. When logged, both the application's events and the garbage collection events can be correlated to determine how and when heap problems occur. For example, a server application could provide events at the start and end of a client request.  \n  \n<a name=\"profiling_api\"></a>   \n### The Profiling API  \n The common language runtime (CLR) profiling interfaces provide detailed information about the objects that were affected during garbage collection. A profiler can be notified when a garbage collection starts and ends. It can provide reports about the objects on the managed heap, including an identification of objects in each generation. For more information, see [Profiling Overview](../../../docs/framework/unmanaged-api/profiling/profiling-overview.md).  \n  \n Profilers can provide comprehensive information. However, complex profilers can potentially modify an application's behavior.  \n  \n### Application Domain Resource Monitoring  \n Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain. For more information, see [Application Domain Resource Monitoring](../../../docs/standard/garbage-collection/app-domain-resource-monitoring.md).  \n  \n [Back to top](#top)  \n  \n<a name=\"troubleshooting_performance_issues\"></a>   \n## Troubleshooting Performance Issues  \n The first step is to [determine whether the issue is actually garbage collection](#IsGC). If you determine that it is, select from the following list to troubleshoot the problem.  \n  \n-   [An out-of-memory exception is thrown](#Issue_OOM)  \n  \n-   [The process uses too much memory](#Issue_TooMuchMemory)  \n  \n-   [The garbage collector does not reclaim objects fast enough](#Issue_NotFastEnough)  \n  \n-   [The managed heap is too fragmented](#Issue_Fragmentation)  \n  \n-   [Garbage collection pauses are too long](#Issue_LongPauses)  \n  \n-   [Generation 0 is too big](#Issue_Gen0)  \n  \n-   [CPU usage during a garbage collection is too high](#Issue_HighCPU)  \n  \n<a name=\"Issue_OOM\"></a>   \n### Issue: An Out-of-Memory Exception Is Thrown  \n There are two legitimate cases for a managed <xref:System.OutOfMemoryException> to be thrown:  \n  \n-   Running out of virtual memory.  \n  \n     The garbage collector allocates memory from the system in segments of a pre-determined size. If an allocation requires an additional segment, but there is no contiguous free block left in the process's virtual memory space, the allocation for the managed heap will fail.  \n  \n-   Not having enough physical memory to allocate.  \n  \n|Performance checks|  \n|------------------------|  \n|[Determine whether the out-of-memory exception is managed.](#OOMIsManaged)<br /><br /> [Determine how much virtual memory can be reserved.](#GetVM)<br /><br /> [Determine whether there is enough physical memory.](#Physical)|  \n  \n If you determine that the exception is not legitimate, contact Microsoft Customer Service and Support with the following information:  \n  \n-   The stack with the managed out-of-memory exception.  \n  \n-   Full memory dump.  \n  \n-   Data that proves that it is not a legitimate out-of-memory exception, including data that shows that virtual or physical memory is not an issue.  \n  \n<a name=\"Issue_TooMuchMemory\"></a>   \n### Issue: The Process Uses Too Much Memory  \n A common assumption is that the memory usage display on the **Performance** tab of Windows Task Manager can indicate when too much memory is being used. However, that display pertains to the working set; it does not provide information about virtual memory usage.  \n  \n If you determine that the issue is caused by the managed heap, you must measure the managed heap over time to determine any patterns.  \n  \n If you determine that the problem is not caused by the managed heap, you must use native debugging.  \n  \n|Performance checks|  \n|------------------------|  \n|[Determine how much virtual memory can be reserved.](#GetVM)<br /><br /> [Determine how much memory the managed heap is committing.](#ManagedHeapCommit)<br /><br /> [Determine how much memory the managed heap reserves.](#ManagedHeapReserve)<br /><br /> [Determine large objects in generation 2.](#ExamineGen2)<br /><br /> [Determine references to objects.](#ObjRef)|  \n  \n<a name=\"Issue_NotFastEnough\"></a>   \n### Issue: The Garbage Collector Does Not Reclaim Objects Fast Enough  \n When it appears as if objects are not being reclaimed as expected for garbage collection, you must determine if there are any strong references to those objects.  \n  \n You may also encounter this issue if there has been no garbage collection for the generation that contains a dead object, which indicates that the finalizer for the dead object has not been run. For example, this is possible when you are running a single-threaded apartment (STA) application and the thread that services the finalizer queue cannot call into it.  \n  \n|Performance checks|  \n|------------------------|  \n|[Check references to objects.](#ObjRef)<br /><br /> [Determine whether a finalizer has been run.](#Induce)<br /><br /> [Determine whether there are objects waiting to be finalized.](#Finalize)|  \n  \n<a name=\"Issue_Fragmentation\"></a>   \n### Issue: The Managed Heap Is Too fragmented  \n The fragmentation level is calculated as the ratio of free space over the total allocated memory for the generation. For generation 2, an acceptable level of fragmentation is no more than 20%. Because generation 2 can get very big, the ratio of fragmentation is more important than the absolute value.  \n  \n Having lots of free space in generation 0 is not a problem because this is the generation where new objects are allocated.  \n  \n Fragmentation always occurs in the large object heap because it is not compacted. Free objects that are adjacent are naturally collapsed into a single space to satisfy large object allocation requests.  \n  \n Fragmentation can become a problem in generation 1 and generation 2. If these generations have a large amount of free space after a garbage collection, an application's object usage may need modification, and you should consider re-evaluating the lifetime of long-term objects.  \n  \n Excessive pinning of objects can increase fragmentation. If fragmentation is high, too many objects could be pinned.  \n  \n If fragmentation of virtual memory is preventing the garbage collector from adding segments, the causes could be one of the following:  \n  \n-   Frequent loading and unloading of many small assemblies.  \n  \n-   Holding too many references to COM objects when interoperating with unmanaged code.  \n  \n-   Creation of large transient objects, which causes the large object heap to allocate and free heap segments frequently.  \n  \n     When hosting the CLR, an application can request that the garbage collector retain its segments. This reduces the frequency of segment allocations. This is accomplished by using the STARTUP_HOARD_GC_VM flag in the [STARTUP_FLAGS Enumeration](../../../docs/framework/unmanaged-api/hosting/startup-flags-enumeration.md).  \n  \n|Performance checks|  \n|------------------------|  \n|[Determine the amount of free space in the managed heap.](#Fragmented)<br /><br /> [Determine the number of pinned objects.](#Pinned)|  \n  \n If you think that there is no legitimate cause for the fragmentation, contact Microsoft Customer Service and Support.  \n  \n<a name=\"Issue_LongPauses\"></a>   \n### Issue: Garbage Collection Pauses Are Too Long  \n Garbage collection operates in soft real time, so an application must be able to tolerate some pauses. A criterion for soft real time is that 95% of the operations must finish on time.  \n  \n In concurrent garbage collection, managed threads are allowed to run during a collection, which means that pauses are very minimal.  \n  \n Ephemeral garbage collections (generations 0 and 1) last only a few milliseconds, so decreasing pauses is usually not feasible. However, you can decrease the pauses in generation 2 collections by changing the pattern of allocation requests by an application.  \n  \n Another, more accurate, method is to use [garbage collection ETW events](../../../docs/framework/performance/garbage-collection-etw-events.md). You can find the timings for collections by adding the time stamp differences for a sequence of events. The whole collection sequence includes suspension of the execution engine, the garbage collection itself, and the resumption of the execution engine.  \n  \n You can use [Garbage Collection Notifications](../../../docs/standard/garbage-collection/notifications.md) to determine whether a server is about to have a generation 2 collection, and whether rerouting requests to another server could ease any problems with pauses.  \n  \n|Performance checks|  \n|------------------------|  \n|[Determine the length of time in a garbage collection.](#TimeInGC)<br /><br /> [Determine what caused a garbage collection.](#Triggered)|  \n  \n<a name=\"Issue_Gen0\"></a>   \n### Issue: Generation 0 Is Too Big  \n Generation 0 is likely to have a larger number of objects on a 64-bit system, especially when you use server garbage collection instead of workstation garbage collection. This is because the threshold to trigger a generation 0 garbage collection is higher in these environments, and generation 0 collections can get much bigger. Performance is improved when an application allocates more memory before a garbage collection is triggered.  \n  \n<a name=\"Issue_HighCPU\"></a>   \n### Issue: CPU Usage During a Garbage Collection Is Too High  \n CPU usage will be high during a garbage collection. If a significant amount of process time is spent in a garbage collection, the number of collections is too frequent or the collection is lasting too long. An increased allocation rate of objects on the managed heap causes garbage collection to occur more frequently. Decreasing the allocation rate reduces the frequency of garbage collections.  \n  \n You can monitor allocation rates by using the `Allocated Bytes/second` performance counter. For more information, see [Performance Counters in the .NET Framework](../../../docs/framework/debug-trace-profile/performance-counters.md).  \n  \n The duration of a collection is primarily a factor of the number of objects that survive after allocation. The garbage collector must go through a large amount of memory if many objects remain to be collected. The work to compact the survivors is time-consuming. To determine how many objects were handled during a collection, set a breakpoint in the debugger at the end of a garbage collection for a specified generation.  \n  \n|Performance checks|  \n|------------------------|  \n|[Determine if high CPU usage is caused by garbage collection.](#HighCPU)<br /><br /> [Set a breakpoint at the end of garbage collection.](#GenBreak)|  \n  \n [Back to top](#top)  \n  \n<a name=\"troubleshooting_guidelines\"></a>   \n## Troubleshooting Guidelines  \n This section describes guidelines that you should consider as you begin your investigations.  \n  \n### Workstation or Server Garbage Collection  \n Determine if you are using the correct type of garbage collection. If your application uses multiple threads and object instances, use server garbage collection instead of workstation garbage collection. Server garbage collection operates on multiple threads, whereas workstation garbage collection requires multiple instances of an application to run their own garbage collection threads and compete for CPU time.  \n  \n An application that has a low load and that performs tasks infrequently in the background, such as a service, could use workstation garbage collection with concurrent garbage collection disabled.  \n  \n### When to Measure the Managed Heap Size  \n Unless you are using a profiler, you will have to establish a consistent measuring pattern to effectively diagnose performance issues. Consider the following points to establish a schedule:  \n  \n-   If you measure after a generation 2 garbage collection, the entire managed heap will be free of garbage (dead objects).  \n  \n-   If you measure immediately after a generation 0 garbage collection, the objects in generations 1 and 2 will not be collected yet.  \n  \n-   If you measure immediately before a garbage collection, you will measure as much allocation as possible before the garbage collection starts.  \n  \n-   Measuring during a garbage collection is problematic, because the garbage collector data structures are not in a valid state for traversal and may not be able to give you the complete results. This is by design.  \n  \n-   When you are using workstation garbage collection with concurrent garbage collection, the reclaimed objects are not compacted, so the heap size can be the same or larger (fragmentation can make it appear to be larger).  \n  \n-   Concurrent garbage collection on generation 2 is delayed when the physical memory load is too high.  \n  \n The following procedure describes how to set a breakpoint so that you can measure the managed heap.  \n  \n<a name=\"GenBreak\"></a>   \n##### To set a breakpoint at the end of garbage collection  \n  \n-   In WinDbg with the SOS debugger extension loaded, type the following command:  \n  \n     **bp mscorwks!WKS::GCHeap::RestartEE \"j (dwo(mscorwks!WKS::GCHeap::GcCondemnedGeneration)==2) 'kb';'g'\"**  \n  \n     where **GcCondemnedGeneration** is set to the desired generation. This command requires private symbols.  \n  \n     This command forces a break if **RestartEE** is executed after generation 2 objects have been reclaimed for garbage collection.  \n  \n     In server garbage collection, only one thread calls **RestartEE**, so the breakpoint will occur only once during a generation 2 garbage collection.  \n  \n [Back to top](#top)  \n  \n<a name=\"performance_check_procedures\"></a>   \n## Performance Check Procedures  \n This section describes the following procedures to isolate the cause of your performance issue:  \n  \n-   [Determine whether the problem is caused by garbage collection.](#IsGC)  \n  \n-   [Determine whether the out-of-memory exception is managed.](#OOMIsManaged)  \n  \n-   [Determine how much virtual memory can be reserved.](#GetVM)  \n  \n-   [Determine whether there is enough physical memory.](#Physical)  \n  \n-   [Determine how much memory the managed heap is committing.](#ManagedHeapCommit)  \n  \n-   [Determine how much memory the managed heap reserves.](#ManagedHeapReserve)  \n  \n-   [Determine large objects in generation 2.](#ExamineGen2)  \n  \n-   [Determine references to objects.](#ObjRef)  \n  \n-   [Determine whether a finalizer has been run.](#Induce)  \n  \n-   [Determine whether there are objects waiting to be finalized.](#Finalize)  \n  \n-   [Determine the amount of free space in the managed heap.](#Fragmented)  \n  \n-   [Determine the number of pinned objects.](#Pinned)  \n  \n-   [Determine the length of time in a garbage collection.](#TimeInGC)  \n  \n-   [Determine what triggered a garbage collection.](#Triggered)  \n  \n-   [Determine whether high CPU usage is caused by garbage collection.](#HighCPU)  \n  \n<a name=\"IsGC\"></a>   \n##### To determine whether the problem is caused by garbage collection  \n  \n-   Examine the following two memory performance counters:  \n  \n    -   **% Time in GC**. Displays the percentage of elapsed time that was spent performing a garbage collection after the last garbage collection cycle. Use this counter to determine whether the garbage collector is spending too much time to make managed heap space available. If the time spent in garbage collection is relatively low, that could indicate a resource problem outside the managed heap. This counter may not be accurate when concurrent or background garbage collection is involved.  \n  \n    -   **# Total committed Bytes**. Displays the amount of virtual memory currently committed by the garbage collector. Use this counter to determine whether the memory consumed by the garbage collector is an excessive portion of the memory that your application uses.  \n  \n     Most of the memory performance counters are updated at the end of each garbage collection. Therefore, they may not reflect the current conditions that you want information about.  \n  \n<a name=\"OOMIsManaged\"></a>   \n##### To determine whether the out-of-memory exception is managed  \n  \n1.  In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the print exception (**pe**) command:  \n  \n     **!pe**  \n  \n     If the exception is managed, <xref:System.OutOfMemoryException> is displayed as the exception type, as shown in the following example.  \n  \n    ```  \n    Exception object: 39594518  \n    Exception type: System.OutOfMemoryException  \n    Message: <none>  \n    InnerException: <none>  \n    StackTrace (generated):  \n    ```  \n  \n2.  If the output does not specify an exception, you have to determine which thread the out-of-memory exception is from. Type the following command in the debugger to show all the threads with their call stacks:  \n  \n     **~\\*kb**  \n  \n     The thread with the stack that has exception calls is indicated by the `RaiseTheException` argument. This is the managed exception object.  \n  \n    ```  \n    28adfb44 7923918f 5b61f2b4 00000000 5b61f2b4 mscorwks!RaiseTheException+0xa0   \n    ```  \n  \n3.  You can use the following command to dump nested exceptions.  \n  \n     **!pe -nested**  \n  \n     If you do not find any exceptions, the out-of-memory exception originated from unmanaged code.  \n  \n<a name=\"GetVM\"></a>   \n##### To determine how much virtual memory can be reserved  \n  \n-   In WinDbg with the SOS debugger extension loaded, type the following command to get the largest free region:  \n  \n     **!address -summary**  \n  \n     The largest free region is displayed as shown in the following output.  \n  \n    ```  \n    Largest free region: Base 54000000 - Size 0003A980  \n    ```  \n  \n     In this example, the size of the largest free region is approximately 24000 KB (3A980 in hexadecimal). This region is much smaller than what the garbage collector needs for a segment.  \n  \n     -or-  \n  \n-   Use the **vmstat** command:  \n  \n     **!vmstat**  \n  \n     The largest free region is the largest value in the MAXIMUM column, as shown in the following output.  \n  \n    ```  \n    TYPE        MINIMUM   MAXIMUM     AVERAGE   BLK COUNT   TOTAL  \n    ~~~~        ~~~~~~~   ~~~~~~~     ~~~~~~~   ~~~~~~~~~~  ~~~~  \n    Free:  \n    Small       8K        64K         46K       36          1,671K  \n    Medium      80K       864K        349K      3           1,047K  \n    Large       1,384K    1,278,848K  151,834K  12          1,822,015K  \n    Summary     8K        1,278,848K  35,779K   51          1,824,735K  \n    ```  \n  \n<a name=\"Physical\"></a>   \n##### To determine whether there is enough physical memory  \n  \n1.  Start Windows Task Manager.  \n  \n2.  On the **Performance** tab, look at the committed value. (In Windows 7, look at **Commit (KB)** in the **System group**.)  \n  \n     If the **Total** is close to the **Limit**, you are running low on physical memory.  \n  \n<a name=\"ManagedHeapCommit\"></a>   \n##### To determine how much memory the managed heap is committing  \n  \n-   Use the `# Total committed bytes` memory performance counter to get the number of bytes that the managed heap is committing. The garbage collector commits chunks on a segment as needed, not all at the same time.  \n  \n    > [!NOTE]\n    >  Do not use the `# Bytes in all Heaps` performance counter, because it does not represent actual memory usage by the managed heap. The size of a generation is included in this value and is actually its threshold size, that is, the size that induces a garbage collection if the generation is filled with objects. Therefore, this value is usually zero.  \n  \n<a name=\"ManagedHeapReserve\"></a>   \n##### To determine how much memory the managed heap reserves  \n  \n-   Use the `# Total reserved bytes` memory performance counter.  \n  \n     The garbage collector reserves memory in segments, and you can determine where a segment starts by using the **eeheap** command.  \n  \n    > [!IMPORTANT]\n    >  Although you can determine the amount of memory the garbage collector allocates for each segment, segment size is implementation-specific and is subject to change at any time, including in periodic updates. Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.  \n  \n-   In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:  \n  \n     **!eeheap -gc**  \n  \n     The result is as follows.  \n  \n    ```  \n    Number of GC Heaps: 2  \n    ------------------------------  \n    Heap 0 (002db550)  \n    generation 0 starts at 0x02abe29c  \n    generation 1 starts at 0x02abdd08  \n    generation 2 starts at 0x02ab0038  \n    ephemeral segment allocation context: none  \n     segment    begin allocated     size  \n    02ab0000 02ab0038  02aceff4 0x0001efbc(126908)  \n    Large object heap starts at 0x0aab0038  \n     segment    begin allocated     size  \n    0aab0000 0aab0038  0aab2278 0x00002240(8768)  \n    Heap Size   0x211fc(135676)  \n    ------------------------------  \n    Heap 1 (002dc958)  \n    generation 0 starts at 0x06ab1bd8  \n    generation 1 starts at 0x06ab1bcc  \n    generation 2 starts at 0x06ab0038  \n    ephemeral segment allocation context: none  \n     segment    begin allocated     size  \n    06ab0000 06ab0038  06ab3be4 0x00003bac(15276)  \n    Large object heap starts at 0x0cab0038  \n     segment    begin allocated     size  \n    0cab0000 0cab0038  0cab0048 0x00000010(16)  \n    Heap Size    0x3bbc(15292)  \n    ------------------------------  \n    GC Heap Size   0x24db8(150968)  \n    ```  \n  \n     The addresses indicated by \"segment\" are the starting addresses of the segments.  \n  \n<a name=\"ExamineGen2\"></a>   \n##### To determine large objects in generation 2  \n  \n-   In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:  \n  \n     **!dumpheap –stat**  \n  \n     If the managed heap is big, **dumpheap** may take a while to finish.  \n  \n     You can start analyzing from the last few lines of the output, because they list the objects that use the most space. For example:  \n  \n    ```  \n    2c6108d4   173712     14591808 DevExpress.XtraGrid.Views.Grid.ViewInfo.GridCellInfo  \n    00155f80      533     15216804      Free  \n    7a747c78   791070     15821400 System.Collections.Specialized.ListDictionary+DictionaryNode  \n    7a747bac   700930     19626040 System.Collections.Specialized.ListDictionary  \n    2c64e36c    78644     20762016 DevExpress.XtraEditors.ViewInfo.TextEditViewInfo  \n    79124228   121143     29064120 System.Object[]  \n    035f0ee4    81626     35588936 Toolkit.TlkOrder  \n    00fcae40     6193     44911636 WaveBasedStrategy.Tick_Snap[]  \n    791242ec    40182     90664128 System.Collections.Hashtable+bucket[]  \n    790fa3e0  3154024    137881448 System.String  \n    Total 8454945 objects  \n    ```  \n  \n     The last object listed is a string and occupies the most space. You can examine your application to see how your string objects can be optimized. To see strings that are between 150 and 200 bytes, type the following:  \n  \n     **!dumpheap -type System.String -min 150 -max 200**  \n  \n     An example of the results is as follows.  \n  \n    ```  \n    Address  MT           Size  Gen  \n    1875d2c0 790fa3e0      152    2 System.String HighlightNullStyle_Blotter_PendingOrder-11_Blotter_PendingOrder-11  \n    …  \n    ```  \n  \n     Using an integer instead of a string for an ID can be more efficient. If the same string is being repeated thousands of times, consider string interning. For more information about string interning, see the reference topic for the <xref:System.String.Intern%2A?displayProperty=fullName> method.  \n  \n<a name=\"ObjRef\"></a>   \n##### To determine references to objects  \n  \n-   In WinDbg with the SOS debugger extension loaded, type the following command to list references to objects:  \n  \n     **!gcroot**  \n  \n     `-or-`  \n  \n-   To determine the references for a specific object, include the address:  \n  \n     **!gcroot 1c37b2ac**  \n  \n     Roots found on stacks may be false positives. For more information, use the command `!help gcroot`.  \n  \n    ```  \n    ebx:Root:19011c5c(System.Windows.Forms.Application+ThreadContext)->  \n    19010b78(DemoApp.FormDemoApp)->  \n    19011158(System.Windows.Forms.PropertyStore)->  \n    … [omitted]  \n    1c3745ec(System.Data.DataTable)->  \n    1c3747a8(System.Data.DataColumnCollection)->  \n    1c3747f8(System.Collections.Hashtable)->  \n    1c376590(System.Collections.Hashtable+bucket[])->  \n    1c376c98(System.Data.DataColumn)->  \n    1c37b270(System.Data.Common.DoubleStorage)->  \n    1c37b2ac(System.Double[])  \n    Scan Thread 0 OSTHread 99c  \n    Scan Thread 6 OSTHread 484  \n    ```  \n  \n     The **gcroot** command can take a long time to finish. Any object that is not reclaimed by garbage collection is a live object. This means that some root is directly or indirectly holding onto the object, so **gcroot** should return path information to the object. You should examine the graphs returned and see why these objects are still referenced.  \n  \n<a name=\"Induce\"></a>   \n##### To determine whether a finalizer has been run  \n  \n-   Run a test program that contains the following code:  \n  \n    ```  \n    GC.Collect();  \n    GC.WaitForPendingFinalizers();  \n    GC.Collect();  \n    ```  \n  \n     If the test resolves the problem, this means that the garbage collector was not reclaiming objects, because the finalizers for those objects had been suspended. The <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=fullName> method enables the finalizers to complete their tasks, and fixes the problem.  \n  \n<a name=\"Finalize\"></a>   \n##### To determine whether there are objects waiting to be finalized  \n  \n1.  In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:  \n  \n     **!finalizequeue**  \n  \n     Look at the number of objects that are ready for finalization. If the number is high, you must examine why these finalizers cannot progress at all or cannot progress fast enough.  \n  \n2.  To get an output of threads, type the following command:  \n  \n     **threads -special**  \n  \n     This command provides output such as the following.  \n  \n    ```  \n       OSID     Special thread type  \n    2    cd0    DbgHelper   \n    3    c18    Finalizer   \n    4    df0    GC SuspendEE   \n    ```  \n  \n     The finalizer thread indicates which finalizer, if any, is currently being run. When a finalizer thread is not running any finalizers, it is waiting for an event to tell it to do its work. Most of the time you will see the finalizer thread in this state because it runs at THREAD_HIGHEST_PRIORITY and is supposed to finish running finalizers, if any, very quickly.  \n  \n<a name=\"Fragmented\"></a>   \n##### To determine the amount of free space in the managed heap  \n  \n-   In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:  \n  \n     **!dumpheap -type Free -stat**  \n  \n     This command displays the total size of all the free objects on the managed heap, as shown in the following example.  \n  \n    ```  \n    total 230 objects  \n    Statistics:  \n          MT    Count    TotalSize Class Name  \n    00152b18      230     40958584      Free  \n    Total 230 objects  \n    ```  \n  \n-   To determine the free space in generation 0, type the following command for memory consumption information by generation:  \n  \n     **!eeheap -gc**  \n  \n     This command displays output similar to the following. The last line shows the ephemeral segment.  \n  \n    ```  \n    Heap 0 (0015ad08)  \n    generation 0 starts at 0x49521f8c  \n    generation 1 starts at 0x494d7f64  \n    generation 2 starts at 0x007f0038  \n    ephemeral segment allocation context: none  \n    segment  begin     allocated  size  \n    00178250 7a80d84c  7a82f1cc   0x00021980(137600)  \n    00161918 78c50e40  78c7056c   0x0001f72c(128812)  \n    007f0000 007f0038  047eed28   0x03ffecf0(67103984)  \n    3a120000 3a120038  3a3e84f8   0x002c84c0(2917568)  \n    46120000 46120038  49e05d04   0x03ce5ccc(63855820)  \n    ```  \n  \n-   Calculate the space used by generation 0:  \n  \n     **? 49e05d04-0x49521f8c**  \n  \n     The result is as follows. Generation 0 is approximately 9 MB.  \n  \n    ```  \n    Evaluate expression: 9321848 = 008e3d78  \n    ```  \n  \n-   The following command dumps the free space within the generation 0 range:  \n  \n     **!dumpheap -type Free -stat 0x49521f8c 49e05d04**  \n  \n     The result is as follows.  \n  \n    ```  \n    ------------------------------  \n    Heap 0  \n    total 409 objects  \n    ------------------------------  \n    Heap 1  \n    total 0 objects  \n    ------------------------------  \n    Heap 2  \n    total 0 objects  \n    ------------------------------  \n    Heap 3  \n    total 0 objects  \n    ------------------------------  \n    total 409 objects  \n    Statistics:  \n          MT    Count TotalSize Class Name  \n    0015a498      409   7296540      Free  \n    Total 409 objects  \n    ```  \n  \n     This output shows that the generation 0 portion of the heap is using 9 MB of space for objects and has 7 MB free. This analysis shows the extent to which generation 0 contributes to fragmentation. This amount of heap usage should be discounted from the total amount as the cause of fragmentation by long-term objects.  \n  \n<a name=\"Pinned\"></a>   \n##### To determine the number of pinned objects  \n  \n-   In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:  \n  \n     **!gchandles**  \n  \n     The statistics displayed includes the number of pinned handles, as the following example shows.  \n  \n    ```  \n    GC Handle Statistics:  \n    Strong Handles:      29  \n    Pinned Handles:      10  \n    ```  \n  \n<a name=\"TimeInGC\"></a>   \n##### To determine the length of time in a garbage collection  \n  \n-   Examine the `% Time in GC` memory performance counter.  \n  \n     The value is calculated by using a sample interval time. Because the counters are updated at the end of each garbage collection, the current sample will have the same value as the previous sample if no collections occurred during the interval.  \n  \n     Collection time is obtained by multiplying the sample interval time with the percentage value.  \n  \n     The following data shows four sampling intervals of two seconds, for an 8-second study. The `Gen0`, `Gen1`, and `Gen2` columns show the number of garbage collections that occurred during that interval for that generation.  \n  \n    ```  \n    Interval    Gen0    Gen1    Gen2    % Time in GC  \n           1       9       3       1              10  \n           2      10       3       1               1  \n           3      11       3       1               3  \n           4      11       3       1               3  \n    ```  \n  \n     This information does not show when the garbage collection occurred, but you can determine the number of garbage collections that occurred in an interval of time. Assuming the worst case, the tenth generation 0 garbage collection finished at the start of the second interval, and the eleventh generation 0 garbage collection finished at the end of the fifth interval. The time between the end of the tenth and the end of the eleventh garbage collection is about 2 seconds, and the performance counter shows 3%, so the duration of the eleventh generation 0 garbage collection was (2 seconds * 3% = 60ms).  \n  \n     In this example, there are 5 periods.  \n  \n    ```  \n    Interval    Gen0    Gen1    Gen2     % Time in GC  \n           1       9       3       1                3  \n           2      10       3       1                1  \n           3      11       4       2                1  \n           4      11       4       2                1  \n           5      11       4       2               20  \n    ```  \n  \n     The second generation 2 garbage collection started during the third interval and finished at the fifth interval. Assuming the worst case, the last garbage collection was for a generation 0 collection that finished at the start of the second interval, and the generation 2 garbage collection finished at the end of the fifth interval. Therefore, the time between the end of the generation 0 garbage collection and the end of the generation 2 garbage collection is 4 seconds. Because the `% Time in GC` counter is 20%, the maximum amount of time the generation 2 garbage collection could have taken is (4 seconds * 20% = 800ms).  \n  \n-   Alternatively, you can determine the length of a garbage collection by using [garbage collection ETW events](../../../docs/framework/performance/garbage-collection-etw-events.md), and analyze the information to determine the duration of garbage collection.  \n  \n     For example, the following data shows an event sequence that occurred during a non-concurrent garbage collection.  \n  \n    ```  \n    Timestamp    Event name  \n    513052        GCSuspendEEBegin_V1  \n    513078        GCSuspendEEEnd  \n    513090        GCStart_V1  \n    517890        GCEnd_V1  \n    517894        GCHeapStats  \n    517897        GCRestartEEBegin  \n    517918        GCRestartEEEnd  \n    ```  \n  \n     Suspending the managed thread took 26us (`GCSuspendEEEnd` – `GCSuspendEEBegin_V1`).  \n  \n     The actual garbage collection took 4.8ms (`GCEnd_V1` – `GCStart_V1`).  \n  \n     Resuming the managed threads took 21us (`GCRestartEEEnd` – `GCRestartEEBegin`).  \n  \n     The following output provides an example for background garbage collection, and includes the process, thread, and event fields. (Not all data is shown.)  \n  \n    ```  \n    timestamp(us)    event name            process    thread    event field  \n    42504385        GCSuspendEEBegin_V1    Test.exe    4372             1  \n    42504648        GCSuspendEEEnd         Test.exe    4372          \n    42504816        GCStart_V1             Test.exe    4372        102019  \n    42504907        GCStart_V1             Test.exe    4372        102020  \n    42514170        GCEnd_V1               Test.exe    4372          \n    42514204        GCHeapStats            Test.exe    4372        102020  \n    42832052        GCRestartEEBegin       Test.exe    4372          \n    42832136        GCRestartEEEnd         Test.exe    4372          \n    63685394        GCSuspendEEBegin_V1    Test.exe    4744             6  \n    63686347        GCSuspendEEEnd         Test.exe    4744          \n    63784294        GCRestartEEBegin       Test.exe    4744          \n    63784407        GCRestartEEEnd         Test.exe    4744          \n    89931423        GCEnd_V1               Test.exe    4372        102019  \n    89931464        GCHeapStats            Test.exe    4372          \n    ```  \n  \n     The `GCStart_V1` event at 42504816 indicates that this is a background garbage collection, because the last field is `1`. This becomes garbage collection No. 102019.  \n  \n     The `GCStart` event occurs because there is a need for an ephemeral garbage collection before you start a background garbage collection. This becomes garbage collection No. 102020.  \n  \n     At 42514170, garbage collection No. 102020 finishes. The managed threads are restarted at this point. This is completed on thread 4372, which triggered this background garbage collection.  \n  \n     On thread 4744, a suspension occurs. This is the only time at which the background garbage collection has to suspend managed threads. This duration is approximately 99ms ((63784407-63685394)/1000).  \n  \n     The `GCEnd` event for the background garbage collection is at 89931423. This means that the background garbage collection lasted for about 47seconds ((89931423-42504816)/1000).  \n  \n     While the managed threads are running, you can see any number of ephemeral garbage collections occurring.  \n  \n<a name=\"Triggered\"></a>   \n##### To determine what triggered a garbage collection  \n  \n-   In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command to show all the threads with their call stacks:  \n  \n     **~\\*kb**  \n  \n     This command displays output similar to the following.  \n  \n    ```  \n    0012f3b0 79ff0bf8 mscorwks!WKS::GCHeap::GarbageCollect   \n    0012f454 30002894 mscorwks!GCInterface::CollectGeneration+0xa4  \n    0012f490 79fa22bd fragment_ni!request.Main(System.String[])+0x48  \n    ```  \n  \n     If the garbage collection was caused by a low memory notification from the operating system, the call stack is similar, except that the thread is the finalizer thread. The finalizer thread gets an asynchronous low memory notification and induces the garbage collection.  \n  \n     If the garbage collection was caused by memory allocation, the stack appears as follows:  \n  \n    ```  \n    0012f230 7a07c551 mscorwks!WKS::GCHeap::GarbageCollectGeneration  \n    0012f2b8 7a07cba8 mscorwks!WKS::gc_heap::try_allocate_more_space+0x1a1  \n    0012f2d4 7a07cefb mscorwks!WKS::gc_heap::allocate_more_space+0x18  \n    0012f2f4 7a02a51b mscorwks!WKS::GCHeap::Alloc+0x4b  \n    0012f310 7a02ae4c mscorwks!Alloc+0x60  \n    0012f364 7a030e46 mscorwks!FastAllocatePrimitiveArray+0xbd  \n    0012f424 300027f4 mscorwks!JIT_NewArr1+0x148  \n    000af70f 3000299f fragment_ni!request..ctor(Int32, Single)+0x20c  \n    0000002a 79fa22bd fragment_ni!request.Main(System.String[])+0x153  \n    ```  \n  \n     A just-in-time helper (`JIT_New*`) eventually calls `GCHeap::GarbageCollectGeneration`. If you determine that generation 2 garbage collections are caused by allocations, you must determine which objects are collected by a generation 2 garbage collection and how to avoid them. That is, you want to determine the difference between the start and the end of a generation 2 garbage collection, and the objects that caused the generation 2 collection.  \n  \n     For example, type the following command in the debugger to show the beginning of a generation 2 collection:  \n  \n     **!dumpheap –stat**  \n  \n     Example output (abridged to show the objects that use the most space):  \n  \n    ```  \n    79124228    31857      9862328 System.Object[]  \n    035f0384    25668     11601936 Toolkit.TlkPosition  \n    00155f80    21248     12256296      Free  \n    79103b6c   297003     13068132 System.Threading.ReaderWriterLock  \n    7a747ad4   708732     14174640 System.Collections.Specialized.HybridDictionary  \n    7a747c78   786498     15729960 System.Collections.Specialized.ListDictionary+DictionaryNode  \n    7a747bac   700298     19608344 System.Collections.Specialized.ListDictionary  \n    035f0ee4    89192     38887712 Toolkit.TlkOrder  \n    00fcae40     6193     44911636 WaveBasedStrategy.Tick_Snap[]  \n    7912c444    91616     71887080 System.Double[]  \n    791242ec    32451     82462728 System.Collections.Hashtable+bucket[]  \n    790fa3e0  2459154    112128436 System.String  \n    Total 6471774 objects  \n    ```  \n  \n     Repeat the command at the end of generation 2:  \n  \n     **!dumpheap –stat**  \n  \n     Example output (abridged to show the objects that use the most space):  \n  \n    ```  \n    79124228    26648      9314256 System.Object[]  \n    035f0384    25668     11601936 Toolkit.TlkPosition  \n    79103b6c   296770     13057880 System.Threading.ReaderWriterLock  \n    7a747ad4   708730     14174600 System.Collections.Specialized.HybridDictionary  \n    7a747c78   786497     15729940 System.Collections.Specialized.ListDictionary+DictionaryNode  \n    7a747bac   700298     19608344 System.Collections.Specialized.ListDictionary  \n    00155f80    13806     34007212      Free  \n    035f0ee4    89187     38885532 Toolkit.TlkOrder  \n    00fcae40     6193     44911636 WaveBasedStrategy.Tick_Snap[]  \n    791242ec    32370     82359768 System.Collections.Hashtable+bucket[]  \n    790fa3e0  2440020    111341808 System.String  \n    Total 6417525 objects  \n    ```  \n  \n     The `double[]` objects disappeared from the end of the output, which means that they were collected. These objects account for approximately 70 MB. The remaining objects did not change much. Therefore, these `double[]` objects were the reason why this generation 2 garbage collection occurred. Your next step is to determine why the `double[]` objects are there and why they died. You can ask the code developer where these objects came from, or you can use the **gcroot** command.  \n  \n<a name=\"HighCPU\"></a>   \n##### To determine whether high CPU usage is caused by garbage collection  \n  \n-   Correlate the `% Time in GC` memory performance counter value with the process time.  \n  \n     If the `% Time in GC` value spikes at the same time as process time, garbage collection is causing a high CPU usage. Otherwise, profile the application to find where the high usage is occurring.  \n  \n## See Also  \n [Garbage Collection](../../../docs/standard/garbage-collection/index.md)","nodes":[{"pos":[12,63],"content":"Garbage Collection and Performance | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Garbage Collection and Performance | Microsoft Docs","pos":[0,51]}]},{"pos":[457,491],"content":"Garbage Collection and Performance","linkify":"Garbage Collection and Performance","nodes":[{"content":"Garbage Collection and Performance","pos":[0,34]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> This topic describes issues related to garbage collection and memory usage.","pos":[492,586],"source":"<a name=\"top\"></a> This topic describes issues related to garbage collection and memory usage."},{"content":"It addresses issues that pertain to the managed heap and explains how to minimize the effect of garbage collection on your applications.","pos":[587,723]},{"content":"Each issue has links to procedures that you can use to investigate problems.","pos":[724,800]},{"content":"This topic contains the following sections:","pos":[807,850]},{"pos":[860,917],"content":"<bpt id=\"p1\">[</bpt>Performance Analysis Tools<ept id=\"p1\">](#performance_analysis_tools)</ept>","source":"[Performance Analysis Tools](#performance_analysis_tools)"},{"pos":[927,1000],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Performance Issues<ept id=\"p1\">](#troubleshooting_performance_issues)</ept>","source":"[Troubleshooting Performance Issues](#troubleshooting_performance_issues)"},{"pos":[1010,1067],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Guidelines<ept id=\"p1\">](#troubleshooting_guidelines)</ept>","source":"[Troubleshooting Guidelines](#troubleshooting_guidelines)"},{"pos":[1077,1138],"content":"<bpt id=\"p1\">[</bpt>Performance Check Procedures<ept id=\"p1\">](#performance_check_procedures)</ept>","source":"[Performance Check Procedures](#performance_check_procedures)"},{"pos":[1192,1218],"content":"Performance Analysis Tools","linkify":"Performance Analysis Tools","nodes":[{"content":"Performance Analysis Tools","pos":[0,26]}]},{"content":"The following sections describe the tools that are available for investigating memory usage and garbage collection issues.","pos":[1222,1344]},{"content":"The <bpt id=\"p1\">[</bpt>procedures<ept id=\"p1\">](#performance_check_procedures)</ept> provided later in this topic refer to these tools.","pos":[1345,1443],"source":" The [procedures](#performance_check_procedures) provided later in this topic refer to these tools."},{"pos":[1485,1512],"content":"Memory Performance Counters","linkify":"Memory Performance Counters","nodes":[{"content":"Memory Performance Counters","pos":[0,27]}]},{"content":"You can use performance counters to gather performance data.","pos":[1516,1576]},{"content":"For instructions, see <bpt id=\"p1\">[</bpt>Runtime Profiling<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/runtime-profiling.md)</ept>.","pos":[1577,1685],"source":" For instructions, see [Runtime Profiling](../../../docs/framework/debug-trace-profile/runtime-profiling.md)."},{"content":"The .NET CLR Memory category of performance counters, as described in <bpt id=\"p1\">[</bpt>Performance Counters in the .NET Framework<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/performance-counters.md)</ept>, provides information about the garbage collector.","pos":[1686,1920],"source":" The .NET CLR Memory category of performance counters, as described in [Performance Counters in the .NET Framework](../../../docs/framework/debug-trace-profile/performance-counters.md), provides information about the garbage collector."},{"pos":[1952,1970],"content":"Debugging with SOS","linkify":"Debugging with SOS","nodes":[{"content":"Debugging with SOS","pos":[0,18]}]},{"pos":[1974,2104],"content":"You can use the <bpt id=\"p1\">[</bpt>Windows Debugger (WinDbg)<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=186482)</ept> to inspect objects on the managed heap.","source":"You can use the [Windows Debugger (WinDbg)](http://go.microsoft.com/fwlink/?LinkId=186482) to inspect objects on the managed heap."},{"pos":[2111,2257],"content":"To install WinDbg, install Debugging Tools for Windows from the <bpt id=\"p1\">[</bpt>WDK and Developer Tools Web site<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=103787)</ept>.","source":"To install WinDbg, install Debugging Tools for Windows from the [WDK and Developer Tools Web site](http://go.microsoft.com/fwlink/?LinkID=103787)."},{"pos":[2289,2318],"content":"Garbage Collection ETW Events","linkify":"Garbage Collection ETW Events","nodes":[{"content":"Garbage Collection ETW Events","pos":[0,29]}]},{"content":"Event tracing for Windows (ETW) is a tracing system that supplements the profiling and debugging support provided by the .NET Framework.","pos":[2322,2458]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, <bpt id=\"p1\">[</bpt>garbage collection ETW events<ept id=\"p1\">](../../../docs/framework/performance/garbage-collection-etw-events.md)</ept> capture useful information for analyzing the managed heap from a statistical point of view.","pos":[2459,2734],"source":" Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], [garbage collection ETW events](../../../docs/framework/performance/garbage-collection-etw-events.md) capture useful information for analyzing the managed heap from a statistical point of view."},{"content":"For example, the <ph id=\"ph1\">`GCStart_V1`</ph> event, which is raised when a garbage collection is about to occur, provides the following information:","pos":[2735,2868],"source":" For example, the `GCStart_V1` event, which is raised when a garbage collection is about to occur, provides the following information:"},{"content":"Which generation of objects is being collected.","pos":[2878,2925]},{"content":"What triggered the garbage collection.","pos":[2935,2973]},{"content":"Type of garbage collection (concurrent or not concurrent).","pos":[2983,3041]},{"content":"ETW event logging is efficient and will not mask any performance problems associated with garbage collection.","pos":[3048,3157]},{"content":"A process can provide its own events in conjunction with ETW events.","pos":[3158,3226]},{"content":"When logged, both the application's events and the garbage collection events can be correlated to determine how and when heap problems occur.","pos":[3227,3368]},{"content":"For example, a server application could provide events at the start and end of a client request.","pos":[3369,3465]},{"pos":[3507,3524],"content":"The Profiling API","linkify":"The Profiling API","nodes":[{"content":"The Profiling API","pos":[0,17]}]},{"content":"The common language runtime (CLR) profiling interfaces provide detailed information about the objects that were affected during garbage collection.","pos":[3528,3675]},{"content":"A profiler can be notified when a garbage collection starts and ends.","pos":[3676,3745]},{"content":"It can provide reports about the objects on the managed heap, including an identification of objects in each generation.","pos":[3746,3866]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Profiling Overview<ept id=\"p1\">](../../../docs/framework/unmanaged-api/profiling/profiling-overview.md)</ept>.","pos":[3867,3985],"source":" For more information, see [Profiling Overview](../../../docs/framework/unmanaged-api/profiling/profiling-overview.md)."},{"content":"Profilers can provide comprehensive information.","pos":[3992,4040]},{"content":"However, complex profilers can potentially modify an application's behavior.","pos":[4041,4117]},{"pos":[4127,4165],"content":"Application Domain Resource Monitoring","linkify":"Application Domain Resource Monitoring","nodes":[{"content":"Application Domain Resource Monitoring","pos":[0,38]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.","pos":[4169,4366],"source":"Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Application Domain Resource Monitoring<ept id=\"p1\">](../../../docs/standard/garbage-collection/app-domain-resource-monitoring.md)</ept>.","pos":[4367,4511],"source":" For more information, see [Application Domain Resource Monitoring](../../../docs/standard/garbage-collection/app-domain-resource-monitoring.md)."},{"pos":[4518,4537],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[4599,4633],"content":"Troubleshooting Performance Issues","linkify":"Troubleshooting Performance Issues","nodes":[{"content":"Troubleshooting Performance Issues","pos":[0,34]}]},{"content":"The first step is to <bpt id=\"p1\">[</bpt>determine whether the issue is actually garbage collection<ept id=\"p1\">](#IsGC)</ept>.","pos":[4637,4726],"source":"The first step is to [determine whether the issue is actually garbage collection](#IsGC)."},{"content":"If you determine that it is, select from the following list to troubleshoot the problem.","pos":[4727,4815]},{"pos":[4825,4875],"content":"<bpt id=\"p1\">[</bpt>An out-of-memory exception is thrown<ept id=\"p1\">](#Issue_OOM)</ept>","source":"[An out-of-memory exception is thrown](#Issue_OOM)"},{"pos":[4885,4941],"content":"<bpt id=\"p1\">[</bpt>The process uses too much memory<ept id=\"p1\">](#Issue_TooMuchMemory)</ept>","source":"[The process uses too much memory](#Issue_TooMuchMemory)"},{"pos":[4951,5033],"content":"<bpt id=\"p1\">[</bpt>The garbage collector does not reclaim objects fast enough<ept id=\"p1\">](#Issue_NotFastEnough)</ept>","source":"[The garbage collector does not reclaim objects fast enough](#Issue_NotFastEnough)"},{"pos":[5043,5101],"content":"<bpt id=\"p1\">[</bpt>The managed heap is too fragmented<ept id=\"p1\">](#Issue_Fragmentation)</ept>","source":"[The managed heap is too fragmented](#Issue_Fragmentation)"},{"pos":[5111,5170],"content":"<bpt id=\"p1\">[</bpt>Garbage collection pauses are too long<ept id=\"p1\">](#Issue_LongPauses)</ept>","source":"[Garbage collection pauses are too long](#Issue_LongPauses)"},{"pos":[5180,5218],"content":"<bpt id=\"p1\">[</bpt>Generation 0 is too big<ept id=\"p1\">](#Issue_Gen0)</ept>","source":"[Generation 0 is too big](#Issue_Gen0)"},{"pos":[5228,5295],"content":"<bpt id=\"p1\">[</bpt>CPU usage during a garbage collection is too high<ept id=\"p1\">](#Issue_HighCPU)</ept>","source":"[CPU usage during a garbage collection is too high](#Issue_HighCPU)"},{"pos":[5333,5376],"content":"Issue: An Out-of-Memory Exception Is Thrown","linkify":"Issue: An Out-of-Memory Exception Is Thrown","nodes":[{"content":"Issue: An Out-of-Memory Exception Is Thrown","pos":[0,43]}]},{"content":"There are two legitimate cases for a managed <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> to be thrown:","pos":[5380,5473],"source":"There are two legitimate cases for a managed <xref:System.OutOfMemoryException> to be thrown:"},{"content":"Running out of virtual memory.","pos":[5483,5513]},{"content":"The garbage collector allocates memory from the system in segments of a pre-determined size.","pos":[5524,5616]},{"content":"If an allocation requires an additional segment, but there is no contiguous free block left in the process's virtual memory space, the allocation for the managed heap will fail.","pos":[5617,5794]},{"content":"Not having enough physical memory to allocate.","pos":[5804,5850]},{"content":"Performance checks","pos":[5857,5875]},{"content":"<bpt id=\"p1\">[</bpt>Determine whether the out-of-memory exception is managed.<ept id=\"p1\">](#OOMIsManaged)</ept>","pos":[5909,5983],"source":"[Determine whether the out-of-memory exception is managed.](#OOMIsManaged)"},{"content":"<bpt id=\"p1\">[</bpt>Determine how much virtual memory can be reserved.<ept id=\"p1\">](#GetVM)</ept>","pos":[5996,6056],"source":"[Determine how much virtual memory can be reserved.](#GetVM)"},{"content":"<bpt id=\"p1\">[</bpt>Determine whether there is enough physical memory.<ept id=\"p1\">](#Physical)</ept>","pos":[6069,6132],"source":"[Determine whether there is enough physical memory.](#Physical)"},{"content":"If you determine that the exception is not legitimate, contact Microsoft Customer Service and Support with the following information:","pos":[6140,6273]},{"content":"The stack with the managed out-of-memory exception.","pos":[6283,6334]},{"content":"Full memory dump.","pos":[6344,6361]},{"content":"Data that proves that it is not a legitimate out-of-memory exception, including data that shows that virtual or physical memory is not an issue.","pos":[6371,6515]},{"pos":[6563,6602],"content":"Issue: The Process Uses Too Much Memory","linkify":"Issue: The Process Uses Too Much Memory","nodes":[{"content":"Issue: The Process Uses Too Much Memory","pos":[0,39]}]},{"content":"A common assumption is that the memory usage display on the <bpt id=\"p1\">**</bpt>Performance<ept id=\"p1\">**</ept> tab of Windows Task Manager can indicate when too much memory is being used.","pos":[6606,6758],"source":"A common assumption is that the memory usage display on the **Performance** tab of Windows Task Manager can indicate when too much memory is being used."},{"content":"However, that display pertains to the working set; it does not provide information about virtual memory usage.","pos":[6759,6869]},{"content":"If you determine that the issue is caused by the managed heap, you must measure the managed heap over time to determine any patterns.","pos":[6876,7009]},{"content":"If you determine that the problem is not caused by the managed heap, you must use native debugging.","pos":[7016,7115]},{"content":"Performance checks","pos":[7122,7140]},{"content":"<bpt id=\"p1\">[</bpt>Determine how much virtual memory can be reserved.<ept id=\"p1\">](#GetVM)</ept>","pos":[7174,7234],"source":"[Determine how much virtual memory can be reserved.](#GetVM)"},{"content":"<bpt id=\"p1\">[</bpt>Determine how much memory the managed heap is committing.<ept id=\"p1\">](#ManagedHeapCommit)</ept>","pos":[7247,7326],"source":"[Determine how much memory the managed heap is committing.](#ManagedHeapCommit)"},{"content":"<bpt id=\"p1\">[</bpt>Determine how much memory the managed heap reserves.<ept id=\"p1\">](#ManagedHeapReserve)</ept>","pos":[7339,7414],"source":"[Determine how much memory the managed heap reserves.](#ManagedHeapReserve)"},{"content":"<bpt id=\"p1\">[</bpt>Determine large objects in generation 2.<ept id=\"p1\">](#ExamineGen2)</ept>","pos":[7427,7483],"source":"[Determine large objects in generation 2.](#ExamineGen2)"},{"content":"<bpt id=\"p1\">[</bpt>Determine references to objects.<ept id=\"p1\">](#ObjRef)</ept>","pos":[7496,7539],"source":"[Determine references to objects.](#ObjRef)"},{"pos":[7588,7653],"content":"Issue: The Garbage Collector Does Not Reclaim Objects Fast Enough","linkify":"Issue: The Garbage Collector Does Not Reclaim Objects Fast Enough","nodes":[{"content":"Issue: The Garbage Collector Does Not Reclaim Objects Fast Enough","pos":[0,65]}]},{"content":"When it appears as if objects are not being reclaimed as expected for garbage collection, you must determine if there are any strong references to those objects.","pos":[7657,7818]},{"content":"You may also encounter this issue if there has been no garbage collection for the generation that contains a dead object, which indicates that the finalizer for the dead object has not been run.","pos":[7825,8019]},{"content":"For example, this is possible when you are running a single-threaded apartment (STA) application and the thread that services the finalizer queue cannot call into it.","pos":[8020,8186]},{"content":"Performance checks","pos":[8193,8211]},{"content":"<bpt id=\"p1\">[</bpt>Check references to objects.<ept id=\"p1\">](#ObjRef)</ept>","pos":[8245,8284],"source":"[Check references to objects.](#ObjRef)"},{"content":"<bpt id=\"p1\">[</bpt>Determine whether a finalizer has been run.<ept id=\"p1\">](#Induce)</ept>","pos":[8297,8351],"source":"[Determine whether a finalizer has been run.](#Induce)"},{"content":"<bpt id=\"p1\">[</bpt>Determine whether there are objects waiting to be finalized.<ept id=\"p1\">](#Finalize)</ept>","pos":[8364,8437],"source":"[Determine whether there are objects waiting to be finalized.](#Finalize)"},{"pos":[8486,8527],"content":"Issue: The Managed Heap Is Too fragmented","linkify":"Issue: The Managed Heap Is Too fragmented","nodes":[{"content":"Issue: The Managed Heap Is Too fragmented","pos":[0,41]}]},{"content":"The fragmentation level is calculated as the ratio of free space over the total allocated memory for the generation.","pos":[8531,8647]},{"content":"For generation 2, an acceptable level of fragmentation is no more than 20%.","pos":[8648,8723]},{"content":"Because generation 2 can get very big, the ratio of fragmentation is more important than the absolute value.","pos":[8724,8832]},{"content":"Having lots of free space in generation 0 is not a problem because this is the generation where new objects are allocated.","pos":[8839,8961]},{"content":"Fragmentation always occurs in the large object heap because it is not compacted.","pos":[8968,9049]},{"content":"Free objects that are adjacent are naturally collapsed into a single space to satisfy large object allocation requests.","pos":[9050,9169]},{"content":"Fragmentation can become a problem in generation 1 and generation 2.","pos":[9176,9244]},{"content":"If these generations have a large amount of free space after a garbage collection, an application's object usage may need modification, and you should consider re-evaluating the lifetime of long-term objects.","pos":[9245,9453]},{"content":"Excessive pinning of objects can increase fragmentation.","pos":[9460,9516]},{"content":"If fragmentation is high, too many objects could be pinned.","pos":[9517,9576]},{"content":"If fragmentation of virtual memory is preventing the garbage collector from adding segments, the causes could be one of the following:","pos":[9583,9717]},{"content":"Frequent loading and unloading of many small assemblies.","pos":[9727,9783]},{"content":"Holding too many references to COM objects when interoperating with unmanaged code.","pos":[9793,9876]},{"content":"Creation of large transient objects, which causes the large object heap to allocate and free heap segments frequently.","pos":[9886,10004]},{"content":"When hosting the CLR, an application can request that the garbage collector retain its segments.","pos":[10015,10111]},{"content":"This reduces the frequency of segment allocations.","pos":[10112,10162]},{"content":"This is accomplished by using the STARTUP_HOARD_GC_VM flag in the <bpt id=\"p1\">[</bpt>STARTUP_FLAGS Enumeration<ept id=\"p1\">](../../../docs/framework/unmanaged-api/hosting/startup-flags-enumeration.md)</ept>.","pos":[10163,10333],"source":" This is accomplished by using the STARTUP_HOARD_GC_VM flag in the [STARTUP_FLAGS Enumeration](../../../docs/framework/unmanaged-api/hosting/startup-flags-enumeration.md)."},{"content":"Performance checks","pos":[10340,10358]},{"content":"<bpt id=\"p1\">[</bpt>Determine the amount of free space in the managed heap.<ept id=\"p1\">](#Fragmented)</ept>","pos":[10392,10462],"source":"[Determine the amount of free space in the managed heap.](#Fragmented)"},{"content":"<bpt id=\"p1\">[</bpt>Determine the number of pinned objects.<ept id=\"p1\">](#Pinned)</ept>","pos":[10475,10525],"source":"[Determine the number of pinned objects.](#Pinned)"},{"content":"If you think that there is no legitimate cause for the fragmentation, contact Microsoft Customer Service and Support.","pos":[10533,10650]},{"pos":[10695,10740],"content":"Issue: Garbage Collection Pauses Are Too Long","linkify":"Issue: Garbage Collection Pauses Are Too Long","nodes":[{"content":"Issue: Garbage Collection Pauses Are Too Long","pos":[0,45]}]},{"content":"Garbage collection operates in soft real time, so an application must be able to tolerate some pauses.","pos":[10744,10846]},{"content":"A criterion for soft real time is that 95% of the operations must finish on time.","pos":[10847,10928]},{"content":"In concurrent garbage collection, managed threads are allowed to run during a collection, which means that pauses are very minimal.","pos":[10935,11066]},{"content":"Ephemeral garbage collections (generations 0 and 1) last only a few milliseconds, so decreasing pauses is usually not feasible.","pos":[11073,11200]},{"content":"However, you can decrease the pauses in generation 2 collections by changing the pattern of allocation requests by an application.","pos":[11201,11331]},{"content":"Another, more accurate, method is to use <bpt id=\"p1\">[</bpt>garbage collection ETW events<ept id=\"p1\">](../../../docs/framework/performance/garbage-collection-etw-events.md)</ept>.","pos":[11338,11481],"source":"Another, more accurate, method is to use [garbage collection ETW events](../../../docs/framework/performance/garbage-collection-etw-events.md)."},{"content":"You can find the timings for collections by adding the time stamp differences for a sequence of events.","pos":[11482,11585]},{"content":"The whole collection sequence includes suspension of the execution engine, the garbage collection itself, and the resumption of the execution engine.","pos":[11586,11735]},{"pos":[11742,12008],"content":"You can use <bpt id=\"p1\">[</bpt>Garbage Collection Notifications<ept id=\"p1\">](../../../docs/standard/garbage-collection/notifications.md)</ept> to determine whether a server is about to have a generation 2 collection, and whether rerouting requests to another server could ease any problems with pauses.","source":"You can use [Garbage Collection Notifications](../../../docs/standard/garbage-collection/notifications.md) to determine whether a server is about to have a generation 2 collection, and whether rerouting requests to another server could ease any problems with pauses."},{"content":"Performance checks","pos":[12015,12033]},{"content":"<bpt id=\"p1\">[</bpt>Determine the length of time in a garbage collection.<ept id=\"p1\">](#TimeInGC)</ept>","pos":[12067,12133],"source":"[Determine the length of time in a garbage collection.](#TimeInGC)"},{"content":"<bpt id=\"p1\">[</bpt>Determine what caused a garbage collection.<ept id=\"p1\">](#Triggered)</ept>","pos":[12146,12203],"source":"[Determine what caused a garbage collection.](#Triggered)"},{"pos":[12243,12273],"content":"Issue: Generation 0 Is Too Big","linkify":"Issue: Generation 0 Is Too Big","nodes":[{"content":"Issue: Generation 0 Is Too Big","pos":[0,30]}]},{"content":"Generation 0 is likely to have a larger number of objects on a 64-bit system, especially when you use server garbage collection instead of workstation garbage collection.","pos":[12277,12447]},{"content":"This is because the threshold to trigger a generation 0 garbage collection is higher in these environments, and generation 0 collections can get much bigger.","pos":[12448,12605]},{"content":"Performance is improved when an application allocates more memory before a garbage collection is triggered.","pos":[12606,12713]},{"pos":[12755,12811],"content":"Issue: CPU Usage During a Garbage Collection Is Too High","linkify":"Issue: CPU Usage During a Garbage Collection Is Too High","nodes":[{"content":"Issue: CPU Usage During a Garbage Collection Is Too High","pos":[0,56]}]},{"content":"CPU usage will be high during a garbage collection.","pos":[12815,12866]},{"content":"If a significant amount of process time is spent in a garbage collection, the number of collections is too frequent or the collection is lasting too long.","pos":[12867,13021]},{"content":"An increased allocation rate of objects on the managed heap causes garbage collection to occur more frequently.","pos":[13022,13133]},{"content":"Decreasing the allocation rate reduces the frequency of garbage collections.","pos":[13134,13210]},{"content":"You can monitor allocation rates by using the <ph id=\"ph1\">`Allocated Bytes/second`</ph> performance counter.","pos":[13217,13308],"source":"You can monitor allocation rates by using the `Allocated Bytes/second` performance counter."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Performance Counters in the .NET Framework<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/performance-counters.md)</ept>.","pos":[13309,13449],"source":" For more information, see [Performance Counters in the .NET Framework](../../../docs/framework/debug-trace-profile/performance-counters.md)."},{"content":"The duration of a collection is primarily a factor of the number of objects that survive after allocation.","pos":[13456,13562]},{"content":"The garbage collector must go through a large amount of memory if many objects remain to be collected.","pos":[13563,13665]},{"content":"The work to compact the survivors is time-consuming.","pos":[13666,13718]},{"content":"To determine how many objects were handled during a collection, set a breakpoint in the debugger at the end of a garbage collection for a specified generation.","pos":[13719,13878]},{"content":"Performance checks","pos":[13885,13903]},{"content":"<bpt id=\"p1\">[</bpt>Determine if high CPU usage is caused by garbage collection.<ept id=\"p1\">](#HighCPU)</ept>","pos":[13937,14009],"source":"[Determine if high CPU usage is caused by garbage collection.](#HighCPU)"},{"content":"<bpt id=\"p1\">[</bpt>Set a breakpoint at the end of garbage collection.<ept id=\"p1\">](#GenBreak)</ept>","pos":[14022,14085],"source":"[Set a breakpoint at the end of garbage collection.](#GenBreak)"},{"pos":[14093,14112],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[14166,14192],"content":"Troubleshooting Guidelines","linkify":"Troubleshooting Guidelines","nodes":[{"content":"Troubleshooting Guidelines","pos":[0,26]}]},{"content":"This section describes guidelines that you should consider as you begin your investigations.","pos":[14196,14288]},{"pos":[14298,14338],"content":"Workstation or Server Garbage Collection","linkify":"Workstation or Server Garbage Collection","nodes":[{"content":"Workstation or Server Garbage Collection","pos":[0,40]}]},{"content":"Determine if you are using the correct type of garbage collection.","pos":[14342,14408]},{"content":"If your application uses multiple threads and object instances, use server garbage collection instead of workstation garbage collection.","pos":[14409,14545]},{"content":"Server garbage collection operates on multiple threads, whereas workstation garbage collection requires multiple instances of an application to run their own garbage collection threads and compete for CPU time.","pos":[14546,14756]},{"content":"An application that has a low load and that performs tasks infrequently in the background, such as a service, could use workstation garbage collection with concurrent garbage collection disabled.","pos":[14763,14958]},{"pos":[14968,15005],"content":"When to Measure the Managed Heap Size","linkify":"When to Measure the Managed Heap Size","nodes":[{"content":"When to Measure the Managed Heap Size","pos":[0,37]}]},{"content":"Unless you are using a profiler, you will have to establish a consistent measuring pattern to effectively diagnose performance issues.","pos":[15009,15143]},{"content":"Consider the following points to establish a schedule:","pos":[15144,15198]},{"content":"If you measure after a generation 2 garbage collection, the entire managed heap will be free of garbage (dead objects).","pos":[15208,15327]},{"content":"If you measure immediately after a generation 0 garbage collection, the objects in generations 1 and 2 will not be collected yet.","pos":[15337,15466]},{"content":"If you measure immediately before a garbage collection, you will measure as much allocation as possible before the garbage collection starts.","pos":[15476,15617]},{"content":"Measuring during a garbage collection is problematic, because the garbage collector data structures are not in a valid state for traversal and may not be able to give you the complete results.","pos":[15627,15819]},{"content":"This is by design.","pos":[15820,15838]},{"content":"When you are using workstation garbage collection with concurrent garbage collection, the reclaimed objects are not compacted, so the heap size can be the same or larger (fragmentation can make it appear to be larger).","pos":[15848,16066]},{"content":"Concurrent garbage collection on generation 2 is delayed when the physical memory load is too high.","pos":[16076,16175]},{"content":"The following procedure describes how to set a breakpoint so that you can measure the managed heap.","pos":[16182,16281]},{"pos":[16320,16372],"content":"To set a breakpoint at the end of garbage collection","linkify":"To set a breakpoint at the end of garbage collection","nodes":[{"content":"To set a breakpoint at the end of garbage collection","pos":[0,52]}]},{"content":"In WinDbg with the SOS debugger extension loaded, type the following command:","pos":[16382,16459]},{"pos":[16470,16575],"content":"<bpt id=\"p1\">**</bpt>bp mscorwks!WKS::GCHeap::RestartEE \"j (dwo(mscorwks!WKS::GCHeap::GcCondemnedGeneration)==2) 'kb';'g'\"<ept id=\"p1\">**</ept>","source":"**bp mscorwks!WKS::GCHeap::RestartEE \"j (dwo(mscorwks!WKS::GCHeap::GcCondemnedGeneration)==2) 'kb';'g'\"**"},{"content":"where <bpt id=\"p1\">**</bpt>GcCondemnedGeneration<ept id=\"p1\">**</ept> is set to the desired generation.","pos":[16586,16651],"source":"where **GcCondemnedGeneration** is set to the desired generation."},{"content":"This command requires private symbols.","pos":[16652,16690]},{"pos":[16701,16828],"content":"This command forces a break if <bpt id=\"p1\">**</bpt>RestartEE<ept id=\"p1\">**</ept> is executed after generation 2 objects have been reclaimed for garbage collection.","source":"This command forces a break if **RestartEE** is executed after generation 2 objects have been reclaimed for garbage collection."},{"pos":[16839,16986],"content":"In server garbage collection, only one thread calls <bpt id=\"p1\">**</bpt>RestartEE<ept id=\"p1\">**</ept>, so the breakpoint will occur only once during a generation 2 garbage collection.","source":"In server garbage collection, only one thread calls **RestartEE**, so the breakpoint will occur only once during a generation 2 garbage collection."},{"pos":[16993,17012],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[17068,17096],"content":"Performance Check Procedures","linkify":"Performance Check Procedures","nodes":[{"content":"Performance Check Procedures","pos":[0,28]}]},{"content":"This section describes the following procedures to isolate the cause of your performance issue:","pos":[17100,17195]},{"pos":[17205,17276],"content":"<bpt id=\"p1\">[</bpt>Determine whether the problem is caused by garbage collection.<ept id=\"p1\">](#IsGC)</ept>","source":"[Determine whether the problem is caused by garbage collection.](#IsGC)"},{"pos":[17286,17360],"content":"<bpt id=\"p1\">[</bpt>Determine whether the out-of-memory exception is managed.<ept id=\"p1\">](#OOMIsManaged)</ept>","source":"[Determine whether the out-of-memory exception is managed.](#OOMIsManaged)"},{"pos":[17370,17430],"content":"<bpt id=\"p1\">[</bpt>Determine how much virtual memory can be reserved.<ept id=\"p1\">](#GetVM)</ept>","source":"[Determine how much virtual memory can be reserved.](#GetVM)"},{"pos":[17440,17503],"content":"<bpt id=\"p1\">[</bpt>Determine whether there is enough physical memory.<ept id=\"p1\">](#Physical)</ept>","source":"[Determine whether there is enough physical memory.](#Physical)"},{"pos":[17513,17592],"content":"<bpt id=\"p1\">[</bpt>Determine how much memory the managed heap is committing.<ept id=\"p1\">](#ManagedHeapCommit)</ept>","source":"[Determine how much memory the managed heap is committing.](#ManagedHeapCommit)"},{"pos":[17602,17677],"content":"<bpt id=\"p1\">[</bpt>Determine how much memory the managed heap reserves.<ept id=\"p1\">](#ManagedHeapReserve)</ept>","source":"[Determine how much memory the managed heap reserves.](#ManagedHeapReserve)"},{"pos":[17687,17743],"content":"<bpt id=\"p1\">[</bpt>Determine large objects in generation 2.<ept id=\"p1\">](#ExamineGen2)</ept>","source":"[Determine large objects in generation 2.](#ExamineGen2)"},{"pos":[17753,17796],"content":"<bpt id=\"p1\">[</bpt>Determine references to objects.<ept id=\"p1\">](#ObjRef)</ept>","source":"[Determine references to objects.](#ObjRef)"},{"pos":[17806,17860],"content":"<bpt id=\"p1\">[</bpt>Determine whether a finalizer has been run.<ept id=\"p1\">](#Induce)</ept>","source":"[Determine whether a finalizer has been run.](#Induce)"},{"pos":[17870,17943],"content":"<bpt id=\"p1\">[</bpt>Determine whether there are objects waiting to be finalized.<ept id=\"p1\">](#Finalize)</ept>","source":"[Determine whether there are objects waiting to be finalized.](#Finalize)"},{"pos":[17953,18023],"content":"<bpt id=\"p1\">[</bpt>Determine the amount of free space in the managed heap.<ept id=\"p1\">](#Fragmented)</ept>","source":"[Determine the amount of free space in the managed heap.](#Fragmented)"},{"pos":[18033,18083],"content":"<bpt id=\"p1\">[</bpt>Determine the number of pinned objects.<ept id=\"p1\">](#Pinned)</ept>","source":"[Determine the number of pinned objects.](#Pinned)"},{"pos":[18093,18159],"content":"<bpt id=\"p1\">[</bpt>Determine the length of time in a garbage collection.<ept id=\"p1\">](#TimeInGC)</ept>","source":"[Determine the length of time in a garbage collection.](#TimeInGC)"},{"pos":[18169,18229],"content":"<bpt id=\"p1\">[</bpt>Determine what triggered a garbage collection.<ept id=\"p1\">](#Triggered)</ept>","source":"[Determine what triggered a garbage collection.](#Triggered)"},{"pos":[18239,18316],"content":"<bpt id=\"p1\">[</bpt>Determine whether high CPU usage is caused by garbage collection.<ept id=\"p1\">](#HighCPU)</ept>","source":"[Determine whether high CPU usage is caused by garbage collection.](#HighCPU)"},{"pos":[18351,18415],"content":"To determine whether the problem is caused by garbage collection","linkify":"To determine whether the problem is caused by garbage collection","nodes":[{"content":"To determine whether the problem is caused by garbage collection","pos":[0,64]}]},{"content":"Examine the following two memory performance counters:","pos":[18425,18479]},{"content":"<bpt id=\"p1\">**</bpt>% Time in GC<ept id=\"p1\">**</ept>.","pos":[18493,18510],"source":"**% Time in GC**."},{"content":"Displays the percentage of elapsed time that was spent performing a garbage collection after the last garbage collection cycle.","pos":[18511,18638]},{"content":"Use this counter to determine whether the garbage collector is spending too much time to make managed heap space available.","pos":[18639,18762]},{"content":"If the time spent in garbage collection is relatively low, that could indicate a resource problem outside the managed heap.","pos":[18763,18886]},{"content":"This counter may not be accurate when concurrent or background garbage collection is involved.","pos":[18887,18981]},{"content":"<bpt id=\"p1\">**</bpt># Total committed Bytes<ept id=\"p1\">**</ept>.","pos":[18995,19023],"source":"**# Total committed Bytes**."},{"content":"Displays the amount of virtual memory currently committed by the garbage collector.","pos":[19024,19107]},{"content":"Use this counter to determine whether the memory consumed by the garbage collector is an excessive portion of the memory that your application uses.","pos":[19108,19256]},{"content":"Most of the memory performance counters are updated at the end of each garbage collection.","pos":[19267,19357]},{"content":"Therefore, they may not reflect the current conditions that you want information about.","pos":[19358,19445]},{"pos":[19488,19547],"content":"To determine whether the out-of-memory exception is managed","linkify":"To determine whether the out-of-memory exception is managed","nodes":[{"content":"To determine whether the out-of-memory exception is managed","pos":[0,59]}]},{"pos":[19557,19679],"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the print exception (<bpt id=\"p1\">**</bpt>pe<ept id=\"p1\">**</ept>) command:","source":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the print exception (**pe**) command:"},{"pos":[19690,19697],"content":"<bpt id=\"p1\">**</bpt>!pe<ept id=\"p1\">**</ept>","source":"**!pe**"},{"content":"If the exception is managed, <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> is displayed as the exception type, as shown in the following example.","pos":[19708,19842],"source":"If the exception is managed, <xref:System.OutOfMemoryException> is displayed as the exception type, as shown in the following example."},{"content":"If the output does not specify an exception, you have to determine which thread the out-of-memory exception is from.","pos":[20039,20155]},{"content":"Type the following command in the debugger to show all the threads with their call stacks:","pos":[20156,20246]},{"pos":[20257,20266],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">~</ph><ph id=\"ph2\">\\*</ph>kb<ept id=\"p1\">**</ept>","source":"**~\\*kb**"},{"content":"The thread with the stack that has exception calls is indicated by the <ph id=\"ph1\">`RaiseTheException`</ph> argument.","pos":[20277,20377],"source":"The thread with the stack that has exception calls is indicated by the `RaiseTheException` argument."},{"content":"This is the managed exception object.","pos":[20378,20415]},{"content":"You can use the following command to dump nested exceptions.","pos":[20532,20592]},{"pos":[20603,20618],"content":"<bpt id=\"p1\">**</bpt>!pe -nested<ept id=\"p1\">**</ept>","source":"**!pe -nested**"},{"content":"If you do not find any exceptions, the out-of-memory exception originated from unmanaged code.","pos":[20629,20723]},{"pos":[20759,20811],"content":"To determine how much virtual memory can be reserved","linkify":"To determine how much virtual memory can be reserved","nodes":[{"content":"To determine how much virtual memory can be reserved","pos":[0,52]}]},{"content":"In WinDbg with the SOS debugger extension loaded, type the following command to get the largest free region:","pos":[20821,20929]},{"pos":[20940,20961],"content":"<bpt id=\"p1\">**</bpt>!address -summary<ept id=\"p1\">**</ept>","source":"**!address -summary**"},{"content":"The largest free region is displayed as shown in the following output.","pos":[20972,21042]},{"content":"In this example, the size of the largest free region is approximately 24000 KB (3A980 in hexadecimal).","pos":[21133,21235]},{"content":"This region is much smaller than what the garbage collector needs for a segment.","pos":[21236,21316]},{"content":"-or-","pos":[21327,21331]},{"pos":[21341,21368],"content":"Use the <bpt id=\"p1\">**</bpt>vmstat<ept id=\"p1\">**</ept> command:","source":"Use the **vmstat** command:"},{"pos":[21379,21390],"content":"<bpt id=\"p1\">**</bpt>!vmstat<ept id=\"p1\">**</ept>","source":"**!vmstat**"},{"content":"The largest free region is the largest value in the MAXIMUM column, as shown in the following output.","pos":[21401,21502]},{"pos":[21995,22047],"content":"To determine whether there is enough physical memory","linkify":"To determine whether there is enough physical memory","nodes":[{"content":"To determine whether there is enough physical memory","pos":[0,52]}]},{"content":"Start Windows Task Manager.","pos":[22057,22084]},{"content":"On the <bpt id=\"p1\">**</bpt>Performance<ept id=\"p1\">**</ept> tab, look at the committed value.","pos":[22094,22150],"source":"On the **Performance** tab, look at the committed value."},{"content":"(In Windows 7, look at <bpt id=\"p1\">**</bpt>Commit (KB)<ept id=\"p1\">**</ept> in the <bpt id=\"p2\">**</bpt>System group<ept id=\"p2\">**</ept>.)","pos":[22151,22215],"source":" (In Windows 7, look at **Commit (KB)** in the **System group**.)"},{"pos":[22226,22309],"content":"If the <bpt id=\"p1\">**</bpt>Total<ept id=\"p1\">**</ept> is close to the <bpt id=\"p2\">**</bpt>Limit<ept id=\"p2\">**</ept>, you are running low on physical memory.","source":"If the **Total** is close to the **Limit**, you are running low on physical memory."},{"pos":[22357,22416],"content":"To determine how much memory the managed heap is committing","linkify":"To determine how much memory the managed heap is committing","nodes":[{"content":"To determine how much memory the managed heap is committing","pos":[0,59]}]},{"content":"Use the <ph id=\"ph1\">`# Total committed bytes`</ph> memory performance counter to get the number of bytes that the managed heap is committing.","pos":[22426,22550],"source":"Use the `# Total committed bytes` memory performance counter to get the number of bytes that the managed heap is committing."},{"content":"The garbage collector commits chunks on a segment as needed, not all at the same time.","pos":[22551,22637]},{"pos":[22649,23013],"content":"[!NOTE]\nDo not use the `# Bytes in all Heaps` performance counter, because it does not represent actual memory usage by the managed heap. The size of a generation is included in this value and is actually its threshold size, that is, the size that induces a garbage collection if the generation is filled with objects. Therefore, this value is usually zero.","leadings":["","    >  "],"nodes":[{"content":"Do not use the `# Bytes in all Heaps` performance counter, because it does not represent actual memory usage by the managed heap. The size of a generation is included in this value and is actually its threshold size, that is, the size that induces a garbage collection if the generation is filled with objects. Therefore, this value is usually zero.","pos":[8,357],"nodes":[{"content":"Do not use the <ph id=\"ph1\">`# Bytes in all Heaps`</ph> performance counter, because it does not represent actual memory usage by the managed heap.","pos":[0,129],"source":"Do not use the `# Bytes in all Heaps` performance counter, because it does not represent actual memory usage by the managed heap."},{"content":"The size of a generation is included in this value and is actually its threshold size, that is, the size that induces a garbage collection if the generation is filled with objects.","pos":[130,310]},{"content":"Therefore, this value is usually zero.","pos":[311,349]}]}]},{"pos":[23062,23116],"content":"To determine how much memory the managed heap reserves","linkify":"To determine how much memory the managed heap reserves","nodes":[{"content":"To determine how much memory the managed heap reserves","pos":[0,54]}]},{"pos":[23126,23186],"content":"Use the <ph id=\"ph1\">`# Total reserved bytes`</ph> memory performance counter.","source":"Use the `# Total reserved bytes` memory performance counter."},{"pos":[23197,23325],"content":"The garbage collector reserves memory in segments, and you can determine where a segment starts by using the <bpt id=\"p1\">**</bpt>eeheap<ept id=\"p1\">**</ept> command.","source":"The garbage collector reserves memory in segments, and you can determine where a segment starts by using the **eeheap** command."},{"pos":[23337,23739],"content":"[!IMPORTANT]\nAlthough you can determine the amount of memory the garbage collector allocates for each segment, segment size is implementation-specific and is subject to change at any time, including in periodic updates. Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.","leadings":["","    >  "],"nodes":[{"content":"Although you can determine the amount of memory the garbage collector allocates for each segment, segment size is implementation-specific and is subject to change at any time, including in periodic updates. Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.","pos":[13,395],"nodes":[{"content":"Although you can determine the amount of memory the garbage collector allocates for each segment, segment size is implementation-specific and is subject to change at any time, including in periodic updates.","pos":[0,206]},{"content":"Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.","pos":[207,382]}]}]},{"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:","pos":[23749,23856]},{"pos":[23867,23882],"content":"<bpt id=\"p1\">**</bpt>!eeheap -gc<ept id=\"p1\">**</ept>","source":"**!eeheap -gc**"},{"content":"The result is as follows.","pos":[23893,23918]},{"content":"The addresses indicated by \"segment\" are the starting addresses of the segments.","pos":[25048,25128]},{"pos":[25170,25212],"content":"To determine large objects in generation 2","linkify":"To determine large objects in generation 2","nodes":[{"content":"To determine large objects in generation 2","pos":[0,42]}]},{"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:","pos":[25222,25329]},{"pos":[25340,25359],"content":"<bpt id=\"p1\">**</bpt>!dumpheap –stat<ept id=\"p1\">**</ept>","source":"**!dumpheap –stat**"},{"pos":[25370,25438],"content":"If the managed heap is big, <bpt id=\"p1\">**</bpt>dumpheap<ept id=\"p1\">**</ept> may take a while to finish.","source":"If the managed heap is big, **dumpheap** may take a while to finish."},{"content":"You can start analyzing from the last few lines of the output, because they list the objects that use the most space.","pos":[25449,25566]},{"content":"For example:","pos":[25567,25579]},{"content":"The last object listed is a string and occupies the most space.","pos":[26345,26408]},{"content":"You can examine your application to see how your string objects can be optimized.","pos":[26409,26490]},{"content":"To see strings that are between 150 and 200 bytes, type the following:","pos":[26491,26561]},{"pos":[26572,26623],"content":"<bpt id=\"p1\">**</bpt>!dumpheap -type System.String -min 150 -max 200<ept id=\"p1\">**</ept>","source":"**!dumpheap -type System.String -min 150 -max 200**"},{"content":"An example of the results is as follows.","pos":[26634,26674]},{"content":"Using an integer instead of a string for an ID can be more efficient.","pos":[26873,26942]},{"content":"If the same string is being repeated thousands of times, consider string interning.","pos":[26943,27026]},{"content":"For more information about string interning, see the reference topic for the <ph id=\"ph1\">&lt;xref:System.String.Intern%2A?displayProperty=fullName&gt;</ph> method.","pos":[27027,27167],"source":" For more information about string interning, see the reference topic for the <xref:System.String.Intern%2A?displayProperty=fullName> method."},{"pos":[27204,27238],"content":"To determine references to objects","linkify":"To determine references to objects","nodes":[{"content":"To determine references to objects","pos":[0,34]}]},{"content":"In WinDbg with the SOS debugger extension loaded, type the following command to list references to objects:","pos":[27248,27355]},{"pos":[27366,27377],"content":"<bpt id=\"p1\">**</bpt>!gcroot<ept id=\"p1\">**</ept>","source":"**!gcroot**"},{"content":"To determine the references for a specific object, include the address:","pos":[27404,27475]},{"pos":[27486,27506],"content":"<bpt id=\"p1\">**</bpt>!gcroot 1c37b2ac<ept id=\"p1\">**</ept>","source":"**!gcroot 1c37b2ac**"},{"content":"Roots found on stacks may be false positives.","pos":[27517,27562]},{"content":"For more information, use the command <ph id=\"ph1\">`!help gcroot`</ph>.","pos":[27563,27616],"source":" For more information, use the command `!help gcroot`."},{"content":"The <bpt id=\"p1\">**</bpt>gcroot<ept id=\"p1\">**</ept> command can take a long time to finish.","pos":[28217,28271],"source":"The **gcroot** command can take a long time to finish."},{"content":"Any object that is not reclaimed by garbage collection is a live object.","pos":[28272,28344]},{"content":"This means that some root is directly or indirectly holding onto the object, so <bpt id=\"p1\">**</bpt>gcroot<ept id=\"p1\">**</ept> should return path information to the object.","pos":[28345,28481],"source":" This means that some root is directly or indirectly holding onto the object, so **gcroot** should return path information to the object."},{"content":"You should examine the graphs returned and see why these objects are still referenced.","pos":[28482,28568]},{"pos":[28605,28650],"content":"To determine whether a finalizer has been run","linkify":"To determine whether a finalizer has been run","nodes":[{"content":"To determine whether a finalizer has been run","pos":[0,45]}]},{"content":"Run a test program that contains the following code:","pos":[28660,28712]},{"content":"If the test resolves the problem, this means that the garbage collector was not reclaiming objects, because the finalizers for those objects had been suspended.","pos":[28823,28983]},{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=fullName&gt;</ph> method enables the finalizers to complete their tasks, and fixes the problem.","pos":[28984,29135],"source":" The <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=fullName> method enables the finalizers to complete their tasks, and fixes the problem."},{"pos":[29174,29236],"content":"To determine whether there are objects waiting to be finalized","linkify":"To determine whether there are objects waiting to be finalized","nodes":[{"content":"To determine whether there are objects waiting to be finalized","pos":[0,62]}]},{"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:","pos":[29246,29353]},{"pos":[29364,29382],"content":"<bpt id=\"p1\">**</bpt>!finalizequeue<ept id=\"p1\">**</ept>","source":"**!finalizequeue**"},{"content":"Look at the number of objects that are ready for finalization.","pos":[29393,29455]},{"content":"If the number is high, you must examine why these finalizers cannot progress at all or cannot progress fast enough.","pos":[29456,29571]},{"content":"To get an output of threads, type the following command:","pos":[29581,29637]},{"pos":[29648,29668],"content":"<bpt id=\"p1\">**</bpt>threads -special<ept id=\"p1\">**</ept>","source":"**threads -special**"},{"content":"This command provides output such as the following.","pos":[29679,29730]},{"content":"The finalizer thread indicates which finalizer, if any, is currently being run.","pos":[29892,29971]},{"content":"When a finalizer thread is not running any finalizers, it is waiting for an event to tell it to do its work.","pos":[29972,30080]},{"content":"Most of the time you will see the finalizer thread in this state because it runs at THREAD_HIGHEST_PRIORITY and is supposed to finish running finalizers, if any, very quickly.","pos":[30081,30256]},{"pos":[30297,30354],"content":"To determine the amount of free space in the managed heap","linkify":"To determine the amount of free space in the managed heap","nodes":[{"content":"To determine the amount of free space in the managed heap","pos":[0,57]}]},{"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:","pos":[30364,30471]},{"pos":[30482,30512],"content":"<bpt id=\"p1\">**</bpt>!dumpheap -type Free -stat<ept id=\"p1\">**</ept>","source":"**!dumpheap -type Free -stat**"},{"content":"This command displays the total size of all the free objects on the managed heap, as shown in the following example.","pos":[30523,30639]},{"content":"To determine the free space in generation 0, type the following command for memory consumption information by generation:","pos":[30833,30954]},{"pos":[30965,30980],"content":"<bpt id=\"p1\">**</bpt>!eeheap -gc<ept id=\"p1\">**</ept>","source":"**!eeheap -gc**"},{"content":"This command displays output similar to the following.","pos":[30991,31045]},{"content":"The last line shows the ephemeral segment.","pos":[31046,31088]},{"content":"Calculate the space used by generation 0:","pos":[31635,31676]},{"pos":[31687,31712],"content":"<bpt id=\"p1\">**</bpt>? 49e05d04-0x49521f8c<ept id=\"p1\">**</ept>","source":"**? 49e05d04-0x49521f8c**"},{"content":"The result is as follows.","pos":[31723,31748]},{"content":"Generation 0 is approximately 9 MB.","pos":[31749,31784]},{"content":"The following command dumps the free space within the generation 0 range:","pos":[31863,31936]},{"pos":[31947,31997],"content":"<bpt id=\"p1\">**</bpt>!dumpheap -type Free -stat 0x49521f8c 49e05d04<ept id=\"p1\">**</ept>","source":"**!dumpheap -type Free -stat 0x49521f8c 49e05d04**"},{"content":"The result is as follows.","pos":[32008,32033]},{"content":"This output shows that the generation 0 portion of the heap is using 9 MB of space for objects and has 7 MB free.","pos":[32549,32662]},{"content":"This analysis shows the extent to which generation 0 contributes to fragmentation.","pos":[32663,32745]},{"content":"This amount of heap usage should be discounted from the total amount as the cause of fragmentation by long-term objects.","pos":[32746,32866]},{"pos":[32903,32944],"content":"To determine the number of pinned objects","linkify":"To determine the number of pinned objects","nodes":[{"content":"To determine the number of pinned objects","pos":[0,41]}]},{"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:","pos":[32954,33061]},{"pos":[33072,33086],"content":"<bpt id=\"p1\">**</bpt>!gchandles<ept id=\"p1\">**</ept>","source":"**!gchandles**"},{"content":"The statistics displayed includes the number of pinned handles, as the following example shows.","pos":[33097,33192]},{"pos":[33342,33397],"content":"To determine the length of time in a garbage collection","linkify":"To determine the length of time in a garbage collection","nodes":[{"content":"To determine the length of time in a garbage collection","pos":[0,55]}]},{"pos":[33407,33461],"content":"Examine the <ph id=\"ph1\">`% Time in GC`</ph> memory performance counter.","source":"Examine the `% Time in GC` memory performance counter."},{"content":"The value is calculated by using a sample interval time.","pos":[33472,33528]},{"content":"Because the counters are updated at the end of each garbage collection, the current sample will have the same value as the previous sample if no collections occurred during the interval.","pos":[33529,33715]},{"content":"Collection time is obtained by multiplying the sample interval time with the percentage value.","pos":[33726,33820]},{"content":"The following data shows four sampling intervals of two seconds, for an 8-second study.","pos":[33831,33918]},{"content":"The <ph id=\"ph1\">`Gen0`</ph>, <ph id=\"ph2\">`Gen1`</ph>, and <ph id=\"ph3\">`Gen2`</ph> columns show the number of garbage collections that occurred during that interval for that generation.","pos":[33919,34052],"source":" The `Gen0`, `Gen1`, and `Gen2` columns show the number of garbage collections that occurred during that interval for that generation."},{"content":"This information does not show when the garbage collection occurred, but you can determine the number of garbage collections that occurred in an interval of time.","pos":[34361,34523]},{"content":"Assuming the worst case, the tenth generation 0 garbage collection finished at the start of the second interval, and the eleventh generation 0 garbage collection finished at the end of the fifth interval.","pos":[34524,34728]},{"content":"The time between the end of the tenth and the end of the eleventh garbage collection is about 2 seconds, and the performance counter shows 3%, so the duration of the eleventh generation 0 garbage collection was (2 seconds * 3% = 60ms).","pos":[34729,34964]},{"content":"In this example, there are 5 periods.","pos":[34975,35012]},{"content":"The second generation 2 garbage collection started during the third interval and finished at the fifth interval.","pos":[35382,35494]},{"content":"Assuming the worst case, the last garbage collection was for a generation 0 collection that finished at the start of the second interval, and the generation 2 garbage collection finished at the end of the fifth interval.","pos":[35495,35715]},{"content":"Therefore, the time between the end of the generation 0 garbage collection and the end of the generation 2 garbage collection is 4 seconds.","pos":[35716,35855]},{"content":"Because the <ph id=\"ph1\">`% Time in GC`</ph> counter is 20%, the maximum amount of time the generation 2 garbage collection could have taken is (4 seconds * 20% = 800ms).","pos":[35856,36008],"source":" Because the `% Time in GC` counter is 20%, the maximum amount of time the generation 2 garbage collection could have taken is (4 seconds * 20% = 800ms)."},{"pos":[36018,36274],"content":"Alternatively, you can determine the length of a garbage collection by using <bpt id=\"p1\">[</bpt>garbage collection ETW events<ept id=\"p1\">](../../../docs/framework/performance/garbage-collection-etw-events.md)</ept>, and analyze the information to determine the duration of garbage collection.","source":"Alternatively, you can determine the length of a garbage collection by using [garbage collection ETW events](../../../docs/framework/performance/garbage-collection-etw-events.md), and analyze the information to determine the duration of garbage collection."},{"content":"For example, the following data shows an event sequence that occurred during a non-concurrent garbage collection.","pos":[36285,36398]},{"pos":[36701,36784],"content":"Suspending the managed thread took 26us (<ph id=\"ph1\">`GCSuspendEEEnd`</ph> – <ph id=\"ph2\">`GCSuspendEEBegin_V1`</ph>).","source":"Suspending the managed thread took 26us (`GCSuspendEEEnd` – `GCSuspendEEBegin_V1`)."},{"pos":[36795,36864],"content":"The actual garbage collection took 4.8ms (<ph id=\"ph1\">`GCEnd_V1`</ph> – <ph id=\"ph2\">`GCStart_V1`</ph>).","source":"The actual garbage collection took 4.8ms (`GCEnd_V1` – `GCStart_V1`)."},{"pos":[36875,36954],"content":"Resuming the managed threads took 21us (<ph id=\"ph1\">`GCRestartEEEnd`</ph> – <ph id=\"ph2\">`GCRestartEEBegin`</ph>).","source":"Resuming the managed threads took 21us (`GCRestartEEEnd` – `GCRestartEEBegin`)."},{"content":"The following output provides an example for background garbage collection, and includes the process, thread, and event fields.","pos":[36965,37092]},{"content":"(Not all data is shown.)","pos":[37093,37117]},{"content":"The <ph id=\"ph1\">`GCStart_V1`</ph> event at 42504816 indicates that this is a background garbage collection, because the last field is <ph id=\"ph2\">`1`</ph>.","pos":[38245,38366],"source":"The `GCStart_V1` event at 42504816 indicates that this is a background garbage collection, because the last field is `1`."},{"content":"This becomes garbage collection No.","pos":[38367,38402]},{"content":"102019.","pos":[38403,38410]},{"content":"The <ph id=\"ph1\">`GCStart`</ph> event occurs because there is a need for an ephemeral garbage collection before you start a background garbage collection.","pos":[38421,38557],"source":"The `GCStart` event occurs because there is a need for an ephemeral garbage collection before you start a background garbage collection."},{"content":"This becomes garbage collection No.","pos":[38558,38593]},{"content":"102020.","pos":[38594,38601]},{"content":"At 42514170, garbage collection No.","pos":[38612,38647]},{"content":"102020 finishes.","pos":[38648,38664]},{"content":"The managed threads are restarted at this point.","pos":[38665,38713]},{"content":"This is completed on thread 4372, which triggered this background garbage collection.","pos":[38714,38799]},{"content":"On thread 4744, a suspension occurs.","pos":[38810,38846]},{"content":"This is the only time at which the background garbage collection has to suspend managed threads.","pos":[38847,38943]},{"content":"This duration is approximately 99ms ((63784407-63685394)/1000).","pos":[38944,39007]},{"content":"The <ph id=\"ph1\">`GCEnd`</ph> event for the background garbage collection is at 89931423.","pos":[39018,39089],"source":"The `GCEnd` event for the background garbage collection is at 89931423."},{"content":"This means that the background garbage collection lasted for about 47seconds ((89931423-42504816)/1000).","pos":[39090,39194]},{"content":"While the managed threads are running, you can see any number of ephemeral garbage collections occurring.","pos":[39205,39310]},{"pos":[39350,39398],"content":"To determine what triggered a garbage collection","linkify":"To determine what triggered a garbage collection","nodes":[{"content":"To determine what triggered a garbage collection","pos":[0,48]}]},{"content":"In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command to show all the threads with their call stacks:","pos":[39408,39562]},{"pos":[39573,39582],"content":"<bpt id=\"p1\">**</bpt><ph id=\"ph1\">~</ph><ph id=\"ph2\">\\*</ph>kb<ept id=\"p1\">**</ept>","source":"**~\\*kb**"},{"content":"This command displays output similar to the following.","pos":[39593,39647]},{"content":"If the garbage collection was caused by a low memory notification from the operating system, the call stack is similar, except that the thread is the finalizer thread.","pos":[39883,40050]},{"content":"The finalizer thread gets an asynchronous low memory notification and induces the garbage collection.","pos":[40051,40152]},{"content":"If the garbage collection was caused by memory allocation, the stack appears as follows:","pos":[40163,40251]},{"content":"A just-in-time helper (<ph id=\"ph1\">`JIT_New*`</ph>) eventually calls <ph id=\"ph2\">`GCHeap::GarbageCollectGeneration`</ph>.","pos":[40865,40952],"source":"A just-in-time helper (`JIT_New*`) eventually calls `GCHeap::GarbageCollectGeneration`."},{"content":"If you determine that generation 2 garbage collections are caused by allocations, you must determine which objects are collected by a generation 2 garbage collection and how to avoid them.","pos":[40953,41141]},{"content":"That is, you want to determine the difference between the start and the end of a generation 2 garbage collection, and the objects that caused the generation 2 collection.","pos":[41142,41312]},{"content":"For example, type the following command in the debugger to show the beginning of a generation 2 collection:","pos":[41323,41430]},{"pos":[41441,41460],"content":"<bpt id=\"p1\">**</bpt>!dumpheap –stat<ept id=\"p1\">**</ept>","source":"**!dumpheap –stat**"},{"content":"Example output (abridged to show the objects that use the most space):","pos":[41471,41541]},{"content":"Repeat the command at the end of generation 2:","pos":[42397,42443]},{"pos":[42454,42473],"content":"<bpt id=\"p1\">**</bpt>!dumpheap –stat<ept id=\"p1\">**</ept>","source":"**!dumpheap –stat**"},{"content":"Example output (abridged to show the objects that use the most space):","pos":[42484,42554]},{"content":"The <ph id=\"ph1\">`double[]`</ph> objects disappeared from the end of the output, which means that they were collected.","pos":[43357,43457],"source":"The `double[]` objects disappeared from the end of the output, which means that they were collected."},{"content":"These objects account for approximately 70 MB.","pos":[43458,43504]},{"content":"The remaining objects did not change much.","pos":[43505,43547]},{"content":"Therefore, these <ph id=\"ph1\">`double[]`</ph> objects were the reason why this generation 2 garbage collection occurred.","pos":[43548,43650],"source":" Therefore, these `double[]` objects were the reason why this generation 2 garbage collection occurred."},{"content":"Your next step is to determine why the <ph id=\"ph1\">`double[]`</ph> objects are there and why they died.","pos":[43651,43737],"source":" Your next step is to determine why the `double[]` objects are there and why they died."},{"content":"You can ask the code developer where these objects came from, or you can use the <bpt id=\"p1\">**</bpt>gcroot<ept id=\"p1\">**</ept> command.","pos":[43738,43838],"source":" You can ask the code developer where these objects came from, or you can use the **gcroot** command."},{"pos":[43876,43943],"content":"To determine whether high CPU usage is caused by garbage collection","linkify":"To determine whether high CPU usage is caused by garbage collection","nodes":[{"content":"To determine whether high CPU usage is caused by garbage collection","pos":[0,67]}]},{"pos":[43953,44037],"content":"Correlate the <ph id=\"ph1\">`% Time in GC`</ph> memory performance counter value with the process time.","source":"Correlate the `% Time in GC` memory performance counter value with the process time."},{"content":"If the <ph id=\"ph1\">`% Time in GC`</ph> value spikes at the same time as process time, garbage collection is causing a high CPU usage.","pos":[44048,44164],"source":"If the `% Time in GC` value spikes at the same time as process time, garbage collection is causing a high CPU usage."},{"content":"Otherwise, profile the application to find where the high usage is occurring.","pos":[44165,44242]},{"pos":[44251,44259],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[44263,44335],"content":"<bpt id=\"p1\">[</bpt>Garbage Collection<ept id=\"p1\">](../../../docs/standard/garbage-collection/index.md)</ept>","source":"[Garbage Collection](../../../docs/standard/garbage-collection/index.md)"}]}