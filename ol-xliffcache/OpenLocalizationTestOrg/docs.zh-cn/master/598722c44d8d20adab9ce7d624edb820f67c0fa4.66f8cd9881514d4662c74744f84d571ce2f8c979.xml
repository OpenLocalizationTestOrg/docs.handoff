{"content":"---\ntitle: \"Profiling Overview\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"managed code, profiling API support\"\n  - \"unmanaged code, combining with managed code in profiling\"\n  - \"notification threads [.NET Framework profiling]\"\n  - \"unmanaged code, profiling\"\n  - \"profiling API [.NET Framework], and COM\"\n  - \"profiling API [.NET Framework], unmanaged code profiling\"\n  - \"profilers, writing\"\n  - \"profiling API [.NET Framework], call stacks\"\n  - \"code profilers, writing\"\n  - \"profiling API [.NET Framework], security considerations\"\n  - \"profiling API [.NET Framework], managed code support\"\n  - \"common language runtime, profiling\"\n  - \"profiling API [.NET Framework], notification threads\"\n  - \"call stacks [.NET Framework profiling]\"\n  - \"profiling API [.NET Framework], stack depth\"\n  - \"common language runtime, writing a profiler\"\n  - \"profiling API [.NET Framework], information retrieval interfaces\"\n  - \"shadow stacks [.NET Framework profiling]\"\n  - \"COM, using in the profiling API\"\n  - \"stack snapshots [.NET Framework profiling]\"\n  - \"profiling API [.NET Framework], supported features\"\n  - \"profiling API [.NET Framework], overview\"\n  - \"security, profiling API considerations\"\n  - \"stack depth [.NET Framework profiling]\"\nms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Profiling Overview\n<a name=\"top\"></a> A profiler is a tool that monitors the execution of another application. A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API. The profiler DLL is loaded by the CLR at run time.  \n  \n Traditional profiling tools focus on measuring the execution of the application. That is, they measure the time that is spent in each function or the memory usage of the application over time. The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids. These uses are all diagnostic in nature. The profiling API not only measures but also monitors the execution of an application. For this reason, the profiling API should never be used by the application itself, and the applicationâ€™s execution should not depend on (or be affected by) the profiler.  \n  \n Profiling a CLR application requires more support than profiling conventionally compiled machine code. This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features. Conventional profiling mechanisms cannot identify or provide useful information about these features. The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.  \n  \n JIT compilation at run time provides good opportunities for profiling. The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled. In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation. Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.  \n  \n This overview consists of the following sections:  \n  \n-   [The Profiling API](#profiling_api)  \n  \n-   [Supported Features](#support)  \n  \n-   [Notification Threads](#notification_threads)  \n  \n-   [Security](#security)  \n  \n-   [Combining Managed and Unmanaged Code in a Code Profiler](#combining_managed_unmanaged)  \n  \n-   [Profiling Unmanaged Code](#unmanaged)  \n  \n-   [Using COM](#com)  \n  \n-   [Call stacks](#call_stacks)  \n  \n-   [Callbacks and Stack Depth](#callbacks)  \n  \n-   [Related Topics](#related_topics)  \n  \n<a name=\"profiling_api\"></a>   \n## The Profiling API  \n Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.  \n  \n The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled. The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later). The CLR calls the methods in that interface to notify the profiler of events in the profiled process. The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.  \n  \n> [!NOTE]\n>  Only the data-gathering part of the profiler solution should be running in the same process as the profiled application. All user interface and data analysis should be performed in a separate process.  \n  \n The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.  \n  \n ![Screenshot that shows the profiling architecture.](./media/profiling-overview/profiling-architecture.png)  \n  \n### The Notification Interfaces  \n [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces. These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md). Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.  \n  \n For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md). It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.  \n  \n### The Information Retrieval Interfaces  \n The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md). The profiler calls these interfaces as required to obtain more information to help its analysis. For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier. The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.  \n  \n [Back to top](#top)  \n  \n<a name=\"support\"></a>   \n## Supported Features  \n The profiling API provides information about a variety of events and actions that occur in the common language runtime. You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.  \n  \n The profiling API retrieves information about the following actions and events that occur in the CLR:  \n  \n-   CLR startup and shutdown events.  \n  \n-   Application domain creation and shutdown events.  \n  \n-   Assembly loading and unloading events.  \n  \n-   Module loading and unloading events.  \n  \n-   COM vtable creation and destruction events.  \n  \n-   Just-in-time (JIT) compilation and code-pitching events.  \n  \n-   Class loading and unloading events.  \n  \n-   Thread creation and destruction events.  \n  \n-   Function entry and exit events.  \n  \n-   Exceptions.  \n  \n-   Transitions between managed and unmanaged code execution.  \n  \n-   Transitions between different runtime contexts.  \n  \n-   Information about runtime suspensions.  \n  \n-   Information about the runtime memory heap and garbage collection activity.  \n  \n The profiling API can be called from any (non-managed) COM-compatible language.  \n  \n The API is efficient with regard to CPU and memory consumption. Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.  \n  \n The profiling API is useful to both sampling and non-sampling profilers. A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart. A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.  \n  \n### Unsupported Functionality  \n The profiling API does not support the following functionality:  \n  \n-   Unmanaged code, which must be profiled using conventional Win32 methods. However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.  \n  \n-   Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.  \n  \n-   Bounds checking, because the profiling API does not provide this information. The CLR provides intrinsic support for bounds checking of all managed code.  \n  \n-   Remote profiling, which is not supported for the following reasons:  \n  \n    -   Remote profiling extends execution time. When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected. This is especially true when execution performance is being monitored. However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.  \n  \n    -   The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running. This limits the ability to create a remote code profiler.  \n  \n-   Profiling in production environments with high-availability requirements. The profiling API was created to support development-time diagnostics. It has not undergone the rigorous testing required to support production environments.  \n  \n [Back to top](#top)  \n  \n<a name=\"notification_threads\"></a>   \n## Notification Threads  \n In most cases, the thread that generates an event also executes notifications. Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`. Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.  \n  \n Note that these callbacks are not serialized. Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads. Therefore, in certain cases you can receive an unusual sequence of callbacks. For example, assume that a managed application is spawning two threads that are executing identical code. In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback. In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.  \n  \n [Back to top](#top)  \n  \n<a name=\"security\"></a>   \n## Security  \n A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine. As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security. The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.  \n  \n Profiler authors should take appropriate precautions to avoid security-related issues. For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.  \n  \n [Back to top](#top)  \n  \n<a name=\"combining_managed_unmanaged\"></a>   \n## Combining Managed and Unmanaged Code in a Code Profiler  \n An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.  \n  \n A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.  \n  \n Although this is possible from a design perspective, the profiling API does not support managed components. A CLR profiler must be completely unmanaged. Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks. The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.  \n  \n The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method. The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface.  \n  \n It is also possible to use the older instrumentation methods to modify MSIL. Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method). This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.  \n  \n Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code. This technique can be used for instrumentation and coverage. For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed. The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.  \n  \n [Back to top](#top)  \n  \n<a name=\"unmanaged\"></a>   \n## Profiling Unmanaged Code  \n The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code. The following functionality is provided:  \n  \n-   Enumeration of stack chains. This feature enables a code profiler to determine the boundary between managed code and unmanaged code.  \n  \n-   Determination whether a stack chain corresponds to managed code or native code.  \n  \n In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API. They are defined in the CorDebug.idl file.  \n  \n In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.  \n  \n [Back to top](#top)  \n  \n<a name=\"com\"></a>   \n## Using COM  \n Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces. The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model. Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.  \n  \n [Back to top](#top)  \n  \n<a name=\"call_stacks\"></a>   \n## Call Stacks  \n The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.  \n  \n### Stack Snapshot  \n A stack snapshot is a trace of the stack of a thread at an instant in time. The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.  \n  \n For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).\n  \n### Shadow Stack  \n Using the snapshot method too frequently can quickly create a performance issue. If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks. The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.  \n  \n A shadow stack may obtain function arguments, return values, and information about generic instantiations. This information is available only through the shadow stack and may be obtained when control is handed to a function. However, this information may not be available later during the run of the function.  \n  \n [Back to top](#top)  \n  \n<a name=\"callbacks\"></a>   \n## Callbacks and Stack Depth  \n Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit. A profiler should make sure to use as little stack as possible in response to callbacks. If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.  \n  \n [Back to top](#top)  \n  \n<a name=\"related_topics\"></a>   \n## Related Topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[Setting Up a Profiling Environment](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)|Explains how to initialize a profiler, set event notifications, and profile a Windows Service.|  \n|[Profiling Interfaces](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)|Describes the unmanaged interfaces that the profiling API uses.|  \n|[Profiling Global Static Functions](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)|Describes the unmanaged global static functions that the profiling API uses.|  \n|[Profiling Enumerations](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)|Describes the unmanaged enumerations that the profiling API uses.|  \n|[Profiling Structures](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)|Describes the unmanaged structures that the profiling API uses.|\n","nodes":[{"pos":[4,1331],"embed":true,"restype":"x-metadata","content":"title: \"Profiling Overview\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"managed code, profiling API support\"\n  - \"unmanaged code, combining with managed code in profiling\"\n  - \"notification threads [.NET Framework profiling]\"\n  - \"unmanaged code, profiling\"\n  - \"profiling API [.NET Framework], and COM\"\n  - \"profiling API [.NET Framework], unmanaged code profiling\"\n  - \"profilers, writing\"\n  - \"profiling API [.NET Framework], call stacks\"\n  - \"code profilers, writing\"\n  - \"profiling API [.NET Framework], security considerations\"\n  - \"profiling API [.NET Framework], managed code support\"\n  - \"common language runtime, profiling\"\n  - \"profiling API [.NET Framework], notification threads\"\n  - \"call stacks [.NET Framework profiling]\"\n  - \"profiling API [.NET Framework], stack depth\"\n  - \"common language runtime, writing a profiler\"\n  - \"profiling API [.NET Framework], information retrieval interfaces\"\n  - \"shadow stacks [.NET Framework profiling]\"\n  - \"COM, using in the profiling API\"\n  - \"stack snapshots [.NET Framework profiling]\"\n  - \"profiling API [.NET Framework], supported features\"\n  - \"profiling API [.NET Framework], overview\"\n  - \"security, profiling API considerations\"\n  - \"stack depth [.NET Framework profiling]\"\nms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Profiling Overview","nodes":[{"pos":[0,18],"content":"Profiling Overview","nodes":[{"content":"Profiling Overview","pos":[0,18]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[1338,1356],"content":"Profiling Overview","linkify":"Profiling Overview","nodes":[{"content":"Profiling Overview","pos":[0,18]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> A profiler is a tool that monitors the execution of another application.","pos":[1357,1448],"source":"<a name=\"top\"></a> A profiler is a tool that monitors the execution of another application."},{"content":"A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.","pos":[1449,1634]},{"content":"The profiler DLL is loaded by the CLR at run time.","pos":[1635,1685]},{"content":"Traditional profiling tools focus on measuring the execution of the application.","pos":[1692,1772]},{"content":"That is, they measure the time that is spent in each function or the memory usage of the application over time.","pos":[1773,1884]},{"content":"The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.","pos":[1885,2012]},{"content":"These uses are all diagnostic in nature.","pos":[2013,2053]},{"content":"The profiling API not only measures but also monitors the execution of an application.","pos":[2054,2140]},{"content":"For this reason, the profiling API should never be used by the application itself, and the applicationâ€™s execution should not depend on (or be affected by) the profiler.","pos":[2141,2310]},{"content":"Profiling a CLR application requires more support than profiling conventionally compiled machine code.","pos":[2317,2419]},{"content":"This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.","pos":[2420,2687]},{"content":"Conventional profiling mechanisms cannot identify or provide useful information about these features.","pos":[2688,2789]},{"content":"The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.","pos":[2790,2934]},{"content":"JIT compilation at run time provides good opportunities for profiling.","pos":[2941,3011]},{"content":"The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.","pos":[3012,3130]},{"content":"In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.","pos":[3131,3255]},{"content":"Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.","pos":[3256,3388]},{"content":"This overview consists of the following sections:","pos":[3395,3444]},{"pos":[3454,3489],"content":"<bpt id=\"p1\">[</bpt>The Profiling API<ept id=\"p1\">](#profiling_api)</ept>","source":"[The Profiling API](#profiling_api)"},{"pos":[3499,3529],"content":"<bpt id=\"p1\">[</bpt>Supported Features<ept id=\"p1\">](#support)</ept>","source":"[Supported Features](#support)"},{"pos":[3539,3584],"content":"<bpt id=\"p1\">[</bpt>Notification Threads<ept id=\"p1\">](#notification_threads)</ept>","source":"[Notification Threads](#notification_threads)"},{"pos":[3594,3615],"content":"<bpt id=\"p1\">[</bpt>Security<ept id=\"p1\">](#security)</ept>","source":"[Security](#security)"},{"pos":[3625,3712],"content":"<bpt id=\"p1\">[</bpt>Combining Managed and Unmanaged Code in a Code Profiler<ept id=\"p1\">](#combining_managed_unmanaged)</ept>","source":"[Combining Managed and Unmanaged Code in a Code Profiler](#combining_managed_unmanaged)"},{"pos":[3722,3760],"content":"<bpt id=\"p1\">[</bpt>Profiling Unmanaged Code<ept id=\"p1\">](#unmanaged)</ept>","source":"[Profiling Unmanaged Code](#unmanaged)"},{"pos":[3770,3787],"content":"<bpt id=\"p1\">[</bpt>Using COM<ept id=\"p1\">](#com)</ept>","source":"[Using COM](#com)"},{"pos":[3797,3824],"content":"<bpt id=\"p1\">[</bpt>Call stacks<ept id=\"p1\">](#call_stacks)</ept>","source":"[Call stacks](#call_stacks)"},{"pos":[3834,3873],"content":"<bpt id=\"p1\">[</bpt>Callbacks and Stack Depth<ept id=\"p1\">](#callbacks)</ept>","source":"[Callbacks and Stack Depth](#callbacks)"},{"pos":[3883,3916],"content":"<bpt id=\"p1\">[</bpt>Related Topics<ept id=\"p1\">](#related_topics)</ept>","source":"[Related Topics](#related_topics)"},{"pos":[3957,3974],"content":"The Profiling API","linkify":"The Profiling API","nodes":[{"content":"The Profiling API","pos":[0,17]}]},{"pos":[3978,4115],"content":"Typically, the profiling API is used to write a <bpt id=\"p1\">*</bpt>code profiler<ept id=\"p1\">*</ept>, which is a program that monitors the execution of a managed application.","source":"Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application."},{"content":"The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.","pos":[4122,4247]},{"content":"The profiler DLL implements a callback interface (<bpt id=\"p1\">[</bpt>ICorProfilerCallback<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> in the .NET Framework version 1.0 and 1.1, <bpt id=\"p2\">[</bpt>ICorProfilerCallback2<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept> in version 2.0 and later).","pos":[4248,4587],"source":" The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later)."},{"content":"The CLR calls the methods in that interface to notify the profiler of events in the profiled process.","pos":[4588,4689]},{"content":"The profiler can call back into the runtime by using the methods in the <bpt id=\"p1\">[</bpt>ICorProfilerInfo<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)</ept> and <bpt id=\"p2\">[</bpt>ICorProfilerInfo2<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)</ept> interfaces to obtain information about the state of the profiled application.","pos":[4690,5047],"source":" The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application."},{"pos":[5055,5266],"content":"[!NOTE]\n Only the data-gathering part of the profiler solution should be running in the same process as the profiled application. All user interface and data analysis should be performed in a separate process.","leadings":["","> "],"nodes":[{"content":"Only the data-gathering part of the profiler solution should be running in the same process as the profiled application. All user interface and data analysis should be performed in a separate process.","pos":[9,209],"nodes":[{"content":"Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.","pos":[0,120]},{"content":"All user interface and data analysis should be performed in a separate process.","pos":[121,200]}]}]},{"content":"The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.","pos":[5273,5393]},{"content":"Screenshot that shows the profiling architecture.","pos":[5402,5451]},{"pos":[5517,5544],"content":"The Notification Interfaces","linkify":"The Notification Interfaces","nodes":[{"content":"The Notification Interfaces","pos":[0,27]}]},{"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> and <bpt id=\"p2\">[</bpt>ICorProfilerCallback2<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept> can be considered notification interfaces.","pos":[5548,5814],"source":"[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces."},{"content":"These interfaces consist of methods such as <bpt id=\"p1\">[</bpt>ClassLoadStarted<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md)</ept>, <bpt id=\"p2\">[</bpt>ClassLoadFinished<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md)</ept>, and <bpt id=\"p3\">[</bpt>JITCompilationStarted<ept id=\"p3\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md)</ept>.","pos":[5815,6234],"source":" These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md)."},{"content":"Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's <ph id=\"ph1\">`ICorProfilerCallback`</ph> or <ph id=\"ph2\">`ICorProfilerCallback2`</ph> interface.","pos":[6235,6423],"source":" Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface."},{"content":"For example, a profiler could measure code performance through two notification functions: <bpt id=\"p1\">[</bpt>FunctionEnter2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md)</ept> and <bpt id=\"p2\">[</bpt>FunctionLeave2<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md)</ept>.","pos":[6430,6717],"source":"For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md)."},{"content":"It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.","pos":[6718,6909]},{"pos":[6919,6955],"content":"The Information Retrieval Interfaces","linkify":"The Information Retrieval Interfaces","nodes":[{"content":"The Information Retrieval Interfaces","pos":[0,36]}]},{"content":"The other main interfaces involved in profiling are <bpt id=\"p1\">[</bpt>ICorProfilerInfo<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)</ept> and <bpt id=\"p2\">[</bpt>ICorProfilerInfo2<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)</ept>.","pos":[6959,7219],"source":"The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)."},{"content":"The profiler calls these interfaces as required to obtain more information to help its analysis.","pos":[7220,7316]},{"content":"For example, whenever the CLR calls the <bpt id=\"p1\">[</bpt>FunctionEnter2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md)</ept> function, it supplies a function identifier.","pos":[7317,7497],"source":" For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier."},{"content":"The profiler can get more information about that function by calling the <bpt id=\"p1\">[</bpt>ICorProfilerInfo2::GetFunctionInfo2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md)</ept> method to discover the function's parent class, its name, and so on.","pos":[7498,7774],"source":" The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on."},{"pos":[7781,7800],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[7835,7853],"content":"Supported Features","linkify":"Supported Features","nodes":[{"content":"Supported Features","pos":[0,18]}]},{"content":"The profiling API provides information about a variety of events and actions that occur in the common language runtime.","pos":[7857,7976]},{"content":"You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.","pos":[7977,8115]},{"content":"The profiling API retrieves information about the following actions and events that occur in the CLR:","pos":[8122,8223]},{"content":"CLR startup and shutdown events.","pos":[8233,8265]},{"content":"Application domain creation and shutdown events.","pos":[8275,8323]},{"content":"Assembly loading and unloading events.","pos":[8333,8371]},{"content":"Module loading and unloading events.","pos":[8381,8417]},{"content":"COM vtable creation and destruction events.","pos":[8427,8470]},{"content":"Just-in-time (JIT) compilation and code-pitching events.","pos":[8480,8536]},{"content":"Class loading and unloading events.","pos":[8546,8581]},{"content":"Thread creation and destruction events.","pos":[8591,8630]},{"content":"Function entry and exit events.","pos":[8640,8671]},{"content":"Exceptions.","pos":[8681,8692]},{"content":"Transitions between managed and unmanaged code execution.","pos":[8702,8759]},{"content":"Transitions between different runtime contexts.","pos":[8769,8816]},{"content":"Information about runtime suspensions.","pos":[8826,8864]},{"content":"Information about the runtime memory heap and garbage collection activity.","pos":[8874,8948]},{"content":"The profiling API can be called from any (non-managed) COM-compatible language.","pos":[8955,9034]},{"content":"The API is efficient with regard to CPU and memory consumption.","pos":[9041,9104]},{"content":"Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.","pos":[9105,9224]},{"content":"The profiling API is useful to both sampling and non-sampling profilers.","pos":[9231,9303]},{"content":"A <bpt id=\"p1\">*</bpt>sampling profiler<ept id=\"p1\">*</ept> inspects the profile at regular clock ticks, say, at 5 milliseconds apart.","pos":[9304,9400],"source":" A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart."},{"content":"A <bpt id=\"p1\">*</bpt>non-sampling profiler<ept id=\"p1\">*</ept> is informed of an event synchronously with the thread that causes the event.","pos":[9401,9503],"source":" A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event."},{"pos":[9513,9538],"content":"Unsupported Functionality","linkify":"Unsupported Functionality","nodes":[{"content":"Unsupported Functionality","pos":[0,25]}]},{"content":"The profiling API does not support the following functionality:","pos":[9542,9605]},{"content":"Unmanaged code, which must be profiled using conventional Win32 methods.","pos":[9615,9687]},{"content":"However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.","pos":[9688,9804]},{"content":"Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.","pos":[9814,9918]},{"content":"Bounds checking, because the profiling API does not provide this information.","pos":[9928,10005]},{"content":"The CLR provides intrinsic support for bounds checking of all managed code.","pos":[10006,10081]},{"content":"Remote profiling, which is not supported for the following reasons:","pos":[10091,10158]},{"content":"Remote profiling extends execution time.","pos":[10172,10212]},{"content":"When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.","pos":[10213,10339]},{"content":"This is especially true when execution performance is being monitored.","pos":[10340,10410]},{"content":"However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.","pos":[10411,10593]},{"content":"The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.","pos":[10607,10759]},{"content":"This limits the ability to create a remote code profiler.","pos":[10760,10817]},{"content":"Profiling in production environments with high-availability requirements.","pos":[10827,10900]},{"content":"The profiling API was created to support development-time diagnostics.","pos":[10901,10971]},{"content":"It has not undergone the rigorous testing required to support production environments.","pos":[10972,11058]},{"pos":[11065,11084],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[11132,11152],"content":"Notification Threads","linkify":"Notification Threads","nodes":[{"content":"Notification Threads","pos":[0,20]}]},{"content":"In most cases, the thread that generates an event also executes notifications.","pos":[11156,11234]},{"content":"Such notifications (for example, <bpt id=\"p1\">[</bpt>FunctionEnter<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md)</ept> and <bpt id=\"p2\">[</bpt>FunctionLeave<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)</ept>) do not need to supply the explicit <ph id=\"ph1\">`ThreadID`</ph>.","pos":[11235,11507],"source":" Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`."},{"content":"Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the <ph id=\"ph1\">`ThreadID`</ph> of the affected thread.","pos":[11508,11714],"source":" Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread."},{"content":"Note that these callbacks are not serialized.","pos":[11721,11766]},{"content":"Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.","pos":[11767,11935]},{"content":"Therefore, in certain cases you can receive an unusual sequence of callbacks.","pos":[11936,12013]},{"content":"For example, assume that a managed application is spawning two threads that are executing identical code.","pos":[12014,12119]},{"content":"In this case, it is possible to receive a <bpt id=\"p1\">[</bpt>ICorProfilerCallback::JITCompilationStarted<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md)</ept> event for some function from one thread and a <ph id=\"ph1\">`FunctionEnter`</ph> callback from the other thread before receiving the <bpt id=\"p2\">[</bpt>ICorProfilerCallback::JITCompilationFinished<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md)</ept> callback.","pos":[12120,12589],"source":" In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback."},{"content":"In this case, the user will receive a <ph id=\"ph1\">`FunctionEnter`</ph> callback for a function that may not have been fully just-in-time (JIT) compiled yet.","pos":[12590,12729],"source":" In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet."},{"pos":[12736,12755],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[12791,12799],"content":"Security","linkify":"Security","nodes":[{"content":"Security","pos":[0,8]}]},{"content":"A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.","pos":[12803,12904]},{"content":"As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.","pos":[12905,13014]},{"content":"The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.","pos":[13015,13150]},{"content":"Profiler authors should take appropriate precautions to avoid security-related issues.","pos":[13157,13243]},{"content":"For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.","pos":[13244,13383]},{"pos":[13390,13409],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[13464,13519],"content":"Combining Managed and Unmanaged Code in a Code Profiler","linkify":"Combining Managed and Unmanaged Code in a Code Profiler","nodes":[{"content":"Combining Managed and Unmanaged Code in a Code Profiler","pos":[0,55]}]},{"content":"An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.","pos":[13523,13632]},{"content":"A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.","pos":[13639,13835]},{"content":"Although this is possible from a design perspective, the profiling API does not support managed components.","pos":[13842,13949]},{"content":"A CLR profiler must be completely unmanaged.","pos":[13950,13994]},{"content":"Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.","pos":[13995,14119]},{"content":"The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.","pos":[14120,14305]},{"content":"The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.","pos":[14312,14446]},{"content":"The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the <bpt id=\"p1\">[</bpt>ICorProfilerCallback4<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)</ept> interface.","pos":[14447,14669],"source":" The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface."},{"content":"It is also possible to use the older instrumentation methods to modify MSIL.","pos":[14676,14752]},{"content":"Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the <bpt id=\"p1\">[</bpt>ICorProfilerInfo::GetILFunctionBody<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md)</ept> method).","pos":[14753,15066],"source":" Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method)."},{"content":"This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.","pos":[15067,15213]},{"content":"Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.","pos":[15220,15349]},{"content":"This technique can be used for instrumentation and coverage.","pos":[15350,15410]},{"content":"For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.","pos":[15411,15541]},{"content":"The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.","pos":[15542,15685]},{"pos":[15692,15711],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[15748,15772],"content":"Profiling Unmanaged Code","linkify":"Profiling Unmanaged Code","nodes":[{"content":"Profiling Unmanaged Code","pos":[0,24]}]},{"content":"The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.","pos":[15776,15878]},{"content":"The following functionality is provided:","pos":[15879,15919]},{"content":"Enumeration of stack chains.","pos":[15929,15957]},{"content":"This feature enables a code profiler to determine the boundary between managed code and unmanaged code.","pos":[15958,16061]},{"content":"Determination whether a stack chain corresponds to managed code or native code.","pos":[16071,16150]},{"content":"In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.","pos":[16157,16284]},{"content":"They are defined in the CorDebug.idl file.","pos":[16285,16327]},{"pos":[16334,16550],"content":"In the .NET Framework 2.0 and later, you can use the <bpt id=\"p1\">[</bpt>ICorProfilerInfo2::DoStackSnapshot<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md)</ept> method for this functionality.","source":"In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality."},{"pos":[16557,16576],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[16607,16616],"content":"Using COM","linkify":"Using COM","nodes":[{"content":"Using COM","pos":[0,9]}]},{"content":"Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.","pos":[16620,16776]},{"content":"The reason is to avoid having to set the threading model by using the <bpt id=\"p1\">[</bpt>CoInitialize<ept id=\"p1\">](/windows/desktop/api/objbase/nf-objbase-coinitialize)</ept> function before the managed application has had a chance to specify its desired threading model.","pos":[16777,17012],"source":" The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model."},{"content":"Similarly, the profiler itself should not call <ph id=\"ph1\">`CoInitialize`</ph>, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.","pos":[17013,17209],"source":" Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail."},{"pos":[17216,17235],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[17274,17285],"content":"Call Stacks","linkify":"Call Stacks","nodes":[{"content":"Call Stacks","pos":[0,11]}]},{"content":"The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.","pos":[17289,17492]},{"pos":[17502,17516],"content":"Stack Snapshot","linkify":"Stack Snapshot","nodes":[{"content":"Stack Snapshot","pos":[0,14]}]},{"content":"A stack snapshot is a trace of the stack of a thread at an instant in time.","pos":[17520,17595]},{"content":"The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.","pos":[17596,17754]},{"pos":[17761,18136],"content":"For more information about how to program the profiler to walk managed stacks, see the <bpt id=\"p1\">[</bpt>ICorProfilerInfo2::DoStackSnapshot<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md)</ept> method in this documentation set, and <bpt id=\"p2\">[</bpt>Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond<ept id=\"p2\">](https://go.microsoft.com/fwlink/?LinkId=73638)</ept>.","source":"For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638)."},{"pos":[18144,18156],"content":"Shadow Stack","linkify":"Shadow Stack","nodes":[{"content":"Shadow Stack","pos":[0,12]}]},{"content":"Using the snapshot method too frequently can quickly create a performance issue.","pos":[18160,18240]},{"content":"If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the <bpt id=\"p1\">[</bpt>FunctionEnter2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md)</ept>, <bpt id=\"p2\">[</bpt>FunctionLeave2<ept id=\"p2\">](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md)</ept>, <bpt id=\"p3\">[</bpt>FunctionTailcall2<ept id=\"p3\">](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md)</ept>, and <bpt id=\"p4\">[</bpt>ICorProfilerCallback2<ept id=\"p4\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept> exception callbacks.","pos":[18241,18781],"source":" If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks."},{"content":"The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.","pos":[18782,18890]},{"content":"A shadow stack may obtain function arguments, return values, and information about generic instantiations.","pos":[18897,19003]},{"content":"This information is available only through the shadow stack and may be obtained when control is handed to a function.","pos":[19004,19121]},{"content":"However, this information may not be available later during the run of the function.","pos":[19122,19206]},{"pos":[19213,19232],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[19269,19294],"content":"Callbacks and Stack Depth","linkify":"Callbacks and Stack Depth","nodes":[{"content":"Callbacks and Stack Depth","pos":[0,25]}]},{"content":"Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.","pos":[19298,19455]},{"content":"A profiler should make sure to use as little stack as possible in response to callbacks.","pos":[19456,19544]},{"content":"If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.","pos":[19545,19703]},{"pos":[19710,19729],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[19771,19785],"content":"Related Topics","linkify":"Related Topics","nodes":[{"content":"Related Topics","pos":[0,14]}]},{"content":"Title","pos":[19792,19797]},{"content":"Description","pos":[19798,19809]},{"pos":[19848,19974],"content":"<bpt id=\"p1\">[</bpt>Setting Up a Profiling Environment<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)</ept>","source":"[Setting Up a Profiling Environment](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)"},{"content":"Explains how to initialize a profiler, set event notifications, and profile a Windows Service.","pos":[19975,20069]},{"pos":[20074,20172],"content":"<bpt id=\"p1\">[</bpt>Profiling Interfaces<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)</ept>","source":"[Profiling Interfaces](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)"},{"content":"Describes the unmanaged interfaces that the profiling API uses.","pos":[20173,20236]},{"pos":[20241,20365],"content":"<bpt id=\"p1\">[</bpt>Profiling Global Static Functions<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)</ept>","source":"[Profiling Global Static Functions](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)"},{"content":"Describes the unmanaged global static functions that the profiling API uses.","pos":[20366,20442]},{"pos":[20447,20549],"content":"<bpt id=\"p1\">[</bpt>Profiling Enumerations<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)</ept>","source":"[Profiling Enumerations](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)"},{"content":"Describes the unmanaged enumerations that the profiling API uses.","pos":[20550,20615]},{"pos":[20620,20718],"content":"<bpt id=\"p1\">[</bpt>Profiling Structures<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)</ept>","source":"[Profiling Structures](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)"},{"content":"Describes the unmanaged structures that the profiling API uses.","pos":[20719,20782]}]}