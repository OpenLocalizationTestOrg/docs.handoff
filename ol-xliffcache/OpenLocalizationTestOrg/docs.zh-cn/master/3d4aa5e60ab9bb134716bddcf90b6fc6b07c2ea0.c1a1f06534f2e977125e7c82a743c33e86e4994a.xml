{"content":"---\ntitle: Delegates and lambdas\ndescription: Learn how delegates define a type, which specify a particular method signature, that can be called directly or passed to another method and called.\nauthor: richlander\nms.author: wiwagn\nms.date: 06/20/2016\nms.technology: dotnet-standard\nms.assetid: fe2e4b4c-6483-4106-a4b4-a33e2e306591\n---\n# Delegates and lambdas\n\nDelegates define a type, which specify a particular method signature. A method (static or instance) that satisfies this signature can be assigned to a variable of that type, then called directly (with the appropriate arguments) or passed as an argument itself to another method and then called. The following example demonstrates delegate use.\n\n```csharp\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public delegate string Reverse(string s);\n\n    static string ReverseString(string s)\n    {\n        return new string(s.Reverse().ToArray());\n    }\n\n    static void Main(string[] args)\n    {\n        Reverse rev = ReverseString;\n\n        Console.WriteLine(rev(\"a string\"));\n    }\n}\n```\n\n* The `public delegate string Reverse(string s);` line creates a delegate type of a certain signature, in this case a method that takes a string parameter and then returns a string parameter.\n* The `static string ReverseString(string s)` method, which has the exact same signature as the defined delegate type, implements the delegate.\n* The `Reverse rev = ReverseString;` line shows that you can assign a method to a variable of the corresponding delegate type.\n* The `Console.WriteLine(rev(\"a string\"));` line demonstrates how to use a variable of a delegate type to invoke the delegate.\n\nIn order to streamline the development process, .NET includes a set of delegate types that programmers can reuse and not have to create new types. These are `Func<>`, `Action<>` and `Predicate<>`, and they can be used in various places throughout the .NET APIs without the need to define new delegate types. Of course, there are some differences between the three as you will see in their signatures which mostly have to do with the way they were meant to be used:\n\n*   `Action<>` is used when there is a need to perform an action using the arguments of the delegate.\n*   `Func<>` is used usually when you have a transformation on hand, that is, you need to transform the arguments of the delegate into a different result. Projections are a prime example of this.\n*   `Predicate<>` is used when you need to determine if the argument satisfies the condition of the delegate. It can also be written as a `Func<T, bool>`.\n\nWe can now take our example above and rewrite it using the `Func<>` delegate instead of a custom type. The program will continue running exactly the same.\n\n```csharp\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    static string ReverseString(string s)\n    {\n        return new string(s.Reverse().ToArray());\n    }\n\n    static void Main(string[] args)\n    {\n        Func<string, string> rev = ReverseString;\n\n        Console.WriteLine(rev(\"a string\"));\n    }\n}\n```\n\nFor this simple example, having a method defined outside of the `Main` method seems a bit superfluous. It is because of this that .NET Framework 2.0 introduced the concept of **anonymous delegates**. With their support you are able to create \"inline\" delegates without having to specify any additional type or method. You simply inline the definition of the delegate where you need it.\n\nFor an example, we are going to switch it up and use our anonymous delegate to filter out a list of only even numbers and then print them to the console.\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        List<int> list = new List<int>();\n\n        for (int i = 1; i <= 100; i++)\n        {\n            list.Add(i);\n        }\n\n        List<int> result = list.FindAll(\n          delegate (int no)\n          {\n              return (no % 2 == 0);\n          }\n        );\n\n        foreach (var item in result)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n```\n\nAs you can see, the body of the delegate is just a set of expressions, as any other delegate. But instead of it being a separate definition, we’ve introduced it _ad hoc_ in our call to the <xref:System.Collections.Generic.List%601.FindAll%2A?displayProperty=nameWithType> method.\n\nHowever, even with this approach, there is still much code that we can throw away. This is where **lambda expressions** come into play.\n\nLambda expressions, or just \"lambdas\" for short, were introduced first in C# 3.0, as one of the core building blocks of Language Integrated Query (LINQ). They are just a more convenient syntax for using delegates. They declare a signature and a method body, but don’t have an formal identity of their own, unless they are assigned to a delegate. Unlike delegates, they can be directly assigned as the left-hand side of event registration or in various LINQ clauses and methods.\n\nSince a lambda expression is just another way of specifying a delegate, we should be able to rewrite the above sample to use a lambda expression instead of an anonymous delegate.\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        List<int> list = new List<int>();\n\n        for (int i = 1; i <= 100; i++)\n        {\n            list.Add(i);\n        }\n\n        List<int> result = list.FindAll(i => i % 2 == 0);\n\n        foreach (var item in result)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n```\n\nIn the preceding example, the lambda expression used is `i => i % 2 == 0`. Again, it is just a **very** convenient syntax for using delegates, so what happens under the covers is similar to what happens with the anonymous delegate.\n\nAgain, lambdas are just delegates, which means that they can be used as an event handler without any problems, as the following code snippet illustrates.\n\n```csharp\npublic MainWindow()\n{\n    InitializeComponent();\n\n    Loaded += (o, e) =>\n    {\n        this.Title = \"Loaded\";\n    };\n}\n```\n\nThe `+=` operator in this context is used to subscribe to an [event](../../docs/csharp/language-reference/keywords/event.md). For more information, see [How to: Subscribe to and Unsubscribe from Events](../../docs/csharp/programming-guide/events/how-to-subscribe-to-and-unsubscribe-from-events.md).\n\n## Further reading and resources\n\n*   [Delegates](../../docs/csharp/programming-guide/delegates/index.md)\n*   [Anonymous Functions](../../docs/csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)\n*   [Lambda expressions](../../docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)\n","nodes":[{"pos":[4,330],"embed":true,"restype":"x-metadata","content":"title: Delegates and lambdas\ndescription: Learn how delegates define a type, which specify a particular method signature, that can be called directly or passed to another method and called.\nauthor: richlander\nms.author: wiwagn\nms.date: 06/20/2016\nms.technology: dotnet-standard\nms.assetid: fe2e4b4c-6483-4106-a4b4-a33e2e306591","nodes":[{"content":"Delegates and lambdas","nodes":[{"pos":[0,21],"content":"Delegates and lambdas","nodes":[{"content":"Delegates and lambdas","pos":[0,21]}]}],"path":["title"],"nosxs":false},{"content":"Learn how delegates define a type, which specify a particular method signature, that can be called directly or passed to another method and called.","nodes":[{"pos":[0,147],"content":"Learn how delegates define a type, which specify a particular method signature, that can be called directly or passed to another method and called.","nodes":[{"content":"Learn how delegates define a type, which specify a particular method signature, that can be called directly or passed to another method and called.","pos":[0,147]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[337,358],"content":"Delegates and lambdas","linkify":"Delegates and lambdas","nodes":[{"content":"Delegates and lambdas","pos":[0,21]}]},{"content":"Delegates define a type, which specify a particular method signature.","pos":[360,429]},{"content":"A method (static or instance) that satisfies this signature can be assigned to a variable of that type, then called directly (with the appropriate arguments) or passed as an argument itself to another method and then called.","pos":[430,654]},{"content":"The following example demonstrates delegate use.","pos":[655,703]},{"pos":[1063,1252],"content":"The <ph id=\"ph1\">`public delegate string Reverse(string s);`</ph> line creates a delegate type of a certain signature, in this case a method that takes a string parameter and then returns a string parameter.","source":"The `public delegate string Reverse(string s);` line creates a delegate type of a certain signature, in this case a method that takes a string parameter and then returns a string parameter."},{"pos":[1255,1396],"content":"The <ph id=\"ph1\">`static string ReverseString(string s)`</ph> method, which has the exact same signature as the defined delegate type, implements the delegate.","source":"The `static string ReverseString(string s)` method, which has the exact same signature as the defined delegate type, implements the delegate."},{"pos":[1399,1523],"content":"The <ph id=\"ph1\">`Reverse rev = ReverseString;`</ph> line shows that you can assign a method to a variable of the corresponding delegate type.","source":"The `Reverse rev = ReverseString;` line shows that you can assign a method to a variable of the corresponding delegate type."},{"pos":[1526,1650],"content":"The <ph id=\"ph1\">`Console.WriteLine(rev(\"a string\"));`</ph> line demonstrates how to use a variable of a delegate type to invoke the delegate.","source":"The `Console.WriteLine(rev(\"a string\"));` line demonstrates how to use a variable of a delegate type to invoke the delegate."},{"content":"In order to streamline the development process, .NET includes a set of delegate types that programmers can reuse and not have to create new types.","pos":[1652,1798]},{"content":"These are <ph id=\"ph1\">`Func&lt;&gt;`</ph>, <ph id=\"ph2\">`Action&lt;&gt;`</ph> and <ph id=\"ph3\">`Predicate&lt;&gt;`</ph>, and they can be used in various places throughout the .NET APIs without the need to define new delegate types.","pos":[1799,1959],"source":" These are `Func<>`, `Action<>` and `Predicate<>`, and they can be used in various places throughout the .NET APIs without the need to define new delegate types."},{"content":"Of course, there are some differences between the three as you will see in their signatures which mostly have to do with the way they were meant to be used:","pos":[1960,2116]},{"pos":[2122,2219],"content":"<ph id=\"ph1\">`Action&lt;&gt;`</ph> is used when there is a need to perform an action using the arguments of the delegate.","source":"`Action<>` is used when there is a need to perform an action using the arguments of the delegate."},{"content":"<ph id=\"ph1\">`Func&lt;&gt;`</ph> is used usually when you have a transformation on hand, that is, you need to transform the arguments of the delegate into a different result.","pos":[2224,2374],"source":"`Func<>` is used usually when you have a transformation on hand, that is, you need to transform the arguments of the delegate into a different result."},{"content":"Projections are a prime example of this.","pos":[2375,2415]},{"content":"<ph id=\"ph1\">`Predicate&lt;&gt;`</ph> is used when you need to determine if the argument satisfies the condition of the delegate.","pos":[2420,2525],"source":"`Predicate<>` is used when you need to determine if the argument satisfies the condition of the delegate."},{"content":"It can also be written as a <ph id=\"ph1\">`Func&lt;T, bool&gt;`</ph>.","pos":[2526,2570],"source":" It can also be written as a `Func<T, bool>`."},{"content":"We can now take our example above and rewrite it using the <ph id=\"ph1\">`Func&lt;&gt;`</ph> delegate instead of a custom type.","pos":[2572,2674],"source":"We can now take our example above and rewrite it using the `Func<>` delegate instead of a custom type."},{"content":"The program will continue running exactly the same.","pos":[2675,2726]},{"content":"For this simple example, having a method defined outside of the <ph id=\"ph1\">`Main`</ph> method seems a bit superfluous.","pos":[3050,3152],"source":"For this simple example, having a method defined outside of the `Main` method seems a bit superfluous."},{"content":"It is because of this that .NET Framework 2.0 introduced the concept of <bpt id=\"p1\">**</bpt>anonymous delegates<ept id=\"p1\">**</ept>.","pos":[3153,3249],"source":" It is because of this that .NET Framework 2.0 introduced the concept of **anonymous delegates**."},{"content":"With their support you are able to create \"inline\" delegates without having to specify any additional type or method.","pos":[3250,3367]},{"content":"You simply inline the definition of the delegate where you need it.","pos":[3368,3435]},{"content":"For an example, we are going to switch it up and use our anonymous delegate to filter out a list of only even numbers and then print them to the console.","pos":[3437,3590]},{"content":"As you can see, the body of the delegate is just a set of expressions, as any other delegate.","pos":[4099,4192]},{"content":"But instead of it being a separate definition, we’ve introduced it <bpt id=\"p1\">_</bpt>ad hoc<ept id=\"p1\">_</ept> in our call to the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601.FindAll%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[4193,4378],"source":" But instead of it being a separate definition, we’ve introduced it _ad hoc_ in our call to the <xref:System.Collections.Generic.List%601.FindAll%2A?displayProperty=nameWithType> method."},{"content":"However, even with this approach, there is still much code that we can throw away.","pos":[4380,4462]},{"content":"This is where <bpt id=\"p1\">**</bpt>lambda expressions<ept id=\"p1\">**</ept> come into play.","pos":[4463,4515],"source":" This is where **lambda expressions** come into play."},{"content":"Lambda expressions, or just \"lambdas\" for short, were introduced first in C# 3.0, as one of the core building blocks of Language Integrated Query (LINQ).","pos":[4517,4670]},{"content":"They are just a more convenient syntax for using delegates.","pos":[4671,4730]},{"content":"They declare a signature and a method body, but don’t have an formal identity of their own, unless they are assigned to a delegate.","pos":[4731,4862]},{"content":"Unlike delegates, they can be directly assigned as the left-hand side of event registration or in various LINQ clauses and methods.","pos":[4863,4994]},{"content":"Since a lambda expression is just another way of specifying a delegate, we should be able to rewrite the above sample to use a lambda expression instead of an anonymous delegate.","pos":[4996,5174]},{"content":"In the preceding example, the lambda expression used is <ph id=\"ph1\">`i =&gt; i % 2 == 0`</ph>.","pos":[5601,5675],"source":"In the preceding example, the lambda expression used is `i => i % 2 == 0`."},{"content":"Again, it is just a <bpt id=\"p1\">**</bpt>very<ept id=\"p1\">**</ept> convenient syntax for using delegates, so what happens under the covers is similar to what happens with the anonymous delegate.","pos":[5676,5832],"source":" Again, it is just a **very** convenient syntax for using delegates, so what happens under the covers is similar to what happens with the anonymous delegate."},{"content":"Again, lambdas are just delegates, which means that they can be used as an event handler without any problems, as the following code snippet illustrates.","pos":[5834,5987]},{"content":"The <ph id=\"ph1\">`+=`</ph> operator in this context is used to subscribe to an <bpt id=\"p1\">[</bpt>event<ept id=\"p1\">](../../docs/csharp/language-reference/keywords/event.md)</ept>.","pos":[6124,6249],"source":"The `+=` operator in this context is used to subscribe to an [event](../../docs/csharp/language-reference/keywords/event.md)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Subscribe to and Unsubscribe from Events<ept id=\"p1\">](../../docs/csharp/programming-guide/events/how-to-subscribe-to-and-unsubscribe-from-events.md)</ept>.","pos":[6250,6422],"source":" For more information, see [How to: Subscribe to and Unsubscribe from Events](../../docs/csharp/programming-guide/events/how-to-subscribe-to-and-unsubscribe-from-events.md)."},{"pos":[6427,6456],"content":"Further reading and resources","linkify":"Further reading and resources","nodes":[{"content":"Further reading and resources","pos":[0,29]}]},{"pos":[6462,6529],"content":"<bpt id=\"p1\">[</bpt>Delegates<ept id=\"p1\">](../../docs/csharp/programming-guide/delegates/index.md)</ept>","source":"[Delegates](../../docs/csharp/programming-guide/delegates/index.md)"},{"pos":[6534,6648],"content":"<bpt id=\"p1\">[</bpt>Anonymous Functions<ept id=\"p1\">](../../docs/csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)</ept>","source":"[Anonymous Functions](../../docs/csharp/programming-guide/statements-expressions-operators/anonymous-functions.md)"},{"pos":[6653,6765],"content":"<bpt id=\"p1\">[</bpt>Lambda expressions<ept id=\"p1\">](../../docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)</ept>","source":"[Lambda expressions](../../docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)"}]}