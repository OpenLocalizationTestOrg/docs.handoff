{"content":"---\ntitle: \"Creating a custom header that is signed and-or encrypted | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: e8668b37-c79f-4714-9de5-afcb88b9ff02\ncaps.latest.revision: 4\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Creating a custom header that is signed and-or encrypted\nWhen calling a non-WCF service using a WCF client it is sometimes necessary to use custom SOAP headers. There is a canonicalization bug in WCF that prevents custom headers that are signed and encrypted from working with a non-WCF service. The problem is caused by the incorrect canonicalization of default XML namespaces. This is only problematic when calling non-WCF services with custom headers that are signed and/or encrypted.  When the service receives the message containing the signed and/or encrypted custom header it is unable to verify the signature. This workaround avoids the canonicalization bug, allows interoperability with non-WCF services, but does not prevent interoperability with WCF services.  \n  \n## Defining the custom header  \n Custom headers are defined by defining a message contract and marking the members you want to be sent as headers with a <xref:System.ServiceModel.MessageHeaderAttribute> attribute. To work around the canonicalization bug you must ensure that the XML serializer declares the namespace for the custom header with a prefix instead of a default namespace declaration. The following code shows how to define the data type that will be used as a message header with the correct namespace declaration.  \n  \n```  \n[System.CodeDom.Compiler.GeneratedCodeAttribute(\"svcutil\", \"3.0.4506.648\")]  \n[System.SerializableAttribute()]  \n[System.Diagnostics.DebuggerStepThroughAttribute()]  \n[System.ComponentModel.DesignerCategoryAttribute(\"code\")]  \n[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace=\"http://www.example.org/getMessage/\")]  \npublic partial class msgHeaderElement  \n{  \n   // Define the XML namespace and force it to use an ‘h’ prefix  \n    [System.Xml.Serialization.XmlNamespaceDeclarations]  \n    public System.Xml.Serialization.XmlSerializerNamespaces _xsns = new System.Xml.Serialization.XmlSerializerNamespaces(new System.Xml.XmlQualifiedName[] { new System.Xml.XmlQualifiedName(\"h\", \"http://www.example.org/getMessage/\") });  \n  \n    private string msgHeaderInputField;  \n  [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, Order=0)]  \n    public string msgHeaderInput  \n    {  \n        get  \n        {  \n            return this.msgHeaderInputField;  \n        }  \n        set  \n        {  \n            this.msgHeaderInputField = value;  \n        }  \n    }  \n}  \n```  \n  \n This code declares a new type called `msgHeaderElement` that will be serialized with the XML Serializer. When an instance of this type is serialized, it will define a namespace with an ‘h’ prefix, thus working around the canonicalization bug.  The message contract would then define an instance of `msgHeaderElement` and mark it with the <xref:System.ServiceModel.MessageHeaderAttribute> attribute as shown in the following example.  \n  \n```  \n[MessageContract]  \npublic  class MyMessageContract  \n{  \n   // other message contents...  \n   [MessageHeader(ProductionLevel=ProtectionLevel.EncryptAndSign)]  \n   public msgHeaderElement;  \n   // other message contents...  \n}  \n  \n```  \n  \n## See Also  \n [Default Message Contract](../../../../docs/framework/wcf/samples/default-message-contract.md)   \n [Message Contracts](../../../../docs/framework/wcf/samples/message-contracts.md)   \n [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)","nodes":[{"pos":[4,376],"nodes":[{"content":"Creating a custom header that is signed and-or encrypted | Microsoft Docs","nodes":[{"pos":[0,73],"content":"Creating a custom header that is signed and-or encrypted | Microsoft Docs","nodes":[{"content":"Creating a custom header that is signed and-or encrypted | Microsoft Docs","pos":[0,73]}]}],"pos":[6,82],"yaml":true}],"content":"title: \"Creating a custom header that is signed and-or encrypted | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: e8668b37-c79f-4714-9de5-afcb88b9ff02\ncaps.latest.revision: 4\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"","yamlblock":true},{"pos":[383,439],"content":"Creating a custom header that is signed and-or encrypted","linkify":"Creating a custom header that is signed and-or encrypted","nodes":[{"content":"Creating a custom header that is signed and-or encrypted","pos":[0,56]}]},{"content":"When calling a non-WCF service using a WCF client it is sometimes necessary to use custom SOAP headers.","pos":[440,543]},{"content":"There is a canonicalization bug in WCF that prevents custom headers that are signed and encrypted from working with a non-WCF service.","pos":[544,678]},{"content":"The problem is caused by the incorrect canonicalization of default XML namespaces.","pos":[679,761]},{"content":"This is only problematic when calling non-WCF services with custom headers that are signed and/or encrypted.","pos":[762,870]},{"content":"When the service receives the message containing the signed and/or encrypted custom header it is unable to verify the signature.","pos":[872,1000]},{"content":"This workaround avoids the canonicalization bug, allows interoperability with non-WCF services, but does not prevent interoperability with WCF services.","pos":[1001,1153]},{"pos":[1162,1188],"content":"Defining the custom header","linkify":"Defining the custom header","nodes":[{"content":"Defining the custom header","pos":[0,26]}]},{"content":"Custom headers are defined by defining a message contract and marking the members you want to be sent as headers with a <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> attribute.","pos":[1192,1372],"source":"Custom headers are defined by defining a message contract and marking the members you want to be sent as headers with a <xref:System.ServiceModel.MessageHeaderAttribute> attribute."},{"content":"To work around the canonicalization bug you must ensure that the XML serializer declares the namespace for the custom header with a prefix instead of a default namespace declaration.","pos":[1373,1555]},{"content":"The following code shows how to define the data type that will be used as a message header with the correct namespace declaration.","pos":[1556,1686]},{"content":"This code declares a new type called <ph id=\"ph1\">`msgHeaderElement`</ph> that will be serialized with the XML Serializer.","pos":[2837,2941],"source":"This code declares a new type called `msgHeaderElement` that will be serialized with the XML Serializer."},{"content":"When an instance of this type is serialized, it will define a namespace with an ‘h’ prefix, thus working around the canonicalization bug.","pos":[2942,3079]},{"content":"The message contract would then define an instance of <ph id=\"ph1\">`msgHeaderElement`</ph> and mark it with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> attribute as shown in the following example.","pos":[3081,3269],"source":"  The message contract would then define an instance of `msgHeaderElement` and mark it with the <xref:System.ServiceModel.MessageHeaderAttribute> attribute as shown in the following example."},{"pos":[3525,3533],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Default Message Contract<ept id=\"p1\">](../../../../docs/framework/wcf/samples/default-message-contract.md)</ept><ph id=\"ph1\"> </ph>","pos":[3537,3632],"source":"[Default Message Contract](../../../../docs/framework/wcf/samples/default-message-contract.md) "},{"content":"<bpt id=\"p1\">[</bpt>Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/samples/message-contracts.md)</ept><ph id=\"ph1\"> </ph>","pos":[3636,3717],"source":"[Message Contracts](../../../../docs/framework/wcf/samples/message-contracts.md) "},{"content":"<bpt id=\"p1\">[</bpt>Using Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)</ept>","pos":[3721,3821],"source":"[Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)"}]}