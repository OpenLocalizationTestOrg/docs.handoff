{"content":"---\ntitle: \"Service Versioning\"\nms.date: \"03/30/2017\"\nms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2\n---\n# Service Versioning\nAfter initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues. Each change introduces a new version of the service. This topic explains how to consider versioning in Windows Communication Foundation (WCF).  \n  \n## Four Categories of Service Changes  \n The changes to services that may be required can be classified into four categories:  \n  \n-   Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.  \n  \n-   Address changes: For example, a service moves to a different location where endpoints have new addresses.  \n  \n-   Binding changes: For example, a security mechanism changes or its settings change.  \n  \n-   Implementation changes: For example, when an internal method implementation changes.  \n  \n Some of these changes are called \"breaking\" and others are \"nonbreaking.\" A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version. Any change that does not meet that criterion is a *breaking* change.  \n  \n## Service Orientation and Versioning  \n One of the tenets of service orientation is that services and clients are autonomous (or independent). Among other things, this implies that service developers cannot assume that they control or even know about all service clients. This eliminates the option of rebuilding and redeploying all clients when a service changes versions. This topic assumes the service adheres to this tenet and therefore must be changed or \"versioned\" independent of its clients.  \n  \n In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.  \n  \n## Contract Versioning  \n Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.  \n  \n For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.  \n  \n For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways. Breaking changes might include removing data members or changing their data type incompatibly. This feature allows the service some latitude in changing the version of its contracts without breaking clients. The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.  \n  \n## Data Contract Versioning  \n This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.  \n  \n### Strict Versioning  \n In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema. In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:  \n  \n-   The old clients were developed with the assumption that the schema will not change. They may fail to process messages that they were never designed for.  \n  \n-   The old clients may perform actual schema validation against the old schema before even attempting to process the messages.  \n  \n The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names. The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.  \n  \n It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract. The appendix at the end of this topic explains how interfaces can be used to satisfy this need.  \n  \n### Lax Versioning  \n In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients. This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members. In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way. The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.  \n  \n WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.  \n  \n It is easy to mistakenly believe that adding a new member will not break existing clients. If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.  \n  \n For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).  \n  \n### Distinguishing Between Data Contract and .NET Types  \n A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class. The .NET type and its data contract projections are two distinct matters. It is possible to have multiple .NET types with the same data contract projection. This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word. There are two things you should always do to maintain this distinction between .NET type and data contract:  \n  \n-   Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>. You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract. This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.  \n  \n-   Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>. You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract. This way, if you decide later to change the .NET name of the member, your data contract remains the same.  \n  \n### Changing or Removing Members  \n Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed. If this is necessary, create a new data contract.  \n  \n If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place. If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).  \n  \n Similarly, changes to the data contract’s name or namespace are breaking changes.  \n  \n### Round-Trips of Unknown Data  \n In some scenarios, there is a need to \"round-trip\" unknown data that comes from members added in a new version. For example, a \"versionNew\" service sends data with some newly added members to a \"versionOld\" client. The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service. The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.  \n  \n To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface. The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type. The property is used to store any data from future versions of the data contract that is unknown to the current version. This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.  \n  \n It is recommended that all your types implement this interface to accommodate new and unknown future members.  \n  \n### Data Contract Libraries  \n There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository. In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it. Thus, you cannot modify the contract once it is published, rendering it effectively immutable.  \n  \n### When Using the XmlSerializer  \n The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class. When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions. When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.  \n  \n> [!NOTE]\n>  The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.  \n  \n## Message Contract Versioning  \n The guidelines for message contract versioning are very similar to versioning data contracts. If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name. If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones. This guidance applies both to bare and wrapped message contracts.  \n  \n Message headers can always be added, even if strict versioning is in use. The MustUnderstand flag may affect versioning. In general, the versioning model for headers in WCF is as described in the SOAP specification.  \n  \n## Service Contract Versioning  \n Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.  \n  \n### Specifying Name, Namespace, and Action  \n By default, the name of a service contract is the name of the interface. Its default namespace is \"http://tempuri.org\", and each operation’s action is \"http://tempuri.org/contractname/methodname\". It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using \"http://tempuri.org\" and to prevent interface and method names from being exposed in the service’s contract.  \n  \n### Adding Parameters and Operations  \n Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.  \n  \n> [!NOTE]\n>  Adding operations to a duplex callback contract is a breaking change.  \n  \n### Changing Operation Parameter or Return Types  \n Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type. To make such a change, add a new operation to the service contract or define a new service contract.  \n  \n### Removing Operations  \n Removing operations is also a breaking change. To make such a change, define a new service contract and expose it on a new endpoint.  \n  \n### Fault Contracts  \n The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.  \n  \n The list of faults described in a service's contract is not considered exhaustive. At any time, an operation may return faults that are not described in its contract. Therefore changing the set of faults described in the contract is not considered breaking. For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.  \n  \n### Service Contract Libraries  \n Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository. In this case, when you publish a service contract to the repository you have no control over who creates services that implement it. Therefore, you cannot modify the service contract once published, rendering it effectively immutable. WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts. To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface. You then change the service that implements the old contract to implement the new contract and change the \"versionOld\" endpoint definition to use the new contract. To \"versionOld\" clients, the endpoint will continue to appear as exposing the \"versionOld\" contract; to \"versionNew\" clients, the endpoint will appear to expose the \"versionNew\" contract.  \n  \n## Address and Binding Versioning  \n Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding. One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata. The client then uses the address and binding from this metadata to communicate with the endpoint. If this communication succeeds, the client caches the address and binding information for future use.  \n  \n## Routing Service and Versioning  \n If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance. The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message. For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md). For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).  \n  \n## Appendix  \n The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required. A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.  \n  \n One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces. The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:  \n  \n```  \npublic interface IPurchaseOrderV1  \n{  \n    string OrderId { get; set; }  \n    string CustomerId { get; set; }  \n}  \n  \n[DataContract(  \nName = \"PurchaseOrder\",  \nNamespace = \"http://examples.microsoft.com/WCF/2005/10/PurchaseOrder\")]  \npublic class PurchaseOrderV1 : IPurchaseOrderV1  \n{  \n    [DataMember(...)]  \n    public string OrderId {...}  \n    [DataMember(...)]  \n    public string CustomerId {...}  \n}  \n```  \n  \n While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`. Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:  \n  \n```  \npublic interface IPurchaseOrderV2  \n{  \n    DateTime OrderDate { get; set; }  \n}\n\n[DataContract(   \nName = \"PurchaseOrder\",  \nNamespace = \"http://examples.microsoft.com/WCF/2006/02/PurchaseOrder\")]  \npublic class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  \n{  \n    [DataMember(...)]  \n    public string OrderId {...}  \n    [DataMember(...)]  \n    public string CustomerId {...}  \n    [DataMember(...)]  \n    public DateTime OrderDate { ... }  \n}  \n```  \n  \n The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`. Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.  \n  \n## See also\n\n- <xref:System.Runtime.Serialization.DataContractSerializer>\n- <xref:System.Runtime.Serialization.DataContractAttribute>\n- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>\n- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>\n- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>\n- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>\n- <xref:System.Runtime.Serialization.IExtensibleDataObject>\n- <xref:System.Runtime.Serialization.ExtensionDataObject>\n- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>\n- <xref:System.Xml.Serialization.XmlSerializer>\n- [Data Contract Equivalence](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)\n- [Version-Tolerant Serialization Callbacks](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)\n","nodes":[{"pos":[4,102],"embed":true,"restype":"x-metadata","content":"title: \"Service Versioning\"\nms.date: \"03/30/2017\"\nms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2","nodes":[{"content":"Service Versioning","nodes":[{"pos":[0,18],"content":"Service Versioning","nodes":[{"content":"Service Versioning","pos":[0,18]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[109,127],"content":"Service Versioning","linkify":"Service Versioning","nodes":[{"content":"Service Versioning","pos":[0,18]}]},{"content":"After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.","pos":[128,394]},{"content":"Each change introduces a new version of the service.","pos":[395,447]},{"content":"This topic explains how to consider versioning in Windows Communication Foundation (WCF).","pos":[448,537]},{"pos":[546,580],"content":"Four Categories of Service Changes","linkify":"Four Categories of Service Changes","nodes":[{"content":"Four Categories of Service Changes","pos":[0,34]}]},{"content":"The changes to services that may be required can be classified into four categories:","pos":[584,668]},{"content":"Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.","pos":[678,795]},{"content":"Address changes: For example, a service moves to a different location where endpoints have new addresses.","pos":[805,910]},{"content":"Binding changes: For example, a security mechanism changes or its settings change.","pos":[920,1002]},{"content":"Implementation changes: For example, when an internal method implementation changes.","pos":[1012,1096]},{"content":"Some of these changes are called \"breaking\" and others are \"nonbreaking.\"","pos":[1103,1176]},{"content":"A change is <bpt id=\"p1\">*</bpt>nonbreaking<ept id=\"p1\">*</ept> if all messages that would have been processed successfully in the previous version are processed successfully in the new version.","pos":[1177,1333],"source":" A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version."},{"content":"Any change that does not meet that criterion is a <bpt id=\"p1\">*</bpt>breaking<ept id=\"p1\">*</ept> change.","pos":[1334,1402],"source":" Any change that does not meet that criterion is a *breaking* change."},{"pos":[1411,1445],"content":"Service Orientation and Versioning","linkify":"Service Orientation and Versioning","nodes":[{"content":"Service Orientation and Versioning","pos":[0,34]}]},{"content":"One of the tenets of service orientation is that services and clients are autonomous (or independent).","pos":[1449,1551]},{"content":"Among other things, this implies that service developers cannot assume that they control or even know about all service clients.","pos":[1552,1680]},{"content":"This eliminates the option of rebuilding and redeploying all clients when a service changes versions.","pos":[1681,1782]},{"content":"This topic assumes the service adheres to this tenet and therefore must be changed or \"versioned\" independent of its clients.","pos":[1783,1908]},{"content":"In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.","pos":[1915,2117]},{"pos":[2126,2145],"content":"Contract Versioning","linkify":"Contract Versioning","nodes":[{"content":"Contract Versioning","pos":[0,19]}]},{"content":"Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.","pos":[2149,2272]},{"content":"For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.","pos":[2279,2439]},{"content":"For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.","pos":[2446,2599]},{"content":"Breaking changes might include removing data members or changing their data type incompatibly.","pos":[2600,2694]},{"content":"This feature allows the service some latitude in changing the version of its contracts without breaking clients.","pos":[2695,2807]},{"content":"The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.","pos":[2808,2922]},{"pos":[2931,2955],"content":"Data Contract Versioning","linkify":"Data Contract Versioning","nodes":[{"content":"Data Contract Versioning","pos":[0,24]}]},{"pos":[2959,3143],"content":"This section deals with data versioning when using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> classes.","source":"This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes."},{"pos":[3153,3170],"content":"Strict Versioning","linkify":"Strict Versioning","nodes":[{"content":"Strict Versioning","pos":[0,17]}]},{"content":"In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.","pos":[3174,3394]},{"content":"In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:","pos":[3395,3506]},{"content":"The old clients were developed with the assumption that the schema will not change.","pos":[3516,3599]},{"content":"They may fail to process messages that they were never designed for.","pos":[3600,3668]},{"content":"The old clients may perform actual schema validation against the old schema before even attempting to process the messages.","pos":[3678,3801]},{"content":"The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.","pos":[3808,3952]},{"content":"The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.","pos":[3953,4118]},{"content":"It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.","pos":[4125,4340]},{"content":"The appendix at the end of this topic explains how interfaces can be used to satisfy this need.","pos":[4341,4436]},{"pos":[4446,4460],"content":"Lax Versioning","linkify":"Lax Versioning","nodes":[{"content":"Lax Versioning","pos":[0,14]}]},{"content":"In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.","pos":[4464,4623]},{"content":"This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.","pos":[4624,4779]},{"content":"In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.","pos":[4780,4903]},{"content":"The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.","pos":[4904,5067]},{"pos":[5074,5245],"content":"WCF, ASP.NET Web Services, and many other Web service stacks support <bpt id=\"p1\">*</bpt>lax versioning<ept id=\"p1\">*</ept>: that is, they do not throw exceptions for new unknown data members in received data.","source":"WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data."},{"content":"It is easy to mistakenly believe that adding a new member will not break existing clients.","pos":[5252,5342]},{"content":"If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.","pos":[5343,5505]},{"pos":[5512,5709],"content":"For detailed guidelines for both lax and strict versioning of data contracts, see <bpt id=\"p1\">[</bpt>Best Practices: Data Contract Versioning<ept id=\"p1\">](../../../docs/framework/wcf/best-practices-data-contract-versioning.md)</ept>.","source":"For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md)."},{"pos":[5719,5770],"content":"Distinguishing Between Data Contract and .NET Types","linkify":"Distinguishing Between Data Contract and .NET Types","nodes":[{"content":"Distinguishing Between Data Contract and .NET Types","pos":[0,51]}]},{"content":"A .NET class or structure can be projected as a data contract by applying the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute to the class.","pos":[5774,5933],"source":"A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class."},{"content":"The .NET type and its data contract projections are two distinct matters.","pos":[5934,6007]},{"content":"It is possible to have multiple .NET types with the same data contract projection.","pos":[6008,6090]},{"content":"This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.","pos":[6091,6309]},{"content":"There are two things you should always do to maintain this distinction between .NET type and data contract:","pos":[6310,6417]},{"content":"Specify a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Name%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A&gt;</ph>.","pos":[6427,6578],"source":"Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>."},{"content":"You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.","pos":[6579,6732]},{"content":"This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.","pos":[6733,6842]},{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A&gt;</ph>.","pos":[6852,6924],"source":"Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>."},{"content":"You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.","pos":[6925,7049]},{"content":"This way, if you decide later to change the .NET name of the member, your data contract remains the same.","pos":[7050,7155]},{"pos":[7165,7193],"content":"Changing or Removing Members","linkify":"Changing or Removing Members","nodes":[{"content":"Changing or Removing Members","pos":[0,28]}]},{"content":"Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.","pos":[7197,7321]},{"content":"If this is necessary, create a new data contract.","pos":[7322,7371]},{"content":"If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.","pos":[7378,7511]},{"content":"If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).","pos":[7512,7779]},{"content":"Similarly, changes to the data contract’s name or namespace are breaking changes.","pos":[7786,7867]},{"pos":[7877,7904],"content":"Round-Trips of Unknown Data","linkify":"Round-Trips of Unknown Data","nodes":[{"content":"Round-Trips of Unknown Data","pos":[0,27]}]},{"content":"In some scenarios, there is a need to \"round-trip\" unknown data that comes from members added in a new version.","pos":[7908,8019]},{"content":"For example, a \"versionNew\" service sends data with some newly added members to a \"versionOld\" client.","pos":[8020,8122]},{"content":"The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.","pos":[8123,8292]},{"content":"The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.","pos":[8293,8403]},{"content":"To enable round-tripping for a particular type, the type must implement the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface.","pos":[8410,8554],"source":"To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface."},{"content":"The interface contains one property, <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A&gt;</ph> that returns the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ExtensionDataObject&gt;</ph> type.","pos":[8555,8745],"source":" The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type."},{"content":"The property is used to store any data from future versions of the data contract that is unknown to the current version.","pos":[8746,8866]},{"content":"This data is opaque to the client, but when the instance is serialized, the content of the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A&gt;</ph> property is written with the rest of the data contract members' data.","pos":[8867,9102],"source":" This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data."},{"content":"It is recommended that all your types implement this interface to accommodate new and unknown future members.","pos":[9109,9218]},{"pos":[9228,9251],"content":"Data Contract Libraries","linkify":"Data Contract Libraries","nodes":[{"content":"Data Contract Libraries","pos":[0,23]}]},{"content":"There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.","pos":[9255,9442]},{"content":"In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.","pos":[9443,9570]},{"content":"Thus, you cannot modify the contract once it is published, rendering it effectively immutable.","pos":[9571,9665]},{"pos":[9675,9703],"content":"When Using the XmlSerializer","linkify":"When Using the XmlSerializer","nodes":[{"content":"When Using the XmlSerializer","pos":[0,28]}]},{"content":"The same versioning principles apply when using the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class.","pos":[9707,9811],"source":"The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class."},{"content":"When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.","pos":[9812,9962]},{"content":"When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.","pos":[9963,10109]},{"pos":[10117,10356],"content":"[!NOTE]\n The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> uses the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlAnyElementAttribute&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.XmlAnyAttributeAttribute&gt;</ph> attributes to support round-tripping of unknown data.","pos":[9,237],"source":"The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data."}]},{"pos":[10365,10392],"content":"Message Contract Versioning","linkify":"Message Contract Versioning","nodes":[{"content":"Message Contract Versioning","pos":[0,27]}]},{"content":"The guidelines for message contract versioning are very similar to versioning data contracts.","pos":[10396,10489]},{"content":"If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.","pos":[10490,10635]},{"content":"If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.","pos":[10636,10755]},{"content":"This guidance applies both to bare and wrapped message contracts.","pos":[10756,10821]},{"content":"Message headers can always be added, even if strict versioning is in use.","pos":[10828,10901]},{"content":"The MustUnderstand flag may affect versioning.","pos":[10902,10948]},{"content":"In general, the versioning model for headers in WCF is as described in the SOAP specification.","pos":[10949,11043]},{"pos":[11052,11079],"content":"Service Contract Versioning","linkify":"Service Contract Versioning","nodes":[{"content":"Service Contract Versioning","pos":[0,27]}]},{"content":"Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.","pos":[11083,11204]},{"pos":[11214,11252],"content":"Specifying Name, Namespace, and Action","linkify":"Specifying Name, Namespace, and Action","nodes":[{"content":"Specifying Name, Namespace, and Action","pos":[0,38]}]},{"content":"By default, the name of a service contract is the name of the interface.","pos":[11256,11328]},{"content":"Its default namespace is \"<ph id=\"ph1\">http://tempuri.org</ph>\", and each operation’s action is \"<ph id=\"ph2\">http://tempuri.org/contractname/methodname</ph>\".","pos":[11329,11452],"source":" Its default namespace is \"http://tempuri.org\", and each operation’s action is \"http://tempuri.org/contractname/methodname\"."},{"content":"It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using \"<ph id=\"ph1\">http://tempuri.org</ph>\" and to prevent interface and method names from being exposed in the service’s contract.","pos":[11453,11702],"source":" It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using \"http://tempuri.org\" and to prevent interface and method names from being exposed in the service’s contract."},{"pos":[11712,11744],"content":"Adding Parameters and Operations","linkify":"Adding Parameters and Operations","nodes":[{"content":"Adding Parameters and Operations","pos":[0,32]}]},{"content":"Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.","pos":[11748,11895]},{"pos":[11903,11983],"content":"[!NOTE]\n Adding operations to a duplex callback contract is a breaking change.","leadings":["","> "],"nodes":[{"content":"Adding operations to a duplex callback contract is a breaking change.","pos":[9,78]}]},{"pos":[11993,12037],"content":"Changing Operation Parameter or Return Types","linkify":"Changing Operation Parameter or Return Types","nodes":[{"content":"Changing Operation Parameter or Return Types","pos":[0,44]}]},{"content":"Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.","pos":[12041,12189]},{"content":"To make such a change, add a new operation to the service contract or define a new service contract.","pos":[12190,12290]},{"pos":[12300,12319],"content":"Removing Operations","linkify":"Removing Operations","nodes":[{"content":"Removing Operations","pos":[0,19]}]},{"content":"Removing operations is also a breaking change.","pos":[12323,12369]},{"content":"To make such a change, define a new service contract and expose it on a new endpoint.","pos":[12370,12455]},{"pos":[12465,12480],"content":"Fault Contracts","linkify":"Fault Contracts","nodes":[{"content":"Fault Contracts","pos":[0,15]}]},{"pos":[12484,12673],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultContractAttribute&gt;</ph> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.","source":"The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations."},{"content":"The list of faults described in a service's contract is not considered exhaustive.","pos":[12680,12762]},{"content":"At any time, an operation may return faults that are not described in its contract.","pos":[12763,12846]},{"content":"Therefore changing the set of faults described in the contract is not considered breaking.","pos":[12847,12937]},{"content":"For example, adding a new fault to the contract using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultContractAttribute&gt;</ph> or removing an existing fault from the contract.","pos":[12938,13094],"source":" For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract."},{"pos":[13104,13130],"content":"Service Contract Libraries","linkify":"Service Contract Libraries","nodes":[{"content":"Service Contract Libraries","pos":[0,26]}]},{"content":"Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.","pos":[13134,13300]},{"content":"In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.","pos":[13301,13433]},{"content":"Therefore, you cannot modify the service contract once published, rendering it effectively immutable.","pos":[13434,13535]},{"content":"WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.","pos":[13536,13646]},{"content":"To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.","pos":[13647,13801]},{"content":"You then change the service that implements the old contract to implement the new contract and change the \"versionOld\" endpoint definition to use the new contract.","pos":[13802,13965]},{"content":"To \"versionOld\" clients, the endpoint will continue to appear as exposing the \"versionOld\" contract; to \"versionNew\" clients, the endpoint will appear to expose the \"versionNew\" contract.","pos":[13966,14153]},{"pos":[14162,14192],"content":"Address and Binding Versioning","linkify":"Address and Binding Versioning","nodes":[{"content":"Address and Binding Versioning","pos":[0,30]}]},{"content":"Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.","pos":[14196,14347]},{"content":"One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.","pos":[14348,14649]},{"content":"The client then uses the address and binding from this metadata to communicate with the endpoint.","pos":[14650,14747]},{"content":"If this communication succeeds, the client caches the address and binding information for future use.","pos":[14748,14849]},{"pos":[14858,14888],"content":"Routing Service and Versioning","linkify":"Routing Service and Versioning","nodes":[{"content":"Routing Service and Versioning","pos":[0,30]}]},{"content":"If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.","pos":[14892,15124]},{"content":"The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.","pos":[15125,15272]},{"content":"For more information about the WCF Routing Service see <bpt id=\"p1\">[</bpt>Routing Service<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/routing-service.md)</ept>.","pos":[15273,15410],"source":" For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md)."},{"content":"For an example of how to use the WCF Routing Service for service versioning see <bpt id=\"p1\">[</bpt>How To: Service Versioning<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md)</ept>.","pos":[15411,15594],"source":" For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md)."},{"pos":[15603,15611],"content":"Appendix","linkify":"Appendix","nodes":[{"content":"Appendix","pos":[0,8]}]},{"content":"The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.","pos":[15615,15780]},{"content":"A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.","pos":[15781,16016]},{"content":"One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.","pos":[16023,16241]},{"content":"The following code for version 1 of a service shows an <ph id=\"ph1\">`IPurchaseOrderV1`</ph> interface and a <ph id=\"ph2\">`PurchaseOrderV1`</ph>:","pos":[16242,16350],"source":" The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:"},{"content":"While the service contract’s operations would be written in terms of <ph id=\"ph1\">`PurchaseOrderV1`</ph>, the actual business logic would be in terms of <ph id=\"ph2\">`IPurchaseOrderV1`</ph>.","pos":[16786,16940],"source":"While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`."},{"content":"Then, in version 2, there would be a new <ph id=\"ph1\">`IPurchaseOrderV2`</ph> interface and a new <ph id=\"ph2\">`PurchaseOrderV2`</ph> class as shown in the following code:","pos":[16941,17076],"source":" Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:"},{"content":"The service contract would be updated to include new operations that are written in terms of <ph id=\"ph1\">`PurchaseOrderV2`</ph>.","pos":[17557,17668],"source":"The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`."},{"content":"Existing business logic written in terms of <ph id=\"ph1\">`IPurchaseOrderV1`</ph> would continue to work for <ph id=\"ph2\">`PurchaseOrderV2`</ph> and new business logic that needs the <ph id=\"ph3\">`OrderDate`</ph> property would be written in terms of <ph id=\"ph4\">`IPurchaseOrderV2`</ph>.","pos":[17669,17884],"source":" Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`."},{"pos":[17893,17901],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[18549,18650],"content":"<bpt id=\"p1\">[</bpt>Data Contract Equivalence<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)</ept>","source":"[Data Contract Equivalence](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)"},{"pos":[18653,18784],"content":"<bpt id=\"p1\">[</bpt>Version-Tolerant Serialization Callbacks<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)</ept>","source":"[Version-Tolerant Serialization Callbacks](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)"}]}