{"content":"---\ntitle: \"Managing Concurrency with DependentTransaction | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: b85a97d8-8e02-4555-95df-34c8af095148\ncaps.latest.revision: 3\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Managing Concurrency with DependentTransaction\nThe <xref:System.Transactions.Transaction> object is created using the <xref:System.Transactions.Transaction.DependentClone%2A> method. Its sole purpose is to guarantee that the transaction cannot commit while some other pieces of code (for example, a worker thread) are still performing work on the transaction. When the work done within the cloned transaction is complete and ready to be committed, it can notify the creator of the transaction using the <xref:System.Transactions.DependentTransaction.Complete%2A> method. Thus, you can preserve the consistency and correctness of data.  \n  \n The <xref:System.Transactions.DependentTransaction> class can also be used to manage concurrency between asynchronous tasks. In this scenario, the parent can continue to execute any code while the dependent clone works on its own tasks. In other words, the parent's execution is not blocked until the dependent completes.  \n  \n## Creating a Dependent Clone  \n To create a dependent transaction, call the <xref:System.Transactions.Transaction.DependentClone%2A> method and pass the <xref:System.Transactions.DependentCloneOption> enumeration as a parameter. This parameter defines the behavior of the transaction if `Commit` is called on the parent transaction before the dependent clone indicates that it is ready for the transaction to commit (by calling the <xref:System.Transactions.DependentTransaction.Complete%2A> method). The following values are valid for this parameter:  \n  \n-   <xref:System.Transactions.DependentCloneOption> creates a dependent transaction that blocks the commit process of the parent transaction until the parent transaction times out, or until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on all dependents indicating their completion. This is useful when the client does not want the parent transaction to commit until the dependent transactions have completed. If the parent finishes its work earlier than the dependent transaction and calls <xref:System.Transactions.CommittableTransaction.Commit%2A> on the transaction, the commit process is blocked in a state where additional work can be done on the transaction and new enlistments can be created, until all of the dependents call <xref:System.Transactions.DependentTransaction.Complete%2A>. As soon as all of them have finished their work and call <xref:System.Transactions.DependentTransaction.Complete%2A>, the commit process for the transaction begins.  \n  \n-   <xref:System.Transactions.DependentCloneOption>, on the other hand, creates a dependent transaction that automatically aborts if <xref:System.Transactions.CommittableTransaction.Commit%2A> is called on the parent transaction before <xref:System.Transactions.DependentTransaction.Complete%2A> is called. In this case, all the work done in the dependent transaction is intact within one transaction lifetime, and no one has a chance to commit just a portion of it.  \n  \n The <xref:System.Transactions.DependentTransaction.Complete%2A> method must be called only once when your application finishes its work on the dependent transaction; otherwise, a <xref:System.InvalidOperationException> is thrown. After this call is invoked, you must not attempt any additional work on the transaction, or an exception is thrown.  \n  \n The following code example shows how to create a dependent transaction to manage two concurrent tasks by cloning a dependent transaction and passing it to a worker thread.  \n  \n```csharp  \npublic class WorkerThread  \n{  \n    public void DoWork(DependentTransaction dependentTransaction)  \n    {  \n        Thread thread = new Thread(ThreadMethod);  \n        thread.Start(dependentTransaction);   \n    }  \n  \n    public void ThreadMethod(object transaction)   \n    {   \n        DependentTransaction dependentTransaction = transaction as DependentTransaction;  \n        Debug.Assert(dependentTransaction != null);   \n        try  \n        {  \n            using(TransactionScope ts = new TransactionScope(dependentTransaction))  \n            {  \n                /* Perform transactional work here */   \n                ts.Complete();  \n            }  \n        }  \n        finally  \n        {  \n            dependentTransaction.Complete();   \n             dependentTransaction.Dispose();   \n        }  \n    }  \n  \n//Client code   \nusing(TransactionScope scope = new TransactionScope())  \n{  \n    Transaction currentTransaction = Transaction.Current;  \n    DependentTransaction dependentTransaction;      \n    dependentTransaction = currentTransaction.DependentClone(DependentCloneOption.BlockCommitUntilComplete);  \n    WorkerThread workerThread = new WorkerThread();  \n    workerThread.DoWork(dependentTransaction);  \n    /* Do some transactional work here, then: */  \n    scope.Complete();  \n}  \n  \n```  \n  \n The client code creates a transactional scope that also sets the ambient transaction. You should not pass the ambient transaction to the worker thread. Instead, you should clone the current (ambient) transaction by calling the <xref:System.Transactions.Transaction.DependentClone%2A> method on the current transaction, and pass the dependent to the worker thread.  \n  \n The `ThreadMethod` method executes on the new thread. The client starts a new thread, passing the dependent transaction as the `ThreadMethod` parameter.  \n  \n Because the dependent transaction is created with <xref:System.Transactions.DependentCloneOption>, you are guaranteed that the transaction cannot be committed until all of the transactional work done on the second thread is finished and <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent transaction. This means that if the client's scope ends (when it tries to dispose of the transaction object at the end of the **using** statement) before the new thread calls <xref:System.Transactions.DependentTransaction.Complete%2A> on the dependent transaction, the client code blocks until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent. Then the transaction can finish committing or aborting.  \n  \n## Concurrency Issues  \n There are a few additional concurrency issues that you need to be aware of when using the <xref:System.Transactions.DependentTransaction> class:  \n  \n-   If the worker thread rolls back the transaction but the parent tries to commit it, a <xref:System.Transactions.TransactionAbortedException> is thrown.  \n  \n-   You should create a new dependent clone for each worker thread in the transaction. Do not pass the same dependent clone to multiple threads, because only one of them can call <xref:System.Transactions.DependentTransaction.Complete%2A> on it.  \n  \n-   If the worker thread spawns a new worker thread, make sure to create a dependent clone from the dependent clone and pass it to the new thread.  \n  \n## See Also  \n <xref:System.Transactions.DependentTransaction>","nodes":[{"pos":[12,75],"content":"Managing Concurrency with DependentTransaction | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Managing Concurrency with DependentTransaction | Microsoft Docs","pos":[0,63]}]},{"pos":[340,386],"content":"Managing Concurrency with DependentTransaction","linkify":"Managing Concurrency with DependentTransaction","nodes":[{"content":"Managing Concurrency with DependentTransaction","pos":[0,46]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Transactions.Transaction&gt;</ph> object is created using the <ph id=\"ph2\">&lt;xref:System.Transactions.Transaction.DependentClone%2A&gt;</ph> method.","pos":[387,522],"source":"The <xref:System.Transactions.Transaction> object is created using the <xref:System.Transactions.Transaction.DependentClone%2A> method."},{"content":"Its sole purpose is to guarantee that the transaction cannot commit while some other pieces of code (for example, a worker thread) are still performing work on the transaction.","pos":[523,699]},{"content":"When the work done within the cloned transaction is complete and ready to be committed, it can notify the creator of the transaction using the <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> method.","pos":[700,910],"source":" When the work done within the cloned transaction is complete and ready to be committed, it can notify the creator of the transaction using the <xref:System.Transactions.DependentTransaction.Complete%2A> method."},{"content":"Thus, you can preserve the consistency and correctness of data.","pos":[911,974]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction&gt;</ph> class can also be used to manage concurrency between asynchronous tasks.","pos":[981,1105],"source":"The <xref:System.Transactions.DependentTransaction> class can also be used to manage concurrency between asynchronous tasks."},{"content":"In this scenario, the parent can continue to execute any code while the dependent clone works on its own tasks.","pos":[1106,1217]},{"content":"In other words, the parent's execution is not blocked until the dependent completes.","pos":[1218,1302]},{"pos":[1311,1337],"content":"Creating a Dependent Clone","linkify":"Creating a Dependent Clone","nodes":[{"content":"Creating a Dependent Clone","pos":[0,26]}]},{"content":"To create a dependent transaction, call the <ph id=\"ph1\">&lt;xref:System.Transactions.Transaction.DependentClone%2A&gt;</ph> method and pass the <ph id=\"ph2\">&lt;xref:System.Transactions.DependentCloneOption&gt;</ph> enumeration as a parameter.","pos":[1341,1537],"source":"To create a dependent transaction, call the <xref:System.Transactions.Transaction.DependentClone%2A> method and pass the <xref:System.Transactions.DependentCloneOption> enumeration as a parameter."},{"content":"This parameter defines the behavior of the transaction if <ph id=\"ph1\">`Commit`</ph> is called on the parent transaction before the dependent clone indicates that it is ready for the transaction to commit (by calling the <ph id=\"ph2\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> method).","pos":[1538,1809],"source":" This parameter defines the behavior of the transaction if `Commit` is called on the parent transaction before the dependent clone indicates that it is ready for the transaction to commit (by calling the <xref:System.Transactions.DependentTransaction.Complete%2A> method)."},{"content":"The following values are valid for this parameter:","pos":[1810,1860]},{"content":"<ph id=\"ph1\">&lt;xref:System.Transactions.DependentCloneOption&gt;</ph> creates a dependent transaction that blocks the commit process of the parent transaction until the parent transaction times out, or until <ph id=\"ph2\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> is called on all dependents indicating their completion.","pos":[1870,2172],"source":"<xref:System.Transactions.DependentCloneOption> creates a dependent transaction that blocks the commit process of the parent transaction until the parent transaction times out, or until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on all dependents indicating their completion."},{"content":"This is useful when the client does not want the parent transaction to commit until the dependent transactions have completed.","pos":[2173,2299]},{"content":"If the parent finishes its work earlier than the dependent transaction and calls <ph id=\"ph1\">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> on the transaction, the commit process is blocked in a state where additional work can be done on the transaction and new enlistments can be created, until all of the dependents call <ph id=\"ph2\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph>.","pos":[2300,2684],"source":" If the parent finishes its work earlier than the dependent transaction and calls <xref:System.Transactions.CommittableTransaction.Commit%2A> on the transaction, the commit process is blocked in a state where additional work can be done on the transaction and new enlistments can be created, until all of the dependents call <xref:System.Transactions.DependentTransaction.Complete%2A>."},{"content":"As soon as all of them have finished their work and call <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph>, the commit process for the transaction begins.","pos":[2685,2849],"source":" As soon as all of them have finished their work and call <xref:System.Transactions.DependentTransaction.Complete%2A>, the commit process for the transaction begins."},{"content":"<ph id=\"ph1\">&lt;xref:System.Transactions.DependentCloneOption&gt;</ph>, on the other hand, creates a dependent transaction that automatically aborts if <ph id=\"ph2\">&lt;xref:System.Transactions.CommittableTransaction.Commit%2A&gt;</ph> is called on the parent transaction before <ph id=\"ph3\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> is called.","pos":[2859,3161],"source":"<xref:System.Transactions.DependentCloneOption>, on the other hand, creates a dependent transaction that automatically aborts if <xref:System.Transactions.CommittableTransaction.Commit%2A> is called on the parent transaction before <xref:System.Transactions.DependentTransaction.Complete%2A> is called."},{"content":"In this case, all the work done in the dependent transaction is intact within one transaction lifetime, and no one has a chance to commit just a portion of it.","pos":[3162,3321]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> method must be called only once when your application finishes its work on the dependent transaction; otherwise, a <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.","pos":[3328,3557],"source":"The <xref:System.Transactions.DependentTransaction.Complete%2A> method must be called only once when your application finishes its work on the dependent transaction; otherwise, a <xref:System.InvalidOperationException> is thrown."},{"content":"After this call is invoked, you must not attempt any additional work on the transaction, or an exception is thrown.","pos":[3558,3673]},{"content":"The following code example shows how to create a dependent transaction to manage two concurrent tasks by cloning a dependent transaction and passing it to a worker thread.","pos":[3680,3851]},{"content":"The client code creates a transactional scope that also sets the ambient transaction.","pos":[5186,5271]},{"content":"You should not pass the ambient transaction to the worker thread.","pos":[5272,5337]},{"content":"Instead, you should clone the current (ambient) transaction by calling the <ph id=\"ph1\">&lt;xref:System.Transactions.Transaction.DependentClone%2A&gt;</ph> method on the current transaction, and pass the dependent to the worker thread.","pos":[5338,5549],"source":" Instead, you should clone the current (ambient) transaction by calling the <xref:System.Transactions.Transaction.DependentClone%2A> method on the current transaction, and pass the dependent to the worker thread."},{"content":"The <ph id=\"ph1\">`ThreadMethod`</ph> method executes on the new thread.","pos":[5556,5609],"source":"The `ThreadMethod` method executes on the new thread."},{"content":"The client starts a new thread, passing the dependent transaction as the <ph id=\"ph1\">`ThreadMethod`</ph> parameter.","pos":[5610,5708],"source":" The client starts a new thread, passing the dependent transaction as the `ThreadMethod` parameter."},{"content":"Because the dependent transaction is created with <ph id=\"ph1\">&lt;xref:System.Transactions.DependentCloneOption&gt;</ph>, you are guaranteed that the transaction cannot be committed until all of the transactional work done on the second thread is finished and <ph id=\"ph2\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> is called on the dependent transaction.","pos":[5715,6051],"source":"Because the dependent transaction is created with <xref:System.Transactions.DependentCloneOption>, you are guaranteed that the transaction cannot be committed until all of the transactional work done on the second thread is finished and <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent transaction."},{"content":"This means that if the client's scope ends (when it tries to dispose of the transaction object at the end of the <bpt id=\"p1\">**</bpt>using<ept id=\"p1\">**</ept> statement) before the new thread calls <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> on the dependent transaction, the client code blocks until <ph id=\"ph2\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> is called on the dependent.","pos":[6052,6420],"source":" This means that if the client's scope ends (when it tries to dispose of the transaction object at the end of the **using** statement) before the new thread calls <xref:System.Transactions.DependentTransaction.Complete%2A> on the dependent transaction, the client code blocks until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent."},{"content":"Then the transaction can finish committing or aborting.","pos":[6421,6476]},{"pos":[6485,6503],"content":"Concurrency Issues","linkify":"Concurrency Issues","nodes":[{"content":"Concurrency Issues","pos":[0,18]}]},{"content":"There are a few additional concurrency issues that you need to be aware of when using the <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction&gt;</ph> class:","pos":[6507,6651],"source":"There are a few additional concurrency issues that you need to be aware of when using the <xref:System.Transactions.DependentTransaction> class:"},{"content":"If the worker thread rolls back the transaction but the parent tries to commit it, a <ph id=\"ph1\">&lt;xref:System.Transactions.TransactionAbortedException&gt;</ph> is thrown.","pos":[6661,6811],"source":"If the worker thread rolls back the transaction but the parent tries to commit it, a <xref:System.Transactions.TransactionAbortedException> is thrown."},{"content":"You should create a new dependent clone for each worker thread in the transaction.","pos":[6821,6903]},{"content":"Do not pass the same dependent clone to multiple threads, because only one of them can call <ph id=\"ph1\">&lt;xref:System.Transactions.DependentTransaction.Complete%2A&gt;</ph> on it.","pos":[6904,7062],"source":" Do not pass the same dependent clone to multiple threads, because only one of them can call <xref:System.Transactions.DependentTransaction.Complete%2A> on it."},{"content":"If the worker thread spawns a new worker thread, make sure to create a dependent clone from the dependent clone and pass it to the new thread.","pos":[7072,7214]},{"pos":[7223,7231],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]}]}