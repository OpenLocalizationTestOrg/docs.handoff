{"content":"---\ntitle: Backreference Constructs in .NET Regular Expressions\ndescription: Learn how to identify repeated text elements by using backreference constructs in a regular expression.\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"backreferences\"\n  - \"constructs, backreference\"\n  - \".NET Framework regular expressions, backreference constructs\"\n  - \"regular expressions, backreference constructs\"\nms.assetid: 567a4b8d-0e79-49dc-8df9-f4b1aa376a2a\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nms.custom: seodec18\n---\n\n# Backreference Constructs in Regular Expressions\n\nBackreferences provide a convenient way to identify a repeated character or substring within a string. For example, if the input string contains multiple occurrences of an arbitrary substring, you can match the first occurrence with a capturing group, and then use a backreference to match subsequent occurrences of the substring.\n\n> [!NOTE]\n> A separate syntax is used to refer to named and numbered capturing groups in replacement strings. For more information, see [Substitutions](substitutions-in-regular-expressions.md).\n\n.NET defines separate language elements to refer to numbered and named capturing groups. For more information about capturing groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).\n\n## Numbered Backreferences\n\nA numbered backreference uses the following syntax:\n\n`\\` *number*\n\nwhere *number* is the ordinal position of the capturing group in the regular expression. For example, `\\4` matches the contents of the fourth capturing group. If *number* is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <xref:System.ArgumentException>. For example, the regular expression `\\b(\\w+)\\s\\1` is valid, because `(\\w+)` is the first and only capturing group in the expression. On the other hand, `\\b(\\w+)\\s\\2` is invalid and throws an argument exception, because there is no capturing group numbered `\\2`. In addition, if *number* identifies a capturing group in a particular ordinal position, but that capturing group has been assigned a numeric name different than its ordinal position, the regular expression parser also throws an <xref:System.ArgumentException>.\n\nNote the ambiguity between octal escape codes (such as `\\16`) and `\\`*number* backreferences that use the same notation. This ambiguity is resolved as follows:\n\n- The expressions `\\1` through `\\9` are always interpreted as backreferences, and not as octal codes.\n\n- If the first digit of a multidigit expression is 8 or 9 (such as `\\80` or `\\91`), the expression as interpreted as a literal.\n\n- Expressions from `\\10` and greater are considered backreferences if there is a backreference corresponding to that number; otherwise, they are interpreted as octal codes.\n\n- If a regular expression contains a backreference to an undefined group number, a parsing error occurs, and the regular expression engine throws an <xref:System.ArgumentException>.\n\nIf the ambiguity is a problem, you can use the `\\k<`*name*`>` notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as `\\xdd` are unambiguous and cannot be confused with backreferences.\n\nThe following example finds doubled word characters in a string. It defines a regular expression, `(\\w)\\1`, which consists of the following elements.\n\n|Element|Description|\n|-------------|-----------------|\n|`(\\w)`|Match a word character and assign it to the first capturing group.|\n|`\\1`|Match the next character that is the same as the value of the first capturing group.|\n\n[!code-csharp[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference1.cs#1)]\n[!code-vb[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference1.vb#1)]\n\n## Named Backreferences\n\nA named backreference is defined by using the following syntax:\n\n`\\k<` *name* `>`\n\nor:\n\n`\\k'` *name* `'`\n\nwhere *name* is the name of a capturing group defined in the regular expression pattern. If *name* is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <xref:System.ArgumentException>.\n\nThe following example finds doubled word characters in a string. It defines a regular expression, `(?<char>\\w)\\k<char>`, which consists of the following elements.\n\n|Element|Description|\n|-------------|-----------------|\n|`(?<char>\\w)`|Match a word character and assign it to a capturing group named `char`.|\n|`\\k<char>`|Match the next character that is the same as the value of the `char` capturing group.|\n\n[!code-csharp[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference2.cs#2)]\n[!code-vb[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference2.vb#2)]\n\n## Named numeric backreferences\n\nIn a named backreference with `\\k`, *name* can also be the string representation of a number. For example, the following example uses the regular expression `(?<2>\\w)\\k<2>` to find doubled word characters in a string. In this case, the example defines a capturing group that is explicitly named \"2\", and the backreference is correspondingly named \"2\".\n\n[!code-csharp[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference3.cs#3)]\n[!code-vb[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference3.vb#3)]\n\nIf *name* is the string representation of a number, and no capturing group has that name, `\\k<`*name*`>` is the same as the backreference `\\`*number*, where *number* is the ordinal position of the capture. In the following example, there is a single capturing group named `char`. The backreference construct refers to it as `\\k<1>`. As the output from the example shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> succeeds because `char` is the first capturing group.\n\n[!code-csharp[Ordinal.Backreference](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference6.cs)]\n[!code-vb[Ordinal.BackReference](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference6.vb)]\n\nHowever, if *name* is the string representation of a number and the capturing group in that position has been explicitly assigned a numeric name, the regular expression parser cannot identify the capturing group by its ordinal position. Instead, it throws an <xref:System.ArgumentException>.The only capturing group in the following example is named \"2\". Because the `\\k` construct is used to define a backreference named \"1\", the regular expression parser is unable to identify the first capturing group and throws an exception.\n\n[!code-csharp[Ordinal.Backreference](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference7.cs)]\n[!code-vb[Ordinal.BackReference](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference7.vb)]\n\n## What Backreferences Match\n\nA backreference refers to the most recent definition of a group (the definition most immediately to the left, when matching left to right). When a group makes multiple captures, a backreference refers to the most recent capture.\n\nThe following example includes a regular expression pattern, `(?<1>a)(?<1>\\1b)*`, which redefines the \\1 named group. The following table describes each pattern in the regular expression.\n\n|Pattern|Description|\n|-------------|-----------------|\n|`(?<1>a)`|Match the character \"a\" and assign the result to the capturing group named `1`.|\n|`(?<1>\\1b)*`|Match zero or more occurrences of the group named `1` along with a \"b\", and assign the result to the capturing group named `1`.|\n\n[!code-csharp[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference4.cs#4)]\n[!code-vb[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference4.vb#4)]\n\nIn comparing the regular expression with the input string (\"aababb\"), the regular expression engine performs the following operations:\n\n1. It starts at the beginning of the string, and successfully matches \"a\" with the expression `(?<1>a)`. The value of the `1` group is now \"a\".\n\n2. It advances to the second character, and successfully matches the string \"ab\" with the expression `\\1b`, or \"ab\". It then assigns the result, \"ab\" to `\\1`.\n\n3. It advances to the fourth character. The expression `(?<1>\\1b)*` is to be matched zero or more times, so it successfully matches the string \"abb\" with the expression `\\1b`. It assigns the result, \"abb\", back to `\\1`.\n\nIn this example, `*` is a looping quantifier -- it is evaluated repeatedly until the regular expression engine cannot match the pattern it defines. Looping quantifiers do not clear group definitions.\n\nIf a group has not captured any substrings, a backreference to that group is undefined and never matches. This is illustrated by the regular expression pattern `\\b(\\p{Lu}{2})(\\d{2})?(\\p{Lu}{2})\\b`, which is defined as follows:\n\n|Pattern|Description|\n|-------------|-----------------|\n|`\\b`|Begin the match on a word boundary.|\n|`(\\p{Lu}{2})`|Match two uppercase letters. This is the first capturing group.|\n|`(\\d{2})?`|Match zero or one occurrence of two decimal digits. This is the second capturing group.|\n|`(\\p{Lu}{2})`|Match two uppercase letters. This is the third capturing group.|\n|`\\b`|End the match on a word boundary.|\n\nAn input string can match this regular expression even if the two decimal digits that are defined by the second capturing group are not present. The following example shows that even though the match is successful, an empty capturing group is found between two successful capturing groups.\n\n[!code-csharp[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference5.cs#5)]\n[!code-vb[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference5.vb#5)]\n\n## See also\n\n- [Regular Expression Language - Quick Reference](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)\n","nodes":[{"pos":[4,568],"embed":true,"restype":"x-metadata","content":"title: Backreference Constructs in .NET Regular Expressions\ndescription: Learn how to identify repeated text elements by using backreference constructs in a regular expression.\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"backreferences\"\n  - \"constructs, backreference\"\n  - \".NET Framework regular expressions, backreference constructs\"\n  - \"regular expressions, backreference constructs\"\nms.assetid: 567a4b8d-0e79-49dc-8df9-f4b1aa376a2a\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nms.custom: seodec18","nodes":[{"content":"Backreference Constructs in .NET Regular Expressions","nodes":[{"pos":[0,52],"content":"Backreference Constructs in .NET Regular Expressions","nodes":[{"content":"Backreference Constructs in .NET Regular Expressions","pos":[0,52]}]}],"path":["title"],"nosxs":false},{"content":"Learn how to identify repeated text elements by using backreference constructs in a regular expression.","nodes":[{"pos":[0,103],"content":"Learn how to identify repeated text elements by using backreference constructs in a regular expression.","nodes":[{"content":"Learn how to identify repeated text elements by using backreference constructs in a regular expression.","pos":[0,103]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[576,623],"content":"Backreference Constructs in Regular Expressions","linkify":"Backreference Constructs in Regular Expressions","nodes":[{"content":"Backreference Constructs in Regular Expressions","pos":[0,47]}]},{"content":"Backreferences provide a convenient way to identify a repeated character or substring within a string.","pos":[625,727]},{"content":"For example, if the input string contains multiple occurrences of an arbitrary substring, you can match the first occurrence with a capturing group, and then use a backreference to match subsequent occurrences of the substring.","pos":[728,955]},{"pos":[959,1150],"content":"[!NOTE]\nA separate syntax is used to refer to named and numbered capturing groups in replacement strings. For more information, see [Substitutions](substitutions-in-regular-expressions.md).","leadings":["","> "],"nodes":[{"content":"A separate syntax is used to refer to named and numbered capturing groups in replacement strings. For more information, see [Substitutions](substitutions-in-regular-expressions.md).","pos":[8,189],"nodes":[{"content":"A separate syntax is used to refer to named and numbered capturing groups in replacement strings.","pos":[0,97]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Substitutions<ept id=\"p1\">](substitutions-in-regular-expressions.md)</ept>.","pos":[98,181],"source":" For more information, see [Substitutions](substitutions-in-regular-expressions.md)."}]}]},{"content":".NET defines separate language elements to refer to numbered and named capturing groups.","pos":[1152,1240]},{"content":"For more information about capturing groups, see <bpt id=\"p1\">[</bpt>Grouping Constructs<ept id=\"p1\">](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.","pos":[1241,1393],"source":" For more information about capturing groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)."},{"pos":[1398,1421],"content":"Numbered Backreferences","linkify":"Numbered Backreferences","nodes":[{"content":"Numbered Backreferences","pos":[0,23]}]},{"content":"A numbered backreference uses the following syntax:","pos":[1423,1474]},{"pos":[1476,1488],"content":"<ph id=\"ph1\">`\\`</ph> <bpt id=\"p1\">*</bpt>number<ept id=\"p1\">*</ept>","source":"`\\` *number*"},{"content":"where <bpt id=\"p1\">*</bpt>number<ept id=\"p1\">*</ept> is the ordinal position of the capturing group in the regular expression.","pos":[1490,1578],"source":"where *number* is the ordinal position of the capturing group in the regular expression."},{"content":"For example, <ph id=\"ph1\">`\\4`</ph> matches the contents of the fourth capturing group.","pos":[1579,1648],"source":" For example, `\\4` matches the contents of the fourth capturing group."},{"content":"If <bpt id=\"p1\">*</bpt>number<ept id=\"p1\">*</ept> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[1649,1811],"source":" If *number* is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <xref:System.ArgumentException>."},{"content":"For example, the regular expression <ph id=\"ph1\">`\\b(\\w+)\\s\\1`</ph> is valid, because <ph id=\"ph2\">`(\\w+)`</ph> is the first and only capturing group in the expression.","pos":[1812,1944],"source":" For example, the regular expression `\\b(\\w+)\\s\\1` is valid, because `(\\w+)` is the first and only capturing group in the expression."},{"content":"On the other hand, <ph id=\"ph1\">`\\b(\\w+)\\s\\2`</ph> is invalid and throws an argument exception, because there is no capturing group numbered <ph id=\"ph2\">`\\2`</ph>.","pos":[1945,2073],"source":" On the other hand, `\\b(\\w+)\\s\\2` is invalid and throws an argument exception, because there is no capturing group numbered `\\2`."},{"content":"In addition, if <bpt id=\"p1\">*</bpt>number<ept id=\"p1\">*</ept> identifies a capturing group in a particular ordinal position, but that capturing group has been assigned a numeric name different than its ordinal position, the regular expression parser also throws an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[2074,2334],"source":" In addition, if *number* identifies a capturing group in a particular ordinal position, but that capturing group has been assigned a numeric name different than its ordinal position, the regular expression parser also throws an <xref:System.ArgumentException>."},{"content":"Note the ambiguity between octal escape codes (such as <ph id=\"ph1\">`\\16`</ph>) and <ph id=\"ph2\">`\\`</ph><bpt id=\"p1\">*</bpt>number<ept id=\"p1\">*</ept> backreferences that use the same notation.","pos":[2336,2456],"source":"Note the ambiguity between octal escape codes (such as `\\16`) and `\\`*number* backreferences that use the same notation."},{"content":"This ambiguity is resolved as follows:","pos":[2457,2495]},{"pos":[2499,2598],"content":"The expressions <ph id=\"ph1\">`\\1`</ph> through <ph id=\"ph2\">`\\9`</ph> are always interpreted as backreferences, and not as octal codes.","source":"The expressions `\\1` through `\\9` are always interpreted as backreferences, and not as octal codes."},{"pos":[2602,2727],"content":"If the first digit of a multidigit expression is 8 or 9 (such as <ph id=\"ph1\">`\\80`</ph> or <ph id=\"ph2\">`\\91`</ph>), the expression as interpreted as a literal.","source":"If the first digit of a multidigit expression is 8 or 9 (such as `\\80` or `\\91`), the expression as interpreted as a literal."},{"pos":[2731,2901],"content":"Expressions from <ph id=\"ph1\">`\\10`</ph> and greater are considered backreferences if there is a backreference corresponding to that number; otherwise, they are interpreted as octal codes.","source":"Expressions from `\\10` and greater are considered backreferences if there is a backreference corresponding to that number; otherwise, they are interpreted as octal codes."},{"pos":[2905,3084],"content":"If a regular expression contains a backreference to an undefined group number, a parsing error occurs, and the regular expression engine throws an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","source":"If a regular expression contains a backreference to an undefined group number, a parsing error occurs, and the regular expression engine throws an <xref:System.ArgumentException>."},{"content":"If the ambiguity is a problem, you can use the <ph id=\"ph1\">`\\k&lt;`</ph><bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept><ph id=\"ph2\">`&gt;`</ph> notation, which is unambiguous and cannot be confused with octal character codes.","pos":[3086,3229],"source":"If the ambiguity is a problem, you can use the `\\k<`*name*`>` notation, which is unambiguous and cannot be confused with octal character codes."},{"content":"Similarly, hexadecimal codes such as <ph id=\"ph1\">`\\xdd`</ph> are unambiguous and cannot be confused with backreferences.","pos":[3230,3333],"source":" Similarly, hexadecimal codes such as `\\xdd` are unambiguous and cannot be confused with backreferences."},{"content":"The following example finds doubled word characters in a string.","pos":[3335,3399]},{"content":"It defines a regular expression, <ph id=\"ph1\">`(\\w)\\1`</ph>, which consists of the following elements.","pos":[3400,3484],"source":" It defines a regular expression, `(\\w)\\1`, which consists of the following elements."},{"content":"Element","pos":[3487,3494]},{"content":"Description","pos":[3495,3506]},{"content":"Match a word character and assign it to the first capturing group.","pos":[3550,3616]},{"content":"Match the next character that is the same as the value of the first capturing group.","pos":[3624,3708]},{"pos":[4070,4090],"content":"Named Backreferences","linkify":"Named Backreferences","nodes":[{"content":"Named Backreferences","pos":[0,20]}]},{"content":"A named backreference is defined by using the following syntax:","pos":[4092,4155]},{"pos":[4157,4173],"content":"<ph id=\"ph1\">`\\k&lt;`</ph> <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> <ph id=\"ph2\">`&gt;`</ph>","source":"`\\k<` *name* `>`"},{"content":"or:","pos":[4175,4178]},{"pos":[4180,4196],"content":"<ph id=\"ph1\">`\\k'`</ph> <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> <ph id=\"ph2\">`'`</ph>","source":"`\\k'` *name* `'`"},{"content":"where <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> is the name of a capturing group defined in the regular expression pattern.","pos":[4198,4286],"source":"where *name* is the name of a capturing group defined in the regular expression pattern."},{"content":"If <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[4287,4447],"source":" If *name* is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <xref:System.ArgumentException>."},{"content":"The following example finds doubled word characters in a string.","pos":[4449,4513]},{"content":"It defines a regular expression, <ph id=\"ph1\">`(?&lt;char&gt;\\w)\\k&lt;char&gt;`</ph>, which consists of the following elements.","pos":[4514,4611],"source":" It defines a regular expression, `(?<char>\\w)\\k<char>`, which consists of the following elements."},{"content":"Element","pos":[4614,4621]},{"content":"Description","pos":[4622,4633]},{"pos":[4684,4755],"content":"Match a word character and assign it to a capturing group named <ph id=\"ph1\">`char`</ph>.","source":"Match a word character and assign it to a capturing group named `char`."},{"pos":[4769,4854],"content":"Match the next character that is the same as the value of the <ph id=\"ph1\">`char`</ph> capturing group.","source":"Match the next character that is the same as the value of the `char` capturing group."},{"pos":[5216,5244],"content":"Named numeric backreferences","linkify":"Named numeric backreferences","nodes":[{"content":"Named numeric backreferences","pos":[0,28]}]},{"content":"In a named backreference with <ph id=\"ph1\">`\\k`</ph>, <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> can also be the string representation of a number.","pos":[5246,5339],"source":"In a named backreference with `\\k`, *name* can also be the string representation of a number."},{"content":"For example, the following example uses the regular expression <ph id=\"ph1\">`(?&lt;2&gt;\\w)\\k&lt;2&gt;`</ph> to find doubled word characters in a string.","pos":[5340,5463],"source":" For example, the following example uses the regular expression `(?<2>\\w)\\k<2>` to find doubled word characters in a string."},{"content":"In this case, the example defines a capturing group that is explicitly named \"2\", and the backreference is correspondingly named \"2\".","pos":[5464,5597]},{"content":"If <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> is the string representation of a number, and no capturing group has that name, <ph id=\"ph1\">`\\k&lt;`</ph><bpt id=\"p2\">*</bpt>name<ept id=\"p2\">*</ept><ph id=\"ph2\">`&gt;`</ph> is the same as the backreference <ph id=\"ph3\">`\\`</ph><bpt id=\"p3\">*</bpt>number<ept id=\"p3\">*</ept>, where <bpt id=\"p4\">*</bpt>number<ept id=\"p4\">*</ept> is the ordinal position of the capture.","pos":[5955,6160],"source":"If *name* is the string representation of a number, and no capturing group has that name, `\\k<`*name*`>` is the same as the backreference `\\`*number*, where *number* is the ordinal position of the capture."},{"content":"In the following example, there is a single capturing group named <ph id=\"ph1\">`char`</ph>.","pos":[6161,6234],"source":" In the following example, there is a single capturing group named `char`."},{"content":"The backreference construct refers to it as <ph id=\"ph1\">`\\k&lt;1&gt;`</ph>.","pos":[6235,6287],"source":" The backreference construct refers to it as `\\k<1>`."},{"content":"As the output from the example shows, the call to the <ph id=\"ph1\">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType&gt;</ph> succeeds because <ph id=\"ph2\">`char`</ph> is the first capturing group.","pos":[6288,6479],"source":" As the output from the example shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> succeeds because `char` is the first capturing group."},{"content":"However, if <bpt id=\"p1\">*</bpt>name<ept id=\"p1\">*</ept> is the string representation of a number and the capturing group in that position has been explicitly assigned a numeric name, the regular expression parser cannot identify the capturing group by its ordinal position.","pos":[6787,7023],"source":"However, if *name* is the string representation of a number and the capturing group in that position has been explicitly assigned a numeric name, the regular expression parser cannot identify the capturing group by its ordinal position."},{"content":"Instead, it throws an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.The only capturing group in the following example is named \"2\".","pos":[7024,7141],"source":" Instead, it throws an <xref:System.ArgumentException>.The only capturing group in the following example is named \"2\"."},{"content":"Because the <ph id=\"ph1\">`\\k`</ph> construct is used to define a backreference named \"1\", the regular expression parser is unable to identify the first capturing group and throws an exception.","pos":[7142,7316],"source":" Because the `\\k` construct is used to define a backreference named \"1\", the regular expression parser is unable to identify the first capturing group and throws an exception."},{"pos":[7627,7652],"content":"What Backreferences Match","linkify":"What Backreferences Match","nodes":[{"content":"What Backreferences Match","pos":[0,25]}]},{"content":"A backreference refers to the most recent definition of a group (the definition most immediately to the left, when matching left to right).","pos":[7654,7793]},{"content":"When a group makes multiple captures, a backreference refers to the most recent capture.","pos":[7794,7882]},{"content":"The following example includes a regular expression pattern, <ph id=\"ph1\">`(?&lt;1&gt;a)(?&lt;1&gt;\\1b)*`</ph>, which redefines the \\1 named group.","pos":[7884,8001],"source":"The following example includes a regular expression pattern, `(?<1>a)(?<1>\\1b)*`, which redefines the \\1 named group."},{"content":"The following table describes each pattern in the regular expression.","pos":[8002,8071]},{"content":"Pattern","pos":[8074,8081]},{"content":"Description","pos":[8082,8093]},{"pos":[8140,8219],"content":"Match the character \"a\" and assign the result to the capturing group named <ph id=\"ph1\">`1`</ph>.","source":"Match the character \"a\" and assign the result to the capturing group named `1`."},{"pos":[8235,8362],"content":"Match zero or more occurrences of the group named <ph id=\"ph1\">`1`</ph> along with a \"b\", and assign the result to the capturing group named <ph id=\"ph2\">`1`</ph>.","source":"Match zero or more occurrences of the group named `1` along with a \"b\", and assign the result to the capturing group named `1`."},{"content":"In comparing the regular expression with the input string (\"aababb\"), the regular expression engine performs the following operations:","pos":[8721,8855]},{"content":"It starts at the beginning of the string, and successfully matches \"a\" with the expression <ph id=\"ph1\">`(?&lt;1&gt;a)`</ph>.","pos":[8860,8961],"source":"It starts at the beginning of the string, and successfully matches \"a\" with the expression `(?<1>a)`."},{"content":"The value of the <ph id=\"ph1\">`1`</ph> group is now \"a\".","pos":[8962,9000],"source":" The value of the `1` group is now \"a\"."},{"content":"It advances to the second character, and successfully matches the string \"ab\" with the expression <ph id=\"ph1\">`\\1b`</ph>, or \"ab\".","pos":[9005,9118],"source":"It advances to the second character, and successfully matches the string \"ab\" with the expression `\\1b`, or \"ab\"."},{"content":"It then assigns the result, \"ab\" to <ph id=\"ph1\">`\\1`</ph>.","pos":[9119,9160],"source":" It then assigns the result, \"ab\" to `\\1`."},{"content":"It advances to the fourth character.","pos":[9165,9201]},{"content":"The expression <ph id=\"ph1\">`(?&lt;1&gt;\\1b)*`</ph> is to be matched zero or more times, so it successfully matches the string \"abb\" with the expression <ph id=\"ph2\">`\\1b`</ph>.","pos":[9202,9337],"source":" The expression `(?<1>\\1b)*` is to be matched zero or more times, so it successfully matches the string \"abb\" with the expression `\\1b`."},{"content":"It assigns the result, \"abb\", back to <ph id=\"ph1\">`\\1`</ph>.","pos":[9338,9381],"source":" It assigns the result, \"abb\", back to `\\1`."},{"content":"In this example, <ph id=\"ph1\">`*`</ph> is a looping quantifier -- it is evaluated repeatedly until the regular expression engine cannot match the pattern it defines.","pos":[9383,9530],"source":"In this example, `*` is a looping quantifier -- it is evaluated repeatedly until the regular expression engine cannot match the pattern it defines."},{"content":"Looping quantifiers do not clear group definitions.","pos":[9531,9582]},{"content":"If a group has not captured any substrings, a backreference to that group is undefined and never matches.","pos":[9584,9689]},{"content":"This is illustrated by the regular expression pattern <ph id=\"ph1\">`\\b(\\p{Lu}{2})(\\d{2})?(\\p{Lu}{2})\\b`</ph>, which is defined as follows:","pos":[9690,9810],"source":" This is illustrated by the regular expression pattern `\\b(\\p{Lu}{2})(\\d{2})?(\\p{Lu}{2})\\b`, which is defined as follows:"},{"content":"Pattern","pos":[9813,9820]},{"content":"Description","pos":[9821,9832]},{"content":"Begin the match on a word boundary.","pos":[9874,9909]},{"content":"Match two uppercase letters.","pos":[9926,9954]},{"content":"This is the first capturing group.","pos":[9955,9989]},{"content":"Match zero or one occurrence of two decimal digits.","pos":[10003,10054]},{"content":"This is the second capturing group.","pos":[10055,10090]},{"content":"Match two uppercase letters.","pos":[10107,10135]},{"content":"This is the third capturing group.","pos":[10136,10170]},{"content":"End the match on a word boundary.","pos":[10178,10211]},{"content":"An input string can match this regular expression even if the two decimal digits that are defined by the second capturing group are not present.","pos":[10214,10358]},{"content":"The following example shows that even though the match is successful, an empty capturing group is found between two successful capturing groups.","pos":[10359,10503]},{"pos":[10864,10872],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10876,11005],"content":"<bpt id=\"p1\">[</bpt>Regular Expression Language - Quick Reference<ept id=\"p1\">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept>","source":"[Regular Expression Language - Quick Reference](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)"}]}