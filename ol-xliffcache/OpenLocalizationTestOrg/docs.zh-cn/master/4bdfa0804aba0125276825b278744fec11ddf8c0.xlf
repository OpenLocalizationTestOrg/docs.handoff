<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4bdfa0804aba0125276825b278744fec11ddf8c0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\whats-new\csharp-7.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">97056a122ecd94bbe6e31660305d30c05eb0e979</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">495951c7d65945fe675ca24d1041b284210fe692</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>What's New in C# 7 | C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Get an overview of the new features coming in the upcoming version 7 of the C# language.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C#, .NET, .NET Core, Latest Features, What's New</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>What's new in C# 7</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>C# 7 adds a number of new features to the C# language:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`out`</ph> variables<ept id="p1">](#out-variables)</ept>:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can declare <ph id="ph1">`out`</ph> values inline as arguments to the method where they are used.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tuples<ept id="p1">](#tuples)</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can create lightweight, unnamed types that contain multiple public fields.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Compilers and IDE tools understand the semantics of these types.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Pattern Matching<ept id="p1">](#pattern-matching)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can create branching logic based on arbitrary types and values of the members of those types.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`ref`</ph> locals and returns<ept id="p1">](#ref-locals-and-returns)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Method arguments and local variables can be references to other storage.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Local Functions<ept id="p1">](#local-functions)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can nest functions inside other functions to limit their scope and visibility.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>More expression-bodied members<ept id="p1">](#more-expression-bodied-members)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The list of members that can be authored using expressions has grown.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`throw`</ph> Expressions<ept id="p1">](#throw-expressions)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can throw exceptions in code constructs that previously were not allowed because <ph id="ph1">`throw`</ph> was a statement.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generalized async return types<ept id="p1">](#generalized-async-return-types)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Methods declared with the <ph id="ph1">`async`</ph> modifier can return other types in addition to <ph id="ph2">`Task`</ph> and <ph id="ph3">`Task&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Numeric literal syntax improvements<ept id="p1">](#numeric-literal-syntax-improvements)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>New tokens improve readability for numeric constants.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The remainder of this topic discusses each of the features.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For each feature, you'll learn the reasoning behind it.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You'll learn the syntax.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You'll see some sample scenarios where using the new feature will make you more productive as a developer.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`out`</ph> variables</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The existing syntax that supports <ph id="ph1">`out`</ph> parameters has been improved in this version.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Previously, you would need to separate the declaration of the out variable and its initialization into two different statements:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>OutVariableOldStyle<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#03_OutVariableOldStyle "</bpt>classic out variable declaration<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can now declare <ph id="ph1">`out`</ph> variables in the argument list of a method call, rather than writing a separate declaration statement:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>OutVariableDeclarations<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#01_OutVariableDeclarations "</bpt>Out variable declarations<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You may want to specify the type of the <ph id="ph1">`out`</ph> variable for clarity, as shown above.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>However, the language does support using an implicitly typed local variable:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>OutVarVariableDeclarations<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#02_OutVarVariableDeclarations "</bpt>Implicitly typed Out variable<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The code is easier to read.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You declare the out variable where you use it, not on another line above.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>No need to assign an initial value.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>By declaring the <ph id="ph1">`out`</ph> variable where it is used in a method call, you can't accidentally use it before it is assigned.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The most common use for this feature will be the <ph id="ph1">`Try`</ph> pattern.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In this pattern, a method returns a <ph id="ph1">`bool`</ph> indicating success or failure and an <ph id="ph2">`out`</ph> variable that provides the result if the method succeeds.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When using the <ph id="ph1">`out`</ph> variable declaration, the declared variable "leaks" into the outer scope of the if statement.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This allows you to use the variable afterwards:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Tuples</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>C# provides a rich syntax for classes and structs that is used to explain your design intent.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>But sometimes that rich syntax requires extra work with minimal benefit.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You may often write methods that need a simple structure containing more than one data element.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>To support these scenarios <bpt id="p1">*</bpt>tuples<ept id="p1">*</ept> were added to C#.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Tuples are lightweight data structures that contain multiple fields to represent the data members.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The fields are not validated, and you cannot define your own methods</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Tuples were available before C# 7 as an API, but had many limitations.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Most importantly, the members of these tuples were named <ph id="ph1">`Item1`</ph>, <ph id="ph2">`Item2`</ph> and so on.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The language support enables semantic names for the fields of a Tuple.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can create a tuple by assigning each member to a value:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UnnamedTuple<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#04_UnnamedTuple "</bpt>Unnamed tuple<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>That assignment creates a tuple whose members are <ph id="ph1">`Item1`</ph> and <ph id="ph2">`Item2`</ph>, following the existing <ph id="ph3">@System.Tuple</ph> syntax.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can modify that assignment to create a tuple that provides semantic names to each of the members of the tuple:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>NamedTuple<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#05_NamedTuple "</bpt>Named tuple<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The new tuples features require the <ph id="ph1">`System.ValueTuple`</ph> type.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For Visual Studio 2017, you must add the NuGet package <bpt id="p1">[</bpt>System.ValueTuple<ept id="p1">](https://www.nuget.org/packages/System.ValueTuple/)</ept>, available on the NuGet Gallery.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`namedLetters`</ph> tuple contains fields referred to as <ph id="ph2">`Alpha`</ph> and <ph id="ph3">`Beta`</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ImplicitNamedTuple<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#06_ImplicitNamedTuple "</bpt>Implicitly named tuple<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The language allows you to specify names for the fields on both the left and right-hand side of the assignment:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>NamedTupleConflict<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#07_NamedTupleConflict "</bpt>Named tuple conflict<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The line above generates a warning, <ph id="ph1">`CS8123`</ph>, telling you that the names on the right side of the assignment, <ph id="ph2">`Alpha`</ph> and <ph id="ph3">`Beta`</ph> are ignored because they conflict with the names on the left side, <ph id="ph4">`First`</ph> and <ph id="ph5">`Second`</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The examples above show the basic syntax to declare tuples.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Tuples are most useful as return types for <ph id="ph1">`private`</ph> and <ph id="ph2">`internal`</ph> methods.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Tuples provide a simple syntax for those methods to return multiple discrete values: You save the work of authoring a <ph id="ph1">`class`</ph> or a <ph id="ph2">`struct`</ph> that defines the type returned.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>There is no need for creating a new type.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Creating a tuple is more efficient and more productive.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It is a simpler, lightweight syntax to define a data structure that carries more than one value.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The example method below returns the minimum and maximum values found in a sequence of integers:</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TupleReturningMethod<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#08_TupleReturningMethod "</bpt>Tuple returning method<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Using tuples in this way offers several advantages:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You save the work of authoring a <ph id="ph1">`class`</ph> or a <ph id="ph2">`struct`</ph> that defines the type returned.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You do not need to create new type.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The language enhancements removes the need to call the &lt;xref:System.Tuple.Create<ph id="ph1">``1(``</ph>0)&gt; methods.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The declaration for the method provides the names for the fields of the tuple that is returned.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>When you call the method, the return value is a tuple whose fields are <ph id="ph1">`Max`</ph> and <ph id="ph2">`Min`</ph>:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>CallingTupleMethod<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#09_CallingTupleMethod "</bpt>Calling a tuple returning method<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>There may be times when you want to unpackage the members of a tuple that were returned from a method.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You can do that by declaring separate variables for each of the values in the tuple.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This is called <bpt id="p1">*</bpt>deconstructing<ept id="p1">*</ept> the tuple:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>CallingWithDeconstructor<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#10_CallingWithDeconstructor "</bpt>Deconstructing a tuple<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can also provide a similar deconstruction for any type in .NET.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This is done by writing a <ph id="ph1">`Deconstruct`</ph> method as a member of the class.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>That <ph id="ph1">`Deconstruct`</ph> method provides a set of <ph id="ph2">`out`</ph> arguments for each of the properties you want to extract.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Consider this <ph id="ph1">`Point`</ph> class that provides a deconstructor method that extracts the <ph id="ph2">`X`</ph> and <ph id="ph3">`Y`</ph> coordinates:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>PointWithDeconstruction<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/point.cs#11_PointWithDeconstruction "</bpt>Point with deconstruction method<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You can extract the individual fields by assigning a tuple to a <ph id="ph1">`Point`</ph>:</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>DeconstructPoint<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#12_DeconstructPoint "</bpt>Deconstruct a point<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You are not bound by the names defined in the <ph id="ph1">`Deconstruct`</ph> method.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can rename the extract variables as part of the assignment:</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>DeconstructNames<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#13_DeconstructNames "</bpt>Deconstruct with new names<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can learn more in depth about tuples in the <bpt id="p1">[</bpt>tuples topic<ept id="p1">](../tuples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Pattern matching<ept id="p1">*</ept> is a feature that allows you to implement method dispatch on properties other than the type of an object.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>You're probably already familiar with method dispatch based on the type of an object.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In Object Oriented programming, virtual and override methods provide language syntax to implement method dispatching based on an object's type.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Base and Derived classes provide different implementations.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Pattern matching expressions extend this concept so that you can easily implement similar dispatch patterns for types and data elements that are not related through an inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Pattern matching supports <ph id="ph1">`is`</ph> expressions and <ph id="ph2">`switch`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Each enables inspecting an object and its properties to determine if that object satisfies the sought pattern.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>You use the <ph id="ph1">`when`</ph> keyword to specify additional rules to the pattern.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`is`</ph> expression</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`is`</ph> pattern expression extends the familiar <ph id="ph2">`is`</ph> operator to query an object beyond its type.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Let's start with a simple scenario.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>We'll add capabilities to this scenario that demonstrate how pattern matching expressions make algorithms that work with unrelated types easy.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>We'll start with a method that computes the sum of a number of die rolls:</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SumDieRolls<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#14_SumDieRolls "</bpt>Sum die rolls<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You might quickly find that you need to find the sum of die rolls where some of the rolls are made with more than one die.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Part of the input sequence may be multiple results instead of a single number:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SumDieRollsWithGroups<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#15_SumDieRollsWithGroups "</bpt>Sum die rolls with groups<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`is`</ph> pattern expression works quite well in this scenario.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>As part of checking the type, you write a variable initialization.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This creates a new variable of the validated runtime type.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>As you keep extending these scenarios, you may find that you build more <ph id="ph1">`if`</ph> and <ph id="ph2">`else if`</ph> statements.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Once that becomes unwieldy, you'll likely want to switch to <ph id="ph1">`switch`</ph> pattern expressions.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`switch`</ph> statement updates</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>match expression<ept id="p1">*</ept> has a familiar syntax, based on the <ph id="ph1">`switch`</ph> statement already part of the C# language.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Let's translate the existing code to use a match expression before adding new cases:</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SumUsingSwitch<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#16_SumUsingSwitch "</bpt>Sum using switch<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The match expressions have a slightly different syntax than the <ph id="ph1">`is`</ph> expressions, where you declare the type and variable at the beginning of the <ph id="ph2">`case`</ph> expression.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The match expressions also support constants.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This can save time by factoring out simple cases:</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SwitchWithConstants<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#17_SwitchWithConstants "</bpt>Switch with constants<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The code above adds cases for <ph id="ph1">`0`</ph> as a special case of <ph id="ph2">`int`</ph>, and <ph id="ph3">`null`</ph> as a special case when there is no input.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This demonstrates one important new feature in switch pattern expressions: the order of the <ph id="ph1">`case`</ph> expressions now matters.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`0`</ph> case must appear before the general <ph id="ph2">`int`</ph> case.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Otherwise, the first pattern to match would be the <ph id="ph1">`int`</ph> case, even when the value is <ph id="ph2">`0`</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>If you accidentally order match expressions such that a later case has already been handled, the compiler will flag that and generate an error.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>This same behavior enables the special case for an empty input sequence.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>You can see that the case for an <ph id="ph1">`IEnumerable`</ph> item that has elements must appear before the general <ph id="ph2">`IEnumerable`</ph> case.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This version has also added a <ph id="ph1">`default`</ph> case.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`default`</ph> case is always evaluated last, regardless of the order it appears in the source.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For that reason, convention is to put the <ph id="ph1">`default`</ph> case last.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Finally, let's add one last <ph id="ph1">`case`</ph> for a new style of die.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Some games use percentile dice to represent larger ranges of numbers.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Two 10-sided percentile dice can represent every number from 0 through 99.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>One die has sides labelled <ph id="ph1">`00`</ph>, <ph id="ph2">`10`</ph>, <ph id="ph3">`20`</ph>, ... <ph id="ph4">`90`</ph>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The other die has sides labeled <ph id="ph1">`0`</ph>, <ph id="ph2">`1`</ph>, <ph id="ph3">`2`</ph>, ... <ph id="ph4">`9`</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Add the two die values together and you can get every number from 0 through 99.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>To add this kind of die to your collection, first define a type to represent the percentile die:</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>18_PercentileDie<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#18_PercentileDie "</bpt>Percentile Die type<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Then, add a <ph id="ph1">`case`</ph> match expression for the new type:</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SwitchWithNewTypes<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#19_SwitchWithNewTypes "</bpt>Include Percentile Die type<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The new syntax for pattern matching expressions makes it easier to create dispatch algorithms based on an object's type, or other properties, using a clear and concise syntax.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>You can learn more about pattern matching in the topic dedicated to <bpt id="p1">[</bpt>pattern matching in C#<ept id="p1">](../pattern-matching.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Ref locals and returns</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This feature enables algorithms that use and return references to variables defined elsewhere.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>One example is working with large matrices, and finding a single location with certain characteristics.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>One method would return the two indices for a single location in the matrix:</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>FindReturningIndices<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#20_FindReturningIndices "</bpt>Find returning indices<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>There are many issues with this code.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>First of all, it's a public method that's returning a tuple.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The language supports this, but user defined types (either classes or structs) are preferred for public APIs.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Second, this method is returning the indices to the item in the matrix.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>That leads callers to write code that uses those indices to dereference the matrix and modify a single element:</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UpdateItemFromIndices<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#21_UpdateItemFromIndices "</bpt>Update Item From Indices<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>You'd rather write a method that returns a <bpt id="p1">*</bpt>reference<ept id="p1">*</ept> to the element of the matrix that you want to change.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>You could only accomplish this by using unsafe code and returning a pointer to an <ph id="ph1">`int`</ph> in previous versions.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Along the way, you'll learn the rules of the ref return and ref local feature that protects you from accidentally misusing it.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Start by modifying the <ph id="ph1">`Find`</ph> method declaration so that it returns a <ph id="ph2">`ref int`</ph> instead of a tuple.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Then, modify the return statement so it returns the value stored in the matrix instead of the two indices:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>When you declare that a method returns a <ph id="ph1">`ref`</ph> variable, you must also add the <ph id="ph2">`ref`</ph> keyword to each return statement.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>FindReturningRef<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#22_FindReturningRef "</bpt>Find returning by reference<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`var`</ph> declaration means that <ph id="ph2">`valItem`</ph> is now an <ph id="ph3">`int`</ph> rather than a tuple:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>AssignRefReturnToValue<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#23_AssignRefReturnToValue "</bpt>Assign ref return to value<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">`WriteLine`</ph> statement in the example above prints out the value <ph id="ph2">`42`</ph>, not <ph id="ph3">`24`</ph>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The variable <ph id="ph1">`valItem`</ph> is an <ph id="ph2">`int`</ph>, not a <ph id="ph3">`ref int`</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`var`</ph> keyword enables the compiler to specify the type, but will not implicitly add the <ph id="ph2">`ref`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Instead, the value referred to by the <ph id="ph1">`ref return`</ph> is <bpt id="p1">*</bpt>copied<ept id="p1">*</ept> to the variable on the left-hand side of the assignment.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The variable is not a <ph id="ph1">`ref`</ph> local.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>In order to get the result you want, you need to add the <ph id="ph1">`ref`</ph> modifier to the local variable declaration to make the variable a reference when the return value is a reference:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>AssignRefReturn<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#24_AssignRefReturn "</bpt>Assign ref return<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Now, the second <ph id="ph1">`WriteLine`</ph> statement in the example above will print out the value <ph id="ph2">`24`</ph>, indicating that the storage in the matrix has been modified.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The local variable has been declared with the <ph id="ph1">`ref`</ph> modifier, and it will take a <ph id="ph2">`ref`</ph> return.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>You must initialize a <ph id="ph1">`ref`</ph> variable when it is declared, you cannot split the declaration and the initialization.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The C# language has three other rules that protect you from misusing the <ph id="ph1">`ref`</ph> locals and returns:</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>You cannot assign a standard method return value to a <ph id="ph1">`ref`</ph> local variable.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>That disallows statements like <ph id="ph1">`ref int i = sequence.Count();`</ph></source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You cannot return a <ph id="ph1">`ref`</ph> to a variable whose lifetime does not extend beyond the execution of the method.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>That means you cannot return a reference to a local variable or a variable with a similar scope.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ref`</ph> locals and returns can't be used with async methods.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The compiler can't know if the referenced variable has been set to its final value when the async method returns.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values, or performing dereferencing operations multiple times.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Local functions</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Many designs for classes include methods that are called from only one location.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>These additional private methods keep each method small and focused.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>However, they can make it harder to understand a class when reading it the first time.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>These methods must be understood outside of the context of the single calling location.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For those designs, <bpt id="p1">*</bpt>local functions<ept id="p1">*</ept> enable you to declare methods inside the context of another method.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>This makes it easier for readers of the class to see that the local method is only called from the context in which is it declared.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>There are two very common use cases for local functions: public iterator methods and public async methods.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Both types of methods generate code that reports errors later than programmers might expect.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>In the case of async methods, any exceptions are only observed when the returned <ph id="ph1">`Task`</ph> is awaited.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Let's start with an iterator method:</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>IteratorMethod<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Iterator.cs#25_IteratorMethod "</bpt>Iterator method<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Examine the code below that calls the iterator method incorrectly:</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>CallIteratorMethod<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/program.cs#26_CallIteratorMethod "</bpt>Call iterator method<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The exception is thrown when <ph id="ph1">`resultSet`</ph> is iterated, not when <ph id="ph2">`resultSet`</ph> is created.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>In this contained example, most developers could quickly diagnose the problem.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>However, in larger codebases, the code that creates an iterator often isn't as close to the code that enumerates the result.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You can refactor the code so that the public method validates all arguments, and a private method generates the enumeration:</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>IteratorMethodRefactored<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Iterator.cs#27_IteratorMethodRefactored "</bpt>Iterator method refactored<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>This refactored version will throw exceptions immediately because the public method is not an iterator method; only the private method uses the <ph id="ph1">`yield return`</ph> syntax.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>However, there are potential problems with this refactoring.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The private method should only be called from the public interface method, because otherwise all argument validation is skipped.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Readers of the class must discover this fact by reading the entire class and searching for any other references to the <ph id="ph1">`alphabetSubsetImplementation`</ph> method.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>You can make that design intent more clear by declaring the <ph id="ph1">`alphabetSubsetImplementation`</ph> as a local function inside the public API method:</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>22_IteratorMethodLocal<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Iterator.cs#28_IteratorMethodLocal "</bpt>Iterator method with local function<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The version above makes it clear that the local method is referenced only in the context of the outer method.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The same technique can be employed with <ph id="ph1">`async`</ph> methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins:</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>TaskExample<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "</bpt>Task returning method with local function<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Some of the designs that are supported by local functions could also be accomplished using <bpt id="p1">*</bpt>lambda expressions<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Those interested can <bpt id="p1">[</bpt>read more about the differences<ept id="p1">](../local-functions-vs-lambdas.md)</ept></source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>More expression-bodied members</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>C# 6 introduced <bpt id="p1">[</bpt>expression-bodied members<ept id="p1">](csharp-6.md#expression-bodied-function-members)</ept> for member functions, and read-only properties.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>C# 7 expands the allowed members that can be implemented as expressions.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>In C# 7, you can implement <bpt id="p1">*</bpt>constructors<ept id="p1">*</ept>, <bpt id="p2">*</bpt>finalizers<ept id="p2">*</ept>, and <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors on <bpt id="p3">*</bpt>properties<ept id="p3">*</ept> and <bpt id="p4">*</bpt>indexers<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The following code shows examples of each:</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ExpressionBodiedMembers<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/expressionmembers.cs#36_ExpressionBodiedEverything "</bpt>new expression-bodied members<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>This example does not need a finalizer, but it is shown to demonstrate the syntax.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>You should not implement a finalizer in your class unless it is necessary to  release unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>You should also consider using the <ph id="ph1">@System.Runtime.InteropServices.SafeHandle</ph> class instead of managing unmanaged resources directly.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>These new locations for expression-bodied members represent an important milestone for the C# language: These features were implemented by community members working on the open-source <bpt id="p1">[</bpt>Roslyn<ept id="p1">](https://github.com/dotnet/Roslyn)</ept> project.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Throw expressions</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>In C#, <ph id="ph1">`throw`</ph> has always been a statement.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`throw`</ph> is a statement, not an expression, there were C# constructs where you could not use it.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>These included conditional expressions, null coalescing expressions, and some lambda expressions.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The addition of expression-bodied members adds more locations where <ph id="ph1">`throw`</ph> expressions would be useful.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>So that you can write any of these constructs, C# 7 introduces <bpt id="p1">*</bpt>throw expressions<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The syntax is the same as you've always used for <ph id="ph1">`throw`</ph> statements.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The only difference is that now you can place them in new locations, such as in a conditional expression:</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Throw_ExpressionExample<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#37_Throw_ExpressionExample "</bpt>conditional throw expressions<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>This features enables using throw expressions in initialization expressions:</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ThrowInInitialization<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#38_ThrowInInitialization "</bpt>conditional throw expressions<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Previously, those initializations would need to be in a constructor, with the throw statements in the body of the constructor:</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ThrowInConstructor<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#39_ThrowInConstructor "</bpt>throw statements<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Both of the preceding constructs will cause exceptions to be thrown during the construction of an object.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Those are often difficult to recover from.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>For that reason, designs that throw exceptions during construction are discouraged.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Generalized async return types</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Returning a <ph id="ph1">`Task`</ph> object from async methods can introduce performance bottlenecks in certain paths.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> is a reference type, so using it means allocating an object.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>In cases where a method declared with the <ph id="ph1">`async`</ph> modifier returns a cached result, or completes synchronously, the extra allocations can become a significant time cost in performance critical sections of code.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>It can become very costly if those allocations occur in tight loops.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The new language feature means that async methods may return other types in addition to <ph id="ph1">`Task`</ph>, <ph id="ph2">`Task&lt;T&gt;`</ph> and <ph id="ph3">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The returned type must still satisfy the async pattern, meaning a <ph id="ph1">`GetAwaiter`</ph> method must be accessible.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>As one concrete example, the <ph id="ph1">`ValueTask`</ph> type has been added to the .NET framework to make use of this new language feature:</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UsingValueTask<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#30_UsingValueTask "</bpt>Using ValueTask<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>You need to add the pre-release NuGet package <ph id="ph1">`System.Threading.Tasks.Extensions`</ph> in order to use <ph id="ph2">`ValueTask`</ph> in Visual Studio 15 Preview 5.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>A simple optimization would be to use <ph id="ph1">`ValueTask`</ph> in places where <ph id="ph2">`Task`</ph> would be used before.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>However, if you want to perform extra optimizations by hand, you can cache results from async work and reuse the result in subsequent calls.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ValueTask`</ph> struct has a constructor with a <ph id="ph2">`Task`</ph> parameter so that you can construct a <ph id="ph3">`ValueTask`</ph> from the return value of any existing async method:</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>AsyncOptimizedValueTask<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#31_AsyncOptimizedValueTask "</bpt>Return async result or cached value<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>As with all performance recommendations, you should benchmark both versions before making large scale changes to your code.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Numeric literal syntax improvements</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Misreading numeric constants can make it harder to understand code when reading it for the first time.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>This often occurs when those numbers are used as bit masks or other symbolic rather than numeric values.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>C# 7 includes two new features to make it easier to write numbers in the most readable fashion for the intended use: <bpt id="p1">*</bpt>binary literals<ept id="p1">*</ept>, and <bpt id="p2">*</bpt>digit separators<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>For those times when you are creating bit masks, or whenever a binary representation of a number makes the most readable code, write that number in binary:</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>BinaryConstants<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Program.cs#32_BinaryConstants "</bpt>Binary constants<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`0b`</ph> at the beginning of the constant indicates that the number is written as a binary number.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Binary numbers can get very long, so it's often easier to see the bit patterns by introducing the <ph id="ph1">`_`</ph> as a digit separator:</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>ThousandSeparators<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Program.cs#33_ThousandSeparators "</bpt>Thousands separators<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The digit separator can appear anywhere in the constant.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>For base 10 numbers, it would be common to use it as a thousands separator:</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>LargeIntegers<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Program.cs#34_LargeIntegers "</bpt>Large integer<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>The digit separator can be used with <ph id="ph1">`decimal`</ph>, <ph id="ph2">`float`</ph> and <ph id="ph3">`double`</ph> types as well:</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>OtherConstants<ept id="p2">]</ept><bpt id="p3">(../../../samples/snippets/csharp/new-in-7/Program.cs#35_OtherConstants "</bpt>non-integral constants<ept id="p3">")</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Taken together, you can declare numeric constants with much more readability.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>