{"content":"---\ntitle: \"Synchronizing Data for Multithreading\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"synchronization, threads\"\n  - \"threading [.NET Framework], synchronizing threads\"\n  - \"managed threading\"\nms.assetid: b980eb4c-71d5-4860-864a-6dfe3692430a\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Synchronizing Data for Multithreading\nWhen multiple threads can make calls to the properties and methods of a single object, it is critical that those calls be synchronized. Otherwise one thread might interrupt what another thread is doing, and the object could be left in an invalid state. A class whose members are protected from such interruptions is called thread-safe.  \n  \n The Common Language Infrastructure provides several strategies to synchronize access to instance and static members:  \n  \n-   Synchronized code regions. You can use the <xref:System.Threading.Monitor> class or compiler support for this class to synchronize only the code block that needs it, improving performance.  \n  \n-   Manual synchronization. You can use the synchronization objects provided by the .NET Framework class library. See [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md), which includes a discussion of the <xref:System.Threading.Monitor> class.  \n  \n-   Synchronized contexts. You can use the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> to enable simple, automatic synchronization for <xref:System.ContextBoundObject> objects.  \n  \n-   Collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace. These classes provide built-in synchronized add and remove operations. For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).  \n  \n The common language runtime provides a thread model in which classes fall into a number of categories that can be synchronized in a variety of different ways depending on the requirements. The following table shows what synchronization support is provided for fields and methods with a given synchronization category.  \n  \n|Category|Global fields|Static fields|Static methods|Instance fields|Instance methods|Specific code blocks|  \n|--------------|-------------------|-------------------|--------------------|---------------------|----------------------|--------------------------|  \n|No Synchronization|No|No|No|No|No|No|  \n|Synchronized Context|No|No|No|Yes|Yes|No|  \n|Synchronized Code Regions|No|No|Only if marked|No|Only if marked|Only if marked|  \n|Manual Synchronization|Manual|Manual|Manual|Manual|Manual|Manual|  \n  \n## No Synchronization  \n This is the default for objects. Any thread can access any method or field at any time. Only one thread at a time should access these objects.  \n  \n## Manual Synchronization  \n The .NET Framework class library provides a number of classes for synchronizing threads. See [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md).  \n  \n## Synchronized Code Regions  \n You can use the <xref:System.Threading.Monitor> class or a compiler keyword to synchronize blocks of code, instance methods, and static methods. There is no support for synchronized static fields.  \n  \n Both Visual Basic and C# support the marking of blocks of code with a particular language keyword, the `lock` statement in C# or the `SyncLock` statement in Visual Basic. When the code is executed by a thread, an attempt is made to acquire the lock. If the lock has already been acquired by another thread, the thread blocks until the lock becomes available. When the thread exits the synchronized block of code, the lock is released, no matter how the thread exits the block.  \n  \n> [!NOTE]\n>  The `lock` and `SyncLock` statements are implemented using <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>, so other methods of <xref:System.Threading.Monitor> can be used in conjunction with them within the synchronized region.  \n  \n You can also decorate a method with a **MethodImplAttribute** and **MethodImplOptions.Synchronized**, which has the same effect as using **Monitor** or one of the compiler keywords to lock the entire body of the method.  \n  \n <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> can be used to break a thread out of blocking operations such as waiting for access to a synchronized region of code. **Thread.Interrupt** is also used to break threads out of operations like <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>.  \n  \n> [!IMPORTANT]\n>  Do not lock the type — that is, `typeof(MyType)` in C#, `GetType(MyType)` in Visual Basic, or `MyType::typeid` in C++ — in order to protect `static` methods (`Shared` methods in Visual Basic). Use a private static object instead. Similarly, do not use `this` in C# (`Me` in Visual Basic) to lock instance methods. Use a private object instead. A class or instance can be locked by code other than your own, potentially causing deadlocks or performance problems.  \n  \n### Compiler Support  \n Both Visual Basic and C# support a language keyword that uses <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> to lock the object. Visual Basic supports the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement; C# supports the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement.  \n  \n In both cases, if an exception is thrown in the code block, the lock acquired by the **lock** or **SyncLock** is released automatically. The C# and Visual Basic compilers emit a **try**/**finally** block with **Monitor.Enter** at the beginning of the try, and **Monitor.Exit** in the **finally** block. If an exception is thrown inside the **lock** or **SyncLock** block, the **finally** handler runs to allow you to do any clean-up work.  \n  \n## Synchronized Context  \n You can use the **SynchronizationAttribute** on any **ContextBoundObject** to synchronize all instance methods and fields. All objects in the same context domain share the same lock. Multiple threads are allowed to access the methods and fields, but only a single thread is allowed at any one time.  \n  \n## See also\n\n- <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>\n- [Threads and Threading](../../../docs/standard/threading/threads-and-threading.md)\n- [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md)\n- [SyncLock Statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md)\n- [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md)\n","nodes":[{"pos":[4,325],"embed":true,"restype":"x-metadata","content":"title: \"Synchronizing Data for Multithreading\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"synchronization, threads\"\n  - \"threading [.NET Framework], synchronizing threads\"\n  - \"managed threading\"\nms.assetid: b980eb4c-71d5-4860-864a-6dfe3692430a\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Synchronizing Data for Multithreading","nodes":[{"pos":[0,37],"content":"Synchronizing Data for Multithreading","nodes":[{"content":"Synchronizing Data for Multithreading","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[332,369],"content":"Synchronizing Data for Multithreading","linkify":"Synchronizing Data for Multithreading","nodes":[{"content":"Synchronizing Data for Multithreading","pos":[0,37]}]},{"content":"When multiple threads can make calls to the properties and methods of a single object, it is critical that those calls be synchronized.","pos":[370,505]},{"content":"Otherwise one thread might interrupt what another thread is doing, and the object could be left in an invalid state.","pos":[506,622]},{"content":"A class whose members are protected from such interruptions is called thread-safe.","pos":[623,705]},{"content":"The Common Language Infrastructure provides several strategies to synchronize access to instance and static members:","pos":[712,828]},{"content":"Synchronized code regions.","pos":[838,864]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class or compiler support for this class to synchronize only the code block that needs it, improving performance.","pos":[865,1026],"source":" You can use the <xref:System.Threading.Monitor> class or compiler support for this class to synchronize only the code block that needs it, improving performance."},{"content":"Manual synchronization.","pos":[1036,1059]},{"content":"You can use the synchronization objects provided by the .NET Framework class library.","pos":[1060,1145]},{"content":"See <bpt id=\"p1\">[</bpt>Overview of Synchronization Primitives<ept id=\"p1\">](../../../docs/standard/threading/overview-of-synchronization-primitives.md)</ept>, which includes a discussion of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class.","pos":[1146,1341],"source":" See [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md), which includes a discussion of the <xref:System.Threading.Monitor> class."},{"content":"Synchronized contexts.","pos":[1351,1373]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> to enable simple, automatic synchronization for <ph id=\"ph2\">&lt;xref:System.ContextBoundObject&gt;</ph> objects.","pos":[1374,1544],"source":" You can use the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> to enable simple, automatic synchronization for <xref:System.ContextBoundObject> objects."},{"content":"Collection classes in the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent?displayProperty=nameWithType&gt;</ph> namespace.","pos":[1554,1656],"source":"Collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace."},{"content":"These classes provide built-in synchronized add and remove operations.","pos":[1657,1727]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Thread-Safe Collections<ept id=\"p1\">](../../../docs/standard/collections/thread-safe/index.md)</ept>.","pos":[1728,1837],"source":" For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md)."},{"content":"The common language runtime provides a thread model in which classes fall into a number of categories that can be synchronized in a variety of different ways depending on the requirements.","pos":[1844,2032]},{"content":"The following table shows what synchronization support is provided for fields and methods with a given synchronization category.","pos":[2033,2161]},{"content":"Category","pos":[2168,2176]},{"content":"Global fields","pos":[2177,2190]},{"content":"Static fields","pos":[2191,2204]},{"content":"Static methods","pos":[2205,2219]},{"content":"Instance fields","pos":[2220,2235]},{"content":"Instance methods","pos":[2236,2252]},{"content":"Specific code blocks","pos":[2253,2273]},{"content":"No Synchronization","pos":[2430,2448]},{"content":"No","pos":[2449,2451]},{"content":"No","pos":[2452,2454]},{"content":"No","pos":[2455,2457]},{"content":"No","pos":[2458,2460]},{"content":"No","pos":[2461,2463]},{"content":"No","pos":[2464,2466]},{"content":"Synchronized Context","pos":[2471,2491]},{"content":"No","pos":[2492,2494]},{"content":"No","pos":[2495,2497]},{"content":"No","pos":[2498,2500]},{"content":"Yes","pos":[2501,2504]},{"content":"Yes","pos":[2505,2508]},{"content":"No","pos":[2509,2511]},{"content":"Synchronized Code Regions","pos":[2516,2541]},{"content":"No","pos":[2542,2544]},{"content":"No","pos":[2545,2547]},{"content":"Only if marked","pos":[2548,2562]},{"content":"No","pos":[2563,2565]},{"content":"Only if marked","pos":[2566,2580]},{"content":"Only if marked","pos":[2581,2595]},{"content":"Manual Synchronization","pos":[2600,2622]},{"content":"Manual","pos":[2623,2629]},{"content":"Manual","pos":[2630,2636]},{"content":"Manual","pos":[2637,2643]},{"content":"Manual","pos":[2644,2650]},{"content":"Manual","pos":[2651,2657]},{"content":"Manual","pos":[2658,2664]},{"pos":[2674,2692],"content":"No Synchronization","linkify":"No Synchronization","nodes":[{"content":"No Synchronization","pos":[0,18]}]},{"content":"This is the default for objects.","pos":[2696,2728]},{"content":"Any thread can access any method or field at any time.","pos":[2729,2783]},{"content":"Only one thread at a time should access these objects.","pos":[2784,2838]},{"pos":[2847,2869],"content":"Manual Synchronization","linkify":"Manual Synchronization","nodes":[{"content":"Manual Synchronization","pos":[0,22]}]},{"content":"The .NET Framework class library provides a number of classes for synchronizing threads.","pos":[2873,2961]},{"content":"See <bpt id=\"p1\">[</bpt>Overview of Synchronization Primitives<ept id=\"p1\">](../../../docs/standard/threading/overview-of-synchronization-primitives.md)</ept>.","pos":[2962,3083],"source":" See [Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md)."},{"pos":[3092,3117],"content":"Synchronized Code Regions","linkify":"Synchronized Code Regions","nodes":[{"content":"Synchronized Code Regions","pos":[0,25]}]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class or a compiler keyword to synchronize blocks of code, instance methods, and static methods.","pos":[3121,3265],"source":"You can use the <xref:System.Threading.Monitor> class or a compiler keyword to synchronize blocks of code, instance methods, and static methods."},{"content":"There is no support for synchronized static fields.","pos":[3266,3317]},{"content":"Both Visual Basic and C# support the marking of blocks of code with a particular language keyword, the <ph id=\"ph1\">`lock`</ph> statement in C# or the <ph id=\"ph2\">`SyncLock`</ph> statement in Visual Basic.","pos":[3324,3494],"source":"Both Visual Basic and C# support the marking of blocks of code with a particular language keyword, the `lock` statement in C# or the `SyncLock` statement in Visual Basic."},{"content":"When the code is executed by a thread, an attempt is made to acquire the lock.","pos":[3495,3573]},{"content":"If the lock has already been acquired by another thread, the thread blocks until the lock becomes available.","pos":[3574,3682]},{"content":"When the thread exits the synchronized block of code, the lock is released, no matter how the thread exits the block.","pos":[3683,3800]},{"pos":[3808,4142],"content":"[!NOTE]\n The `lock` and `SyncLock` statements are implemented using <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>, so other methods of <xref:System.Threading.Monitor> can be used in conjunction with them within the synchronized region.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">`lock`</ph> and <ph id=\"ph2\">`SyncLock`</ph> statements are implemented using <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph>, so other methods of <ph id=\"ph5\">&lt;xref:System.Threading.Monitor&gt;</ph> can be used in conjunction with them within the synchronized region.","pos":[9,332],"source":"The `lock` and `SyncLock` statements are implemented using <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>, so other methods of <xref:System.Threading.Monitor> can be used in conjunction with them within the synchronized region."}]},{"pos":[4149,4368],"content":"You can also decorate a method with a <bpt id=\"p1\">**</bpt>MethodImplAttribute<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>MethodImplOptions.Synchronized<ept id=\"p2\">**</ept>, which has the same effect as using <bpt id=\"p3\">**</bpt>Monitor<ept id=\"p3\">**</ept> or one of the compiler keywords to lock the entire body of the method.","source":"You can also decorate a method with a **MethodImplAttribute** and **MethodImplOptions.Synchronized**, which has the same effect as using **Monitor** or one of the compiler keywords to lock the entire body of the method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType&gt;</ph> can be used to break a thread out of blocking operations such as waiting for access to a synchronized region of code.","pos":[4375,4565],"source":"<xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> can be used to break a thread out of blocking operations such as waiting for access to a synchronized region of code."},{"content":"<bpt id=\"p1\">**</bpt>Thread.Interrupt<ept id=\"p1\">**</ept> is also used to break threads out of operations like <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph>.","pos":[4566,4709],"source":"**Thread.Interrupt** is also used to break threads out of operations like <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>."},{"pos":[4717,5194],"content":"[!IMPORTANT]\n Do not lock the type — that is, `typeof(MyType)` in C#, `GetType(MyType)` in Visual Basic, or `MyType::typeid` in C++ — in order to protect `static` methods (`Shared` methods in Visual Basic). Use a private static object instead. Similarly, do not use `this` in C# (`Me` in Visual Basic) to lock instance methods. Use a private object instead. A class or instance can be locked by code other than your own, potentially causing deadlocks or performance problems.","leadings":["","> "],"nodes":[{"content":"Do not lock the type — that is, `typeof(MyType)` in C#, `GetType(MyType)` in Visual Basic, or `MyType::typeid` in C++ — in order to protect `static` methods (`Shared` methods in Visual Basic). Use a private static object instead. Similarly, do not use `this` in C# (`Me` in Visual Basic) to lock instance methods. Use a private object instead. A class or instance can be locked by code other than your own, potentially causing deadlocks or performance problems.","pos":[14,475],"nodes":[{"content":"Do not lock the type — that is, <ph id=\"ph1\">`typeof(MyType)`</ph> in C#, <ph id=\"ph2\">`GetType(MyType)`</ph> in Visual Basic, or <ph id=\"ph3\">`MyType::typeid`</ph> in C++ — in order to protect <ph id=\"ph4\">`static`</ph> methods (<ph id=\"ph5\">`Shared`</ph> methods in Visual Basic).","pos":[0,192],"source":"Do not lock the type — that is, `typeof(MyType)` in C#, `GetType(MyType)` in Visual Basic, or `MyType::typeid` in C++ — in order to protect `static` methods (`Shared` methods in Visual Basic)."},{"content":"Use a private static object instead.","pos":[193,229]},{"content":"Similarly, do not use <ph id=\"ph1\">`this`</ph> in C# (<ph id=\"ph2\">`Me`</ph> in Visual Basic) to lock instance methods.","pos":[230,313],"source":" Similarly, do not use `this` in C# (`Me` in Visual Basic) to lock instance methods."},{"content":"Use a private object instead.","pos":[314,343]},{"content":"A class or instance can be locked by code other than your own, potentially causing deadlocks or performance problems.","pos":[344,461]}]}]},{"pos":[5204,5220],"content":"Compiler Support","linkify":"Compiler Support","nodes":[{"content":"Compiler Support","pos":[0,16]}]},{"content":"Both Visual Basic and C# support a language keyword that uses <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> to lock the object.","pos":[5224,5448],"source":"Both Visual Basic and C# support a language keyword that uses <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> to lock the object."},{"content":"Visual Basic supports the <bpt id=\"p1\">[</bpt>SyncLock<ept id=\"p1\">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement; C# supports the <bpt id=\"p2\">[</bpt>lock<ept id=\"p2\">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement.","pos":[5449,5664],"source":" Visual Basic supports the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement; C# supports the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement."},{"content":"In both cases, if an exception is thrown in the code block, the lock acquired by the <bpt id=\"p1\">**</bpt>lock<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>SyncLock<ept id=\"p2\">**</ept> is released automatically.","pos":[5671,5807],"source":"In both cases, if an exception is thrown in the code block, the lock acquired by the **lock** or **SyncLock** is released automatically."},{"content":"The C# and Visual Basic compilers emit a <bpt id=\"p1\">**</bpt>try<ept id=\"p1\">**</ept><ph id=\"ph1\">/</ph><bpt id=\"p2\">**</bpt>finally<ept id=\"p2\">**</ept> block with <bpt id=\"p3\">**</bpt>Monitor.Enter<ept id=\"p3\">**</ept> at the beginning of the try, and <bpt id=\"p4\">**</bpt>Monitor.Exit<ept id=\"p4\">**</ept> in the <bpt id=\"p5\">**</bpt>finally<ept id=\"p5\">**</ept> block.","pos":[5808,5973],"source":" The C# and Visual Basic compilers emit a **try**/**finally** block with **Monitor.Enter** at the beginning of the try, and **Monitor.Exit** in the **finally** block."},{"content":"If an exception is thrown inside the <bpt id=\"p1\">**</bpt>lock<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>SyncLock<ept id=\"p2\">**</ept> block, the <bpt id=\"p3\">**</bpt>finally<ept id=\"p3\">**</ept> handler runs to allow you to do any clean-up work.","pos":[5974,6109],"source":" If an exception is thrown inside the **lock** or **SyncLock** block, the **finally** handler runs to allow you to do any clean-up work."},{"pos":[6118,6138],"content":"Synchronized Context","linkify":"Synchronized Context","nodes":[{"content":"Synchronized Context","pos":[0,20]}]},{"content":"You can use the <bpt id=\"p1\">**</bpt>SynchronizationAttribute<ept id=\"p1\">**</ept> on any <bpt id=\"p2\">**</bpt>ContextBoundObject<ept id=\"p2\">**</ept> to synchronize all instance methods and fields.","pos":[6142,6264],"source":"You can use the **SynchronizationAttribute** on any **ContextBoundObject** to synchronize all instance methods and fields."},{"content":"All objects in the same context domain share the same lock.","pos":[6265,6324]},{"content":"Multiple threads are allowed to access the methods and fields, but only a single thread is allowed at any one time.","pos":[6325,6440]},{"pos":[6449,6457],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6528,6610],"content":"<bpt id=\"p1\">[</bpt>Threads and Threading<ept id=\"p1\">](../../../docs/standard/threading/threads-and-threading.md)</ept>","source":"[Threads and Threading](../../../docs/standard/threading/threads-and-threading.md)"},{"pos":[6613,6729],"content":"<bpt id=\"p1\">[</bpt>Overview of Synchronization Primitives<ept id=\"p1\">](../../../docs/standard/threading/overview-of-synchronization-primitives.md)</ept>","source":"[Overview of Synchronization Primitives](../../../docs/standard/threading/overview-of-synchronization-primitives.md)"},{"pos":[6732,6825],"content":"<bpt id=\"p1\">[</bpt>SyncLock Statement<ept id=\"p1\">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept>","source":"[SyncLock Statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md)"},{"pos":[6828,6905],"content":"<bpt id=\"p1\">[</bpt>lock Statement<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept>","source":"[lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md)"}]}