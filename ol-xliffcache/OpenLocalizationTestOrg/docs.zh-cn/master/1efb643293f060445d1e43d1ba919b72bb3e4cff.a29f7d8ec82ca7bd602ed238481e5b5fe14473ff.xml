{"content":"---\ntitle: \"Default Marshaling Behavior | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"interop marshaling, default\"\n  - \"interoperation with unmanaged code, marshaling\"\n  - \"marshaling behavior\"\nms.assetid: c0a9bcdf-3df8-4db3-b1b6-abbdb2af809a\ncaps.latest.revision: 15\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Default Marshaling Behavior\nInterop marshaling operates on rules that dictate how data associated with method parameters behaves as it passes between managed and unmanaged memory. These built-in rules control such marshaling activities as data type transformations, whether a callee can change data passed to it and return those changes to the caller, and under which circumstances the marshaler provides performance optimizations.  \n  \n This section identifies the default behavioral characteristics of the interop marshaling service. It presents detailed information on marshaling arrays, Boolean types, char types, delegates, classes, objects, strings, and structures.  \n  \n> [!NOTE]\n>  Marshaling of generic types is not supported. For more information see, [Interoperating Using Generic Types](http://msdn.microsoft.com/en-us/26b88e03-085b-4b53-94ba-a5a9c709ce58).  \n  \n## Memory management with the interop marshaler  \n The interop marshaler always attempts to free memory allocated by unmanaged code. This behavior complies with COM memory management rules, but differs from the rules that govern native C++.  \n  \n Confusion can arise if you anticipate native C++ behavior (no memory freeing) when using platform invoke, which automatically frees memory for pointers. For example, calling the following unmanaged method from a C++ DLL does not automatically free any memory.  \n  \n### Unmanaged signature  \n  \n```  \nBSTR MethodOne (BSTR b) {  \n     return b;  \n}  \n```  \n  \n However, if you define the method as a platform invoke prototype, replace each **BSTR** type with a <xref:System.String> type, and call `MethodOne`, the common language runtime attempts to free `b` twice. You can change the marshaling behavior by using <xref:System.IntPtr> types rather than **String** types.  \n  \n The runtime always uses the **CoTaskMemFree** method to free memory. If the memory you are working with was not allocated with the **CoTaskMemAlloc** method, you must use an **IntPtr** and free the memory manually using the appropriate method. Similarly, you can avoid automatic memory freeing in situations where memory should never be freed, such as when using the **GetCommandLine** function from Kernel32.dll, which returns a pointer to kernel memory. For details on manually freeing memory, see the [Buffers Sample](http://msdn.microsoft.com/en-us/e30d36e8-d7c4-4936-916a-8fdbe4d9ffd5).  \n  \n## Default marshaling for classes  \n Classes can be marshaled only by COM interop and are always marshaled as interfaces. In some cases the interface used to marshal the class is known as the class interface. For information about overriding the class interface with an interface of your choice, see [Introducing the Class Interface](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024).  \n  \n### Passing Classes to COM  \n When a managed class is passed to COM, the interop marshaler automatically wraps the class with a COM proxy and passes the class interface produced by the proxy to the COM method call. The proxy then delegates all calls on the class interface back to the managed object. The proxy also exposes other interfaces that are not explicitly implemented by the class. The proxy automatically implements interfaces such as **IUnknown** and **IDispatch** on behalf of the class.  \n  \n### Passing Classes to .NET Code  \n Coclasses are not typically used as method arguments in COM. Instead, a default interface is usually passed in place of the coclass.  \n  \n When an interface is passed into managed code, the interop marshaler is responsible for wrapping the interface with the proper wrapper and passing the wrapper to the managed method. Determining which wrapper to use can be difficult. Every instance of a COM object has a single, unique wrapper, no matter how many interfaces the object implements. For example, a single COM object that implements five distinct interfaces has only one wrapper. The same wrapper exposes all five interfaces. If two instances of the COM object are created, then two instances of the wrapper are created.  \n  \n For the wrapper to maintain the same type throughout its lifetime, the interop marshaler must identify the correct wrapper the first time an interface exposed by the object is passed through the marshaler. The marshaler identifies the object by looking at one of the interfaces the object implements.  \n  \n For example, the marshaler determines that the class wrapper should be used to wrap the interface that was passed into managed code. When the interface is first passed through the marshaler, the marshaler checks whether the interface is coming from a known object. This check occurs in two situations:  \n  \n-   An interface is being implemented by another managed object that was passed to COM elsewhere. The marshaler can readily identify interfaces exposed by managed objects and is able to match the interface with the managed object that provides the implementation. The managed object is then passed to the method and no wrapper is needed.  \n  \n-   An object that has already been wrapped is implementing the interface. To determine whether this is the case, the marshaler queries the object for its **IUnknown** interface and compares the returned interface to the interfaces of other objects that are already wrapped. If the interface is the same as that of another wrapper, the objects have the same identity and the existing wrapper is passed to the method.  \n  \n If an interface is not from a known object, the marshaler does the following:  \n  \n1.  The marshaler queries the object for the **IProvideClassInfo2** interface. If provided, the marshaler uses the CLSID returned from **IProvideClassInfo2.GetGUID** to identify the coclass providing the interface. With the CLSID, the marshaler can locate the wrapper from the registry if the assembly has previously been registered.  \n  \n2.  The marshaler queries the interface for the **IProvideClassInfo** interface. If provided, the marshaler uses the **ITypeInfo** returned from **IProvideClassInfo.GetClassinfo** to determine the CLSID of the class exposing the interface. The marshaler can use the CLSID to locate the metadata for the wrapper.  \n  \n3.  If the marshaler still cannot identify the class, it wraps the interface with a generic wrapper class called **System.__ComObject**.  \n  \n## Default marshaling for delegates  \n A managed delegate is marshaled as a COM interface or as a function pointer, based on the calling mechanism:  \n  \n-   For platform invoke, a delegate is marshaled as an unmanaged function pointer by default.  \n  \n-   For COM interop, a delegate is marshaled as a COM interface of type **_Delegate** by default. The **_Delegate** interface is defined in the Mscorlib.tlb type library and contains the <xref:System.Delegate.DynamicInvoke%2A?displayProperty=fullName> method, which enables you to call the method that the delegate references.  \n  \n The following table shows the marshaling options for the managed delegate data type. The <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute provides several <xref:System.Runtime.InteropServices.UnmanagedType> enumeration values to marshal delegates.  \n  \n|Enumeration type|Description of unmanaged format|  \n|----------------------|-------------------------------------|  \n|**UnmanagedType.FunctionPtr**|An unmanaged function pointer.|  \n|**UnmanagedType.Interface**|An interface of type **_Delegate**, as defined in Mscorlib.tlb.|  \n  \n Consider the following example code in which the methods of `DelegateTestInterface` are exported to a COM type library. Notice that only delegates marked with the **ref** (or **ByRef**) keyword are passed as In/Out parameters.  \n  \n```csharp  \nusing System;  \nusing System.Runtime.InteropServices;  \n  \npublic interface DelegateTest {  \nvoid m1(Delegate d);  \nvoid m2([MarshalAs(UnmanagedType.Interface)] Delegate d);     \nvoid m3([MarshalAs(UnmanagedType.Interface)] ref Delegate d);    \nvoid m4([MarshalAs(UnmanagedType.FunctionPtr)] Delegate d);   \nvoid m5([MarshalAs(UnmanagedType.FunctionPtr)] ref Delegate d);     \n}  \n```  \n  \n### Type library representation  \n  \n```  \nimportlib(\"mscorlib.tlb\");  \ninterface DelegateTest : IDispatch {  \n[id(…)] HRESULT m1([in] _Delegate* d);  \n[id(…)] HRESULT m2([in] _Delegate* d);  \n[id(…)] HRESULT m3([in, out] _Delegate** d);  \n[id()] HRESULT m4([in] int d);  \n[id()] HRESULT m5([in, out] int *d);  \n   };  \n```  \n  \n A function pointer can be dereferenced, just as any other unmanaged function pointer can be dereferenced.  \n  \n> [!NOTE]\n>  A reference to the function pointer to a managed delegate held by unmanaged code does not prevent the common language runtime from performing garbage collection on the managed object.  \n  \n For example, the following code is incorrect because the reference to the `cb` object, passed to the `SetChangeHandler` method, does not keep `cb` alive beyond the life of the `Test` method. Once the `cb` object is garbage collected, the function pointer passed to `SetChangeHandler` is no longer valid.  \n  \n```csharp  \npublic class ExternalAPI {  \n   [DllImport(\"External.dll\")]  \n   public static extern void SetChangeHandler(  \n      [MarshalAs(UnmanagedType.FunctionPtr)]ChangeDelegate d);  \n}  \npublic delegate bool ChangeDelegate([MarshalAs(UnmanagedType.LPWStr) string S);  \npublic class CallBackClass {  \n   public bool OnChange(string S){ return true;}  \n}  \ninternal class DelegateTest {  \n   public static void Test() {  \n      CallBackClass cb = new CallBackClass();  \n      // Caution: The following reference on the cb object does not keep the   \n      // object from being garbage collected after the Main method   \n      // executes.  \n      ExternalAPI.SetChangeHandler(new ChangeDelegate(cb.OnChange));     \n   }  \n}  \n```  \n  \n To compensate for unexpected garbage collection, the caller must ensure that the `cb` object is kept alive as long as the unmanaged function pointer is in use. Optionally, you can have the unmanaged code notify the managed code when the function pointer is no longer needed, as the following example shows.  \n  \n```csharp  \ninternal class DelegateTest {  \n   CallBackClass cb;  \n   // Called before ever using the callback function.  \n   public static void SetChangeHandler() {  \n      cb = new CallBackClass();  \n      ExternalAPI.SetChangeHandler(new ChangeDelegate(cb.OnChange));  \n   }  \n   // Called after using the callback function for the last time.  \n   public static void RemoveChangeHandler() {  \n      // The cb object can be collected now. The unmanaged code is   \n      // finished with the callback function.  \n      cb = null;  \n   }  \n}  \n```  \n  \n## Default marshaling for value types  \n Most value types, such as integers and floating-point numbers, are [blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) and do not require marshaling. Other [non-blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) types have dissimilar representations in managed and unmanaged memory and do require marshaling. Still other types require explicit formatting across the interoperation boundary.  \n  \n This topic provides the follow information on formatted value types:  \n  \n-   [Value Types Used in Platform Invoke](#cpcondefaultmarshalingforvaluetypesanchor2)  \n  \n-   [Value Types Used in COM Interop](#cpcondefaultmarshalingforvaluetypesanchor3)  \n  \n In addition to describing formatted types, this topic identifies [System Value Types](#cpcondefaultmarshalingforvaluetypesanchor1) that have unusual marshaling behavior.  \n  \n A formatted type is a complex type that contains information that explicitly controls the layout of its members in memory. The member layout information is provided using the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute. The layout can be one of the following <xref:System.Runtime.InteropServices.LayoutKind> enumeration values:  \n  \n-   **LayoutKind.Automatic**  \n  \n     Indicates that the common language runtime is free to reorder the members of the type for efficiency. However, when a value type is passed to unmanaged code, the layout of the members is predictable. An attempt to marshal such a structure automatically causes an exception.  \n  \n-   **LayoutKind.Sequential**  \n  \n     Indicates that the members of the type are to be laid out in unmanaged memory in the same order in which they appear in the managed type definition.  \n  \n-   **LayoutKind.Explicit**  \n  \n     Indicates that the members are laid out according to the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> supplied with each field.  \n  \n<a name=\"cpcondefaultmarshalingforvaluetypesanchor2\"></a>   \n### Value Types Used in Platform Invoke  \n In the following example the `Point` and `Rect` types provide member layout information using the **StructLayoutAttribute**.  \n  \n```vb  \nImports System.Runtime.InteropServices  \n<StructLayout(LayoutKind.Sequential)> Public Structure Point  \n   Public x As Integer  \n   Public y As Integer  \nEnd Structure  \n<StructLayout(LayoutKind.Explicit)> Public Structure Rect  \n   <FieldOffset(0)> Public left As Integer  \n   <FieldOffset(4)> Public top As Integer  \n   <FieldOffset(8)> Public right As Integer  \n   <FieldOffset(12)> Public bottom As Integer  \nEnd Structure  \n  \n```  \n  \n```csharp  \nusing System.Runtime.InteropServices;  \n[StructLayout(LayoutKind.Sequential)]  \npublic struct Point {  \n   public int x;  \n   public int y;  \n}     \n  \n[StructLayout(LayoutKind.Explicit)]  \npublic struct Rect {  \n   [FieldOffset(0)] public int left;  \n   [FieldOffset(4)] public int top;  \n   [FieldOffset(8)] public int right;  \n   [FieldOffset(12)] public int bottom;  \n}  \n```  \n  \n When marshaled to unmanaged code, these formatted types are marshaled as C-style structures. This provides an easy way of calling an unmanaged API that has structure arguments. For example, the `POINT` and `RECT` structures can be passed to the Microsoft Win32 API **PtInRect** function as follows:  \n  \n```  \nBOOL PtInRect(const RECT *lprc, POINT pt);  \n```  \n  \n You can pass structures using the following platform invoke definition:  \n  \n```vb  \nClass Win32API      \n   Declare Auto Function PtInRect Lib \"User32.dll\" _  \n    (ByRef r As Rect, p As Point) As Boolean  \nEnd Class  \n  \n```  \n  \n```csharp  \nclass Win32API {  \n   [DllImport(\"User32.dll\")]  \n   public static extern Bool PtInRect(ref Rect r, Point p);  \n}  \n```  \n  \n The `Rect` value type must be passed by reference because the unmanaged API is expecting a pointer to a `RECT` to be passed to the function. The `Point` value type is passed by value because the unmanaged API expects the `POINT` to be passed on the stack. This subtle difference is very important. References are passed to unmanaged code as pointers. Values are passed to unmanaged code on the stack.  \n  \n> [!NOTE]\n>  When a formatted type is marshaled as a structure, only the fields within the type are accessible. If the type has methods, properties, or events, they are inaccessible from unmanaged code.  \n  \n Classes can also be marshaled to unmanaged code as C-style structures, provided they have fixed member layout. The member layout information for a class is also provided with the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute. The main difference between value types with fixed layout and classes with fixed layout is the way in which they are marshaled to unmanaged code. Value types are passed by value (on the stack) and consequently any changes made to the members of the type by the callee are not seen by the caller. Reference types are passed by reference (a reference to the type is passed on the stack); consequently, all changes made to blittable-type members of a type by the callee are seen by the caller.  \n  \n> [!NOTE]\n>  If a reference type has members of non-blittable types, conversion is required twice: the first time when an argument is passed to the unmanaged side and the second time on return from the call. Due to this added overhead, In/Out parameters must be explicitly applied to an argument if the caller wants to see changes made by the callee.  \n  \n In the following example, the `SystemTime` class has sequential member layout and can be passed to the Win32 API **GetSystemTime** function.  \n  \n```vb  \n<StructLayout(LayoutKind.Sequential)> Public Class SystemTime  \n   Public wYear As System.UInt16  \n   Public wMonth As System.UInt16  \n   Public wDayOfWeek As System.UInt16  \n   Public wDay As System.UInt16  \n   Public wHour As System.UInt16  \n   Public wMinute As System.UInt16  \n   Public wSecond As System.UInt16  \n   Public wMilliseconds As System.UInt16  \nEnd Class  \n  \n```  \n  \n```csharp  \n[StructLayout(LayoutKind.Sequential)]  \n   public class SystemTime {  \n   public ushort wYear;   \n   public ushort wMonth;  \n   public ushort wDayOfWeek;   \n   public ushort wDay;   \n   public ushort wHour;   \n   public ushort wMinute;   \n   public ushort wSecond;   \n   public ushort wMilliseconds;   \n}  \n```  \n  \n The **GetSystemTime** function is defined as follows:  \n  \n```  \nvoid GetSystemTime(SYSTEMTIME* SystemTime);  \n```  \n  \n The equivalent platform invoke definition for **GetSystemTime** is as follows:  \n  \n```vb  \nPublic Class Win32  \n   Declare Auto Sub GetSystemTime Lib \"Kernel32.dll\" (ByVal sysTime _  \n   As SystemTime)  \nEnd Class  \n  \n```  \n  \n```csharp  \nclass Win32API {  \n   [DllImport(\"Kernel32.dll\", CharSet=CharSet.Auto)]  \n   public static extern void GetSystemTime(SystemTime st);  \n}  \n```  \n  \n Notice that the `SystemTime` argument is not typed as a reference argument because `SystemTime` is a class, not a value type. Unlike value types, classes are always passed by reference.  \n  \n The following code example shows a different `Point` class that has a method called `SetXY`. Because the type has sequential layout, it can be passed to unmanaged code and marshaled as a structure. However, the `SetXY` member is not callable from unmanaged code, even though the object is passed by reference.  \n  \n```vb  \n<StructLayout(LayoutKind.Sequential)> Public Class Point  \n   Private x, y As Integer  \n   Public Sub SetXY(x As Integer, y As Integer)  \n      Me.x = x  \n      Me.y = y  \n   End Sub  \nEnd Class  \n  \n```  \n  \n```csharp  \n[StructLayout(LayoutKind.Sequential)]  \npublic class Point {  \n   int x, y;  \n   public void SetXY(int x, int y){   \n      this.x = x;  \n      this.y = y;  \n   }  \n}  \n```  \n  \n<a name=\"cpcondefaultmarshalingforvaluetypesanchor3\"></a>   \n### Value Types Used in COM Interop  \n Formatted types can also be passed to COM interop method calls. In fact, when exported to a type library, value types are automatically converted to structures. As the following example shows, the `Point` value type becomes a type definition (typedef) with the name `Point`. All references to the `Point` value type elsewhere in the type library are replaced with the `Point` typedef.  \n  \n **Type library representation**  \n  \n```  \ntypedef struct tagPoint {  \n   int x;  \n   int y;  \n} Point;  \ninterface _Graphics {  \n   …  \n   HRESULT SetPoint ([in] Point p)  \n   HRESULT SetPointRef ([in,out] Point *p)  \n   HRESULT GetPoint ([out,retval] Point *p)  \n}  \n```  \n  \n The same rules used to marshal values and references to platform invoke calls are used when marshaling through COM interfaces. For example, when an instance of the `Point` value type is passed from the .NET Framework to COM, the `Point` is passed by value. If the `Point` value type is passed by reference, a pointer to a `Point` is passed on the stack. The interop marshaler does not support higher levels of indirection (**Point \\*\\***) in either direction.  \n  \n> [!NOTE]\n>  Structures having the <xref:System.Runtime.InteropServices.LayoutKind> enumeration value set to **Explicit** cannot be used in COM interop because the exported type library cannot express an explicit layout.  \n  \n<a name=\"cpcondefaultmarshalingforvaluetypesanchor1\"></a>   \n### System Value Types  \n The <xref:System> namespace has several value types that represent the boxed form of the runtime primitive types. For example, the value type <xref:System.Int32?displayProperty=fullName> structure represents the boxed form of **ELEMENT_TYPE_I4**. Instead of marshaling these types as structures, as other formatted types are, you marshal them in the same way as the primitive types they box. **System.Int32** is therefore marshaled as **ELEMENT_TYPE_I4** instead of as a structure containing a single member of type **long**. The following table contains a list of the value types in the **System** namespace that are boxed representations of primitive types.  \n  \n|System value type|Element type|  \n|-----------------------|------------------|  \n|<xref:System.Boolean?displayProperty=fullName>|**ELEMENT_TYPE_BOOLEAN**|  \n|<xref:System.SByte?displayProperty=fullName>|**ELEMENT_TYPE_I1**|  \n|<xref:System.Byte?displayProperty=fullName>|**ELEMENT_TYPE_UI1**|  \n|<xref:System.Char?displayProperty=fullName>|**ELEMENT_TYPE_CHAR**|  \n|<xref:System.Int16?displayProperty=fullName>|**ELEMENT_TYPE_I2**|  \n|<xref:System.UInt16?displayProperty=fullName>|**ELEMENT_TYPE_U2**|  \n|<xref:System.Int32?displayProperty=fullName>|**ELEMENT_TYPE_I4**|  \n|<xref:System.UInt32?displayProperty=fullName>|**ELEMENT_TYPE_U4**|  \n|<xref:System.Int64?displayProperty=fullName>|**ELEMENT_TYPE_I8**|  \n|<xref:System.UInt64?displayProperty=fullName>|**ELEMENT_TYPE_U8**|  \n|<xref:System.Single?displayProperty=fullName>|**ELEMENT_TYPE_R4**|  \n|<xref:System.Double?displayProperty=fullName>|**ELEMENT_TYPE_R8**|  \n|<xref:System.String?displayProperty=fullName>|**ELEMENT_TYPE_STRING**|  \n|<xref:System.IntPtr?displayProperty=fullName>|**ELEMENT_TYPE_I**|  \n|<xref:System.UIntPtr?displayProperty=fullName>|**ELEMENT_TYPE_U**|  \n  \n Some other value types in the **System** namespace are handled differently. Because the unmanaged code already has well-established formats for these types, the marshaler has special rules for marshaling them. The following table lists the special value types in the **System** namespace, as well as the unmanaged type they are marshaled to.  \n  \n|System value type|IDL type|  \n|-----------------------|--------------|  \n|<xref:System.DateTime?displayProperty=fullName>|**DATE**|  \n|<xref:System.Decimal?displayProperty=fullName>|**DECIMAL**|  \n|<xref:System.Guid?displayProperty=fullName>|**GUID**|  \n|<xref:System.Drawing.Color?displayProperty=fullName>|**OLE_COLOR**|  \n  \n The following code shows the definition of the unmanaged types **DATE**, **GUID**, **DECIMAL**, and **OLE_COLOR** in the Stdole2 type library.  \n  \n#### Type library representation  \n  \n```  \ntypedef double DATE;  \ntypedef DWORD OLE_COLOR;  \n  \ntypedef struct tagDEC {  \n    USHORT    wReserved;  \n    BYTE      scale;  \n    BYTE      sign;  \n    ULONG     Hi32;  \n    ULONGLONG Lo64;  \n} DECIMAL;  \n  \ntypedef struct tagGUID {  \n    DWORD Data1;  \n    WORD  Data2;  \n    WORD  Data3;  \n    BYTE  Data4[ 8 ];  \n} GUID;  \n```  \n  \n The following code shows the corresponding definitions in the managed `IValueTypes` interface.  \n  \n```vb  \nPublic Interface IValueTypes  \n   Sub M1(d As System.DateTime)  \n   Sub M2(d As System.Guid)  \n   Sub M3(d As System.Decimal)  \n   Sub M4(d As System.Drawing.Color)  \nEnd Interface  \n  \n```  \n  \n```csharp  \npublic interface IValueTypes {  \n   void M1(System.DateTime d);  \n   void M2(System.Guid d);  \n   void M3(System.Decimal d);  \n   void M4(System.Drawing.Color d);  \n}  \n```  \n  \n#### Type library representation  \n  \n```  \n[…]  \ninterface IValueTypes : IDispatch {  \n   HRESULT M1([in] DATE d);  \n   HRESULT M2([in] GUID d);  \n   HRESULT M3([in] DECIMAL d);  \n   HRESULT M4([in] OLE_COLOR d);  \n};  \n```  \n  \n## See Also  \n [Blittable and Non-Blittable Types](../../../docs/framework/interop/blittable-and-non-blittable-types.md)   \n [Copying and Pinning](../../../docs/framework/interop/copying-and-pinning.md)   \n [Default Marshaling for Arrays](../../../docs/framework/interop/default-marshaling-for-arrays.md)   \n [Default Marshaling for Objects](../../../docs/framework/interop/default-marshaling-for-objects.md)   \n [Default Marshaling for Strings](../../../docs/framework/interop/default-marshaling-for-strings.md)","nodes":[{"pos":[4,545],"nodes":[{"content":"Default Marshaling Behavior | Microsoft Docs","nodes":[{"pos":[0,44],"content":"Default Marshaling Behavior | Microsoft Docs","nodes":[{"content":"Default Marshaling Behavior | Microsoft Docs","pos":[0,44]}]}],"pos":[6,53],"yaml":true}],"content":"title: \"Default Marshaling Behavior | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"interop marshaling, default\"\n  - \"interoperation with unmanaged code, marshaling\"\n  - \"marshaling behavior\"\nms.assetid: c0a9bcdf-3df8-4db3-b1b6-abbdb2af809a\ncaps.latest.revision: 15\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[552,579],"content":"Default Marshaling Behavior","linkify":"Default Marshaling Behavior","nodes":[{"content":"Default Marshaling Behavior","pos":[0,27]}]},{"content":"Interop marshaling operates on rules that dictate how data associated with method parameters behaves as it passes between managed and unmanaged memory.","pos":[580,731]},{"content":"These built-in rules control such marshaling activities as data type transformations, whether a callee can change data passed to it and return those changes to the caller, and under which circumstances the marshaler provides performance optimizations.","pos":[732,983]},{"content":"This section identifies the default behavioral characteristics of the interop marshaling service.","pos":[990,1087]},{"content":"It presents detailed information on marshaling arrays, Boolean types, char types, delegates, classes, objects, strings, and structures.","pos":[1088,1223]},{"pos":[1231,1421],"content":"[!NOTE]\n Marshaling of generic types is not supported. For more information see, [Interoperating Using Generic Types](http://msdn.microsoft.com/en-us/26b88e03-085b-4b53-94ba-a5a9c709ce58).","leadings":["","> "],"nodes":[{"content":"Marshaling of generic types is not supported. For more information see, [Interoperating Using Generic Types](http://msdn.microsoft.com/en-us/26b88e03-085b-4b53-94ba-a5a9c709ce58).","pos":[9,188],"nodes":[{"content":"Marshaling of generic types is not supported.","pos":[0,45]},{"content":"For more information see, <bpt id=\"p1\">[</bpt>Interoperating Using Generic Types<ept id=\"p1\">](http://msdn.microsoft.com/en-us/26b88e03-085b-4b53-94ba-a5a9c709ce58)</ept>.","pos":[46,179],"source":" For more information see, [Interoperating Using Generic Types](http://msdn.microsoft.com/en-us/26b88e03-085b-4b53-94ba-a5a9c709ce58)."}]}]},{"pos":[1430,1474],"content":"Memory management with the interop marshaler","linkify":"Memory management with the interop marshaler","nodes":[{"content":"Memory management with the interop marshaler","pos":[0,44]}]},{"content":"The interop marshaler always attempts to free memory allocated by unmanaged code.","pos":[1478,1559]},{"content":"This behavior complies with COM memory management rules, but differs from the rules that govern native C++.","pos":[1560,1667]},{"content":"Confusion can arise if you anticipate native C++ behavior (no memory freeing) when using platform invoke, which automatically frees memory for pointers.","pos":[1674,1826]},{"content":"For example, calling the following unmanaged method from a C++ DLL does not automatically free any memory.","pos":[1827,1933]},{"pos":[1943,1962],"content":"Unmanaged signature","linkify":"Unmanaged signature","nodes":[{"content":"Unmanaged signature","pos":[0,19]}]},{"content":"However, if you define the method as a platform invoke prototype, replace each <bpt id=\"p1\">**</bpt>BSTR<ept id=\"p1\">**</ept> type with a <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type, and call <ph id=\"ph2\">`MethodOne`</ph>, the common language runtime attempts to free <ph id=\"ph3\">`b`</ph> twice.","pos":[2033,2237],"source":"However, if you define the method as a platform invoke prototype, replace each **BSTR** type with a <xref:System.String> type, and call `MethodOne`, the common language runtime attempts to free `b` twice."},{"content":"You can change the marshaling behavior by using <ph id=\"ph1\">&lt;xref:System.IntPtr&gt;</ph> types rather than <bpt id=\"p1\">**</bpt>String<ept id=\"p1\">**</ept> types.","pos":[2238,2342],"source":" You can change the marshaling behavior by using <xref:System.IntPtr> types rather than **String** types."},{"content":"The runtime always uses the <bpt id=\"p1\">**</bpt>CoTaskMemFree<ept id=\"p1\">**</ept> method to free memory.","pos":[2349,2417],"source":"The runtime always uses the **CoTaskMemFree** method to free memory."},{"content":"If the memory you are working with was not allocated with the <bpt id=\"p1\">**</bpt>CoTaskMemAlloc<ept id=\"p1\">**</ept> method, you must use an <bpt id=\"p2\">**</bpt>IntPtr<ept id=\"p2\">**</ept> and free the memory manually using the appropriate method.","pos":[2418,2592],"source":" If the memory you are working with was not allocated with the **CoTaskMemAlloc** method, you must use an **IntPtr** and free the memory manually using the appropriate method."},{"content":"Similarly, you can avoid automatic memory freeing in situations where memory should never be freed, such as when using the <bpt id=\"p1\">**</bpt>GetCommandLine<ept id=\"p1\">**</ept> function from Kernel32.dll, which returns a pointer to kernel memory.","pos":[2593,2804],"source":" Similarly, you can avoid automatic memory freeing in situations where memory should never be freed, such as when using the **GetCommandLine** function from Kernel32.dll, which returns a pointer to kernel memory."},{"content":"For details on manually freeing memory, see the <bpt id=\"p1\">[</bpt>Buffers Sample<ept id=\"p1\">](http://msdn.microsoft.com/en-us/e30d36e8-d7c4-4936-916a-8fdbe4d9ffd5)</ept>.","pos":[2805,2940],"source":" For details on manually freeing memory, see the [Buffers Sample](http://msdn.microsoft.com/en-us/e30d36e8-d7c4-4936-916a-8fdbe4d9ffd5)."},{"pos":[2949,2979],"content":"Default marshaling for classes","linkify":"Default marshaling for classes","nodes":[{"content":"Default marshaling for classes","pos":[0,30]}]},{"content":"Classes can be marshaled only by COM interop and are always marshaled as interfaces.","pos":[2983,3067]},{"content":"In some cases the interface used to marshal the class is known as the class interface.","pos":[3068,3154]},{"content":"For information about overriding the class interface with an interface of your choice, see <bpt id=\"p1\">[</bpt>Introducing the Class Interface<ept id=\"p1\">](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.","pos":[3155,3350],"source":" For information about overriding the class interface with an interface of your choice, see [Introducing the Class Interface](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024)."},{"pos":[3360,3382],"content":"Passing Classes to COM","linkify":"Passing Classes to COM","nodes":[{"content":"Passing Classes to COM","pos":[0,22]}]},{"content":"When a managed class is passed to COM, the interop marshaler automatically wraps the class with a COM proxy and passes the class interface produced by the proxy to the COM method call.","pos":[3386,3570]},{"content":"The proxy then delegates all calls on the class interface back to the managed object.","pos":[3571,3656]},{"content":"The proxy also exposes other interfaces that are not explicitly implemented by the class.","pos":[3657,3746]},{"content":"The proxy automatically implements interfaces such as <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IDispatch<ept id=\"p2\">**</ept> on behalf of the class.","pos":[3747,3855],"source":" The proxy automatically implements interfaces such as **IUnknown** and **IDispatch** on behalf of the class."},{"pos":[3865,3893],"content":"Passing Classes to .NET Code","linkify":"Passing Classes to .NET Code","nodes":[{"content":"Passing Classes to .NET Code","pos":[0,28]}]},{"content":"Coclasses are not typically used as method arguments in COM.","pos":[3897,3957]},{"content":"Instead, a default interface is usually passed in place of the coclass.","pos":[3958,4029]},{"content":"When an interface is passed into managed code, the interop marshaler is responsible for wrapping the interface with the proper wrapper and passing the wrapper to the managed method.","pos":[4036,4217]},{"content":"Determining which wrapper to use can be difficult.","pos":[4218,4268]},{"content":"Every instance of a COM object has a single, unique wrapper, no matter how many interfaces the object implements.","pos":[4269,4382]},{"content":"For example, a single COM object that implements five distinct interfaces has only one wrapper.","pos":[4383,4478]},{"content":"The same wrapper exposes all five interfaces.","pos":[4479,4524]},{"content":"If two instances of the COM object are created, then two instances of the wrapper are created.","pos":[4525,4619]},{"content":"For the wrapper to maintain the same type throughout its lifetime, the interop marshaler must identify the correct wrapper the first time an interface exposed by the object is passed through the marshaler.","pos":[4626,4831]},{"content":"The marshaler identifies the object by looking at one of the interfaces the object implements.","pos":[4832,4926]},{"content":"For example, the marshaler determines that the class wrapper should be used to wrap the interface that was passed into managed code.","pos":[4933,5065]},{"content":"When the interface is first passed through the marshaler, the marshaler checks whether the interface is coming from a known object.","pos":[5066,5197]},{"content":"This check occurs in two situations:","pos":[5198,5234]},{"content":"An interface is being implemented by another managed object that was passed to COM elsewhere.","pos":[5244,5337]},{"content":"The marshaler can readily identify interfaces exposed by managed objects and is able to match the interface with the managed object that provides the implementation.","pos":[5338,5503]},{"content":"The managed object is then passed to the method and no wrapper is needed.","pos":[5504,5577]},{"content":"An object that has already been wrapped is implementing the interface.","pos":[5587,5657]},{"content":"To determine whether this is the case, the marshaler queries the object for its <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> interface and compares the returned interface to the interfaces of other objects that are already wrapped.","pos":[5658,5857],"source":" To determine whether this is the case, the marshaler queries the object for its **IUnknown** interface and compares the returned interface to the interfaces of other objects that are already wrapped."},{"content":"If the interface is the same as that of another wrapper, the objects have the same identity and the existing wrapper is passed to the method.","pos":[5858,5999]},{"content":"If an interface is not from a known object, the marshaler does the following:","pos":[6006,6083]},{"content":"The marshaler queries the object for the <bpt id=\"p1\">**</bpt>IProvideClassInfo2<ept id=\"p1\">**</ept> interface.","pos":[6093,6167],"source":"The marshaler queries the object for the **IProvideClassInfo2** interface."},{"content":"If provided, the marshaler uses the CLSID returned from <bpt id=\"p1\">**</bpt>IProvideClassInfo2.GetGUID<ept id=\"p1\">**</ept> to identify the coclass providing the interface.","pos":[6168,6303],"source":" If provided, the marshaler uses the CLSID returned from **IProvideClassInfo2.GetGUID** to identify the coclass providing the interface."},{"content":"With the CLSID, the marshaler can locate the wrapper from the registry if the assembly has previously been registered.","pos":[6304,6422]},{"content":"The marshaler queries the interface for the <bpt id=\"p1\">**</bpt>IProvideClassInfo<ept id=\"p1\">**</ept> interface.","pos":[6432,6508],"source":"The marshaler queries the interface for the **IProvideClassInfo** interface."},{"content":"If provided, the marshaler uses the <bpt id=\"p1\">**</bpt>ITypeInfo<ept id=\"p1\">**</ept> returned from <bpt id=\"p2\">**</bpt>IProvideClassInfo.GetClassinfo<ept id=\"p2\">**</ept> to determine the CLSID of the class exposing the interface.","pos":[6509,6667],"source":" If provided, the marshaler uses the **ITypeInfo** returned from **IProvideClassInfo.GetClassinfo** to determine the CLSID of the class exposing the interface."},{"content":"The marshaler can use the CLSID to locate the metadata for the wrapper.","pos":[6668,6739]},{"pos":[6749,6881],"content":"If the marshaler still cannot identify the class, it wraps the interface with a generic wrapper class called <bpt id=\"p1\">**</bpt>System.__ComObject<ept id=\"p1\">**</ept>.","source":"If the marshaler still cannot identify the class, it wraps the interface with a generic wrapper class called **System.__ComObject**."},{"pos":[6890,6922],"content":"Default marshaling for delegates","linkify":"Default marshaling for delegates","nodes":[{"content":"Default marshaling for delegates","pos":[0,32]}]},{"content":"A managed delegate is marshaled as a COM interface or as a function pointer, based on the calling mechanism:","pos":[6926,7034]},{"content":"For platform invoke, a delegate is marshaled as an unmanaged function pointer by default.","pos":[7044,7133]},{"content":"For COM interop, a delegate is marshaled as a COM interface of type <bpt id=\"p1\">**</bpt>_Delegate<ept id=\"p1\">**</ept> by default.","pos":[7143,7236],"source":"For COM interop, a delegate is marshaled as a COM interface of type **_Delegate** by default."},{"content":"The <bpt id=\"p1\">**</bpt>_Delegate<ept id=\"p1\">**</ept> interface is defined in the Mscorlib.tlb type library and contains the <ph id=\"ph1\">&lt;xref:System.Delegate.DynamicInvoke%2A?displayProperty=fullName&gt;</ph> method, which enables you to call the method that the delegate references.","pos":[7237,7465],"source":" The **_Delegate** interface is defined in the Mscorlib.tlb type library and contains the <xref:System.Delegate.DynamicInvoke%2A?displayProperty=fullName> method, which enables you to call the method that the delegate references."},{"content":"The following table shows the marshaling options for the managed delegate data type.","pos":[7472,7556]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute&gt;</ph> attribute provides several <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.UnmanagedType&gt;</ph> enumeration values to marshal delegates.","pos":[7557,7737],"source":" The <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute provides several <xref:System.Runtime.InteropServices.UnmanagedType> enumeration values to marshal delegates."},{"content":"Enumeration type","pos":[7744,7760]},{"content":"Description of unmanaged format","pos":[7761,7792]},{"pos":[7862,7891],"content":"<bpt id=\"p1\">**</bpt>UnmanagedType.FunctionPtr<ept id=\"p1\">**</ept>","source":"**UnmanagedType.FunctionPtr**"},{"content":"An unmanaged function pointer.","pos":[7892,7922]},{"pos":[7927,7954],"content":"<bpt id=\"p1\">**</bpt>UnmanagedType.Interface<ept id=\"p1\">**</ept>","source":"**UnmanagedType.Interface**"},{"pos":[7955,8018],"content":"An interface of type <bpt id=\"p1\">**</bpt>_Delegate<ept id=\"p1\">**</ept>, as defined in Mscorlib.tlb.","source":"An interface of type **_Delegate**, as defined in Mscorlib.tlb."},{"content":"Consider the following example code in which the methods of <ph id=\"ph1\">`DelegateTestInterface`</ph> are exported to a COM type library.","pos":[8026,8145],"source":"Consider the following example code in which the methods of `DelegateTestInterface` are exported to a COM type library."},{"content":"Notice that only delegates marked with the <bpt id=\"p1\">**</bpt>ref<ept id=\"p1\">**</ept> (or <bpt id=\"p2\">**</bpt>ByRef<ept id=\"p2\">**</ept>) keyword are passed as In/Out parameters.","pos":[8146,8252],"source":" Notice that only delegates marked with the **ref** (or **ByRef**) keyword are passed as In/Out parameters."},{"pos":[8664,8691],"content":"Type library representation","linkify":"Type library representation","nodes":[{"content":"Type library representation","pos":[0,27]}]},{"content":"A function pointer can be dereferenced, just as any other unmanaged function pointer can be dereferenced.","pos":[8990,9095]},{"pos":[9103,9297],"content":"[!NOTE]\n A reference to the function pointer to a managed delegate held by unmanaged code does not prevent the common language runtime from performing garbage collection on the managed object.","leadings":["","> "],"nodes":[{"content":"A reference to the function pointer to a managed delegate held by unmanaged code does not prevent the common language runtime from performing garbage collection on the managed object.","pos":[9,192]}]},{"content":"For example, the following code is incorrect because the reference to the <ph id=\"ph1\">`cb`</ph> object, passed to the <ph id=\"ph2\">`SetChangeHandler`</ph> method, does not keep <ph id=\"ph3\">`cb`</ph> alive beyond the life of the <ph id=\"ph4\">`Test`</ph> method.","pos":[9304,9494],"source":"For example, the following code is incorrect because the reference to the `cb` object, passed to the `SetChangeHandler` method, does not keep `cb` alive beyond the life of the `Test` method."},{"content":"Once the <ph id=\"ph1\">`cb`</ph> object is garbage collected, the function pointer passed to <ph id=\"ph2\">`SetChangeHandler`</ph> is no longer valid.","pos":[9495,9607],"source":" Once the `cb` object is garbage collected, the function pointer passed to `SetChangeHandler` is no longer valid."},{"content":"To compensate for unexpected garbage collection, the caller must ensure that the <ph id=\"ph1\">`cb`</ph> object is kept alive as long as the unmanaged function pointer is in use.","pos":[10352,10511],"source":"To compensate for unexpected garbage collection, the caller must ensure that the `cb` object is kept alive as long as the unmanaged function pointer is in use."},{"content":"Optionally, you can have the unmanaged code notify the managed code when the function pointer is no longer needed, as the following example shows.","pos":[10512,10658]},{"pos":[11220,11254],"content":"Default marshaling for value types","linkify":"Default marshaling for value types","nodes":[{"content":"Default marshaling for value types","pos":[0,34]}]},{"content":"Most value types, such as integers and floating-point numbers, are <bpt id=\"p1\">[</bpt>blittable<ept id=\"p1\">](../../../docs/framework/interop/blittable-and-non-blittable-types.md)</ept> and do not require marshaling.","pos":[11258,11437],"source":"Most value types, such as integers and floating-point numbers, are [blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) and do not require marshaling."},{"content":"Other <bpt id=\"p1\">[</bpt>non-blittable<ept id=\"p1\">](../../../docs/framework/interop/blittable-and-non-blittable-types.md)</ept> types have dissimilar representations in managed and unmanaged memory and do require marshaling.","pos":[11438,11626],"source":" Other [non-blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) types have dissimilar representations in managed and unmanaged memory and do require marshaling."},{"content":"Still other types require explicit formatting across the interoperation boundary.","pos":[11627,11708]},{"content":"This topic provides the follow information on formatted value types:","pos":[11715,11783]},{"pos":[11793,11875],"content":"<bpt id=\"p1\">[</bpt>Value Types Used in Platform Invoke<ept id=\"p1\">](#cpcondefaultmarshalingforvaluetypesanchor2)</ept>","source":"[Value Types Used in Platform Invoke](#cpcondefaultmarshalingforvaluetypesanchor2)"},{"pos":[11885,11963],"content":"<bpt id=\"p1\">[</bpt>Value Types Used in COM Interop<ept id=\"p1\">](#cpcondefaultmarshalingforvaluetypesanchor3)</ept>","source":"[Value Types Used in COM Interop](#cpcondefaultmarshalingforvaluetypesanchor3)"},{"pos":[11970,12139],"content":"In addition to describing formatted types, this topic identifies <bpt id=\"p1\">[</bpt>System Value Types<ept id=\"p1\">](#cpcondefaultmarshalingforvaluetypesanchor1)</ept> that have unusual marshaling behavior.","source":"In addition to describing formatted types, this topic identifies [System Value Types](#cpcondefaultmarshalingforvaluetypesanchor1) that have unusual marshaling behavior."},{"content":"A formatted type is a complex type that contains information that explicitly controls the layout of its members in memory.","pos":[12146,12268]},{"content":"The member layout information is provided using the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute.","pos":[12269,12391],"source":" The member layout information is provided using the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute."},{"content":"The layout can be one of the following <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration values:","pos":[12392,12499],"source":" The layout can be one of the following <xref:System.Runtime.InteropServices.LayoutKind> enumeration values:"},{"pos":[12509,12533],"content":"<bpt id=\"p1\">**</bpt>LayoutKind.Automatic<ept id=\"p1\">**</ept>","source":"**LayoutKind.Automatic**"},{"content":"Indicates that the common language runtime is free to reorder the members of the type for efficiency.","pos":[12544,12645]},{"content":"However, when a value type is passed to unmanaged code, the layout of the members is predictable.","pos":[12646,12743]},{"content":"An attempt to marshal such a structure automatically causes an exception.","pos":[12744,12817]},{"pos":[12827,12852],"content":"<bpt id=\"p1\">**</bpt>LayoutKind.Sequential<ept id=\"p1\">**</ept>","source":"**LayoutKind.Sequential**"},{"content":"Indicates that the members of the type are to be laid out in unmanaged memory in the same order in which they appear in the managed type definition.","pos":[12863,13011]},{"pos":[13021,13044],"content":"<bpt id=\"p1\">**</bpt>LayoutKind.Explicit<ept id=\"p1\">**</ept>","source":"**LayoutKind.Explicit**"},{"content":"Indicates that the members are laid out according to the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> supplied with each field.","pos":[13055,13196],"source":"Indicates that the members are laid out according to the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> supplied with each field."},{"pos":[13267,13302],"content":"Value Types Used in Platform Invoke","linkify":"Value Types Used in Platform Invoke","nodes":[{"content":"Value Types Used in Platform Invoke","pos":[0,35]}]},{"pos":[13306,13430],"content":"In the following example the <ph id=\"ph1\">`Point`</ph> and <ph id=\"ph2\">`Rect`</ph> types provide member layout information using the <bpt id=\"p1\">**</bpt>StructLayoutAttribute<ept id=\"p1\">**</ept>.","source":"In the following example the `Point` and `Rect` types provide member layout information using the **StructLayoutAttribute**."},{"content":"When marshaled to unmanaged code, these formatted types are marshaled as C-style structures.","pos":[14283,14375]},{"content":"This provides an easy way of calling an unmanaged API that has structure arguments.","pos":[14376,14459]},{"content":"For example, the <ph id=\"ph1\">`POINT`</ph> and <ph id=\"ph2\">`RECT`</ph> structures can be passed to the Microsoft Win32 API <bpt id=\"p1\">**</bpt>PtInRect<ept id=\"p1\">**</ept> function as follows:","pos":[14460,14581],"source":" For example, the `POINT` and `RECT` structures can be passed to the Microsoft Win32 API **PtInRect** function as follows:"},{"content":"You can pass structures using the following platform invoke definition:","pos":[14648,14719]},{"content":"The <ph id=\"ph1\">`Rect`</ph> value type must be passed by reference because the unmanaged API is expecting a pointer to a <ph id=\"ph2\">`RECT`</ph> to be passed to the function.","pos":[15018,15158],"source":"The `Rect` value type must be passed by reference because the unmanaged API is expecting a pointer to a `RECT` to be passed to the function."},{"content":"The <ph id=\"ph1\">`Point`</ph> value type is passed by value because the unmanaged API expects the <ph id=\"ph2\">`POINT`</ph> to be passed on the stack.","pos":[15159,15273],"source":" The `Point` value type is passed by value because the unmanaged API expects the `POINT` to be passed on the stack."},{"content":"This subtle difference is very important.","pos":[15274,15315]},{"content":"References are passed to unmanaged code as pointers.","pos":[15316,15368]},{"content":"Values are passed to unmanaged code on the stack.","pos":[15369,15418]},{"pos":[15426,15626],"content":"[!NOTE]\n When a formatted type is marshaled as a structure, only the fields within the type are accessible. If the type has methods, properties, or events, they are inaccessible from unmanaged code.","leadings":["","> "],"nodes":[{"content":"When a formatted type is marshaled as a structure, only the fields within the type are accessible. If the type has methods, properties, or events, they are inaccessible from unmanaged code.","pos":[9,198],"nodes":[{"content":"When a formatted type is marshaled as a structure, only the fields within the type are accessible.","pos":[0,98]},{"content":"If the type has methods, properties, or events, they are inaccessible from unmanaged code.","pos":[99,189]}]}]},{"content":"Classes can also be marshaled to unmanaged code as C-style structures, provided they have fixed member layout.","pos":[15633,15743]},{"content":"The member layout information for a class is also provided with the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute.","pos":[15744,15882],"source":" The member layout information for a class is also provided with the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute."},{"content":"The main difference between value types with fixed layout and classes with fixed layout is the way in which they are marshaled to unmanaged code.","pos":[15883,16028]},{"content":"Value types are passed by value (on the stack) and consequently any changes made to the members of the type by the callee are not seen by the caller.","pos":[16029,16178]},{"content":"Reference types are passed by reference (a reference to the type is passed on the stack); consequently, all changes made to blittable-type members of a type by the callee are seen by the caller.","pos":[16179,16373]},{"pos":[16381,16729],"content":"[!NOTE]\n If a reference type has members of non-blittable types, conversion is required twice: the first time when an argument is passed to the unmanaged side and the second time on return from the call. Due to this added overhead, In/Out parameters must be explicitly applied to an argument if the caller wants to see changes made by the callee.","leadings":["","> "],"nodes":[{"content":"If a reference type has members of non-blittable types, conversion is required twice: the first time when an argument is passed to the unmanaged side and the second time on return from the call. Due to this added overhead, In/Out parameters must be explicitly applied to an argument if the caller wants to see changes made by the callee.","pos":[9,346],"nodes":[{"content":"If a reference type has members of non-blittable types, conversion is required twice: the first time when an argument is passed to the unmanaged side and the second time on return from the call.","pos":[0,194]},{"content":"Due to this added overhead, In/Out parameters must be explicitly applied to an argument if the caller wants to see changes made by the callee.","pos":[195,337]}]}]},{"pos":[16736,16876],"content":"In the following example, the <ph id=\"ph1\">`SystemTime`</ph> class has sequential member layout and can be passed to the Win32 API <bpt id=\"p1\">**</bpt>GetSystemTime<ept id=\"p1\">**</ept> function.","source":"In the following example, the `SystemTime` class has sequential member layout and can be passed to the Win32 API **GetSystemTime** function."},{"pos":[17604,17657],"content":"The <bpt id=\"p1\">**</bpt>GetSystemTime<ept id=\"p1\">**</ept> function is defined as follows:","source":"The **GetSystemTime** function is defined as follows:"},{"pos":[17725,17803],"content":"The equivalent platform invoke definition for <bpt id=\"p1\">**</bpt>GetSystemTime<ept id=\"p1\">**</ept> is as follows:","source":"The equivalent platform invoke definition for **GetSystemTime** is as follows:"},{"content":"Notice that the <ph id=\"ph1\">`SystemTime`</ph> argument is not typed as a reference argument because <ph id=\"ph2\">`SystemTime`</ph> is a class, not a value type.","pos":[18115,18240],"source":"Notice that the `SystemTime` argument is not typed as a reference argument because `SystemTime` is a class, not a value type."},{"content":"Unlike value types, classes are always passed by reference.","pos":[18241,18300]},{"content":"The following code example shows a different <ph id=\"ph1\">`Point`</ph> class that has a method called <ph id=\"ph2\">`SetXY`</ph>.","pos":[18307,18399],"source":"The following code example shows a different `Point` class that has a method called `SetXY`."},{"content":"Because the type has sequential layout, it can be passed to unmanaged code and marshaled as a structure.","pos":[18400,18504]},{"content":"However, the <ph id=\"ph1\">`SetXY`</ph> member is not callable from unmanaged code, even though the object is passed by reference.","pos":[18505,18616],"source":" However, the `SetXY` member is not callable from unmanaged code, even though the object is passed by reference."},{"pos":[19093,19124],"content":"Value Types Used in COM Interop","linkify":"Value Types Used in COM Interop","nodes":[{"content":"Value Types Used in COM Interop","pos":[0,31]}]},{"content":"Formatted types can also be passed to COM interop method calls.","pos":[19128,19191]},{"content":"In fact, when exported to a type library, value types are automatically converted to structures.","pos":[19192,19288]},{"content":"As the following example shows, the <ph id=\"ph1\">`Point`</ph> value type becomes a type definition (typedef) with the name <ph id=\"ph2\">`Point`</ph>.","pos":[19289,19402],"source":" As the following example shows, the `Point` value type becomes a type definition (typedef) with the name `Point`."},{"content":"All references to the <ph id=\"ph1\">`Point`</ph> value type elsewhere in the type library are replaced with the <ph id=\"ph2\">`Point`</ph> typedef.","pos":[19403,19512],"source":" All references to the `Point` value type elsewhere in the type library are replaced with the `Point` typedef."},{"pos":[19519,19550],"content":"<bpt id=\"p1\">**</bpt>Type library representation<ept id=\"p1\">**</ept>","source":"**Type library representation**"},{"content":"The same rules used to marshal values and references to platform invoke calls are used when marshaling through COM interfaces.","pos":[19798,19924]},{"content":"For example, when an instance of the <ph id=\"ph1\">`Point`</ph> value type is passed from the .NET Framework to COM, the <ph id=\"ph2\">`Point`</ph> is passed by value.","pos":[19925,20054],"source":" For example, when an instance of the `Point` value type is passed from the .NET Framework to COM, the `Point` is passed by value."},{"content":"If the <ph id=\"ph1\">`Point`</ph> value type is passed by reference, a pointer to a <ph id=\"ph2\">`Point`</ph> is passed on the stack.","pos":[20055,20151],"source":" If the `Point` value type is passed by reference, a pointer to a `Point` is passed on the stack."},{"content":"The interop marshaler does not support higher levels of indirection (<bpt id=\"p1\">**</bpt>Point <ph id=\"ph1\">\\*</ph><ph id=\"ph2\">\\*</ph><ept id=\"p1\">**</ept>) in either direction.","pos":[20152,20257],"source":" The interop marshaler does not support higher levels of indirection (**Point \\*\\***) in either direction."},{"pos":[20265,20483],"content":"[!NOTE]\n Structures having the <xref:System.Runtime.InteropServices.LayoutKind> enumeration value set to **Explicit** cannot be used in COM interop because the exported type library cannot express an explicit layout.","leadings":["","> "],"nodes":[{"content":"Structures having the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration value set to <bpt id=\"p1\">**</bpt>Explicit<ept id=\"p1\">**</ept> cannot be used in COM interop because the exported type library cannot express an explicit layout.","pos":[9,216],"source":"Structures having the <xref:System.Runtime.InteropServices.LayoutKind> enumeration value set to **Explicit** cannot be used in COM interop because the exported type library cannot express an explicit layout."}]},{"pos":[20554,20572],"content":"System Value Types","linkify":"System Value Types","nodes":[{"content":"System Value Types","pos":[0,18]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System&gt;</ph> namespace has several value types that represent the boxed form of the runtime primitive types.","pos":[20576,20689],"source":"The <xref:System> namespace has several value types that represent the boxed form of the runtime primitive types."},{"content":"For example, the value type <ph id=\"ph1\">&lt;xref:System.Int32?displayProperty=fullName&gt;</ph> structure represents the boxed form of <bpt id=\"p1\">**</bpt>ELEMENT_TYPE_I4<ept id=\"p1\">**</ept>.","pos":[20690,20822],"source":" For example, the value type <xref:System.Int32?displayProperty=fullName> structure represents the boxed form of **ELEMENT_TYPE_I4**."},{"content":"Instead of marshaling these types as structures, as other formatted types are, you marshal them in the same way as the primitive types they box.","pos":[20823,20967]},{"content":"<bpt id=\"p1\">**</bpt>System.Int32<ept id=\"p1\">**</ept> is therefore marshaled as <bpt id=\"p2\">**</bpt>ELEMENT_TYPE_I4<ept id=\"p2\">**</ept> instead of as a structure containing a single member of type <bpt id=\"p3\">**</bpt>long<ept id=\"p3\">**</ept>.","pos":[20968,21101],"source":"**System.Int32** is therefore marshaled as **ELEMENT_TYPE_I4** instead of as a structure containing a single member of type **long**."},{"content":"The following table contains a list of the value types in the <bpt id=\"p1\">**</bpt>System<ept id=\"p1\">**</ept> namespace that are boxed representations of primitive types.","pos":[21102,21235],"source":" The following table contains a list of the value types in the **System** namespace that are boxed representations of primitive types."},{"content":"System value type","pos":[21242,21259]},{"content":"Element type","pos":[21260,21272]},{"pos":[21371,21395],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_BOOLEAN<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_BOOLEAN**"},{"pos":[21445,21464],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_I1<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_I1**"},{"pos":[21513,21533],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_UI1<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_UI1**"},{"pos":[21582,21603],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_CHAR<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_CHAR**"},{"pos":[21653,21672],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_I2<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_I2**"},{"pos":[21723,21742],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_U2<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_U2**"},{"pos":[21792,21811],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_I4<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_I4**"},{"pos":[21862,21881],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_U4<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_U4**"},{"pos":[21931,21950],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_I8<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_I8**"},{"pos":[22001,22020],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_U8<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_U8**"},{"pos":[22071,22090],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_R4<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_R4**"},{"pos":[22141,22160],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_R8<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_R8**"},{"pos":[22211,22234],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_STRING<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_STRING**"},{"pos":[22285,22303],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_I<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_I**"},{"pos":[22355,22373],"content":"<bpt id=\"p1\">**</bpt>ELEMENT_TYPE_U<ept id=\"p1\">**</ept>","source":"**ELEMENT_TYPE_U**"},{"content":"Some other value types in the <bpt id=\"p1\">**</bpt>System<ept id=\"p1\">**</ept> namespace are handled differently.","pos":[22381,22456],"source":"Some other value types in the **System** namespace are handled differently."},{"content":"Because the unmanaged code already has well-established formats for these types, the marshaler has special rules for marshaling them.","pos":[22457,22590]},{"content":"The following table lists the special value types in the <bpt id=\"p1\">**</bpt>System<ept id=\"p1\">**</ept> namespace, as well as the unmanaged type they are marshaled to.","pos":[22591,22722],"source":" The following table lists the special value types in the **System** namespace, as well as the unmanaged type they are marshaled to."},{"content":"System value type","pos":[22729,22746]},{"content":"IDL type","pos":[22747,22755]},{"pos":[22851,22859],"content":"<bpt id=\"p1\">**</bpt>DATE<ept id=\"p1\">**</ept>","source":"**DATE**"},{"pos":[22911,22922],"content":"<bpt id=\"p1\">**</bpt>DECIMAL<ept id=\"p1\">**</ept>","source":"**DECIMAL**"},{"pos":[22971,22979],"content":"<bpt id=\"p1\">**</bpt>GUID<ept id=\"p1\">**</ept>","source":"**GUID**"},{"pos":[23037,23050],"content":"<bpt id=\"p1\">**</bpt>OLE_COLOR<ept id=\"p1\">**</ept>","source":"**OLE_COLOR**"},{"pos":[23058,23200],"content":"The following code shows the definition of the unmanaged types <bpt id=\"p1\">**</bpt>DATE<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>GUID<ept id=\"p2\">**</ept>, <bpt id=\"p3\">**</bpt>DECIMAL<ept id=\"p3\">**</ept>, and <bpt id=\"p4\">**</bpt>OLE_COLOR<ept id=\"p4\">**</ept> in the Stdole2 type library.","source":"The following code shows the definition of the unmanaged types **DATE**, **GUID**, **DECIMAL**, and **OLE_COLOR** in the Stdole2 type library."},{"pos":[23211,23238],"content":"Type library representation","linkify":"Type library representation","nodes":[{"content":"Type library representation","pos":[0,27]}]},{"pos":[23589,23683],"content":"The following code shows the corresponding definitions in the managed <ph id=\"ph1\">`IValueTypes`</ph> interface.","source":"The following code shows the corresponding definitions in the managed `IValueTypes` interface."},{"pos":[24087,24114],"content":"Type library representation","linkify":"Type library representation","nodes":[{"content":"Type library representation","pos":[0,27]}]},{"pos":[24315,24323],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Blittable and Non-Blittable Types<ept id=\"p1\">](../../../docs/framework/interop/blittable-and-non-blittable-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[24327,24433],"source":"[Blittable and Non-Blittable Types](../../../docs/framework/interop/blittable-and-non-blittable-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Copying and Pinning<ept id=\"p1\">](../../../docs/framework/interop/copying-and-pinning.md)</ept><ph id=\"ph1\"> </ph>","pos":[24437,24515],"source":"[Copying and Pinning](../../../docs/framework/interop/copying-and-pinning.md) "},{"content":"<bpt id=\"p1\">[</bpt>Default Marshaling for Arrays<ept id=\"p1\">](../../../docs/framework/interop/default-marshaling-for-arrays.md)</ept><ph id=\"ph1\"> </ph>","pos":[24519,24617],"source":"[Default Marshaling for Arrays](../../../docs/framework/interop/default-marshaling-for-arrays.md) "},{"content":"<bpt id=\"p1\">[</bpt>Default Marshaling for Objects<ept id=\"p1\">](../../../docs/framework/interop/default-marshaling-for-objects.md)</ept><ph id=\"ph1\"> </ph>","pos":[24621,24721],"source":"[Default Marshaling for Objects](../../../docs/framework/interop/default-marshaling-for-objects.md) "},{"content":"<bpt id=\"p1\">[</bpt>Default Marshaling for Strings<ept id=\"p1\">](../../../docs/framework/interop/default-marshaling-for-strings.md)</ept>","pos":[24725,24824],"source":"[Default Marshaling for Strings](../../../docs/framework/interop/default-marshaling-for-strings.md)"}]}