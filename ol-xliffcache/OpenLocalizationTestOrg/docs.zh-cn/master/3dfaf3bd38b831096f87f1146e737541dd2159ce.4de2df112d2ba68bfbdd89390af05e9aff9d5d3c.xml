{"content":"---\ntitle: \"Implementing a Dispose method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"04/07/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Dispose method\"\n  - \"garbage collection, Dispose method\"\nms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9\ncaps.latest.revision: 44\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n\n# Implementing a Dispose method\n\nYou implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application. The .NET garbage collector does not allocate or release unmanaged memory.  \n  \nThe pattern for disposing an object, referred to as a [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md), imposes order on the lifetime of an object. The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory. This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.  \n  \nThe dispose pattern has two variations:  \n  \n* You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>). In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method. This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  \n  \n  > [!NOTE]\n  > The <xref:Microsoft.Win32.SafeHandles?displayProperty=fullName> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section. If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.  \n  \n* You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method. You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is not called by a consumer of your type. If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class does this on your behalf.  \n  \nTo help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.  \n  \nThe code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=fullName> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing. It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method.  \n  \n<a name=\"Dispose2\"></a>\n## Dispose() and Dispose(Boolean)  \n\nThe <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>. However, the dispose pattern requires two `Dispose` methods to be implemented:  \n  \n* A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation that has no parameters.  \n  \n* A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:  \n  \n  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]\n  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  \n  \n### The Dispose() overload\n\nBecause the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run. Because of this, it has a standard implementation:  \n  \n[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]\n[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  \n  \nThe `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=fullName> override. Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer. If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> has no effect. Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.  \n  \n### The Dispose(Boolean) overload\n\nIn the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).  \n  \nThe body of the method consists of two blocks of code:  \n  \n* A block that frees unmanaged resources. This block executes regardless of the value of the `disposing` parameter.  \n  \n* A conditional block that frees managed resources. This block executes if the value of `disposing` is `true`. The managed resources that it frees can include:  \n  \n  **Managed objects that implement <xref:System.IDisposable>.** The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation. If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=fullName> implementation here.  \n  \n  **Managed objects that consume large amounts of memory or consume scarce resources.** Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.  \n  \nIf the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes. Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.  \n  \n## Implementing the dispose pattern for a base class\n\nIf you implement the dispose pattern for a base class, you must provide the following:  \n  \n> [!IMPORTANT]\n> You should implement this pattern for all base classes that implement <xref:System.IDisposable> and are not `sealed` (`NotInheritable` in Visual Basic).  \n  \n* A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.  \n  \n* A `Dispose(Boolean)` method that performs the actual work of releasing resources.  \n  \n* Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method. The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.  \n  \nHere's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.  \n  \n[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]\n[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  \n  \n> [!NOTE]\n> The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead. Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.  \n  \nHere's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=fullName>.  \n  \n[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]\n[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  \n  \n> [!NOTE]\n> In C#, you override <xref:System.Object.Finalize%2A?displayProperty=fullName> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).  \n  \n## Implementing the dispose pattern for a derived class\n\nA class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> is inherited by its derived classes. Instead, to implement the dispose pattern for a derived class, you provide the following:  \n  \n* A `protected``Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class. This method should also call the `Dispose(Boolean)` method of the base class and pass it a value of `true` for the *disposing* argument.  \n  \n* Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method. The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one. If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.  \n  \nHere's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:  \n  \n[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]\n[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  \n  \n> [!NOTE]\n> The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead. Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.  \n  \nHere's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=fullName>:  \n  \n[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]\n[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  \n  \n> [!NOTE]\n> In C#, you override <xref:System.Object.Finalize%2A?displayProperty=fullName> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).  \n  \n<a name=\"SafeHandles\"></a>   \n## Using safe handles\n\nWriting code for an object's finalizer is a complex task that can cause problems if not done correctly. Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> objects instead of implementing a finalizer.  \n  \nClasses derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class simplify object lifetime issues by assigning and releasing handles without interruption. They contain a critical finalizer that is guaranteed to run while an application domain is unloading. For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:  \n  \n* The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.  \n  \n* The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.  \n  \n* The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.  \n  \n* The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.  \n  \n* The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.  \n  \n<a name=\"base\"></a>   \n## Using a safe handle to implement the dispose pattern for a base class\n\nThe following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources. It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file. The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.  \n  \n[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]\n[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  \n  \n<a name=\"derived\"></a>   \n## Using a safe handle to implement the dispose pattern for a derived class\n\nThe following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example. The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.  \n  \n[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]\n[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  \n  \n## See also\n\n<xref:System.GC.SuppressFinalize%2A>   \n<xref:System.IDisposable>   \n<xref:System.IDisposable.Dispose%2A?displayProperty=fullName>   \n<xref:Microsoft.Win32.SafeHandles>   \n<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>   \n<xref:System.Object.Finalize%2A?displayProperty=fullName>   \n[How to: Define and Consume Classes and Structs (C++/CLI)](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)   \n[Dispose Pattern](../../../docs/standard/design-guidelines/dispose-pattern.md)\n","nodes":[{"pos":[4,427],"embed":true,"restype":"x-metadata","content":"title: \"Implementing a Dispose method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"04/07/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Dispose method\"\n  - \"garbage collection, Dispose method\"\nms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9\ncaps.latest.revision: 44\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","nodes":[{"content":"Implementing a Dispose method | Microsoft Docs","nodes":[{"pos":[0,46],"content":"Implementing a Dispose method | Microsoft Docs","nodes":[{"content":"Implementing a Dispose method | Microsoft Docs","pos":[0,46]}]}],"path":["title"]}],"yml":true},{"pos":[435,464],"content":"Implementing a Dispose method","linkify":"Implementing a Dispose method","nodes":[{"content":"Implementing a Dispose method","pos":[0,29]}]},{"content":"You implement a <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method to release unmanaged resources used by your application.","pos":[466,582],"source":"You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application."},{"content":"The .NET garbage collector does not allocate or release unmanaged memory.","pos":[583,656]},{"content":"The pattern for disposing an object, referred to as a <bpt id=\"p1\">[</bpt>dispose pattern<ept id=\"p1\">](../../../docs/standard/design-guidelines/dispose-pattern.md)</ept>, imposes order on the lifetime of an object.","pos":[662,839],"source":"The pattern for disposing an object, referred to as a [dispose pattern](../../../docs/standard/design-guidelines/dispose-pattern.md), imposes order on the lifetime of an object."},{"content":"The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.","pos":[840,1023]},{"content":"This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.","pos":[1024,1164]},{"content":"The dispose pattern has two variations:","pos":[1170,1209]},{"content":"You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph>).","pos":[1217,1393],"source":"You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>)."},{"content":"In this case, you implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface and an additional <ph id=\"ph2\">`Dispose(Boolean)`</ph> method.","pos":[1394,1506],"source":" In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method."},{"content":"This is the recommended variation and doesn't require overriding the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[1507,1641],"source":" This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."},{"pos":[1651,2064],"content":"[!NOTE]\nThe <xref:Microsoft.Win32.SafeHandles?displayProperty=fullName> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section. If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.","leadings":["","  > "],"nodes":[{"content":"The <xref:Microsoft.Win32.SafeHandles?displayProperty=fullName> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section. If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.","pos":[8,409],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles?displayProperty=fullName&gt;</ph> namespace provides a set of classes derived from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>, which are listed in the <bpt id=\"p1\">[</bpt>Using safe handles<ept id=\"p1\">](#SafeHandles)</ept> section.","pos":[0,230],"source":"The <xref:Microsoft.Win32.SafeHandles?displayProperty=fullName> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section."},{"content":"If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>.","pos":[231,401],"source":" If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>."}]}]},{"content":"You implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface and an additional <ph id=\"ph2\">`Dispose(Boolean)`</ph> method, and you also override the <ph id=\"ph3\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[2072,2262],"source":"You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."},{"content":"You must override <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> to ensure that unmanaged resources are disposed of if your <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation is not called by a consumer of your type.","pos":[2263,2491],"source":" You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is not called by a consumer of your type."},{"content":"If you use the recommended technique discussed in the previous bullet, the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> class does this on your behalf.","pos":[2492,2672],"source":" If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class does this on your behalf."},{"content":"To help ensure that resources are always cleaned up appropriately, a <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method should be callable multiple times without throwing an exception.","pos":[2678,2855],"source":"To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception."},{"content":"The code example provided for the <ph id=\"ph1\">&lt;xref:System.GC.KeepAlive%2A?displayProperty=fullName&gt;</ph> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.","pos":[2861,3084],"source":"The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=fullName> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing."},{"content":"It is a good idea to call the <ph id=\"ph1\">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method at the end of a lengthy <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[3085,3220],"source":" It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method."},{"pos":[3253,3283],"content":"Dispose() and Dispose(Boolean)","linkify":"Dispose() and Dispose(Boolean)","nodes":[{"content":"Dispose() and Dispose(Boolean)","pos":[0,30]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface requires the implementation of a single parameterless method, <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>.","pos":[3287,3426],"source":"The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>."},{"content":"However, the dispose pattern requires two <ph id=\"ph1\">`Dispose`</ph> methods to be implemented:","pos":[3427,3505],"source":" However, the dispose pattern requires two `Dispose` methods to be implemented:"},{"pos":[3513,3669],"content":"A public non-virtual (<ph id=\"ph1\">`NonInheritable`</ph> in Visual Basic) <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation that has no parameters.","source":"A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation that has no parameters."},{"pos":[3677,3765],"content":"A protected virtual (<ph id=\"ph1\">`Overridable`</ph> in Visual Basic) <ph id=\"ph2\">`Dispose`</ph> method whose signature is:","source":"A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:"},{"pos":[3773,4033],"content":"[!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]\n[!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]","leadings":["","  "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#8<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)</ept><ept id=\"p1\">]</ept>","pos":[0,128],"source":"[!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#8<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)</ept><ept id=\"p1\">]</ept>","pos":[129,258],"source":"[!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]"}]},{"pos":[4043,4065],"content":"The Dispose() overload","linkify":"The Dispose() overload","nodes":[{"content":"The Dispose() overload","pos":[0,22]}]},{"content":"Because the public, non-virtual (<ph id=\"ph1\">`NonInheritable`</ph> in Visual Basic), parameterless <ph id=\"ph2\">`Dispose`</ph> method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.","pos":[4067,4321],"source":"Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run."},{"content":"Because of this, it has a standard implementation:","pos":[4322,4372]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#7<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)</ept><ept id=\"p1\">]</ept>","pos":[4378,4506],"source":"[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#7<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)</ept><ept id=\"p1\">]</ept>","pos":[4507,4636],"source":"[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]"},{"content":"The <ph id=\"ph1\">`Dispose`</ph> method performs all object cleanup, so the garbage collector no longer needs to call the objects' <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> override.","pos":[4642,4821],"source":"The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=fullName> override."},{"content":"Therefore, the call to the <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method prevents the garbage collector from running the finalizer.","pos":[4822,4951],"source":" Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer."},{"content":"If the type has no finalizer, the call to <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> has no effect.","pos":[4952,5070],"source":" If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> has no effect."},{"content":"Note that the actual work of releasing unmanaged resources is performed by the second overload of the <ph id=\"ph1\">`Dispose`</ph> method.","pos":[5071,5190],"source":" Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method."},{"pos":[5200,5229],"content":"The Dispose(Boolean) overload","linkify":"The Dispose(Boolean) overload","nodes":[{"content":"The Dispose(Boolean) overload","pos":[0,29]}]},{"pos":[5231,5469],"content":"In the second overload, the <bpt id=\"p1\">*</bpt>disposing<ept id=\"p1\">*</ept> parameter is a <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph> that indicates whether the method call comes from a <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method (its value is <ph id=\"ph3\">`true`</ph>) or from a finalizer (its value is <ph id=\"ph4\">`false`</ph>).","source":"In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`)."},{"content":"The body of the method consists of two blocks of code:","pos":[5475,5529]},{"content":"A block that frees unmanaged resources.","pos":[5537,5576]},{"content":"This block executes regardless of the value of the <ph id=\"ph1\">`disposing`</ph> parameter.","pos":[5577,5650],"source":" This block executes regardless of the value of the `disposing` parameter."},{"content":"A conditional block that frees managed resources.","pos":[5658,5707]},{"content":"This block executes if the value of <ph id=\"ph1\">`disposing`</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[5708,5766],"source":" This block executes if the value of `disposing` is `true`."},{"content":"The managed resources that it frees can include:","pos":[5767,5815]},{"content":"<bpt id=\"p1\">**</bpt>Managed objects that implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph>.<ept id=\"p1\">**</ept>","pos":[5823,5884],"source":"**Managed objects that implement <xref:System.IDisposable>.**"},{"content":"The conditional block can be used to call their <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation.","pos":[5885,5985],"source":" The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation."},{"content":"If you have used a safe handle to wrap your unmanaged resource, you should call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=fullName&gt;</ph> implementation here.","pos":[5986,6192],"source":" If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=fullName> implementation here."},{"content":"<bpt id=\"p1\">**</bpt>Managed objects that consume large amounts of memory or consume scarce resources.<ept id=\"p1\">**</ept>","pos":[6200,6285],"source":"**Managed objects that consume large amounts of memory or consume scarce resources.**"},{"content":"Freeing these objects explicitly in the <ph id=\"ph1\">`Dispose`</ph> method releases them faster than if they were reclaimed non-deterministically by the garbage collector.","pos":[6286,6439],"source":" Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector."},{"content":"If the method call comes from a finalizer (that is, if <bpt id=\"p1\">*</bpt>disposing<ept id=\"p1\">*</ept> is <ph id=\"ph1\">`false`</ph>), only the code that frees unmanaged resources executes.","pos":[6445,6579],"source":"If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes."},{"content":"Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this <ph id=\"ph1\">`Dispose`</ph> overload with a value of <ph id=\"ph2\">`false`</ph> prevents the finalizer from trying to release managed resources that may have already been reclaimed.","pos":[6580,6847],"source":" Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed."},{"pos":[6856,6905],"content":"Implementing the dispose pattern for a base class","linkify":"Implementing the dispose pattern for a base class","nodes":[{"content":"Implementing the dispose pattern for a base class","pos":[0,49]}]},{"content":"If you implement the dispose pattern for a base class, you must provide the following:","pos":[6907,6993]},{"pos":[7001,7168],"content":"[!IMPORTANT]\nYou should implement this pattern for all base classes that implement <xref:System.IDisposable> and are not `sealed` (`NotInheritable` in Visual Basic).","leadings":["","> "],"nodes":[{"content":"You should implement this pattern for all base classes that implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> and are not <ph id=\"ph2\">`sealed`</ph> (<ph id=\"ph3\">`NotInheritable`</ph> in Visual Basic).","pos":[13,165],"source":"You should implement this pattern for all base classes that implement <xref:System.IDisposable> and are not `sealed` (`NotInheritable` in Visual Basic)."}]},{"pos":[7176,7271],"content":"A <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation that calls the <ph id=\"ph2\">`Dispose(Boolean)`</ph> method.","source":"A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method."},{"pos":[7279,7360],"content":"A <ph id=\"ph1\">`Dispose(Boolean)`</ph> method that performs the actual work of releasing resources.","source":"A `Dispose(Boolean)` method that performs the actual work of releasing resources."},{"content":"Either a class derived from <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> that wraps your unmanaged resource (recommended), or an override to the <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[7368,7582],"source":"Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class provides a finalizer that frees you from having to code one.","pos":[7583,7702],"source":" The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one."},{"content":"Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.","pos":[7708,7813]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#3<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)</ept><ept id=\"p1\">]</ept>","pos":[7819,7945],"source":"[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#3<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)</ept><ept id=\"p1\">]</ept>","pos":[7946,8073],"source":"[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]"},{"pos":[8081,8412],"content":"[!NOTE]\nThe previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead. Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.","leadings":["","> "],"nodes":[{"content":"The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead. Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.","pos":[8,329],"nodes":[{"content":"The previous example uses a <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> object to illustrate the pattern; any object derived from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> could be used instead.","pos":[0,207],"source":"The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead."},{"content":"Note that the example does not properly instantiate its <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> object.","pos":[208,321],"source":" Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object."}]}]},{"content":"Here's the general pattern for implementing the dispose pattern for a base class that overrides <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph>.","pos":[8418,8572],"source":"Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=fullName>."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#5<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)</ept><ept id=\"p1\">]</ept>","pos":[8578,8704],"source":"[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#5<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)</ept><ept id=\"p1\">]</ept>","pos":[8705,8832],"source":"[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]"},{"pos":[8840,9023],"content":"[!NOTE]\nIn C#, you override <xref:System.Object.Finalize%2A?displayProperty=fullName> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).","leadings":["","> "],"nodes":[{"content":"In C#, you override <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> by defining a <bpt id=\"p1\">[</bpt>destructor<ept id=\"p1\">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept>.","pos":[8,181],"source":"In C#, you override <xref:System.Object.Finalize%2A?displayProperty=fullName> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)."}]},{"pos":[9032,9084],"content":"Implementing the dispose pattern for a derived class","linkify":"Implementing the dispose pattern for a derived class","nodes":[{"content":"Implementing the dispose pattern for a derived class","pos":[0,52]}]},{"content":"A class derived from a class that implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface shouldn't implement <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph>, because the base class implementation of <ph id=\"ph3\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> is inherited by its derived classes.","pos":[9086,9357],"source":"A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> is inherited by its derived classes."},{"content":"Instead, to implement the dispose pattern for a derived class, you provide the following:","pos":[9358,9447]},{"content":"A <ph id=\"ph1\">`protected``Dispose(Boolean)`</ph> method that overrides the base class method and performs the actual work of releasing the resources of the derived class.","pos":[9455,9608],"source":"A `protected``Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class."},{"content":"This method should also call the <ph id=\"ph1\">`Dispose(Boolean)`</ph> method of the base class and pass it a value of <ph id=\"ph2\">`true`</ph> for the <bpt id=\"p1\">*</bpt>disposing<ept id=\"p1\">*</ept> argument.","pos":[9609,9745],"source":" This method should also call the `Dispose(Boolean)` method of the base class and pass it a value of `true` for the *disposing* argument."},{"content":"Either a class derived from <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> that wraps your unmanaged resource (recommended), or an override to the <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[9753,9967],"source":"Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class provides a finalizer that frees you from having to code one.","pos":[9968,10087],"source":" The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one."},{"content":"If you do provide a finalizer, it should call the <ph id=\"ph1\">`Dispose(Boolean)`</ph> overload with a <bpt id=\"p1\">*</bpt>disposing<ept id=\"p1\">*</ept> argument of <ph id=\"ph2\">`false`</ph>.","pos":[10088,10205],"source":" If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`."},{"content":"Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:","pos":[10211,10319]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#4<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)</ept><ept id=\"p1\">]</ept>","pos":[10325,10454],"source":"[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#4<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)</ept><ept id=\"p1\">]</ept>","pos":[10455,10585],"source":"[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]"},{"pos":[10593,10924],"content":"[!NOTE]\nThe previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead. Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.","leadings":["","> "],"nodes":[{"content":"The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead. Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.","pos":[8,329],"nodes":[{"content":"The previous example uses a <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> object to illustrate the pattern; any object derived from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> could be used instead.","pos":[0,207],"source":"The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead."},{"content":"Note that the example does not properly instantiate its <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> object.","pos":[208,321],"source":" Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object."}]}]},{"content":"Here's the general pattern for implementing the dispose pattern for a derived class that overrides <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph>:","pos":[10930,11087],"source":"Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=fullName>:"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#6<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)</ept><ept id=\"p1\">]</ept>","pos":[11093,11222],"source":"[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#6<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)</ept><ept id=\"p1\">]</ept>","pos":[11223,11353],"source":"[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]"},{"pos":[11361,11544],"content":"[!NOTE]\nIn C#, you override <xref:System.Object.Finalize%2A?displayProperty=fullName> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md).","leadings":["","> "],"nodes":[{"content":"In C#, you override <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> by defining a <bpt id=\"p1\">[</bpt>destructor<ept id=\"p1\">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept>.","pos":[8,181],"source":"In C#, you override <xref:System.Object.Finalize%2A?displayProperty=fullName> by defining a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)."}]},{"pos":[11583,11601],"content":"Using safe handles","linkify":"Using safe handles","nodes":[{"content":"Using safe handles","pos":[0,18]}]},{"content":"Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.","pos":[11603,11706]},{"content":"Therefore, we recommend that you construct <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> objects instead of implementing a finalizer.","pos":[11707,11868],"source":" Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> objects instead of implementing a finalizer."},{"content":"Classes derived from the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> class simplify object lifetime issues by assigning and releasing handles without interruption.","pos":[11874,12067],"source":"Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> class simplify object lifetime issues by assigning and releasing handles without interruption."},{"content":"They contain a critical finalizer that is guaranteed to run while an application domain is unloading.","pos":[12068,12169]},{"content":"For more information about the advantages of using a safe handle, see <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph>.","pos":[12170,12314],"source":" For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>."},{"content":"The following derived classes in the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles&gt;</ph> namespace provide safe handles:","pos":[12315,12418],"source":" The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:"},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph>, and <ph id=\"ph3\">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> class, for files, memory mapped files, and pipes.","pos":[12426,12647],"source":"The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> class, for memory views.","pos":[12655,12745],"source":"The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id=\"ph3\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> classes, for cryptography constructs.","pos":[12753,12973],"source":"The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> class, for registry keys.","pos":[12981,13064],"source":"The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> class, for wait handles.","pos":[13072,13150],"source":"The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles."},{"pos":[13182,13251],"content":"Using a safe handle to implement the dispose pattern for a base class","linkify":"Using a safe handle to implement the dispose pattern for a base class","nodes":[{"content":"Using a safe handle to implement the dispose pattern for a base class","pos":[0,69]}]},{"content":"The following example illustrates the dispose pattern for a base class, <ph id=\"ph1\">`DisposableStreamResource`</ph>, that uses a safe handle to encapsulate unmanaged resources.","pos":[13253,13412],"source":"The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources."},{"content":"It defines a <ph id=\"ph1\">`DisposableResource`</ph> class that uses a <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> to wrap a <ph id=\"ph3\">&lt;xref:System.IO.Stream&gt;</ph> object that represents an open file.","pos":[13413,13585],"source":" It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file."},{"content":"The <ph id=\"ph1\">`DisposableResource`</ph> method also includes a single property, <ph id=\"ph2\">`Size`</ph>, that returns the total number of bytes in the file stream.","pos":[13586,13717],"source":" The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#9<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)</ept><ept id=\"p1\">]</ept>","pos":[13723,13848],"source":"[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#9<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)</ept><ept id=\"p1\">]</ept>","pos":[13849,13975],"source":"[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]"},{"pos":[14010,14082],"content":"Using a safe handle to implement the dispose pattern for a derived class","linkify":"Using a safe handle to implement the dispose pattern for a derived class","nodes":[{"content":"Using a safe handle to implement the dispose pattern for a derived class","pos":[0,72]}]},{"content":"The following example illustrates the dispose pattern for a derived class, <ph id=\"ph1\">`DisposableStreamResource2`</ph>, that inherits from the <ph id=\"ph2\">`DisposableStreamResource`</ph> class presented in the previous example.","pos":[14084,14278],"source":"The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example."},{"content":"The class adds an additional method, <ph id=\"ph1\">`WriteFileInfo`</ph>, and uses a <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> object to wrap the handle of the writable file.","pos":[14279,14441],"source":" The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#10<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)</ept><ept id=\"p1\">]</ept>","pos":[14447,14577],"source":"[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Conceptual.Disposable#10<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)</ept><ept id=\"p1\">]</ept>","pos":[14578,14709],"source":"[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]"},{"pos":[14718,14726],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>","pos":[14728,14764],"source":"<xref:System.GC.SuppressFinalize%2A> "},{"content":"<ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph>","pos":[14768,14793],"source":"<xref:System.IDisposable> "},{"content":"<ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph>","pos":[14797,14858],"source":"<xref:System.IDisposable.Dispose%2A?displayProperty=fullName> "},{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles&gt;</ph>","pos":[14862,14896],"source":"<xref:Microsoft.Win32.SafeHandles> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph>","pos":[14900,14973],"source":"<xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph>","pos":[14977,15034],"source":"<xref:System.Object.Finalize%2A?displayProperty=fullName> "},{"content":"<bpt id=\"p1\">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id=\"p1\">](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)</ept><ph id=\"ph1\"> </ph>","pos":[15038,15164],"source":"[How to: Define and Consume Classes and Structs (C++/CLI)](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli) "},{"content":"<bpt id=\"p1\">[</bpt>Dispose Pattern<ept id=\"p1\">](../../../docs/standard/design-guidelines/dispose-pattern.md)</ept>","pos":[15167,15245],"source":"[Dispose Pattern](../../../docs/standard/design-guidelines/dispose-pattern.md)"}]}