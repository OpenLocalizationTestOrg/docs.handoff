<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="basic-query-operations.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1ced446d6646bd26b9169f5894138e12a38efde7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\basic-query-operations.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1c6c7ca5b33f98ec8b768ab085b5e9021f662cdd</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ac82a01baf3b8aee64ce8a79c14b03a2b2b08ab2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Basic Query Operations (Visual Basic) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Basic Query Operations (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic provides a brief introduction to <ph id="ph1">[!INCLUDE[vbteclinqext](../../../../csharp/getting-started/includes/vbteclinqext_md.md)]</ph> expressions in Visual Basic, and to some of the typical kinds of operations that you perform in a query.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For more information, see the following topics:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Queries<ept id="p1">](../../../../visual-basic/language-reference/queries/queries.md)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Walkthrough: Writing Queries in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/walkthrough-writing-queries.md)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Specifying the Data Source (From)</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In a <ph id="ph1">[!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]</ph> query, the first step is to specify the data source that you want to query.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Therefore, the <ph id="ph1">`From`</ph> clause in a query always comes first.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Query operators select and shape the result based on the type of the source.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`From`</ph> clause specifies the data source, <ph id="ph2">`customers`</ph>, and a <bpt id="p1">*</bpt>range variable<ept id="p1">*</ept>, <ph id="ph3">`cust`</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The range variable is like a loop iteration variable, except that in a query expression, no actual iteration occurs.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When the query is executed, often by using a <ph id="ph1">`For Each`</ph> loop, the range variable serves as a reference to each successive element in <ph id="ph2">`customers`</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Because the compiler can infer the type of <ph id="ph1">`cust`</ph>, you do not have to specify it explicitly.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For examples of queries written with and without explicit typing, see <bpt id="p1">[</bpt>Type Relationships in Query Operations (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information about how to use the <ph id="ph1">`From`</ph> clause in Visual Basic, see <bpt id="p1">[</bpt>From Clause<ept id="p1">](../../../../visual-basic/language-reference/queries/from-clause.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Filtering Data (Where)</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Probably the most common query operation is applying a filter in the form of a Boolean expression.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The query then returns only those elements for which the expression is true.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Where`</ph> clause is used to perform the filtering.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The filter specifies which elements in the data source to include in the resulting sequence.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the following example, only those customers who have an address in London are included.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You can use logical operators such as <ph id="ph1">`And`</ph> and <ph id="ph2">`Or`</ph> to combine filter expressions in a <ph id="ph3">`Where`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example, to return only those customers who are from London and whose name is Devon, use the following code:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>To return customers from London or Paris, use the following code:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For more information about how to use the <ph id="ph1">`Where`</ph> clause in Visual Basic, see <bpt id="p1">[</bpt>Where Clause<ept id="p1">](../../../../visual-basic/language-reference/queries/where-clause.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Ordering Data (Order By)</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>It often is convenient to sort returned data into a particular order.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Order By`</ph> clause will cause the elements in the returned sequence to be sorted on a specified field or fields.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, the following query sorts the results based on the <ph id="ph1">`Name`</ph> property.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`Name`</ph> is a string, the returned data will be sorted alphabetically, from A to Z.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To order the results in reverse order, from Z to A, use the <ph id="ph1">`Order By...Descending`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`Ascending`</ph> when neither <ph id="ph2">`Ascending`</ph> nor <ph id="ph3">`Descending`</ph> is specified.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information about how to use the <ph id="ph1">`Order By`</ph> clause in Visual Basic, see <bpt id="p1">[</bpt>Order By Clause<ept id="p1">](../../../../visual-basic/language-reference/queries/order-by-clause.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Selecting Data (Select)</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Select`</ph> clause specifies the form and content of returned elements.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, you can specify whether your results will consist of complete <ph id="ph1">`Customer`</ph> objects, just one <ph id="ph2">`Customer`</ph> property, a subset of properties, a combination of properties from various data sources, or some new result type based on a computation.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`Select`</ph> clause produces something other than a copy of the source element, the operation is called a <bpt id="p1">*</bpt>projection<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>To retrieve a collection that consists of complete <ph id="ph1">`Customer`</ph> objects, select the range variable itself:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">`Customer`</ph> instance is a large object that has many fields, and all that you want to retrieve is the name, you can select <ph id="ph2">`cust.Name`</ph>, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Local type inference recognizes that this changes the result type from a collection of <ph id="ph1">`Customer`</ph> objects to a collection of strings.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To select multiple fields from the data source, you have two choices:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`Select`</ph> clause, specify the fields you want to include in the result.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The compiler will define an anonymous type that has those fields as its properties.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Because the returned elements in the following example are instances of an anonymous type, you cannot refer to the type by name elsewhere in your code.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The compiler-designated name for the type contains characters that are not valid in normal Visual Basic code.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>In the following example, the elements in the collection that is returned by the query in <ph id="ph1">`londonCusts4`</ph> are instances of an anonymous type</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Define a named type that contains the particular fields that you want to include in the result, and create and initialize instances of the type in the <ph id="ph1">`Select`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Use this option only if you have to use individual results outside the collection in which they are returned, or if you have to pass them as parameters in method calls.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The type of <ph id="ph1">`londonCusts5`</ph> in the following example is IEnumerable(Of NamePhone).</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about how to use the <ph id="ph1">`Select`</ph> clause in Visual Basic, see <bpt id="p1">[</bpt>Select Clause<ept id="p1">](../../../../visual-basic/language-reference/queries/select-clause.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Joining Data (Join and Group Join)</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can combine more than one data source in the <ph id="ph1">`From`</ph> clause in several ways.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, the following code uses two data sources and implicitly combines properties from both of them in the result.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The query selects students whose last names start with a vowel.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can run this code with the list of students created in <bpt id="p1">[</bpt>How to: Create a List of Items<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/how-to-create-a-list-of-items.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Join`</ph> keyword is equivalent to an <ph id="ph2">`INNER JOIN`</ph> in SQL.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>It combines two collections based on matching key values between elements in the two collections.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The query returns all or part of the collection elements that have matching key values.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example, the following code duplicates the action of the previous implicit join.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Group Join`</ph> combines collections into a single hierarchical collection, just like a <ph id="ph2">`LEFT JOIN`</ph> in SQL.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Join Clause<ept id="p1">](../../../../visual-basic/language-reference/queries/join-clause.md)</ept> and <bpt id="p2">[</bpt>Group Join Clause<ept id="p2">](../../../../visual-basic/language-reference/queries/group-join-clause.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Grouping Data (Group By)</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can add a <ph id="ph1">`Group By`</ph> clause to group the elements in a query result according to one or more fields of the elements.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For example, the following code groups students by class year.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If you run this code using the list of students created in <bpt id="p1">[</bpt>How to: Create a List of Items<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/how-to-create-a-list-of-items.md)</ept>, the output from the <ph id="ph1">`For Each`</ph> statement is:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Year: Junior</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Tucker, Michael</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Garcia, Hugo</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Garcia, Debra</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Tucker, Lance</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Year: Senior</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Omelchenko, Svetlana</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Osada, Michiko</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Fakhouri, Fadi</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Feng, Hanying</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Adams, Terry</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Year: Freshman</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Mortensen, Sven</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Garcia, Cesar</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The variation shown in the following code orders the class years, and then orders the students within each year by last name.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">`Group By`</ph>, see <bpt id="p1">[</bpt>Group By Clause<ept id="p1">](../../../../visual-basic/language-reference/queries/group-by-clause.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started with LINQ in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/getting-started-with-linq.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Queries<ept id="p1">](../../../../visual-basic/language-reference/queries/queries.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Standard Query Operators Overview (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ<ept id="p1">](../../../../visual-basic/programming-guide/language-features/linq/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>