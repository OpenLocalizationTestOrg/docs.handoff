{"content":"---\ntitle: \"CountdownEvent\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"synchronization primitives, CountdownEvent\"\nms.assetid: eec3812a-e20f-4ecd-bfef-6921d508b708\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# CountdownEvent\n<xref:System.Threading.CountdownEvent?displayProperty=nameWithType> is a synchronization primitive that unblocks its waiting threads after it has been signaled a certain number of times. <xref:System.Threading.CountdownEvent> is designed for scenarios in which you would otherwise have to use a <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim> and manually decrement a variable before signaling the event. For example, in a fork/join scenario, you can just create a <xref:System.Threading.CountdownEvent> that has a signal count of 5, and then start five work items on the thread pool and have each work item call <xref:System.Threading.CountdownEvent.Signal%2A> when it completes. Each call to <xref:System.Threading.CountdownEvent.Signal%2A> decrements the signal count by 1. On the main thread, the call to <xref:System.Threading.CountdownEvent.Wait%2A> will block until the signal count is zero.  \n  \n> [!NOTE]\n>  For code that does not have to interact with legacy .NET Framework synchronization APIs, consider using <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objects or the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method for an even easier approach to expressing fork-join parallelism.  \n  \n <xref:System.Threading.CountdownEvent> has these additional features:  \n  \n-   The wait operation can be canceled by using cancellation tokens.  \n  \n-   Its signal count can be incremented after the instance is created.  \n  \n-   Instances can be reused after <xref:System.Threading.CountdownEvent.Wait%2A> has returned by calling the <xref:System.Threading.CountdownEvent.Reset%2A> method.  \n  \n-   Instances expose a <xref:System.Threading.WaitHandle> for integration with other .NET Framework synchronization APIs such as <xref:System.Threading.WaitHandle.WaitAll%2A>.  \n  \n## Basic Usage  \n The following example demonstrates how to use a <xref:System.Threading.CountdownEvent> with <xref:System.Threading.ThreadPool> work items.  \n  \n [!code-csharp[CDS_CountdownEvent#01](../../../samples/snippets/csharp/VS_Snippets_Misc/cds_countdownevent/cs/countdownevent.cs#01)]\n [!code-vb[CDS_CountdownEvent#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_countdownevent/vb/module1.vb#01)]  \n  \n## CountdownEvent With Cancellation  \n The following example shows how to cancel the wait operation on <xref:System.Threading.CountdownEvent> by using a cancellation token. The basic pattern follows the model for unified cancellation, which is introduced in [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]. For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md).  \n  \n [!code-csharp[CDS_CountdownEvent#02](../../../samples/snippets/csharp/VS_Snippets_Misc/cds_countdownevent/cs/countdownevent.cs#02)]\n [!code-vb[CDS_CountdownEvent#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_countdownevent/vb/canceleventwait.vb#02)]  \n  \n Note that the wait operation does not cancel the threads that are signaling it. Typically, cancellation is applied to a logical operation, and that can include waiting on the event as well as all the work items that the wait is synchronizing. In this example, each work item is passed a copy of the same cancellation token so that it can respond to the cancellation request.  \n  \n## See also\n\n- <xref:System.Threading.Semaphore?displayProperty=nameWithType>\n","nodes":[{"pos":[4,274],"embed":true,"restype":"x-metadata","content":"title: \"CountdownEvent\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"synchronization primitives, CountdownEvent\"\nms.assetid: eec3812a-e20f-4ecd-bfef-6921d508b708\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"CountdownEvent","nodes":[{"pos":[0,14],"content":"CountdownEvent","nodes":[{"content":"CountdownEvent","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[281,295],"content":"CountdownEvent","linkify":"CountdownEvent","nodes":[{"content":"CountdownEvent","pos":[0,14]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent?displayProperty=nameWithType&gt;</ph> is a synchronization primitive that unblocks its waiting threads after it has been signaled a certain number of times.","pos":[296,482],"source":"<xref:System.Threading.CountdownEvent?displayProperty=nameWithType> is a synchronization primitive that unblocks its waiting threads after it has been signaled a certain number of times."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> is designed for scenarios in which you would otherwise have to use a <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.ManualResetEventSlim&gt;</ph> and manually decrement a variable before signaling the event.","pos":[483,741],"source":"<xref:System.Threading.CountdownEvent> is designed for scenarios in which you would otherwise have to use a <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim> and manually decrement a variable before signaling the event."},{"content":"For example, in a fork/join scenario, you can just create a <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> that has a signal count of 5, and then start five work items on the thread pool and have each work item call <ph id=\"ph2\">&lt;xref:System.Threading.CountdownEvent.Signal%2A&gt;</ph> when it completes.","pos":[742,1017],"source":" For example, in a fork/join scenario, you can just create a <xref:System.Threading.CountdownEvent> that has a signal count of 5, and then start five work items on the thread pool and have each work item call <xref:System.Threading.CountdownEvent.Signal%2A> when it completes."},{"content":"Each call to <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent.Signal%2A&gt;</ph> decrements the signal count by 1.","pos":[1018,1113],"source":" Each call to <xref:System.Threading.CountdownEvent.Signal%2A> decrements the signal count by 1."},{"content":"On the main thread, the call to <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent.Wait%2A&gt;</ph> will block until the signal count is zero.","pos":[1114,1235],"source":" On the main thread, the call to <xref:System.Threading.CountdownEvent.Wait%2A> will block until the signal count is zero."},{"pos":[1243,1557],"content":"[!NOTE]\n For code that does not have to interact with legacy .NET Framework synchronization APIs, consider using <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objects or the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method for an even easier approach to expressing fork-join parallelism.","leadings":["","> "],"nodes":[{"content":"For code that does not have to interact with legacy .NET Framework synchronization APIs, consider using <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> objects or the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Parallel.Invoke%2A&gt;</ph> method for an even easier approach to expressing fork-join parallelism.","pos":[9,312],"source":"For code that does not have to interact with legacy .NET Framework synchronization APIs, consider using <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objects or the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method for an even easier approach to expressing fork-join parallelism."}]},{"pos":[1564,1633],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> has these additional features:","source":"<xref:System.Threading.CountdownEvent> has these additional features:"},{"content":"The wait operation can be canceled by using cancellation tokens.","pos":[1643,1707]},{"content":"Its signal count can be incremented after the instance is created.","pos":[1717,1783]},{"pos":[1793,1953],"content":"Instances can be reused after <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent.Wait%2A&gt;</ph> has returned by calling the <ph id=\"ph2\">&lt;xref:System.Threading.CountdownEvent.Reset%2A&gt;</ph> method.","source":"Instances can be reused after <xref:System.Threading.CountdownEvent.Wait%2A> has returned by calling the <xref:System.Threading.CountdownEvent.Reset%2A> method."},{"pos":[1963,2134],"content":"Instances expose a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> for integration with other .NET Framework synchronization APIs such as <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.","source":"Instances expose a <xref:System.Threading.WaitHandle> for integration with other .NET Framework synchronization APIs such as <xref:System.Threading.WaitHandle.WaitAll%2A>."},{"pos":[2143,2154],"content":"Basic Usage","linkify":"Basic Usage","nodes":[{"content":"Basic Usage","pos":[0,11]}]},{"pos":[2158,2296],"content":"The following example demonstrates how to use a <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> with <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool&gt;</ph> work items.","source":"The following example demonstrates how to use a <xref:System.Threading.CountdownEvent> with <xref:System.Threading.ThreadPool> work items."},{"pos":[2570,2602],"content":"CountdownEvent With Cancellation","linkify":"CountdownEvent With Cancellation","nodes":[{"content":"CountdownEvent With Cancellation","pos":[0,32]}]},{"content":"The following example shows how to cancel the wait operation on <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> by using a cancellation token.","pos":[2606,2739],"source":"The following example shows how to cancel the wait operation on <xref:System.Threading.CountdownEvent> by using a cancellation token."},{"content":"The basic pattern follows the model for unified cancellation, which is introduced in <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>.","pos":[2740,2888],"source":" The basic pattern follows the model for unified cancellation, which is introduced in [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Cancellation in Managed Threads<ept id=\"p1\">](../../../docs/standard/threading/cancellation-in-managed-threads.md)</ept>.","pos":[2889,3018],"source":" For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md)."},{"content":"Note that the wait operation does not cancel the threads that are signaling it.","pos":[3298,3377]},{"content":"Typically, cancellation is applied to a logical operation, and that can include waiting on the event as well as all the work items that the wait is synchronizing.","pos":[3378,3540]},{"content":"In this example, each work item is passed a copy of the same cancellation token so that it can respond to the cancellation request.","pos":[3541,3672]},{"pos":[3681,3689],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]}]}