{"content":"---\ntitle: \"WPF Add-Ins Overview\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"add-ins and XAML browser applications [WPF]\"\n  - \"add-ins overview [WPF]\"\n  - \"add-ins [WPF], performance\"\n  - \"add-ins [WPF], benefits\"\n  - \".NET Framework add-in model [WPF]\"\n  - \"add-ins [WPF], user interface\"\n  - \"add-ins and the user interface [WPF]\"\n  - \"add-ins [WPF], architecture\"\n  - \"add-ins [WPF], limitations\"\nms.assetid: 00b4c776-29a8-4dba-b603-280a0cdc2ade\n---\n# WPF Add-Ins Overview\n<a name=\"Introduction\"></a> The .NET Framework includes an add-in model that developers can use to create applications that support add-in extensibility. This add-in model allows the creation of add-ins that integrate with and extend application functionality. In some scenarios, applications also need to display user interfaces that are provided by add-ins. This topic shows how WPF augments the .NET Framework add-in model to enable these scenarios, the architecture behind it, its benefits, and its limitations.  \n\n<a name=\"Requirements\"></a>   \n## Prerequisites  \n Familiarity with the .NET Framework add-in model is required. For more information, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).  \n  \n<a name=\"AddInsOverview\"></a>   \n## Add-Ins Overview  \n In order to avoid the complexities of application recompilation and redeployment to incorporate new functionality, applications implement extensibility mechanisms that allow developers (both first-party and third-party) to create other applications that integrate with them. The most common way to support this type of extensibility is through the use of add-ins (also known as \"add-ons\" and \"plug-ins\"). Examples of real-world applications that expose extensibility with add-ins include:  \n  \n-   Internet Explorer add-ons.  \n  \n-   Windows Media Player plug-ins.  \n  \n-   Visual Studio add-ins.  \n  \n For example, the Windows Media Player add-in model allows third-party developers to implement \"plug-ins\" that extend Windows Media Player in a variety of ways, including creating decoders and encoders for media formats that are not supported natively by Windows Media Player (for example, DVD, MP3), audio effects, and skins. Each add-in model is built to expose the functionality that is unique to an application, although there are several entities and behaviors that are common to all add-in models.  \n  \n The three main entities of typical add-in extensibility solutions are *contracts*, *add-ins*, and *host applications*. Contracts define how add-ins integrate with host applications in two ways:  \n  \n-   Add-ins integrate with functionality that is implemented by host applications.  \n  \n-   Host applications expose functionality for add-ins to integrate with.  \n  \n In order for add-ins to be used, host applications need to find them and load them at run time. Consequently, applications that support add-ins have the following additional responsibilities:  \n  \n-   **Discovery**: Finding add-ins that adhere to contracts supported by host applications.  \n  \n-   **Activation**: Loading, running, and establishing communication with add-ins.  \n  \n-   **Isolation**: Using either application domains or processes to establish isolation boundaries that protect applications from potential security and execution problems with add-ins.  \n  \n-   **Communication**: Allowing add-ins and host applications to communicate with each other across isolation boundaries by calling methods and passing data.  \n  \n-   **Lifetime Management**: Loading and unloading application domains and processes in a clean, predictable manner (see [Application Domains](../../app-domains/application-domains.md)).  \n  \n-   **Versioning**: Ensuring that host applications and add-ins can still communicate when new versions of either are created.  \n  \n Ultimately, developing a robust add-in model is a non-trivial undertaking. For this reason, the .NET Framework provides an infrastructure for building add-in models.  \n  \n> [!NOTE]\n>  For more detailed information on add-ins, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).  \n  \n<a name=\"NETFrameworkAddInModelOverview\"></a>   \n## .NET Framework Add-In Model Overview  \n The .NET Framework add-in model, found in the <xref:System.AddIn> namespace, contains a set of types that are designed to simplify the development of add-in extensibility. The fundamental unit of the .NET Framework add-in model is the *contract*, which defines how a host application and an add-in communicate with each other. A contract is exposed to a host application using a host-application-specific *view* of the contract. Likewise, an add-in-specific *view* of the contract is exposed to the add-in. An *adapter* is used to allow a host application and an add-in to communicate between their respective views of the contract. Contracts, views, and adapters are referred to as segments, and a set of related segments constitutes a *pipeline*. Pipelines are the foundation upon which the .NET Framework add-in model supports discovery, activation, security isolation, execution isolation (using both application domains and processes), communication, lifetime management, and versioning.  \n  \n The sum of this support allows developers to build add-ins that integrate with the functionality of a host application. However, some scenarios require host applications to display user interfaces provided by add-ins. Because each presentation technology in the .NET Framework has its own model for implementing user interfaces, the .NET Framework add-in model does not support any particular presentation technology. Instead, WPF extends the .NET Framework add-in model with UI support for add-ins.  \n  \n<a name=\"WPFAddInModel\"></a>   \n## WPF Add-Ins  \n WPF, in conjunction with the .NET Framework add-in model, allows you to address a wide variety of scenarios that require host applications to display user interfaces from add-ins. In particular, these scenarios are addressed by WPF with the following two programming models:  \n  \n1.  **The add-in returns a UI**. An add-in returns a UI to the host application via a method call, as defined by the contract. This scenario is used in the following cases:  \n  \n    -   The appearance of a UI that is returned by an add-in is dependent on either data or conditions that exist only at run time, such as dynamically generated reports.  \n  \n    -   The UI for services provided by an add-in differs from the UI of the host applications that can use the add-in.  \n  \n    -   The add-in primarily performs a service for the host application, and reports status to the host application with a UI.  \n  \n2.  **The add-in is a UI**. An add-in is a UI, as defined by the contract. This scenario is used in the following cases:  \n  \n    -   An add-in doesn't provide services other than being displayed, such as an advertisement.  \n  \n    -   The UI for services provided by an add-in is common to all host applications that can use that add-in, such as a calculator or color picker.  \n  \n These scenarios require that UI objects can be passed between host application and add-in application domains. Since the .NET Framework add-in model relies on remoting to communicate between application domains, the objects that are passed between them must be remotable.  \n  \n A remotable object is an instance of a class that does one or more of the following:  \n  \n-   Derives from the <xref:System.MarshalByRefObject> class.  \n  \n-   Implements the <xref:System.Runtime.Serialization.ISerializable> interface.  \n  \n-   Has the <xref:System.SerializableAttribute> attribute applied.  \n  \n> [!NOTE]\n>  For more information regarding the creation of remotable .NET Framework objects, see [Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100)).  \n  \n The WPF UI types are not remotable. To solve the problem, WPF extends the .NET Framework add-in model to enable WPF UI created by add-ins to be displayed from host applications. This support is provided by WPF by two types: the <xref:System.AddIn.Contract.INativeHandleContract> interface and two static methods implemented by the <xref:System.AddIn.Pipeline.FrameworkElementAdapters> class: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>. At a high level, these types and methods are used in the following manner:  \n  \n1.  WPF requires that user interfaces provided by add-ins are classes that derive directly or indirectly from <xref:System.Windows.FrameworkElement>, such as shapes, controls, user controls, layout panels, and pages.  \n  \n2.  Wherever the contract declares that a UI will be passed between the add-in and the host application, it must be declared as an <xref:System.AddIn.Contract.INativeHandleContract> (not a <xref:System.Windows.FrameworkElement>); <xref:System.AddIn.Contract.INativeHandleContract> is a remotable representation of the add-in UI that can be passed across isolation boundaries.  \n  \n3.  Before being passed from the add-in's application domain, a <xref:System.Windows.FrameworkElement> is packaged as an <xref:System.AddIn.Contract.INativeHandleContract> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.  \n  \n4.  After being passed to the host application's application domain, the <xref:System.AddIn.Contract.INativeHandleContract> must be repackaged as a <xref:System.Windows.FrameworkElement> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.  \n  \n How <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> are used depends on the specific scenario. The following sections provide details for each programming model.  \n  \n<a name=\"ReturnUIFromAddInContract\"></a>   \n## Add-In Returns a User Interface  \n For an add-in to return a UI to a host application, the following are required:  \n  \n1.  The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.  \n  \n2.  The contract must implement <xref:System.AddIn.Contract.IContract> and, to return a UI, the contract must declare a method with a return value of type <xref:System.AddIn.Contract.INativeHandleContract>.  \n  \n3.  The UI that is passed between the add-in and the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.  \n  \n4.  The UI that is returned by the add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.  \n  \n5.  The UI that is returned must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.  \n  \n6.  The host application displays the returned <xref:System.Windows.FrameworkElement>.  \n  \n For an example that demonstrates how to implement an add-in that returns a UI, see [Create an Add-In That Returns a UI](how-to-create-an-add-in-that-returns-a-ui.md).  \n  \n<a name=\"AddInIsAUI\"></a>   \n## Add-In Is a User Interface  \n When an add-in is a UI, the following are required:  \n  \n1.  The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.  \n  \n2.  The contract interface for the add-in must implement <xref:System.AddIn.Contract.INativeHandleContract>.  \n  \n3.  The add-in that is passed to the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.  \n  \n4.  The add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.  \n  \n5.  The add-in must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.  \n  \n6.  The host application displays the returned <xref:System.Windows.FrameworkElement>.  \n  \n For an example that demonstrates how to implement an add-in that is a UI, see [Create an Add-In That Is a UI](how-to-create-an-add-in-that-is-a-ui.md).  \n  \n<a name=\"ReturningMultipleUIsFromAnAddIn\"></a>   \n## Returning Multiple UIs from an Add-In  \n Add-ins often provide multiple user interfaces for host applications to display. For example, consider an add-in that is a UI that also provides status information to the host application, also as a UI. An add-in like this can be implemented by using a combination of techniques from both the [Add-In Returns a User Interface](#ReturnUIFromAddInContract) and [Add-In Is a User Interface](#AddInIsAUI) models.  \n  \n<a name=\"AddInsAndXBAPs\"></a>   \n## Add-Ins and XAML Browser Applications  \n In the examples so far, the host application has been an installed standalone application. But [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] can also host add-ins, albeit with the following additional build and implementation requirements:  \n  \n-   The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application manifest must be configured specially to download the pipeline (folders and assemblies) and add-in assembly to the [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] application cache on the client machine, in the same folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].  \n  \n-   The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code to discover and load add-ins must use the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] application cache for the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] as the pipeline and add-in location.  \n  \n-   The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] must load the add-in into a special security context if the add-in references loose files that are located at the site of origin; when hosted by [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)], add-ins can only reference loose files that are located at the host application's site of origin.  \n  \n These tasks are described in detail in the following subsections.  \n  \n### Configuring the Pipeline and Add-In for ClickOnce Deployment  \n [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] are downloaded to and run from a safe folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment cache. In order for an [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] to host an add-in, the pipeline and add-in assembly must also be downloaded to the safe folder. To achieve this, you need to configure the application manifest to include both the pipeline and add-in assembly for download. This is most easily done in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)], although the pipeline and add-in assembly needs to be in the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root folder in order for [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] to detect the pipeline assemblies.  \n  \n Consequently, the first step is to build the pipeline and add-in assembly to the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root by setting the build output of each pipeline assembly and add-in assembly projects. The following table shows the build output paths for pipeline assembly projects and add-in assembly project that are in the same solution and root folder as the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project.  \n  \n Table 1: Build Output Paths for the Pipeline Assemblies That Are Hosted by an XBAP  \n  \n|Pipeline assembly project|Build output path|  \n|-------------------------------|-----------------------|  \n|Contract|`..\\HostXBAP\\Contracts\\`|  \n|Add-In View|`..\\HostXBAP\\AddInViews\\`|  \n|Add-In-Side Adapter|`..\\HostXBAP\\AddInSideAdapters\\`|  \n|Host-Side Adapter|`..\\HostXBAP\\HostSideAdapters\\`|  \n|Add-In|`..\\HostXBAP\\AddIns\\WPFAddIn1`|  \n  \n The next step is to specify the pipeline assemblies and add-in assembly as the [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] content files in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:  \n  \n1.  Including the pipeline and add-in assembly in the project by right-clicking each pipeline folder in Solution Explorer and choosing **Include In Project**.  \n  \n2.  Setting the **Build Action** of each pipeline assembly and add-in assembly to **Content** from the **Properties** window.  \n  \n The final step is to configure the application manifest to include the pipeline assembly files and add-in assembly file for download. The files should be located in folders at the root of the folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache that the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application occupies. The configuration can be achieved in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:  \n  \n1.  Right-click the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project, click **Properties**, click **Publish**, and then click the **Application Files** button.  \n  \n2.  In the **Application Files** dialog, set the **Publish Status** of each pipeline and add-in DLL to **Include (Auto)**, and set the **Download Group** for each pipeline and add-in DLL to **(Required)**.  \n  \n### Using the Pipeline and Add-In from the Application Base  \n When the pipeline and add-in are configured for [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment, they are downloaded to the same [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]. To use the pipeline and add-in from the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code must get them from the application base. The various types and members of the .NET Framework add-in model for using pipelines and add-ins provide special support for this scenario. Firstly, the path is identified by the <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> enumeration value. You use this value with overloads of the pertinent add-in members for using pipelines that include the following:  \n  \n-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  \n  \n-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%2CSystem.String%5B%5D%29?displayProperty=nameWithType>  \n  \n-   <xref:System.AddIn.Hosting.AddInStore.Rebuild%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  \n  \n-   <xref:System.AddIn.Hosting.AddInStore.Update%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  \n  \n### Accessing the Host's Site of Origin  \n To ensure that an add-in can reference files from the site of origin, the add-in must be loaded with security isolation that is equivalent to the host application. This security level is identified by the <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> enumeration value, and passed to the <xref:System.AddIn.Hosting.AddInToken.Activate%2A> method when an add-in is activated.  \n  \n<a name=\"WPFAddInModelArchitecture\"></a>   \n## WPF Add-In Architecture  \n At the highest level, as we've seen, WPF enables .NET Framework add-ins to implement user interfaces (that derive directly or indirectly from <xref:System.Windows.FrameworkElement>) using <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>. The result is that the host application is returned a <xref:System.Windows.FrameworkElement> that is displayed from UI in the host application.  \n  \n For simple UI add-in scenarios, this is as much detail as a developer needs. For more complex scenarios, particularly those that try to utilize additional WPF services such as layout, resources, and data binding, more detailed knowledge of how WPF extends the .NET Framework add-in model with UI support is required to understand its benefits and limitations.  \n  \n Fundamentally, WPF doesn't pass a UI from an add-in to a host application; instead, WPF passes the Win32 window handle for the UI by using WPF interoperability. As such, when a UI from an add-in is passed to a host application, the following occurs:  \n  \n-   On the add-in side, WPF acquires a window handle for the UI that will be displayed by the host application. The window handle is encapsulated by an internal WPF class that derives from <xref:System.Windows.Interop.HwndSource> and implements <xref:System.AddIn.Contract.INativeHandleContract>. An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and is marshaled from the add-in's application domain to the host application's application domain.  \n  \n-   On the host application side, WPF repackages the <xref:System.Windows.Interop.HwndSource> as an internal WPF class that derives from <xref:System.Windows.Interop.HwndHost> and consumes <xref:System.AddIn.Contract.INativeHandleContract>. An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the host application.  \n  \n <xref:System.Windows.Interop.HwndHost> exists to display user interfaces, identified by window handles, from WPF user interfaces. For more information, see [WPF and Win32 Interoperation](../advanced/wpf-and-win32-interoperation.md).  \n  \n In summary, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> exist to allow the window handle for a WPF UI to be passed from an add-in to a host application, where it is encapsulated by a <xref:System.Windows.Interop.HwndHost> and displayed the host application's UI.  \n  \n> [!NOTE]\n>  Because the host application gets an <xref:System.Windows.Interop.HwndHost>, the host application cannot convert the object that is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the type it is implemented as by the add-in (for example, a <xref:System.Windows.Controls.UserControl>).  \n  \n By its nature, <xref:System.Windows.Interop.HwndHost> has certain limitations that affect how host applications can use them. However, WPF extends <xref:System.Windows.Interop.HwndHost> with several capabilities for add-in scenarios. These benefits and limitations are described below.  \n  \n<a name=\"WPFAddInModelBenefits\"></a>   \n## WPF Add-In Benefits  \n Because WPF add-in user interfaces are displayed from host applications using an internal class that derives from <xref:System.Windows.Interop.HwndHost>, those user interfaces are constrained by the capabilities of <xref:System.Windows.Interop.HwndHost> with respect to WPF UI services such as layout, rendering, data binding, styles, templates, and resources. However, WPF augments its internal <xref:System.Windows.Interop.HwndHost> subclass with additional capabilities that include the following:  \n  \n-   Tabbing between a host application's UI and an add-in's UI. Note that the \"add-in is a UI\" programming model requires the add-in-side adapter to override <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> to enable tabbing, whether the add-in is fully trusted or partially trusted.  \n  \n-   Honoring accessibility requirements for add-in user interfaces that are displayed from host application user interfaces.  \n  \n-   Enabling WPF applications to run safely in multiple application domain scenarios.  \n  \n-   Preventing illegal access to add-in UI window handles when add-ins run with security isolation (that is, a partial-trust security sandbox). Calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> ensures this security:  \n  \n    -   For the \"add-in returns a UI\" programming model, the only way to pass the window handle for an add-in UI across the isolation boundary is to call <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.  \n  \n    -   For the \"add-in is a UI\" programming model, overriding <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> on the add-in-side adapter and calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (as shown in the preceding examples) is required, as is calling the add-in-side adapter's `QueryContract` implementation from the host-side adapter.  \n  \n-   Providing multiple application domain execution protection. Due to limitations with application domains, unhandled exceptions that are thrown in add-in application domains cause the entire application to crash, even though the isolation boundary exists. However, WPF and the .NET Framework add-in model provide a simple way to work around this problem and improve application stability. A WPF add-in that displays a UI creates a <xref:System.Windows.Threading.Dispatcher> for the thread that the application domain runs on, if the host application is a WPF application. You can detect all unhandled exceptions that occur in the application domain by handling the <xref:System.Windows.Threading.Dispatcher.UnhandledException> event of the WPF add-in's <xref:System.Windows.Threading.Dispatcher>. You can get the <xref:System.Windows.Threading.Dispatcher> from the <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> property.  \n  \n<a name=\"WPFAddInModelLimitations\"></a>   \n## WPF Add-In Limitations  \n Beyond the benefits that WPF adds to the default behaviors supplied by <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>, and window handles, there are also limitations for add-in user interfaces that are displayed from host applications:  \n  \n-   Add-in user interfaces displayed from a host application do not respect the host application's clipping behavior.  \n  \n-   The concept of *airspace* in interoperability scenarios also applies to add-ins (see [Technology Regions Overview](../advanced/technology-regions-overview.md)).  \n  \n-   A host application's UI services, such as resource inheritance, data binding, and commanding, are not automatically available to add-in user interfaces. To provide these services to the add-in, you need to update the pipeline.  \n  \n-   An add-in UI cannot be rotated, scaled, skewed, or otherwise affected by a transformation (see [Transforms Overview](../graphics-multimedia/transforms-overview.md)).  \n  \n-   Content inside add-in user interfaces that is rendered by drawing operations from the <xref:System.Drawing> namespace can include alpha blending. However, both an add-in UI and the host application UI that contains it must be 100% opaque; in other words, the `Opacity` property on both must be set to 1.  \n  \n-   If the <xref:System.Windows.Window.AllowsTransparency%2A> property of a window in the host application that contains an add-in UI is set to `true`, the add-in is invisible. This is true even if the add-in UI is 100% opaque (that is, the `Opacity` property has a value of 1).  \n  \n-   An add-in UI must appear on top of other WPF elements in the same top-level window.  \n  \n-   No portion of an add-in's UI can be rendered using a <xref:System.Windows.Media.VisualBrush>. Instead, the add-in may take a snapshot of the generated UI to create a bitmap that can be passed to the host application using methods defined by the contract.  \n  \n-   Media files cannot be played from a <xref:System.Windows.Controls.MediaElement> in an add-in UI.  \n  \n-   Mouse events generated for the add-in UI are neither received nor raised by the host application, and the `IsMouseOver` property for host application UI has a value of `false`.  \n  \n-   When focus shifts between controls in an add-in UI, the `GotFocus` and `LostFocus` events are neither received nor raised by the host application.  \n  \n-   The portion of a host application that contains an add-in UI appears white when printed.  \n  \n-   All dispatchers (see <xref:System.Windows.Threading.Dispatcher>) created by the add-in UI must be shut down manually before the owner add-in is unloaded if the host application continues execution. The contract can implement methods that allow the host application to signal the add-in before the add-in is unloaded, thereby allowing the add-in UI to shut down its dispatchers.  \n  \n-   If an add-in UI is an <xref:System.Windows.Controls.InkCanvas> or contains an <xref:System.Windows.Controls.InkCanvas>, you cannot unload the add-in.  \n  \n<a name=\"PerformanceOptimization\"></a>   \n## Performance Optimization  \n By default, when multiple application domains are used, the various .NET Framework assemblies required by each application are all loaded into that application's domain. As a result, the time required for creating new application domains and starting applications in them might affect performance. However, the .NET Framework provides a way for you to reduce start times by instructing applications to share assemblies across application domains if they are already loaded. You do this by using the <xref:System.LoaderOptimizationAttribute> attribute, which must be applied to the entry point method (`Main`). In this case, you must use only code to implement your application definition (see [Application Management Overview](application-management-overview.md)).  \n  \n## See also\n\n- <xref:System.LoaderOptimizationAttribute>\n- [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))\n- [Application Domains](../../app-domains/application-domains.md)\n- [.NET Framework Remoting Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))\n- [Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))\n- [How-to Topics](how-to-topics.md)\n","nodes":[{"pos":[4,454],"embed":true,"restype":"x-metadata","content":"title: \"WPF Add-Ins Overview\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"add-ins and XAML browser applications [WPF]\"\n  - \"add-ins overview [WPF]\"\n  - \"add-ins [WPF], performance\"\n  - \"add-ins [WPF], benefits\"\n  - \".NET Framework add-in model [WPF]\"\n  - \"add-ins [WPF], user interface\"\n  - \"add-ins and the user interface [WPF]\"\n  - \"add-ins [WPF], architecture\"\n  - \"add-ins [WPF], limitations\"\nms.assetid: 00b4c776-29a8-4dba-b603-280a0cdc2ade","nodes":[{"content":"WPF Add-Ins Overview","nodes":[{"pos":[0,20],"content":"WPF Add-Ins Overview","nodes":[{"content":"WPF Add-Ins Overview","pos":[0,20]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[461,481],"content":"WPF Add-Ins Overview","linkify":"WPF Add-Ins Overview","nodes":[{"content":"WPF Add-Ins Overview","pos":[0,20]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"Introduction\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> The .NET Framework includes an add-in model that developers can use to create applications that support add-in extensibility.","pos":[482,635],"source":"<a name=\"Introduction\"></a> The .NET Framework includes an add-in model that developers can use to create applications that support add-in extensibility."},{"content":"This add-in model allows the creation of add-ins that integrate with and extend application functionality.","pos":[636,742]},{"content":"In some scenarios, applications also need to display user interfaces that are provided by add-ins. This topic shows how WPF augments the .NET Framework add-in model to enable these scenarios, the architecture behind it, its benefits, and its limitations.","pos":[743,997]},{"pos":[1035,1048],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"Familiarity with the .NET Framework add-in model is required.","pos":[1052,1113]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Add-ins and Extensibility<ept id=\"p1\">](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</ept>.","pos":[1114,1233],"source":" For more information, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))."},{"pos":[1275,1291],"content":"Add-Ins Overview","linkify":"Add-Ins Overview","nodes":[{"content":"Add-Ins Overview","pos":[0,16]}]},{"content":"In order to avoid the complexities of application recompilation and redeployment to incorporate new functionality, applications implement extensibility mechanisms that allow developers (both first-party and third-party) to create other applications that integrate with them.","pos":[1295,1569]},{"content":"The most common way to support this type of extensibility is through the use of add-ins (also known as \"add-ons\" and \"plug-ins\").","pos":[1570,1699]},{"content":"Examples of real-world applications that expose extensibility with add-ins include:","pos":[1700,1783]},{"content":"Internet Explorer add-ons.","pos":[1793,1819]},{"content":"Windows Media Player plug-ins.","pos":[1829,1859]},{"content":"Visual Studio add-ins.","pos":[1869,1891]},{"content":"For example, the Windows Media Player add-in model allows third-party developers to implement \"plug-ins\" that extend Windows Media Player in a variety of ways, including creating decoders and encoders for media formats that are not supported natively by Windows Media Player (for example, DVD, MP3), audio effects, and skins.","pos":[1898,2223]},{"content":"Each add-in model is built to expose the functionality that is unique to an application, although there are several entities and behaviors that are common to all add-in models.","pos":[2224,2400]},{"content":"The three main entities of typical add-in extensibility solutions are <bpt id=\"p1\">*</bpt>contracts<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>add-ins<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>host applications<ept id=\"p3\">*</ept>.","pos":[2407,2525],"source":"The three main entities of typical add-in extensibility solutions are *contracts*, *add-ins*, and *host applications*."},{"content":"Contracts define how add-ins integrate with host applications in two ways:","pos":[2526,2600]},{"content":"Add-ins integrate with functionality that is implemented by host applications.","pos":[2610,2688]},{"content":"Host applications expose functionality for add-ins to integrate with.","pos":[2698,2767]},{"content":"In order for add-ins to be used, host applications need to find them and load them at run time.","pos":[2774,2869]},{"content":"Consequently, applications that support add-ins have the following additional responsibilities:","pos":[2870,2965]},{"pos":[2975,3062],"content":"<bpt id=\"p1\">**</bpt>Discovery<ept id=\"p1\">**</ept>: Finding add-ins that adhere to contracts supported by host applications.","source":"**Discovery**: Finding add-ins that adhere to contracts supported by host applications."},{"pos":[3072,3150],"content":"<bpt id=\"p1\">**</bpt>Activation<ept id=\"p1\">**</ept>: Loading, running, and establishing communication with add-ins.","source":"**Activation**: Loading, running, and establishing communication with add-ins."},{"pos":[3160,3341],"content":"<bpt id=\"p1\">**</bpt>Isolation<ept id=\"p1\">**</ept>: Using either application domains or processes to establish isolation boundaries that protect applications from potential security and execution problems with add-ins.","source":"**Isolation**: Using either application domains or processes to establish isolation boundaries that protect applications from potential security and execution problems with add-ins."},{"pos":[3351,3504],"content":"<bpt id=\"p1\">**</bpt>Communication<ept id=\"p1\">**</ept>: Allowing add-ins and host applications to communicate with each other across isolation boundaries by calling methods and passing data.","source":"**Communication**: Allowing add-ins and host applications to communicate with each other across isolation boundaries by calling methods and passing data."},{"pos":[3514,3696],"content":"<bpt id=\"p1\">**</bpt>Lifetime Management<ept id=\"p1\">**</ept>: Loading and unloading application domains and processes in a clean, predictable manner (see <bpt id=\"p2\">[</bpt>Application Domains<ept id=\"p2\">](../../app-domains/application-domains.md)</ept>).","source":"**Lifetime Management**: Loading and unloading application domains and processes in a clean, predictable manner (see [Application Domains](../../app-domains/application-domains.md))."},{"pos":[3706,3828],"content":"<bpt id=\"p1\">**</bpt>Versioning<ept id=\"p1\">**</ept>: Ensuring that host applications and add-ins can still communicate when new versions of either are created.","source":"**Versioning**: Ensuring that host applications and add-ins can still communicate when new versions of either are created."},{"content":"Ultimately, developing a robust add-in model is a non-trivial undertaking.","pos":[3835,3909]},{"content":"For this reason, the .NET Framework provides an infrastructure for building add-in models.","pos":[3910,4000]},{"pos":[4008,4158],"content":"[!NOTE]\n For more detailed information on add-ins, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).","leadings":["","> "],"nodes":[{"content":"For more detailed information on add-ins, see <bpt id=\"p1\">[</bpt>Add-ins and Extensibility<ept id=\"p1\">](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</ept>.","pos":[9,148],"source":"For more detailed information on add-ins, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))."}]},{"pos":[4216,4252],"content":".NET Framework Add-In Model Overview","linkify":".NET Framework Add-In Model Overview","nodes":[{"content":".NET Framework Add-In Model Overview","pos":[0,36]}]},{"content":"The .NET Framework add-in model, found in the <ph id=\"ph1\">&lt;xref:System.AddIn&gt;</ph> namespace, contains a set of types that are designed to simplify the development of add-in extensibility.","pos":[4256,4427],"source":"The .NET Framework add-in model, found in the <xref:System.AddIn> namespace, contains a set of types that are designed to simplify the development of add-in extensibility."},{"content":"The fundamental unit of the .NET Framework add-in model is the <bpt id=\"p1\">*</bpt>contract<ept id=\"p1\">*</ept>, which defines how a host application and an add-in communicate with each other.","pos":[4428,4582],"source":" The fundamental unit of the .NET Framework add-in model is the *contract*, which defines how a host application and an add-in communicate with each other."},{"content":"A contract is exposed to a host application using a host-application-specific <bpt id=\"p1\">*</bpt>view<ept id=\"p1\">*</ept> of the contract.","pos":[4583,4684],"source":" A contract is exposed to a host application using a host-application-specific *view* of the contract."},{"content":"Likewise, an add-in-specific <bpt id=\"p1\">*</bpt>view<ept id=\"p1\">*</ept> of the contract is exposed to the add-in.","pos":[4685,4762],"source":" Likewise, an add-in-specific *view* of the contract is exposed to the add-in."},{"content":"An <bpt id=\"p1\">*</bpt>adapter<ept id=\"p1\">*</ept> is used to allow a host application and an add-in to communicate between their respective views of the contract.","pos":[4763,4888],"source":" An *adapter* is used to allow a host application and an add-in to communicate between their respective views of the contract."},{"content":"Contracts, views, and adapters are referred to as segments, and a set of related segments constitutes a <bpt id=\"p1\">*</bpt>pipeline<ept id=\"p1\">*</ept>.","pos":[4889,5004],"source":" Contracts, views, and adapters are referred to as segments, and a set of related segments constitutes a *pipeline*."},{"content":"Pipelines are the foundation upon which the .NET Framework add-in model supports discovery, activation, security isolation, execution isolation (using both application domains and processes), communication, lifetime management, and versioning.","pos":[5005,5248]},{"content":"The sum of this support allows developers to build add-ins that integrate with the functionality of a host application.","pos":[5255,5374]},{"content":"However, some scenarios require host applications to display user interfaces provided by add-ins. Because each presentation technology in the .NET Framework has its own model for implementing user interfaces, the .NET Framework add-in model does not support any particular presentation technology.","pos":[5375,5672]},{"content":"Instead, WPF extends the .NET Framework add-in model with UI support for add-ins.","pos":[5673,5754]},{"pos":[5795,5806],"content":"WPF Add-Ins","linkify":"WPF Add-Ins","nodes":[{"content":"WPF Add-Ins","pos":[0,11]}]},{"content":"WPF, in conjunction with the .NET Framework add-in model, allows you to address a wide variety of scenarios that require host applications to display user interfaces from add-ins. In particular, these scenarios are addressed by WPF with the following two programming models:","pos":[5810,6084]},{"content":"<bpt id=\"p1\">**</bpt>The add-in returns a UI<ept id=\"p1\">**</ept>.","pos":[6094,6122],"source":"**The add-in returns a UI**."},{"content":"An add-in returns a UI to the host application via a method call, as defined by the contract.","pos":[6123,6216]},{"content":"This scenario is used in the following cases:","pos":[6217,6262]},{"content":"The appearance of a UI that is returned by an add-in is dependent on either data or conditions that exist only at run time, such as dynamically generated reports.","pos":[6276,6438]},{"content":"The UI for services provided by an add-in differs from the UI of the host applications that can use the add-in.","pos":[6452,6563]},{"content":"The add-in primarily performs a service for the host application, and reports status to the host application with a UI.","pos":[6577,6696]},{"content":"<bpt id=\"p1\">**</bpt>The add-in is a UI<ept id=\"p1\">**</ept>.","pos":[6706,6729],"source":"**The add-in is a UI**."},{"content":"An add-in is a UI, as defined by the contract.","pos":[6730,6776]},{"content":"This scenario is used in the following cases:","pos":[6777,6822]},{"content":"An add-in doesn't provide services other than being displayed, such as an advertisement.","pos":[6836,6924]},{"content":"The UI for services provided by an add-in is common to all host applications that can use that add-in, such as a calculator or color picker.","pos":[6938,7078]},{"content":"These scenarios require that UI objects can be passed between host application and add-in application domains.","pos":[7085,7195]},{"content":"Since the .NET Framework add-in model relies on remoting to communicate between application domains, the objects that are passed between them must be remotable.","pos":[7196,7356]},{"content":"A remotable object is an instance of a class that does one or more of the following:","pos":[7363,7447]},{"pos":[7457,7513],"content":"Derives from the <ph id=\"ph1\">&lt;xref:System.MarshalByRefObject&gt;</ph> class.","source":"Derives from the <xref:System.MarshalByRefObject> class."},{"pos":[7523,7598],"content":"Implements the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.","source":"Implements the <xref:System.Runtime.Serialization.ISerializable> interface."},{"pos":[7608,7670],"content":"Has the <ph id=\"ph1\">&lt;xref:System.SerializableAttribute&gt;</ph> attribute applied.","source":"Has the <xref:System.SerializableAttribute> attribute applied."},{"pos":[7678,7890],"content":"[!NOTE]\n For more information regarding the creation of remotable .NET Framework objects, see [Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100)).","leadings":["","> "],"nodes":[{"content":"For more information regarding the creation of remotable .NET Framework objects, see <bpt id=\"p1\">[</bpt>Making Objects Remotable<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))</ept>.","pos":[9,210],"source":"For more information regarding the creation of remotable .NET Framework objects, see [Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))."}]},{"content":"The WPF UI types are not remotable.","pos":[7897,7932]},{"content":"To solve the problem, WPF extends the .NET Framework add-in model to enable WPF UI created by add-ins to be displayed from host applications.","pos":[7933,8074]},{"content":"This support is provided by WPF by two types: the <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> interface and two static methods implemented by the <ph id=\"ph2\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters&gt;</ph> class: <ph id=\"ph3\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph>.","pos":[8075,8451],"source":" This support is provided by WPF by two types: the <xref:System.AddIn.Contract.INativeHandleContract> interface and two static methods implemented by the <xref:System.AddIn.Pipeline.FrameworkElementAdapters> class: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>."},{"content":"At a high level, these types and methods are used in the following manner:","pos":[8452,8526]},{"pos":[8536,8748],"content":"WPF requires that user interfaces provided by add-ins are classes that derive directly or indirectly from <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, such as shapes, controls, user controls, layout panels, and pages.","source":"WPF requires that user interfaces provided by add-ins are classes that derive directly or indirectly from <xref:System.Windows.FrameworkElement>, such as shapes, controls, user controls, layout panels, and pages."},{"pos":[8758,9129],"content":"Wherever the contract declares that a UI will be passed between the add-in and the host application, it must be declared as an <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> (not a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>); <ph id=\"ph3\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> is a remotable representation of the add-in UI that can be passed across isolation boundaries.","source":"Wherever the contract declares that a UI will be passed between the add-in and the host application, it must be declared as an <xref:System.AddIn.Contract.INativeHandleContract> (not a <xref:System.Windows.FrameworkElement>); <xref:System.AddIn.Contract.INativeHandleContract> is a remotable representation of the add-in UI that can be passed across isolation boundaries."},{"pos":[9139,9397],"content":"Before being passed from the add-in's application domain, a <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is packaged as an <ph id=\"ph2\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> by calling <ph id=\"ph3\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph>.","source":"Before being passed from the add-in's application domain, a <xref:System.Windows.FrameworkElement> is packaged as an <xref:System.AddIn.Contract.INativeHandleContract> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>."},{"pos":[9407,9680],"content":"After being passed to the host application's application domain, the <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> must be repackaged as a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> by calling <ph id=\"ph3\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph>.","source":"After being passed to the host application's application domain, the <xref:System.AddIn.Contract.INativeHandleContract> must be repackaged as a <xref:System.Windows.FrameworkElement> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>."},{"content":"How <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph> are used depends on the specific scenario.","pos":[9687,9948],"source":"How <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> are used depends on the specific scenario."},{"content":"The following sections provide details for each programming model.","pos":[9949,10015]},{"pos":[10068,10099],"content":"Add-In Returns a User Interface","linkify":"Add-In Returns a User Interface","nodes":[{"content":"Add-In Returns a User Interface","pos":[0,31]}]},{"content":"For an add-in to return a UI to a host application, the following are required:","pos":[10103,10182]},{"pos":[10192,10394],"content":"The host application, add-in, and pipeline must be created, as described by the .NET Framework <bpt id=\"p1\">[</bpt>Add-ins and Extensibility<ept id=\"p1\">](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</ept> documentation.","source":"The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation."},{"pos":[10404,10606],"content":"The contract must implement <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.IContract&gt;</ph> and, to return a UI, the contract must declare a method with a return value of type <ph id=\"ph2\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>.","source":"The contract must implement <xref:System.AddIn.Contract.IContract> and, to return a UI, the contract must declare a method with a return value of type <xref:System.AddIn.Contract.INativeHandleContract>."},{"pos":[10616,10761],"content":"The UI that is passed between the add-in and the host application must directly or indirectly derive from <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.","source":"The UI that is passed between the add-in and the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>."},{"pos":[10771,10969],"content":"The UI that is returned by the add-in must be converted from a <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> to an <ph id=\"ph2\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> before crossing the isolation boundary.","source":"The UI that is returned by the add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary."},{"pos":[10979,11162],"content":"The UI that is returned must be converted from an <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> to a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> after crossing the isolation boundary.","source":"The UI that is returned must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary."},{"pos":[11172,11254],"content":"The host application displays the returned <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.","source":"The host application displays the returned <xref:System.Windows.FrameworkElement>."},{"pos":[11261,11427],"content":"For an example that demonstrates how to implement an add-in that returns a UI, see <bpt id=\"p1\">[</bpt>Create an Add-In That Returns a UI<ept id=\"p1\">](how-to-create-an-add-in-that-returns-a-ui.md)</ept>.","source":"For an example that demonstrates how to implement an add-in that returns a UI, see [Create an Add-In That Returns a UI](how-to-create-an-add-in-that-returns-a-ui.md)."},{"pos":[11465,11491],"content":"Add-In Is a User Interface","linkify":"Add-In Is a User Interface","nodes":[{"content":"Add-In Is a User Interface","pos":[0,26]}]},{"content":"When an add-in is a UI, the following are required:","pos":[11495,11546]},{"pos":[11556,11758],"content":"The host application, add-in, and pipeline must be created, as described by the .NET Framework <bpt id=\"p1\">[</bpt>Add-ins and Extensibility<ept id=\"p1\">](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</ept> documentation.","source":"The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation."},{"pos":[11768,11872],"content":"The contract interface for the add-in must implement <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>.","source":"The contract interface for the add-in must implement <xref:System.AddIn.Contract.INativeHandleContract>."},{"pos":[11882,12011],"content":"The add-in that is passed to the host application must directly or indirectly derive from <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.","source":"The add-in that is passed to the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>."},{"pos":[12021,12192],"content":"The add-in must be converted from a <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> to an <ph id=\"ph2\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> before crossing the isolation boundary.","source":"The add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary."},{"pos":[12202,12372],"content":"The add-in must be converted from an <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph> to a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> after crossing the isolation boundary.","source":"The add-in must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary."},{"pos":[12382,12464],"content":"The host application displays the returned <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.","source":"The host application displays the returned <xref:System.Windows.FrameworkElement>."},{"pos":[12471,12622],"content":"For an example that demonstrates how to implement an add-in that is a UI, see <bpt id=\"p1\">[</bpt>Create an Add-In That Is a UI<ept id=\"p1\">](how-to-create-an-add-in-that-is-a-ui.md)</ept>.","source":"For an example that demonstrates how to implement an add-in that is a UI, see [Create an Add-In That Is a UI](how-to-create-an-add-in-that-is-a-ui.md)."},{"pos":[12681,12718],"content":"Returning Multiple UIs from an Add-In","linkify":"Returning Multiple UIs from an Add-In","nodes":[{"content":"Returning Multiple UIs from an Add-In","pos":[0,37]}]},{"content":"Add-ins often provide multiple user interfaces for host applications to display.","pos":[12722,12802]},{"content":"For example, consider an add-in that is a UI that also provides status information to the host application, also as a UI.","pos":[12803,12924]},{"content":"An add-in like this can be implemented by using a combination of techniques from both the <bpt id=\"p1\">[</bpt>Add-In Returns a User Interface<ept id=\"p1\">](#ReturnUIFromAddInContract)</ept> and <bpt id=\"p2\">[</bpt>Add-In Is a User Interface<ept id=\"p2\">](#AddInIsAUI)</ept> models.","pos":[12925,13130],"source":" An add-in like this can be implemented by using a combination of techniques from both the [Add-In Returns a User Interface](#ReturnUIFromAddInContract) and [Add-In Is a User Interface](#AddInIsAUI) models."},{"pos":[13172,13209],"content":"Add-Ins and XAML Browser Applications","linkify":"Add-Ins and XAML Browser Applications","nodes":[{"content":"Add-Ins and XAML Browser Applications","pos":[0,37]}]},{"content":"In the examples so far, the host application has been an installed standalone application.","pos":[13213,13303]},{"content":"But <ph id=\"ph1\">[!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)]</ph> can also host add-ins, albeit with the following additional build and implementation requirements:","pos":[13304,13494],"source":" But [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] can also host add-ins, albeit with the following additional build and implementation requirements:"},{"pos":[13504,13926],"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> application manifest must be configured specially to download the pipeline (folders and assemblies) and add-in assembly to the <ph id=\"ph2\">[!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)]</ph> application cache on the client machine, in the same folder as the <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph>.","source":"The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application manifest must be configured specially to download the pipeline (folders and assemblies) and add-in assembly to the [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] application cache on the client machine, in the same folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]."},{"pos":[13936,14275],"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> code to discover and load add-ins must use the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)]</ph> application cache for the <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> as the pipeline and add-in location.","source":"The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code to discover and load add-ins must use the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] application cache for the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] as the pipeline and add-in location."},{"pos":[14285,14694],"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> must load the add-in into a special security context if the add-in references loose files that are located at the site of origin; when hosted by <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)]</ph>, add-ins can only reference loose files that are located at the host application's site of origin.","source":"The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] must load the add-in into a special security context if the add-in references loose files that are located at the site of origin; when hosted by [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)], add-ins can only reference loose files that are located at the host application's site of origin."},{"content":"These tasks are described in detail in the following subsections.","pos":[14701,14766]},{"pos":[14776,14836],"content":"Configuring the Pipeline and Add-In for ClickOnce Deployment","linkify":"Configuring the Pipeline and Add-In for ClickOnce Deployment","nodes":[{"content":"Configuring the Pipeline and Add-In for ClickOnce Deployment","pos":[0,60]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)]</ph> are downloaded to and run from a safe folder in the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)]</ph> deployment cache.","pos":[14840,15081],"source":"[!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] are downloaded to and run from a safe folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment cache."},{"content":"In order for an <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> to host an add-in, the pipeline and add-in assembly must also be downloaded to the safe folder.","pos":[15082,15265],"source":" In order for an [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] to host an add-in, the pipeline and add-in assembly must also be downloaded to the safe folder."},{"content":"To achieve this, you need to configure the application manifest to include both the pipeline and add-in assembly for download.","pos":[15266,15392]},{"content":"This is most easily done in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]</ph>, although the pipeline and add-in assembly needs to be in the host <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> project's root folder in order for <ph id=\"ph3\">[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]</ph> to detect the pipeline assemblies.","pos":[15393,15793],"source":" This is most easily done in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)], although the pipeline and add-in assembly needs to be in the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root folder in order for [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] to detect the pipeline assemblies."},{"content":"Consequently, the first step is to build the pipeline and add-in assembly to the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> project's root by setting the build output of each pipeline assembly and add-in assembly projects.","pos":[15800,16051],"source":"Consequently, the first step is to build the pipeline and add-in assembly to the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root by setting the build output of each pipeline assembly and add-in assembly projects."},{"content":"The following table shows the build output paths for pipeline assembly projects and add-in assembly project that are in the same solution and root folder as the host <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> project.","pos":[16052,16298],"source":" The following table shows the build output paths for pipeline assembly projects and add-in assembly project that are in the same solution and root folder as the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project."},{"content":"Table 1: Build Output Paths for the Pipeline Assemblies That Are Hosted by an XBAP","pos":[16305,16387]},{"content":"Pipeline assembly project","pos":[16394,16419]},{"content":"Build output path","pos":[16420,16437]},{"content":"Contract","pos":[16502,16510]},{"content":"Add-In View","pos":[16540,16551]},{"content":"Add-In-Side Adapter","pos":[16582,16601]},{"content":"Host-Side Adapter","pos":[16639,16656]},{"content":"Add-In","pos":[16693,16699]},{"pos":[16738,17029],"content":"The next step is to specify the pipeline assemblies and add-in assembly as the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)]</ph> content files in <ph id=\"ph2\">[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]</ph> by doing the following:","source":"The next step is to specify the pipeline assemblies and add-in assembly as the [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] content files in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:"},{"pos":[17039,17193],"content":"Including the pipeline and add-in assembly in the project by right-clicking each pipeline folder in Solution Explorer and choosing <bpt id=\"p1\">**</bpt>Include In Project<ept id=\"p1\">**</ept>.","source":"Including the pipeline and add-in assembly in the project by right-clicking each pipeline folder in Solution Explorer and choosing **Include In Project**."},{"pos":[17203,17324],"content":"Setting the <bpt id=\"p1\">**</bpt>Build Action<ept id=\"p1\">**</ept> of each pipeline assembly and add-in assembly to <bpt id=\"p2\">**</bpt>Content<ept id=\"p2\">**</ept> from the <bpt id=\"p3\">**</bpt>Properties<ept id=\"p3\">**</ept> window.","source":"Setting the **Build Action** of each pipeline assembly and add-in assembly to **Content** from the **Properties** window."},{"content":"The final step is to configure the application manifest to include the pipeline assembly files and add-in assembly file for download.","pos":[17331,17464]},{"content":"The files should be located in folders at the root of the folder in the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)]</ph> cache that the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> application occupies.","pos":[17465,17727],"source":" The files should be located in folders at the root of the folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache that the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application occupies."},{"content":"The configuration can be achieved in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]</ph> by doing the following:","pos":[17728,17870],"source":" The configuration can be achieved in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:"},{"pos":[17880,18066],"content":"Right-click the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> project, click <bpt id=\"p1\">**</bpt>Properties<ept id=\"p1\">**</ept>, click <bpt id=\"p2\">**</bpt>Publish<ept id=\"p2\">**</ept>, and then click the <bpt id=\"p3\">**</bpt>Application Files<ept id=\"p3\">**</ept> button.","source":"Right-click the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project, click **Properties**, click **Publish**, and then click the **Application Files** button."},{"pos":[18076,18277],"content":"In the <bpt id=\"p1\">**</bpt>Application Files<ept id=\"p1\">**</ept> dialog, set the <bpt id=\"p2\">**</bpt>Publish Status<ept id=\"p2\">**</ept> of each pipeline and add-in DLL to <bpt id=\"p3\">**</bpt>Include (Auto)<ept id=\"p3\">**</ept>, and set the <bpt id=\"p4\">**</bpt>Download Group<ept id=\"p4\">**</ept> for each pipeline and add-in DLL to <bpt id=\"p5\">**</bpt>(Required)<ept id=\"p5\">**</ept>.","source":"In the **Application Files** dialog, set the **Publish Status** of each pipeline and add-in DLL to **Include (Auto)**, and set the **Download Group** for each pipeline and add-in DLL to **(Required)**."},{"pos":[18287,18342],"content":"Using the Pipeline and Add-In from the Application Base","linkify":"Using the Pipeline and Add-In from the Application Base","nodes":[{"content":"Using the Pipeline and Add-In from the Application Base","pos":[0,55]}]},{"content":"When the pipeline and add-in are configured for <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)]</ph> deployment, they are downloaded to the same <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)]</ph> cache folder as the <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph>.","pos":[18346,18694],"source":"When the pipeline and add-in are configured for [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment, they are downloaded to the same [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]."},{"content":"To use the pipeline and add-in from the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph>, the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]</ph> code must get them from the application base.","pos":[18695,18929],"source":" To use the pipeline and add-in from the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code must get them from the application base."},{"content":"The various types and members of the .NET Framework add-in model for using pipelines and add-ins provide special support for this scenario.","pos":[18930,19069]},{"content":"Firstly, the path is identified by the <ph id=\"ph1\">&lt;xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase&gt;</ph> enumeration value.","pos":[19070,19193],"source":" Firstly, the path is identified by the <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> enumeration value."},{"content":"You use this value with overloads of the pertinent add-in members for using pipelines that include the following:","pos":[19194,19307]},{"pos":[19904,19939],"content":"Accessing the Host's Site of Origin","linkify":"Accessing the Host's Site of Origin","nodes":[{"content":"Accessing the Host's Site of Origin","pos":[0,35]}]},{"content":"To ensure that an add-in can reference files from the site of origin, the add-in must be loaded with security isolation that is equivalent to the host application.","pos":[19943,20106]},{"content":"This security level is identified by the <ph id=\"ph1\">&lt;xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType&gt;</ph> enumeration value, and passed to the <ph id=\"ph2\">&lt;xref:System.AddIn.Hosting.AddInToken.Activate%2A&gt;</ph> method when an add-in is activated.","pos":[20107,20352],"source":" This security level is identified by the <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> enumeration value, and passed to the <xref:System.AddIn.Hosting.AddInToken.Activate%2A> method when an add-in is activated."},{"pos":[20405,20428],"content":"WPF Add-In Architecture","linkify":"WPF Add-In Architecture","nodes":[{"content":"WPF Add-In Architecture","pos":[0,23]}]},{"content":"At the highest level, as we've seen, WPF enables .NET Framework add-ins to implement user interfaces (that derive directly or indirectly from <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>) using <ph id=\"ph2\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph>.","pos":[20432,20834],"source":"At the highest level, as we've seen, WPF enables .NET Framework add-ins to implement user interfaces (that derive directly or indirectly from <xref:System.Windows.FrameworkElement>) using <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>."},{"content":"The result is that the host application is returned a <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that is displayed from UI in the host application.","pos":[20835,20978],"source":" The result is that the host application is returned a <xref:System.Windows.FrameworkElement> that is displayed from UI in the host application."},{"content":"For simple UI add-in scenarios, this is as much detail as a developer needs.","pos":[20985,21061]},{"content":"For more complex scenarios, particularly those that try to utilize additional WPF services such as layout, resources, and data binding, more detailed knowledge of how WPF extends the .NET Framework add-in model with UI support is required to understand its benefits and limitations.","pos":[21062,21344]},{"content":"Fundamentally, WPF doesn't pass a UI from an add-in to a host application; instead, WPF passes the Win32 window handle for the UI by using WPF interoperability.","pos":[21351,21511]},{"content":"As such, when a UI from an add-in is passed to a host application, the following occurs:","pos":[21512,21600]},{"content":"On the add-in side, WPF acquires a window handle for the UI that will be displayed by the host application.","pos":[21610,21717]},{"content":"The window handle is encapsulated by an internal WPF class that derives from <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> and implements <ph id=\"ph2\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>.","pos":[21718,21902],"source":" The window handle is encapsulated by an internal WPF class that derives from <xref:System.Windows.Interop.HwndSource> and implements <xref:System.AddIn.Contract.INativeHandleContract>."},{"content":"An instance of this class is returned by <ph id=\"ph1\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph> and is marshaled from the add-in's application domain to the host application's application domain.","pos":[21903,22122],"source":" An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and is marshaled from the add-in's application domain to the host application's application domain."},{"content":"On the host application side, WPF repackages the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph> as an internal WPF class that derives from <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and consumes <ph id=\"ph3\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>.","pos":[22132,22368],"source":"On the host application side, WPF repackages the <xref:System.Windows.Interop.HwndSource> as an internal WPF class that derives from <xref:System.Windows.Interop.HwndHost> and consumes <xref:System.AddIn.Contract.INativeHandleContract>."},{"content":"An instance of this class is returned by <ph id=\"ph1\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph> to the host application.","pos":[22369,22513],"source":" An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the host application."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> exists to display user interfaces, identified by window handles, from WPF user interfaces.","pos":[22520,22649],"source":"<xref:System.Windows.Interop.HwndHost> exists to display user interfaces, identified by window handles, from WPF user interfaces."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>WPF and Win32 Interoperation<ept id=\"p1\">](../advanced/wpf-and-win32-interoperation.md)</ept>.","pos":[22650,22752],"source":" For more information, see [WPF and Win32 Interoperation](../advanced/wpf-and-win32-interoperation.md)."},{"pos":[22759,23192],"content":"In summary, <ph id=\"ph1\">&lt;xref:System.AddIn.Contract.INativeHandleContract&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph> exist to allow the window handle for a WPF UI to be passed from an add-in to a host application, where it is encapsulated by a <ph id=\"ph4\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and displayed the host application's UI.","source":"In summary, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> exist to allow the window handle for a WPF UI to be passed from an add-in to a host application, where it is encapsulated by a <xref:System.Windows.Interop.HwndHost> and displayed the host application's UI."},{"pos":[23200,23541],"content":"[!NOTE]\n Because the host application gets an <xref:System.Windows.Interop.HwndHost>, the host application cannot convert the object that is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the type it is implemented as by the add-in (for example, a <xref:System.Windows.Controls.UserControl>).","leadings":["","> "],"nodes":[{"content":"Because the host application gets an <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>, the host application cannot convert the object that is returned by <ph id=\"ph2\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A&gt;</ph> to the type it is implemented as by the add-in (for example, a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>).","pos":[9,339],"source":"Because the host application gets an <xref:System.Windows.Interop.HwndHost>, the host application cannot convert the object that is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the type it is implemented as by the add-in (for example, a <xref:System.Windows.Controls.UserControl>)."}]},{"content":"By its nature, <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> has certain limitations that affect how host applications can use them.","pos":[23548,23673],"source":"By its nature, <xref:System.Windows.Interop.HwndHost> has certain limitations that affect how host applications can use them."},{"content":"However, WPF extends <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> with several capabilities for add-in scenarios.","pos":[23674,23781],"source":" However, WPF extends <xref:System.Windows.Interop.HwndHost> with several capabilities for add-in scenarios."},{"content":"These benefits and limitations are described below.","pos":[23782,23833]},{"pos":[23882,23901],"content":"WPF Add-In Benefits","linkify":"WPF Add-In Benefits","nodes":[{"content":"WPF Add-In Benefits","pos":[0,19]}]},{"content":"Because WPF add-in user interfaces are displayed from host applications using an internal class that derives from <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>, those user interfaces are constrained by the capabilities of <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> with respect to WPF UI services such as layout, rendering, data binding, styles, templates, and resources.","pos":[23905,24265],"source":"Because WPF add-in user interfaces are displayed from host applications using an internal class that derives from <xref:System.Windows.Interop.HwndHost>, those user interfaces are constrained by the capabilities of <xref:System.Windows.Interop.HwndHost> with respect to WPF UI services such as layout, rendering, data binding, styles, templates, and resources."},{"content":"However, WPF augments its internal <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> subclass with additional capabilities that include the following:","pos":[24266,24405],"source":" However, WPF augments its internal <xref:System.Windows.Interop.HwndHost> subclass with additional capabilities that include the following:"},{"content":"Tabbing between a host application's UI and an add-in's UI.","pos":[24415,24474]},{"content":"Note that the \"add-in is a UI\" programming model requires the add-in-side adapter to override <ph id=\"ph1\">&lt;xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A&gt;</ph> to enable tabbing, whether the add-in is fully trusted or partially trusted.","pos":[24475,24704],"source":" Note that the \"add-in is a UI\" programming model requires the add-in-side adapter to override <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> to enable tabbing, whether the add-in is fully trusted or partially trusted."},{"content":"Honoring accessibility requirements for add-in user interfaces that are displayed from host application user interfaces.","pos":[24714,24834]},{"content":"Enabling WPF applications to run safely in multiple application domain scenarios.","pos":[24844,24925]},{"content":"Preventing illegal access to add-in UI window handles when add-ins run with security isolation (that is, a partial-trust security sandbox).","pos":[24935,25074]},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph> ensures this security:","pos":[25075,25184],"source":" Calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> ensures this security:"},{"pos":[25198,25423],"content":"For the \"add-in returns a UI\" programming model, the only way to pass the window handle for an add-in UI across the isolation boundary is to call <ph id=\"ph1\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph>.","source":"For the \"add-in returns a UI\" programming model, the only way to pass the window handle for an add-in UI across the isolation boundary is to call <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>."},{"pos":[25437,25817],"content":"For the \"add-in is a UI\" programming model, overriding <ph id=\"ph1\">&lt;xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A&gt;</ph> on the add-in-side adapter and calling <ph id=\"ph2\">&lt;xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A&gt;</ph> (as shown in the preceding examples) is required, as is calling the add-in-side adapter's <ph id=\"ph3\">`QueryContract`</ph> implementation from the host-side adapter.","source":"For the \"add-in is a UI\" programming model, overriding <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> on the add-in-side adapter and calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (as shown in the preceding examples) is required, as is calling the add-in-side adapter's `QueryContract` implementation from the host-side adapter."},{"content":"Providing multiple application domain execution protection.","pos":[25827,25886]},{"content":"Due to limitations with application domains, unhandled exceptions that are thrown in add-in application domains cause the entire application to crash, even though the isolation boundary exists.","pos":[25887,26080]},{"content":"However, WPF and the .NET Framework add-in model provide a simple way to work around this problem and improve application stability.","pos":[26081,26213]},{"content":"A WPF add-in that displays a UI creates a <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> for the thread that the application domain runs on, if the host application is a WPF application.","pos":[26214,26396],"source":" A WPF add-in that displays a UI creates a <xref:System.Windows.Threading.Dispatcher> for the thread that the application domain runs on, if the host application is a WPF application."},{"content":"You can detect all unhandled exceptions that occur in the application domain by handling the <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.UnhandledException&gt;</ph> event of the WPF add-in's <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>.","pos":[26397,26621],"source":" You can detect all unhandled exceptions that occur in the application domain by handling the <xref:System.Windows.Threading.Dispatcher.UnhandledException> event of the WPF add-in's <xref:System.Windows.Threading.Dispatcher>."},{"content":"You can get the <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> from the <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A&gt;</ph> property.","pos":[26622,26763],"source":" You can get the <xref:System.Windows.Threading.Dispatcher> from the <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> property."},{"pos":[26815,26837],"content":"WPF Add-In Limitations","linkify":"WPF Add-In Limitations","nodes":[{"content":"WPF Add-In Limitations","pos":[0,22]}]},{"pos":[26841,27110],"content":"Beyond the benefits that WPF adds to the default behaviors supplied by <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>, and window handles, there are also limitations for add-in user interfaces that are displayed from host applications:","source":"Beyond the benefits that WPF adds to the default behaviors supplied by <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>, and window handles, there are also limitations for add-in user interfaces that are displayed from host applications:"},{"content":"Add-in user interfaces displayed from a host application do not respect the host application's clipping behavior.","pos":[27120,27233]},{"pos":[27243,27403],"content":"The concept of <bpt id=\"p1\">*</bpt>airspace<ept id=\"p1\">*</ept> in interoperability scenarios also applies to add-ins (see <bpt id=\"p2\">[</bpt>Technology Regions Overview<ept id=\"p2\">](../advanced/technology-regions-overview.md)</ept>).","source":"The concept of *airspace* in interoperability scenarios also applies to add-ins (see [Technology Regions Overview](../advanced/technology-regions-overview.md))."},{"content":"A host application's UI services, such as resource inheritance, data binding, and commanding, are not automatically available to add-in user interfaces.","pos":[27413,27565]},{"content":"To provide these services to the add-in, you need to update the pipeline.","pos":[27566,27639]},{"pos":[27649,27814],"content":"An add-in UI cannot be rotated, scaled, skewed, or otherwise affected by a transformation (see <bpt id=\"p1\">[</bpt>Transforms Overview<ept id=\"p1\">](../graphics-multimedia/transforms-overview.md)</ept>).","source":"An add-in UI cannot be rotated, scaled, skewed, or otherwise affected by a transformation (see [Transforms Overview](../graphics-multimedia/transforms-overview.md))."},{"content":"Content inside add-in user interfaces that is rendered by drawing operations from the <ph id=\"ph1\">&lt;xref:System.Drawing&gt;</ph> namespace can include alpha blending.","pos":[27824,27969],"source":"Content inside add-in user interfaces that is rendered by drawing operations from the <xref:System.Drawing> namespace can include alpha blending."},{"content":"However, both an add-in UI and the host application UI that contains it must be 100% opaque; in other words, the <ph id=\"ph1\">`Opacity`</ph> property on both must be set to 1.","pos":[27970,28127],"source":" However, both an add-in UI and the host application UI that contains it must be 100% opaque; in other words, the `Opacity` property on both must be set to 1."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Windows.Window.AllowsTransparency%2A&gt;</ph> property of a window in the host application that contains an add-in UI is set to <ph id=\"ph2\">`true`</ph>, the add-in is invisible.","pos":[28137,28309],"source":"If the <xref:System.Windows.Window.AllowsTransparency%2A> property of a window in the host application that contains an add-in UI is set to `true`, the add-in is invisible."},{"content":"This is true even if the add-in UI is 100% opaque (that is, the <ph id=\"ph1\">`Opacity`</ph> property has a value of 1).","pos":[28310,28411],"source":" This is true even if the add-in UI is 100% opaque (that is, the `Opacity` property has a value of 1)."},{"content":"An add-in UI must appear on top of other WPF elements in the same top-level window.","pos":[28421,28504]},{"content":"No portion of an add-in's UI can be rendered using a <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualBrush&gt;</ph>.","pos":[28514,28607],"source":"No portion of an add-in's UI can be rendered using a <xref:System.Windows.Media.VisualBrush>."},{"content":"Instead, the add-in may take a snapshot of the generated UI to create a bitmap that can be passed to the host application using methods defined by the contract.","pos":[28608,28768]},{"pos":[28778,28874],"content":"Media files cannot be played from a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.MediaElement&gt;</ph> in an add-in UI.","source":"Media files cannot be played from a <xref:System.Windows.Controls.MediaElement> in an add-in UI."},{"pos":[28884,29060],"content":"Mouse events generated for the add-in UI are neither received nor raised by the host application, and the <ph id=\"ph1\">`IsMouseOver`</ph> property for host application UI has a value of <ph id=\"ph2\">`false`</ph>.","source":"Mouse events generated for the add-in UI are neither received nor raised by the host application, and the `IsMouseOver` property for host application UI has a value of `false`."},{"pos":[29070,29216],"content":"When focus shifts between controls in an add-in UI, the <ph id=\"ph1\">`GotFocus`</ph> and <ph id=\"ph2\">`LostFocus`</ph> events are neither received nor raised by the host application.","source":"When focus shifts between controls in an add-in UI, the `GotFocus` and `LostFocus` events are neither received nor raised by the host application."},{"content":"The portion of a host application that contains an add-in UI appears white when printed.","pos":[29226,29314]},{"content":"All dispatchers (see <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>) created by the add-in UI must be shut down manually before the owner add-in is unloaded if the host application continues execution.","pos":[29324,29521],"source":"All dispatchers (see <xref:System.Windows.Threading.Dispatcher>) created by the add-in UI must be shut down manually before the owner add-in is unloaded if the host application continues execution."},{"content":"The contract can implement methods that allow the host application to signal the add-in before the add-in is unloaded, thereby allowing the add-in UI to shut down its dispatchers.","pos":[29522,29701]},{"pos":[29711,29860],"content":"If an add-in UI is an <ph id=\"ph1\">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph> or contains an <ph id=\"ph2\">&lt;xref:System.Windows.Controls.InkCanvas&gt;</ph>, you cannot unload the add-in.","source":"If an add-in UI is an <xref:System.Windows.Controls.InkCanvas> or contains an <xref:System.Windows.Controls.InkCanvas>, you cannot unload the add-in."},{"pos":[29911,29935],"content":"Performance Optimization","linkify":"Performance Optimization","nodes":[{"content":"Performance Optimization","pos":[0,24]}]},{"content":"By default, when multiple application domains are used, the various .NET Framework assemblies required by each application are all loaded into that application's domain.","pos":[29939,30108]},{"content":"As a result, the time required for creating new application domains and starting applications in them might affect performance.","pos":[30109,30236]},{"content":"However, the .NET Framework provides a way for you to reduce start times by instructing applications to share assemblies across application domains if they are already loaded.","pos":[30237,30412]},{"content":"You do this by using the <ph id=\"ph1\">&lt;xref:System.LoaderOptimizationAttribute&gt;</ph> attribute, which must be applied to the entry point method (<ph id=\"ph2\">`Main`</ph>).","pos":[30413,30548],"source":" You do this by using the <xref:System.LoaderOptimizationAttribute> attribute, which must be applied to the entry point method (`Main`)."},{"content":"In this case, you must use only code to implement your application definition (see <bpt id=\"p1\">[</bpt>Application Management Overview<ept id=\"p1\">](application-management-overview.md)</ept>).","pos":[30549,30703],"source":" In this case, you must use only code to implement your application definition (see [Application Management Overview](application-management-overview.md))."},{"pos":[30712,30720],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[30768,30860],"content":"<bpt id=\"p1\">[</bpt>Add-ins and Extensibility<ept id=\"p1\">](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</ept>","source":"[Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))"},{"pos":[30863,30926],"content":"<bpt id=\"p1\">[</bpt>Application Domains<ept id=\"p1\">](../../app-domains/application-domains.md)</ept>","source":"[Application Domains](../../app-domains/application-domains.md)"},{"pos":[30929,31052],"content":"<bpt id=\"p1\">[</bpt>.NET Framework Remoting Overview<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))</ept>","source":"[.NET Framework Remoting Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))"},{"pos":[31055,31170],"content":"<bpt id=\"p1\">[</bpt>Making Objects Remotable<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))</ept>","source":"[Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))"},{"pos":[31173,31206],"content":"<bpt id=\"p1\">[</bpt>How-to Topics<ept id=\"p1\">](how-to-topics.md)</ept>","source":"[How-to Topics](how-to-topics.md)"}]}