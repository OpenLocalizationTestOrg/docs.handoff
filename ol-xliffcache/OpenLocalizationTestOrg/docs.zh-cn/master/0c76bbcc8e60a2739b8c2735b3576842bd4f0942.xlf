<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0c76bbcc8e60a2739b8c2735b3576842bd4f0942</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\tutorials\inheritance.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_hi-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fdcdfe36bed12258048d2b0933ad97bde47374de</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ecdc468b66a7d3713633a6cf7ef7b92c6309181a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Inheritance in C#</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn to use inheritance in C# libraries and applications.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>inheritance (C#), base classes, derived classes, abstract base classes</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Inheritance in C# and .NET</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Introduction</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This tutorial introduces you to inheritance in C#.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that you've installed .NET Core.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For installation instructions, see <bpt id="p1">[</bpt>.NET Core installation guide<ept id="p1">](https://www.microsoft.com/net/core)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You also need a code editor.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This tutorial uses <bpt id="p1">[</bpt>Visual Studio Code<ept id="p1">](https://code.visualstudio.com)</ept>, although you can use any code editor of your choice.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Running the examples</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>To create and run the examples in this tutorial, you use the <bpt id="p1">[</bpt>dotnet<ept id="p1">](../../core/tools/dotnet.md)</ept> utility from the command line.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Follow these steps for each example:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Create a directory to store the example.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Enter the <bpt id="p1">[</bpt>dotnet new console<ept id="p1">](../../core/tools/dotnet-new.md)</ept> command at a command prompt to create a new .NET Core project.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Copy and paste the code from the example into your code editor.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Enter the <bpt id="p1">[</bpt>dotnet restore<ept id="p1">](../../core/tools/dotnet-restore.md)</ept> command from the command line to load or restore the project's dependencies.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Enter the <bpt id="p1">[</bpt>dotnet run<ept id="p1">](../../core/tools/dotnet-run.md)</ept> command to compile and execute the example.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Background: What is inheritance?</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Inheritance<ept id="p1">*</ept> is one of the fundamental attributes of object-oriented programming.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The class whose members are inherited is called the <bpt id="p1">*</bpt>base class<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The class that inherits the members of the base class is called the <bpt id="p1">*</bpt>derived class<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>C# and .NET support <bpt id="p1">*</bpt>single inheritance<ept id="p1">*</ept> only.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>That is, a class can only inherit from a single class.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In other words, type <ph id="ph1">`D`</ph> can inherit from type <ph id="ph2">`C`</ph>, which inherits from type <ph id="ph3">`B`</ph>, which inherits from the base class type <ph id="ph4">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Because inheritance is transitive, the members of type <ph id="ph1">`A`</ph> are available to type <ph id="ph2">`D`</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Not all members of a base class are inherited by derived classes.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following members are not inherited:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Static constructors<ept id="p1">](../programming-guide/classes-and-structs/static-constructors.md)</ept>, which initialize the static data of a class.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Instance constructors<ept id="p1">](../programming-guide/classes-and-structs/constructors.md)</ept>, which you call to create a new instance of the class.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Each class must define its own constructors.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Finalizers<ept id="p1">](../programming-guide/classes-and-structs/destructors.md)</ept>, which are called by the runtime's garbage collector to destroy instances of a class.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A member's accessibility affects its visibility for derived classes as follows:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Private<ept id="p1">](../language-reference/keywords/private.md)</ept> members are visible only in derived classes that are nested in their base class.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Otherwise, they are not visible in derived classes.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`A.B`</ph> is a nested class that derives from <ph id="ph2">`A`</ph>, and <ph id="ph3">`C`</ph> derives from <ph id="ph4">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The private <ph id="ph1">`A.value`</ph> field is visible in A.B.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>However, if you remove the comments from the <ph id="ph1">`C.GetValue`</ph> method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Protected<ept id="p1">](../language-reference/keywords/protected.md)</ept> members are visible only in derived classes.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Internal<ept id="p1">](../language-reference/keywords/protected.md)</ept> members are visible only in derived classes that are located in the same assembly as the base class.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>They are not visible in derived classes located in a different assembly from the base class.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>[Public] (../language-reference/keywords/protected.md) members are visible in derived classes and are part of the derived class' public interface.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Public inherited members can be called just as if they were defined in the derived class.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In the following example, class <ph id="ph1">`A`</ph> defines a method named <ph id="ph2">`Method1`</ph>, and class <ph id="ph3">`B`</ph> inherits from class <ph id="ph4">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The example then calls <ph id="ph1">`Method1`</ph> as if it were an instance method on <ph id="ph2">`B`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Derived classes can also <bpt id="p1">*</bpt>override<ept id="p1">*</ept> inherited members by providing an alternate implementation.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In order to be able to override a member, the member in the base class must be marked with the <bpt id="p1">[</bpt>virtual<ept id="p1">](../language-reference/keywords/virtual.md)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>By default, base class members are not marked as <ph id="ph1">`virtual`</ph> and cannot be overridden.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<ph id="ph1">&lt;member&gt;</ph> cannot override inherited member <ph id="ph2">&lt;member&gt;</ph> because it is not marked virtual, abstract, or override.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In some cases, a derived class <bpt id="p1">*</bpt>must<ept id="p1">*</ept> override the base class implementation.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Base class members marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](../language-reference/keywords/abstract.md)</ept> keyword require that derived classes override them.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Attempting to compile the following example generates compiler error CS0534, "<ph id="ph1">&lt;class&gt;</ph> does not implement inherited abstract member <ph id="ph2">&lt;member&gt;</ph>', because class <ph id="ph3">`B`</ph> provides no implementation for <ph id="ph4">`A.Method1`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Inheritance applies only to classes and interfaces.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Other type categories (structs, delegates, and enums) do not support inheritance.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Implicit inheritance</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <ph id="ph1">@System.Object</ph> or a type derived from it.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This ensures that common functionality is available to any type.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To see what implicit inheritance means, let's define a new class, <ph id="ph1">`SimpleClass`</ph>, that is simply an empty class definition:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the <ph id="ph1">`SimpleClass`</ph> type.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Although we haven't defined any members in our <ph id="ph1">`SimpleClass`</ph> class, output from the example indicates that it actually has nine members.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>One of these is a parameterless (or default) constructor that is automatically supplied for the <ph id="ph1">`SimpleClass`</ph> type by the C# compiler.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The eight seven are members of <ph id="ph1">@System.Object</ph>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Implicit inheritance from the <ph id="ph1">@System.Object</ph> class makes these methods available to the <ph id="ph2">`SimpleClass`</ph> class:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The public <ph id="ph1">`ToString`</ph> method, which converts a <ph id="ph2">`SimpleClass`</ph> object to its string representation, the fully qualified type name.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`ToString`</ph> method returns the string "SimpleClass".</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Three methods that test for equality of two objects: the public instance <ph id="ph1">`Equals(Object)`</ph> method, the public static <ph id="ph2">`Equals(Object, Object)`</ph> method, and the public static <ph id="ph3">`ReferenceEquals(Object, Object)`</ph> method.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The public <ph id="ph1">`GetHashCode`</ph> method, which computes a value that allows an instance of the type to be used in hashed collections.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The public <ph id="ph1">`GetType`</ph> method, which returns a <ph id="ph2">@System.Type</ph> object that represents the <ph id="ph3">`SimpleClass`</ph> type.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The protected <ph id="ph1">@System.Object.Finalize</ph> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The protected <ph id="ph1">@System.Object.MemberwiseClone</ph> method, which creates a shallow clone of the current object.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Because of implicit inheritance, we can call any inherited member from a <ph id="ph1">`SimpleClass`</ph> object just as if it was actually a member defined in the <ph id="ph2">`SimpleClass`</ph> class.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For instance, the following example calls the <ph id="ph1">`SimpleClass.ToString`</ph> method, which <ph id="ph2">`SimpleClass`</ph> inherits from <ph id="ph3">@System.Object</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Each base type makes a different set of members available through inheritance to implicitly derived types.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Type category</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Implicitly inherits from...</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>class</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>struct</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.ValueType</ph>, <ph id="ph2">@System.Object</ph></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>enum</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.Enum</ph>, System.ValueType, <ph id="ph2">@System.Object</ph></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>delegate</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">@System.MulticastDelegate</ph>, <ph id="ph2">@System.Delegate</ph>, <ph id="ph3">@System.Object</ph></source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Inheritance and an "is a" relationship</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`Publication`</ph> class represents a publication of any kind, and the <ph id="ph2">`Book`</ph> and <ph id="ph3">`Magazine`</ph> classes represent specific types of publications.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>A class or struct can implement one more interfaces.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`Automobile`</ph> is a class that has three unique read-only properties: <ph id="ph2">`Moke`</ph>, the manufacturer of the automobile; <ph id="ph3">`Model`</ph>, the kind of automobile; and <ph id="ph4">`Year`</ph>, its year of manufacture.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Our <ph id="ph1">`Automobile`</ph> class also has a constructor whose arguments are assigned to the property values, and it overrides the <ph id="ph2">@System.Object.ToString</ph> method to produce a string that uniquely identifies the <ph id="ph3">`Automobile`</ph> instance rather than the <ph id="ph4">`Automobile`</ph> class.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In this case, we should not rely on inheritance to represent specific car makes and models.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For example, we do not need to define a <ph id="ph1">`Packard`</ph> type to represent automobiles manufactured by the Packard Motor Car Company.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Instead, we can represent them by creating an <ph id="ph1">`Automobile`</ph> object with the appropriate values passed to its class constructor, as the following example does.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Designing the base class and derived classes</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Let's look at the process of designing a base class and its derived classes.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>In this section, we'll define a base class, <ph id="ph1">`Publication`</ph>, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a <ph id="ph2">`Book`</ph> class that derives from <ph id="ph3">`Publication`</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>We could easily extend the example to define other derived classes, such as <ph id="ph1">`Magazine`</ph>, <ph id="ph2">`Journal`</ph>, <ph id="ph3">`Newspaper`</ph>, and <ph id="ph4">`Article`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The base <ph id="ph1">`Publication`</ph> class</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>In designing our <ph id="ph1">`Publication`</ph> class, we need to make several design decisions:</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>What members to include in our base <ph id="ph1">`Publication`</ph> class, and whether the <ph id="ph2">`Publication`</ph> members provide method implementations, or whether <ph id="ph3">`Publication`</ph> is an abstract base class that serves as a template for its derived classes.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In this case, the <ph id="ph1">`Publication`</ph> class will provide method implementations.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Designing abstract base classes amd their derived classes<ept id="p1">](#abstract)</ept> section contains an example that uses an abstract base class to define the methods that derived classes must override.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Derived classes are free to provide any implementation that is suitable for the derived type.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Therefore, we should add members to <ph id="ph1">`Publication`</ph> if their code is likely to be shared by some or most specialized <ph id="ph2">`Publication`</ph> types.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The need to maintain duplicated code in multiple locations is a potential source of bugs.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the <ph id="ph1">`Publication`</ph> class only the data and functionality that is common to all or to most publications.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Derived classes then implement members that are unique to the particular kinds of publication that they represent.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>How far to extend our class hierarchy.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`Publication`</ph> could be a base class of <ph id="ph2">`Periodical`</ph>, which in turn is a base class of <ph id="ph3">`Magazine`</ph>, <ph id="ph4">`Journal`</ph> and <ph id="ph5">`Newspaper`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For our example, we'll use the simple hierarchy of a <ph id="ph1">`Publication`</ph> class and a single derived classes, <ph id="ph2">`Book`</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>We could easily extend the example to create a number of additional   classes that derive from <ph id="ph1">`Publication`</ph>, such as <ph id="ph2">`Magazine`</ph> and <ph id="ph3">`Article`</ph>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Whether it makes sense to instantiate the base class.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>If it does not, we should apply the <bpt id="p1">[</bpt>abstract<ept id="p1">](../language-reference/keywords/abstract.md)</ept> keyword to the class.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If an attempt is made to instantiate a class marked with the <ph id="ph1">`abstract`</ph> keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>If an attempt is made to instantiate the class by using reflection, the reflection method throws a <ph id="ph1">@System.MemberAccessException</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Otherwise, our <ph id="ph1">`Publication`</ph> class can be instantiated by calling its class constructor.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>By default, a base class can be instantiated by calling its class constructor.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Note that we do not have to explicitly define a class constructor.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For our example, we'll mark the <ph id="ph1">`Publication`</ph> class as <bpt id="p1">[</bpt>abstract<ept id="p1">](../language-reference/keywords/abstract.md)</ept> so that it cannot be instantiated.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>We have to use the <bpt id="p1">[</bpt>virtual<ept id="p1">](../language-reference/keywords/virtual.md)</ept> keyword to allow derived classes to override a base class method.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>By default, methods defined in the base class are <bpt id="p1">*</bpt>not<ept id="p1">*</ept> overridable.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>By default, any class can serve as a base class.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>We can apply the <bpt id="p1">[</bpt>sealed<ept id="p1">](../language-reference/keywords/sealed.md)</ept> keyword to indicate that a class cannot serve as a base class for any additional classes.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <ph id="ph1">&lt;typeName&gt;</ph>".</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>For our example, we'll mark our derived class as <ph id="ph1">`sealed`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following example shows the source code for the <ph id="ph1">`Publication`</ph> class, as well as a <ph id="ph2">`PublicationType`</ph> enumeration that is returned by the <ph id="ph3">`Publication.PublicationType`</ph> property.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>In addition to the members that it inherits from <ph id="ph1">@System.Object</ph>, the <ph id="ph2">`Publication`</ph> class defines the following unique members and member overrides:</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>A constructor</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`Publication`</ph> class is <ph id="ph2">`abstract`</ph>, it cannot be instantiated directly from code like the following:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>However, its instance constructor can be called directly from derived class constructors, as the source code for the <ph id="ph1">`Book`</ph> class shows.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Two publication-related properties</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Title`</ph> is a read-only <ph id="ph2">@System.String</ph> property whose value is supplied by calling the <ph id="ph3">`Publication`</ph> constructor, which stores the value in a private field named <ph id="ph4">`pubTitle`</ph>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Pages`</ph> is a read-write <ph id="ph2">@System.Int32</ph> property that indicates how many total pages the publication has.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The value is stored in a private field named <ph id="ph1">`totalPages`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>It must be a positive number or an <ph id="ph1">@System.ArgumentOutOfRangeException</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Publisher-related members</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Two read-only properties, <ph id="ph1">`Publisher`</ph> and <ph id="ph2">`Type`</ph>, return the value of the private <ph id="ph3">`pubName`</ph> and <ph id="ph4">`pubType`</ph> fields.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The values are originally supplied by the call to the <ph id="ph1">`Publication`</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Publishing-related members</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Two methods, <ph id="ph1">`Publish`</ph> and <ph id="ph2">`GetPublicationDate`</ph>, set and return the publication date.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Publish`</ph> method sets a private  <ph id="ph2">`published`</ph> flag to <ph id="ph3">`true`</ph> when it is called and assigns the date passed to it as an argument to the private <ph id="ph4">`datePublished`</ph> field.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GetPublicationDate`</ph> method returns the string "NYP" if the <ph id="ph2">`published`</ph> flag is <ph id="ph3">`false`</ph>, and the value of the <ph id="ph4">`datePublished`</ph> field if it is <ph id="ph5">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Copyright-related members</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Copyright`</ph> method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the private <ph id="ph2">`copyrName`</ph> and <ph id="ph3">`copyrDate`</ph> fields.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The values can be retrieved from the <ph id="ph1">`CopyrightName`</ph> and <ph id="ph2">`CopyrightDate`</ph> properties.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>An override of the <ph id="ph1">`ToString`</ph> method</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>If a type does not override the <ph id="ph1">@System.Object.ToString</ph> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Publication`</ph> class overrides <ph id="ph2">@System.Object.ToString</ph> to return the value of the <ph id="ph3">`Title`</ph> property.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The following figure illustrates the relationship between our base <ph id="ph1">`Publication`</ph> class and its implicitly inherited <ph id="ph2">@System.Object</ph> class.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The Object and Publication classes</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Book`</ph> class</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Book`</ph> class represents a book as a specialized type of publication.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The following example shows the source code for the <ph id="ph1">`Book`</ph> class.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>In addition to the members that it inherits from <ph id="ph1">`Publication`</ph>, the <ph id="ph2">`Book`</ph> class defines the following unique members and member overrides:</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Two constructors</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The two <ph id="ph1">`Book`</ph> constructors share three common parameters.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Two, <bpt id="p1">*</bpt>title<ept id="p1">*</ept> and <bpt id="p2">*</bpt>publisher<ept id="p2">*</ept>, correspond to parameters of the <ph id="ph1">`Publication`</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The third is <bpt id="p1">*</bpt>author<ept id="p1">*</ept>, which is stored to a private <ph id="ph1">`authorName`</ph> field.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>One constructor includes an <bpt id="p1">*</bpt>isbn<ept id="p1">*</ept> parameter, which is stored to the private <ph id="ph1">`id`</ph> field.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The first constructor uses the <bpt id="p1">[</bpt>this<ept id="p1">](../language-reference/keywords/this.md)</ept> keyword to call the other constructor.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>This is a common pattern in defining constructors; constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The second constructor uses the <bpt id="p1">[</bpt>base<ept id="p1">](../language-reference/keywords/base.md)</ept> keyword to pass the title and publisher name to the base class constructor.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>A read-only <ph id="ph1">`ISBN`</ph> property, which returns the <ph id="ph2">`Book`</ph> object's International Standard Book Number, a unique 10- or 13-digit number.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The ISBN is supplied as an argument to one of the <ph id="ph1">`Book`</ph> constructors and is stored in the private <ph id="ph2">`id`</ph> field.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A read-only <ph id="ph1">`Author`</ph> property.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The author name is supplied as an argument to both <ph id="ph1">`Book`</ph> constructors and is stored in the private <ph id="ph2">`authorName`</ph> field.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Two read-only price-related properties, <ph id="ph1">`Price`</ph> and <ph id="ph2">`Currency`</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Their values are provided as arguments in a <ph id="ph1">`SetPrice`</ph> method call.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The price is stored in a private field, <ph id="ph1">`bookPrice`</ph>.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Currency`</ph> property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private <ph id="ph2">`ISOCurrencySymbol`</ph> field.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>ISO currency symbols can be retrieved from the <ph id="ph1">@System.Globalization.RegionInfo.ISOCurrencySymbol</ph> property.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`SetPrice`</ph> method, which sets the values of the <ph id="ph2">`bookPrice`</ph> and <ph id="ph3">`ISOCurrencySymbol`</ph> fields.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>These are the values returned by the <ph id="ph1">`Price`</ph> and <ph id="ph2">`Currency`</ph> properties.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Overrides to the <ph id="ph1">`ToString`</ph> method (inherited from <ph id="ph2">`Publication`</ph>) and the <ph id="ph3">@System.Object.Equals</ph>(System.Object) and <ph id="ph4">@System.Object.GetHashCode</ph> methods (inherited from <ph id="ph5">@System.Object</ph>).</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Unless it is overridden, the <ph id="ph1">@System.Object.Equals</ph>(System.Object) method tests for reference equality.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>That is, two object variables are considered to be equal if they refer to the same object.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>In the case of the <ph id="ph1">`Book`</ph> class, on the other hand, two <ph id="ph2">`Book`</ph> objects should be equal if they have the same ISBN.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>When you override the <ph id="ph1">@System.Object.Equals</ph>(System.Object) method, you must also override the <ph id="ph2">@System.Object.GetHashCode</ph> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The hash code should return a value that's consistent with the test for equality.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Since we've overridden <ph id="ph1">@System.Object.Equals</ph>(System.Object) to return <ph id="ph2">`true`</ph> if the ISBN properties of two <ph id="ph3">`Book`</ph> objects are equal, we return the hash code computed by calling the <ph id="ph4">@System.String.GetHashCode</ph> method of the string returned by the <ph id="ph5">`ISBN`</ph> property.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The following figure illustrates the relationship between the <ph id="ph1">`Book`</ph> class and <ph id="ph2">`Publication`</ph>, its base class.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Publication and Book classes</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>We can now instantiate a <ph id="ph1">`Book`</ph> object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type <ph id="ph2">`Publication`</ph> or of type <ph id="ph3">`Book`</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="abstract"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Designing abstract base classes and their derived classes</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>In many cases, however, the base class is not expected to provide an implementation.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Instead, the base class is an <bpt id="p1">*</bpt>abstract class<ept id="p1">*</ept>; it serves as a template that defines the members that each derived class must implement.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The way in which these properties are calculated, however, depends completely on the specific shape.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The following example defines an abstract base class named <ph id="ph1">`Shape`</ph> that defines two properties: <ph id="ph2">`Area`</ph> and <ph id="ph3">`Perimeter`</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Note that, in addition to marking the class with the <bpt id="p1">[</bpt>abstract<ept id="p1">](../language-reference/keywords/abstract.md)</ept> keyword, each instance member is also marked with the <bpt id="p2">[</bpt>abstract<ept id="p2">](../language-reference/keywords/abstract.md)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>In this case, <ph id="ph1">`Shape`</ph> also overrides the <ph id="ph2">@System.Object.ToString</ph> method to return the name of the type, rather than its fully qualified name.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>And it defines two static members, <ph id="ph1">`GetArea`</ph> and <ph id="ph2">`GetPerimeter`</ph>, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>We can then derive some classes from <ph id="ph1">`Shape`</ph> that represent specific shapes.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The following example defines three classes, <ph id="ph1">`Triangle`</ph>, <ph id="ph2">`Rectangle`</ph>, and <ph id="ph3">`Circle`</ph>.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Each uses a formula unique for that particular shape to compute the area and perimeter.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Some of the derived classes also define properties, such as <ph id="ph1">`Rectangle.Diagonal`</ph> and <ph id="ph2">`Circle.Diameter`</ph>, that are unique to the shape that they represent.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The following example uses objects derived from <ph id="ph1">`Shape`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>It instantiates an array of objects derived from <ph id="ph1">`Shape`</ph> and calls the static methods of the <ph id="ph2">`Shape`</ph> class, which wraps return <ph id="ph3">`Shape`</ph> property values.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Note that the runtime retrieves values from the overridden properties of the derived types.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The example also casts each <ph id="ph1">`Shape`</ph> object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of <ph id="ph2">`Shape`</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Inheritance<ept id="p2">](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes and objects<ept id="p1">](../tour-of-csharp/classes-and-objects.md)</ept></source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source><ph id="ph1">
</ph><bpt id="p1">[</bpt>Inheritance (C# Programming Guide)<ept id="p1">](../programming-guide/classes-and-structs/inheritance.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>