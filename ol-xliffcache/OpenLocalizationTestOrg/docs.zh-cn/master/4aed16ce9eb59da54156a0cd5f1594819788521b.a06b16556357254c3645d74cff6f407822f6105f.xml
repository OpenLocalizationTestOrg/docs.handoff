{"content":"---\ntitle: \"Generic Procedures in Visual Basic\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generic methods [Visual Basic], type inference\"\n  - \"generics [Visual Basic], type inference\"\n  - \"procedures [Visual Basic], generic\"\n  - \"generic procedures\"\n  - \"type inference, generics\"\n  - \"generic methods [Visual Basic]\"\n  - \"type inference\"\n  - \"generics [Visual Basic], procedures\"\n  - \"generic procedures [Visual Basic], type inference\"\nms.assetid: 95577b28-137f-4d5c-a149-919c828600e5\n---\n# Generic Procedures in Visual Basic\nA *generic procedure*, also called a *generic method*, is a procedure defined with at least one type parameter. This allows the calling code to tailor the data types to its requirements each time it calls the procedure.  \n  \n A procedure is not generic simply by virtue of being defined inside a generic class or a generic structure. To be generic, the procedure must take at least one type parameter, in addition to any normal parameters it might take. A generic class or structure can contain nongeneric procedures, and a nongeneric class, structure, or module can contain generic procedures.  \n  \n A generic procedure can use its type parameters in its normal parameter list, in its return type if it has one, and in its procedure code.  \n  \n## Type Inference  \n You can call a generic procedure without supplying any type arguments at all. If you call it this way, the compiler attempts to determine the appropriate data types to pass to the procedure's type arguments. This is called *type inference*. The following code shows a call in which the compiler infers that it should pass type `String` to the type parameter `t`.  \n  \n [!code-vb[VbVbalrDataTypes#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#15)]  \n  \n If the compiler cannot infer the type arguments from the context of your call, it reports an error. One possible cause of such an error is an array rank mismatch. For example, suppose you define a normal parameter as an array of a type parameter. If you call the generic procedure supplying an array of a different rank (number of dimensions), the mismatch causes type inference to fail. The following code shows a call in which a two-dimensional array is passed to a procedure that expects a one-dimensional array.  \n  \n```vb  \nPublic Sub demoSub(Of t)(ByVal arg() As t)\nEnd Sub\n\nPublic Sub callDemoSub()\n    Dim twoDimensions(,) As Integer\n    demoSub(twoDimensions)\nEnd Sub\n```\n  \n You can invoke type inference only by omitting all the type arguments. If you supply one type argument, you must supply them all.  \n  \n Type inference is supported only for generic procedures. You cannot invoke type inference on generic classes, structures, interfaces, or delegates.  \n  \n## Example  \n  \n### Description  \n The following example defines a generic `Function` procedure to find a particular element in an array. It defines one type parameter and uses it to construct the two parameters in the parameter list.  \n  \n### Code  \n [!code-vb[VbVbalrDataTypes#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#14)]  \n  \n### Comments  \n The preceding example requires the ability to compare `searchValue` against each element of `searchArray`. To guarantee this ability, it constrains the type parameter `T` to implement the <xref:System.IComparable%601> interface. The code uses the <xref:System.IComparable%601.CompareTo%2A> method instead of the `=` operator, because there is no guarantee that a type argument supplied for `T` supports the `=` operator.  \n  \n You can test the `findElement` procedure with the following code.  \n  \n [!code-vb[VbVbalrDataTypes#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#13)]  \n  \n The preceding calls to `MsgBox` display \"0\", \"1\", and \"-1\" respectively.  \n  \n## See also\n\n- [Generic Types in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-types.md)\n- [How to: Define a Class That Can Provide Identical Functionality on Different Data Types](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)\n- [How to: Use a Generic Class](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)\n- [Procedures](../../../../visual-basic/programming-guide/language-features/procedures/index.md)\n- [Procedure Parameters and Arguments](../../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)\n- [Type List](../../../../visual-basic/language-reference/statements/type-list.md)\n- [Parameter List](../../../../visual-basic/language-reference/statements/parameter-list.md)\n","nodes":[{"pos":[4,490],"embed":true,"restype":"x-metadata","content":"title: \"Generic Procedures in Visual Basic\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generic methods [Visual Basic], type inference\"\n  - \"generics [Visual Basic], type inference\"\n  - \"procedures [Visual Basic], generic\"\n  - \"generic procedures\"\n  - \"type inference, generics\"\n  - \"generic methods [Visual Basic]\"\n  - \"type inference\"\n  - \"generics [Visual Basic], procedures\"\n  - \"generic procedures [Visual Basic], type inference\"\nms.assetid: 95577b28-137f-4d5c-a149-919c828600e5","nodes":[{"content":"Generic Procedures in Visual Basic","nodes":[{"pos":[0,34],"content":"Generic Procedures in Visual Basic","nodes":[{"content":"Generic Procedures in Visual Basic","pos":[0,34]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[497,531],"content":"Generic Procedures in Visual Basic","linkify":"Generic Procedures in Visual Basic","nodes":[{"content":"Generic Procedures in Visual Basic","pos":[0,34]}]},{"content":"A <bpt id=\"p1\">*</bpt>generic procedure<ept id=\"p1\">*</ept>, also called a <bpt id=\"p2\">*</bpt>generic method<ept id=\"p2\">*</ept>, is a procedure defined with at least one type parameter.","pos":[532,643],"source":"A *generic procedure*, also called a *generic method*, is a procedure defined with at least one type parameter."},{"content":"This allows the calling code to tailor the data types to its requirements each time it calls the procedure.","pos":[644,751]},{"content":"A procedure is not generic simply by virtue of being defined inside a generic class or a generic structure.","pos":[758,865]},{"content":"To be generic, the procedure must take at least one type parameter, in addition to any normal parameters it might take.","pos":[866,985]},{"content":"A generic class or structure can contain nongeneric procedures, and a nongeneric class, structure, or module can contain generic procedures.","pos":[986,1126]},{"content":"A generic procedure can use its type parameters in its normal parameter list, in its return type if it has one, and in its procedure code.","pos":[1133,1271]},{"pos":[1280,1294],"content":"Type Inference","linkify":"Type Inference","nodes":[{"content":"Type Inference","pos":[0,14]}]},{"content":"You can call a generic procedure without supplying any type arguments at all.","pos":[1298,1375]},{"content":"If you call it this way, the compiler attempts to determine the appropriate data types to pass to the procedure's type arguments.","pos":[1376,1505]},{"content":"This is called <bpt id=\"p1\">*</bpt>type inference<ept id=\"p1\">*</ept>.","pos":[1506,1538],"source":" This is called *type inference*."},{"content":"The following code shows a call in which the compiler infers that it should pass type <ph id=\"ph1\">`String`</ph> to the type parameter <ph id=\"ph2\">`t`</ph>.","pos":[1539,1660],"source":" The following code shows a call in which the compiler infers that it should pass type `String` to the type parameter `t`."},{"content":"If the compiler cannot infer the type arguments from the context of your call, it reports an error.","pos":[1791,1890]},{"content":"One possible cause of such an error is an array rank mismatch.","pos":[1891,1953]},{"content":"For example, suppose you define a normal parameter as an array of a type parameter.","pos":[1954,2037]},{"content":"If you call the generic procedure supplying an array of a different rank (number of dimensions), the mismatch causes type inference to fail.","pos":[2038,2178]},{"content":"The following code shows a call in which a two-dimensional array is passed to a procedure that expects a one-dimensional array.","pos":[2179,2306]},{"content":"You can invoke type inference only by omitting all the type arguments.","pos":[2476,2546]},{"content":"If you supply one type argument, you must supply them all.","pos":[2547,2605]},{"content":"Type inference is supported only for generic procedures.","pos":[2612,2668]},{"content":"You cannot invoke type inference on generic classes, structures, interfaces, or delegates.","pos":[2669,2759]},{"pos":[2768,2775],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2785,2796],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"content":"The following example defines a generic <ph id=\"ph1\">`Function`</ph> procedure to find a particular element in an array.","pos":[2800,2902],"source":"The following example defines a generic `Function` procedure to find a particular element in an array."},{"content":"It defines one type parameter and uses it to construct the two parameters in the parameter list.","pos":[2903,2999]},{"pos":[3009,3013],"content":"Code","linkify":"Code","nodes":[{"content":"Code","pos":[0,4]}]},{"pos":[3144,3152],"content":"Comments","linkify":"Comments","nodes":[{"content":"Comments","pos":[0,8]}]},{"content":"The preceding example requires the ability to compare <ph id=\"ph1\">`searchValue`</ph> against each element of <ph id=\"ph2\">`searchArray`</ph>.","pos":[3156,3262],"source":"The preceding example requires the ability to compare `searchValue` against each element of `searchArray`."},{"content":"To guarantee this ability, it constrains the type parameter <ph id=\"ph1\">`T`</ph> to implement the <ph id=\"ph2\">&lt;xref:System.IComparable%601&gt;</ph> interface.","pos":[3263,3384],"source":" To guarantee this ability, it constrains the type parameter `T` to implement the <xref:System.IComparable%601> interface."},{"content":"The code uses the <ph id=\"ph1\">&lt;xref:System.IComparable%601.CompareTo%2A&gt;</ph> method instead of the <ph id=\"ph2\">`=`</ph> operator, because there is no guarantee that a type argument supplied for <ph id=\"ph3\">`T`</ph> supports the <ph id=\"ph4\">`=`</ph> operator.","pos":[3385,3576],"source":" The code uses the <xref:System.IComparable%601.CompareTo%2A> method instead of the `=` operator, because there is no guarantee that a type argument supplied for `T` supports the `=` operator."},{"pos":[3583,3648],"content":"You can test the <ph id=\"ph1\">`findElement`</ph> procedure with the following code.","source":"You can test the `findElement` procedure with the following code."},{"pos":[3779,3851],"content":"The preceding calls to <ph id=\"ph1\">`MsgBox`</ph> display \"0\", \"1\", and \"-1\" respectively.","source":"The preceding calls to `MsgBox` display \"0\", \"1\", and \"-1\" respectively."},{"pos":[3860,3868],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3872,3993],"content":"<bpt id=\"p1\">[</bpt>Generic Types in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/generic-types.md)</ept>","source":"[Generic Types in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-types.md)"},{"pos":[3996,4224],"content":"<bpt id=\"p1\">[</bpt>How to: Define a Class That Can Provide Identical Functionality on Different Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)</ept>","source":"[How to: Define a Class That Can Provide Identical Functionality on Different Data Types](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)"},{"pos":[4227,4359],"content":"<bpt id=\"p1\">[</bpt>How to: Use a Generic Class<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)</ept>","source":"[How to: Use a Generic Class](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)"},{"pos":[4362,4456],"content":"<bpt id=\"p1\">[</bpt>Procedures<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/procedures/index.md)</ept>","source":"[Procedures](../../../../visual-basic/programming-guide/language-features/procedures/index.md)"},{"pos":[4459,4606],"content":"<bpt id=\"p1\">[</bpt>Procedure Parameters and Arguments<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)</ept>","source":"[Procedure Parameters and Arguments](../../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)"},{"pos":[4609,4689],"content":"<bpt id=\"p1\">[</bpt>Type List<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/type-list.md)</ept>","source":"[Type List](../../../../visual-basic/language-reference/statements/type-list.md)"},{"pos":[4692,4782],"content":"<bpt id=\"p1\">[</bpt>Parameter List<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/parameter-list.md)</ept>","source":"[Parameter List](../../../../visual-basic/language-reference/statements/parameter-list.md)"}]}