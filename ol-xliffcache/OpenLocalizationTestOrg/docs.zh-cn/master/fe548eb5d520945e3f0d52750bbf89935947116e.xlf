<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fe548eb5d520945e3f0d52750bbf89935947116e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\classes-and-structs\objects.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6af9e621c4eb6e671f76c7054bc4ba875e79a3d6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">587d0bea90f4c0fbd755624465bb11c711959665</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Objects (C# Programming Guide) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Objects (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A class or struct definition is like a blueprint that specifies what the type can do.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>An object is basically a block of memory that has been allocated and configured according to the blueprint.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A program may create many objects of the same class.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Client code is the code that uses these variables to call the methods and access the public properties of the object.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Static types behave differently than what is described here.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Static Classes and Static Class Members<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Struct Instances vs. Class Instances</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This point is discussed in more detail later in this topic.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Instances of classes are created by using the <bpt id="p1">[</bpt>new operator<ept id="p1">](../../../csharp/language-reference/keywords/new-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`Person`</ph> is the type and <ph id="ph2">`person1`</ph> and <ph id="ph3">`person 2`</ph> are instances, or objects, of that type.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideStatements#30<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_1.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Because structs are value types, a variable of a struct object holds a copy of the entire object.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Instances of structs can also be created by using the <ph id="ph1">`new`</ph> operator, but this is not required, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideStatements#31<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_2.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The memory for both <ph id="ph1">`p1`</ph> and <ph id="ph2">`p2`</ph> is allocated on the thread stack.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That memory is reclaimed along with the type or method in which it is declared.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This is one reason why structs are copied on assignment.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It is not possible to deterministically destroy a class object like you can in C++.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information about garbage collection in the <ph id="ph1">[!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph>, see <bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](../../../standard/garbage-collection/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Object Identity vs. Value Equality</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To determine whether two class instances refer to the same location in memory (which means that they have the same <bpt id="p1">*</bpt>identity<ept id="p1">*</ept>), use the static <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>To determine whether the instance fields in two struct instances have the same values, use the <ph id="ph1">&lt;xref:System.ValueType.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because all structs implicitly inherit from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>, you call the method directly on your object as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-cs</bpt><bpt id="p2">[</bpt>csProgGuideStatements#32<ept id="p2">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_3.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph> implementation of <ph id="ph2">`Equals`</ph> uses reflection because it must be able to determine what the fields are in any struct.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>When creating your own structs, override the <ph id="ph1">`Equals`</ph> method to provide an efficient equality algorithm that is specific to your type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To determine whether the values of the fields in two class instances are equal, you might be able to use the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method or the <bpt id="p1">[</bpt>== operator<ept id="p1">](../../../csharp/language-reference/operators/equality-comparison-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The class might also implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface or the <ph id="ph2">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Both interfaces provide methods that can be used to test value equality.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When designing your own classes that override <ph id="ph1">`Equals`</ph>, make sure to follow the guidelines stated in <bpt id="p1">[</bpt>How to: Define Value Equality for a Type<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md)</ept> and <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Related Sections</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/classes.md)</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Structs<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/structs.md)</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Constructors<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/constructors.md)</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Finalizers<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/destructors.md)</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Events<ept id="p1">](../../../csharp/programming-guide/events/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>object<ept id="p1">](../../../csharp/language-reference/keywords/object.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Inheritance<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>class<ept id="p1">](../../../csharp/language-reference/keywords/class.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>struct<ept id="p1">](../../../csharp/language-reference/keywords/struct.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>new Operator<ept id="p1">](../../../csharp/language-reference/keywords/new-operator.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Common Type System<ept id="p1">](../../../standard/base-types/common-type-system.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>