{"content":"---\ntitle: \"Thread-Safe Collections\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"thread-safe collections, overview\"\nms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Thread-Safe Collections\nThe [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable. Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code. When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently. If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace. We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.  \n  \n## Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections  \n The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace. These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection. The wrapper works by locking the entire collection on every add or remove operation. Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock. This is not scalable and can cause significant performance degradation for large collections. Also, the design is not completely protected from race conditions. For more information, see [Synchronization in Generic Collections](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/).  \n  \n The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace. These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on. These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes. However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.  \n  \n We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide.  \n  \n## Fine-Grained Locking and Lock-Free Mechanisms  \n Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]. These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state. When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition. For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate. For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).  \n  \n The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all. Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.  \n  \n> [!NOTE]\n>  Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant. `IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).  \n  \n The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.  \n  \n|Type|Description|  \n|----------|-----------------|  \n|<xref:System.Collections.Concurrent.BlockingCollection%601>|Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).|  \n|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|Thread-safe implementation of a dictionary of key-value pairs.|  \n|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|Thread-safe implementation of a FIFO (first-in, first-out) queue.|  \n|<xref:System.Collections.Concurrent.ConcurrentStack%601>|Thread-safe implementation of a LIFO (last-in, first-out) stack.|  \n|<xref:System.Collections.Concurrent.ConcurrentBag%601>|Thread-safe implementation of an unordered collection of elements.|  \n|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|The interface that a type must implement to be used in a `BlockingCollection`.|  \n  \n## Related Topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.|  \n|[How to: Add and Remove Items from a ConcurrentDictionary](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602>|  \n|[How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.|  \n|[How to: Add Bounding and Blocking Functionality to a Collection](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.|  \n|[How to: Use ForEach to Remove Items in a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.|  \n|[How to: Use Arrays of Blocking Collections in a Pipeline](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|Describes how to use multiple blocking collections at the same time to implement a pipeline.|  \n|[How to: Create an Object Pool by Using a ConcurrentBag](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.|  \n  \n## Reference  \n <xref:System.Collections.Concurrent?displayProperty=nameWithType>\n","nodes":[{"pos":[4,237],"embed":true,"restype":"x-metadata","content":"title: \"Thread-Safe Collections\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"thread-safe collections, overview\"\nms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Thread-Safe Collections","nodes":[{"pos":[0,23],"content":"Thread-Safe Collections","nodes":[{"content":"Thread-Safe Collections","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[244,267],"content":"Thread-Safe Collections","linkify":"Thread-Safe Collections","nodes":[{"content":"Thread-Safe Collections","pos":[0,23]}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]</ph> introduces the <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent?displayProperty=nameWithType&gt;</ph> namespace, which includes several collection classes that are both thread-safe and scalable.","pos":[268,513],"source":"The [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable."},{"content":"Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.","pos":[514,660]},{"content":"When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.","pos":[661,792]},{"content":"If you are only reading from a shared collection, then you can use the classes in the <ph id=\"ph1\">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace.","pos":[793,952],"source":" If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace."},{"content":"We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.","pos":[953,1085]},{"pos":[1094,1162],"content":"Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections","linkify":"Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections","nodes":[{"content":"Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections","pos":[0,68]}]},{"content":"The collections introduced in the .NET Framework 1.0 are found in the <ph id=\"ph1\">&lt;xref:System.Collections?displayProperty=nameWithType&gt;</ph> namespace.","pos":[1166,1301],"source":"The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace."},{"content":"These collections, which include the commonly used <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Collections.Hashtable&gt;</ph>, provide some thread-safety through the <ph id=\"ph3\">`Synchronized`</ph> property, which returns a thread-safe wrapper around the collection.","pos":[1302,1552],"source":" These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection."},{"content":"The wrapper works by locking the entire collection on every add or remove operation.","pos":[1553,1637]},{"content":"Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.","pos":[1638,1749]},{"content":"This is not scalable and can cause significant performance degradation for large collections.","pos":[1750,1843]},{"content":"Also, the design is not completely protected from race conditions.","pos":[1844,1910]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Synchronization in Generic Collections<ept id=\"p1\">](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/)</ept>.","pos":[1911,2089],"source":" For more information, see [Synchronization in Generic Collections](https://blogs.msdn.microsoft.com/bclteam/2005/03/15/synchronization-in-generic-collections-brian-grunkemeyer/)."},{"content":"The collection classes introduced in the .NET Framework 2.0 are found in the <ph id=\"ph1\">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace.","pos":[2096,2246],"source":"The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace."},{"content":"These include <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>, and so on.","pos":[2247,2365],"source":" These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on."},{"content":"These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.","pos":[2366,2468]},{"content":"However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.","pos":[2469,2671]},{"pos":[2678,3046],"content":"We recommend the concurrent collections classes in the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]</ph> because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the <ph id=\"ph2\">[!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)]</ph> collections provide.","source":"We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide."},{"pos":[3055,3100],"content":"Fine-Grained Locking and Lock-Free Mechanisms","linkify":"Fine-Grained Locking and Lock-Free Mechanisms","nodes":[{"content":"Fine-Grained Locking and Lock-Free Mechanisms","pos":[0,45]}]},{"content":"Some of the concurrent collection types use lightweight synchronization mechanisms such as <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.SpinWait&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.CountdownEvent&gt;</ph>, which are new in the <ph id=\"ph5\">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]</ph>.","pos":[3104,3435],"source":"Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)]."},{"content":"These synchronization types typically use <bpt id=\"p1\">*</bpt>busy spinning<ept id=\"p1\">*</ept> for brief periods before they put the thread into a true Wait state.","pos":[3436,3562],"source":" These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state."},{"content":"When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.","pos":[3563,3717]},{"content":"For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.","pos":[3718,3849]},{"content":"For more information about spinning vs. blocking, see <bpt id=\"p1\">[</bpt>SpinLock<ept id=\"p1\">](../../../../docs/standard/threading/spinlock.md)</ept> and <bpt id=\"p2\">[</bpt>SpinWait<ept id=\"p2\">](../../../../docs/standard/threading/spinwait.md)</ept>.","pos":[3850,4028],"source":" For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md)."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Collections.Concurrent.ConcurrentStack%601&gt;</ph> classes do not use locks at all.","pos":[4035,4189],"source":"The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all."},{"content":"Instead, they rely on <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> operations to achieve thread-safety.","pos":[4190,4284],"source":" Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety."},{"pos":[4292,4697],"content":"[!NOTE]\n Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant. `IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).","leadings":["","> "],"nodes":[{"content":"Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant. `IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).","pos":[9,403],"nodes":[{"content":"Because the concurrent collections classes support <ph id=\"ph1\">&lt;xref:System.Collections.ICollection&gt;</ph>, they provide implementations for the <ph id=\"ph2\">&lt;xref:System.Collections.ICollection.IsSynchronized%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> properties, even though these properties are irrelevant.","pos":[0,293],"source":"Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant."},{"content":"<ph id=\"ph1\">`IsSynchronized`</ph> always returns <ph id=\"ph2\">`false`</ph> and <ph id=\"ph3\">`SyncRoot`</ph> is always <ph id=\"ph4\">`null`</ph> (<ph id=\"ph5\">`Nothing`</ph> in Visual Basic).","pos":[294,394],"source":"`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic)."}]}]},{"pos":[4704,4834],"content":"The following table lists the collection types in the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent?displayProperty=nameWithType&gt;</ph> namespace.","source":"The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace."},{"content":"Type","pos":[4841,4845]},{"content":"Description","pos":[4846,4857]},{"content":"Provides bounding and blocking functionality for any type that implements <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph>.","pos":[4955,5098],"source":"Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>BlockingCollection Overview<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)</ept>.","pos":[5099,5237],"source":" For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)."},{"content":"Thread-safe implementation of a dictionary of key-value pairs.","pos":[5304,5366]},{"content":"Thread-safe implementation of a FIFO (first-in, first-out) queue.","pos":[5428,5493]},{"content":"Thread-safe implementation of a LIFO (last-in, first-out) stack.","pos":[5555,5619]},{"content":"Thread-safe implementation of an unordered collection of elements.","pos":[5679,5745]},{"pos":[5819,5897],"content":"The interface that a type must implement to be used in a <ph id=\"ph1\">`BlockingCollection`</ph>.","source":"The interface that a type must implement to be used in a `BlockingCollection`."},{"pos":[5907,5921],"content":"Related Topics","linkify":"Related Topics","nodes":[{"content":"Related Topics","pos":[0,14]}]},{"content":"Title","pos":[5928,5933]},{"content":"Description","pos":[5934,5945]},{"pos":[5984,6095],"content":"<bpt id=\"p1\">[</bpt>BlockingCollection Overview<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)</ept>","source":"[BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)"},{"pos":[6096,6205],"content":"Describes the functionality provided by the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> type.","source":"Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type."},{"pos":[6210,6350],"content":"<bpt id=\"p1\">[</bpt>How to: Add and Remove Items from a ConcurrentDictionary<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)</ept>","source":"[How to: Add and Remove Items from a ConcurrentDictionary](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)"},{"pos":[6351,6460],"content":"Describes how to add and remove elements from a <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph>","source":"Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602>"},{"pos":[6465,6612],"content":"<bpt id=\"p1\">[</bpt>How to: Add and Take Items Individually from a BlockingCollection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)</ept>","source":"[How to: Add and Take Items Individually from a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)"},{"content":"Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.","pos":[6613,6719]},{"pos":[6724,6876],"content":"<bpt id=\"p1\">[</bpt>How to: Add Bounding and Blocking Functionality to a Collection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)</ept>","source":"[How to: Add Bounding and Blocking Functionality to a Collection](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)"},{"pos":[6877,7042],"content":"Describes how to use any collection class as the underlying storage mechanism for an <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601&gt;</ph> collection.","source":"Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection."},{"pos":[7047,7191],"content":"<bpt id=\"p1\">[</bpt>How to: Use ForEach to Remove Items in a BlockingCollection<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)</ept>","source":"[How to: Use ForEach to Remove Items in a BlockingCollection](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)"},{"pos":[7192,7298],"content":"Describes how to use <ph id=\"ph1\">`foreach`</ph>, (<ph id=\"ph2\">`For Each`</ph> in Visual Basic) to remove all items in a blocking collection.","source":"Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection."},{"pos":[7303,7456],"content":"<bpt id=\"p1\">[</bpt>How to: Use Arrays of Blocking Collections in a Pipeline<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)</ept>","source":"[How to: Use Arrays of Blocking Collections in a Pipeline](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)"},{"content":"Describes how to use multiple blocking collections at the same time to implement a pipeline.","pos":[7457,7549]},{"pos":[7554,7693],"content":"<bpt id=\"p1\">[</bpt>How to: Create an Object Pool by Using a ConcurrentBag<ept id=\"p1\">](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)</ept>","source":"[How to: Create an Object Pool by Using a ConcurrentBag](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)"},{"content":"Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.","pos":[7694,7833]},{"pos":[7843,7852],"content":"Reference","linkify":"Reference","nodes":[{"content":"Reference","pos":[0,9]}]}]}