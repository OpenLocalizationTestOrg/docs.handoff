{"content":"---\ntitle: \"XAML Security Considerations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"security [XAML Services], .NET XAML services\"\n  - \"XAML security [XAML Services]\"\nms.assetid: 544296d4-f38e-4498-af49-c9f4dad28964\ncaps.latest.revision: 7\nauthor: \"wadepickett\"\nms.author: \"wpickett\"\nmanager: \"wpickett\"\n---\n# XAML Security Considerations\nThis topic describes best practices for security in applications when you use XAML and .NET Framework XAML Services API.  \n  \n## Untrusted XAML in Applications  \n In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.  \n  \n XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted. You can trust the XAML as much as you trust the assembly as a whole. In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other IO. Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure. However, an assembly might implement a behavior that involves loading loose XAML.  \n  \n For untrusted XAML, you should treat it generally the same as if it were untrusted code. Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.  \n  \n The nature of XAML capabilities gives the XAML the right to construct objects and set their properties. These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on.  \n  \n In addition to its language-level capabilities, XAML is used for UI definition in many technologies. Loading untrusted XAML might mean loading a malicious spoofing UI.  \n  \n## Sharing Context Between Readers and Writers  \n The .NET Framework XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context. Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path. You should not share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.  \n  \n Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context. The default XAML schema context does not explicitly include settings that could compromise full trust. It is thus safe to share context between trusted and untrusted XAML reader/writer components. However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust.  \n  \n## XAML Namespaces and Assembly Trust  \n The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain. Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information. If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:  \n  \n-   Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.  \n  \n-   Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers. See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>.  \n  \n## XAML Type Mapping and Type System Access  \n XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system. However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types. This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET Framework XAML Services implementations. These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context. For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>.  \n  \n## See Also  \n <xref:System.Xaml.Permissions.XamlAccessLevel>","nodes":[{"pos":[12,57],"content":"XAML Security Considerations | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"XAML Security Considerations | Microsoft Docs","pos":[0,45]}]},{"pos":[473,501],"content":"XAML Security Considerations","linkify":"XAML Security Considerations","nodes":[{"content":"XAML Security Considerations","pos":[0,28]}]},{"content":"This topic describes best practices for security in applications when you use XAML and .NET Framework XAML Services API.","pos":[502,622]},{"pos":[631,661],"content":"Untrusted XAML in Applications","linkify":"Untrusted XAML in Applications","nodes":[{"content":"Untrusted XAML in Applications","pos":[0,30]}]},{"content":"In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.","pos":[665,785]},{"content":"XAML that is compiled into or stored as a <ph id=\"ph1\">`resx`</ph>-type resource within a trusted and signed assembly is not inherently untrusted.","pos":[792,920],"source":"XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted."},{"content":"You can trust the XAML as much as you trust the assembly as a whole.","pos":[921,989]},{"content":"In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other IO.","pos":[990,1129]},{"content":"Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure.","pos":[1130,1251]},{"content":"However, an assembly might implement a behavior that involves loading loose XAML.","pos":[1252,1333]},{"content":"For untrusted XAML, you should treat it generally the same as if it were untrusted code.","pos":[1340,1428]},{"content":"Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.","pos":[1429,1531]},{"content":"The nature of XAML capabilities gives the XAML the right to construct objects and set their properties.","pos":[1538,1641]},{"content":"These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, <ph id=\"ph1\">`x:Code`</ph> blocks, and so on.","pos":[1642,1813],"source":" These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on."},{"content":"In addition to its language-level capabilities, XAML is used for UI definition in many technologies.","pos":[1820,1920]},{"content":"Loading untrusted XAML might mean loading a malicious spoofing UI.","pos":[1921,1987]},{"pos":[1996,2039],"content":"Sharing Context Between Readers and Writers","linkify":"Sharing Context Between Readers and Writers","nodes":[{"content":"Sharing Context Between Readers and Writers","pos":[0,43]}]},{"content":"The .NET Framework XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context.","pos":[2043,2210]},{"content":"Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path.","pos":[2211,2330]},{"content":"You should not share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.","pos":[2331,2485]},{"content":"Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context.","pos":[2492,2622]},{"content":"The default XAML schema context does not explicitly include settings that could compromise full trust.","pos":[2623,2725]},{"content":"It is thus safe to share context between trusted and untrusted XAML reader/writer components.","pos":[2726,2819]},{"content":"However, if you do this, it is still a best practice to keep such readers and writers in separate <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> scopes, with one of them specifically intended/sandboxed for partial trust.","pos":[2820,3017],"source":" However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust."},{"pos":[3026,3060],"content":"XAML Namespaces and Assembly Trust","linkify":"XAML Namespaces and Assembly Trust","nodes":[{"content":"XAML Namespaces and Assembly Trust","pos":[0,34]}]},{"content":"The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain.","pos":[3064,3279]},{"content":"Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information.","pos":[3280,3470]},{"content":"If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:","pos":[3471,3620]},{"content":"Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.","pos":[3630,3745]},{"content":"Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <ph id=\"ph1\">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph> for your XAML readers and XAML object writers.","pos":[3755,3931],"source":"Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers."},{"content":"See <ph id=\"ph1\">&lt;xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29&gt;</ph>.","pos":[3932,4057],"source":" See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>."},{"pos":[4066,4106],"content":"XAML Type Mapping and Type System Access","linkify":"XAML Type Mapping and Type System Access","nodes":[{"content":"XAML Type Mapping and Type System Access","pos":[0,40]}]},{"content":"XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system.","pos":[4110,4222]},{"content":"However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types.","pos":[4223,4417]},{"content":"This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET Framework XAML Services implementations.","pos":[4418,4643]},{"content":"These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context.","pos":[4644,4893]},{"content":"For more information, see the specific notes on several of the properties of <ph id=\"ph1\">&lt;xref:System.Xaml.XamlType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Xaml.XamlMember&gt;</ph>.","pos":[4894,5033],"source":" For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>."},{"pos":[5042,5050],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]}]}