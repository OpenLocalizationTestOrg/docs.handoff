{"content":"---\ntitle: \"Interoperability Overview - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"COM interop\"\n  - \"C# language, interoperability\"\n  - \"C++ Interop\"\n  - \"interoperability, about interoperability\"\n  - \"platform invoke\"\nms.assetid: c025b2e0-2357-4c27-8461-118f0090aeff\n---\n# Interoperability Overview (C# Programming Guide)\nThe topic describes methods to enable interoperability between C# managed code and unmanaged code.  \n  \n## Platform Invoke  \n *Platform invoke* is a service that enables managed code to call unmanaged functions that are implemented in dynamic link libraries (DLLs), such as those in the Microsoft Windows API. It locates and invokes an exported function and marshals its arguments (integers, strings, arrays, structures, and so on) across the interoperation boundary as needed.  \n  \n For more information, see [Consuming Unmanaged DLL Functions](../../../framework/interop/consuming-unmanaged-dll-functions.md) and [How to: Use Platform Invoke to Play a Wave File](../../../csharp/programming-guide/interop/how-to-use-platform-invoke-to-play-a-wave-file.md).  \n  \n> [!NOTE]\n>  The [Common Language Runtime](../../../standard/clr.md) (CLR) manages access to system resources. Calling unmanaged code that is outside the CLR bypasses this security mechanism, and therefore presents a security risk. For example, unmanaged code might call resources in unmanaged code directly, bypassing CLR security mechanisms. For more information, see [Security in .NET](../../../standard/security/index.md).  \n  \n## C++ Interop  \n You can use C++ interop, also known as It Just Works (IJW), to wrap a native C++ class so that it can be consumed by code that is authored in C# or another .NET Framework language. To do this, you write C++ code to wrap a native DLL or COM component. Unlike other .NET Framework languages, [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)] has interoperability support that enables managed and unmanaged code to be located in the same application and even in the same file. You then build the C++ code by using the **/clr** compiler switch to produce a managed assembly. Finally, you add a reference to the assembly in your C# project and use the wrapped objects just as you would use other managed classes.  \n  \n## Exposing COM Components to C\\#\n You can consume a COM component from a C# project. The general steps are as follows:  \n  \n1.  Locate a COM component to use and register it. Use regsvr32.exe to register or un–register a COM DLL.  \n  \n2.  Add to the project a reference to the COM component or type library.  \n  \n     When you add the reference, Visual Studio uses the [Tlbimp.exe (Type Library Importer)](../../../../docs/framework/tools/tlbimp-exe-type-library-importer.md), which takes a type library as input, to output a .NET Framework interop assembly. The assembly, also named a runtime callable wrapper (RCW), contains managed classes and interfaces that wrap the COM classes and interfaces that are in the type library. Visual Studio adds to the project a reference to the generated assembly.  \n  \n3.  Create an instance of a class that is defined in the RCW. This, in turn, creates an instance of the COM object.  \n  \n4.  Use the object just as you use other managed objects. When the object is reclaimed by garbage collection, the instance of the COM object is also released from memory.  \n  \n For more information, see [Exposing COM Components to the .NET Framework](../../../../docs/framework/interop/exposing-com-components.md).  \n  \n## Exposing C# to COM  \n COM clients can consume C# types that have been correctly exposed. The basic steps to expose C# types are as follows:  \n  \n1.  Add interop attributes in the C# project.  \n  \n     You can make an assembly COM visible by modifying Visual C# project properties. For more information, see [Assembly Information Dialog Box](/visualstudio/ide/reference/assembly-information-dialog-box).  \n  \n2.  Generate a COM type library and register it for COM usage.  \n  \n     You can modify Visual C# project properties to automatically register the C# assembly for COM interop. Visual Studio uses the [Regasm.exe (Assembly Registration Tool)](../../../../docs/framework/tools/regasm-exe-assembly-registration-tool.md), using the `/tlb` command-line switch, which takes a managed assembly as input, to generate a type library. This type library describes the `public` types in the assembly and adds registry entries so that COM clients can create managed classes.  \n  \n For more information, see [Exposing .NET Framework Components to COM](../../../../docs/framework/interop/exposing-dotnet-components-to-com.md) and [Example COM Class](../../../csharp/programming-guide/interop/example-com-class.md).  \n  \n## See also\n\n- [Improving Interop Performance](https://docs.microsoft.com/previous-versions/msp-n-p/ff647812%28v=pandp.10%29)\n- [Introduction to Interoperability between COM and .NET](/office/client-developer/outlook/pia/introduction-to-interoperability-between-com-and-net)\n- [Introduction to COM Interop in Visual Basic](../../../../docs/visual-basic/programming-guide/com-interop/introduction-to-com-interop.md)\n- [Marshaling between Managed and Unmanaged Code](../../../../docs/framework/interop/interop-marshaling.md)\n- [Interoperating with Unmanaged Code](../../../../docs/framework/interop/index.md)\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n","nodes":[{"pos":[4,313],"embed":true,"restype":"x-metadata","content":"title: \"Interoperability Overview - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"COM interop\"\n  - \"C# language, interoperability\"\n  - \"C++ Interop\"\n  - \"interoperability, about interoperability\"\n  - \"platform invoke\"\nms.assetid: c025b2e0-2357-4c27-8461-118f0090aeff","nodes":[{"content":"Interoperability Overview - C# Programming Guide","nodes":[{"pos":[0,48],"content":"Interoperability Overview - C# Programming Guide","nodes":[{"content":"Interoperability Overview - C# Programming Guide","pos":[0,48]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[320,368],"content":"Interoperability Overview (C# Programming Guide)","linkify":"Interoperability Overview (C# Programming Guide)","nodes":[{"content":"Interoperability Overview (C# Programming Guide)","pos":[0,48]}]},{"content":"The topic describes methods to enable interoperability between C# managed code and unmanaged code.","pos":[369,467]},{"pos":[476,491],"content":"Platform Invoke","linkify":"Platform Invoke","nodes":[{"content":"Platform Invoke","pos":[0,15]}]},{"content":"<bpt id=\"p1\">*</bpt>Platform invoke<ept id=\"p1\">*</ept> is a service that enables managed code to call unmanaged functions that are implemented in dynamic link libraries (DLLs), such as those in the Microsoft Windows API.","pos":[495,678],"source":"*Platform invoke* is a service that enables managed code to call unmanaged functions that are implemented in dynamic link libraries (DLLs), such as those in the Microsoft Windows API."},{"content":"It locates and invokes an exported function and marshals its arguments (integers, strings, arrays, structures, and so on) across the interoperation boundary as needed.","pos":[679,846]},{"pos":[853,1127],"content":"For more information, see <bpt id=\"p1\">[</bpt>Consuming Unmanaged DLL Functions<ept id=\"p1\">](../../../framework/interop/consuming-unmanaged-dll-functions.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Use Platform Invoke to Play a Wave File<ept id=\"p2\">](../../../csharp/programming-guide/interop/how-to-use-platform-invoke-to-play-a-wave-file.md)</ept>.","source":"For more information, see [Consuming Unmanaged DLL Functions](../../../framework/interop/consuming-unmanaged-dll-functions.md) and [How to: Use Platform Invoke to Play a Wave File](../../../csharp/programming-guide/interop/how-to-use-platform-invoke-to-play-a-wave-file.md)."},{"pos":[1135,1559],"content":"[!NOTE]\n The [Common Language Runtime](../../../standard/clr.md) (CLR) manages access to system resources. Calling unmanaged code that is outside the CLR bypasses this security mechanism, and therefore presents a security risk. For example, unmanaged code might call resources in unmanaged code directly, bypassing CLR security mechanisms. For more information, see [Security in .NET](../../../standard/security/index.md).","leadings":["","> "],"nodes":[{"content":"The [Common Language Runtime](../../../standard/clr.md) (CLR) manages access to system resources. Calling unmanaged code that is outside the CLR bypasses this security mechanism, and therefore presents a security risk. For example, unmanaged code might call resources in unmanaged code directly, bypassing CLR security mechanisms. For more information, see [Security in .NET](../../../standard/security/index.md).","pos":[9,422],"nodes":[{"content":"The <bpt id=\"p1\">[</bpt>Common Language Runtime<ept id=\"p1\">](../../../standard/clr.md)</ept> (CLR) manages access to system resources.","pos":[0,97],"source":"The [Common Language Runtime](../../../standard/clr.md) (CLR) manages access to system resources."},{"content":"Calling unmanaged code that is outside the CLR bypasses this security mechanism, and therefore presents a security risk.","pos":[98,218]},{"content":"For example, unmanaged code might call resources in unmanaged code directly, bypassing CLR security mechanisms.","pos":[219,330]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Security in .NET<ept id=\"p1\">](../../../standard/security/index.md)</ept>.","pos":[331,413],"source":" For more information, see [Security in .NET](../../../standard/security/index.md)."}]}]},{"pos":[1568,1579],"content":"C++ Interop","linkify":"C++ Interop","nodes":[{"content":"C++ Interop","pos":[0,11]}]},{"content":"You can use C++ interop, also known as It Just Works (IJW), to wrap a native C++ class so that it can be consumed by code that is authored in C# or another .NET Framework language.","pos":[1583,1763]},{"content":"To do this, you write C++ code to wrap a native DLL or COM component.","pos":[1764,1833]},{"content":"Unlike other .NET Framework languages, <ph id=\"ph1\">[!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]</ph> has interoperability support that enables managed and unmanaged code to be located in the same application and even in the same file.","pos":[1834,2050],"source":" Unlike other .NET Framework languages, [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)] has interoperability support that enables managed and unmanaged code to be located in the same application and even in the same file."},{"content":"You then build the C++ code by using the <bpt id=\"p1\">**</bpt>/clr<ept id=\"p1\">**</ept> compiler switch to produce a managed assembly.","pos":[2051,2147],"source":" You then build the C++ code by using the **/clr** compiler switch to produce a managed assembly."},{"content":"Finally, you add a reference to the assembly in your C# project and use the wrapped objects just as you would use other managed classes.","pos":[2148,2284]},{"pos":[2293,2323],"content":"Exposing COM Components to C\\#","linkify":"Exposing COM Components to C\\#","nodes":[{"content":"Exposing COM Components to C<ph id=\"ph1\">\\#</ph>","pos":[0,30],"source":"Exposing COM Components to C\\#"}]},{"content":"You can consume a COM component from a C# project.","pos":[2325,2375]},{"content":"The general steps are as follows:","pos":[2376,2409]},{"content":"Locate a COM component to use and register it.","pos":[2419,2465]},{"content":"Use regsvr32.exe to register or un–register a COM DLL.","pos":[2466,2520]},{"content":"Add to the project a reference to the COM component or type library.","pos":[2530,2598]},{"content":"When you add the reference, Visual Studio uses the <bpt id=\"p1\">[</bpt>Tlbimp.exe (Type Library Importer)<ept id=\"p1\">](../../../../docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>, which takes a type library as input, to output a .NET Framework interop assembly.","pos":[2609,2849],"source":"When you add the reference, Visual Studio uses the [Tlbimp.exe (Type Library Importer)](../../../../docs/framework/tools/tlbimp-exe-type-library-importer.md), which takes a type library as input, to output a .NET Framework interop assembly."},{"content":"The assembly, also named a runtime callable wrapper (RCW), contains managed classes and interfaces that wrap the COM classes and interfaces that are in the type library.","pos":[2850,3019]},{"content":"Visual Studio adds to the project a reference to the generated assembly.","pos":[3020,3092]},{"content":"Create an instance of a class that is defined in the RCW.","pos":[3102,3159]},{"content":"This, in turn, creates an instance of the COM object.","pos":[3160,3213]},{"content":"Use the object just as you use other managed objects.","pos":[3223,3276]},{"content":"When the object is reclaimed by garbage collection, the instance of the COM object is also released from memory.","pos":[3277,3389]},{"pos":[3396,3533],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exposing COM Components to the .NET Framework<ept id=\"p1\">](../../../../docs/framework/interop/exposing-com-components.md)</ept>.","source":"For more information, see [Exposing COM Components to the .NET Framework](../../../../docs/framework/interop/exposing-com-components.md)."},{"pos":[3542,3560],"content":"Exposing C# to COM","linkify":"Exposing C# to COM","nodes":[{"content":"Exposing C# to COM","pos":[0,18]}]},{"content":"COM clients can consume C# types that have been correctly exposed.","pos":[3564,3630]},{"content":"The basic steps to expose C# types are as follows:","pos":[3631,3681]},{"content":"Add interop attributes in the C# project.","pos":[3691,3732]},{"content":"You can make an assembly COM visible by modifying Visual C# project properties.","pos":[3743,3822]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Assembly Information Dialog Box<ept id=\"p1\">](/visualstudio/ide/reference/assembly-information-dialog-box)</ept>.","pos":[3823,3944],"source":" For more information, see [Assembly Information Dialog Box](/visualstudio/ide/reference/assembly-information-dialog-box)."},{"content":"Generate a COM type library and register it for COM usage.","pos":[3954,4012]},{"content":"You can modify Visual C# project properties to automatically register the C# assembly for COM interop.","pos":[4023,4125]},{"content":"Visual Studio uses the <bpt id=\"p1\">[</bpt>Regasm.exe (Assembly Registration Tool)<ept id=\"p1\">](../../../../docs/framework/tools/regasm-exe-assembly-registration-tool.md)</ept>, using the <ph id=\"ph1\">`/tlb`</ph> command-line switch, which takes a managed assembly as input, to generate a type library.","pos":[4126,4373],"source":" Visual Studio uses the [Regasm.exe (Assembly Registration Tool)](../../../../docs/framework/tools/regasm-exe-assembly-registration-tool.md), using the `/tlb` command-line switch, which takes a managed assembly as input, to generate a type library."},{"content":"This type library describes the <ph id=\"ph1\">`public`</ph> types in the assembly and adds registry entries so that COM clients can create managed classes.","pos":[4374,4510],"source":" This type library describes the `public` types in the assembly and adds registry entries so that COM clients can create managed classes."},{"pos":[4517,4748],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exposing .NET Framework Components to COM<ept id=\"p1\">](../../../../docs/framework/interop/exposing-dotnet-components-to-com.md)</ept> and <bpt id=\"p2\">[</bpt>Example COM Class<ept id=\"p2\">](../../../csharp/programming-guide/interop/example-com-class.md)</ept>.","source":"For more information, see [Exposing .NET Framework Components to COM](../../../../docs/framework/interop/exposing-dotnet-components-to-com.md) and [Example COM Class](../../../csharp/programming-guide/interop/example-com-class.md)."},{"pos":[4757,4765],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4769,4879],"content":"<bpt id=\"p1\">[</bpt>Improving Interop Performance<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/msp-n-p/ff647812%28v=pandp.10%29)</ept>","source":"[Improving Interop Performance](https://docs.microsoft.com/previous-versions/msp-n-p/ff647812%28v=pandp.10%29)"},{"pos":[4882,5028],"content":"<bpt id=\"p1\">[</bpt>Introduction to Interoperability between COM and .NET<ept id=\"p1\">](/office/client-developer/outlook/pia/introduction-to-interoperability-between-com-and-net)</ept>","source":"[Introduction to Interoperability between COM and .NET](/office/client-developer/outlook/pia/introduction-to-interoperability-between-com-and-net)"},{"pos":[5031,5168],"content":"<bpt id=\"p1\">[</bpt>Introduction to COM Interop in Visual Basic<ept id=\"p1\">](../../../../docs/visual-basic/programming-guide/com-interop/introduction-to-com-interop.md)</ept>","source":"[Introduction to COM Interop in Visual Basic](../../../../docs/visual-basic/programming-guide/com-interop/introduction-to-com-interop.md)"},{"pos":[5171,5276],"content":"<bpt id=\"p1\">[</bpt>Marshaling between Managed and Unmanaged Code<ept id=\"p1\">](../../../../docs/framework/interop/interop-marshaling.md)</ept>","source":"[Marshaling between Managed and Unmanaged Code](../../../../docs/framework/interop/interop-marshaling.md)"},{"pos":[5279,5360],"content":"<bpt id=\"p1\">[</bpt>Interoperating with Unmanaged Code<ept id=\"p1\">](../../../../docs/framework/interop/index.md)</ept>","source":"[Interoperating with Unmanaged Code](../../../../docs/framework/interop/index.md)"},{"pos":[5363,5429],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"}]}