<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="handling-exceptions-and-faults.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c51d78bb982ec0748cd74a67a4f4b747526a4b42</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\extending\handling-exceptions-and-faults.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b8410c90db6e96110c6061931cbd6179e2d51ed4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">af75f4d7b95de79fd376bcc905455b2b1a6be3f7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Handling Exceptions and Faults</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Handling Exceptions and Faults</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Exceptions are used to communicate errors locally within the service or the client implementation.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Faults, on the other hand, are used to communicate errors across service boundaries, such as from the server to the client or vice versa.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In addition to faults, transport channels often use transport-specific mechanisms to communicate transport-level errors.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, HTTP transport uses status codes such as 404 to communicate a non-existing endpoint URL (there is no endpoint to send back a fault).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This document consists of three sections that provide guidance to custom channel authors.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The first section provides guidance on when and how to define and throw exceptions.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The second section provides guidance around generating and consuming faults.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The third section explains how to provide trace information to aid the user of your custom channel in troubleshooting running applications.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>There are two things to keep in mind when throwing an exception: First it has to be of a type that allows users to write correct code that can react appropriately to the exception.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Second, it has to provide enough information for the user to understand what went wrong, the failure impact, and how to fix it.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following sections give guidance around exception types and messages for Windows Communication Foundation (WCF) channels.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>There is also general guidance around exceptions in .NET in the Design Guidelines for Exceptions document.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Exception Types</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>All exceptions thrown by channels must be either a <ph id="ph1">&lt;xref:System.TimeoutException?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.ServiceModel.CommunicationException?displayProperty=nameWithType&gt;</ph>, or a type derived from <ph id="ph3">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>(Exceptions such as <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> may also be thrown, but only to indicate that the calling code has misused the channel.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If a channel is used correctly, it must only throw the given exceptions.) WCF provides seven exception types that derive from <ph id="ph1">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph> and are designed to be used by channels.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>There are other <ph id="ph1">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>-derived exceptions that are designed to be used by other parts of the system.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>These exception types are:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Exception Type</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Inner Exception Content</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Recovery Strategy</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The endpoint address specified for listening is already in use.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If present, provides more details about the transport error that caused this exception.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.IO.PipeException&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.HttpListenerException&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Try a different address.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The process is not allowed access to the endpoint address specified for listening.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If present, provides more details about the transport error that caused this exception.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref:System.IO.PipeException&gt;</ph>, or <ph id="ph2">&lt;xref:System.Net.HttpListenerException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Try with different credentials.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> being used is in the Faulted state (for more information, see <bpt id="p1">[</bpt>Understanding State Changes<ept id="p1">](../../../../docs/framework/wcf/extending/understanding-state-changes.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Note that when an object with multiple pending calls transitions to the Faulted state, only one call throws an exception that is related to the failure and the rest of the calls throw a <ph id="ph1">&lt;xref:System.ServiceModel.CommunicationObjectFaultedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This exception is typically thrown because an application overlooks some exception and tries to use an already faulted object, possibly on a thread other than the one that caught the original exception.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If present provides details about the inner exception.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Create a new object.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Note that depending on what caused the <ph id="ph1">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> to fault in the first place, there may be other work required to recover.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> being used has been Aborted (for more information, see <bpt id="p1">[</bpt>Understanding State Changes<ept id="p1">](../../../../docs/framework/wcf/extending/understanding-state-changes.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Similar to <ph id="ph1">&lt;xref:System.ServiceModel.CommunicationObjectFaultedException&gt;</ph>, his exception indicates the application has called <ph id="ph2">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> on the object, possibly from another thread, and the object is no longer usable for that reason.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If present provides details about the inner exception.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Create a new object.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Note that depending on what caused the <ph id="ph1">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> to abort in the first place, there may be other work required to recover.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The target remote endpoint is not listening.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This can result from any part of the endpoint address being incorrect, irresolvable, or the endpoint being down.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Examples include DNS error, Queue Manager not available, and service not running.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The inner exception provides details, typically from the underlying transport.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Try a different address.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Alternatively, the sender may wait a while and try again in case the service was down</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The communication protocols, as described by the endpoint’s policy, are mismatched between endpoints.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, framing content type mismatch or max message size exceeded.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If present provides more information about the specific protocol error.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is the inner exception when the error cause is exceeding MaxReceivedMessageSize.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Recovery: Ensure sender and received protocol settings match.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>One way to do this is to re-import the service endpoint’s metadata (policy) and use the generated binding to recreate the channel.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The remote endpoint is listening but is not prepared to process messages.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If present, the inner Exception provides the SOAP fault or transport-level error details.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Recovery: Wait and retry the operation later.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The operation failed to complete within the timeout period.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>May provide details about the timeout.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Wait and retry the operation later.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Define a new exception type only if that type corresponds to a specific recovery strategy different from all of the existing exception types.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If you do define a new exception type, it must derive from <ph id="ph1">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph> or one of its derived classes.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Exception Messages</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Exception messages are targeted at the user not the program so they should provide sufficient information to help the user understand and solve the problem.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The three essential parts of a good exception message are:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>What happened.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Provide a clear description of the problem using terms that relate to the user’s experience.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, a bad exception message would be "Invalid configuration section".</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This leaves the user wondering which configuration section is incorrect and why it is incorrect.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>An improved message would be "Invalid configuration section <ph id="ph1">\&lt;</ph>customBinding&gt;".</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>An even better message would be "Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport".</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This is a very specific message using terms and names that the user can easily identify in the application’s configuration file.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>However, there are still a few key components missing.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The significance of the error.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Unless the message states clearly what the error means, the user is likely to wonder whether it is a fatal error or if it can be ignored.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In general, messages should lead with the meaning or significance of the error.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>To improve the previous example, the message could be "ServiceHost failed to Open due to a configuration error: Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport".</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>How the user should correct the problem.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The most important part of the message is helping the user fix the problem.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The message should include some guidance or hints about what to check or fix to remedy the problem.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example, "ServiceHost failed to Open due to a configuration error: Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Please ensure there is only one transport in the binding".</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Communicating Faults</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>SOAP 1.1 and SOAP 1.2 both define a specific structure for faults.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>There are some differences between the two specifications but in general, the Message and MessageFault types are used to create and consume faults.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Handling exceptions and faults<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wcf/extending/media/wcfc-soap1-1andsoap1-2faultcomparisonc.gif "</bpt>wcfc_SOAP1-1AndSOAP1-2FaultComparisonc<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>SOAP 1.2 Fault (left) and SOAP 1.1 Fault (right).</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Note that in SOAP 1.1 only the Fault element is namespace qualified.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>SOAP defines a fault message as a message that contains only a fault element (an element whose name is <ph id="ph1">`&lt;env:Fault&gt;`</ph>) as a child of <ph id="ph2">`&lt;env:Body&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The contents of the fault element differ slightly between SOAP 1.1 and SOAP 1.2 as shown in figure 1.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageFault?displayProperty=nameWithType&gt;</ph> class normalizes these differences into one object model:</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Code`</ph> property corresponds to the <ph id="ph2">`env:Code`</ph> (or <ph id="ph3">`faultCode`</ph> in SOAP 1.1) and identifies the type of the fault.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>SOAP 1.2 defines five allowable values for <ph id="ph1">`faultCode`</ph> (for example, Sender and Receiver) and defines a <ph id="ph2">`Subcode`</ph> element which can contain any subcode value.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>(See the <bpt id="p1">[</bpt>SOAP 1.2 specification<ept id="p1">](https://go.microsoft.com/fwlink/?LinkId=95176)</ept> for the list of allowable fault codes and their meaning.) SOAP 1.1 has a slightly different mechanism: It defines four <ph id="ph1">`faultCode`</ph> values (for example, Client and Server) that can be extended either by defining entirely new ones or by using the dot notation to create more specific <ph id="ph2">`faultCodes`</ph>, for example, Client.Authentication.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>When you use MessageFault to program faults, the FaultCode.Name and FaultCode.Namespace maps to the name and namespace of the SOAP 1.2 <ph id="ph1">`env:Code`</ph> or the SOAP 1.1 <ph id="ph2">`faultCode`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The FaultCode.SubCode maps to <ph id="ph1">`env:Subcode`</ph> for SOAP 1.2 and is null for SOAP 1.1.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You should create new fault subcodes (or new fault codes if using SOAP 1.1) if it is interesting to programmatically distinguish a fault.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This is analogous to creating a new exception type.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>You should avoid using the dot notation with SOAP 1.1 fault codes.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>(The <bpt id="p1">[</bpt>WS-I Basic Profile<ept id="p1">](https://go.microsoft.com/fwlink/?LinkId=95177)</ept> also discourages the use of the fault code dot notation.)</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Reason`</ph> property corresponds to the <ph id="ph2">`env:Reason`</ph> (or <ph id="ph3">`faultString`</ph> in SOAP 1.1) a human-readable description of the error condition analogous to an exception’s message.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`FaultReason`</ph> class (and SOAP <ph id="ph2">`env:Reason/faultString`</ph>) has built-in support for having multiple translations in the interest of globalization.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The fault detail contents are exposed on MessageFault using various methods including the <ph id="ph1">`GetDetail`</ph><ph id="ph2">\&lt;</ph>T&gt; and <ph id="ph3">`GetReaderAtDetailContents`</ph>().</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The fault detail is an opaque element for carrying additional detail about the fault.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>This is useful if there is some arbitrary structured detail that you want to carry with the fault.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Generating Faults</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This section explains the process of generating a fault in response to an error condition detected in a channel or in a message property created by the channel.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A typical example is sending back a fault in response to a request message that contains invalid data.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>When generating a fault, the custom channel should not send the fault directly, rather, it should throw an exception and let the layer above decide whether to convert that exception to a fault and how to send it.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>To aid in this conversion, the channel should provide a <ph id="ph1">`FaultConverter`</ph> implementation that can convert the exception thrown by the custom channel to the appropriate fault.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`FaultConverter`</ph> is defined as:</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Each channel that generates custom faults must implement <ph id="ph1">`FaultConverter`</ph> and return it from a call to <ph id="ph2">`GetProperty&lt;FaultConverter&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The custom <ph id="ph1">`OnTryCreateFaultMessage`</ph> implementation must either convert the exception to a fault or delegate to the inner channel’s <ph id="ph2">`FaultConverter`</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If the channel is a transport it must either convert the exception or delegate to the encoder’s <ph id="ph1">`FaultConverter`</ph> or the default <ph id="ph2">`FaultConverter`</ph> provided in WCF .</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The default <ph id="ph1">`FaultConverter`</ph> converts errors corresponding to fault messages specified by WS-Addressing and SOAP.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Here is an example <ph id="ph1">`OnTryCreateFaultMessage`</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>An implication of this pattern is that exceptions thrown between layers for error conditions that require faults must contain enough information for the corresponding fault generator to create the correct fault.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As a custom channel author, you may define exception types that correspond to different fault conditions if such exceptions do not already exist.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Note that exceptions traversing channel layers should communicate the error condition rather than opaque fault data.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Fault Categories</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>There are generally three categories of faults:</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Faults that are pervasive throughout the entire stack.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>These faults could be encountered at any layer in the channel stack, for example InvalidCardinalityAddressingException.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Faults that can be encountered anywhere above a certain layer in the stack for example some errors that pertain to a flowed transaction or to security roles.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Faults that are directed at a single layer in the stack, for example errors like WS-RM sequence number faults.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Category 1.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Faults are generally WS-Addressing and SOAP faults.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The base <ph id="ph1">`FaultConverter`</ph> class provided by WCF converts errors corresponding to fault messages specified by WS-Addressing and SOAP so you do not have to handle conversion of these exceptions yourself.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Category 2.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Faults occur when a layer adds a property to the message that does not completely consume message information that pertains to that layer.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Errors may be detected later when a higher layer asks the message property to process message information further.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Such channels should implement the <ph id="ph1">`GetProperty`</ph> specified previously to enable the higher layer to send back the correct fault.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>An example of this is the TransactionMessageProperty.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This property is added to the message without fully validating all the data in the header (doing so may involve contacting the distributed transaction coordinator (DTC).</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Category 3.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Faults are only generated and sent by a single layer in the processor.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Therefore all the exceptions are contained within the layer.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>To improve consistency among channels and ease maintenance, your custom channel should use the pattern specified previously to generate fault messages even for internal faults.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Interpreting Received Faults</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This section provides guidance for generating the appropriate exception when receiving a fault message.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The decision tree for processing a message at every layer in the stack is as follows:</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If the layer considers the message to be invalid, the layer should do its ‘invalid message’ processing.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Such processing is specific to the layer but could include dropping the message, tracing, or throwing an exception that gets converted to a fault.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Examples include security receiving a message that is not secured properly, or RM receiving a message with a bad sequence number.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Otherwise, if the message is a fault message that applies specifically to the layer, and the message is not meaningful outside the layer’s interaction, the layer should handle the error condition.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>An example of this is an RM Sequence Refused fault that is meaningless to layers above the RM channel and that implies faulting the RM channel and throwing from pending operations.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Otherwise, the message should be returned from Request() or Receive().</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This includes cases where the layer recognizes the fault, but the fault just indicates that a request failed and does not imply faulting the channel and throwing from pending operations.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>To improve usability in such a case, the layer should implement <ph id="ph1">`GetProperty&lt;FaultConverter&gt;`</ph> and return a <ph id="ph2">`FaultConverter`</ph> derived class that can convert the fault to an exception by overriding <ph id="ph3">`OnTryCreateException`</ph>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The following object model supports converting messages to exceptions:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>A channel layer can implement <ph id="ph1">`GetProperty&lt;FaultConverter&gt;`</ph> to support converting fault messages to exceptions.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>To do so, override <ph id="ph1">`OnTryCreateException`</ph> and inspect the fault message.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>If recognized, do the conversion, otherwise ask the inner channel to convert it.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Transport channels should delegate to <ph id="ph1">`FaultConverter.GetDefaultFaultConverter`</ph> to get the default SOAP/WS-Addressing FaultConverter.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A typical implementation looks like this:</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For specific fault conditions that have distinct recovery scenarios, consider defining a derived class of <ph id="ph1">`ProtocolException`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>MustUnderstand Processing</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>SOAP defines a general fault for signaling that a required header was not understood by the receiver.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This fault is known as the <ph id="ph1">`mustUnderstand`</ph> fault.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>In WCF, custom channels never generate <ph id="ph1">`mustUnderstand`</ph> faults.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Instead, the WCF Dispatcher, which is located at the top of the WCF communication stack, checks to see that all headers that were marked as MustUndestand=true were understood by the underlying stack.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>If any were not understood, a <ph id="ph1">`mustUnderstand`</ph> fault is generated at that point.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>(The user can choose to turn off this <ph id="ph1">`mustUnderstand`</ph> processing and have the application receive all message headers.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In that case the application is responsible for performing <ph id="ph1">`mustUnderstand`</ph> processing.) The generated fault includes a NotUnderstood header that contains the names of all headers with MustUnderstand=true that were not understood.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>If your protocol channel sends a custom header with MustUnderstand=true and receives a <ph id="ph1">`mustUnderstand`</ph> fault, it must figure out whether that fault is due to the header it sent.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>There are two members on the <ph id="ph1">`MessageFault`</ph> class that are useful for this:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IsMustUnderstandFault`</ph> returns <ph id="ph2">`true`</ph> if the fault is a <ph id="ph3">`mustUnderstand`</ph> fault.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`WasHeaderNotUnderstood`</ph> returns <ph id="ph2">`true`</ph> if the header with the specified name and namespace is included in the fault as a NotUnderstood header.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>If a channel emits a header that is marked MustUnderstand = true, then that layer should also implement the Exception Generation API pattern and should convert <ph id="ph1">`mustUnderstand`</ph> faults caused by that header to a more useful exception as described previously.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Tracing</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The .NET Framework provides a mechanism to trace program execution as a way to aid diagnosing production applications or intermittent problems where it is not possible to just attach a debugger and step through the code.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The core components of this mechanism are in the <ph id="ph1">&lt;xref:System.Diagnostics?displayProperty=nameWithType&gt;</ph> namespace and consist of:</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Diagnostics.TraceSource?displayProperty=nameWithType&gt;</ph>, which is the source of trace information to be written, <ph id="ph2">&lt;xref:System.Diagnostics.TraceListener?displayProperty=nameWithType&gt;</ph>, which is an abstract base class for concrete listeners that receive the information to be traced from the <ph id="ph3">&lt;xref:System.Diagnostics.TraceSource&gt;</ph> and output it to a listener-specific destination.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">&lt;xref:System.Diagnostics.XmlWriterTraceListener&gt;</ph> outputs trace information to an XML file.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Finally, <ph id="ph1">&lt;xref:System.Diagnostics.TraceSwitch?displayProperty=nameWithType&gt;</ph>, which lets the application user control the tracing verbosity and is typically specified in configuration.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>In addition to the core components, you can use the <bpt id="p1">[</bpt>Service Trace Viewer Tool (SvcTraceViewer.exe)<ept id="p1">](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md)</ept> to view and search WCF traces.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The tool is designed specifically for trace files generated by WCF and written out using <ph id="ph1">&lt;xref:System.Diagnostics.XmlWriterTraceListener&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The following figure shows the various components involved in tracing.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Handling exceptions and faults<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wcf/extending/media/wcfc-tracinginchannelsc.gif "</bpt>wcfc_TracingInChannelsc<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Tracing from a Custom Channel</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Custom channels should write out trace messages to assist in diagnosing problems when it is not possible to attach a debugger to the running application.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>This involves two high level tasks: Instantiating a <ph id="ph1">&lt;xref:System.Diagnostics.TraceSource&gt;</ph> and calling its methods to write traces.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When instantiating a <ph id="ph1">&lt;xref:System.Diagnostics.TraceSource&gt;</ph>, the string you specify becomes the name of that source.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This name is used to configure (enable/disable/set tracing level) the trace source.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>It also appears in the trace output itself.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Custom channels should use a unique source name to help readers of the trace output understand where the trace information comes from.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Using the name of the assembly that is writing the information as the name of the trace source is the common practice.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For example, WCF uses System.ServiceModel as the trace source for information written from the System.ServiceModel assembly.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Once you have a trace source, you call its <ph id="ph1">&lt;xref:System.Diagnostics.TraceSource.TraceData%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Diagnostics.TraceSource.TraceEvent%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Diagnostics.TraceSource.TraceInformation%2A&gt;</ph> methods to write trace entries to the trace listeners.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>For each trace entry you write, you need to classify the type of event as one of the event types defined in <ph id="ph1">&lt;xref:System.Diagnostics.TraceEventType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>This classification and the trace level setting in configuration determine whether the trace entry is output to the listener.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>For example, setting the trace level in configuration to <ph id="ph1">`Warning`</ph> allows <ph id="ph2">`Warning`</ph>, <ph id="ph3">`Error`</ph> and <ph id="ph4">`Critical`</ph> trace entries to be written but blocks Information and Verbose entries.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Here is an example of instantiating a trace source and writing out an entry at Information level:</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you specify a trace source name that is unique to your custom channel to help trace output readers understand where the output came from.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Integrating with the Trace Viewer</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Traces generated by your channel can be output in a format readable by the <bpt id="p1">[</bpt>Service Trace Viewer Tool (SvcTraceViewer.exe)<ept id="p1">](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md)</ept> by using <ph id="ph1">&lt;xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=nameWithType&gt;</ph> as the trace listener.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>This is not something you, as the channel developer, need to do.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Rather, it is the application user (or the person troubleshooting the application) that needs to configure this trace listener in the application’s configuration file.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For example, the following configuration outputs trace information from both <ph id="ph1">&lt;xref:System.ServiceModel?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`Microsoft.Samples.Udp`</ph> to the file named <ph id="ph3">`TraceEventsFile.e2e`</ph>:</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Tracing Structured Data</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Diagnostics.TraceSource?displayProperty=nameWithType&gt;</ph> has a <ph id="ph2">&lt;xref:System.Diagnostics.TraceSource.TraceData%2A&gt;</ph> method that takes one or more objects that are to be included in the trace entry.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In general, the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method is called on each object and the resulting string is written as part of the trace entry.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>When using <ph id="ph1">&lt;xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=nameWithType&gt;</ph> to output traces, you can pass an <ph id="ph2">&lt;xref:System.Xml.XPath.IXPathNavigable?displayProperty=nameWithType&gt;</ph> as the data object to <ph id="ph3">&lt;xref:System.Diagnostics.TraceSource.TraceData%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>The resulting trace entry includes the XML provided by the <ph id="ph1">&lt;xref:System.Xml.XPath.XPathNavigator?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Here is an example entry with XML application data:</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The WCF trace viewer understands the schema of the <ph id="ph1">`TraceRecord`</ph> element shown previously and extracts the data from its child elements and displays it in a tabular format.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Your channel should use this schema when tracing structured application data to help Svctraceviewer.exe users read the data.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>