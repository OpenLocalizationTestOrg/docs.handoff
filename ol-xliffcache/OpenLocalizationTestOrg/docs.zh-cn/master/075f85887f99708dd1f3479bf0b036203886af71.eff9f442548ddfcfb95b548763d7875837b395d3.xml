{"content":"---\ntitle: \"Mapping Between JSON and XML\"\nms.date: \"03/30/2017\"\nms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af\n---\n# Mapping Between JSON and XML\nThe readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content. JSON encodes data using a subset of the object literals of JavaScript. The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.\n\nWhen initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML. The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content. The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.\n\nInternally, JSON is represented as an XML infoset when processed by WCF. Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML. The mapping means that XML APIs are used to access JSON content.\n\nWhen WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate. The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly. (It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)\n\nIn advanced scenarios, it may become necessary to directly access the following mapping. These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON. The JSON-XML mapping is also used for message logging. When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.\n\nTo clarify the concept of a mapping, the following example is of a JSON document.\n\n```json\n{\"product\":\"pencil\",\"price\":12}\n```\n\nTo read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.\n\n```xml\n<root type=\"object\">\n    <product type=\"string\">pencil</product>\n    <price type=\"number\">12</price>\n</root>\n```\n\nFurthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.\n\n## Mapping Between JSON and the XML Infoset\nFormally, the mapping is between JSON as described in [RFC 4627](https://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://go.microsoft.com/fwlink/?LinkId=98809) . See this topic for the definitions of *information items* and fields in [square brackets].\n\nA blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document. On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.\n\nThe mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON. The EII, or the DII’s [document element] property, is referred to as the Root JSON Element. Note that document fragments (XML with multiple root elements) are not supported in this mapping.\n\nExample: The following document:\n\n```xml\n<?xml version=\"1.0\"?>\n<root type=\"number\">42</root>`\n```\n\nAnd the following element:\n\n```xml\n<root type=\"number\">42</root>\n```\n\nBoth have a mapping to JSON. The <`root`> element is the Root JSON Element in both cases.\n\nFurthermore, in the case of a DII, the following should be considered:\n\n- Some items in the [children] list must not be present. Do not rely on this fact when reading XML mapped from JSON.\n\n- The [children] list holds no comment information items.\n\n- The [children] list holds no DTD information items.\n\n- The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)\n\n- The [notations] set is empty.\n\n- The [unparsed entities] set is empty.\n\nExample: The following document has no mapping to JSON because [children] holds a PI and a comment.\n\n```xml\n<?xml version=\"1.0\"?>\n<!--comment--><?pi?>\n<root type=\"number\">42</root>\n```\n\nThe EII for the Root JSON Element has the following characteristics:\n\n- [local name] has the value \"root\".\n\n- [namespace name] has no value.\n\n- [prefix] has no value.\n\n- [children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.\n\n- [attributes] may contain the following optional attribute information items (AIIs)\n\n- The JSON Type Attribute (\"type\") as described further. This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.\n\n- The Data Contract Name Attribute (\"\\_\\_type\") as described further. This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is \"object\". This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected. If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.\n\n- [in-scope namespaces] contains the binding of \"xml\" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification.\n\n- [children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.\n\nExample: The following document has no mapping to JSON because [namespace attributes] is not empty.\n\n```xml\n<?xml version=\"1.0\"?>\n<root xmlns:a=\"myattributevalue\">42</root>\n```\n\nThe AII for the JSON Type Attribute has the following characteristics:\n\n- [namespace name] has no value.\n- [prefix] has no value.\n- [local name] is \"type\".\n- [normalized value] is one of the possible type values described in the following section.\n- [specified] is `true`.\n- [attribute type] has no value.\n- [references] has no value.\n\nThe AII for the Data Contract Name Attribute has the following characteristics:\n\n- [namespace name] has no value.\n- [prefix] has no value.\n- [local name] is \"\\_\\_type\" (two underscores and then \"type\").\n- [normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.\n- [specified] is `true`.\n- [attribute type] has no value.\n- [references] has no value.\n\nInner elements contained within the Root JSON Element or other inner elements have the following characteristics:\n\n- [local name] may have any value as described further.\n- [namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.\n\nIn both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation. The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.\n\n|[normalized value] of JSON Type Attribute’s AII|Allowed [children] of the corresponding EII|Mapping to JSON|\n|---------------------------------------------------------|---------------------------------------------------|---------------------|\n|`string` (or absence of the JSON type AII)<br /><br /> A `string` and the absence of the JSON type AII are the same makes `string` the default.<br /><br /> So, `<root> string1</root>` maps to the JSON `string` \"string1\".|0 or more CIIs|A JSON `string` (JSON RFC, section 2.5). Each `char` is a character that corresponds to the [character code] from the CII. If there are no CIIs, it maps to an empty JSON `string`.<br /><br /> Example: The following element maps to a JSON fragment:<br /><br /> `<root type=\"string\">42</root>`<br /><br /> The JSON fragment is \"42\".<br /><br /> On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped. The \"/\" character is special – it is escaped even though it does not have to be (written out as \"\\\\/\").<br /><br /> Example: The following element maps to a JSON fragment.<br /><br /> `<root type=\"string\">the \"da/ta\"</root>`<br /><br /> The JSON fragment is \"the \\\\\"da\\\\/ta\\\\\"\".<br /><br /> On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].<br /><br /> Example: The JSON fragment \"\\u0041BC\", maps to the following XML element.<br /><br /> `<root type=\"string\">ABC</root>`<br /><br /> The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.<br /><br /> Example: The JSON fragment           \"ABC\", (there are spaces before the first double quote), maps to the following XML element.<br /><br /> `<root type=\"string\">ABC</root>`<br /><br /> Any white space in XML maps to white space in JSON.<br /><br /> Example: The following XML element maps to a JSON fragment.<br /><br /> `<root type=\"string\">  A BC      </root>`<br /><br /> The JSON fragment is \" A BC \".|\n|`number`|1 or more CIIs|A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space. Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.<br /><br /> Example: The following element maps to a JSON fragment.<br /><br /> `<root type=\"number\">    42</root>`<br /><br /> The JSON fragment is    42<br /><br /> (White space is preserved).|\n|`boolean`|4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.|A CII sequence that corresponds to the string \"true\" is mapped to the literal `true`, and a CII sequence that corresponds to the string \"false\" is mapped to the literal `false`. Surrounding white space is preserved.<br /><br /> Example: The following element maps to a JSON fragment.<br /><br /> `<root type=\"boolean\"> false</root>`<br /><br /> The JSON fragment is `false`.|\n|`null`|None allowed.|The literal `null`. On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.<br /><br /> Example: The following element maps to a JSON fragment.<br /><br /> `<root type=\"null\"/>`<br /><br /> or<br /><br /> `<root type=\"null\"></root>`<br /><br /> :<br /><br /> The JSON fragment in both cases is `Null`.|\n|`object`|0 or more EIIs.|A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further. If there is more than one EII, there are value-separators (commas) between the member records. All this is followed by an end-object (right curly brace).<br /><br /> Example: The following element maps to the JSON fragment.<br /><br /> `<root type=\"object\">`<br /><br /> `<type1 type=\"string\">aaa\\</type1>`<br /><br /> `<type2 type=\"string\">bbb\\</type2>`<br /><br /> `</root >`<br /><br /> The JSON fragment is `{\"type1\":\"aaa\",\"type2\":\"bbb\"}`.<br /><br /> If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning. Its name is the [local name] of the Data Contract Type Attribute (\"\\_\\_type\"), and its value is the attribute's [normalized value]. Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, \"\\_\\_type\"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present. Note that this member record must occur first in the JSON object for this special mapping to apply. This represents a departure from usual JSON processing, where the order of member records is not significant.<br /><br /> Example:<br /><br /> The following JSON fragment maps to XML.<br /><br /> `{\"__type\":\"Person\",\"name\":\"John\"}`<br /><br /> The XML is the following code.<br /><br /> `<root type=\"object\" __type=\"Person\">   <name type=\"string\">John</name> </root>`<br /><br /> Notice that the \\_\\_type AII is present, but there is no \\_\\_type EII.<br /><br /> However, if the order in the JSON is reversed as shown in the following example.<br /><br /> {\"name\":\"John\",\"\\_\\_type\":\"Person\"}<br /><br /> The corresponding XML is shown.<br /><br /> `<root type=\"object\">   <name type=\"string\">John</name>   <__type type=\"string\">Person</__type> </root>`<br /><br /> That is, \\__type ceases to have special meaning and maps to an EII as usual, not AII.<br /><br /> Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the \"string\" row of this table.<br /><br /> Example:<br /><br /> `<root type=\"object\" __type=\"\\abc\" />`<br /><br /> to the previous example can be mapped to the following JSON.<br /><br /> `{\"__type\":\"\\\\abc\"}`<br /><br /> On an XML to JSON mapping, the first EII’s [local name] must not be \"\\_\\_type\".<br /><br /> White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.<br /><br /> Example: The following JSON fragment maps to an XML element.<br /><br /> `{ \"ccc\" : \"aaa\", \"ddd\" :\"bbb\"}`<br /><br /> The XML element is shown in the following code.<br /><br /> `<root type=\"object\">    <ccc type=\"string\">aaa</ccc>    <ddd type=\"string\">bbb</bar> </root >`|\n|array|0 or more EIIs|A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further. If there is more than one EII, there are value-separators (commas) between the array records. All this is followed by an end-array.<br /><br /> Example: The following XML element maps to a JSON fragment.<br /><br /> `<root type=\"array\"/>    <item type=\"string\">aaa</item>    <item type=\"string\">bbb</item> </root >`<br /><br /> The JSON fragment is [\"aaa\",\"bbb\"]<br /><br /> White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.<br /><br /> Example: A JSON fragment.<br /><br />`[\"aaa\", \"bbb\"]`<br /><br /> The XML element that it maps to.<br /><br /> `<root type=\"array\"/>    <item type=\"string\">aaa</item>    <item type=\"string\">bbb</item> </root >`|\n\nMember Records work as follows:\n\n- Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.\n\nExample: The following element maps to a JSON fragment.\n\n`<root type=\"object\"/>`\n\n`<myLocalName type=\"string\">aaa</myLocalName>`\n\n`</root >`\n\nThe following JSON fragment is displayed.\n\n`{\"myLocalName\":\"aaa\"}`\n\n- On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped. The \"/\" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping). This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.\n\n- On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].\n\n- Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`. Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.\n\nExample: The following element maps to a JSON fragment.\n\n```xml\n<root type=\"object\">\n    <myLocalName1 type=\"string\">myValue1</myLocalName1>\n    <myLocalName2 type=\"number\">2</myLocalName2>\n    <myLocalName3 type=\"object\">\n        <myNestedName1 type=\"boolean\">true</myNestedName1>\n        <myNestedName2 type=\"null\"/>\n    </myLocalName3>\n</root >\n```\n\nThe following JSON fragment is what it maps to.\n\n`{\"myLocalName1\":\"myValue1\",\"myLocalName2\":2,\"myLocalName3\":{\"myNestedName1\":true,\"myNestedName2\":null}}`\n\n> [!NOTE]\n> There is no XML encoding step in the preceding mapping. Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names. For example, the JSON document {\"<\":\"a\"} is not supported because < is not a valid name for an XML element.\n\nThe reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.\n\nArray Records work as follows:\n\n- Inner element’s [local name] is \"item\".\n\n- Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element. Multiple levels of nesting of EIIs (including nesting within objects) are allowed.\n\nExample: The following element maps to a JSON fragment.\n\n```xml\n<root type=\"array\"/>\n    <item type=\"string\">myValue1</item>\n    <item type=\"number\">2</item>\n    <item type=\"array\">\n    <item type=\"boolean\">true</item>\n    <item type=\"null\"/></item>\n</root >\n```\n\nThe following is the JSON fragment.\n\n`[\"myValue1\",2,[true,null]]`\n\n## See also\n\n- <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>\n- <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>\n- [Stand-Alone JSON Serialization](stand-alone-json-serialization.md)","nodes":[{"pos":[4,112],"embed":true,"restype":"x-metadata","content":"title: \"Mapping Between JSON and XML\"\nms.date: \"03/30/2017\"\nms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af","nodes":[{"content":"Mapping Between JSON and XML","nodes":[{"pos":[0,28],"content":"Mapping Between JSON and XML","nodes":[{"content":"Mapping Between JSON and XML","pos":[0,28]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[119,147],"content":"Mapping Between JSON and XML","linkify":"Mapping Between JSON and XML","nodes":[{"content":"Mapping Between JSON and XML","pos":[0,28]}]},{"content":"The readers and writers produced by the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory&gt;</ph> provide an XML API over JavaScript Object Notation (JSON) content.","pos":[148,319],"source":"The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content."},{"content":"JSON encodes data using a subset of the object literals of JavaScript.","pos":[320,390]},{"content":"The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.ServiceModel.WebHttpBinding&gt;</ph>.","pos":[391,681],"source":" The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>."},{"content":"When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.","pos":[683,814]},{"content":"The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.","pos":[815,949]},{"content":"The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.","pos":[950,1069]},{"content":"Internally, JSON is represented as an XML infoset when processed by WCF.","pos":[1071,1143]},{"content":"Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.","pos":[1144,1346]},{"content":"The mapping means that XML APIs are used to access JSON content.","pos":[1347,1411]},{"content":"When WCF uses JSON, the usual scenario is that the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> is automatically plugged in by the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.WebScriptEnablingBehavior&gt;</ph> behavior, or by the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Description.WebHttpBehavior&gt;</ph> behavior when appropriate.","pos":[1413,1733],"source":"When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.","pos":[1734,1911],"source":" The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly."},{"content":"(It is possible to use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)","pos":[1912,2109],"source":" (It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)"},{"content":"In advanced scenarios, it may become necessary to directly access the following mapping.","pos":[2111,2199]},{"content":"These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph>, or when dealing with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> type directly for messages containing JSON.","pos":[2200,2490],"source":" These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON."},{"content":"The JSON-XML mapping is also used for message logging.","pos":[2491,2545]},{"content":"When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.","pos":[2546,2679]},{"content":"To clarify the concept of a mapping, the following example is of a JSON document.","pos":[2681,2762]},{"pos":[2809,3000],"content":"To read this JSON document using one of the readers previously mentioned, use the same sequence of <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> calls as you would to read the following XML document.","source":"To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document."},{"content":"Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.","pos":[3123,3254]},{"pos":[3259,3299],"content":"Mapping Between JSON and the XML Infoset","linkify":"Mapping Between JSON and the XML Infoset","nodes":[{"content":"Mapping Between JSON and the XML Infoset","pos":[0,40]}]},{"content":"Formally, the mapping is between JSON as described in <bpt id=\"p1\">[</bpt>RFC 4627<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=98808)</ept> (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in <bpt id=\"p2\">[</bpt>XML Information Set<ept id=\"p2\">](https://go.microsoft.com/fwlink/?LinkId=98809)</ept> .","pos":[3300,3620],"source":"Formally, the mapping is between JSON as described in [RFC 4627](https://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://go.microsoft.com/fwlink/?LinkId=98809) ."},{"content":"See this topic for the definitions of <bpt id=\"p1\">*</bpt>information items<ept id=\"p1\">*</ept> and fields in [square brackets].","pos":[3621,3711],"source":" See this topic for the definitions of *information items* and fields in [square brackets]."},{"content":"A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.","pos":[3713,3820]},{"content":"On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.","pos":[3821,3931]},{"content":"The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.","pos":[3933,4051]},{"content":"The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.","pos":[4052,4143]},{"content":"Note that document fragments (XML with multiple root elements) are not supported in this mapping.","pos":[4144,4241]},{"content":"Example: The following document:","pos":[4243,4275]},{"content":"And the following element:","pos":[4342,4368]},{"content":"Both have a mapping to JSON.","pos":[4412,4440]},{"content":"The &lt;<ph id=\"ph1\">`root`</ph>&gt; element is the Root JSON Element in both cases.","pos":[4441,4501],"source":" The <`root`> element is the Root JSON Element in both cases."},{"content":"Furthermore, in the case of a DII, the following should be considered:","pos":[4503,4573]},{"content":"Some items in the [children] list must not be present.","pos":[4577,4631]},{"content":"Do not rely on this fact when reading XML mapped from JSON.","pos":[4632,4691]},{"content":"The [children] list holds no comment information items.","pos":[4695,4750]},{"content":"The [children] list holds no DTD information items.","pos":[4754,4805]},{"pos":[4809,4949],"content":"The [children] list holds no personal Information (PI) information items (the <ph id=\"ph1\">`&lt;?xml…&gt;`</ph> declaration is not considered a PI information item)","source":"The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)"},{"content":"The [notations] set is empty.","pos":[4953,4982]},{"content":"The [unparsed entities] set is empty.","pos":[4986,5023]},{"content":"Example: The following document has no mapping to JSON because [children] holds a PI and a comment.","pos":[5025,5124]},{"content":"The EII for the Root JSON Element has the following characteristics:","pos":[5211,5279]},{"content":"[local name] has the value \"root\".","pos":[5283,5317]},{"content":"[namespace name] has no value.","pos":[5321,5351]},{"content":"[prefix] has no value.","pos":[5355,5377]},{"content":"[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.","pos":[5381,5560]},{"content":"[attributes] may contain the following optional attribute information items (AIIs)","pos":[5564,5646]},{"content":"The JSON Type Attribute (\"type\") as described further.","pos":[5650,5704]},{"content":"This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.","pos":[5705,5821]},{"content":"The Data Contract Name Attribute (\"<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type\") as described further.","pos":[5825,5892],"source":"The Data Contract Name Attribute (\"\\_\\_type\") as described further."},{"content":"This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is \"object\".","pos":[5893,6013]},{"content":"This attribute is used by the <ph id=\"ph1\">`DataContractJsonSerializer`</ph> to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.","pos":[6014,6221],"source":" This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected."},{"content":"If you are not working with the <ph id=\"ph1\">`DataContractJsonSerializer`</ph>, in most cases, this attribute is ignored.","pos":[6222,6325],"source":" If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored."},{"pos":[6329,6464],"content":"[in-scope namespaces] contains the binding of \"xml\" to <ph id=\"ph1\">`http://www.w3.org/XML/1998/namespace`</ph> as mandated by the infoset specification.","source":"[in-scope namespaces] contains the binding of \"xml\" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification."},{"content":"[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.","pos":[6468,6692]},{"content":"Example: The following document has no mapping to JSON because [namespace attributes] is not empty.","pos":[6694,6793]},{"content":"The AII for the JSON Type Attribute has the following characteristics:","pos":[6872,6942]},{"content":"[namespace name] has no value.","pos":[6946,6976]},{"content":"[prefix] has no value.","pos":[6979,7001]},{"content":"[local name] is \"type\".","pos":[7004,7027]},{"content":"[normalized value] is one of the possible type values described in the following section.","pos":[7030,7119]},{"pos":[7122,7144],"content":"[specified] is <ph id=\"ph1\">`true`</ph>.","source":"[specified] is `true`."},{"content":"[attribute type] has no value.","pos":[7147,7177]},{"content":"[references] has no value.","pos":[7180,7206]},{"content":"The AII for the Data Contract Name Attribute has the following characteristics:","pos":[7208,7287]},{"content":"[namespace name] has no value.","pos":[7291,7321]},{"content":"[prefix] has no value.","pos":[7324,7346]},{"content":"[local name] is \"<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type\" (two underscores and then \"type\").","pos":[7349,7410],"source":"[local name] is \"\\_\\_type\" (two underscores and then \"type\")."},{"content":"[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.","pos":[7413,7535]},{"pos":[7538,7560],"content":"[specified] is <ph id=\"ph1\">`true`</ph>.","source":"[specified] is `true`."},{"content":"[attribute type] has no value.","pos":[7563,7593]},{"content":"[references] has no value.","pos":[7596,7622]},{"content":"Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:","pos":[7624,7737]},{"content":"[local name] may have any value as described further.","pos":[7741,7794]},{"content":"[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.","pos":[7797,7956]},{"content":"In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.","pos":[7958,8117]},{"content":"The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.","pos":[8118,8225]},{"content":"[normalized value] of JSON Type Attribute’s AII","pos":[8228,8275]},{"content":"Allowed [children] of the corresponding EII","pos":[8276,8319]},{"content":"Mapping to JSON","pos":[8320,8335]},{"content":"<ph id=\"ph1\">`string`</ph> (or absence of the JSON type AII)","pos":[8472,8514],"source":"`string` (or absence of the JSON type AII)"},{"content":"A <ph id=\"ph1\">`string`</ph> and the absence of the JSON type AII are the same makes <ph id=\"ph2\">`string`</ph> the default.","pos":[8527,8615],"source":"A `string` and the absence of the JSON type AII are the same makes `string` the default."},{"content":"So, <ph id=\"ph1\">`&lt;root&gt; string1&lt;/root&gt;`</ph> maps to the JSON <ph id=\"ph2\">`string`</ph> \"string1\".","pos":[8628,8692],"source":"So, `<root> string1</root>` maps to the JSON `string` \"string1\"."},{"content":"0 or more CIIs","pos":[8693,8707]},{"content":"A JSON <ph id=\"ph1\">`string`</ph> (JSON RFC, section 2.5).","pos":[8708,8748],"source":"A JSON `string` (JSON RFC, section 2.5)."},{"content":"Each <ph id=\"ph1\">`char`</ph> is a character that corresponds to the [character code] from the CII.","pos":[8749,8830],"source":" Each `char` is a character that corresponds to the [character code] from the CII."},{"content":"If there are no CIIs, it maps to an empty JSON <ph id=\"ph1\">`string`</ph>.","pos":[8831,8887],"source":" If there are no CIIs, it maps to an empty JSON `string`."},{"content":"Example: The following element maps to a JSON fragment:","pos":[8900,8955]},{"content":"The JSON fragment is \"42\".","pos":[9012,9038]},{"content":"On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.","pos":[9051,9184]},{"content":"The \"/\" character is special – it is escaped even though it does not have to be (written out as \"<ph id=\"ph1\">\\\\</ph>/\").","pos":[9185,9288],"source":" The \"/\" character is special – it is escaped even though it does not have to be (written out as \"\\\\/\")."},{"content":"Example: The following element maps to a JSON fragment.","pos":[9301,9356]},{"content":"The JSON fragment is \"the <ph id=\"ph1\">\\\\</ph>\"da<ph id=\"ph2\">\\\\</ph>/ta<ph id=\"ph3\">\\\\</ph>\"\".","pos":[9422,9463],"source":"The JSON fragment is \"the \\\\\"da\\\\/ta\\\\\"\"."},{"content":"On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].","pos":[9476,9611]},{"content":"Example: The JSON fragment \"\\u0041BC\", maps to the following XML element.","pos":[9624,9697]},{"content":"The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.","pos":[9755,9867]},{"content":"Example: The JSON fragment           \"ABC\", (there are spaces before the first double quote), maps to the following XML element.","pos":[9880,10008]},{"content":"Any white space in XML maps to white space in JSON.","pos":[10066,10117]},{"content":"Example: The following XML element maps to a JSON fragment.","pos":[10130,10189]},{"content":"The JSON fragment is \" A BC \".","pos":[10256,10286]},{"content":"1 or more CIIs","pos":[10298,10312]},{"content":"A JSON <ph id=\"ph1\">`number`</ph> (JSON RFC, section 2.4), possibly surrounded by white space.","pos":[10313,10389],"source":"A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space."},{"content":"Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.","pos":[10390,10512]},{"content":"Example: The following element maps to a JSON fragment.","pos":[10525,10580]},{"content":"The JSON fragment is    42","pos":[10641,10667]},{"content":"(White space is preserved).","pos":[10680,10707]},{"pos":[10720,10825],"content":"4 or 5 CIIs (which corresponds to <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>), possibly surrounded by additional white-space CIIs.","source":"4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs."},{"content":"A CII sequence that corresponds to the string \"true\" is mapped to the literal <ph id=\"ph1\">`true`</ph>, and a CII sequence that corresponds to the string \"false\" is mapped to the literal <ph id=\"ph2\">`false`</ph>.","pos":[10826,11003],"source":"A CII sequence that corresponds to the string \"true\" is mapped to the literal `true`, and a CII sequence that corresponds to the string \"false\" is mapped to the literal `false`."},{"content":"Surrounding white space is preserved.","pos":[11004,11041]},{"content":"Example: The following element maps to a JSON fragment.","pos":[11054,11109]},{"content":"The JSON fragment is <ph id=\"ph1\">`false`</ph>.","pos":[11171,11200],"source":"The JSON fragment is `false`."},{"content":"None allowed.","pos":[11210,11223]},{"content":"The literal <ph id=\"ph1\">`null`</ph>.","pos":[11224,11243],"source":"The literal `null`."},{"content":"On JSON to XML mapping, the <ph id=\"ph1\">`null`</ph> may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.","pos":[11244,11364],"source":" On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML."},{"content":"Example: The following element maps to a JSON fragment.","pos":[11377,11432]},{"content":"or","pos":[11479,11481]},{"content":":","pos":[11534,11535]},{"content":"The JSON fragment in both cases is <ph id=\"ph1\">`Null`</ph>.","pos":[11548,11590],"source":"The JSON fragment in both cases is `Null`."},{"content":"0 or more EIIs.","pos":[11602,11617]},{"content":"A <ph id=\"ph1\">`begin-object`</ph> (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.","pos":[11618,11751],"source":"A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further."},{"content":"If there is more than one EII, there are value-separators (commas) between the member records.","pos":[11752,11846]},{"content":"All this is followed by an end-object (right curly brace).","pos":[11847,11905]},{"content":"Example: The following element maps to the JSON fragment.","pos":[11918,11975]},{"content":"The JSON fragment is <ph id=\"ph1\">`{\"type1\":\"aaa\",\"type2\":\"bbb\"}`</ph>.","pos":[12142,12195],"source":"The JSON fragment is `{\"type1\":\"aaa\",\"type2\":\"bbb\"}`."},{"content":"If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.","pos":[12208,12341]},{"content":"Its name is the [local name] of the Data Contract Type Attribute (\"<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type\"), and its value is the attribute's [normalized value].","pos":[12342,12473],"source":" Its name is the [local name] of the Data Contract Type Attribute (\"\\_\\_type\"), and its value is the attribute's [normalized value]."},{"content":"Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, \"<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type\"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.","pos":[12474,12737],"source":" Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, \"\\_\\_type\"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present."},{"content":"Note that this member record must occur first in the JSON object for this special mapping to apply.","pos":[12738,12837]},{"content":"This represents a departure from usual JSON processing, where the order of member records is not significant.","pos":[12838,12947]},{"content":"Example:","pos":[12960,12968]},{"content":"The following JSON fragment maps to XML.","pos":[12981,13021]},{"content":"The XML is the following code.","pos":[13082,13112]},{"content":"Notice that the <ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type AII is present, but there is no <ph id=\"ph3\">\\_</ph><ph id=\"ph4\">\\_</ph>type EII.","pos":[13218,13288],"source":"Notice that the \\_\\_type AII is present, but there is no \\_\\_type EII."},{"content":"However, if the order in the JSON is reversed as shown in the following example.","pos":[13301,13381]},{"content":"{\"name\":\"John\",\"<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type\":\"Person\"}","pos":[13394,13429],"source":"{\"name\":\"John\",\"\\_\\_type\":\"Person\"}"},{"content":"The corresponding XML is shown.","pos":[13442,13473]},{"content":"That is, <ph id=\"ph1\">\\_</ph>_type ceases to have special meaning and maps to an EII as usual, not AII.","pos":[13603,13688],"source":"That is, \\__type ceases to have special meaning and maps to an EII as usual, not AII."},{"content":"Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the \"string\" row of this table.","pos":[13701,13866]},{"content":"Example:","pos":[13879,13887]},{"content":"to the previous example can be mapped to the following JSON.","pos":[13951,14011]},{"content":"On an XML to JSON mapping, the first EII’s [local name] must not be \"<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\_</ph>type\".","pos":[14057,14136],"source":"On an XML to JSON mapping, the first EII’s [local name] must not be \"\\_\\_type\"."},{"content":"White space (<ph id=\"ph1\">`ws`</ph>) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.","pos":[14149,14260],"source":"White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping."},{"content":"Example: The following JSON fragment maps to an XML element.","pos":[14273,14333]},{"content":"The XML element is shown in the following code.","pos":[14391,14438]},{"content":"array","pos":[14549,14554]},{"content":"0 or more EIIs","pos":[14555,14569]},{"content":"A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.","pos":[14570,14703]},{"content":"If there is more than one EII, there are value-separators (commas) between the array records.","pos":[14704,14797]},{"content":"All this is followed by an end-array.","pos":[14798,14835]},{"content":"Example: The following XML element maps to a JSON fragment.","pos":[14848,14907]},{"content":"The JSON fragment is [\"aaa\",\"bbb\"]","pos":[15032,15066]},{"content":"White space (<ph id=\"ph1\">`ws`</ph>) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.","pos":[15079,15189],"source":"White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping."},{"content":"Example: A JSON fragment.","pos":[15202,15227]},{"content":"The XML element that it maps to.","pos":[15268,15300]},{"content":"Member Records work as follows:","pos":[15415,15446]},{"pos":[15450,15563],"content":"Inner element’s [local name] maps to the <ph id=\"ph1\">`string`</ph> part of the <ph id=\"ph2\">`member`</ph> as defined in section 2.2 of the JSON RFC.","source":"Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC."},{"content":"Example: The following element maps to a JSON fragment.","pos":[15565,15620]},{"content":"The following JSON fragment is displayed.","pos":[15707,15748]},{"content":"On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.","pos":[15777,15893]},{"content":"The \"/\" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).","pos":[15894,16049]},{"content":"This is required to support the ASP.NET AJAX format for <ph id=\"ph1\">`DateTime`</ph> data in JSON.","pos":[16050,16130],"source":" This is required to support the ASP.NET AJAX format for `DateTime` data in JSON."},{"pos":[16134,16288],"content":"On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a <ph id=\"ph1\">`string`</ph> that produces a [local name].","source":"On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name]."},{"content":"Inner elements [children] map to the value in section 2.2, according to the <ph id=\"ph1\">`JSON Type Attribute`</ph> just like for the <ph id=\"ph2\">`Root JSON Element`</ph>.","pos":[16292,16428],"source":"Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`."},{"content":"Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.","pos":[16429,16510]},{"content":"Example: The following element maps to a JSON fragment.","pos":[16512,16567]},{"content":"The following JSON fragment is what it maps to.","pos":[16865,16912]},{"pos":[17023,17317],"content":"[!NOTE]\nThere is no XML encoding step in the preceding mapping. Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names. For example, the JSON document {\"<\":\"a\"} is not supported because < is not a valid name for an XML element.","leadings":["","> "],"nodes":[{"content":"There is no XML encoding step in the preceding mapping. Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names. For example, the JSON document {\"<\":\"a\"} is not supported because < is not a valid name for an XML element.","pos":[8,292],"nodes":[{"content":"There is no XML encoding step in the preceding mapping.","pos":[0,55]},{"content":"Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.","pos":[56,176]},{"content":"For example, the JSON document {\"&lt;\":\"a\"} is not supported because &lt; is not a valid name for an XML element.","pos":[177,284],"source":" For example, the JSON document {\"<\":\"a\"} is not supported because < is not a valid name for an XML element."}]}]},{"content":"The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.","pos":[17319,17481]},{"content":"Array Records work as follows:","pos":[17483,17513]},{"content":"Inner element’s [local name] is \"item\".","pos":[17517,17556]},{"content":"Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.","pos":[17560,17694]},{"content":"Multiple levels of nesting of EIIs (including nesting within objects) are allowed.","pos":[17695,17777]},{"content":"Example: The following element maps to a JSON fragment.","pos":[17779,17834]},{"content":"The following is the JSON fragment.","pos":[18043,18078]},{"pos":[18113,18121],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[18262,18329],"content":"<bpt id=\"p1\">[</bpt>Stand-Alone JSON Serialization<ept id=\"p1\">](stand-alone-json-serialization.md)</ept>","source":"[Stand-Alone JSON Serialization](stand-alone-json-serialization.md)"}]}