<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="anchors-in-regular-expressions.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f0e42c0032dc6f9dac0895a29db9de79547c0a49</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\anchors-in-regular-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ceecaca2a3ef4761dc1b9fc977b3ed4ed0a3707e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">450d495683881ef697ab42c69a7b1ba0241ac22f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Anchors in .NET Regular Expressions</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn how to use anchors in regular expression patterns.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Anchors in Regular Expressions</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`^`</ph> specifies that the match must start at the beginning of a line or string.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression <ph id="ph1">`^http:`</ph> matches "http:" only when it occurs at the beginning of a line.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following table lists the anchors supported by the regular expressions in .NET.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Anchor</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>By default, the match must occur at the beginning of the string; in multiline mode, it must occur at the beginning of the line.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Start of String or Line<ept id="p1">](#Start)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>By default, the match must occur at the end of the string or before <ph id="ph1">`\n`</ph> at the end of the string; in multiline mode, it must occur at the end of the line or before <ph id="ph2">`\n`</ph> at the end of the line.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>End of String or Line<ept id="p1">](#End)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The match must occur at the beginning of the string only (no multiline support).</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Start of String Only<ept id="p1">](#StartOnly)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string, or before <ph id="ph1">`\n`</ph> at the end of the string.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>End of String or Before Ending Newline<ept id="p1">](#EndOrNOnly)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The match must occur at the end of the string only.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>End of String Only<ept id="p1">](#EndOnly)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The match must start at the position where the previous match ended.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Contiguous Matches<ept id="p1">](#Contiguous)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The match must occur on a word boundary.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Word Boundary<ept id="p1">](#WordBoundary)</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The match must not occur on a word boundary.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Non-Word Boundary<ept id="p1">](#NonwordBoundary)</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Start of String or Line: ^</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>By default, the <ph id="ph1">`^`</ph> anchor specifies that the following pattern must begin at the first character position of the string.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you use <ph id="ph1">`^`</ph> with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option (see <bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept>), the match must occur at the beginning of each line.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`^`</ph> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The example calls two overloads of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29&gt;</ph> overload finds only the first substring in the input string that matches the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29&gt;</ph> overload with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> finds all five substrings.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+`</ph> is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option).</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed either by zero or by one space exactly two times.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Match a comma followed by a white-space character.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a space, followed by one or more word characters.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This is the fourth capturing group.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Match a comma.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Match a space followed by four decimal digits.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is the sixth capturing group.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It also includes a seventh capturing group.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a comma.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This is the fifth capturing group.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>End of String or Line: $</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`$`</ph> anchor specifies that the preceding pattern must occur at the end of the input string, or before <ph id="ph2">`\n`</ph> at the end of the input string.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you use <ph id="ph1">`$`</ph> with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option, the match can also occur at the end of a line.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`$`</ph> matches <ph id="ph2">`\n`</ph> but does not match <ph id="ph3">`\r\n`</ph> (the combination of carriage return and newline characters, or CR/LF).</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To match the CR/LF character combination, include <ph id="ph1">`\r?$`</ph> in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example adds the <ph id="ph1">`$`</ph> anchor to the regular expression pattern used in the example in the <bpt id="p1">[</bpt>Start of String or Line<ept id="p1">](#Start)</ept> section.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When used with the original input string, which includes five lines of text, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method is unable to find a match, because the end of the first line does not match the <ph id="ph2">`$`</ph> pattern.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When the original input string is split into a string array, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method succeeds in matching each of the five lines.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method is called with the <ph id="ph2">`options`</ph> parameter set to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, when the regular expression pattern is modified by replacing <ph id="ph1">`$`</ph> with <ph id="ph2">`\r?$`</ph>, calling the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method with the <ph id="ph4">`options`</ph> parameter set to <ph id="ph5">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> again finds five matches.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Start of String Only: \A</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\A`</ph> anchor specifies that a match must occur at the beginning of the input string.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It is identical to the <ph id="ph1">`^`</ph> anchor, except that <ph id="ph2">`\A`</ph> ignores the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the start of the first line in a multiline input string.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following example is similar to the examples for the <ph id="ph1">`^`</ph> and <ph id="ph2">`$`</ph> anchors.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It uses the <ph id="ph1">`\A`</ph> anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The input string includes five lines.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The call to the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType&gt;</ph> method finds only the first substring in the input string that matches the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>As the example shows, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline&gt;</ph> option has no effect.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>End of String or Before Ending Newline: \Z</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\Z`</ph> anchor specifies that a match must occur at the end of the input string, or before <ph id="ph2">`\n`</ph> at the end of the input string.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It is identical to the <ph id="ph1">`$`</ph> anchor, except that <ph id="ph2">`\Z`</ph> ignores the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Therefore, in a multiline string, it can only match the end of the last line, or the last line before <ph id="ph1">`\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Note that <ph id="ph1">`\Z`</ph> matches <ph id="ph2">`\n`</ph> but does not match <ph id="ph3">`\r\n`</ph> (the CR/LF character combination).</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>To match CR/LF, include <ph id="ph1">`\r?\Z`</ph> in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`\Z`</ph> anchor in a regular expression that is similar to the example in the <bpt id="p1">[</bpt>Start of String or Line<ept id="p1">](#Start)</ept> section, which extracts information about the years during which some professional baseball teams existed.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The subexpression <ph id="ph1">`\r?\Z`</ph> in the regular expression <ph id="ph2">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z`</ph> matches the end of a string, and also matches a string that ends with <ph id="ph3">`\n`</ph> or <ph id="ph4">`\r\n`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>As a result, each element in the array matches the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>End of String Only: \z</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\z`</ph> anchor specifies that a match must occur at the end of the input string.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Like the <ph id="ph1">`$`</ph> language element, <ph id="ph2">`\z`</ph> ignores the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Unlike the <ph id="ph1">`\Z`</ph> language element, <ph id="ph2">`\z`</ph> does not match a <ph id="ph3">`\n`</ph> character at the end of a string.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Therefore, it can only match the last line of the input string.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`\z`</ph> anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The example tries to match each of five elements in a string array with the regular expression pattern <ph id="ph1">`^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>As the output shows, only the strings without a carriage return or line feed character match the pattern.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Contiguous Matches: \G</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\G`</ph> anchor specifies that a match must occur at the point where the previous match ended.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When you use this anchor with the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method, it ensures that all matches are contiguous.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\G(\w+\s?\w*),?`</ph> is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Begin where the last match ended.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Match zero or one space.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by zero or one space, followed by zero or more word characters.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Match zero or one occurrence of a literal comma character.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Word Boundary: \b</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\b`</ph> anchor specifies that the match must occur on a boundary between a word character (the <ph id="ph2">`\w`</ph> language element) and a non-word character (the <ph id="ph3">`\W`</ph> language element).</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>(For more information, see <bpt id="p1">[</bpt>Character Classes<ept id="p1">](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)</ept>.) The match may also occur on a word boundary at the beginning or end of the string.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\b`</ph> anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`\bare\w*\b`</ph> in the following example illustrates this usage.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>It matches any word that begins with the substring "are".</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The output from the example also illustrates that <ph id="ph1">`\b`</ph> matches both the beginning and the end of the input string.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Match the substring "are".</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Match zero or more word characters.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>End the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Non-Word Boundary: \B</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`\B`</ph> anchor specifies that the match must not occur on a word boundary.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It is the opposite of the <ph id="ph1">`\b`</ph> anchor.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`\B`</ph> anchor to locate occurrences of the substring "qu" in a word.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`\Bqu\w+`</ph> matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The regular expression pattern is interpreted as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Do not begin the match at a word boundary.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Match the substring "qu".</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Match one or more word characters.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept></source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular Expression Options<ept id="p1">](../../../docs/standard/base-types/regular-expression-options.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>