{"content":"---\ntitle: \"Differences Between C++ Templates and C# Generics - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generics [C#], vs. C++ templates\"\nms.assetid: 1da6beeb-d4a4-4da0-87b7-0cfbe04920b7\n---\n# Differences Between C++ Templates and C# Generics (C# Programming Guide)\nC# Generics and C++ templates are both language features that provide support for parameterized types. However, there are many differences between the two. At the syntax level, C# generics are a simpler approach to parameterized types without the complexity of C++ templates. In addition, C# does not attempt to provide all of the functionality that C++ templates provide. At the implementation level, the primary difference is that C# generic type substitutions are performed at runtime and generic type information is thereby preserved for instantiated objects. For more information, see [Generics in the Run Time](../../../csharp/programming-guide/generics/generics-in-the-run-time.md).  \n  \n The following are the key differences between C# Generics and C++ templates:  \n  \n-   C# generics do not provide the same amount of flexibility as C++ templates. For example, it is not possible to call arithmetic operators in a C# generic class, although it is possible to call user defined operators.  \n  \n-   C# does not allow non-type template parameters, such as `template C<int i> {}`.  \n  \n-   C# does not support explicit specialization; that is, a custom implementation of a template for a specific type.  \n  \n-   C# does not support partial specialization: a custom implementation for a subset of the type arguments.  \n  \n-   C# does not allow the type parameter to be used as the base class for the generic type.  \n  \n-   C# does not allow type parameters to have default types.  \n  \n-   In C#, a generic type parameter cannot itself be a generic, although constructed types can be used as generics. C++ does allow template parameters.  \n  \n-   C++ allows code that might not be valid for all type parameters in the template, which is then checked for the specific type used as the type parameter. C# requires code in a class to be written in such a way that it will work with any type that satisfies the constraints. For example, in C++ it is possible to write a function that uses the arithmetic operators `+` and `-` on objects of the type parameter, which will produce an error at the time of instantiation of the template with a type that does not support these operators. C# disallows this; the only language constructs allowed are those that can be deduced from the constraints.  \n  \n## See also\n\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)\n- [Templates](/cpp/cpp/templates-cpp)\n","nodes":[{"pos":[4,235],"embed":true,"restype":"x-metadata","content":"title: \"Differences Between C++ Templates and C# Generics - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"generics [C#], vs. C++ templates\"\nms.assetid: 1da6beeb-d4a4-4da0-87b7-0cfbe04920b7","nodes":[{"content":"Differences Between C++ Templates and C# Generics - C# Programming Guide","nodes":[{"pos":[0,72],"content":"Differences Between C++ Templates and C# Generics - C# Programming Guide","nodes":[{"content":"Differences Between C++ Templates and C# Generics - C# Programming Guide","pos":[0,72]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[242,314],"content":"Differences Between C++ Templates and C# Generics (C# Programming Guide)","linkify":"Differences Between C++ Templates and C# Generics (C# Programming Guide)","nodes":[{"content":"Differences Between C++ Templates and C# Generics (C# Programming Guide)","pos":[0,72]}]},{"content":"C# Generics and C++ templates are both language features that provide support for parameterized types.","pos":[315,417]},{"content":"However, there are many differences between the two.","pos":[418,470]},{"content":"At the syntax level, C# generics are a simpler approach to parameterized types without the complexity of C++ templates.","pos":[471,590]},{"content":"In addition, C# does not attempt to provide all of the functionality that C++ templates provide.","pos":[591,687]},{"content":"At the implementation level, the primary difference is that C# generic type substitutions are performed at runtime and generic type information is thereby preserved for instantiated objects.","pos":[688,878]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Generics in the Run Time<ept id=\"p1\">](../../../csharp/programming-guide/generics/generics-in-the-run-time.md)</ept>.","pos":[879,1004],"source":" For more information, see [Generics in the Run Time](../../../csharp/programming-guide/generics/generics-in-the-run-time.md)."},{"content":"The following are the key differences between C# Generics and C++ templates:","pos":[1011,1087]},{"content":"C# generics do not provide the same amount of flexibility as C++ templates.","pos":[1097,1172]},{"content":"For example, it is not possible to call arithmetic operators in a C# generic class, although it is possible to call user defined operators.","pos":[1173,1312]},{"pos":[1322,1401],"content":"C# does not allow non-type template parameters, such as <ph id=\"ph1\">`template C&lt;int i&gt; {}`</ph>.","source":"C# does not allow non-type template parameters, such as `template C<int i> {}`."},{"content":"C# does not support explicit specialization; that is, a custom implementation of a template for a specific type.","pos":[1411,1523]},{"content":"C# does not support partial specialization: a custom implementation for a subset of the type arguments.","pos":[1533,1636]},{"content":"C# does not allow the type parameter to be used as the base class for the generic type.","pos":[1646,1733]},{"content":"C# does not allow type parameters to have default types.","pos":[1743,1799]},{"content":"In C#, a generic type parameter cannot itself be a generic, although constructed types can be used as generics.","pos":[1809,1920]},{"content":"C++ does allow template parameters.","pos":[1921,1956]},{"content":"C++ allows code that might not be valid for all type parameters in the template, which is then checked for the specific type used as the type parameter.","pos":[1966,2118]},{"content":"C# requires code in a class to be written in such a way that it will work with any type that satisfies the constraints.","pos":[2119,2238]},{"content":"For example, in C++ it is possible to write a function that uses the arithmetic operators <ph id=\"ph1\">`+`</ph> and <ph id=\"ph2\">`-`</ph> on objects of the type parameter, which will produce an error at the time of instantiation of the template with a type that does not support these operators.","pos":[2239,2498],"source":" For example, in C++ it is possible to write a function that uses the arithmetic operators `+` and `-` on objects of the type parameter, which will produce an error at the time of instantiation of the template with a type that does not support these operators."},{"content":"C# disallows this; the only language constructs allowed are those that can be deduced from the constraints.","pos":[2499,2606]},{"pos":[2615,2623],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2627,2693],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[2696,2794],"content":"<bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept>","source":"[Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)"},{"pos":[2797,2832],"content":"<bpt id=\"p1\">[</bpt>Templates<ept id=\"p1\">](/cpp/cpp/templates-cpp)</ept>","source":"[Templates](/cpp/cpp/templates-cpp)"}]}