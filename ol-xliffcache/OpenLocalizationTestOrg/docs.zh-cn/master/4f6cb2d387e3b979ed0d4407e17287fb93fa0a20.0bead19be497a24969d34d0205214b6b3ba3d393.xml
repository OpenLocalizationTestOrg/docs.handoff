{"content":"---\ntitle: \"Interop with Other Asynchronous Patterns and Types\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \".NET Framework, and TAP\"\n  - \"asynchronous design patterns, .NET Framework\"\n  - \"TAP, .NET Framework support for\"\n  - \"Task-based Asynchronous Pattern, .NET Framework support for\"\n  - \".NET Framework, asynchronous design patterns\"\nms.assetid: f120a5d9-933b-4d1d-acb6-f034a57c3749\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Interop with Other Asynchronous Patterns and Types\nThe .NET Framework 1.0 introduced the <xref:System.IAsyncResult> pattern, otherwise known as the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md), or the `Begin/End` pattern.  The .NET Framework 2.0 added the [Event-based Asynchronous Pattern (EAP)](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md).  Starting with the .NET Framework 4, the [Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) supersedes both APM and EAP, but provides the ability to easily build migration routines from the earlier patterns.  \n  \n In this topic:  \n  \n-   [Tasks and APM](#APM) ([from APM to TAP](#ApmToTap) or [from TAP to APM](#TapToApm))  \n  \n-   [Tasks and EAP](#EAP)  \n  \n-   [Tasks and wait handles](#WaitHandles) ([from wait handles to TAP](#WHToTap) or [from TAP to wait handles](#TapToWH))  \n  \n<a name=\"APM\"></a>   \n## Tasks and the Asynchronous Programming Model (APM)  \n  \n<a name=\"ApmToTap\"></a>   \n### From APM to TAP  \n Because the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) pattern is very structured, it is quite easy to build a wrapper to expose an APM implementation as a TAP implementation. In fact, the .NET Framework, starting with [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], includes helper routines in the form of <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> method overloads to provide this translation.  \n  \n Consider the <xref:System.IO.Stream> class and its <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> methods, which represent the APM counterpart to the synchronous <xref:System.IO.Stream.Read%2A> method:  \n  \n [!code-csharp[Conceptual.AsyncInterop#1](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Stream1.cs#1)]\n [!code-vb[Conceptual.AsyncInterop#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/stream1.vb#1)]  \n[!code-csharp[Conceptual.AsyncInterop#2](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Stream1.cs#2)]\n[!code-vb[Conceptual.AsyncInterop#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/stream1.vb#2)]  \n[!code-csharp[Conceptual.AsyncInterop#3](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Stream1.cs#3)]\n[!code-vb[Conceptual.AsyncInterop#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/stream1.vb#3)]  \n  \n You can use the <xref:System.Threading.Tasks.TaskFactory%601.FromAsync%2A?displayProperty=nameWithType> method to implement a TAP wrapper for this operation as follows:  \n  \n [!code-csharp[Conceptual.AsyncInterop#4](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Wrap1.cs#4)]\n [!code-vb[Conceptual.AsyncInterop#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/Wrap1.vb#4)]  \n  \n This implementation is similar to the following:  \n  \n [!code-csharp[Conceptual.AsyncInterop#5](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Wrap2.cs#5)]\n [!code-vb[Conceptual.AsyncInterop#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/Wrap2.vb#5)]  \n  \n<a name=\"TapToApm\"></a>   \n### From TAP to APM  \n If your existing infrastructure expects the APM pattern, you'll also want to take a TAP implementation and use it where an APM implementation is expected.  Because tasks can be composed and  the <xref:System.Threading.Tasks.Task> class implements <xref:System.IAsyncResult>, you can use a straightforward helper function to do this. The following code uses an extension of the <xref:System.Threading.Tasks.Task%601> class, but you can use an almost identical function for non-generic tasks.  \n  \n [!code-csharp[Conceptual.AsyncInterop#6](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/APM1.cs#6)]\n [!code-vb[Conceptual.AsyncInterop#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/APM1.vb#6)]  \n  \n Now, consider a case where you have the following TAP implementation:  \n  \n [!code-csharp[Conceptual.AsyncInterop#7](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/APM2.cs#7)]\n [!code-vb[Conceptual.AsyncInterop#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/APM2.vb#7)]  \n  \n and you want to provide this APM implementation:  \n  \n [!code-csharp[Conceptual.AsyncInterop#8](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/APM2.cs#8)]\n [!code-vb[Conceptual.AsyncInterop#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/APM2.vb#8)]  \n[!code-csharp[Conceptual.AsyncInterop#9](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/APM2.cs#9)]\n[!code-vb[Conceptual.AsyncInterop#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/APM2.vb#9)]  \n  \n The following example demonstrates one migration to APM:  \n  \n [!code-csharp[Conceptual.AsyncInterop#10](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/APM2.cs#10)]\n [!code-vb[Conceptual.AsyncInterop#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/APM2.vb#10)]  \n  \n<a name=\"EAP\"></a>   \n## Tasks and the Event-based Asynchronous Pattern (EAP)  \n Wrapping an [Event-based Asynchronous Pattern (EAP)](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md) implementation is more involved than wrapping an APM pattern, because the EAP pattern has more variation and less structure than the APM pattern.  To demonstrate, the following code wraps the `DownloadStringAsync` method.  `DownloadStringAsync` accepts a URI, raises the `DownloadProgressChanged` event while downloading in order to report multiple statistics on progress, and raises the `DownloadStringCompleted` event when it's done.  The final result is a string that contains the contents of the page at the specified URI.  \n  \n [!code-csharp[Conceptual.AsyncInterop#11](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/EAP1.cs#11)]\n [!code-vb[Conceptual.AsyncInterop#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/EAP1.vb#11)]  \n  \n<a name=\"WaitHandles\"></a>   \n## Tasks and Wait Handles  \n  \n<a name=\"WHToTap\"></a>   \n### From Wait Handles to TAP  \n Although wait handles don't implement an asynchronous pattern, advanced developers may use the <xref:System.Threading.WaitHandle> class and the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> method for asynchronous notifications when a wait handle is set.  You can wrap the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to enable a task-based alternative to any synchronous wait on a wait handle:  \n  \n [!code-csharp[Conceptual.AsyncInterop#12](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Wait1.cs#12)]\n [!code-vb[Conceptual.AsyncInterop#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/Wait1.vb#12)]  \n  \n With this method, you can use existing <xref:System.Threading.WaitHandle> implementations in asynchronous methods.  For example, if you want to throttle the number of asynchronous operations that are executing at any particular time, you can utilize a semaphore (a <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> object).  You can throttle to *N* the number of operations that run concurrently by initializing the semaphore’s count to *N*, waiting on the semaphore any time you want to perform an operation, and releasing the semaphore when you’re done with an operation:  \n  \n [!code-csharp[Conceptual.AsyncInterop#13](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Semaphore1.cs#13)]\n [!code-vb[Conceptual.AsyncInterop#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/Semaphore1.vb#13)]  \n  \n You can also build an asynchronous semaphore that does not rely on wait handles and instead works completely with tasks. To do this, you can use techniques such as those discussed in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md) for building data structures on top of <xref:System.Threading.Tasks.Task>.  \n  \n<a name=\"TapToWH\"></a>   \n### From TAP to Wait Handles  \n As previously mentioned, the <xref:System.Threading.Tasks.Task> class implements <xref:System.IAsyncResult>, and that implementation exposes an <xref:System.Threading.Tasks.Task.System%23IAsyncResult%23AsyncWaitHandle%2A> property that returns a wait handle that will be set when the <xref:System.Threading.Tasks.Task> completes.  You can get a <xref:System.Threading.WaitHandle> for a <xref:System.Threading.Tasks.Task> as follows:  \n  \n [!code-csharp[Conceptual.AsyncInterop#14](../../../samples/snippets/csharp/VS_Snippets_CLR/Conceptual.AsyncInterop/cs/Wait1.cs#14)]\n [!code-vb[Conceptual.AsyncInterop#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/Conceptual.AsyncInterop/vb/Wait1.vb#14)]  \n  \n## See also\n\n- [Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)\n- [Implementing the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)\n- [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)\n","nodes":[{"pos":[4,497],"embed":true,"restype":"x-metadata","content":"title: \"Interop with Other Asynchronous Patterns and Types\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \".NET Framework, and TAP\"\n  - \"asynchronous design patterns, .NET Framework\"\n  - \"TAP, .NET Framework support for\"\n  - \"Task-based Asynchronous Pattern, .NET Framework support for\"\n  - \".NET Framework, asynchronous design patterns\"\nms.assetid: f120a5d9-933b-4d1d-acb6-f034a57c3749\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Interop with Other Asynchronous Patterns and Types","nodes":[{"pos":[0,50],"content":"Interop with Other Asynchronous Patterns and Types","nodes":[{"content":"Interop with Other Asynchronous Patterns and Types","pos":[0,50]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[504,554],"content":"Interop with Other Asynchronous Patterns and Types","linkify":"Interop with Other Asynchronous Patterns and Types","nodes":[{"content":"Interop with Other Asynchronous Patterns and Types","pos":[0,50]}]},{"content":"The .NET Framework 1.0 introduced the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> pattern, otherwise known as the <bpt id=\"p1\">[</bpt>Asynchronous Programming Model (APM)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)</ept>, or the <ph id=\"ph2\">`Begin/End`</ph> pattern.","pos":[555,815],"source":"The .NET Framework 1.0 introduced the <xref:System.IAsyncResult> pattern, otherwise known as the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md), or the `Begin/End` pattern."},{"content":"The .NET Framework 2.0 added the <bpt id=\"p1\">[</bpt>Event-based Asynchronous Pattern (EAP)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)</ept>.","pos":[817,989],"source":"  The .NET Framework 2.0 added the [Event-based Asynchronous Pattern (EAP)](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)."},{"content":"Starting with the .NET Framework 4, the <bpt id=\"p1\">[</bpt>Task-based Asynchronous Pattern (TAP)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> supersedes both APM and EAP, but provides the ability to easily build migration routines from the earlier patterns.","pos":[991,1283],"source":"  Starting with the .NET Framework 4, the [Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) supersedes both APM and EAP, but provides the ability to easily build migration routines from the earlier patterns."},{"content":"In this topic:","pos":[1290,1304]},{"pos":[1314,1398],"content":"<bpt id=\"p1\">[</bpt>Tasks and APM<ept id=\"p1\">](#APM)</ept> (<bpt id=\"p2\">[</bpt>from APM to TAP<ept id=\"p2\">](#ApmToTap)</ept> or <bpt id=\"p3\">[</bpt>from TAP to APM<ept id=\"p3\">](#TapToApm)</ept>)","source":"[Tasks and APM](#APM) ([from APM to TAP](#ApmToTap) or [from TAP to APM](#TapToApm))"},{"pos":[1408,1429],"content":"<bpt id=\"p1\">[</bpt>Tasks and EAP<ept id=\"p1\">](#EAP)</ept>","source":"[Tasks and EAP](#EAP)"},{"pos":[1439,1556],"content":"<bpt id=\"p1\">[</bpt>Tasks and wait handles<ept id=\"p1\">](#WaitHandles)</ept> (<bpt id=\"p2\">[</bpt>from wait handles to TAP<ept id=\"p2\">](#WHToTap)</ept> or <bpt id=\"p3\">[</bpt>from TAP to wait handles<ept id=\"p3\">](#TapToWH)</ept>)","source":"[Tasks and wait handles](#WaitHandles) ([from wait handles to TAP](#WHToTap) or [from TAP to wait handles](#TapToWH))"},{"pos":[1587,1637],"content":"Tasks and the Asynchronous Programming Model (APM)","linkify":"Tasks and the Asynchronous Programming Model (APM)","nodes":[{"content":"Tasks and the Asynchronous Programming Model (APM)","pos":[0,50]}]},{"pos":[1674,1689],"content":"From APM to TAP","linkify":"From APM to TAP","nodes":[{"content":"From APM to TAP","pos":[0,15]}]},{"content":"Because the <bpt id=\"p1\">[</bpt>Asynchronous Programming Model (APM)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)</ept> pattern is very structured, it is quite easy to build a wrapper to expose an APM implementation as a TAP implementation.","pos":[1693,1960],"source":"Because the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) pattern is very structured, it is quite easy to build a wrapper to expose an APM implementation as a TAP implementation."},{"content":"In fact, the .NET Framework, starting with <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, includes helper routines in the form of <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskFactory.FromAsync%2A&gt;</ph> method overloads to provide this translation.","pos":[1961,2210],"source":" In fact, the .NET Framework, starting with [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], includes helper routines in the form of <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> method overloads to provide this translation."},{"pos":[2217,2447],"content":"Consider the <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph> class and its <ph id=\"ph2\">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> methods, which represent the APM counterpart to the synchronous <ph id=\"ph4\">&lt;xref:System.IO.Stream.Read%2A&gt;</ph> method:","source":"Consider the <xref:System.IO.Stream> class and its <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> methods, which represent the APM counterpart to the synchronous <xref:System.IO.Stream.Read%2A> method:"},{"pos":[3260,3428],"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskFactory%601.FromAsync%2A?displayProperty=nameWithType&gt;</ph> method to implement a TAP wrapper for this operation as follows:","source":"You can use the <xref:System.Threading.Tasks.TaskFactory%601.FromAsync%2A?displayProperty=nameWithType> method to implement a TAP wrapper for this operation as follows:"},{"content":"This implementation is similar to the following:","pos":[3703,3751]},{"pos":[4056,4071],"content":"From TAP to APM","linkify":"From TAP to APM","nodes":[{"content":"From TAP to APM","pos":[0,15]}]},{"content":"If your existing infrastructure expects the APM pattern, you'll also want to take a TAP implementation and use it where an APM implementation is expected.","pos":[4075,4229]},{"content":"Because tasks can be composed and  the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph>, you can use a straightforward helper function to do this.","pos":[4231,4407],"source":"  Because tasks can be composed and  the <xref:System.Threading.Tasks.Task> class implements <xref:System.IAsyncResult>, you can use a straightforward helper function to do this."},{"content":"The following code uses an extension of the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class, but you can use an almost identical function for non-generic tasks.","pos":[4408,4565],"source":" The following code uses an extension of the <xref:System.Threading.Tasks.Task%601> class, but you can use an almost identical function for non-generic tasks."},{"content":"Now, consider a case where you have the following TAP implementation:","pos":[4838,4907]},{"content":"and you want to provide this APM implementation:","pos":[5180,5228]},{"content":"The following example demonstrates one migration to APM:","pos":[5762,5818]},{"pos":[6119,6171],"content":"Tasks and the Event-based Asynchronous Pattern (EAP)","linkify":"Tasks and the Event-based Asynchronous Pattern (EAP)","nodes":[{"content":"Tasks and the Event-based Asynchronous Pattern (EAP)","pos":[0,52]}]},{"content":"Wrapping an <bpt id=\"p1\">[</bpt>Event-based Asynchronous Pattern (EAP)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)</ept> implementation is more involved than wrapping an APM pattern, because the EAP pattern has more variation and less structure than the APM pattern.","pos":[6175,6471],"source":"Wrapping an [Event-based Asynchronous Pattern (EAP)](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md) implementation is more involved than wrapping an APM pattern, because the EAP pattern has more variation and less structure than the APM pattern."},{"content":"To demonstrate, the following code wraps the <ph id=\"ph1\">`DownloadStringAsync`</ph> method.","pos":[6473,6547],"source":"  To demonstrate, the following code wraps the `DownloadStringAsync` method."},{"content":"<ph id=\"ph1\">`DownloadStringAsync`</ph> accepts a URI, raises the <ph id=\"ph2\">`DownloadProgressChanged`</ph> event while downloading in order to report multiple statistics on progress, and raises the <ph id=\"ph3\">`DownloadStringCompleted`</ph> event when it's done.","pos":[6549,6761],"source":"`DownloadStringAsync` accepts a URI, raises the `DownloadProgressChanged` event while downloading in order to report multiple statistics on progress, and raises the `DownloadStringCompleted` event when it's done."},{"content":"The final result is a string that contains the contents of the page at the specified URI.","pos":[6763,6852]},{"pos":[7161,7183],"content":"Tasks and Wait Handles","linkify":"Tasks and Wait Handles","nodes":[{"content":"Tasks and Wait Handles","pos":[0,22]}]},{"pos":[7219,7243],"content":"From Wait Handles to TAP","linkify":"From Wait Handles to TAP","nodes":[{"content":"From Wait Handles to TAP","pos":[0,24]}]},{"content":"Although wait handles don't implement an asynchronous pattern, advanced developers may use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class and the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType&gt;</ph> method for asynchronous notifications when a wait handle is set.","pos":[7247,7550],"source":"Although wait handles don't implement an asynchronous pattern, advanced developers may use the <xref:System.Threading.WaitHandle> class and the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=nameWithType> method for asynchronous notifications when a wait handle is set."},{"content":"You can wrap the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt;</ph> method to enable a task-based alternative to any synchronous wait on a wait handle:","pos":[7552,7718],"source":"  You can wrap the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to enable a task-based alternative to any synchronous wait on a wait handle:"},{"content":"With this method, you can use existing <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> implementations in asynchronous methods.","pos":[7997,8111],"source":"With this method, you can use existing <xref:System.Threading.WaitHandle> implementations in asynchronous methods."},{"content":"For example, if you want to throttle the number of asynchronous operations that are executing at any particular time, you can utilize a semaphore (a <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType&gt;</ph> object).","pos":[8113,8337],"source":"  For example, if you want to throttle the number of asynchronous operations that are executing at any particular time, you can utilize a semaphore (a <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> object)."},{"content":"You can throttle to <bpt id=\"p1\">*</bpt>N<ept id=\"p1\">*</ept> the number of operations that run concurrently by initializing the semaphore’s count to <bpt id=\"p2\">*</bpt>N<ept id=\"p2\">*</ept>, waiting on the semaphore any time you want to perform an operation, and releasing the semaphore when you’re done with an operation:","pos":[8339,8587],"source":"  You can throttle to *N* the number of operations that run concurrently by initializing the semaphore’s count to *N*, waiting on the semaphore any time you want to perform an operation, and releasing the semaphore when you’re done with an operation:"},{"content":"You can also build an asynchronous semaphore that does not rely on wait handles and instead works completely with tasks.","pos":[8876,8996]},{"content":"To do this, you can use techniques such as those discussed in <bpt id=\"p1\">[</bpt>Consuming the Task-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)</ept> for building data structures on top of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>.","pos":[8997,9288],"source":" To do this, you can use techniques such as those discussed in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md) for building data structures on top of <xref:System.Threading.Tasks.Task>."},{"pos":[9324,9348],"content":"From TAP to Wait Handles","linkify":"From TAP to Wait Handles","nodes":[{"content":"From TAP to Wait Handles","pos":[0,24]}]},{"content":"As previously mentioned, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph>, and that implementation exposes an <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task.System%23IAsyncResult%23AsyncWaitHandle%2A&gt;</ph> property that returns a wait handle that will be set when the <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> completes.","pos":[9352,9681],"source":"As previously mentioned, the <xref:System.Threading.Tasks.Task> class implements <xref:System.IAsyncResult>, and that implementation exposes an <xref:System.Threading.Tasks.Task.System%23IAsyncResult%23AsyncWaitHandle%2A> property that returns a wait handle that will be set when the <xref:System.Threading.Tasks.Task> completes."},{"content":"You can get a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> for a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> as follows:","pos":[9683,9784],"source":"  You can get a <xref:System.Threading.WaitHandle> for a <xref:System.Threading.Tasks.Task> as follows:"},{"pos":[10065,10073],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10077,10213],"content":"<bpt id=\"p1\">[</bpt>Task-based Asynchronous Pattern (TAP)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>","source":"[Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)"},{"pos":[10216,10376],"content":"<bpt id=\"p1\">[</bpt>Implementing the Task-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)</ept>","source":"[Implementing the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)"},{"pos":[10379,10533],"content":"<bpt id=\"p1\">[</bpt>Consuming the Task-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)</ept>","source":"[Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)"}]}