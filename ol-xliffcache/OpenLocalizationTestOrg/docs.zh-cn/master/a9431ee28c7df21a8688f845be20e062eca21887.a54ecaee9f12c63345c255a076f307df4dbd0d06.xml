{"content":"---\ntitle: Create a .NET Core application with plugins\ndescription: Learn how to create a .NET Core application that supports plugins.\nauthor: jkoritzinsky\nms.author: jekoritz\nms.date: 01/28/2019\n---\n\n# Create a .NET Core application with plugins\n\nThis tutorial shows you how to:\n\n- Structure a project to support plugins.\n- Create a custom <xref:System.Runtime.Loader.AssemblyLoadContext> to load each plugin.\n- Use the `System.Runtime.Loader.AssemblyDependencyResolver` type to allow plugins to have dependencies.\n- Author plugins that can be easily deployed by just copying the build artifacts.\n\n## Prerequisites\n\n- Install the [.NET Core 3.0 Preview 2 SDK](https://www.microsoft.com/net/core) or a newer version.\n\n## Create the application\n\nThe first step is to create the application:\n\n1. Create a new folder, and in that folder run `dotnet new console -o AppWithPlugin`. \n2. To make building the project easier, create a Visual Studio solution file. Run `dotnet new sln` in the same folder. \n3. Run `dotnet sln add AppWithPlugin/AppWithPlugin.csproj` to add the app project to the solution.\n\nNow we can fill in the skeleton of our application. Replace the code in the *AppWithPlugin/Program.cs* file with the following code:\n\n```csharp\nusing PluginBase;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\n\nnamespace AppWithPlugin\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            try\n            {\n                if (args.Length == 1 && args[0] == \"/d\")\n                {\n                    Console.WriteLine(\"Waiting for any key...\");\n                    Console.ReadLine();\n                }\n\n                // Load commands from plugins.\n\n                if (args.Length == 0)\n                {\n                    Console.WriteLine(\"Commands: \");\n                    // Output the loaded commands.\n                }\n                else\n                {\n                    foreach (string commandName in args)\n                    {\n                        Console.WriteLine($\"-- {commandName} --\");\n\n                        // Execute the command with the name passed as an argument.\n\n                        Console.WriteLine();\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex);\n            }\n        }\n    }\n}\n\n```\n\n## Create the plugin interfaces\n\nThe next step in building an app with plugins is defining the interface the plugins need to implement. We suggest that you make a class library that contains any types that you plan to use for communicating between your app and plugins. This division allows you to publish your plugin interface as a package without having to ship your full application.\n\nIn the root folder of the project, run `dotnet new classlib -o PluginBase`. Also, run `dotnet sln add PluginBase/PluginBase.csproj` to add the project to the solution file. Delete the `PluginBase/Class1.cs` file, and create a new file in the `PluginBase` folder named `ICommand.cs` with the following interface definition:\n\n[!code-csharp[the-plugin-interface](~/samples/core/extensions/AppWithPlugin/PluginBase/ICommand.cs)]\n\nThis `ICommand` interface is the interface that all of the plugins will implement.\n\nNow that the `ICommand` interface is defined, the application project can be filled in a little more. Add a reference from the `AppWithPlugin` project to the `PluginBase` project with the `dotnet add AppWithPlugin\\AppWithPlugin.csproj reference PluginBase\\PluginBase.csproj`  command from the root folder.\n\nReplace the `// Load commands from plugins` comment with the following code snippet to enable it to load plugins from given file paths:\n\n```csharp\nstring[] pluginPaths = new string[]\n{\n    // Paths to plugins to load.\n};\n\nIEnumerable<ICommand> commands = pluginPaths.SelectMany(pluginPath =>\n{\n    Assembly pluginAssembly = LoadPlugin(pluginPath);\n    return CreateCommands(pluginAssembly);\n}).ToList();\n```\n\nThen replace the `// Output the loaded commands` comment with the following code snippet:\n\n```csharp\nforeach (ICommand command in commands)\n{\n    Console.WriteLine($\"{command.Name}\\t - {command.Description}\");\n}\n```\n\nReplace the `// Execute the command with the name passed as an argument` comment with the following snippet:\n\n```csharp\nICommand command = commands.FirstOrDefault(c => c.Name == commandName);\nif (command == null)\n{\n    Console.WriteLine(\"No such command is known.\");\n    return;\n}\n\ncommand.Execute();\n```\n\nAnd finally, add static methods to the `Program` class named `LoadPlugin` and `CreateCommands`, as shown here:\n\n```csharp\nstatic Assembly LoadPlugin(string relativePath)\n{\n    throw new NotImplementedException();\n}\n\nstatic IEnumerable<ICommand> CreateCommands(Assembly assembly)\n{\n    int count = 0;\n\n    foreach (Type type in assembly.GetTypes())\n    {\n        if (typeof(ICommand).IsAssignableFrom(type))\n        {\n            ICommand result = Activator.CreateInstance(type) as ICommand;\n            if (result != null)\n            {\n                count++;\n                yield return result;\n            }\n        }\n    }\n\n    if (count == 0)\n    {\n        string availableTypes = string.Join(\",\", assembly.GetTypes().Select(t => t.FullName));\n        throw new ApplicationException(\n            $\"Can't find any type which implements ICommand in {assembly} from {assembly.Location}.\\n\" +\n            $\"Available types: {availableTypes}\");\n    }\n}\n```\n\n## Load plugins\n\nNow the application can correctly load and instantiate commands from loaded plugin assemblies, but it is still unable to load the plugin assemblies. Create a file named *PluginLoadContext.cs* in the *AppWithPlugin* folder with the following contents:\n\n[!code-csharp[loading-plugins](~/samples/core/extensions/AppWithPlugin/AppWithPlugin/PluginLoadContext.cs)]\n\nThe `PluginLoadContext` type derives from <xref:System.Runtime.Loader.AssemblyLoadContext>. The `AssemblyLoadContext` type is a special type in the runtime that allows developers to isolate loaded assemblies into different groups to ensure that assembly versions do not conflict. Additionally, a custom `AssemblyLoadContext` can choose different paths to load assemblies from and override the default behavior. The `PluginLoadContext` uses an instance of the `AssemblyDependencyResolver` type introduced in .NET Core 3.0 to resolve assembly names to paths. The `AssemblyDependencyResolver` object is constructed with the path to a .NET class library. It resolves assemblies and native libraries to their relative paths based on the *deps.json* file for the class library whose path was passed to the `AssemblyDependencyResolver` constructor. The custom `AssemblyLoadContext` enables plugins to have their own dependencies, and the `AssemblyDependencyResolver` makes it easy to correctly load the dependencies.\n\nNow that the `AppWithPlugin` project has the `PluginLoadContext` type, update the `Program.LoadPlugin` method with the following body:\n\n```csharp\nstatic Assembly LoadPlugin(string relativePath)\n{\n    // Navigate up to the solution root\n    string root = Path.GetFullPath(Path.Combine(\n        Path.GetDirectoryName(\n            Path.GetDirectoryName(\n                Path.GetDirectoryName(\n                    Path.GetDirectoryName(\n                        Path.GetDirectoryName(typeof(Program).Assembly.Location)))))));\n\n    string pluginLocation = Path.GetFullPath(Path.Combine(root, relativePath.Replace('\\\\', Path.DirectorySeparatorChar)));\n    Console.WriteLine($\"Loading commands from: {pluginLocation}\");\n    PluginLoadContext loadContext = new PluginLoadContext(pluginLocation);\n    return loadContext.LoadFromAssemblyName(new AssemblyName(Path.GetFileNameWithoutExtension(pluginLocation)));\n}\n```\n\nBy using a different `PluginLoadContext` instance for each plugin, the plugins can have different or even conflicting dependencies without issue.\n\n## Create a simple plugin with no dependencies\n\nBack in the root folder, do the following:\n\n1. Run `dotnet new classlib -o HelloPlugin` to create a new class library project named `HelloPlugin`.\n2. Run `dotnet sln add HelloPlugin/HelloPlugin.csproj` to add the project to the `AppWithPlugin` solution. \n3. Replace the *HelloPlugin/Class1.cs* file with a file named *HelloCommand.cs* with the following contents:\n\n[!code-csharp[the-hello-plugin](~/samples/core/extensions/AppWithPlugin/HelloPlugin/HelloCommand.cs)]\n\nNow, open the *HelloPlugin.csproj* file. It should look similar to the following:\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.0</TargetFramework>\n  </PropertyGroup>\n\n</Project>\n\n```\n\nIn between the `<Project>` tags, add the following elements:\n\n```xml\n<ItemGroup>\n<ProjectReference Include=\"..\\PluginBase\\PluginBase.csproj\">\n    <Private>false</Private>\n</ProjectReference>\n</ItemGroup>\n```\n\nThe `<Private>false</Private>` element is very important. This tells MSBuild to not copy *PluginBase.dll* to the output directory for HelloPlugin. If the *PluginBase.dll* assembly is present in the output directory, `PluginLoadContext` will find the assembly there and load it when it loads the *HelloPlugin.dll* assembly. At this point, the `HelloPlugin.HelloCommand` type will implement the `ICommand` interface from the *PluginBase.dll* in the output directory of the `HelloPlugin` project, not the `ICommand` interface that is loaded into the default load context. Since the runtime sees these two types as different types from different assemblies, the `AppWithPlugin.Program.CreateCommands` method will not find the commands. As a result, the `<Private>false</Private>` metadata is required for the reference to the assembly containing the plugin interfaces.\n\nNow that the `HelloPlugin` project is complete, we should update the `AppWithPlugin` project to know where the `HelloPlugin` plugin can be found. After the `// Paths to plugins to load` comment, add `@\"HelloPlugin\\bin\\Debug\\netcoreapp3.0\\HelloPlugin.dll\"` as an element of the `pluginPaths` array.\n\n## Create a plugin with library dependencies\n\nAlmost all plugins are more complex than a simple \"Hello World\", and many plugins have dependencies on other libraries. The `JsonPlugin` and `OldJson` plugin projects in the sample show two examples of plugins with NuGet package dependencies on `Newtonsoft.Json`. The project files themselves do not have any special information for the project references, and (after adding the plugin paths to the `pluginPaths` array) the plugins run perfectly, even if run in the same execution of the AppWithPlugin app. However, these projects do not copy the referenced assemblies to their output directory, so the assemblies need to be present on the user's machine for the plugins to work. There are two ways to work around this problem. The first option is to use the `dotnet publish` command to publish the class library. Alternatively, if you want to be able to use the output of `dotnet build` for your plugin, you can add the `<CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>` property between the `<PropertyGroup>` tags in the plugin's project file. See the `XcopyablePlugin` plugin project for an example.\n\n## Other plugin examples in the sample\n\nThe complete source code for this tutorial can be found in [the dotnet/samples repository](https://github.com/dotnet/samples/tree/master/core/extensions/AppWithPlugin). The completed sample includes a few other examples of `AssemblyDependencyResolver` behavior. For example, the `AssemblyDependencyResolver` object can also resolve native libraries as well as localized satellite assemblies included in NuGet packages. The `UVPlugin` and `FrenchPlugin` in the samples repository demonstrate these scenarios.\n\n## How to reference a plugin interface assembly defined in a NuGet package\n\nLet's say that there is an app A that has a plugin interface defined in the NuGet package named `A.PluginBase`. How do you reference the package correctly in your plugin project? For project references, using the `<Private>false</Private>` metadata on the `ProjectReference` element in the project file prevented the dll from being copied to the output.\n\nTo correctly reference the `A.PluginBase` package, you want to change the `<PackageReference>` element in the project file to the following:\n\n```xml\n<PackageReference Include=\"A.PluginBase\" Version=\"1.0.0\">\n    <ExcludeAssets>runtime</ExcludeAssets>\n</PackageReference>\n```\n\nThis prevents the `A.PluginBase` assemblies from being copied to the output directory of your plugin and ensures that your plugin will use A's version of `A.PluginBase`.\n\n## Plugin target framework recommendations\n\nBecause plugin dependency loading uses the *deps.json* file, there is a gotcha related to the plugin's target framework. Specifically, your plugins should target a runtime, such as .NET Core 3.0, instead of a version of .NET Standard. The `deps.json` file is generated based on which framework the project targets, and since many .NET Standard-compatible packages ship reference assemblies for building against .NET Standard and implementation assemblies for specific runtimes, the `deps.json` may not correctly see implementation assemblies, or it may grab the .NET Standard version of an assembly instead of the .NET Core version you expect.\n","nodes":[{"pos":[4,195],"embed":true,"restype":"x-metadata","content":"title: Create a .NET Core application with plugins\ndescription: Learn how to create a .NET Core application that supports plugins.\nauthor: jkoritzinsky\nms.author: jekoritz\nms.date: 01/28/2019","nodes":[{"content":"Create a .NET Core application with plugins","nodes":[{"pos":[0,43],"content":"Create a .NET Core application with plugins","nodes":[{"content":"Create a .NET Core application with plugins","pos":[0,43]}]}],"path":["title"],"nosxs":false},{"content":"Learn how to create a .NET Core application that supports plugins.","nodes":[{"pos":[0,66],"content":"Learn how to create a .NET Core application that supports plugins.","nodes":[{"content":"Learn how to create a .NET Core application that supports plugins.","pos":[0,66]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[203,246],"content":"Create a .NET Core application with plugins","linkify":"Create a .NET Core application with plugins","nodes":[{"content":"Create a .NET Core application with plugins","pos":[0,43]}]},{"content":"This tutorial shows you how to:","pos":[248,279]},{"content":"Structure a project to support plugins.","pos":[283,322]},{"pos":[325,410],"content":"Create a custom <ph id=\"ph1\">&lt;xref:System.Runtime.Loader.AssemblyLoadContext&gt;</ph> to load each plugin.","source":"Create a custom <xref:System.Runtime.Loader.AssemblyLoadContext> to load each plugin."},{"pos":[413,515],"content":"Use the <ph id=\"ph1\">`System.Runtime.Loader.AssemblyDependencyResolver`</ph> type to allow plugins to have dependencies.","source":"Use the `System.Runtime.Loader.AssemblyDependencyResolver` type to allow plugins to have dependencies."},{"content":"Author plugins that can be easily deployed by just copying the build artifacts.","pos":[518,597]},{"pos":[602,615],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"pos":[619,716],"content":"Install the <bpt id=\"p1\">[</bpt>.NET Core 3.0 Preview 2 SDK<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> or a newer version.","source":"Install the [.NET Core 3.0 Preview 2 SDK](https://www.microsoft.com/net/core) or a newer version."},{"pos":[721,743],"content":"Create the application","linkify":"Create the application","nodes":[{"content":"Create the application","pos":[0,22]}]},{"content":"The first step is to create the application:","pos":[745,789]},{"pos":[794,876],"content":"Create a new folder, and in that folder run <ph id=\"ph1\">`dotnet new console -o AppWithPlugin`</ph>.","source":"Create a new folder, and in that folder run `dotnet new console -o AppWithPlugin`."},{"content":"To make building the project easier, create a Visual Studio solution file.","pos":[881,955]},{"content":"Run <ph id=\"ph1\">`dotnet new sln`</ph> in the same folder.","pos":[956,996],"source":" Run `dotnet new sln` in the same folder."},{"pos":[1001,1096],"content":"Run <ph id=\"ph1\">`dotnet sln add AppWithPlugin/AppWithPlugin.csproj`</ph> to add the app project to the solution.","source":"Run `dotnet sln add AppWithPlugin/AppWithPlugin.csproj` to add the app project to the solution."},{"content":"Now we can fill in the skeleton of our application.","pos":[1098,1149]},{"content":"Replace the code in the <bpt id=\"p1\">*</bpt>AppWithPlugin/Program.cs<ept id=\"p1\">*</ept> file with the following code:","pos":[1150,1230],"source":" Replace the code in the *AppWithPlugin/Program.cs* file with the following code:"},{"pos":[2422,2450],"content":"Create the plugin interfaces","linkify":"Create the plugin interfaces","nodes":[{"content":"Create the plugin interfaces","pos":[0,28]}]},{"content":"The next step in building an app with plugins is defining the interface the plugins need to implement.","pos":[2452,2554]},{"content":"We suggest that you make a class library that contains any types that you plan to use for communicating between your app and plugins.","pos":[2555,2688]},{"content":"This division allows you to publish your plugin interface as a package without having to ship your full application.","pos":[2689,2805]},{"content":"In the root folder of the project, run <ph id=\"ph1\">`dotnet new classlib -o PluginBase`</ph>.","pos":[2807,2882],"source":"In the root folder of the project, run `dotnet new classlib -o PluginBase`."},{"content":"Also, run <ph id=\"ph1\">`dotnet sln add PluginBase/PluginBase.csproj`</ph> to add the project to the solution file.","pos":[2883,2979],"source":" Also, run `dotnet sln add PluginBase/PluginBase.csproj` to add the project to the solution file."},{"content":"Delete the <ph id=\"ph1\">`PluginBase/Class1.cs`</ph> file, and create a new file in the <ph id=\"ph2\">`PluginBase`</ph> folder named <ph id=\"ph3\">`ICommand.cs`</ph> with the following interface definition:","pos":[2980,3129],"source":" Delete the `PluginBase/Class1.cs` file, and create a new file in the `PluginBase` folder named `ICommand.cs` with the following interface definition:"},{"pos":[3233,3315],"content":"This <ph id=\"ph1\">`ICommand`</ph> interface is the interface that all of the plugins will implement.","source":"This `ICommand` interface is the interface that all of the plugins will implement."},{"content":"Now that the <ph id=\"ph1\">`ICommand`</ph> interface is defined, the application project can be filled in a little more.","pos":[3317,3418],"source":"Now that the `ICommand` interface is defined, the application project can be filled in a little more."},{"content":"Add a reference from the <ph id=\"ph1\">`AppWithPlugin`</ph> project to the <ph id=\"ph2\">`PluginBase`</ph> project with the <ph id=\"ph3\">`dotnet add AppWithPlugin\\AppWithPlugin.csproj reference PluginBase\\PluginBase.csproj`</ph>  command from the root folder.","pos":[3419,3622],"source":" Add a reference from the `AppWithPlugin` project to the `PluginBase` project with the `dotnet add AppWithPlugin\\AppWithPlugin.csproj reference PluginBase\\PluginBase.csproj`  command from the root folder."},{"pos":[3624,3759],"content":"Replace the <ph id=\"ph1\">`// Load commands from plugins`</ph> comment with the following code snippet to enable it to load plugins from given file paths:","source":"Replace the `// Load commands from plugins` comment with the following code snippet to enable it to load plugins from given file paths:"},{"pos":[4033,4122],"content":"Then replace the <ph id=\"ph1\">`// Output the loaded commands`</ph> comment with the following code snippet:","source":"Then replace the `// Output the loaded commands` comment with the following code snippet:"},{"pos":[4250,4358],"content":"Replace the <ph id=\"ph1\">`// Execute the command with the name passed as an argument`</ph> comment with the following snippet:","source":"Replace the `// Execute the command with the name passed as an argument` comment with the following snippet:"},{"pos":[4556,4666],"content":"And finally, add static methods to the <ph id=\"ph1\">`Program`</ph> class named <ph id=\"ph2\">`LoadPlugin`</ph> and <ph id=\"ph3\">`CreateCommands`</ph>, as shown here:","source":"And finally, add static methods to the `Program` class named `LoadPlugin` and `CreateCommands`, as shown here:"},{"pos":[5519,5531],"content":"Load plugins","linkify":"Load plugins","nodes":[{"content":"Load plugins","pos":[0,12]}]},{"content":"Now the application can correctly load and instantiate commands from loaded plugin assemblies, but it is still unable to load the plugin assemblies.","pos":[5533,5681]},{"content":"Create a file named <bpt id=\"p1\">*</bpt>PluginLoadContext.cs<ept id=\"p1\">*</ept> in the <bpt id=\"p2\">*</bpt>AppWithPlugin<ept id=\"p2\">*</ept> folder with the following contents:","pos":[5682,5783],"source":" Create a file named *PluginLoadContext.cs* in the *AppWithPlugin* folder with the following contents:"},{"content":"The <ph id=\"ph1\">`PluginLoadContext`</ph> type derives from <ph id=\"ph2\">&lt;xref:System.Runtime.Loader.AssemblyLoadContext&gt;</ph>.","pos":[5894,5985],"source":"The `PluginLoadContext` type derives from <xref:System.Runtime.Loader.AssemblyLoadContext>."},{"content":"The <ph id=\"ph1\">`AssemblyLoadContext`</ph> type is a special type in the runtime that allows developers to isolate loaded assemblies into different groups to ensure that assembly versions do not conflict.","pos":[5986,6173],"source":" The `AssemblyLoadContext` type is a special type in the runtime that allows developers to isolate loaded assemblies into different groups to ensure that assembly versions do not conflict."},{"content":"Additionally, a custom <ph id=\"ph1\">`AssemblyLoadContext`</ph> can choose different paths to load assemblies from and override the default behavior.","pos":[6174,6304],"source":" Additionally, a custom `AssemblyLoadContext` can choose different paths to load assemblies from and override the default behavior."},{"content":"The <ph id=\"ph1\">`PluginLoadContext`</ph> uses an instance of the <ph id=\"ph2\">`AssemblyDependencyResolver`</ph> type introduced in .NET Core 3.0 to resolve assembly names to paths.","pos":[6305,6450],"source":" The `PluginLoadContext` uses an instance of the `AssemblyDependencyResolver` type introduced in .NET Core 3.0 to resolve assembly names to paths."},{"content":"The <ph id=\"ph1\">`AssemblyDependencyResolver`</ph> object is constructed with the path to a .NET class library.","pos":[6451,6544],"source":" The `AssemblyDependencyResolver` object is constructed with the path to a .NET class library."},{"content":"It resolves assemblies and native libraries to their relative paths based on the <bpt id=\"p1\">*</bpt>deps.json<ept id=\"p1\">*</ept> file for the class library whose path was passed to the <ph id=\"ph1\">`AssemblyDependencyResolver`</ph> constructor.","pos":[6545,6735],"source":" It resolves assemblies and native libraries to their relative paths based on the *deps.json* file for the class library whose path was passed to the `AssemblyDependencyResolver` constructor."},{"content":"The custom <ph id=\"ph1\">`AssemblyLoadContext`</ph> enables plugins to have their own dependencies, and the <ph id=\"ph2\">`AssemblyDependencyResolver`</ph> makes it easy to correctly load the dependencies.","pos":[6736,6903],"source":" The custom `AssemblyLoadContext` enables plugins to have their own dependencies, and the `AssemblyDependencyResolver` makes it easy to correctly load the dependencies."},{"pos":[6905,7039],"content":"Now that the <ph id=\"ph1\">`AppWithPlugin`</ph> project has the <ph id=\"ph2\">`PluginLoadContext`</ph> type, update the <ph id=\"ph3\">`Program.LoadPlugin`</ph> method with the following body:","source":"Now that the `AppWithPlugin` project has the `PluginLoadContext` type, update the `Program.LoadPlugin` method with the following body:"},{"pos":[7812,7957],"content":"By using a different <ph id=\"ph1\">`PluginLoadContext`</ph> instance for each plugin, the plugins can have different or even conflicting dependencies without issue.","source":"By using a different `PluginLoadContext` instance for each plugin, the plugins can have different or even conflicting dependencies without issue."},{"pos":[7962,8005],"content":"Create a simple plugin with no dependencies","linkify":"Create a simple plugin with no dependencies","nodes":[{"content":"Create a simple plugin with no dependencies","pos":[0,43]}]},{"content":"Back in the root folder, do the following:","pos":[8007,8049]},{"pos":[8054,8153],"content":"Run <ph id=\"ph1\">`dotnet new classlib -o HelloPlugin`</ph> to create a new class library project named <ph id=\"ph2\">`HelloPlugin`</ph>.","source":"Run `dotnet new classlib -o HelloPlugin` to create a new class library project named `HelloPlugin`."},{"pos":[8157,8260],"content":"Run <ph id=\"ph1\">`dotnet sln add HelloPlugin/HelloPlugin.csproj`</ph> to add the project to the <ph id=\"ph2\">`AppWithPlugin`</ph> solution.","source":"Run `dotnet sln add HelloPlugin/HelloPlugin.csproj` to add the project to the `AppWithPlugin` solution."},{"pos":[8265,8370],"content":"Replace the <bpt id=\"p1\">*</bpt>HelloPlugin/Class1.cs<ept id=\"p1\">*</ept> file with a file named <bpt id=\"p2\">*</bpt>HelloCommand.cs<ept id=\"p2\">*</ept> with the following contents:","source":"Replace the *HelloPlugin/Class1.cs* file with a file named *HelloCommand.cs* with the following contents:"},{"content":"Now, open the <bpt id=\"p1\">*</bpt>HelloPlugin.csproj<ept id=\"p1\">*</ept> file.","pos":[8475,8515],"source":"Now, open the *HelloPlugin.csproj* file."},{"content":"It should look similar to the following:","pos":[8516,8556]},{"pos":[8708,8768],"content":"In between the <ph id=\"ph1\">`&lt;Project&gt;`</ph> tags, add the following elements:","source":"In between the `<Project>` tags, add the following elements:"},{"content":"The <ph id=\"ph1\">`&lt;Private&gt;false&lt;/Private&gt;`</ph> element is very important.","pos":[8917,8974],"source":"The `<Private>false</Private>` element is very important."},{"content":"This tells MSBuild to not copy <bpt id=\"p1\">*</bpt>PluginBase.dll<ept id=\"p1\">*</ept> to the output directory for HelloPlugin.","pos":[8975,9063],"source":" This tells MSBuild to not copy *PluginBase.dll* to the output directory for HelloPlugin."},{"content":"If the <bpt id=\"p1\">*</bpt>PluginBase.dll<ept id=\"p1\">*</ept> assembly is present in the output directory, <ph id=\"ph1\">`PluginLoadContext`</ph> will find the assembly there and load it when it loads the <bpt id=\"p2\">*</bpt>HelloPlugin.dll<ept id=\"p2\">*</ept> assembly.","pos":[9064,9239],"source":" If the *PluginBase.dll* assembly is present in the output directory, `PluginLoadContext` will find the assembly there and load it when it loads the *HelloPlugin.dll* assembly."},{"content":"At this point, the <ph id=\"ph1\">`HelloPlugin.HelloCommand`</ph> type will implement the <ph id=\"ph2\">`ICommand`</ph> interface from the <bpt id=\"p1\">*</bpt>PluginBase.dll<ept id=\"p1\">*</ept> in the output directory of the <ph id=\"ph3\">`HelloPlugin`</ph> project, not the <ph id=\"ph4\">`ICommand`</ph> interface that is loaded into the default load context.","pos":[9240,9485],"source":" At this point, the `HelloPlugin.HelloCommand` type will implement the `ICommand` interface from the *PluginBase.dll* in the output directory of the `HelloPlugin` project, not the `ICommand` interface that is loaded into the default load context."},{"content":"Since the runtime sees these two types as different types from different assemblies, the <ph id=\"ph1\">`AppWithPlugin.Program.CreateCommands`</ph> method will not find the commands.","pos":[9486,9648],"source":" Since the runtime sees these two types as different types from different assemblies, the `AppWithPlugin.Program.CreateCommands` method will not find the commands."},{"content":"As a result, the <ph id=\"ph1\">`&lt;Private&gt;false&lt;/Private&gt;`</ph> metadata is required for the reference to the assembly containing the plugin interfaces.","pos":[9649,9781],"source":" As a result, the `<Private>false</Private>` metadata is required for the reference to the assembly containing the plugin interfaces."},{"content":"Now that the <ph id=\"ph1\">`HelloPlugin`</ph> project is complete, we should update the <ph id=\"ph2\">`AppWithPlugin`</ph> project to know where the <ph id=\"ph3\">`HelloPlugin`</ph> plugin can be found.","pos":[9783,9928],"source":"Now that the `HelloPlugin` project is complete, we should update the `AppWithPlugin` project to know where the `HelloPlugin` plugin can be found."},{"content":"After the <ph id=\"ph1\">`// Paths to plugins to load`</ph> comment, add <ph id=\"ph2\">`@\"HelloPlugin\\bin\\Debug\\netcoreapp3.0\\HelloPlugin.dll\"`</ph> as an element of the <ph id=\"ph3\">`pluginPaths`</ph> array.","pos":[9929,10080],"source":" After the `// Paths to plugins to load` comment, add `@\"HelloPlugin\\bin\\Debug\\netcoreapp3.0\\HelloPlugin.dll\"` as an element of the `pluginPaths` array."},{"pos":[10085,10126],"content":"Create a plugin with library dependencies","linkify":"Create a plugin with library dependencies","nodes":[{"content":"Create a plugin with library dependencies","pos":[0,41]}]},{"content":"Almost all plugins are more complex than a simple \"Hello World\", and many plugins have dependencies on other libraries.","pos":[10128,10247]},{"content":"The <ph id=\"ph1\">`JsonPlugin`</ph> and <ph id=\"ph2\">`OldJson`</ph> plugin projects in the sample show two examples of plugins with NuGet package dependencies on <ph id=\"ph3\">`Newtonsoft.Json`</ph>.","pos":[10248,10391],"source":" The `JsonPlugin` and `OldJson` plugin projects in the sample show two examples of plugins with NuGet package dependencies on `Newtonsoft.Json`."},{"content":"The project files themselves do not have any special information for the project references, and (after adding the plugin paths to the <ph id=\"ph1\">`pluginPaths`</ph> array) the plugins run perfectly, even if run in the same execution of the AppWithPlugin app.","pos":[10392,10634],"source":" The project files themselves do not have any special information for the project references, and (after adding the plugin paths to the `pluginPaths` array) the plugins run perfectly, even if run in the same execution of the AppWithPlugin app."},{"content":"However, these projects do not copy the referenced assemblies to their output directory, so the assemblies need to be present on the user's machine for the plugins to work.","pos":[10635,10807]},{"content":"There are two ways to work around this problem.","pos":[10808,10855]},{"content":"The first option is to use the <ph id=\"ph1\">`dotnet publish`</ph> command to publish the class library.","pos":[10856,10941],"source":" The first option is to use the `dotnet publish` command to publish the class library."},{"content":"Alternatively, if you want to be able to use the output of <ph id=\"ph1\">`dotnet build`</ph> for your plugin, you can add the <ph id=\"ph2\">`&lt;CopyLocalLockFileAssemblies&gt;true&lt;/CopyLocalLockFileAssemblies&gt;`</ph> property between the <ph id=\"ph3\">`&lt;PropertyGroup&gt;`</ph> tags in the plugin's project file.","pos":[10942,11188],"source":" Alternatively, if you want to be able to use the output of `dotnet build` for your plugin, you can add the `<CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>` property between the `<PropertyGroup>` tags in the plugin's project file."},{"content":"See the <ph id=\"ph1\">`XcopyablePlugin`</ph> plugin project for an example.","pos":[11189,11245],"source":" See the `XcopyablePlugin` plugin project for an example."},{"pos":[11250,11285],"content":"Other plugin examples in the sample","linkify":"Other plugin examples in the sample","nodes":[{"content":"Other plugin examples in the sample","pos":[0,35]}]},{"content":"The complete source code for this tutorial can be found in <bpt id=\"p1\">[</bpt>the dotnet/samples repository<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/core/extensions/AppWithPlugin)</ept>.","pos":[11287,11455],"source":"The complete source code for this tutorial can be found in [the dotnet/samples repository](https://github.com/dotnet/samples/tree/master/core/extensions/AppWithPlugin)."},{"content":"The completed sample includes a few other examples of <ph id=\"ph1\">`AssemblyDependencyResolver`</ph> behavior.","pos":[11456,11548],"source":" The completed sample includes a few other examples of `AssemblyDependencyResolver` behavior."},{"content":"For example, the <ph id=\"ph1\">`AssemblyDependencyResolver`</ph> object can also resolve native libraries as well as localized satellite assemblies included in NuGet packages.","pos":[11549,11705],"source":" For example, the `AssemblyDependencyResolver` object can also resolve native libraries as well as localized satellite assemblies included in NuGet packages."},{"content":"The <ph id=\"ph1\">`UVPlugin`</ph> and <ph id=\"ph2\">`FrenchPlugin`</ph> in the samples repository demonstrate these scenarios.","pos":[11706,11794],"source":" The `UVPlugin` and `FrenchPlugin` in the samples repository demonstrate these scenarios."},{"pos":[11799,11870],"content":"How to reference a plugin interface assembly defined in a NuGet package","linkify":"How to reference a plugin interface assembly defined in a NuGet package","nodes":[{"content":"How to reference a plugin interface assembly defined in a NuGet package","pos":[0,71]}]},{"content":"Let's say that there is an app A that has a plugin interface defined in the NuGet package named <ph id=\"ph1\">`A.PluginBase`</ph>.","pos":[11872,11983],"source":"Let's say that there is an app A that has a plugin interface defined in the NuGet package named `A.PluginBase`."},{"content":"How do you reference the package correctly in your plugin project?","pos":[11984,12050]},{"content":"For project references, using the <ph id=\"ph1\">`&lt;Private&gt;false&lt;/Private&gt;`</ph> metadata on the <ph id=\"ph2\">`ProjectReference`</ph> element in the project file prevented the dll from being copied to the output.","pos":[12051,12225],"source":" For project references, using the `<Private>false</Private>` metadata on the `ProjectReference` element in the project file prevented the dll from being copied to the output."},{"pos":[12227,12367],"content":"To correctly reference the <ph id=\"ph1\">`A.PluginBase`</ph> package, you want to change the <ph id=\"ph2\">`&lt;PackageReference&gt;`</ph> element in the project file to the following:","source":"To correctly reference the `A.PluginBase` package, you want to change the `<PackageReference>` element in the project file to the following:"},{"pos":[12502,12671],"content":"This prevents the <ph id=\"ph1\">`A.PluginBase`</ph> assemblies from being copied to the output directory of your plugin and ensures that your plugin will use A's version of <ph id=\"ph2\">`A.PluginBase`</ph>.","source":"This prevents the `A.PluginBase` assemblies from being copied to the output directory of your plugin and ensures that your plugin will use A's version of `A.PluginBase`."},{"pos":[12676,12715],"content":"Plugin target framework recommendations","linkify":"Plugin target framework recommendations","nodes":[{"content":"Plugin target framework recommendations","pos":[0,39]}]},{"content":"Because plugin dependency loading uses the <bpt id=\"p1\">*</bpt>deps.json<ept id=\"p1\">*</ept> file, there is a gotcha related to the plugin's target framework.","pos":[12717,12837],"source":"Because plugin dependency loading uses the *deps.json* file, there is a gotcha related to the plugin's target framework."},{"content":"Specifically, your plugins should target a runtime, such as .NET Core 3.0, instead of a version of .NET Standard.","pos":[12838,12951]},{"content":"The <ph id=\"ph1\">`deps.json`</ph> file is generated based on which framework the project targets, and since many .NET Standard-compatible packages ship reference assemblies for building against .NET Standard and implementation assemblies for specific runtimes, the <ph id=\"ph2\">`deps.json`</ph> may not correctly see implementation assemblies, or it may grab the .NET Standard version of an assembly instead of the .NET Core version you expect.","pos":[12952,13360],"source":" The `deps.json` file is generated based on which framework the project targets, and since many .NET Standard-compatible packages ship reference assemblies for building against .NET Standard and implementation assemblies for specific runtimes, the `deps.json` may not correctly see implementation assemblies, or it may grab the .NET Standard version of an assembly instead of the .NET Core version you expect."}]}