{"content":"---\ntitle: \"How to: List All Nodes in a Tree (C#)\"\nms.date: 07/20/2015\nms.assetid: 3e934371-f4c6-458b-9f6b-f9061b596f5b\n---\n# How to: List All Nodes in a Tree (C#)\nSometimes it is helpful to list all nodes in a tree. This can be useful when learning exactly how a method or property affects the tree. One approach to listing all nodes in a textual form is to generate an XPath expression that exactly and specifically identifies any node in the tree.  \n  \n It is not particularly helpful to execute XPath expressions using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]. XPath expressions have poorer performance than [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries, and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries are much more powerful. However, as a way to identify nodes in the XML tree, XPath works well.  \n  \n## Example  \n This example shows an function named `GetXPath` that generates a specific XPath expression for any node in the XML tree. It generates appropriate XPath expressions even when nodes are in a namespace. The XPath expressions are generated by using namespace prefixes.  \n  \n The example then creates a small XML tree that contains an example of several types of nodes. It then iterates through the descendant nodes and prints the XPath expression for each node.  \n  \n You will notice that the XML declaration is not a node in the tree.  \n  \n The following is an XML file that contains several types of nodes:  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>  \n<?target data?>  \n<Root AttName=\"An Attribute\" xmlns:aw=\"http://www.adventure-works.com\">  \n  <!--This is a comment-->  \n  <Child>Text</Child>  \n  <Child>Other Text</Child>  \n  <ChildWithMixedContent>text<b>BoldText</b>otherText</ChildWithMixedContent>  \n  <aw:ElementInNamespace>  \n    <aw:ChildInNamespace />  \n  </aw:ElementInNamespace>  \n</Root>  \n```  \n  \n The following is the list of nodes in the above XML tree, expressed as XPath expressions:  \n  \n```  \n/processing-instruction()  \n/Root  \n/Root/@AttName  \n/Root/@xmlns:aw  \n/Root/comment()  \n/Root/Child[1]  \n/Root/Child[1]/text()  \n/Root/Child[2]  \n/Root/Child[2]/text()  \n/Root/ChildWithMixedContent  \n/Root/ChildWithMixedContent/text()[1]  \n/Root/ChildWithMixedContent/b  \n/Root/ChildWithMixedContent/b/text()  \n/Root/ChildWithMixedContent/text()[2]  \n/Root/aw:ElementInNamespace  \n/Root/aw:ElementInNamespace/aw:ChildInNamespace  \n```  \n  \n```csharp  \npublic static class MyExtensions  \n{  \n    private static string GetQName(XElement xe)  \n    {  \n        string prefix = xe.GetPrefixOfNamespace(xe.Name.Namespace);  \n        if (xe.Name.Namespace == XNamespace.None || prefix == null)  \n            return xe.Name.LocalName.ToString();  \n        else  \n            return prefix + \":\" + xe.Name.LocalName.ToString();  \n    }  \n  \n    private static string GetQName(XAttribute xa)  \n    {  \n        string prefix =  \n            xa.Parent.GetPrefixOfNamespace(xa.Name.Namespace);  \n        if (xa.Name.Namespace == XNamespace.None || prefix == null)  \n            return xa.Name.ToString();  \n        else  \n            return prefix + \":\" + xa.Name.LocalName;  \n    }  \n  \n    private static string NameWithPredicate(XElement el)  \n    {  \n        if (el.Parent != null && el.Parent.Elements(el.Name).Count() != 1)  \n            return GetQName(el) + \"[\" +  \n                (el.ElementsBeforeSelf(el.Name).Count() + 1) + \"]\";  \n        else  \n            return GetQName(el);  \n    }  \n  \n    public static string StrCat<T>(this IEnumerable<T> source,  \n        string separator)  \n    {  \n        return source.Aggregate(new StringBuilder(),  \n                   (sb, i) => sb  \n                       .Append(i.ToString())  \n                       .Append(separator),  \n                   s => s.ToString());  \n    }  \n  \n    public static string GetXPath(this XObject xobj)  \n    {  \n        if (xobj.Parent == null)  \n        {  \n            XDocument doc = xobj as XDocument;  \n            if (doc != null)  \n                return \".\";  \n            XElement el = xobj as XElement;  \n            if (el != null)  \n                return \"/\" + NameWithPredicate(el);  \n            // the XPath data model does not include white space text nodes  \n            // that are children of a document, so this method returns null.  \n            XText xt = xobj as XText;  \n            if (xt != null)  \n                return null;  \n            XComment com = xobj as XComment;  \n            if (com != null)  \n                return  \n                    \"/\" +  \n                    (  \n                        com  \n                        .Document  \n                        .Nodes()  \n                        .OfType<XComment>()  \n                        .Count() != 1 ?  \n                        \"comment()[\" +  \n                        (com  \n                        .NodesBeforeSelf()  \n                        .OfType<XComment>()  \n                        .Count() + 1) +  \n                        \"]\" :  \n                        \"comment()\"  \n                    );  \n            XProcessingInstruction pi = xobj as XProcessingInstruction;  \n            if (pi != null)  \n                return  \n                    \"/\" +  \n                    (  \n                        pi.Document.Nodes()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() != 1 ?  \n                        \"processing-instruction()[\" +  \n                        (pi  \n                        .NodesBeforeSelf()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() + 1) +  \n                        \"]\" :  \n                        \"processing-instruction()\"  \n                    );  \n            return null;  \n        }  \n        else  \n        {  \n            XElement el = xobj as XElement;  \n            if (el != null)  \n            {  \n                return  \n                    \"/\" +  \n                    el  \n                    .Ancestors()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    NameWithPredicate(el);  \n            }  \n            XAttribute at = xobj as XAttribute;  \n            if (at != null)  \n                return  \n                    \"/\" +  \n                    at  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    \"@\" + GetQName(at);  \n            XComment com = xobj as XComment;  \n            if (com != null)  \n                return  \n                    \"/\" +  \n                    com  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        com  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XComment>()  \n                        .Count() != 1 ?  \n                        \"comment()[\" +  \n                        (com  \n                        .NodesBeforeSelf()  \n                        .OfType<XComment>()  \n                        .Count() + 1) + \"]\" :  \n                        \"comment()\"  \n                    );  \n            XCData cd = xobj as XCData;  \n            if (cd != null)  \n                return  \n                    \"/\" +  \n                    cd  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        cd  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XText>()  \n                        .Count() != 1 ?  \n                        \"text()[\" +  \n                        (cd  \n                        .NodesBeforeSelf()  \n                        .OfType<XText>()  \n                        .Count() + 1) + \"]\" :  \n                        \"text()\"  \n                    );  \n            XText tx = xobj as XText;  \n            if (tx != null)  \n                return  \n                    \"/\" +  \n                    tx  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        tx  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XText>()  \n                        .Count() != 1 ?  \n                        \"text()[\" +  \n                        (tx  \n                        .NodesBeforeSelf()  \n                        .OfType<XText>()  \n                        .Count() + 1) + \"]\" :  \n                        \"text()\"  \n                    );  \n            XProcessingInstruction pi = xobj as XProcessingInstruction;  \n            if (pi != null)  \n                return  \n                    \"/\" +  \n                    pi  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        pi  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() != 1 ?  \n                        \"processing-instruction()[\" +  \n                        (pi  \n                        .NodesBeforeSelf()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() + 1) + \"]\" :  \n                        \"processing-instruction()\"  \n                    );  \n            return null;  \n        }  \n    }  \n}  \n  \nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        XNamespace aw = \"http://www.adventure-works.com\";  \n        XDocument doc = new XDocument(  \n            new XDeclaration(\"1.0\", \"utf-8\", \"yes\"),  \n            new XProcessingInstruction(\"target\", \"data\"),  \n            new XElement(\"Root\",  \n                new XAttribute(\"AttName\", \"An Attribute\"),  \n                new XAttribute(XNamespace.Xmlns + \"aw\", aw.ToString()),  \n                new XComment(\"This is a comment\"),  \n                new XElement(\"Child\",  \n                    new XText(\"Text\")  \n                ),  \n                new XElement(\"Child\",  \n                    new XText(\"Other Text\")  \n                ),  \n                new XElement(\"ChildWithMixedContent\",  \n                    new XText(\"text\"),  \n                    new XElement(\"b\", \"BoldText\"),  \n                    new XText(\"otherText\")  \n                ),  \n                new XElement(aw + \"ElementInNamespace\",  \n                    new XElement(aw + \"ChildInNamespace\")  \n                )  \n            )  \n        );  \n        doc.Save(\"Test.xml\");  \n        Console.WriteLine(File.ReadAllText(\"Test.xml\"));  \n        Console.WriteLine(\"------\");  \n        foreach (XObject obj in doc.DescendantNodes())  \n        {  \n            Console.WriteLine(obj.GetXPath());  \n            XElement el = obj as XElement;  \n            if (el != null)  \n                foreach (XAttribute at in el.Attributes())  \n                    Console.WriteLine(at.GetXPath());  \n        }  \n    }  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>  \n<?target data?>  \n<Root AttName=\"An Attribute\" xmlns:aw=\"http://www.adventure-works.com\">  \n  <!--This is a comment-->  \n  <Child>Text</Child>  \n  <Child>Other Text</Child>  \n  <ChildWithMixedContent>text<b>BoldText</b>otherText</ChildWithMixedContent>  \n  <aw:ElementInNamespace>  \n    <aw:ChildInNamespace />  \n  </aw:ElementInNamespace>  \n</Root>  \n------  \n/processing-instruction()  \n/Root  \n/Root/@AttName  \n/Root/@xmlns:aw  \n/Root/comment()  \n/Root/Child[1]  \n/Root/Child[1]/text()  \n/Root/Child[2]  \n/Root/Child[2]/text()  \n/Root/ChildWithMixedContent  \n/Root/ChildWithMixedContent/text()[1]  \n/Root/ChildWithMixedContent/b  \n/Root/ChildWithMixedContent/b/text()  \n/Root/ChildWithMixedContent/text()[2]  \n/Root/aw:ElementInNamespace  \n/Root/aw:ElementInNamespace/aw:ChildInNamespace  \n```  \n  \n## See also\n\n- [Advanced Query Techniques (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)\n","nodes":[{"pos":[4,119],"embed":true,"restype":"x-metadata","content":"title: \"How to: List All Nodes in a Tree (C#)\"\nms.date: 07/20/2015\nms.assetid: 3e934371-f4c6-458b-9f6b-f9061b596f5b","nodes":[{"content":"How to: List All Nodes in a Tree (C#)","nodes":[{"pos":[0,37],"content":"How to: List All Nodes in a Tree (C#)","nodes":[{"content":"How to: List All Nodes in a Tree (C#)","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[126,163],"content":"How to: List All Nodes in a Tree (C#)","linkify":"How to: List All Nodes in a Tree (C#)","nodes":[{"content":"How to: List All Nodes in a Tree (C#)","pos":[0,37]}]},{"content":"Sometimes it is helpful to list all nodes in a tree.","pos":[164,216]},{"content":"This can be useful when learning exactly how a method or property affects the tree.","pos":[217,300]},{"content":"One approach to listing all nodes in a textual form is to generate an XPath expression that exactly and specifically identifies any node in the tree.","pos":[301,450]},{"content":"It is not particularly helpful to execute XPath expressions using <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph>.","pos":[457,577],"source":"It is not particularly helpful to execute XPath expressions using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]."},{"content":"XPath expressions have poorer performance than <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> queries, and <ph id=\"ph2\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> queries are much more powerful.","pos":[578,777],"source":" XPath expressions have poorer performance than [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries, and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries are much more powerful."},{"content":"However, as a way to identify nodes in the XML tree, XPath works well.","pos":[778,848]},{"pos":[857,864],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example shows an function named <ph id=\"ph1\">`GetXPath`</ph> that generates a specific XPath expression for any node in the XML tree.","pos":[868,988],"source":"This example shows an function named `GetXPath` that generates a specific XPath expression for any node in the XML tree."},{"content":"It generates appropriate XPath expressions even when nodes are in a namespace.","pos":[989,1067]},{"content":"The XPath expressions are generated by using namespace prefixes.","pos":[1068,1132]},{"content":"The example then creates a small XML tree that contains an example of several types of nodes.","pos":[1139,1232]},{"content":"It then iterates through the descendant nodes and prints the XPath expression for each node.","pos":[1233,1325]},{"content":"You will notice that the XML declaration is not a node in the tree.","pos":[1332,1399]},{"content":"The following is an XML file that contains several types of nodes:","pos":[1406,1472]},{"content":"The following is the list of nodes in the above XML tree, expressed as XPath expressions:","pos":[1907,1996]},{"content":"This example produces the following output:","pos":[11691,11734]},{"pos":[12609,12617],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[12621,12760],"content":"<bpt id=\"p1\">[</bpt>Advanced Query Techniques (LINQ to XML) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)</ept>","source":"[Advanced Query Techniques (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)"}]}