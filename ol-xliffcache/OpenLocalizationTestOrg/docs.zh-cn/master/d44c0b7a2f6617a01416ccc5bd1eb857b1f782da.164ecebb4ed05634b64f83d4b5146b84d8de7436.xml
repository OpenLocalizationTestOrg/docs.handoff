{"content":"---\ntitle: \"from clause - C# Reference\"\nms.custom: seodec18\n\nms.date: 07/20/2015\nf1_keywords: \n  - \"from_CSharpKeyword\"\n  - \"from\"\nhelpviewer_keywords: \n  - \"from clause [C#]\"\n  - \"from keyword [C#]\"\nms.assetid: 1aefd18c-1314-47f8-99ec-9bcefb09e699\n---\n# from clause (C# Reference)\n\nA query expression must begin with a `from` clause. Additionally, a query expression can contain sub-queries, which also begin with a `from` clause. The `from` clause specifies the following:\n\n- The data source on which the query or sub-query will be run.\n\n- A local *range variable* that represents each element in the source sequence.\n\nBoth the range variable and the data source are strongly typed. The data source referenced in the `from` clause must have a type of <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, or a derived type such as <xref:System.Linq.IQueryable%601>.\n\nIn the following example, `numbers` is the data source and `num` is the range variable. Note that both variables are strongly typed even though the [var](var.md) keyword is used.\n\n[!code-csharp[cscsrefQueryKeywords#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/From.cs#1)]\n\n## The range variable\n\nThe compiler infers the type of the range variable when the data source implements <xref:System.Collections.Generic.IEnumerable%601>. For example, if the source has a type of `IEnumerable<Customer>`, then the range variable is inferred to be `Customer`. The only time that you must specify the type explicitly is when the source is a non-generic `IEnumerable` type such as <xref:System.Collections.ArrayList>. For more information, see [How to: Query an ArrayList with LINQ](../../programming-guide/concepts/linq/how-to-query-an-arraylist-with-linq.md).\n\nIn the previous example `num` is inferred to be of type `int`. Because the range variable is strongly typed, you can call methods on it or use it in other operations. For example, instead of writing `select num`, you could write `select num.ToString()` to cause the query expression to return a sequence of strings instead of integers. Or you could write `select num + 10` to cause the expression to return the sequence 14, 11, 13, 12, 10. For more information, see [select clause](select-clause.md).\n\nThe range variable is like an iteration variable in a [foreach](foreach-in.md) statement except for one very important difference: a range variable never actually stores data from the source. It's just a syntactic convenience that enables the query to describe what will occur when the query is executed. For more information, see [Introduction to LINQ Queries (C#)](../../programming-guide/concepts/linq/introduction-to-linq-queries.md).\n\n## Compound from clauses\n\nIn some cases, each element in the source sequence may itself be either a sequence or contain a sequence. For example, your data source may be an `IEnumerable<Student>` where each student object in the sequence contains a list of test scores. To access the inner list within each `Student` element, you can use compound `from` clauses. The technique is like using nested [foreach](foreach-in.md) statements. You can add [where](partial-method.md) or [orderby](orderby-clause.md) clauses to either `from` clause to filter the results. The following example shows a sequence of `Student` objects, each of which contains an inner `List` of integers representing test scores. To access the inner list, use a compound `from` clause. You can insert clauses between the two `from` clauses if necessary.\n\n[!code-csharp[cscsrefQueryKeywords#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/From.cs#2)]\n\n## Using Multiple from Clauses to Perform Joins\n\nA compound `from` clause is used to access inner collections in a single data source. However, a query can also contain multiple `from` clauses that generate supplemental queries from independent data sources. This technique enables you to perform certain types of join operations that are not possible by using the [join clause](join-clause.md).\n\nThe following example shows how two `from` clauses can be used to form a complete cross join of two data sources.\n\n[!code-csharp[cscsrefQueryKeywords#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsCsrefQueryKeywords/CS/From.cs#3)]\n\nFor more information about join operations that use multiple `from` clauses, see [Perform left outer joins](../../linq/perform-left-outer-joins.md).\n\n## See also\n\n- [Query Keywords (LINQ)](query-keywords.md)\n- [Language Integrated Query (LINQ)](../../linq/index.md)\n","nodes":[{"pos":[4,248],"embed":true,"restype":"x-metadata","content":"title: \"from clause - C# Reference\"\nms.custom: seodec18\n\nms.date: 07/20/2015\nf1_keywords: \n  - \"from_CSharpKeyword\"\n  - \"from\"\nhelpviewer_keywords: \n  - \"from clause [C#]\"\n  - \"from keyword [C#]\"\nms.assetid: 1aefd18c-1314-47f8-99ec-9bcefb09e699","nodes":[{"content":"from clause - C# Reference","nodes":[{"pos":[0,26],"content":"from clause - C# Reference","nodes":[{"content":"from clause - C# Reference","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[255,281],"content":"from clause (C# Reference)","linkify":"from clause (C# Reference)","nodes":[{"content":"from clause (C# Reference)","pos":[0,26]}]},{"content":"A query expression must begin with a <ph id=\"ph1\">`from`</ph> clause.","pos":[283,334],"source":"A query expression must begin with a `from` clause."},{"content":"Additionally, a query expression can contain sub-queries, which also begin with a <ph id=\"ph1\">`from`</ph> clause.","pos":[335,431],"source":" Additionally, a query expression can contain sub-queries, which also begin with a `from` clause."},{"content":"The <ph id=\"ph1\">`from`</ph> clause specifies the following:","pos":[432,474],"source":" The `from` clause specifies the following:"},{"content":"The data source on which the query or sub-query will be run.","pos":[478,538]},{"pos":[542,619],"content":"A local <bpt id=\"p1\">*</bpt>range variable<ept id=\"p1\">*</ept> that represents each element in the source sequence.","source":"A local *range variable* that represents each element in the source sequence."},{"content":"Both the range variable and the data source are strongly typed.","pos":[621,684]},{"content":"The data source referenced in the <ph id=\"ph1\">`from`</ph> clause must have a type of <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, or a derived type such as <ph id=\"ph4\">&lt;xref:System.Linq.IQueryable%601&gt;</ph>.","pos":[685,903],"source":" The data source referenced in the `from` clause must have a type of <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, or a derived type such as <xref:System.Linq.IQueryable%601>."},{"content":"In the following example, <ph id=\"ph1\">`numbers`</ph> is the data source and <ph id=\"ph2\">`num`</ph> is the range variable.","pos":[905,992],"source":"In the following example, `numbers` is the data source and `num` is the range variable."},{"content":"Note that both variables are strongly typed even though the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](var.md)</ept> keyword is used.","pos":[993,1083],"source":" Note that both variables are strongly typed even though the [var](var.md) keyword is used."},{"pos":[1210,1228],"content":"The range variable","linkify":"The range variable","nodes":[{"content":"The range variable","pos":[0,18]}]},{"content":"The compiler infers the type of the range variable when the data source implements <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[1230,1363],"source":"The compiler infers the type of the range variable when the data source implements <xref:System.Collections.Generic.IEnumerable%601>."},{"content":"For example, if the source has a type of <ph id=\"ph1\">`IEnumerable&lt;Customer&gt;`</ph>, then the range variable is inferred to be <ph id=\"ph2\">`Customer`</ph>.","pos":[1364,1483],"source":" For example, if the source has a type of `IEnumerable<Customer>`, then the range variable is inferred to be `Customer`."},{"content":"The only time that you must specify the type explicitly is when the source is a non-generic <ph id=\"ph1\">`IEnumerable`</ph> type such as <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>.","pos":[1484,1639],"source":" The only time that you must specify the type explicitly is when the source is a non-generic `IEnumerable` type such as <xref:System.Collections.ArrayList>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Query an ArrayList with LINQ<ept id=\"p1\">](../../programming-guide/concepts/linq/how-to-query-an-arraylist-with-linq.md)</ept>.","pos":[1640,1783],"source":" For more information, see [How to: Query an ArrayList with LINQ](../../programming-guide/concepts/linq/how-to-query-an-arraylist-with-linq.md)."},{"content":"In the previous example <ph id=\"ph1\">`num`</ph> is inferred to be of type <ph id=\"ph2\">`int`</ph>.","pos":[1785,1847],"source":"In the previous example `num` is inferred to be of type `int`."},{"content":"Because the range variable is strongly typed, you can call methods on it or use it in other operations.","pos":[1848,1951]},{"content":"For example, instead of writing <ph id=\"ph1\">`select num`</ph>, you could write <ph id=\"ph2\">`select num.ToString()`</ph> to cause the query expression to return a sequence of strings instead of integers.","pos":[1952,2120],"source":" For example, instead of writing `select num`, you could write `select num.ToString()` to cause the query expression to return a sequence of strings instead of integers."},{"content":"Or you could write <ph id=\"ph1\">`select num + 10`</ph> to cause the expression to return the sequence 14, 11, 13, 12, 10.","pos":[2121,2224],"source":" Or you could write `select num + 10` to cause the expression to return the sequence 14, 11, 13, 12, 10."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>select clause<ept id=\"p1\">](select-clause.md)</ept>.","pos":[2225,2285],"source":" For more information, see [select clause](select-clause.md)."},{"content":"The range variable is like an iteration variable in a <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](foreach-in.md)</ept> statement except for one very important difference: a range variable never actually stores data from the source.","pos":[2287,2478],"source":"The range variable is like an iteration variable in a [foreach](foreach-in.md) statement except for one very important difference: a range variable never actually stores data from the source."},{"content":"It's just a syntactic convenience that enables the query to describe what will occur when the query is executed.","pos":[2479,2591]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Introduction to LINQ Queries (C#)<ept id=\"p1\">](../../programming-guide/concepts/linq/introduction-to-linq-queries.md)</ept>.","pos":[2592,2725],"source":" For more information, see [Introduction to LINQ Queries (C#)](../../programming-guide/concepts/linq/introduction-to-linq-queries.md)."},{"pos":[2730,2751],"content":"Compound from clauses","linkify":"Compound from clauses","nodes":[{"content":"Compound from clauses","pos":[0,21]}]},{"content":"In some cases, each element in the source sequence may itself be either a sequence or contain a sequence.","pos":[2753,2858]},{"content":"For example, your data source may be an <ph id=\"ph1\">`IEnumerable&lt;Student&gt;`</ph> where each student object in the sequence contains a list of test scores.","pos":[2859,2995],"source":" For example, your data source may be an `IEnumerable<Student>` where each student object in the sequence contains a list of test scores."},{"content":"To access the inner list within each <ph id=\"ph1\">`Student`</ph> element, you can use compound <ph id=\"ph2\">`from`</ph> clauses.","pos":[2996,3088],"source":" To access the inner list within each `Student` element, you can use compound `from` clauses."},{"content":"The technique is like using nested <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](foreach-in.md)</ept> statements.","pos":[3089,3160],"source":" The technique is like using nested [foreach](foreach-in.md) statements."},{"content":"You can add <bpt id=\"p1\">[</bpt>where<ept id=\"p1\">](partial-method.md)</ept> or <bpt id=\"p2\">[</bpt>orderby<ept id=\"p2\">](orderby-clause.md)</ept> clauses to either <ph id=\"ph1\">`from`</ph> clause to filter the results.","pos":[3161,3286],"source":" You can add [where](partial-method.md) or [orderby](orderby-clause.md) clauses to either `from` clause to filter the results."},{"content":"The following example shows a sequence of <ph id=\"ph1\">`Student`</ph> objects, each of which contains an inner <ph id=\"ph2\">`List`</ph> of integers representing test scores.","pos":[3287,3424],"source":" The following example shows a sequence of `Student` objects, each of which contains an inner `List` of integers representing test scores."},{"content":"To access the inner list, use a compound <ph id=\"ph1\">`from`</ph> clause.","pos":[3425,3480],"source":" To access the inner list, use a compound `from` clause."},{"content":"You can insert clauses between the two <ph id=\"ph1\">`from`</ph> clauses if necessary.","pos":[3481,3548],"source":" You can insert clauses between the two `from` clauses if necessary."},{"pos":[3675,3719],"content":"Using Multiple from Clauses to Perform Joins","linkify":"Using Multiple from Clauses to Perform Joins","nodes":[{"content":"Using Multiple from Clauses to Perform Joins","pos":[0,44]}]},{"content":"A compound <ph id=\"ph1\">`from`</ph> clause is used to access inner collections in a single data source.","pos":[3721,3806],"source":"A compound `from` clause is used to access inner collections in a single data source."},{"content":"However, a query can also contain multiple <ph id=\"ph1\">`from`</ph> clauses that generate supplemental queries from independent data sources.","pos":[3807,3930],"source":" However, a query can also contain multiple `from` clauses that generate supplemental queries from independent data sources."},{"content":"This technique enables you to perform certain types of join operations that are not possible by using the <bpt id=\"p1\">[</bpt>join clause<ept id=\"p1\">](join-clause.md)</ept>.","pos":[3931,4067],"source":" This technique enables you to perform certain types of join operations that are not possible by using the [join clause](join-clause.md)."},{"pos":[4069,4182],"content":"The following example shows how two <ph id=\"ph1\">`from`</ph> clauses can be used to form a complete cross join of two data sources.","source":"The following example shows how two `from` clauses can be used to form a complete cross join of two data sources."},{"pos":[4306,4454],"content":"For more information about join operations that use multiple <ph id=\"ph1\">`from`</ph> clauses, see <bpt id=\"p1\">[</bpt>Perform left outer joins<ept id=\"p1\">](../../linq/perform-left-outer-joins.md)</ept>.","source":"For more information about join operations that use multiple `from` clauses, see [Perform left outer joins](../../linq/perform-left-outer-joins.md)."},{"pos":[4459,4467],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4471,4513],"content":"<bpt id=\"p1\">[</bpt>Query Keywords (LINQ)<ept id=\"p1\">](query-keywords.md)</ept>","source":"[Query Keywords (LINQ)](query-keywords.md)"},{"pos":[4516,4571],"content":"<bpt id=\"p1\">[</bpt>Language Integrated Query (LINQ)<ept id=\"p1\">](../../linq/index.md)</ept>","source":"[Language Integrated Query (LINQ)](../../linq/index.md)"}]}