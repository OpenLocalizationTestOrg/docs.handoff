{"content":"---\ntitle: \"Operator Overloads\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"operators [.NET Framework], overloads\"\n  - \"names [.NET Framework], overloaded operators\"\n  - \"member design guidelines, operators\"\n  - \"overloaded operators\"\nms.assetid: 37585bf2-4c27-4dee-849a-af70e3338cc1\nauthor: \"KrzysztofCwalina\"\n---\n# Operator Overloads\nOperator overloads allow framework types to appear as if they were built-in language primitives.  \n  \n Although allowed and useful in some situations, operator overloads should be used cautiously. There are many cases in which operator overloading has been abused, such as when framework designers started to use operators for operations that should be simple methods. The following guidelines should help you decide when and how to use operator overloading.  \n  \n **X AVOID** defining operator overloads, except in types that should feel like primitive (built-in) types.  \n  \n **✓ CONSIDER** defining operator overloads in a type that should feel like a primitive type.  \n  \n For example, <xref:System.String?displayProperty=nameWithType> has `operator==` and `operator!=` defined.  \n  \n **✓ DO** define operator overloads in structs that represent numbers (such as <xref:System.Decimal?displayProperty=nameWithType>).  \n  \n **X DO NOT** be cute when defining operator overloads.  \n  \n Operator overloading is useful in cases in which it is immediately obvious what the result of the operation will be. For example, it makes sense to be able to subtract one <xref:System.DateTime> from another `DateTime` and get a <xref:System.TimeSpan>. However, it is not appropriate to use the logical union operator to union two database queries, or to use the shift operator to write to a stream.  \n  \n **X DO NOT** provide operator overloads unless at least one of the operands is of the type defining the overload.  \n  \n **✓ DO** overload operators in a symmetric fashion.  \n  \n For example, if you overload the `operator==`, you should also overload the `operator!=`. Similarly, if you overload the `operator<`, you should also overload the `operator>`, and so on.  \n  \n **✓ CONSIDER** providing methods with friendly names that correspond to each overloaded operator.  \n  \n Many languages do not support operator overloading. For this reason, it is recommended that types that overload operators include a secondary method with an appropriate domain-specific name that provides equivalent functionality.  \n  \n The following table contains a list of operators and the corresponding friendly method names.  \n  \n|C# Operator Symbol|Metadata Name|Friendly Name|  \n|-------------------------|-------------------|-------------------|  \n|`N/A`|`op_Implicit`|`To<TypeName>/From<TypeName>`|  \n|`N/A`|`op_Explicit`|`To<TypeName>/From<TypeName>`|  \n|`+ (binary)`|`op_Addition`|`Add`|  \n|`- (binary)`|`op_Subtraction`|`Subtract`|  \n|`* (binary)`|`op_Multiply`|`Multiply`|  \n|`/`|`op_Division`|`Divide`|  \n|`%`|`op_Modulus`|`Mod or Remainder`|  \n|`^`|`op_ExclusiveOr`|`Xor`|  \n|`& (binary)`|`op_BitwiseAnd`|`BitwiseAnd`|  \n|<code>&#124;</code>|`op_BitwiseOr`|`BitwiseOr`|  \n|`&&`|`op_LogicalAnd`|`And`|  \n|<code>&#124;&#124;</code>|`op_LogicalOr`|`Or`|  \n|`=`|`op_Assign`|`Assign`|  \n|`<<`|`op_LeftShift`|`LeftShift`|  \n|`>>`|`op_RightShift`|`RightShift`|  \n|`N/A`|`op_SignedRightShift`|`SignedRightShift`|  \n|`N/A`|`op_UnsignedRightShift`|`UnsignedRightShift`|  \n|`==`|`op_Equality`|`Equals`|  \n|`!=`|`op_Inequality`|`Equals`|  \n|`>`|`op_GreaterThan`|`CompareTo`|  \n|`<`|`op_LessThan`|`CompareTo`|  \n|`>=`|`op_GreaterThanOrEqual`|`CompareTo`|  \n|`<=`|`op_LessThanOrEqual`|`CompareTo`|  \n|`*=`|`op_MultiplicationAssignment`|`Multiply`|  \n|`-=`|`op_SubtractionAssignment`|`Subtract`|  \n|`^=`|`op_ExclusiveOrAssignment`|`Xor`|  \n|`<<=`|`op_LeftShiftAssignment`|`LeftShift`|  \n|`%=`|`op_ModulusAssignment`|`Mod`|  \n|`+=`|`op_AdditionAssignment`|`Add`|  \n|`&=`|`op_BitwiseAndAssignment`|`BitwiseAnd`|  \n|<code>&#124;=</code>|`op_BitwiseOrAssignment`|`BitwiseOr`|  \n|`,`|`op_Comma`|`Comma`|  \n|`/=`|`op_DivisionAssignment`|`Divide`|  \n|`--`|`op_Decrement`|`Decrement`|  \n|`++`|`op_Increment`|`Increment`|  \n|`- (unary)`|`op_UnaryNegation`|`Negate`|  \n|`+ (unary)`|`op_UnaryPlus`|`Plus`|  \n|`~`|`op_OnesComplement`|`OnesComplement`|  \n  \n### Overloading Operator ==  \n Overloading `operator ==` is quite complicated. The semantics of the operator need to be compatible with several other members, such as <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  \n  \n### Conversion Operators  \n Conversion operators are unary operators that allow conversion from one type to another. The operators must be defined as static members on either the operand or the return type. There are two types of conversion operators: implicit and explicit.  \n  \n **X DO NOT** provide a conversion operator if such conversion is not clearly expected by the end users.  \n  \n **X DO NOT** define conversion operators outside of a type’s domain.  \n  \n For example, <xref:System.Int32>, <xref:System.Double>, and <xref:System.Decimal> are all numeric types, whereas <xref:System.DateTime> is not. Therefore, there should be no conversion operator to convert a `Double(long)` to a `DateTime`. A constructor is preferred in such a case.  \n  \n **X DO NOT** provide an implicit conversion operator if the conversion is potentially lossy.  \n  \n For example, there should not be an implicit conversion from `Double` to `Int32` because `Double` has a wider range than `Int32`. An explicit conversion operator can be provided even if the conversion is potentially lossy.  \n  \n **X DO NOT** throw exceptions from implicit casts.  \n  \n It is very difficult for end users to understand what is happening, because they might not be aware that a conversion is taking place.  \n  \n **✓ DO** throw <xref:System.InvalidCastException?displayProperty=nameWithType> if a call to a cast operator results in a lossy conversion and the contract of the operator does not allow lossy conversions.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n","nodes":[{"pos":[4,346],"embed":true,"restype":"x-metadata","content":"title: \"Operator Overloads\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"operators [.NET Framework], overloads\"\n  - \"names [.NET Framework], overloaded operators\"\n  - \"member design guidelines, operators\"\n  - \"overloaded operators\"\nms.assetid: 37585bf2-4c27-4dee-849a-af70e3338cc1\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Operator Overloads","nodes":[{"pos":[0,18],"content":"Operator Overloads","nodes":[{"content":"Operator Overloads","pos":[0,18]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[353,371],"content":"Operator Overloads","linkify":"Operator Overloads","nodes":[{"content":"Operator Overloads","pos":[0,18]}]},{"content":"Operator overloads allow framework types to appear as if they were built-in language primitives.","pos":[372,468]},{"content":"Although allowed and useful in some situations, operator overloads should be used cautiously.","pos":[475,568]},{"content":"There are many cases in which operator overloading has been abused, such as when framework designers started to use operators for operations that should be simple methods.","pos":[569,740]},{"content":"The following guidelines should help you decide when and how to use operator overloading.","pos":[741,830]},{"pos":[837,943],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> defining operator overloads, except in types that should feel like primitive (built-in) types.","source":"**X AVOID** defining operator overloads, except in types that should feel like primitive (built-in) types."},{"pos":[950,1042],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> defining operator overloads in a type that should feel like a primitive type.","source":"**✓ CONSIDER** defining operator overloads in a type that should feel like a primitive type."},{"pos":[1049,1154],"content":"For example, <ph id=\"ph1\">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> has <ph id=\"ph2\">`operator==`</ph> and <ph id=\"ph3\">`operator!=`</ph> defined.","source":"For example, <xref:System.String?displayProperty=nameWithType> has `operator==` and `operator!=` defined."},{"pos":[1161,1291],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> define operator overloads in structs that represent numbers (such as <ph id=\"ph1\">&lt;xref:System.Decimal?displayProperty=nameWithType&gt;</ph>).","source":"**✓ DO** define operator overloads in structs that represent numbers (such as <xref:System.Decimal?displayProperty=nameWithType>)."},{"pos":[1298,1352],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> be cute when defining operator overloads.","source":"**X DO NOT** be cute when defining operator overloads."},{"content":"Operator overloading is useful in cases in which it is immediately obvious what the result of the operation will be.","pos":[1359,1475]},{"content":"For example, it makes sense to be able to subtract one <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> from another <ph id=\"ph2\">`DateTime`</ph> and get a <ph id=\"ph3\">&lt;xref:System.TimeSpan&gt;</ph>.","pos":[1476,1611],"source":" For example, it makes sense to be able to subtract one <xref:System.DateTime> from another `DateTime` and get a <xref:System.TimeSpan>."},{"content":"However, it is not appropriate to use the logical union operator to union two database queries, or to use the shift operator to write to a stream.","pos":[1612,1758]},{"pos":[1765,1878],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide operator overloads unless at least one of the operands is of the type defining the overload.","source":"**X DO NOT** provide operator overloads unless at least one of the operands is of the type defining the overload."},{"pos":[1885,1936],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> overload operators in a symmetric fashion.","source":"**✓ DO** overload operators in a symmetric fashion."},{"content":"For example, if you overload the <ph id=\"ph1\">`operator==`</ph>, you should also overload the <ph id=\"ph2\">`operator!=`</ph>.","pos":[1943,2032],"source":"For example, if you overload the `operator==`, you should also overload the `operator!=`."},{"content":"Similarly, if you overload the <ph id=\"ph1\">`operator&lt;`</ph>, you should also overload the <ph id=\"ph2\">`operator&gt;`</ph>, and so on.","pos":[2033,2129],"source":" Similarly, if you overload the `operator<`, you should also overload the `operator>`, and so on."},{"pos":[2136,2233],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> providing methods with friendly names that correspond to each overloaded operator.","source":"**✓ CONSIDER** providing methods with friendly names that correspond to each overloaded operator."},{"content":"Many languages do not support operator overloading.","pos":[2240,2291]},{"content":"For this reason, it is recommended that types that overload operators include a secondary method with an appropriate domain-specific name that provides equivalent functionality.","pos":[2292,2469]},{"content":"The following table contains a list of operators and the corresponding friendly method names.","pos":[2476,2569]},{"content":"C# Operator Symbol","pos":[2576,2594]},{"content":"Metadata Name","pos":[2595,2608]},{"content":"Friendly Name","pos":[2609,2622]},{"pos":[4289,4312],"content":"Overloading Operator ==","linkify":"Overloading Operator ==","nodes":[{"content":"Overloading Operator ==","pos":[0,23]}]},{"content":"Overloading <ph id=\"ph1\">`operator ==`</ph> is quite complicated.","pos":[4316,4363],"source":"Overloading `operator ==` is quite complicated."},{"content":"The semantics of the operator need to be compatible with several other members, such as <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.","pos":[4364,4512],"source":" The semantics of the operator need to be compatible with several other members, such as <xref:System.Object.Equals%2A?displayProperty=nameWithType>."},{"pos":[4522,4542],"content":"Conversion Operators","linkify":"Conversion Operators","nodes":[{"content":"Conversion Operators","pos":[0,20]}]},{"content":"Conversion operators are unary operators that allow conversion from one type to another.","pos":[4546,4634]},{"content":"The operators must be defined as static members on either the operand or the return type.","pos":[4635,4724]},{"content":"There are two types of conversion operators: implicit and explicit.","pos":[4725,4792]},{"pos":[4799,4902],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide a conversion operator if such conversion is not clearly expected by the end users.","source":"**X DO NOT** provide a conversion operator if such conversion is not clearly expected by the end users."},{"pos":[4909,4977],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> define conversion operators outside of a type’s domain.","source":"**X DO NOT** define conversion operators outside of a type’s domain."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Double&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Decimal&gt;</ph> are all numeric types, whereas <ph id=\"ph4\">&lt;xref:System.DateTime&gt;</ph> is not.","pos":[4984,5127],"source":"For example, <xref:System.Int32>, <xref:System.Double>, and <xref:System.Decimal> are all numeric types, whereas <xref:System.DateTime> is not."},{"content":"Therefore, there should be no conversion operator to convert a <ph id=\"ph1\">`Double(long)`</ph> to a <ph id=\"ph2\">`DateTime`</ph>.","pos":[5128,5222],"source":" Therefore, there should be no conversion operator to convert a `Double(long)` to a `DateTime`."},{"content":"A constructor is preferred in such a case.","pos":[5223,5265]},{"pos":[5272,5364],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> provide an implicit conversion operator if the conversion is potentially lossy.","source":"**X DO NOT** provide an implicit conversion operator if the conversion is potentially lossy."},{"content":"For example, there should not be an implicit conversion from <ph id=\"ph1\">`Double`</ph> to <ph id=\"ph2\">`Int32`</ph> because <ph id=\"ph3\">`Double`</ph> has a wider range than <ph id=\"ph4\">`Int32`</ph>.","pos":[5371,5500],"source":"For example, there should not be an implicit conversion from `Double` to `Int32` because `Double` has a wider range than `Int32`."},{"content":"An explicit conversion operator can be provided even if the conversion is potentially lossy.","pos":[5501,5593]},{"pos":[5600,5650],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> throw exceptions from implicit casts.","source":"**X DO NOT** throw exceptions from implicit casts."},{"content":"It is very difficult for end users to understand what is happening, because they might not be aware that a conversion is taking place.","pos":[5657,5791]},{"pos":[5798,6002],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> throw <ph id=\"ph1\">&lt;xref:System.InvalidCastException?displayProperty=nameWithType&gt;</ph> if a call to a cast operator results in a lossy conversion and the contract of the operator does not allow lossy conversions.","source":"**✓ DO** throw <xref:System.InvalidCastException?displayProperty=nameWithType> if a call to a cast operator results in a lossy conversion and the contract of the operator does not allow lossy conversions."},{"pos":[6009,6076],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[6083,6488],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[6497,6505],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6509,6587],"content":"<bpt id=\"p1\">[</bpt>Member Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/member.md)</ept>","source":"[Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)"},{"pos":[6590,6670],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"}]}