{"content":"---\ntitle: \"What's new for Visual Basic\"\nms.date: 10/24/2018\nf1_keywords: \n  - \"VB.StartPage.WhatsNew\"\nhelpviewer_keywords: \n  - \"new features, Visual Basic\"\n  - \"what's new [Visual Basic]\"\n  - \"Visual Basic, what's new\"\nms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02\n---\n# What's new for Visual Basic\n\nThis topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.\n  \n## Current version\n\nVisual Basic 15.8 / Visual Studio 2017 Version 15.8  \nFor new features, see [Visual Basic 15.8](#visual-basic-158)\n\n## Previous versions\n\nVisual Basic 15.5 / Visual Studio 2017 Version 15.5  \nFor new features, see [Visual Basic 15.5](#visual-basic-155)\n\nVisual Basic 15.3 / Visual Studio 2017 Version 15.3  \nFor new features, see [Visual Basic 15.3](#visual-basic-153)\n\nVisual Basic 2017 / Visual Studio 2017  \nFor new features, see [Visual Basic 2017](#visual-basic-2017)\n\nVisual Basic / Visual Studio 2015   \nFor new features, see [Visual Basic 14](#visual-basic-14)\n\nVisual Basic / Visual Studio 2013  \nTechnology previews of the .NET Compiler Platform (“Roslyn”)\n\nVisual Basic / Visual Studio 2012   \n`Async` and `await` keywords, iterators, caller info attributes\n\nVisual Basic, Visual Studio 2010   \nAuto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access\n\nVisual Basic / Visual Studio 2008   \nLanguage Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types  \n\nVisual Basic / Visual Studio 2005   \nThe `My` type and helper types (access to app, computer, files system, network)\n\nVisual Basic / Visual Studio .NET 2003   \nBit-shift operators, loop variable declaration\n\nVisual Basic / Visual Studio .NET 2002   \nThe first release of Visual Basic .NET\n\n## Visual Basic 15.8\n\n**Optimized floating-point to integer conversion**\n\nIn previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance. Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) is set to `Off`:\n\n- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>\n- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>\n- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>\n- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>\n- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>\n- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>\n- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>\n- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>\n- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>\n- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>\n\nThis optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types. The following example illustrates some simple method calls that are affected by this optimization:\n\n```vb\nDim s As Single = 173.7619\nDim d As Double = s \n\nDim i1 As Integer = CInt(Fix(s))               ' Result: 173\nDim b1 As Byte = CByte(Int(d))                 ' Result: 173\nDim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173\nDim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174\nDim i3 As Integer = CInt(Math.Round(s))        ' Result: 174\n\n```\n\nNote that this truncates rather than rounds floating-point values.\n\n## Visual Basic 15.5\n\n[Non-trailing named arguments](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)\n\nIn Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments. Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position. This is particularly useful when named arguments are used to make code more readable.\n\nFor example, the following method call has two positional arguments between a named argument. The named argument makes it clear that the value 19 represents an age.\n\n```vb\nStudentInfo.Display(\"Mary\", age:=19, #9/21/1998#)\n```\n\n[`Private Protected` member access modifier](../language-reference/modifiers/private-protected.md)\n\nThis new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly. Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.\n\n**Leading hex/binary/octal separator**\n\nVisual Basic 2017 added support for the underscore character (`_`) as a digit separator. Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits. The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:\n\n```vb\nDim number As Integer = &H_C305_F860\n``` \nTo use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\\*.vbproj) file:\n\n```xml\n<PropertyGroup>\n  <LangVersion>15.5</LangVersion>\n</PropertyGroup>\n```\n\n## Visual Basic 15.3\n\n[**Named tuple inference**](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)\n\nWhen you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element. The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.\n\n[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]\n\n**Additional compiler switches**  \n\nThe Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies. **-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.\n\n## Visual Basic 2017\n\n[**Tuples**](../programming-guide/language-features/data-types/tuples.md)\n\nTuples are a lightweight data structure that most commonly is used to return multiple values from a single method call. Ordinarily, to return multiple values from a method, you have to do one of the following:\n\n- Define a custom type (a `Class` or a `Structure`). This is a heavyweight solution.\n\n- Define one or more `ByRef` parameters, in addition to returning a value from the method.\n \nVisual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values. The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.\n\n[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]\n\nYou can then call the method and handle the returned tuple with code like the following.\n\n[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] \n\n**Binary literals and digit separators**\n\nYou can define a binary literal by using the prefix `&B` or `&b`. In addition, you can use the underscore character, `_`, as a digit separator to enhance readability. The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.\n\n[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]\n\nFor more information, see the \"Literal assignments\" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.\n\n[**Support for C# reference return values**](../programming-guide/language-features/procedures/ref-return-values.md)\n\nStarting with C# 7.0, C# supports reference return values. That is, when the calling method receives a value returned by reference, it can change the value of the reference. Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.\n\nFor example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring. The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful. This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.\n\n[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]\n\nIn its simplest form, you can modify the word found in the sentence by using code like the following. Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.\n\n[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]\n\nA problem with this code, though, is that if a match is not found, the method returns the first word. Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match. The following example corrects this by replacing the first word with itself if there is no match.\n\n[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]\n\nA better solution is to use a helper method to which the reference return value is passed by reference. The helper method can then modify the argument passed to it by reference. The following example does that.\n\n[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]\n\nFor more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).\n\n## Visual Basic 14\n\n[Nameof](../../csharp/language-reference/keywords/nameof.md)  \n You can get the unqualified string name of a type or member for use in an error message without hard coding a string.  This allows your code to remain correct when refactoring.  This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.  \n  \n[String interpolation](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  \n You can use string interpolation expressions to construct strings.  An interpolated string expression looks like a template string that contains expressions.  An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).  \n  \n[Null-conditional member access and indexing](../language-reference/operators/null-conditional-operators.md)  \nYou can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.  These operators help you write less code to handle null checks, especially for descending into data structures.  If the left operand or object reference is null, the operations returns null.  \n  \n[Multi-line string literals](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  \n String literals can contain newline sequences.  You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`  \n  \n**Comments**  \nYou can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.  \n  \n**Smarter fully-qualified name resolution**  \n Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace \"Threading\", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.  Visual Basic now considers both possible namespaces together.  If you show the completion list, the Visual Studio editor lists members from both types in the completion list.  \n  \n **Year-first date literals**  \n You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.  \n  \n **Readonly interface properties**  \n You can implement readonly interface properties using a readwrite property.  The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.  \n  \n [TypeOf \\<expr> IsNot \\<type>](../../visual-basic/language-reference/operators/typeof-operator.md)  \n For more readability of your code, you can now use `TypeOf` with `IsNot`.  \n  \n [#Disable Warning \\<ID> and #Enable Warning \\<ID>](../../visual-basic/language-reference/directives/index.md)  \n You can disable and enable specific warnings for regions within a source file.  \n  \n **XML doc comment improvements**  \n When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.  \n  \n [Partial module and interface definitions](../../visual-basic/language-reference/modifiers/partial.md)  \n In addition to classes and structs, you can declare partial modules and interfaces.  \n  \n [#Region directives inside method bodies](../../visual-basic/language-reference/directives/region-directive.md)  \n You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.  \n  \n [Overrides definitions are implicitly overloads](../../visual-basic/language-reference/modifiers/overrides.md)  \n If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.  \n  \n **CObj allowed in attributes arguments**  \n The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.  \n  \n **Declaring and consuming ambiguous methods from different interfaces**  \n Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):  \n  \n```vb  \nInterface ICustomer  \n  Sub GetDetails(x As Integer)  \nEnd Interface  \n  \nInterface ITime  \n  Sub GetDetails(x As String)  \nEnd Interface  \n  \nInterface IMock : Inherits ICustomer, ITime  \n  Overloads Sub GetDetails(x As Char)  \nEnd Interface  \n  \nInterface IMock2 : Inherits ICustomer, ITime  \nEnd Interface  \n```  \n  \n Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.  \n  \n## See also\n\n- [What's New in Visual Studio 2017](/visualstudio/ide/whats-new-in-visual-studio)\n","nodes":[{"pos":[4,269],"embed":true,"restype":"x-metadata","content":"title: \"What's new for Visual Basic\"\nms.date: 10/24/2018\nf1_keywords: \n  - \"VB.StartPage.WhatsNew\"\nhelpviewer_keywords: \n  - \"new features, Visual Basic\"\n  - \"what's new [Visual Basic]\"\n  - \"Visual Basic, what's new\"\nms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02","nodes":[{"content":"What's new for Visual Basic","nodes":[{"pos":[0,27],"content":"What's new for Visual Basic","nodes":[{"content":"What's new for Visual Basic","pos":[0,27]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[276,303],"content":"What's new for Visual Basic","linkify":"What's new for Visual Basic","nodes":[{"content":"What's new for Visual Basic","pos":[0,27]}]},{"content":"This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.","pos":[305,473]},{"pos":[480,495],"content":"Current version","linkify":"Current version","nodes":[{"content":"Current version","pos":[0,15]}]},{"content":"Visual Basic 15.8 / Visual Studio 2017 Version 15.8","pos":[497,548]},{"content":"For new features, see <bpt id=\"p1\">[</bpt>Visual Basic 15.8<ept id=\"p1\">](#visual-basic-158)</ept>","pos":[551,611],"source":"For new features, see [Visual Basic 15.8](#visual-basic-158)"},{"pos":[616,633],"content":"Previous versions","linkify":"Previous versions","nodes":[{"content":"Previous versions","pos":[0,17]}]},{"content":"Visual Basic 15.5 / Visual Studio 2017 Version 15.5","pos":[635,686]},{"content":"For new features, see <bpt id=\"p1\">[</bpt>Visual Basic 15.5<ept id=\"p1\">](#visual-basic-155)</ept>","pos":[689,749],"source":"For new features, see [Visual Basic 15.5](#visual-basic-155)"},{"content":"Visual Basic 15.3 / Visual Studio 2017 Version 15.3","pos":[751,802]},{"content":"For new features, see <bpt id=\"p1\">[</bpt>Visual Basic 15.3<ept id=\"p1\">](#visual-basic-153)</ept>","pos":[805,865],"source":"For new features, see [Visual Basic 15.3](#visual-basic-153)"},{"content":"Visual Basic 2017 / Visual Studio 2017","pos":[867,905]},{"content":"For new features, see <bpt id=\"p1\">[</bpt>Visual Basic 2017<ept id=\"p1\">](#visual-basic-2017)</ept>","pos":[908,969],"source":"For new features, see [Visual Basic 2017](#visual-basic-2017)"},{"content":"Visual Basic / Visual Studio 2015","pos":[971,1004]},{"content":"For new features, see <bpt id=\"p1\">[</bpt>Visual Basic 14<ept id=\"p1\">](#visual-basic-14)</ept>","pos":[1008,1065],"source":"For new features, see [Visual Basic 14](#visual-basic-14)"},{"content":"Visual Basic / Visual Studio 2013","pos":[1067,1100]},{"content":"Technology previews of the .NET Compiler Platform (“Roslyn”)","pos":[1103,1163]},{"content":"Visual Basic / Visual Studio 2012","pos":[1165,1198]},{"content":"<ph id=\"ph1\">`Async`</ph> and <ph id=\"ph2\">`await`</ph> keywords, iterators, caller info attributes","pos":[1202,1265],"source":"`Async` and `await` keywords, iterators, caller info attributes"},{"content":"Visual Basic, Visual Studio 2010","pos":[1267,1299]},{"content":"Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access","pos":[1303,1445]},{"content":"Visual Basic / Visual Studio 2008","pos":[1447,1480]},{"content":"Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local <ph id=\"ph1\">`var`</ph> type inference, lambda expressions, <ph id=\"ph2\">`if`</ph> operator, partial methods, nullable value types","pos":[1484,1711],"source":"Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types"},{"content":"Visual Basic / Visual Studio 2005","pos":[1715,1748]},{"content":"The <ph id=\"ph1\">`My`</ph> type and helper types (access to app, computer, files system, network)","pos":[1752,1831],"source":"The `My` type and helper types (access to app, computer, files system, network)"},{"content":"Visual Basic / Visual Studio .NET 2003","pos":[1833,1871]},{"content":"Bit-shift operators, loop variable declaration","pos":[1875,1921]},{"content":"Visual Basic / Visual Studio .NET 2002","pos":[1923,1961]},{"content":"The first release of Visual Basic .NET","pos":[1965,2003]},{"pos":[2008,2025],"content":"Visual Basic 15.8","linkify":"Visual Basic 15.8","nodes":[{"content":"Visual Basic 15.8","pos":[0,17]}]},{"pos":[2027,2077],"content":"<bpt id=\"p1\">**</bpt>Optimized floating-point to integer conversion<ept id=\"p1\">**</ept>","source":"**Optimized floating-point to integer conversion**"},{"content":"In previous versions of Visual Basic, conversion of <bpt id=\"p1\">[</bpt>Double<ept id=\"p1\">](../language-reference/data-types/double-data-type.md)</ept> and <bpt id=\"p2\">[</bpt>Single<ept id=\"p2\">](../language-reference/data-types/single-data-type.md)</ept> values to integers offered relatively poor performance.","pos":[2079,2316],"source":"In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance."},{"content":"Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the <bpt id=\"p1\">[</bpt>intrinsic Visual Basic integer conversion functions<ept id=\"p1\">](../language-reference/functions/type-conversion-functions.md)</ept> (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when <bpt id=\"p2\">[</bpt>Option Strict<ept id=\"p2\">](~/docs/visual-basic/language-reference/statements/option-strict-statement.md)</ept> is set to <ph id=\"ph1\">`Off`</ph>:","pos":[2317,2884],"source":" Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) is set to `Off`:"},{"content":"This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.","pos":[3716,3849]},{"content":"The following example illustrates some simple method calls that are affected by this optimization:","pos":[3850,3948]},{"content":"Note that this truncates rather than rounds floating-point values.","pos":[4316,4382]},{"pos":[4387,4404],"content":"Visual Basic 15.5","linkify":"Visual Basic 15.5","nodes":[{"content":"Visual Basic 15.5","pos":[0,17]}]},{"pos":[4406,4573],"content":"<bpt id=\"p1\">[</bpt>Non-trailing named arguments<ept id=\"p1\">](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)</ept>","source":"[Non-trailing named arguments](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)"},{"content":"In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.","pos":[4575,4738]},{"content":"Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.","pos":[4739,4915]},{"content":"This is particularly useful when named arguments are used to make code more readable.","pos":[4916,5001]},{"content":"For example, the following method call has two positional arguments between a named argument.","pos":[5003,5096]},{"content":"The named argument makes it clear that the value 19 represents an age.","pos":[5097,5167]},{"pos":[5230,5328],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`Private Protected`</ph> member access modifier<ept id=\"p1\">](../language-reference/modifiers/private-protected.md)</ept>","source":"[`Private Protected` member access modifier](../language-reference/modifiers/private-protected.md)"},{"content":"This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.","pos":[5330,5548]},{"content":"Because structures cannot be inherited, <ph id=\"ph1\">`Private Protected`</ph> can only be applied to the members of a class.","pos":[5549,5655],"source":" Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class."},{"pos":[5657,5695],"content":"<bpt id=\"p1\">**</bpt>Leading hex/binary/octal separator<ept id=\"p1\">**</ept>","source":"**Leading hex/binary/octal separator**"},{"content":"Visual Basic 2017 added support for the underscore character (<ph id=\"ph1\">`_`</ph>) as a digit separator.","pos":[5697,5785],"source":"Visual Basic 2017 added support for the underscore character (`_`) as a digit separator."},{"content":"Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.","pos":[5786,5939]},{"content":"The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:","pos":[5940,6041]},{"content":"To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (<ph id=\"ph1\">\\*</ph>.vbproj) file:","pos":[6091,6228],"source":"To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\\*.vbproj) file:"},{"pos":[6312,6329],"content":"Visual Basic 15.3","linkify":"Visual Basic 15.3","nodes":[{"content":"Visual Basic 15.3","pos":[0,17]}]},{"pos":[6331,6448],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Named tuple inference<ept id=\"p2\">**</ept><ept id=\"p1\">](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)</ept>","source":"[**Named tuple inference**](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)"},{"content":"When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.","pos":[6450,6647]},{"content":"The following example uses inference to create a tuple with three named elements, <ph id=\"ph1\">`state`</ph>, <ph id=\"ph2\">`stateName`</ph>, and <ph id=\"ph3\">`capital`</ph>.","pos":[6648,6766],"source":" The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`."},{"pos":[6914,6946],"content":"<bpt id=\"p1\">**</bpt>Additional compiler switches<ept id=\"p1\">**</ept>","source":"**Additional compiler switches**"},{"content":"The Visual Basic command-line compiler now supports the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>-refout<ept id=\"p2\">**</ept><ept id=\"p1\">](../reference/command-line-compiler/refout-compiler-option.md)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>-refonly<ept id=\"p4\">**</ept><ept id=\"p3\">](../reference/command-line-compiler/refonly-compiler-option.md)</ept> compiler options to control the output of reference assemblies.","pos":[6950,7227],"source":"The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies."},{"content":"<bpt id=\"p1\">**</bpt>-refout<ept id=\"p1\">**</ept> defines the output directory of the reference assembly, and <bpt id=\"p2\">**</bpt>-refonly<ept id=\"p2\">**</ept> specifies that only a reference assembly is to be output by compilation.","pos":[7228,7385],"source":"**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation."},{"pos":[7390,7407],"content":"Visual Basic 2017","linkify":"Visual Basic 2017","nodes":[{"content":"Visual Basic 2017","pos":[0,17]}]},{"pos":[7409,7482],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Tuples<ept id=\"p2\">**</ept><ept id=\"p1\">](../programming-guide/language-features/data-types/tuples.md)</ept>","source":"[**Tuples**](../programming-guide/language-features/data-types/tuples.md)"},{"content":"Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.","pos":[7484,7603]},{"content":"Ordinarily, to return multiple values from a method, you have to do one of the following:","pos":[7604,7693]},{"content":"Define a custom type (a <ph id=\"ph1\">`Class`</ph> or a <ph id=\"ph2\">`Structure`</ph>).","pos":[7697,7747],"source":"Define a custom type (a `Class` or a `Structure`)."},{"content":"This is a heavyweight solution.","pos":[7748,7779]},{"pos":[7783,7871],"content":"Define one or more <ph id=\"ph1\">`ByRef`</ph> parameters, in addition to returning a value from the method.","source":"Define one or more `ByRef` parameters, in addition to returning a value from the method."},{"content":"Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.","pos":[7874,8021]},{"content":"The following example wraps a call to the <ph id=\"ph1\">&lt;xref:System.Int32.TryParse%2A&gt;</ph> method and returns a tuple.","pos":[8022,8123],"source":" The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple."},{"content":"You can then call the method and handle the returned tuple with code like the following.","pos":[8249,8337]},{"pos":[8470,8510],"content":"<bpt id=\"p1\">**</bpt>Binary literals and digit separators<ept id=\"p1\">**</ept>","source":"**Binary literals and digit separators**"},{"content":"You can define a binary literal by using the prefix <ph id=\"ph1\">`&amp;B`</ph> or <ph id=\"ph2\">`&amp;b`</ph>.","pos":[8512,8577],"source":"You can define a binary literal by using the prefix `&B` or `&b`."},{"content":"In addition, you can use the underscore character, <ph id=\"ph1\">`_`</ph>, as a digit separator to enhance readability.","pos":[8578,8678],"source":" In addition, you can use the underscore character, `_`, as a digit separator to enhance readability."},{"content":"The following example uses both features to assign a <ph id=\"ph1\">`Byte`</ph> value and to display it as a decimal, hexadecimal, and binary number.","pos":[8679,8808],"source":" The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number."},{"pos":[8902,9647],"content":"For more information, see the \"Literal assignments\" section of the <bpt id=\"p1\">[</bpt>Byte<ept id=\"p1\">](../language-reference/data-types/byte-data-type.md#literal-assignments)</ept>, <bpt id=\"p2\">[</bpt>Integer<ept id=\"p2\">](../language-reference/data-types/integer-data-type.md#literal-assignments)</ept>, <bpt id=\"p3\">[</bpt>Long<ept id=\"p3\">](../language-reference/data-types/long-data-type.md#literal-assignments)</ept>, <bpt id=\"p4\">[</bpt>Short<ept id=\"p4\">](../language-reference/data-types/short-data-type.md#literal-assignments)</ept>, <bpt id=\"p5\">[</bpt>SByte<ept id=\"p5\">](../language-reference/data-types/sbyte-data-type.md#literal-assignments)</ept>, <bpt id=\"p6\">[</bpt>UInteger<ept id=\"p6\">](../language-reference/data-types/uinteger-data-type.md#literal-assignments)</ept>, <bpt id=\"p7\">[</bpt>ULong<ept id=\"p7\">](../language-reference/data-types/ulong-data-type.md#literal-assignments)</ept>, and <bpt id=\"p8\">[</bpt>UShort<ept id=\"p8\">](../language-reference/data-types/ushort-data-type.md#literal-assignments)</ept> data types.","source":"For more information, see the \"Literal assignments\" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types."},{"pos":[9649,9765],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Support for C# reference return values<ept id=\"p2\">**</ept><ept id=\"p1\">](../programming-guide/language-features/procedures/ref-return-values.md)</ept>","source":"[**Support for C# reference return values**](../programming-guide/language-features/procedures/ref-return-values.md)"},{"content":"Starting with C# 7.0, C# supports reference return values.","pos":[9767,9825]},{"content":"That is, when the calling method receives a value returned by reference, it can change the value of the reference.","pos":[9826,9940]},{"content":"Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.","pos":[9941,10093]},{"content":"For example, the following <ph id=\"ph1\">`Sentence`</ph> class written in C# includes a <ph id=\"ph2\">`FindNext`</ph> method that finds the next word in a sentence that begins with a specified substring.","pos":[10095,10260],"source":"For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring."},{"content":"The string is returned as a reference return value, and a <ph id=\"ph1\">`Boolean`</ph> variable passed by reference to the method indicates whether the search was successful.","pos":[10261,10416],"source":" The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful."},{"content":"This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the <ph id=\"ph1\">`Sentence`</ph> class.","pos":[10417,10571],"source":" This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class."},{"content":"In its simplest form, you can modify the word found in the sentence by using code like the following.","pos":[10671,10772]},{"content":"Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.","pos":[10773,10918]},{"content":"A problem with this code, though, is that if a match is not found, the method returns the first word.","pos":[11015,11116]},{"content":"Since the example does not examine the value of the <ph id=\"ph1\">`Boolean`</ph> argument to determine whether a match is found, it modifies the first word if there is no match.","pos":[11117,11275],"source":" Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match."},{"content":"The following example corrects this by replacing the first word with itself if there is no match.","pos":[11276,11373]},{"content":"A better solution is to use a helper method to which the reference return value is passed by reference.","pos":[11470,11573]},{"content":"The helper method can then modify the argument passed to it by reference.","pos":[11574,11647]},{"content":"The following example does that.","pos":[11648,11680]},{"pos":[11784,11908],"content":"For more information, see <bpt id=\"p1\">[</bpt>Reference Return Values<ept id=\"p1\">](../programming-guide/language-features/procedures/ref-return-values.md)</ept>.","source":"For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md)."},{"pos":[11913,11928],"content":"Visual Basic 14","linkify":"Visual Basic 14","nodes":[{"content":"Visual Basic 14","pos":[0,15]}]},{"content":"<bpt id=\"p1\">[</bpt>Nameof<ept id=\"p1\">](../../csharp/language-reference/keywords/nameof.md)</ept>","pos":[11930,11990],"source":"[Nameof](../../csharp/language-reference/keywords/nameof.md)"},{"content":"You can get the unqualified string name of a type or member for use in an error message without hard coding a string.","pos":[11994,12111]},{"content":"This allows your code to remain correct when refactoring.","pos":[12113,12170]},{"content":"This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.","pos":[12172,12282]},{"content":"<bpt id=\"p1\">[</bpt>String interpolation<ept id=\"p1\">](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)</ept>","pos":[12288,12398],"source":"[String interpolation](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)"},{"content":"You can use string interpolation expressions to construct strings.","pos":[12402,12468]},{"content":"An interpolated string expression looks like a template string that contains expressions.","pos":[12470,12559]},{"content":"An interpolated string is easier to understand with respect to arguments than <bpt id=\"p1\">[</bpt>Composite Formatting<ept id=\"p1\">](../../standard/base-types/composite-format.md)</ept>.","pos":[12561,12709],"source":"  An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md)."},{"content":"<bpt id=\"p1\">[</bpt>Null-conditional member access and indexing<ept id=\"p1\">](../language-reference/operators/null-conditional-operators.md)</ept>","pos":[12715,12823],"source":"[Null-conditional member access and indexing](../language-reference/operators/null-conditional-operators.md)"},{"content":"You can test for null in a very light syntactic way before performing a member access (<ph id=\"ph1\">`?.`</ph>) or index (<ph id=\"ph2\">`?[]`</ph>) operation.","pos":[12826,12946],"source":"You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation."},{"content":"These operators help you write less code to handle null checks, especially for descending into data structures.","pos":[12948,13059]},{"content":"If the left operand or object reference is null, the operations returns null.","pos":[13061,13138]},{"content":"<bpt id=\"p1\">[</bpt>Multi-line string literals<ept id=\"p1\">](../../visual-basic/programming-guide/language-features/strings/string-basics.md)</ept>","pos":[13144,13253],"source":"[Multi-line string literals](../../visual-basic/programming-guide/language-features/strings/string-basics.md)"},{"content":"String literals can contain newline sequences.","pos":[13257,13303]},{"content":"You no longer need the old work around of using <ph id=\"ph1\">`&lt;xml&gt;&lt;![CDATA[...text with newlines...]]&gt;&lt;/xml&gt;.Value`</ph>","pos":[13305,13408],"source":"  You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`"},{"content":"<bpt id=\"p1\">**</bpt>Comments<ept id=\"p1\">**</ept>","pos":[13414,13426],"source":"**Comments**"},{"content":"You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.","pos":[13429,13549]},{"content":"<bpt id=\"p1\">**</bpt>Smarter fully-qualified name resolution<ept id=\"p1\">**</ept>","pos":[13555,13598],"source":"**Smarter fully-qualified name resolution**"},{"content":"Given code such as <ph id=\"ph1\">`Threading.Thread.Sleep(1000)`</ph>, Visual Basic used to look up the namespace \"Threading\", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.","pos":[13602,13815],"source":"Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace \"Threading\", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error."},{"content":"Visual Basic now considers both possible namespaces together.","pos":[13817,13878]},{"content":"If you show the completion list, the Visual Studio editor lists members from both types in the completion list.","pos":[13880,13991]},{"content":"<bpt id=\"p1\">**</bpt>Year-first date literals<ept id=\"p1\">**</ept>","pos":[13998,14026],"source":"**Year-first date literals**"},{"content":"You can have date literals in yyyy-mm-dd format, <ph id=\"ph1\">`#2015-03-17 16:10 PM#`</ph>.","pos":[14030,14103],"source":"You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`."},{"content":"<bpt id=\"p1\">**</bpt>Readonly interface properties<ept id=\"p1\">**</ept>","pos":[14110,14143],"source":"**Readonly interface properties**"},{"content":"You can implement readonly interface properties using a readwrite property.","pos":[14147,14222]},{"content":"The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.","pos":[14224,14352]},{"content":"<bpt id=\"p1\">[</bpt>TypeOf <ph id=\"ph1\">\\&lt;</ph>expr&gt; IsNot <ph id=\"ph2\">\\&lt;</ph>type&gt;<ept id=\"p1\">](../../visual-basic/language-reference/operators/typeof-operator.md)</ept>","pos":[14359,14457],"source":"[TypeOf \\<expr> IsNot \\<type>](../../visual-basic/language-reference/operators/typeof-operator.md)"},{"content":"For more readability of your code, you can now use <ph id=\"ph1\">`TypeOf`</ph> with <ph id=\"ph2\">`IsNot`</ph>.","pos":[14461,14534],"source":"For more readability of your code, you can now use `TypeOf` with `IsNot`."},{"content":"<bpt id=\"p1\">[</bpt>#Disable Warning <ph id=\"ph1\">\\&lt;</ph>ID&gt; and #Enable Warning <ph id=\"ph2\">\\&lt;</ph>ID&gt;<ept id=\"p1\">](../../visual-basic/language-reference/directives/index.md)</ept>","pos":[14541,14650],"source":"[#Disable Warning \\<ID> and #Enable Warning \\<ID>](../../visual-basic/language-reference/directives/index.md)"},{"content":"You can disable and enable specific warnings for regions within a source file.","pos":[14654,14732]},{"content":"<bpt id=\"p1\">**</bpt>XML doc comment improvements<ept id=\"p1\">**</ept>","pos":[14739,14771],"source":"**XML doc comment improvements**"},{"content":"When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of <ph id=\"ph1\">`crefs`</ph> (generics, operators, etc.), colorizing, and refactoring.","pos":[14775,14957],"source":"When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring."},{"content":"<bpt id=\"p1\">[</bpt>Partial module and interface definitions<ept id=\"p1\">](../../visual-basic/language-reference/modifiers/partial.md)</ept>","pos":[14964,15066],"source":"[Partial module and interface definitions](../../visual-basic/language-reference/modifiers/partial.md)"},{"content":"In addition to classes and structs, you can declare partial modules and interfaces.","pos":[15070,15153]},{"content":"<bpt id=\"p1\">[</bpt>#Region directives inside method bodies<ept id=\"p1\">](../../visual-basic/language-reference/directives/region-directive.md)</ept>","pos":[15160,15271],"source":"[#Region directives inside method bodies](../../visual-basic/language-reference/directives/region-directive.md)"},{"content":"You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.","pos":[15275,15397]},{"content":"<bpt id=\"p1\">[</bpt>Overrides definitions are implicitly overloads<ept id=\"p1\">](../../visual-basic/language-reference/modifiers/overrides.md)</ept>","pos":[15404,15514],"source":"[Overrides definitions are implicitly overloads](../../visual-basic/language-reference/modifiers/overrides.md)"},{"content":"If you add the <ph id=\"ph1\">`Overrides`</ph> modifier to a definition, the compiler implicitly adds <ph id=\"ph2\">`Overloads`</ph> so that you can type less code in common cases.","pos":[15518,15659],"source":"If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases."},{"content":"<bpt id=\"p1\">**</bpt>CObj allowed in attributes arguments<ept id=\"p1\">**</ept>","pos":[15666,15706],"source":"**CObj allowed in attributes arguments**"},{"content":"The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.","pos":[15710,15814]},{"content":"<bpt id=\"p1\">**</bpt>Declaring and consuming ambiguous methods from different interfaces<ept id=\"p1\">**</ept>","pos":[15821,15892],"source":"**Declaring and consuming ambiguous methods from different interfaces**"},{"content":"Previously the following code yielded errors that prevented you from declaring <ph id=\"ph1\">`IMock`</ph> or from calling <ph id=\"ph2\">`GetDetails`</ph> (if these had been declared in C#):","pos":[15896,16047],"source":"Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):"},{"pos":[16382,16585],"content":"Now the compiler will use normal overload resolution rules to choose the most appropriate <ph id=\"ph1\">`GetDetails`</ph> to call, and you can declare interface relationships in Visual Basic like those shown in the sample.","source":"Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample."},{"pos":[16594,16602],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[16606,16686],"content":"<bpt id=\"p1\">[</bpt>What's New in Visual Studio 2017<ept id=\"p1\">](/visualstudio/ide/whats-new-in-visual-studio)</ept>","source":"[What's New in Visual Studio 2017](/visualstudio/ide/whats-new-in-visual-studio)"}]}