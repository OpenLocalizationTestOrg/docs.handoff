{"content":"---\ntitle: \"Custom Message Interceptor\"\nms.date: \"03/30/2017\"\nms.assetid: 73f20972-53f8-475a-8bfe-c133bfa225b0\n---\n# Custom Message Interceptor\nThis sample demonstrates the use of the channel extensibility model. In particular, it shows how to implement a custom binding element that creates channel factories and channel listeners to intercept all incoming and outgoing messages at a particular point in the run-time stack. The sample also includes a client and server that demonstrate the use of these custom factories.  \n  \n In this sample, both the client and the service are console programs (.exe). The client and service both make use of a common library (.dll) that contains the custom binding element and its associated run-time objects.  \n  \n> [!NOTE]\n>  The setup procedure and build instructions for this sample are located at the end of this topic.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Channels\\MessageInterceptor`  \n  \n The sample describes the recommended procedure for creating a custom layered channel in Windows Communication Foundation (WCF), by using the channel framework and following WCF best practices. The steps to create a custom layered channel are as follows:  \n  \n1.  Decide which of the channel shapes your channel factory and channel listener will support.  \n  \n2.  Create a channel factory and a channel listener that support your channel shapes.  \n  \n3.  Add a binding element that adds the custom layered channel to a channel stack.  \n  \n4.  Add a binding element extension section to expose the new binding element to the configuration system.  \n  \n## Channel Shapes  \n The first step in writing a custom layered channel is to decide which shapes are required for the channel. For our message inspector, we support any shape that the layer below us supports (for example, if the layer below us can build <xref:System.ServiceModel.Channels.IOutputChannel> and <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, then we also expose <xref:System.ServiceModel.Channels.IOutputChannel> and <xref:System.ServiceModel.Channels.IDuplexSessionChannel>).  \n  \n## Channel Factory and Listener Factory  \n The next step in writing a custom layered channel is to create an implementation of <xref:System.ServiceModel.Channels.IChannelFactory> for client channels and of <xref:System.ServiceModel.Channels.IChannelListener> for service channels.  \n  \n These classes take an inner factory and listener, and delegate all but the `OnCreateChannel` and `OnAcceptChannel` calls to the inner factory and listener.  \n  \n```  \nclass InterceptingChannelFactory<TChannel> : ChannelFactoryBase<TChannel>  \n{ ... }  \nclass InterceptingChannelListener<TChannel> : ListenerFactoryBase<TChannel>  \n{ ... }  \n```  \n  \n## Adding a Binding Element  \n The sample defines a custom binding element: `InterceptingBindingElement`. `InterceptingBindingElement` takes a `ChannelMessageInterceptor` as an input, and uses this `ChannelMessageInterceptor` to manipulate messages that pass through it. This is the only class that must be public. The factory, listener, and channels can all be internal implementations of the public run-time interfaces.  \n  \n```  \npublic class InterceptingBindingElement : BindingElement  \n```  \n  \n## Adding Configuration Support  \n To integrate with binding configuration, the library defines a configuration section handler as a binding element extension section. The client and server configuration files must register the binding element extension with the configuration system. Implementers that want to expose their binding element to the configuration system can derive from this class.  \n  \n```  \npublic abstract class InterceptingElement : BindingElementExtensionElement { ... }  \n```  \n  \n## Adding Policy  \n To integrate with our policy system, `InterceptingBindingElement` implements IPolicyExportExtension to signal that we should participate in generating policy. To support importing policy on a generated client, the user can register a derived class of `InterceptingBindingElementImporter` and override `CreateMessageInterceptor`() to generate their policy-enabled `ChannelMessageInterceptor` class.  \n  \n## Example: Droppable Message Inspector  \n Included in the sample is an example implementation of `ChannelMessageInspector` which drops messages.  \n  \n```  \nclass DroppingServerElement : InterceptingElement  \n{  \n    protected override ChannelMessageInterceptor CreateMessageInterceptor()  \n    {  \n        return new DroppingServerInterceptor();  \n    }  \n}  \n```  \n  \n You can access it from configuration as follows:  \n  \n```xml  \n<configuration>  \n    ...  \n    <system.serviceModel>  \n        ...  \n        <extensions>  \n            <bindingElementExtensions>  \n                <add name=\"droppingInterceptor\"   \n                   type=  \n          \"Microsoft.ServiceModel.Samples.DroppingServerElement, library\"/>  \n            </bindingElementExtensions>  \n        </extensions>  \n    </system.serviceModel>  \n</configuration>  \n```  \n  \n The client and server both use this newly created configuration section to insert the custom factories into the lowest-level of their run-time channel stacks (above the transport level).  \n  \n```xml  \n<customBinding>  \n  <binding name=\"sampleBinding\">  \n    <droppingInterceptor/>  \n    <httpTransport/>  \n  </binding>  \n</customBinding>  \n```  \n  \n The client uses the `MessageInterceptor` library to add a custom header to even numbered messages. The service on the other hand uses `MessageInterceptor` library to drop any messages that do not have this special header.  \n  \n You should see the following client output after running the service and then the client.  \n  \n```  \nReporting the next 10 wind speed  \n100 kph  \nServer dropped a message.  \n90 kph  \n80 kph  \nServer dropped a message.  \n70 kph  \n60 kph  \nServer dropped a message.  \n50 kph  \n40 kph  \nServer dropped a message.  \n30 kph  \n20 kph  \nServer dropped a message.  \n10 kph  \nPress ENTER to shut down client  \n```  \n  \n The client reports 10 different wind speeds to the service, but only tags half of them with the special header.  \n  \n On the service, you should see the following output:  \n  \n```  \nPress ENTER to exit.  \nDangerous wind detected! Reported speed (90) is greater than 64 kph.  \nDangerous wind detected! Reported speed (70) is greater than 64 kph.  \n5 wind speed reports have been received.  \n```  \n  \n#### To set up, build, and run the sample  \n  \n1.  Install [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 4.0 using the following command.  \n  \n    ```  \n    %windir%\\Microsoft.NET\\Framework\\v4.0.XXXXX\\aspnet_regiis.exe /i /enable  \n    ```  \n  \n2.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n3.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n4.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n5.  Run Service.exe first then run Client.exe and watch both console windows for output.  \n","nodes":[{"pos":[4,110],"embed":true,"restype":"x-metadata","content":"title: \"Custom Message Interceptor\"\nms.date: \"03/30/2017\"\nms.assetid: 73f20972-53f8-475a-8bfe-c133bfa225b0","nodes":[{"content":"Custom Message Interceptor","nodes":[{"pos":[0,26],"content":"Custom Message Interceptor","nodes":[{"content":"Custom Message Interceptor","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[117,143],"content":"Custom Message Interceptor","linkify":"Custom Message Interceptor","nodes":[{"content":"Custom Message Interceptor","pos":[0,26]}]},{"content":"This sample demonstrates the use of the channel extensibility model.","pos":[144,212]},{"content":"In particular, it shows how to implement a custom binding element that creates channel factories and channel listeners to intercept all incoming and outgoing messages at a particular point in the run-time stack.","pos":[213,424]},{"content":"The sample also includes a client and server that demonstrate the use of these custom factories.","pos":[425,521]},{"content":"In this sample, both the client and the service are console programs (.exe).","pos":[528,604]},{"content":"The client and service both make use of a common library (.dll) that contains the custom binding element and its associated run-time objects.","pos":[605,746]},{"pos":[754,861],"content":"[!NOTE]\n The setup procedure and build instructions for this sample are located at the end of this topic.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this topic.","pos":[9,105]}]},{"pos":[869,1001],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[14,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[1055,1365],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[1366,1416]},{"content":"The sample describes the recommended procedure for creating a custom layered channel in Windows Communication Foundation (WCF), by using the channel framework and following WCF best practices.","pos":[1512,1704]},{"content":"The steps to create a custom layered channel are as follows:","pos":[1705,1765]},{"content":"Decide which of the channel shapes your channel factory and channel listener will support.","pos":[1775,1865]},{"content":"Create a channel factory and a channel listener that support your channel shapes.","pos":[1875,1956]},{"content":"Add a binding element that adds the custom layered channel to a channel stack.","pos":[1966,2044]},{"content":"Add a binding element extension section to expose the new binding element to the configuration system.","pos":[2054,2156]},{"pos":[2165,2179],"content":"Channel Shapes","linkify":"Channel Shapes","nodes":[{"content":"Channel Shapes","pos":[0,14]}]},{"content":"The first step in writing a custom layered channel is to decide which shapes are required for the channel.","pos":[2183,2289]},{"content":"For our message inspector, we support any shape that the layer below us supports (for example, if the layer below us can build <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IOutputChannel&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph>, then we also expose <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IOutputChannel&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph>).","pos":[2290,2665],"source":" For our message inspector, we support any shape that the layer below us supports (for example, if the layer below us can build <xref:System.ServiceModel.Channels.IOutputChannel> and <xref:System.ServiceModel.Channels.IDuplexSessionChannel>, then we also expose <xref:System.ServiceModel.Channels.IOutputChannel> and <xref:System.ServiceModel.Channels.IDuplexSessionChannel>)."},{"pos":[2674,2710],"content":"Channel Factory and Listener Factory","linkify":"Channel Factory and Listener Factory","nodes":[{"content":"Channel Factory and Listener Factory","pos":[0,36]}]},{"pos":[2714,2951],"content":"The next step in writing a custom layered channel is to create an implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelFactory&gt;</ph> for client channels and of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph> for service channels.","source":"The next step in writing a custom layered channel is to create an implementation of <xref:System.ServiceModel.Channels.IChannelFactory> for client channels and of <xref:System.ServiceModel.Channels.IChannelListener> for service channels."},{"pos":[2958,3113],"content":"These classes take an inner factory and listener, and delegate all but the <ph id=\"ph1\">`OnCreateChannel`</ph> and <ph id=\"ph2\">`OnAcceptChannel`</ph> calls to the inner factory and listener.","source":"These classes take an inner factory and listener, and delegate all but the `OnCreateChannel` and `OnAcceptChannel` calls to the inner factory and listener."},{"pos":[3311,3335],"content":"Adding a Binding Element","linkify":"Adding a Binding Element","nodes":[{"content":"Adding a Binding Element","pos":[0,24]}]},{"content":"The sample defines a custom binding element: <ph id=\"ph1\">`InterceptingBindingElement`</ph>.","pos":[3339,3413],"source":"The sample defines a custom binding element: `InterceptingBindingElement`."},{"content":"<ph id=\"ph1\">`InterceptingBindingElement`</ph> takes a <ph id=\"ph2\">`ChannelMessageInterceptor`</ph> as an input, and uses this <ph id=\"ph3\">`ChannelMessageInterceptor`</ph> to manipulate messages that pass through it.","pos":[3414,3578],"source":"`InterceptingBindingElement` takes a `ChannelMessageInterceptor` as an input, and uses this `ChannelMessageInterceptor` to manipulate messages that pass through it."},{"content":"This is the only class that must be public.","pos":[3579,3622]},{"content":"The factory, listener, and channels can all be internal implementations of the public run-time interfaces.","pos":[3623,3729]},{"pos":[3812,3840],"content":"Adding Configuration Support","linkify":"Adding Configuration Support","nodes":[{"content":"Adding Configuration Support","pos":[0,28]}]},{"content":"To integrate with binding configuration, the library defines a configuration section handler as a binding element extension section.","pos":[3844,3976]},{"content":"The client and server configuration files must register the binding element extension with the configuration system.","pos":[3977,4093]},{"content":"Implementers that want to expose their binding element to the configuration system can derive from this class.","pos":[4094,4204]},{"pos":[4313,4326],"content":"Adding Policy","linkify":"Adding Policy","nodes":[{"content":"Adding Policy","pos":[0,13]}]},{"content":"To integrate with our policy system, <ph id=\"ph1\">`InterceptingBindingElement`</ph> implements IPolicyExportExtension to signal that we should participate in generating policy.","pos":[4330,4488],"source":"To integrate with our policy system, `InterceptingBindingElement` implements IPolicyExportExtension to signal that we should participate in generating policy."},{"content":"To support importing policy on a generated client, the user can register a derived class of <ph id=\"ph1\">`InterceptingBindingElementImporter`</ph> and override <ph id=\"ph2\">`CreateMessageInterceptor`</ph>() to generate their policy-enabled <ph id=\"ph3\">`ChannelMessageInterceptor`</ph> class.","pos":[4489,4727],"source":" To support importing policy on a generated client, the user can register a derived class of `InterceptingBindingElementImporter` and override `CreateMessageInterceptor`() to generate their policy-enabled `ChannelMessageInterceptor` class."},{"pos":[4736,4772],"content":"Example: Droppable Message Inspector","linkify":"Example: Droppable Message Inspector","nodes":[{"content":"Example: Droppable Message Inspector","pos":[0,36]}]},{"pos":[4776,4878],"content":"Included in the sample is an example implementation of <ph id=\"ph1\">`ChannelMessageInspector`</ph> which drops messages.","source":"Included in the sample is an example implementation of `ChannelMessageInspector` which drops messages."},{"content":"You can access it from configuration as follows:","pos":[5104,5152]},{"content":"The client and server both use this newly created configuration section to insert the custom factories into the lowest-level of their run-time channel stacks (above the transport level).","pos":[5581,5767]},{"content":"The client uses the <ph id=\"ph1\">`MessageInterceptor`</ph> library to add a custom header to even numbered messages.","pos":[5931,6029],"source":"The client uses the `MessageInterceptor` library to add a custom header to even numbered messages."},{"content":"The service on the other hand uses <ph id=\"ph1\">`MessageInterceptor`</ph> library to drop any messages that do not have this special header.","pos":[6030,6152],"source":" The service on the other hand uses `MessageInterceptor` library to drop any messages that do not have this special header."},{"content":"You should see the following client output after running the service and then the client.","pos":[6159,6248]},{"content":"The client reports 10 different wind speeds to the service, but only tags half of them with the special header.","pos":[6570,6681]},{"content":"On the service, you should see the following output:","pos":[6688,6740]},{"pos":[6974,7010],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[7020,7118],"content":"Install <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> 4.0 using the following command.","source":"Install [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 4.0 using the following command."},{"pos":[7230,7429],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[7439,7609],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[7619,7827],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"content":"Run Service.exe first then run Client.exe and watch both console windows for output.","pos":[7837,7921]}]}