<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="classes-and-objects.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6f06a43b60a1101e5583ffa85bd948c69679943b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\tour-of-csharp\classes-and-objects.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_hi-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">62a9b522ca70412b5b66224f2c40ba46f48c0317</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bebe7d51f31126514109a957c9490fe3855edff1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Classes and Objects in C# - A tour of the C# Language</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>New to C#?</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Read this overview of classes, objects and inheritance</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Classes and objects</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Classes<ept id="p1">*</ept> are the most fundamental of C#’s types.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A class provides a definition for dynamically created <bpt id="p1">*</bpt>instances<ept id="p1">*</ept> of the class, also known as <bpt id="p2">*</bpt>objects<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Classes support <bpt id="p1">*</bpt>inheritance<ept id="p1">*</ept> and <bpt id="p2">*</bpt>polymorphism<ept id="p2">*</ept>, mechanisms whereby <bpt id="p3">*</bpt>derived classes<ept id="p3">*</ept> can extend and specialize <bpt id="p4">*</bpt>base classes<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>New classes are created using class declarations.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The header is followed by the class body, which consists of a list of member declarations written between the delimiters <ph id="ph1">`{`</ph> and <ph id="ph2">`}`</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following is a declaration of a simple class named <ph id="ph1">`Point`</ph>:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Instances of classes are created using the <ph id="ph1">`new`</ph> operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following statements create two Point objects and store references to those objects in two variables:</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It is neither necessary nor possible to explicitly deallocate objects in C#.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Members</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The members of a class are either static members or instance members.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Static members belong to classes, and instance members belong to objects (instances of classes).</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following provides an overview of the kinds of members a class can contain.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Constants</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Constant values associated with the class</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Fields</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Variables of the class</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Methods</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Computations and actions that can be performed by the class</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Properties</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Actions associated with reading and writing named properties of the class</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Indexers</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Actions associated with indexing instances of the class like an array</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Events</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Notifications that can be generated by the class</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Operators</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Conversions and expression operators supported by the class</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Constructors</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Actions required to initialize instances of the class or the class itself</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Finalizers</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Actions to perform before instances of the class are permanently discarded</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Types</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Nested types declared by the class</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>There are six possible forms of accessibility.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>These are summarized below.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Access not limited</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Access limited to this class or classes derived from this class</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Access limited to the current assembly (.exe, .dll, etc.)</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Access limited to the containing class, classes derived from the containing class, or classes within the same assembly</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Access limited to this class</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Access limited to the containing class or classes derived from the containing type within the same assembly</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The type parameters can then be used in the body of the class declarations to define the members of the class.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In the following example, the type parameters of <ph id="ph1">`Pair`</ph> are <ph id="ph2">`TFirst`</ph> and <ph id="ph3">`TSecond`</ph>:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A class type that is declared to take type parameters is called a <bpt id="p1">*</bpt>generic class type<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Struct, interface and delegate types can also be generic.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When the generic class is used, type arguments must be provided for each of the type parameters:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A generic type with type arguments provided, like <ph id="ph1">`Pair&lt;int,string&gt;`</ph> above, is called a <bpt id="p1">*</bpt>constructed type<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Base classes</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Omitting a base class specification is the same as deriving from type <ph id="ph1">`object`</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In the following example, the base class of <ph id="ph1">`Point3D`</ph> is <ph id="ph2">`Point`</ph>, and the base class of <ph id="ph3">`Point`</ph> is <ph id="ph4">`object`</ph>:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A class inherits the members of its base class.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In the previous example, <ph id="ph1">`Point3D`</ph> inherits the <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> fields from <ph id="ph4">`Point`</ph>, and every <ph id="ph5">`Point3D`</ph> instance contains three fields, <ph id="ph6">`x`</ph>, <ph id="ph7">`y`</ph>, and <ph id="ph8">`z`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>An implicit conversion exists from a class type to any of its base class types.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, given the previous class declarations, a variable of type <ph id="ph1">`Point`</ph> can reference either a <ph id="ph2">`Point`</ph> or a <ph id="ph3">`Point3D`</ph>:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Fields</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>field<ept id="p1">*</ept> is a variable that is associated with a class or with an instance of a class.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A field declared with the static modifier defines a static field.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A static field identifies exactly one storage location.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>No matter how many instances of a class are created, there is only ever one copy of a static field.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>A field declared without the static modifier defines an instance field.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Every instance of a class contains a separate copy of all the instance fields of that class.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>In the following example, each instance of the <ph id="ph1">`Color`</ph> class has a separate copy of the <ph id="ph2">`r`</ph>, <ph id="ph3">`g`</ph>, and <ph id="ph4">`b`</ph> instance fields, but there is only one copy of the <ph id="ph5">`Black`</ph>, <ph id="ph6">`White`</ph>, <ph id="ph7">`Red`</ph>, <ph id="ph8">`Green`</ph>, and <ph id="ph9">`Blue`</ph> static fields:</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As shown in the previous example, <bpt id="p1">*</bpt>read-only fields<ept id="p1">*</ept> may be declared with a <ph id="ph1">`readonly`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Assignment to a <ph id="ph1">`readonly`</ph> field can only occur as part of the field’s declaration or in a constructor in the same class.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Methods</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>method<ept id="p1">*</ept> is a member that implements a computation or action that can be performed by an object or class.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Static methods<ept id="p1">*</ept> are accessed through the class.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Instance methods<ept id="p1">*</ept> are accessed through instances of the class.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Methods may have a list of <bpt id="p1">*</bpt>parameters<ept id="p1">*</ept>, which represent values or variable references passed to the method, and a <bpt id="p2">*</bpt>return type<ept id="p2">*</ept>, which specifies the type of the value computed and returned by the method.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A method’s return type is <ph id="ph1">`void`</ph> if it does not return a value.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>signature<ept id="p1">*</ept> of a method must be unique in the class in which the method is declared.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The signature of a method does not include the return type.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Parameters</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Parameters are used to pass values or variable references to methods.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The parameters of a method get their actual values from the <bpt id="p1">*</bpt>arguments<ept id="p1">*</ept> that are specified when the method is invoked.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>value parameter<ept id="p1">*</ept> is used for passing input arguments.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Modifications to a value parameter do not affect the argument that was passed for the parameter.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>reference parameter<ept id="p1">*</ept> is used for passing arguments by reference.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A reference parameter is declared with the <ph id="ph1">`ref`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following example shows the use of <ph id="ph1">`ref`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>output parameter<ept id="p1">*</ept> is used for passing arguments by reference.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>An output parameter is declared with the <ph id="ph1">`out`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example shows the use of <ph id="ph1">`out`</ph> parameters using the syntax introduced in C# 7.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>parameter array<ept id="p1">*</ept> permits a variable number of arguments to be passed to a method.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A parameter array is declared with the <ph id="ph1">`params`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The Write and WriteLine methods of the <ph id="ph1">&lt;xref:System.Console?displayProperty=nameWithType&gt;</ph> class are good examples of parameter array usage.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>They are declared as follows.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>In the latter case, an array instance is automatically created and initialized with the given arguments.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This example</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>is equivalent to writing the following.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Method body and local variables</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A method’s body specifies the statements to execute when the method is invoked.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>A method body can declare variables that are specific to the invocation of the method.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Such variables are called <bpt id="p1">*</bpt>local variables<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>A local variable declaration specifies a type name, a variable name, and possibly an initial value.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example declares a local variable <ph id="ph1">`i`</ph> with an initial value of zero and a local variable <ph id="ph2">`j`</ph> with no initial value.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>C# requires a local variable to be <bpt id="p1">*</bpt>definitely assigned<ept id="p1">*</ept> before its value can be obtained.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For example, if the declaration of the previous <ph id="ph1">`i`</ph> did not include an initial value, the compiler would report an error for the subsequent usages of <ph id="ph2">`i`</ph> because <ph id="ph3">`i`</ph> would not be definitely assigned at those points in the program.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A method can use <ph id="ph1">`return`</ph> statements to return control to its caller.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In a method returning <ph id="ph1">`void`</ph>, <ph id="ph2">`return`</ph> statements cannot specify an expression.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In a method returning non-void, <ph id="ph1">`return`</ph> statements must include an expression that computes the return value.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Static and instance methods</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>A method declared with a static modifier is a <bpt id="p1">*</bpt>static method<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>A static method does not operate on a specific instance and can only directly access static members.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A method declared without a static modifier is an <bpt id="p1">*</bpt>instance method<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>An instance method operates on a specific instance and can access both static and instance members.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The instance on which an instance method was invoked can be explicitly accessed as <ph id="ph1">`this`</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>It is an error to refer to <ph id="ph1">`this`</ph> in a static method.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The following <ph id="ph1">`Entity`</ph> class has both static and instance members.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Each <ph id="ph1">`Entity`</ph> instance contains a serial number (and presumably some other information that is not shown here).</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Entity`</ph> constructor (which is like an instance method) initializes the new instance with the next available serial number.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Because the constructor is an instance member, it is permitted to access both the <ph id="ph1">`serialNo`</ph> instance field and the <ph id="ph2">`nextSerialNo`</ph> static field.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GetNextSerialNo`</ph> and <ph id="ph2">`SetNextSerialNo`</ph> static methods can access the <ph id="ph3">`nextSerialNo`</ph> static field, but it would be an error for them to directly access the <ph id="ph4">`serialNo`</ph> instance field.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example shows the use of the Entity class.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`SetNextSerialNo`</ph> and <ph id="ph2">`GetNextSerialNo`</ph> static methods are invoked on the class whereas the <ph id="ph3">`GetSerialNo`</ph> instance method is invoked on instances of the class.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Virtual, override, and abstract methods</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When an instance method declaration includes a <ph id="ph1">`virtual`</ph> modifier, the method is said to be a <bpt id="p1">*</bpt>virtual method<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>When no virtual modifier is present, the method is said to be a <bpt id="p1">*</bpt>nonvirtual method<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>When a virtual method is invoked, the <bpt id="p1">*</bpt>run-time type<ept id="p1">*</ept> of the instance for which that invocation takes place determines the actual method implementation to invoke.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>In a nonvirtual method invocation, the <bpt id="p1">*</bpt>compile-time type<ept id="p1">*</ept> of the instance is the determining factor.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>A virtual method can be <bpt id="p1">*</bpt>overridden<ept id="p1">*</ept> in a derived class.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>abstract method<ept id="p1">*</ept> is a virtual method with no implementation.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>An abstract method must be overridden in every non-abstract derived class.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The following example declares an abstract class, <ph id="ph1">`Expression`</ph>, which represents an expression tree node, and three derived classes, <ph id="ph2">`Constant`</ph>, <ph id="ph3">`VariableReference`</ph>, and <ph id="ph4">`Operation`</ph>, which implement expression tree nodes for constants, variable references, and arithmetic operations.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>(This is similar to, but not to be confused with the expression tree types).</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The previous four classes can be used to model arithmetic expressions.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For example, using instances of these classes, the expression <ph id="ph1">`x + 3`</ph> can be represented as follows.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Evaluate`</ph> method of an <ph id="ph2">`Expression`</ph> instance is invoked to evaluate the given expression and produce a <ph id="ph3">`double`</ph> value.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The method takes a <ph id="ph1">`Dictionary`</ph> argument that contains variable names (as keys of the entries) and values (as values of the entries).</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`Evaluate`</ph> is an abstract method, non-abstract classes derived from <ph id="ph2">`Expression`</ph> must override <ph id="ph3">`Evaluate`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Constant`</ph>'s implementation of <ph id="ph2">`Evaluate`</ph> simply returns the stored constant.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`VariableReference`</ph>'s implementation looks up the variable name in the dictionary and returns the resulting value.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`Operation`</ph>'s implementation first evaluates the left and right operands (by recursively invoking their <ph id="ph2">`Evaluate`</ph> methods) and then performs the given arithmetic operation.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The following program uses the <ph id="ph1">`Expression`</ph> classes to evaluate the expression <ph id="ph2">`x * (y + 2)`</ph> for different values of <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Method overloading</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Method <bpt id="p1">*</bpt>overloading<ept id="p1">*</ept> permits multiple methods in the same class to have the same name as long as they have unique signatures.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>When compiling an invocation of an overloaded method, the compiler uses <bpt id="p1">*</bpt>overload resolution<ept id="p1">*</ept> to determine the specific method to invoke.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The following example shows overload resolution in effect.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The comment for each invocation in the <ph id="ph1">`UsageExample`</ph> method shows which method is actually invoked.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Other function members</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Members that contain executable code are collectively known as the <bpt id="p1">*</bpt>function members<ept id="p1">*</ept> of a class.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The preceding section describes methods, which are the primary kind of function members.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The following shows a generic class called <ph id="ph1">`MyList&lt;T&gt;`</ph>, which implements a growable list of objects.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The class contains several examples of the most common kinds of function members.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This example creates a <ph id="ph1">`MyList`</ph> class, which is not the same as the .NET standard <ph id="ph2">&lt;xref:System.Collections.Generic.List%601?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>It does illustrate the concepts needed for this tour, but is not a replacement for that class.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Constructors</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>C# supports both instance and static constructors.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>instance constructor<ept id="p1">*</ept> is a member that implements the actions required to initialize an instance of a class.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>static constructor<ept id="p1">*</ept> is a member that implements the actions required to initialize a class itself when it is first loaded.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>A constructor is declared like a method with no return type and the same name as the containing class.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>If a constructor declaration includes a static modifier, it declares a static constructor.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Otherwise, it declares an instance constructor.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Instance constructors can be overloaded, and can have optional parameters.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`MyList&lt;T&gt;`</ph> class declares two instance constructors, one with no parameters and one that takes an <ph id="ph2">`int`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Instance constructors are invoked using the <ph id="ph1">`new`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The following statements allocate two <ph id="ph1">`MyList&lt;string&gt;`</ph> instances using the constructor of the <ph id="ph2">`MyList`</ph> class with and without the optional argument.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Properties</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Properties<ept id="p1">*</ept> are a natural extension of fields.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Both are named members with associated types, and the syntax for accessing fields and properties is the same.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>However, unlike fields, properties do not denote storage locations.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Instead, properties have <bpt id="p1">*</bpt>accessors<ept id="p1">*</ept> that specify the statements to be executed when their values are read or written.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters <ph id="ph1">`{`</ph> and <ph id="ph2">`}`</ph> instead of ending in a semicolon.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>A property that has both a get accessor and a set accessor is a <bpt id="p1">*</bpt>read-write property<ept id="p1">*</ept>, a property that has only a get accessor is a <bpt id="p2">*</bpt>read-only property<ept id="p2">*</ept>, and a property that has only a set accessor is a <bpt id="p3">*</bpt>write-only property<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A get accessor corresponds to a parameterless method with a return value of the property type.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A set accessor corresponds to a method with a single parameter named value and no return type.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MyList&lt;T&gt;`</ph> class declares two properties, <ph id="ph2">`Count`</ph> and <ph id="ph3">`Capacity`</ph>, which are read-only and read-write, respectively.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The following is an example of use of these properties:</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Similar to fields and methods, C# supports both instance properties and static properties.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Static properties are declared with the static modifier, and instance properties are declared without it.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The accessor(s) of a property can be virtual.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>When a property declaration includes a <ph id="ph1">`virtual`</ph>, <ph id="ph2">`abstract`</ph>, or <ph id="ph3">`override`</ph> modifier, it applies to the accessor(s) of the property.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Indexers</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>indexer<ept id="p1">*</ept> is a member that enables objects to be indexed in the same way as an array.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters <ph id="ph1">`[`</ph> and <ph id="ph2">`]`</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The parameters are available in the accessor(s) of the indexer.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MyList&lt;T&gt;`</ph> class declares a single read-write indexer that takes an <ph id="ph2">`int`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The indexer makes it possible to index <ph id="ph1">`MyList&lt;T&gt;`</ph> instances with <ph id="ph2">`int`</ph> values.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Events</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>event<ept id="p1">*</ept> is a member that enables a class or object to provide notifications.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The field stores a reference to a delegate that represents the event handlers that have been added to the event.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>If no event handlers are present, the field is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MyList&lt;T&gt;`</ph> class declares a single event member called <ph id="ph2">`Changed`</ph>, which indicates that a new item has been added to the list.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The Changed event is raised by the <ph id="ph1">`OnChanged`</ph> virtual method, which first checks whether the event is <ph id="ph2">`null`</ph> (meaning that no handlers are present).</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Clients react to events through <bpt id="p1">*</bpt>event handlers<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Event handlers are attached using the <ph id="ph1">`+=`</ph> operator and removed using the <ph id="ph2">`-=`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The following example attaches an event handler to the <ph id="ph1">`Changed`</ph> event of a <ph id="ph2">`MyList&lt;string&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide <ph id="ph1">`add`</ph> and <ph id="ph2">`remove`</ph> accessors, which are somewhat similar to the <ph id="ph3">`set`</ph> accessor of a property.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Operators</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>operator<ept id="p1">*</ept> is a member that defines the meaning of applying a particular expression operator to instances of a class.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>All operators must be declared as <ph id="ph1">`public`</ph> and <ph id="ph2">`static`</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MyList&lt;T&gt;`</ph> class declares two operators, <ph id="ph2">`operator ==`</ph> and <ph id="ph3">`operator !=`</ph>, and thus gives new meaning to expressions that apply those operators to <ph id="ph4">`MyList`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Specifically, the operators define equality of two <ph id="ph1">`MyList&lt;T&gt;`</ph> instances as comparing each of the contained objects using their Equals methods.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`==`</ph> operator to compare two <ph id="ph2">`MyList&lt;int&gt;`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">`Console.WriteLine`</ph> outputs <ph id="ph2">`True`</ph> because the two lists contain the same number of objects with the same values in the same order.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Had <ph id="ph1">`MyList&lt;T&gt;`</ph> not defined <ph id="ph2">`operator ==`</ph>, the first <ph id="ph3">`Console.WriteLine`</ph> would have output <ph id="ph4">`False`</ph> because <ph id="ph5">`a`</ph> and <ph id="ph6">`b`</ph> reference different <ph id="ph7">`MyList&lt;int&gt;`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Finalizers</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>finalizer<ept id="p1">*</ept> is a member that implements the actions required to finalize an instance of a class.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The finalizer for an instance is invoked automatically during garbage collection.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`using`</ph> statement provides a better approach to object destruction.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Previous<ept id="p1">](statements.md)</ept><ph id="ph1">
</ph><bpt id="p2">[</bpt>Next<ept id="p2">](structs.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>