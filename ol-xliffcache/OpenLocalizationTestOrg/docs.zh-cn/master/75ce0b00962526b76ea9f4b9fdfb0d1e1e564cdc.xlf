<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="how-entity-sql-differs-from-transact-sql.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">75ce0b00962526b76ea9f4b9fdfb0d1e1e564cdc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\data\adonet\ef\language-reference\how-entity-sql-differs-from-transact-sql.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">899a70f0ca753111be01e236202857b71a8291ca</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8aa3ec93dd2525efa83ee2b1235a61b8abc99904</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>How Entity SQL Differs from Transact-SQL</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>How Entity SQL Differs from Transact-SQL</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic describes the differences between <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> and <ph id="ph2">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Inheritance and Relationships Support</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> works directly with conceptual entity schemas and supports conceptual model features such as inheritance and relationships.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When working with inheritance, it is often useful to select instances of a subtype from a collection of supertype instances.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>oftype<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/oftype-entity-sql.md)</ept> operator in <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> (similar to <ph id="ph2">`oftype`</ph> in C# Sequences) provides this capability.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Support for Collections</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> treats collections as first-class entities.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Collection expressions are valid in a <ph id="ph1">`from`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`in`</ph> and <ph id="ph2">`exists`</ph> subqueries have been generalized to allow any collections.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A subquery is one kind of collection.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`e1 in e2`</ph> and <ph id="ph2">`exists(e)`</ph> are the <ph id="ph3">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> constructs to perform these operations.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Set operations, such as <ph id="ph1">`union`</ph>, <ph id="ph2">`intersect`</ph>, and <ph id="ph3">`except`</ph>, now operate on collections.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Joins operate on collections.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Support for Expressions</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> has subqueries (tables) and expressions (rows and columns).</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To support collections and nested collections, <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> makes everything an expression.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> is more composable than <ph id="ph2">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>â€”every expression can be used anywhere.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Query expressions always result in collections of the projected types and can be used anywhere a collection expression is allowed.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For information about <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> expressions that are not supported in <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>, see <bpt id="p1">[</bpt>Unsupported Expressions<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/unsupported-expressions-entity-sql.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following are all valid <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> queries:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Uniform Treatment of Subqueries</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Given its emphasis on tables, <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> performs contextual interpretation of subqueries.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, a subquery in the <ph id="ph1">`from`</ph> clause is considered to be a multiset (table).</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>But the same subquery used in the <ph id="ph1">`select`</ph> clause is considered to be a scalar subquery.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Similarly, a subquery used on the left side of an <ph id="ph1">`in`</ph> operator is considered to be a scalar subquery, while the right side is expected to be a multiset subquery.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> eliminates these differences.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>An expression has a uniform interpretation that does not depend on the context in which it is used.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> considers all subqueries to be multiset subqueries.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If a scalar value is desired from the subquery, <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> provides the <ph id="ph2">`anyelement`</ph> operator that operates on a collection (in this case, the subquery), and extracts a singleton value from the collection.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Avoiding Implicit Coercions for Subqueries</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A related side effect of uniform treatment of subqueries is implicit conversion of subqueries to scalar values.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Specifically, in <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, a multiset of rows (with a single field) is implicitly converted into a scalar value whose data type is that of the field.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not support this implicit coercion.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> provides the ANYELEMENT operator to extract a singleton value from a collection, and a <ph id="ph2">`select value`</ph> clause to avoid creating a row-wrapper during a query expression.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Select Value: Avoiding the Implicit Row Wrapper</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The select clause in a <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> subquery implicitly creates a row wrapper around the items in the clause.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This implies that we cannot create collections of scalars or objects.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> allows an implicit coercion between a rowtype with one field, and a singleton value of the same data type.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> provides the <ph id="ph2">`select value`</ph> clause to skip the implicit row construction.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Only one item may be specified in a <ph id="ph1">`select value`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When such a clause is used, no row wrapper is constructed around the items in the <ph id="ph1">`select`</ph> clause, and a collection of the desired shape may be produced, for example: <ph id="ph2">`select value a`</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> also provides the row constructor to construct arbitrary rows.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`select`</ph> takes one or more elements in the projection and results in a data record with fields, as follows:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Left Correlation and Aliasing</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, expressions in a given scope (a single clause like <ph id="ph2">`select`</ph> or <ph id="ph3">`from`</ph>) cannot reference expressions defined earlier in the same scope.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Some dialects of SQL (including <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>) do support limited forms of these in the <ph id="ph2">`from`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> generalizes left correlations in the <ph id="ph2">`from`</ph> clause, and treats them uniformly.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Expressions in the <ph id="ph1">`from`</ph> clause can reference earlier definitions (definitions to the left) in the same clause without the need for additional syntax.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> also imposes additional restrictions on queries involving <ph id="ph2">`group by`</ph> clauses.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Expressions in the <ph id="ph1">`select`</ph> clause and <ph id="ph2">`having`</ph> clause of such queries may only refer to the <ph id="ph3">`group by`</ph> keys via their aliases.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The following construct is valid in <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> but are not in <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>To do this in <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Referencing Columns (Properties) of Tables (Collections)</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>All column references in <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> must be qualified with the table alias.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following construct (assuming that <ph id="ph1">`a`</ph> is a valid column of table <ph id="ph2">`T`</ph>) is valid in <ph id="ph3">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> but not in <ph id="ph4">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> form is</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The table aliases are optional in the <ph id="ph1">`from`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The name of the table is used as the implicit alias.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> allows the following form as well:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Navigation Through Objects</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> uses the "." notation for referencing columns of (a row of) a table.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> extends this notation (borrowed from programming languages) to support navigation through properties of an object.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, if <ph id="ph1">`p`</ph> is an expression of type Person, the following is the <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> syntax for referencing the city of the address of this person.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>No Support for *</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> supports the unqualified * syntax as an alias for the entire row, and the qualified <ph id="ph2">\*</ph> syntax (t.<ph id="ph3">\*</ph>) as a shortcut for the fields of that table.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In addition, <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> allows for a special count(<ph id="ph2">\*</ph>) aggregate, which includes nulls.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not support the * construct.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> queries of the form <ph id="ph2">`select * from T`</ph> and <ph id="ph3">`select T1.* from T1, T2...`</ph> can be expressed in <ph id="ph4">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> as <ph id="ph5">`select value t from T as t`</ph> and <ph id="ph6">`select value t1 from T1 as t1, T2 as t2...`</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Additionally, these constructs handle inheritance (value substitutability), while the <ph id="ph1">`select *`</ph> variants are restricted to top-level properties of the declared type.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not support the <ph id="ph2">`count(*)`</ph> aggregate.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">`count(0)`</ph> instead.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Changes to Group By</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports aliasing of <ph id="ph2">`group by`</ph> keys.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Expressions in the <ph id="ph1">`select`</ph> clause and <ph id="ph2">`having`</ph> clause must refer to the <ph id="ph3">`group by`</ph> keys via these aliases.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, this <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> syntax:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>...is equivalent to the following <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Collection-Based Aggregates</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports two kinds of aggregates.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Collection-based aggregates operate on collections and produce the aggregated result.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>These can appear anywhere in the query, and do not require a <ph id="ph1">`group by`</ph> clause.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> also supports SQL-style aggregates.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>ORDER BY Clause Usage</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> allows ORDER BY clauses to be specified only in the topmost SELECT ..</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>FROM ..</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>WHERE block.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> you can use a nested ORDER BY expression and it can be placed anywhere in the query, but ordering in a nested query is not preserved.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, identifier comparison is based on the collation of the current database.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>, identifiers are always case insensitive and accent sensitive (that is, <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> distinguishes between accented and unaccented characters; for example, 'a' is not equal to 'áº¥').</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> treats versions of letters that appear the same but are from different code pages as different characters.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Input Character Set<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/input-character-set-entity-sql.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Transact-SQL Functionality Not Available in Entity SQL</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> functionality is not available in <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>DML</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> currently provides no support for DML statements (insert, update, delete).</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>DDL</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> provides no support for DDL in the current version.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Imperative Programming</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> provides no support for imperative programming, unlike <ph id="ph2">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Use a programming language instead.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Grouping Functions</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not yet provide support for grouping functions (for example, CUBE, ROLLUP, and GROUPING_SET).</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Analytic Functions</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not (yet) provide support for analytic functions.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Built-in Functions, Operators</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports a subset of <ph id="ph2">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>'s built in functions and operators.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>These operators and functions are likely to be supported by the major store providers.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> uses the store-specific functions declared in a provider manifest.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Additionally, the <ph id="ph1">[!INCLUDE[adonet_ef](../../../../../../includes/adonet-ef-md.md)]</ph> allows you to declare built-in and user-defined existing store functions, for <ph id="ph2">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> to use.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Hints</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not provide mechanisms for query hints.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Batching Query Results</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> does not support batching query results.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For example, the following is valid <ph id="ph1">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> (sending as a batch):</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>However, the equivalent <ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> is not supported:</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> only supports one result-producing query statement per command.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Entity SQL Overview<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-overview.md)</ept></source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unsupported Expressions<ept id="p1">](../../../../../../docs/framework/data/adonet/ef/language-reference/unsupported-expressions-entity-sql.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>