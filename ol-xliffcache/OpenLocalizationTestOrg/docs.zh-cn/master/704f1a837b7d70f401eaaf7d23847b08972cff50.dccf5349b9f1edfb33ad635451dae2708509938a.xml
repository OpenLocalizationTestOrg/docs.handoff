{"content":"---\ntitle: \"Poison Message Handling\"\nms.date: \"03/30/2017\"\nms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595\n---\n# Poison Message Handling\nA *poison message* is a message that has exceeded the maximum number of delivery attempts to the application. This situation can arise when a queue-based application cannot process a message because of errors. To meet reliability demands, a queued application receives messages under a transaction. Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction. If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.  \n  \n A message can become a poison message for many reasons. The most common reasons are application specific. For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction. Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database. Messages can also become poison if they contain invalid information. For example, a purchase order may contain an invalid customer number. In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.  \n  \n On rare occasions, messages can fail to get dispatched to the application. The Windows Communication Foundation (WCF) layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header. In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.  \n  \n## Handling Poison Messages  \n In WCF, poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application, or messages that are dispatched to the application but which fail to be processed because of application-specific reasons. Poison message handling is configured by the following properties in each of the available queued bindings:  \n  \n-   `ReceiveRetryCount`. An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application. The default value is 5. This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.  \n  \n-   `MaxRetryCycles`. An integer value that indicates the maximum number of retry cycles. A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery. The default value is 2. On [!INCLUDE[wv](../../../../includes/wv-md.md)], the message is tried a maximum of (`ReceiveRetryCount` +1) * (`MaxRetryCycles` + 1) times. `MaxRetryCycles` is ignored on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  \n  \n-   `RetryCycleDelay`. The time delay between retry cycles. The default value is 30 minutes. `MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem. For example, this handles a locked row set in SQL Server pending transaction commit.  \n  \n-   `ReceiveErrorHandling`. An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted. The values can be Fault, Drop, Reject, and Move. The default option is Fault.  \n  \n-   Fault. This option sends a fault to the listener that caused the `ServiceHost` to fault. The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.  \n  \n-   Drop. This option drops the poison message and the message is never delivered to the application. If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue. If not, the message does not appear anywhere. This option indicates that the user has not specified what to do if the message is lost.  \n  \n-   Reject. This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)]. This instructs Message Queuing (MSMQ) to send a negative acknowledgement back to the sending queue manager that the application cannot receive the message. The message is placed in the sending queue manager's dead-letter queue.  \n  \n-   Move. This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)]. This moves the poison message to a poison-message queue for later processing by a poison-message handling application. The poison-message queue is a subqueue of the application queue. A poison-message handling application can be a WCF service that reads messages out of the poison queue. The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.  \n  \n The following are the maximum number of delivery attempts made for a message:  \n  \n-   ((ReceiveRetryCount+1) * (MaxRetryCycles + 1)) on [!INCLUDE[wv](../../../../includes/wv-md.md)].  \n  \n-   (ReceiveRetryCount + 1) on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  \n  \n> [!NOTE]\n>  No retries are made for a message that is delivered successfully.  \n  \n To keep track of the number of times a message read is attempted, [!INCLUDE[wv](../../../../includes/wv-md.md)] maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues. The WCF channel uses these to compute the receive retry count and the retry cycles count. On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], the abort count is maintained in memory by the WCF channel and is reset if the application fails. Also, the WCF channel can hold the abort counts for up to 256 messages in memory at any time. If a 257th message is read, then the oldest message's abort count is reset.  \n  \n The abort count and move count properties are available to the service operation through the operation context. The following code example shows how to access them.  \n  \n [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  \n  \n WCF provides two standard queued bindings:  \n  \n-   <xref:System.ServiceModel.NetMsmqBinding>. A [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] binding suitable for performing queue-based communication with other WCF endpoints.  \n  \n-   <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>. A binding suitable for communicating with existing Message Queuing applications.  \n  \n> [!NOTE]\n>  You can alter properties in these bindings based on the requirements of your WCF service. The entire poison message handling mechanism is local to the receiving application. The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender. In that case, the message is moved to the sender's dead-letter queue.  \n  \n## Best Practice: Handling MsmqPoisonMessageException  \n When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.  \n  \n A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires. For more information, see [Extending Control Over Error Handling and Reporting](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).  \n  \n The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue. The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>. The poison-message sample for Message Queuing 3.0 demonstrates this behavior. The following outlines the steps to take to handle poison messages, including best practices:  \n  \n1.  Ensure your poison settings reflect the requirements of your application. When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  \n  \n2.  If required, implement the `IErrorHandler` to handle poison-message errors. Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.  \n  \n     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  \n  \n3.  Create a `PoisonBehaviorAttribute` that the service behavior can use. The behavior installs the `IErrorHandler` on the dispatcher. See the following code example.  \n  \n     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  \n  \n4.  Ensure that your service is annotated with the poison behavior attribute.  \n\n In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message. You can hook up to the faulted event and shut down the service, take corrective actions, and restart. For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue. You can then restart `ServiceHost` to resume normal processing. The [Poison Message Handling in MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.  \n  \n## Transaction Time-Out and Poison Messages  \n A class of errors can occur between the queued transport channel and the user code. These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic. For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application. When this happens, the service model drops the message. Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue. In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.  \n  \n To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented. Eventually, the message becomes poison and the right disposition is made according to the user settings.  \n  \n## Sessions and Poison Messages  \n A session undergoes the same retry and poison-message handling procedures as a single message. The properties previously listed for poison messages apply to the entire session. This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.  \n  \n## Batching and Poison Messages  \n If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time. For more information about batching, see [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)  \n  \n## Poison-message Handling for Messages in a Poison Queue  \n Poison-message handling does not end when a message is placed in the poison-message queue. Messages in the poison-message queue must still be read and handled. You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue. The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`. You can set `ReceiveErrorHandling` to Drop, Reject, or Fault. `MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.  \n  \n## Windows Vista, Windows Server 2003, and Windows XP Differences  \n As noted earlier, not all poison-message handling settings apply to [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]. The following key differences between Message Queuing on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and [!INCLUDE[wv](../../../../includes/wv-md.md)] are relevant to poison-message handling:  \n  \n-   Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports subqueues, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues. Subqueues are used in poison-message handling. The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings. The `MaxRetryCycles` dictates how many retry subqueues to create. Therefore, when running on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.  \n  \n-   Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports negative acknowledgment, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not. A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue. As such, `ReceiveErrorHandling.Reject` is not allowed with [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].  \n  \n-   Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports a message property that keeps count of the number of times message delivery is attempted. This abort count property is not available on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]. WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a farm.  \n  \n## See also\n\n- [Queues Overview](../../../../docs/framework/wcf/feature-details/queues-overview.md)\n- [Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)\n- [Specifying and Handling Faults in Contracts and Services](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)\n","nodes":[{"pos":[4,107],"embed":true,"restype":"x-metadata","content":"title: \"Poison Message Handling\"\nms.date: \"03/30/2017\"\nms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595","nodes":[{"content":"Poison Message Handling","nodes":[{"pos":[0,23],"content":"Poison Message Handling","nodes":[{"content":"Poison Message Handling","pos":[0,23]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[114,137],"content":"Poison Message Handling","linkify":"Poison Message Handling","nodes":[{"content":"Poison Message Handling","pos":[0,23]}]},{"content":"A <bpt id=\"p1\">*</bpt>poison message<ept id=\"p1\">*</ept> is a message that has exceeded the maximum number of delivery attempts to the application.","pos":[138,247],"source":"A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application."},{"content":"This situation can arise when a queue-based application cannot process a message because of errors.","pos":[248,347]},{"content":"To meet reliability demands, a queued application receives messages under a transaction.","pos":[348,436]},{"content":"Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.","pos":[437,588]},{"content":"If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.","pos":[589,842]},{"content":"A message can become a poison message for many reasons.","pos":[849,904]},{"content":"The most common reasons are application specific.","pos":[905,954]},{"content":"For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.","pos":[955,1146]},{"content":"Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.","pos":[1147,1351]},{"content":"Messages can also become poison if they contain invalid information.","pos":[1352,1420]},{"content":"For example, a purchase order may contain an invalid customer number.","pos":[1421,1490]},{"content":"In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.","pos":[1491,1610]},{"content":"On rare occasions, messages can fail to get dispatched to the application.","pos":[1617,1691]},{"content":"The Windows Communication Foundation (WCF) layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.","pos":[1692,1894]},{"content":"In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.","pos":[1895,2036]},{"pos":[2045,2069],"content":"Handling Poison Messages","linkify":"Handling Poison Messages","nodes":[{"content":"Handling Poison Messages","pos":[0,24]}]},{"content":"In WCF, poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application, or messages that are dispatched to the application but which fail to be processed because of application-specific reasons.","pos":[2073,2344]},{"content":"Poison message handling is configured by the following properties in each of the available queued bindings:","pos":[2345,2452]},{"content":"<ph id=\"ph1\">`ReceiveRetryCount`</ph>.","pos":[2462,2482],"source":"`ReceiveRetryCount`."},{"content":"An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.","pos":[2483,2620]},{"content":"The default value is 5.","pos":[2621,2644]},{"content":"This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.","pos":[2645,2765]},{"content":"<ph id=\"ph1\">`MaxRetryCycles`</ph>.","pos":[2775,2792],"source":"`MaxRetryCycles`."},{"content":"An integer value that indicates the maximum number of retry cycles.","pos":[2793,2860]},{"content":"A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.","pos":[2861,3070]},{"content":"The default value is 2.","pos":[3071,3094]},{"content":"On <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph>, the message is tried a maximum of (<ph id=\"ph2\">`ReceiveRetryCount`</ph> +1) * (<ph id=\"ph3\">`MaxRetryCycles`</ph> + 1) times.","pos":[3095,3235],"source":" On [!INCLUDE[wv](../../../../includes/wv-md.md)], the message is tried a maximum of (`ReceiveRetryCount` +1) * (`MaxRetryCycles` + 1) times."},{"content":"<ph id=\"ph1\">`MaxRetryCycles`</ph> is ignored on <ph id=\"ph2\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph3\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>.","pos":[3236,3373],"source":"`MaxRetryCycles` is ignored on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]."},{"content":"<ph id=\"ph1\">`RetryCycleDelay`</ph>.","pos":[3383,3401],"source":"`RetryCycleDelay`."},{"content":"The time delay between retry cycles.","pos":[3402,3438]},{"content":"The default value is 30 minutes.","pos":[3439,3471]},{"content":"<ph id=\"ph1\">`MaxRetryCycles`</ph> and <ph id=\"ph2\">`RetryCycleDelay`</ph> together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.","pos":[3472,3618],"source":"`MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem."},{"content":"For example, this handles a locked row set in SQL Server pending transaction commit.","pos":[3619,3703]},{"content":"<ph id=\"ph1\">`ReceiveErrorHandling`</ph>.","pos":[3713,3736],"source":"`ReceiveErrorHandling`."},{"content":"An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.","pos":[3737,3880]},{"content":"The values can be Fault, Drop, Reject, and Move.","pos":[3881,3929]},{"content":"The default option is Fault.","pos":[3930,3958]},{"content":"Fault.","pos":[3968,3974]},{"content":"This option sends a fault to the listener that caused the <ph id=\"ph1\">`ServiceHost`</ph> to fault.","pos":[3975,4056],"source":" This option sends a fault to the listener that caused the `ServiceHost` to fault."},{"content":"The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.","pos":[4057,4210]},{"content":"Drop.","pos":[4220,4225]},{"content":"This option drops the poison message and the message is never delivered to the application.","pos":[4226,4317]},{"content":"If the message's <ph id=\"ph1\">`TimeToLive`</ph> property has expired at this point, then the message may appear in the sender's dead-letter queue.","pos":[4318,4446],"source":" If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue."},{"content":"If not, the message does not appear anywhere.","pos":[4447,4492]},{"content":"This option indicates that the user has not specified what to do if the message is lost.","pos":[4493,4581]},{"content":"Reject.","pos":[4591,4598]},{"content":"This option is available only on <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph>.","pos":[4599,4678],"source":" This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)]."},{"content":"This instructs Message Queuing (MSMQ) to send a negative acknowledgement back to the sending queue manager that the application cannot receive the message.","pos":[4679,4834]},{"content":"The message is placed in the sending queue manager's dead-letter queue.","pos":[4835,4906]},{"content":"Move.","pos":[4916,4921]},{"content":"This option is available only on <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph>.","pos":[4922,5001],"source":" This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)]."},{"content":"This moves the poison message to a poison-message queue for later processing by a poison-message handling application.","pos":[5002,5120]},{"content":"The poison-message queue is a subqueue of the application queue.","pos":[5121,5185]},{"content":"A poison-message handling application can be a WCF service that reads messages out of the poison queue.","pos":[5186,5289]},{"content":"The poison queue is a subqueue of the application queue and can be addressed as net.msmq://<ph id=\"ph1\">\\&lt;</ph><bpt id=\"p1\">*</bpt>machine-name<ept id=\"p1\">*</ept><ph id=\"ph2\">&gt;/</ph><bpt id=\"p2\">*</bpt>applicationQueue<ept id=\"p2\">*</ept>;poison, where <bpt id=\"p3\">*</bpt>machine-name<ept id=\"p3\">*</ept> is the name of the computer on which the queue resides and the <bpt id=\"p4\">*</bpt>applicationQueue<ept id=\"p4\">*</ept> is the name of the application-specific queue.","pos":[5290,5575],"source":" The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue."},{"content":"The following are the maximum number of delivery attempts made for a message:","pos":[5582,5659]},{"pos":[5669,5765],"content":"((ReceiveRetryCount+1) * (MaxRetryCycles + 1)) on <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph>.","source":"((ReceiveRetryCount+1) * (MaxRetryCycles + 1)) on [!INCLUDE[wv](../../../../includes/wv-md.md)]."},{"pos":[5775,5908],"content":"(ReceiveRetryCount + 1) on <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>.","source":"(ReceiveRetryCount + 1) on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]."},{"pos":[5916,5992],"content":"[!NOTE]\n No retries are made for a message that is delivered successfully.","leadings":["","> "],"nodes":[{"content":"No retries are made for a message that is delivered successfully.","pos":[9,74]}]},{"content":"To keep track of the number of times a message read is attempted, <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph> maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.","pos":[5999,6301],"source":"To keep track of the number of times a message read is attempted, [!INCLUDE[wv](../../../../includes/wv-md.md)] maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues."},{"content":"The WCF channel uses these to compute the receive retry count and the retry cycles count.","pos":[6302,6391]},{"content":"On <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>, the abort count is maintained in memory by the WCF channel and is reset if the application fails.","pos":[6392,6599],"source":" On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], the abort count is maintained in memory by the WCF channel and is reset if the application fails."},{"content":"Also, the WCF channel can hold the abort counts for up to 256 messages in memory at any time.","pos":[6600,6693]},{"content":"If a 257th message is read, then the oldest message's abort count is reset.","pos":[6694,6769]},{"content":"The abort count and move count properties are available to the service operation through the operation context.","pos":[6776,6887]},{"content":"The following code example shows how to access them.","pos":[6888,6940]},{"content":"WCF provides two standard queued bindings:","pos":[7074,7116]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.NetMsmqBinding&gt;</ph>.","pos":[7126,7168],"source":"<xref:System.ServiceModel.NetMsmqBinding>."},{"content":"A <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> binding suitable for performing queue-based communication with other WCF endpoints.","pos":[7169,7318],"source":" A [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] binding suitable for performing queue-based communication with other WCF endpoints."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding&gt;</ph>.","pos":[7328,7394],"source":"<xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>."},{"content":"A binding suitable for communicating with existing Message Queuing applications.","pos":[7395,7475]},{"pos":[7483,7895],"content":"[!NOTE]\n You can alter properties in these bindings based on the requirements of your WCF service. The entire poison message handling mechanism is local to the receiving application. The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender. In that case, the message is moved to the sender's dead-letter queue.","leadings":["","> "],"nodes":[{"content":"You can alter properties in these bindings based on the requirements of your WCF service. The entire poison message handling mechanism is local to the receiving application. The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender. In that case, the message is moved to the sender's dead-letter queue.","pos":[9,410],"nodes":[{"content":"You can alter properties in these bindings based on the requirements of your WCF service.","pos":[0,89]},{"content":"The entire poison message handling mechanism is local to the receiving application.","pos":[90,173]},{"content":"The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.","pos":[174,331]},{"content":"In that case, the message is moved to the sender's dead-letter queue.","pos":[332,401]}]}]},{"pos":[7904,7954],"content":"Best Practice: Handling MsmqPoisonMessageException","linkify":"Best Practice: Handling MsmqPoisonMessageException","nodes":[{"content":"Best Practice: Handling MsmqPoisonMessageException","pos":[0,50]}]},{"pos":[7958,8147],"content":"When the service determines that a message is poison, the queued transport throws a <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqPoisonMessageException&gt;</ph> that contains the <ph id=\"ph2\">`LookupId`</ph> of the poison message.","source":"When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message."},{"content":"A receiving application can implement the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IErrorHandler&gt;</ph> interface to handle any errors that the application requires.","pos":[8154,8309],"source":"A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Extending Control Over Error Handling and Reporting<ept id=\"p1\">](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md)</ept>.","pos":[8310,8485],"source":" For more information, see [Extending Control Over Error Handling and Reporting](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md)."},{"content":"The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.","pos":[8492,8697]},{"content":"The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A&gt;</ph> setting is set to <ph id=\"ph2\">&lt;xref:System.ServiceModel.ReceiveErrorHandling.Fault&gt;</ph>.","pos":[8698,8966],"source":" The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>."},{"content":"The poison-message sample for Message Queuing 3.0 demonstrates this behavior.","pos":[8967,9044]},{"content":"The following outlines the steps to take to handle poison messages, including best practices:","pos":[9045,9138]},{"content":"Ensure your poison settings reflect the requirements of your application.","pos":[9148,9221]},{"content":"When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>.","pos":[9222,9498],"source":" When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]."},{"content":"If required, implement the <ph id=\"ph1\">`IErrorHandler`</ph> to handle poison-message errors.","pos":[9508,9583],"source":"If required, implement the `IErrorHandler` to handle poison-message errors."},{"content":"Because setting <ph id=\"ph1\">`ReceiveErrorHandling`</ph> to <ph id=\"ph2\">`Fault`</ph> requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement <ph id=\"ph3\">`IErrorHandler`</ph> when <ph id=\"ph4\">`ReceiveErrorHandling`</ph> is set to <ph id=\"ph5\">`Fault`</ph>, as shown in the following code.","pos":[9584,9877],"source":" Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code."},{"content":"Create a <ph id=\"ph1\">`PoisonBehaviorAttribute`</ph> that the service behavior can use.","pos":[10029,10098],"source":"Create a `PoisonBehaviorAttribute` that the service behavior can use."},{"content":"The behavior installs the <ph id=\"ph1\">`IErrorHandler`</ph> on the dispatcher.","pos":[10099,10159],"source":" The behavior installs the `IErrorHandler` on the dispatcher."},{"content":"See the following code example.","pos":[10160,10191]},{"content":"Ensure that your service is annotated with the poison behavior attribute.","pos":[10348,10421]},{"content":"In addition, if the <ph id=\"ph1\">`ReceiveErrorHandling`</ph> is set to <ph id=\"ph2\">`Fault`</ph>, the <ph id=\"ph3\">`ServiceHost`</ph> faults when encountering the poison message.","pos":[10426,10550],"source":"In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message."},{"content":"You can hook up to the faulted event and shut down the service, take corrective actions, and restart.","pos":[10551,10652]},{"content":"For example, the <ph id=\"ph1\">`LookupId`</ph> in the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MsmqPoisonMessageException&gt;</ph> propagated to the <ph id=\"ph3\">`IErrorHandler`</ph> can be noted and when the service host faults, you could use the <ph id=\"ph4\">`System.Messaging`</ph> API to receive the message from the queue using the <ph id=\"ph5\">`LookupId`</ph> to remove the message from the queue and store the message in some external store or another queue.","pos":[10653,11022],"source":" For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue."},{"content":"You can then restart <ph id=\"ph1\">`ServiceHost`</ph> to resume normal processing.","pos":[11023,11086],"source":" You can then restart `ServiceHost` to resume normal processing."},{"content":"The <bpt id=\"p1\">[</bpt>Poison Message Handling in MSMQ 4.0<ept id=\"p1\">](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md)</ept> demonstrates this behavior.","pos":[11087,11235],"source":" The [Poison Message Handling in MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior."},{"pos":[11244,11284],"content":"Transaction Time-Out and Poison Messages","linkify":"Transaction Time-Out and Poison Messages","nodes":[{"content":"Transaction Time-Out and Poison Messages","pos":[0,40]}]},{"content":"A class of errors can occur between the queued transport channel and the user code.","pos":[11288,11371]},{"content":"These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.","pos":[11372,11491]},{"content":"For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.","pos":[11492,11657]},{"content":"When this happens, the service model drops the message.","pos":[11658,11713]},{"content":"Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.","pos":[11714,11904]},{"content":"In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph>.","pos":[11905,12150],"source":" In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>."},{"content":"To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.","pos":[12157,12471]},{"content":"Eventually, the message becomes poison and the right disposition is made according to the user settings.","pos":[12472,12576]},{"pos":[12585,12613],"content":"Sessions and Poison Messages","linkify":"Sessions and Poison Messages","nodes":[{"content":"Sessions and Poison Messages","pos":[0,28]}]},{"content":"A session undergoes the same retry and poison-message handling procedures as a single message.","pos":[12617,12711]},{"content":"The properties previously listed for poison messages apply to the entire session.","pos":[12712,12793]},{"content":"This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.","pos":[12794,12942]},{"pos":[12951,12979],"content":"Batching and Poison Messages","linkify":"Batching and Poison Messages","nodes":[{"content":"Batching and Poison Messages","pos":[0,28]}]},{"content":"If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.","pos":[12983,13139]},{"content":"For more information about batching, see <bpt id=\"p1\">[</bpt>Batching Messages in a Transaction<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</ept>","pos":[13140,13303],"source":" For more information about batching, see [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)"},{"pos":[13312,13366],"content":"Poison-message Handling for Messages in a Poison Queue","linkify":"Poison-message Handling for Messages in a Poison Queue","nodes":[{"content":"Poison-message Handling for Messages in a Poison Queue","pos":[0,54]}]},{"content":"Poison-message handling does not end when a message is placed in the poison-message queue.","pos":[13370,13460]},{"content":"Messages in the poison-message queue must still be read and handled.","pos":[13461,13529]},{"content":"You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.","pos":[13530,13644]},{"content":"The applicable settings are <ph id=\"ph1\">`ReceiveRetryCount`</ph> and <ph id=\"ph2\">`ReceiveErrorHandling`</ph>.","pos":[13645,13720],"source":" The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`."},{"content":"You can set <ph id=\"ph1\">`ReceiveErrorHandling`</ph> to Drop, Reject, or Fault.","pos":[13721,13782],"source":" You can set `ReceiveErrorHandling` to Drop, Reject, or Fault."},{"content":"<ph id=\"ph1\">`MaxRetryCycles`</ph> is ignored and an exception is thrown if <ph id=\"ph2\">`ReceiveErrorHandling`</ph> is set to Move.","pos":[13783,13879],"source":"`MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move."},{"pos":[13888,13950],"content":"Windows Vista, Windows Server 2003, and Windows XP Differences","linkify":"Windows Vista, Windows Server 2003, and Windows XP Differences","nodes":[{"content":"Windows Vista, Windows Server 2003, and Windows XP Differences","pos":[0,62]}]},{"content":"As noted earlier, not all poison-message handling settings apply to <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>.","pos":[13954,14128],"source":"As noted earlier, not all poison-message handling settings apply to [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]."},{"content":"The following key differences between Message Queuing on <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph> are relevant to poison-message handling:","pos":[14129,14380],"source":" The following key differences between Message Queuing on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and [!INCLUDE[wv](../../../../includes/wv-md.md)] are relevant to poison-message handling:"},{"content":"Message Queuing in <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph> supports subqueues, while <ph id=\"ph2\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph3\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph> do not support subqueues.","pos":[14390,14612],"source":"Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports subqueues, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues."},{"content":"Subqueues are used in poison-message handling.","pos":[14613,14659]},{"content":"The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.","pos":[14660,14799]},{"content":"The <ph id=\"ph1\">`MaxRetryCycles`</ph> dictates how many retry subqueues to create.","pos":[14800,14865],"source":" The `MaxRetryCycles` dictates how many retry subqueues to create."},{"content":"Therefore, when running on <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> or <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>, <ph id=\"ph3\">`MaxRetryCycles`</ph> are ignored and <ph id=\"ph4\">`ReceiveErrorHandling.Move`</ph> is not allowed.","pos":[14866,15075],"source":" Therefore, when running on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed."},{"content":"Message Queuing in <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph> supports negative acknowledgment, while <ph id=\"ph2\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph3\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph> do not.","pos":[15085,15303],"source":"Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports negative acknowledgment, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not."},{"content":"A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.","pos":[15304,15451]},{"content":"As such, <ph id=\"ph1\">`ReceiveErrorHandling.Reject`</ph> is not allowed with <ph id=\"ph2\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph3\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>.","pos":[15452,15617],"source":" As such, `ReceiveErrorHandling.Reject` is not allowed with [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]."},{"content":"Message Queuing in <ph id=\"ph1\">[!INCLUDE[wv](../../../../includes/wv-md.md)]</ph> supports a message property that keeps count of the number of times message delivery is attempted.","pos":[15627,15790],"source":"Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports a message property that keeps count of the number of times message delivery is attempted."},{"content":"This abort count property is not available on <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wxp](../../../../includes/wxp-md.md)]</ph>.","pos":[15791,15943],"source":" This abort count property is not available on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)]."},{"content":"WCF maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one WCF service in a farm.","pos":[15944,16125]},{"pos":[16134,16142],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[16146,16230],"content":"<bpt id=\"p1\">[</bpt>Queues Overview<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/queues-overview.md)</ept>","source":"[Queues Overview](../../../../docs/framework/wcf/feature-details/queues-overview.md)"},{"pos":[16233,16417],"content":"<bpt id=\"p1\">[</bpt>Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)</ept>","source":"[Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)"},{"pos":[16420,16570],"content":"<bpt id=\"p1\">[</bpt>Specifying and Handling Faults in Contracts and Services<ept id=\"p1\">](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)</ept>","source":"[Specifying and Handling Faults in Contracts and Services](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)"}]}