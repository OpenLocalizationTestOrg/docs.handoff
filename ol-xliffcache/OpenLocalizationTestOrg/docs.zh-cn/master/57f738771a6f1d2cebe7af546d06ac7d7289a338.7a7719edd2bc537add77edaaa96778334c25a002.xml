{"content":"---\ntitle: Design with nullable reference types\ndescription: This advanced tutorial provides an introduction to nullable reference types. You'll learn to express your design intent on when reference values may be null, and have the compiler enforce when they cannot be null.\nms.date: 02/19/2019\nms.custom: mvc\n---\n# Tutorial: Migrate existing code with nullable reference types\n\nC# 8 introduces **nullable reference types**, which complement reference types the same way nullable value types complement value types. You declare a variable to be a **nullable reference type** by appending a `?` to the type. For example, `string?` represents a nullable `string`. You can use these new types to more clearly express your design intent: some variables *must always have a value*, others *may be missing a value*. Any existing variables of a reference type would be interpreted as a non-nullable reference type. \n\nIn this tutorial, you'll learn how to:\n\n> [!div class=\"checklist\"]\n> * Enable null reference checks as you work with code.\n> * Diagnose and correct different warnings related to null values.\n> * Manage the interface between nullable enabled and nullable disabled contexts.\n> * Control nullable annotation contexts.\n\n## Prerequisites\n\nYou'll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler. The C# 8 beta compiler is available with [Visual Studio 2019 preview 2 and later](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019+preview), or [.NET Core 3.0 preview 2](https://dotnet.microsoft.com/download/dotnet-core/3.0).\n\nThis tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.\n\n## Explore the sample application\n\nThe sample application that you'll migrate is an RSS feed reader web app. It reads from a single RSS feed and displays summaries for the most recent articles. You can click on any of the articles to visit the site. The application is relatively new but was written before nullable reference types were available. The design decisions for the application represented sound principles, but don't take advantage of this important language feature.\n\nThe sample application includes a unit test library that validates the major functionality of the app. That project will make it easier to upgrade safely, if you change any of the implementation based on the warnings generated. You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start) GitHub repository.\n\nYour goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to `enabled`.\n\n## Upgrade the projects to C# 8\n\nA good first step is to determine the scope of the migration task. Start by upgrading the project to C# 8.0 (or newer). Add the `LangVersion` element to both csproj files for the web project and the unit test project:\n\n```xml\n<LangVersion>8.0</LangVersion>\n```\n\nUpgrading the language version selects C# 8.0, but does not enable the nullable annotation context or the nullable warning context. Rebuild the project to ensure that it builds without warnings.\n\nA good next step is to turn on the nullable annotation context and see how many warnings are generated. Add the following element to both csproj files in the solution, directly under the `LangVersion` element:\n\n```xml\n<NullableContextOptions>enable</NullableContextOptions>\n```\n\nDo a test build, and notice the warning list. In this small application, the compiler generates five warnings, so it's likely you'd leave the nullable annotation context enabled and start fixing warnings for the entire project.\n\nThat strategy works only for smaller projects. For any larger projects, the number of warnings generated by enabling the nullable annotation context for the entire codebase makes it harder to fix the warnings systematically. For larger enterprise projects, you'll often want to migrate one project at a time. In each project, migrate one class or file at a time.\n\n## Warnings help discover original design intent\n\nThere are two classes that generate multiple warnings. Start with the `NewsStoryViewModel` class. Remove the `NullableContextOptions` element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with. Open the *NewsStoryViewModel.cs* file and add the following directives to enable the nullable annotation context for the `NewsStoryViewModel` and restore it following that class definition:\n\n```csharp\n#nullable enable\npublic class NewsStoryViewModel\n{\n    public DateTimeOffset Published { get; set; }\n    public string Title { get; set; }\n    public string Uri { get; set; }\n}\n#nullable restore\n```\n\nThese two directives help you focus your migration efforts. The nullable warnings are generated for the area of code you're actively working on. You'll leave them on until you're ready to turn on the warnings for the entire project. You should use the `restore` rather than `disable` value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project. Once you've turned on the nullable annotation context for the entire project, you can remove all the `#nullable` pragmas from that project.\n\nThe `NewsStoryViewModel` class is a data transfer object (DTO) and two of the properties are read/write strings:\n\n[!code-csharp[InitialViewModel](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#StarterViewModel)]\n\nThese two properties cause `CS8618`, \"Non-nullable property is uninitialized\". That's clear enough: both `string` properties have the default value of `null` when a `NewsStoryViewModel` is constructed. What's important to discover is how `NewsStoryViewModel` objects are constructed. Looking at this class, you can't tell if the `null` value is part of the design, or if these objects are set to non-null values whenever one is created. The news stories are created in the `GetNews` method of the `NewsService` class:\n\n[!code-csharp[StarterCreateNewsItem](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#CreateNewsItem)]\n\nThere's quite a bit going on in the preceding block of code. This application uses the [AutoMapper](http://automapper.org/) NuGet package to construct a news item from an `ISyndicationItem`. You've discovered that the news story items are constructed and the properties are set in that one statement. That means the design for the `NewsStoryViewModel` indicates that these properties should never have the `null` value. These properties should be **nonnullable reference types**. That best expresses the original design intent. In fact, any `NewsStoryViewModel` *is* correctly instantiated with non-null values. That makes the following initialization code a valid fix:\n\n```csharp\npublic class NewsStoryViewModel\n{\n    public DateTimeOffset Published { get; set; }\n    public string Title { get; set; } = default!;\n    public string Uri { get; set; } = default!;\n}\n```\n\nThe assignment of `Title` and `Uri` to `default` which is `null` for the `string` type doesn't change the runtime behavior of the program. The `NewsStoryViewModel` is still constructed with null values, but now the compiler reports no warnings. The **null-forgiving operator**, the `!` character following the `default` expression tells the compiler that the preceding expression is not null. This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the `NewsStoryViewModel` an immutable type where all the properties are set in the constructor. Make the following changes to the `NewsStoryViewModel`:\n\n[!code-csharp[FinishedViewModel](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#FinishedViewModel)]\n\nOnce that's done, you need to update the code that configures the AutoMapper so that it uses the constructor rather than setting properties. Open `NewsService.cs` and look for the following code at the bottom of the file:\n\n[!code-csharp[StarterAutoMapper](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]\n\nThat code maps properties of the `ISyndicationItem` object to the `NewsStoryViewModel` properties. You want the AutoMapper to provide the mapping using a constructor instead. Replace the above code with the following automapper configuration:\n\n[!code-csharp[FinishedViewModel](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]\n\nNotice that because this class is small, and you've examined carefully, you should turn on the `#nullable enable` directive above this class declaration. The change to the constructor could have broken something, so it's worthwhile to run all the tests and test the application before moving on.\n\nThe first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to `null`. The technique is referred to as **correct by construction**. You declare that an object and its properties cannot be `null` when it's constructed. The compiler's flow analysis provides assurance that those properties aren't set to `null` after construction. Note that this constructor is called by external code, and that code is **nullable oblivious**. The new syntax doesn't provide runtime checking. External code might circumvent the compiler's flow analysis. \n\nOther times, the structure of a class provides different clues to the intent. Open the *Error.cshtml.cs* file in the *Pages* folder. The `ErrorViewModel` contains the following code:\n\n[!code-csharp[StarterErrorModel](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Error.cshtml.cs#StartErrorModel)]\n\nAdd the `#nullable enable` directive before the class declaration, and a `#nullable restore` directive after it. You'll get one warning that `RequestId` is not initialized. By looking at the class, you should decide that the `RequestId` property should be null in some cases. The existence of the `ShowRequestId` property indicates that missing values are possible. Because `null` is valid, add the `?` on the `string` type to indicate the `RequestId` property is a *nullable reference type*. The final class looks like the following example:\n\n[!code-csharp[FinishedErrorModel](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Error.cshtml.cs#ErrorModel)]\n\nCheck for the uses of the property, and you see that in the associated page, the property is checked for null before rendering it in markup. That's a safe use of a nullable reference type, so you're done with this class.\n\n## Fixing nulls causes change\n\nFrequently, the fix for one set of warnings creates new warnings in related code. Let's see the warnings in action by fixing the `index.cshtml.cs` class. Open the `index.cshtml.cs` file and examine the code. This file contains the code behind for the index page:\n\n[!code-csharp[StarterIndexModel](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Index.cshtml.cs#IndexModelStart)]\n\nAdd the `#nullable enable` directive and you'll see two warnings. Neither the `ErrorText` property nor the `NewsItems` property is initialized. An examination of this class would lead you to believe that both properties should be nullable reference types: Both have private setters. Exactly one is assigned in the `OnGet` method. Before making changes, look at the consumers of both properties. In the page itself, the `ErrorText` is checked against null before generating markup for any errors. The `NewsItems` collection is checked against `null`, and checked to ensure the collection has items. A quick fix would be to make both properties nullable reference types. A better fix would be to make the collection a nonnullable reference type, and add items to the existing collection when retrieving news. The first fix is to add the `?` to the `string` type for the `ErrorText`:\n\n[!code-csharp[UpdateErrorText](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#UpdateErrorText)]\n\nThat change won't ripple through other code, because any access to the `ErrorText` property was already guarded by null checks. Next, initialize the `NewsItems` list and remove the property setter, making it a readonly property:\n\n[!code-csharp[InitializeNewsItems](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#InitializeNewsItems)]\n\nThat fixed the warning but introduced an error. The `NewsItems` list is now **correct by construction**, but the code that sets the list in `OnGet` must change to match the new API. Instead of an assignment, call `AddRange` to add the news items to the existing list:\n\n[!code-csharp[AddRange](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#AddRange)]\n\nUsing `AddRange` instead of an assignment means that the `GetNews` method can return an `IEnumerable` instead of a `List`. That saves one allocation. Change the signature of the method, and remove the `ToList` call, as shown in the following code sample:\n\n[!code-csharp[GetNews](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#GetNewsFinished)]\n\nChanging the signature breaks one of tests as well. Open the `NewsServiceTests.cs` file in the `Services` folder of the `SimpleFeedReader.Tests` project. Navigate to the `Returns_News_Stories_Given_Valid_Uri` test and change the type of the `result` variable to `IEnumerable<NewsItem>`. Changing the type means the `Count` property is no longer available, so replace the `Count` property in the `Assert` with a call to `Any()`:\n\n[!code-csharp[FixTests](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader.Tests/Services/NewsServiceTests.cs#FixTestSignature)]\n\nYou'll need to add a `using System.Linq` statement to the beginning of the file as well.\n\nThis set of changes highlights special consideration when updating code that includes generic instantiations. Both the list and the elements in the list of non-nullable types. Either or both could be nullable types. All the following declarations are allowed:\n\n- `List<NewsStoryViewModel>`: nonnullable list of nonullable view models.\n- `List<NewsStoryViewModel?>`: nonnullable list of nullable view models.\n- `List<NewsStoryViewModel>?`: nullable list of nonnullable view models.\n- `List<NewsStoryViewModel?>?`: nullable list of nullable view models.\n\n## Interfaces with external code\n\nYou've made changes to the `NewsService` class, so turn on the `#nullable enable` annotation for that class. This won't generate any new warnings. However, careful examination of the class helps to illustrate some of the limitations of the compiler's flow analysis. Examine the constructor:\n\n[!code-csharp[ServiceConstructor](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ServiceConstructor)]\n\nThe `IMapper` parameter is typed as a nonnullable reference. It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the `IMapper` will never be null. The default ASP.NET Core dependency injection (DI) container throws an exception if it can't resolve a necessary service, so the code is correct. The compiler can't validate all calls to your public APIs, even if your code is compiled with nullable annotation contexts enabled. Furthermore, your libraries may be consumed by projects that have not yet opted into using nullable reference types. Validate inputs to public APIs even though you've declared them as nonnullable types.\n\n## Get the code\n\nYou've fixed the warnings you identified in the initial test compile, so now you can turn on the nullable annotation context for both projects. Rebuild the projects; the compiler reports no warnings. You can get the code for the finished project in the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished) GitHub repository.\n\nThe new features that support nullable reference types help you find and fix potential errors in how you handle `null` values in your code. Enabling the nullable annotation context allows you to express your design intent: some variables should never be null, other variables may contain null values. These features make it easier for you to declare your design intent. Similarly, the nullable warning context instructs the compiler to issue warnings when you have violated that intent. Those warnings guide you to make updates that make your code more resilient and less likely to throw a `NullReferenceException` during execution. You can control the scope of these contexts so that you can focus on local areas of code to migrate while the remaining codebase is untouched. In practice, you can make this migration task a part of regular maintenance to your classes. This tutorial demonstrated the process to migrate an application to use nullable reference types. You can explore a larger real-world example of this process by examining the PR [Jon Skeet](https://github.com/jskeet) made to incorporate nullable reference types into [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits).\n","nodes":[{"pos":[4,309],"embed":true,"restype":"x-metadata","content":"title: Design with nullable reference types\ndescription: This advanced tutorial provides an introduction to nullable reference types. You'll learn to express your design intent on when reference values may be null, and have the compiler enforce when they cannot be null.\nms.date: 02/19/2019\nms.custom: mvc","nodes":[{"content":"Design with nullable reference types","nodes":[{"pos":[0,36],"content":"Design with nullable reference types","nodes":[{"content":"Design with nullable reference types","pos":[0,36]}]}],"path":["title"],"nosxs":false},{"content":"This advanced tutorial provides an introduction to nullable reference types. You'll learn to express your design intent on when reference values may be null, and have the compiler enforce when they cannot be null.","nodes":[{"pos":[0,213],"content":"This advanced tutorial provides an introduction to nullable reference types. You'll learn to express your design intent on when reference values may be null, and have the compiler enforce when they cannot be null.","nodes":[{"content":"This advanced tutorial provides an introduction to nullable reference types. You'll learn to express your design intent on when reference values may be null, and have the compiler enforce when they cannot be null.","pos":[0,213],"nodes":[{"content":"This advanced tutorial provides an introduction to nullable reference types.","pos":[0,76]},{"content":"You'll learn to express your design intent on when reference values may be null, and have the compiler enforce when they cannot be null.","pos":[77,213]}]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[316,377],"content":"Tutorial: Migrate existing code with nullable reference types","linkify":"Tutorial: Migrate existing code with nullable reference types","nodes":[{"content":"Tutorial: Migrate existing code with nullable reference types","pos":[0,61]}]},{"content":"C# 8 introduces <bpt id=\"p1\">**</bpt>nullable reference types<ept id=\"p1\">**</ept>, which complement reference types the same way nullable value types complement value types.","pos":[379,515],"source":"C# 8 introduces **nullable reference types**, which complement reference types the same way nullable value types complement value types."},{"content":"You declare a variable to be a <bpt id=\"p1\">**</bpt>nullable reference type<ept id=\"p1\">**</ept> by appending a <ph id=\"ph1\">`?`</ph> to the type.","pos":[516,606],"source":" You declare a variable to be a **nullable reference type** by appending a `?` to the type."},{"content":"For example, <ph id=\"ph1\">`string?`</ph> represents a nullable <ph id=\"ph2\">`string`</ph>.","pos":[607,661],"source":" For example, `string?` represents a nullable `string`."},{"content":"You can use these new types to more clearly express your design intent: some variables <bpt id=\"p1\">*</bpt>must always have a value<ept id=\"p1\">*</ept>, others <bpt id=\"p2\">*</bpt>may be missing a value<ept id=\"p2\">*</ept>.","pos":[662,809],"source":" You can use these new types to more clearly express your design intent: some variables *must always have a value*, others *may be missing a value*."},{"content":"Any existing variables of a reference type would be interpreted as a non-nullable reference type.","pos":[810,907]},{"content":"In this tutorial, you'll learn how to:","pos":[910,948]},{"content":"Enable null reference checks as you work with code.","pos":[981,1032]},{"content":"Diagnose and correct different warnings related to null values.","pos":[1037,1100]},{"content":"Manage the interface between nullable enabled and nullable disabled contexts.","pos":[1105,1182]},{"content":"Control nullable annotation contexts.","pos":[1187,1224]},{"pos":[1229,1242],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"You'll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler.","pos":[1244,1332]},{"content":"The C# 8 beta compiler is available with <bpt id=\"p1\">[</bpt>Visual Studio 2019 preview 2 and later<ept id=\"p1\">](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019+preview)</ept>, or <bpt id=\"p2\">[</bpt>.NET Core 3.0 preview 2<ept id=\"p2\">](https://dotnet.microsoft.com/download/dotnet-core/3.0)</ept>.","pos":[1333,1660],"source":" The C# 8 beta compiler is available with [Visual Studio 2019 preview 2 and later](https://visualstudio.microsoft.com/vs/preview/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019+preview), or [.NET Core 3.0 preview 2](https://dotnet.microsoft.com/download/dotnet-core/3.0)."},{"content":"This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.","pos":[1662,1770]},{"pos":[1775,1805],"content":"Explore the sample application","linkify":"Explore the sample application","nodes":[{"content":"Explore the sample application","pos":[0,30]}]},{"content":"The sample application that you'll migrate is an RSS feed reader web app.","pos":[1807,1880]},{"content":"It reads from a single RSS feed and displays summaries for the most recent articles.","pos":[1881,1965]},{"content":"You can click on any of the articles to visit the site.","pos":[1966,2021]},{"content":"The application is relatively new but was written before nullable reference types were available.","pos":[2022,2119]},{"content":"The design decisions for the application represented sound principles, but don't take advantage of this important language feature.","pos":[2120,2251]},{"content":"The sample application includes a unit test library that validates the major functionality of the app.","pos":[2253,2355]},{"content":"That project will make it easier to upgrade safely, if you change any of the implementation based on the warnings generated.","pos":[2356,2480]},{"content":"You can download the starter code from the <bpt id=\"p1\">[</bpt>dotnet/samples<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start)</ept> GitHub repository.","pos":[2481,2658],"source":" You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start) GitHub repository."},{"pos":[2660,2971],"content":"Your goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to <ph id=\"ph1\">`enabled`</ph>.","source":"Your goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to `enabled`."},{"pos":[2976,3004],"content":"Upgrade the projects to C# 8","linkify":"Upgrade the projects to C# 8","nodes":[{"content":"Upgrade the projects to C# 8","pos":[0,28]}]},{"content":"A good first step is to determine the scope of the migration task.","pos":[3006,3072]},{"content":"Start by upgrading the project to C# 8.0 (or newer).","pos":[3073,3125]},{"content":"Add the <ph id=\"ph1\">`LangVersion`</ph> element to both csproj files for the web project and the unit test project:","pos":[3126,3223],"source":" Add the `LangVersion` element to both csproj files for the web project and the unit test project:"},{"content":"Upgrading the language version selects C# 8.0, but does not enable the nullable annotation context or the nullable warning context.","pos":[3268,3399]},{"content":"Rebuild the project to ensure that it builds without warnings.","pos":[3400,3462]},{"content":"A good next step is to turn on the nullable annotation context and see how many warnings are generated.","pos":[3464,3567]},{"content":"Add the following element to both csproj files in the solution, directly under the <ph id=\"ph1\">`LangVersion`</ph> element:","pos":[3568,3673],"source":" Add the following element to both csproj files in the solution, directly under the `LangVersion` element:"},{"content":"Do a test build, and notice the warning list.","pos":[3743,3788]},{"content":"In this small application, the compiler generates five warnings, so it's likely you'd leave the nullable annotation context enabled and start fixing warnings for the entire project.","pos":[3789,3970]},{"content":"That strategy works only for smaller projects.","pos":[3972,4018]},{"content":"For any larger projects, the number of warnings generated by enabling the nullable annotation context for the entire codebase makes it harder to fix the warnings systematically.","pos":[4019,4196]},{"content":"For larger enterprise projects, you'll often want to migrate one project at a time.","pos":[4197,4280]},{"content":"In each project, migrate one class or file at a time.","pos":[4281,4334]},{"pos":[4339,4384],"content":"Warnings help discover original design intent","linkify":"Warnings help discover original design intent","nodes":[{"content":"Warnings help discover original design intent","pos":[0,45]}]},{"content":"There are two classes that generate multiple warnings.","pos":[4386,4440]},{"content":"Start with the <ph id=\"ph1\">`NewsStoryViewModel`</ph> class.","pos":[4441,4483],"source":" Start with the `NewsStoryViewModel` class."},{"content":"Remove the <ph id=\"ph1\">`NullableContextOptions`</ph> element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with.","pos":[4484,4639],"source":" Remove the `NullableContextOptions` element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with."},{"content":"Open the <bpt id=\"p1\">*</bpt>NewsStoryViewModel.cs<ept id=\"p1\">*</ept> file and add the following directives to enable the nullable annotation context for the <ph id=\"ph1\">`NewsStoryViewModel`</ph> and restore it following that class definition:","pos":[4640,4829],"source":" Open the *NewsStoryViewModel.cs* file and add the following directives to enable the nullable annotation context for the `NewsStoryViewModel` and restore it following that class definition:"},{"content":"These two directives help you focus your migration efforts.","pos":[5041,5100]},{"content":"The nullable warnings are generated for the area of code you're actively working on.","pos":[5101,5185]},{"content":"You'll leave them on until you're ready to turn on the warnings for the entire project.","pos":[5186,5273]},{"content":"You should use the <ph id=\"ph1\">`restore`</ph> rather than <ph id=\"ph2\">`disable`</ph> value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project.","pos":[5274,5454],"source":" You should use the `restore` rather than `disable` value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project."},{"content":"Once you've turned on the nullable annotation context for the entire project, you can remove all the <ph id=\"ph1\">`#nullable`</ph> pragmas from that project.","pos":[5455,5594],"source":" Once you've turned on the nullable annotation context for the entire project, you can remove all the `#nullable` pragmas from that project."},{"pos":[5596,5708],"content":"The <ph id=\"ph1\">`NewsStoryViewModel`</ph> class is a data transfer object (DTO) and two of the properties are read/write strings:","source":"The `NewsStoryViewModel` class is a data transfer object (DTO) and two of the properties are read/write strings:"},{"content":"These two properties cause <ph id=\"ph1\">`CS8618`</ph>, \"Non-nullable property is uninitialized\".","pos":[5874,5952],"source":"These two properties cause `CS8618`, \"Non-nullable property is uninitialized\"."},{"content":"That's clear enough: both <ph id=\"ph1\">`string`</ph> properties have the default value of <ph id=\"ph2\">`null`</ph> when a <ph id=\"ph3\">`NewsStoryViewModel`</ph> is constructed.","pos":[5953,6075],"source":" That's clear enough: both `string` properties have the default value of `null` when a `NewsStoryViewModel` is constructed."},{"content":"What's important to discover is how <ph id=\"ph1\">`NewsStoryViewModel`</ph> objects are constructed.","pos":[6076,6157],"source":" What's important to discover is how `NewsStoryViewModel` objects are constructed."},{"content":"Looking at this class, you can't tell if the <ph id=\"ph1\">`null`</ph> value is part of the design, or if these objects are set to non-null values whenever one is created.","pos":[6158,6310],"source":" Looking at this class, you can't tell if the `null` value is part of the design, or if these objects are set to non-null values whenever one is created."},{"content":"The news stories are created in the <ph id=\"ph1\">`GetNews`</ph> method of the <ph id=\"ph2\">`NewsService`</ph> class:","pos":[6311,6391],"source":" The news stories are created in the `GetNews` method of the `NewsService` class:"},{"content":"There's quite a bit going on in the preceding block of code.","pos":[6551,6611]},{"content":"This application uses the <bpt id=\"p1\">[</bpt>AutoMapper<ept id=\"p1\">](http://automapper.org/)</ept> NuGet package to construct a news item from an <ph id=\"ph1\">`ISyndicationItem`</ph>.","pos":[6612,6741],"source":" This application uses the [AutoMapper](http://automapper.org/) NuGet package to construct a news item from an `ISyndicationItem`."},{"content":"You've discovered that the news story items are constructed and the properties are set in that one statement.","pos":[6742,6851]},{"content":"That means the design for the <ph id=\"ph1\">`NewsStoryViewModel`</ph> indicates that these properties should never have the <ph id=\"ph2\">`null`</ph> value.","pos":[6852,6970],"source":" That means the design for the `NewsStoryViewModel` indicates that these properties should never have the `null` value."},{"content":"These properties should be <bpt id=\"p1\">**</bpt>nonnullable reference types<ept id=\"p1\">**</ept>.","pos":[6971,7030],"source":" These properties should be **nonnullable reference types**."},{"content":"That best expresses the original design intent.","pos":[7031,7078]},{"content":"In fact, any <ph id=\"ph1\">`NewsStoryViewModel`</ph> <bpt id=\"p1\">*</bpt>is<ept id=\"p1\">*</ept> correctly instantiated with non-null values.","pos":[7079,7162],"source":" In fact, any `NewsStoryViewModel` *is* correctly instantiated with non-null values."},{"content":"That makes the following initialization code a valid fix:","pos":[7163,7220]},{"content":"The assignment of <ph id=\"ph1\">`Title`</ph> and <ph id=\"ph2\">`Uri`</ph> to <ph id=\"ph3\">`default`</ph> which is <ph id=\"ph4\">`null`</ph> for the <ph id=\"ph5\">`string`</ph> type doesn't change the runtime behavior of the program.","pos":[7421,7559],"source":"The assignment of `Title` and `Uri` to `default` which is `null` for the `string` type doesn't change the runtime behavior of the program."},{"content":"The <ph id=\"ph1\">`NewsStoryViewModel`</ph> is still constructed with null values, but now the compiler reports no warnings.","pos":[7560,7665],"source":" The `NewsStoryViewModel` is still constructed with null values, but now the compiler reports no warnings."},{"content":"The <bpt id=\"p1\">**</bpt>null-forgiving operator<ept id=\"p1\">**</ept>, the <ph id=\"ph1\">`!`</ph> character following the <ph id=\"ph2\">`default`</ph> expression tells the compiler that the preceding expression is not null.","pos":[7666,7813],"source":" The **null-forgiving operator**, the `!` character following the `default` expression tells the compiler that the preceding expression is not null."},{"content":"This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the <ph id=\"ph1\">`NewsStoryViewModel`</ph> an immutable type where all the properties are set in the constructor.","pos":[7814,8080],"source":" This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the `NewsStoryViewModel` an immutable type where all the properties are set in the constructor."},{"content":"Make the following changes to the <ph id=\"ph1\">`NewsStoryViewModel`</ph>:","pos":[8081,8136],"source":" Make the following changes to the `NewsStoryViewModel`:"},{"content":"Once that's done, you need to update the code that configures the AutoMapper so that it uses the constructor rather than setting properties.","pos":[8307,8447]},{"content":"Open <ph id=\"ph1\">`NewsService.cs`</ph> and look for the following code at the bottom of the file:","pos":[8448,8528],"source":" Open `NewsService.cs` and look for the following code at the bottom of the file:"},{"content":"That code maps properties of the <ph id=\"ph1\">`ISyndicationItem`</ph> object to the <ph id=\"ph2\">`NewsStoryViewModel`</ph> properties.","pos":[8689,8787],"source":"That code maps properties of the `ISyndicationItem` object to the `NewsStoryViewModel` properties."},{"content":"You want the AutoMapper to provide the mapping using a constructor instead.","pos":[8788,8863]},{"content":"Replace the above code with the following automapper configuration:","pos":[8864,8931]},{"content":"Notice that because this class is small, and you've examined carefully, you should turn on the <ph id=\"ph1\">`#nullable enable`</ph> directive above this class declaration.","pos":[9095,9248],"source":"Notice that because this class is small, and you've examined carefully, you should turn on the `#nullable enable` directive above this class declaration."},{"content":"The change to the constructor could have broken something, so it's worthwhile to run all the tests and test the application before moving on.","pos":[9249,9390]},{"content":"The first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to <ph id=\"ph1\">`null`</ph>.","pos":[9392,9521],"source":"The first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to `null`."},{"content":"The technique is referred to as <bpt id=\"p1\">**</bpt>correct by construction<ept id=\"p1\">**</ept>.","pos":[9522,9582],"source":" The technique is referred to as **correct by construction**."},{"content":"You declare that an object and its properties cannot be <ph id=\"ph1\">`null`</ph> when it's constructed.","pos":[9583,9668],"source":" You declare that an object and its properties cannot be `null` when it's constructed."},{"content":"The compiler's flow analysis provides assurance that those properties aren't set to <ph id=\"ph1\">`null`</ph> after construction.","pos":[9669,9779],"source":" The compiler's flow analysis provides assurance that those properties aren't set to `null` after construction."},{"content":"Note that this constructor is called by external code, and that code is <bpt id=\"p1\">**</bpt>nullable oblivious<ept id=\"p1\">**</ept>.","pos":[9780,9875],"source":" Note that this constructor is called by external code, and that code is **nullable oblivious**."},{"content":"The new syntax doesn't provide runtime checking.","pos":[9876,9924]},{"content":"External code might circumvent the compiler's flow analysis.","pos":[9925,9985]},{"content":"Other times, the structure of a class provides different clues to the intent.","pos":[9988,10065]},{"content":"Open the <bpt id=\"p1\">*</bpt>Error.cshtml.cs<ept id=\"p1\">*</ept> file in the <bpt id=\"p2\">*</bpt>Pages<ept id=\"p2\">*</ept> folder.","pos":[10066,10120],"source":" Open the *Error.cshtml.cs* file in the *Pages* folder."},{"content":"The <ph id=\"ph1\">`ErrorViewModel`</ph> contains the following code:","pos":[10121,10170],"source":" The `ErrorViewModel` contains the following code:"},{"content":"Add the <ph id=\"ph1\">`#nullable enable`</ph> directive before the class declaration, and a <ph id=\"ph2\">`#nullable restore`</ph> directive after it.","pos":[10325,10437],"source":"Add the `#nullable enable` directive before the class declaration, and a `#nullable restore` directive after it."},{"content":"You'll get one warning that <ph id=\"ph1\">`RequestId`</ph> is not initialized.","pos":[10438,10497],"source":" You'll get one warning that `RequestId` is not initialized."},{"content":"By looking at the class, you should decide that the <ph id=\"ph1\">`RequestId`</ph> property should be null in some cases.","pos":[10498,10600],"source":" By looking at the class, you should decide that the `RequestId` property should be null in some cases."},{"content":"The existence of the <ph id=\"ph1\">`ShowRequestId`</ph> property indicates that missing values are possible.","pos":[10601,10690],"source":" The existence of the `ShowRequestId` property indicates that missing values are possible."},{"content":"Because <ph id=\"ph1\">`null`</ph> is valid, add the <ph id=\"ph2\">`?`</ph> on the <ph id=\"ph3\">`string`</ph> type to indicate the <ph id=\"ph4\">`RequestId`</ph> property is a <bpt id=\"p1\">*</bpt>nullable reference type<ept id=\"p1\">*</ept>.","pos":[10691,10817],"source":" Because `null` is valid, add the `?` on the `string` type to indicate the `RequestId` property is a *nullable reference type*."},{"content":"The final class looks like the following example:","pos":[10818,10867]},{"content":"Check for the uses of the property, and you see that in the associated page, the property is checked for null before rendering it in markup.","pos":[11021,11161]},{"content":"That's a safe use of a nullable reference type, so you're done with this class.","pos":[11162,11241]},{"pos":[11246,11272],"content":"Fixing nulls causes change","linkify":"Fixing nulls causes change","nodes":[{"content":"Fixing nulls causes change","pos":[0,26]}]},{"content":"Frequently, the fix for one set of warnings creates new warnings in related code.","pos":[11274,11355]},{"content":"Let's see the warnings in action by fixing the <ph id=\"ph1\">`index.cshtml.cs`</ph> class.","pos":[11356,11427],"source":" Let's see the warnings in action by fixing the `index.cshtml.cs` class."},{"content":"Open the <ph id=\"ph1\">`index.cshtml.cs`</ph> file and examine the code.","pos":[11428,11481],"source":" Open the `index.cshtml.cs` file and examine the code."},{"content":"This file contains the code behind for the index page:","pos":[11482,11536]},{"content":"Add the <ph id=\"ph1\">`#nullable enable`</ph> directive and you'll see two warnings.","pos":[11691,11756],"source":"Add the `#nullable enable` directive and you'll see two warnings."},{"content":"Neither the <ph id=\"ph1\">`ErrorText`</ph> property nor the <ph id=\"ph2\">`NewsItems`</ph> property is initialized.","pos":[11757,11834],"source":" Neither the `ErrorText` property nor the `NewsItems` property is initialized."},{"content":"An examination of this class would lead you to believe that both properties should be nullable reference types: Both have private setters.","pos":[11835,11973]},{"content":"Exactly one is assigned in the <ph id=\"ph1\">`OnGet`</ph> method.","pos":[11974,12020],"source":" Exactly one is assigned in the `OnGet` method."},{"content":"Before making changes, look at the consumers of both properties.","pos":[12021,12085]},{"content":"In the page itself, the <ph id=\"ph1\">`ErrorText`</ph> is checked against null before generating markup for any errors.","pos":[12086,12186],"source":" In the page itself, the `ErrorText` is checked against null before generating markup for any errors."},{"content":"The <ph id=\"ph1\">`NewsItems`</ph> collection is checked against <ph id=\"ph2\">`null`</ph>, and checked to ensure the collection has items.","pos":[12187,12288],"source":" The `NewsItems` collection is checked against `null`, and checked to ensure the collection has items."},{"content":"A quick fix would be to make both properties nullable reference types.","pos":[12289,12359]},{"content":"A better fix would be to make the collection a nonnullable reference type, and add items to the existing collection when retrieving news.","pos":[12360,12497]},{"content":"The first fix is to add the <ph id=\"ph1\">`?`</ph> to the <ph id=\"ph2\">`string`</ph> type for the <ph id=\"ph3\">`ErrorText`</ph>:","pos":[12498,12571],"source":" The first fix is to add the `?` to the `string` type for the `ErrorText`:"},{"content":"That change won't ripple through other code, because any access to the <ph id=\"ph1\">`ErrorText`</ph> property was already guarded by null checks.","pos":[12727,12854],"source":"That change won't ripple through other code, because any access to the `ErrorText` property was already guarded by null checks."},{"content":"Next, initialize the <ph id=\"ph1\">`NewsItems`</ph> list and remove the property setter, making it a readonly property:","pos":[12855,12955],"source":" Next, initialize the `NewsItems` list and remove the property setter, making it a readonly property:"},{"content":"That fixed the warning but introduced an error.","pos":[13119,13166]},{"content":"The <ph id=\"ph1\">`NewsItems`</ph> list is now <bpt id=\"p1\">**</bpt>correct by construction<ept id=\"p1\">**</ept>, but the code that sets the list in <ph id=\"ph2\">`OnGet`</ph> must change to match the new API.","pos":[13167,13300],"source":" The `NewsItems` list is now **correct by construction**, but the code that sets the list in `OnGet` must change to match the new API."},{"content":"Instead of an assignment, call <ph id=\"ph1\">`AddRange`</ph> to add the news items to the existing list:","pos":[13301,13386],"source":" Instead of an assignment, call `AddRange` to add the news items to the existing list:"},{"content":"Using <ph id=\"ph1\">`AddRange`</ph> instead of an assignment means that the <ph id=\"ph2\">`GetNews`</ph> method can return an <ph id=\"ph3\">`IEnumerable`</ph> instead of a <ph id=\"ph4\">`List`</ph>.","pos":[13528,13650],"source":"Using `AddRange` instead of an assignment means that the `GetNews` method can return an `IEnumerable` instead of a `List`."},{"content":"That saves one allocation.","pos":[13651,13677]},{"content":"Change the signature of the method, and remove the <ph id=\"ph1\">`ToList`</ph> call, as shown in the following code sample:","pos":[13678,13782],"source":" Change the signature of the method, and remove the `ToList` call, as shown in the following code sample:"},{"content":"Changing the signature breaks one of tests as well.","pos":[13932,13983]},{"content":"Open the <ph id=\"ph1\">`NewsServiceTests.cs`</ph> file in the <ph id=\"ph2\">`Services`</ph> folder of the <ph id=\"ph3\">`SimpleFeedReader.Tests`</ph> project.","pos":[13984,14085],"source":" Open the `NewsServiceTests.cs` file in the `Services` folder of the `SimpleFeedReader.Tests` project."},{"content":"Navigate to the <ph id=\"ph1\">`Returns_News_Stories_Given_Valid_Uri`</ph> test and change the type of the <ph id=\"ph2\">`result`</ph> variable to <ph id=\"ph3\">`IEnumerable&lt;NewsItem&gt;`</ph>.","pos":[14086,14218],"source":" Navigate to the `Returns_News_Stories_Given_Valid_Uri` test and change the type of the `result` variable to `IEnumerable<NewsItem>`."},{"content":"Changing the type means the <ph id=\"ph1\">`Count`</ph> property is no longer available, so replace the <ph id=\"ph2\">`Count`</ph> property in the <ph id=\"ph3\">`Assert`</ph> with a call to <ph id=\"ph4\">`Any()`</ph>:","pos":[14219,14359],"source":" Changing the type means the `Count` property is no longer available, so replace the `Count` property in the `Assert` with a call to `Any()`:"},{"pos":[14522,14610],"content":"You'll need to add a <ph id=\"ph1\">`using System.Linq`</ph> statement to the beginning of the file as well.","source":"You'll need to add a `using System.Linq` statement to the beginning of the file as well."},{"content":"This set of changes highlights special consideration when updating code that includes generic instantiations.","pos":[14612,14721]},{"content":"Both the list and the elements in the list of non-nullable types.","pos":[14722,14787]},{"content":"Either or both could be nullable types.","pos":[14788,14827]},{"content":"All the following declarations are allowed:","pos":[14828,14871]},{"pos":[14875,14946],"content":"<ph id=\"ph1\">`List&lt;NewsStoryViewModel&gt;`</ph>: nonnullable list of nonullable view models.","source":"`List<NewsStoryViewModel>`: nonnullable list of nonullable view models."},{"pos":[14949,15019],"content":"<ph id=\"ph1\">`List&lt;NewsStoryViewModel?&gt;`</ph>: nonnullable list of nullable view models.","source":"`List<NewsStoryViewModel?>`: nonnullable list of nullable view models."},{"pos":[15022,15092],"content":"<ph id=\"ph1\">`List&lt;NewsStoryViewModel&gt;?`</ph>: nullable list of nonnullable view models.","source":"`List<NewsStoryViewModel>?`: nullable list of nonnullable view models."},{"pos":[15095,15163],"content":"<ph id=\"ph1\">`List&lt;NewsStoryViewModel?&gt;?`</ph>: nullable list of nullable view models.","source":"`List<NewsStoryViewModel?>?`: nullable list of nullable view models."},{"pos":[15168,15197],"content":"Interfaces with external code","linkify":"Interfaces with external code","nodes":[{"content":"Interfaces with external code","pos":[0,29]}]},{"content":"You've made changes to the <ph id=\"ph1\">`NewsService`</ph> class, so turn on the <ph id=\"ph2\">`#nullable enable`</ph> annotation for that class.","pos":[15199,15307],"source":"You've made changes to the `NewsService` class, so turn on the `#nullable enable` annotation for that class."},{"content":"This won't generate any new warnings.","pos":[15308,15345]},{"content":"However, careful examination of the class helps to illustrate some of the limitations of the compiler's flow analysis.","pos":[15346,15464]},{"content":"Examine the constructor:","pos":[15465,15489]},{"content":"The <ph id=\"ph1\">`IMapper`</ph> parameter is typed as a nonnullable reference.","pos":[15653,15713],"source":"The `IMapper` parameter is typed as a nonnullable reference."},{"content":"It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the <ph id=\"ph1\">`IMapper`</ph> will never be null.","pos":[15714,15837],"source":" It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the `IMapper` will never be null."},{"content":"The default ASP.NET Core dependency injection (DI) container throws an exception if it can't resolve a necessary service, so the code is correct.","pos":[15838,15983]},{"content":"The compiler can't validate all calls to your public APIs, even if your code is compiled with nullable annotation contexts enabled.","pos":[15984,16115]},{"content":"Furthermore, your libraries may be consumed by projects that have not yet opted into using nullable reference types.","pos":[16116,16232]},{"content":"Validate inputs to public APIs even though you've declared them as nonnullable types.","pos":[16233,16318]},{"pos":[16323,16335],"content":"Get the code","linkify":"Get the code","nodes":[{"content":"Get the code","pos":[0,12]}]},{"content":"You've fixed the warnings you identified in the initial test compile, so now you can turn on the nullable annotation context for both projects.","pos":[16337,16480]},{"content":"Rebuild the projects; the compiler reports no warnings.","pos":[16481,16536]},{"content":"You can get the code for the finished project in the <bpt id=\"p1\">[</bpt>dotnet/samples<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished)</ept> GitHub repository.","pos":[16537,16727],"source":" You can get the code for the finished project in the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished) GitHub repository."},{"content":"The new features that support nullable reference types help you find and fix potential errors in how you handle <ph id=\"ph1\">`null`</ph> values in your code.","pos":[16729,16868],"source":"The new features that support nullable reference types help you find and fix potential errors in how you handle `null` values in your code."},{"content":"Enabling the nullable annotation context allows you to express your design intent: some variables should never be null, other variables may contain null values.","pos":[16869,17029]},{"content":"These features make it easier for you to declare your design intent.","pos":[17030,17098]},{"content":"Similarly, the nullable warning context instructs the compiler to issue warnings when you have violated that intent.","pos":[17099,17215]},{"content":"Those warnings guide you to make updates that make your code more resilient and less likely to throw a <ph id=\"ph1\">`NullReferenceException`</ph> during execution.","pos":[17216,17361],"source":" Those warnings guide you to make updates that make your code more resilient and less likely to throw a `NullReferenceException` during execution."},{"content":"You can control the scope of these contexts so that you can focus on local areas of code to migrate while the remaining codebase is untouched.","pos":[17362,17504]},{"content":"In practice, you can make this migration task a part of regular maintenance to your classes.","pos":[17505,17597]},{"content":"This tutorial demonstrated the process to migrate an application to use nullable reference types.","pos":[17598,17695]},{"content":"You can explore a larger real-world example of this process by examining the PR <bpt id=\"p1\">[</bpt>Jon Skeet<ept id=\"p1\">](https://github.com/jskeet)</ept> made to incorporate nullable reference types into <bpt id=\"p2\">[</bpt>NodaTime<ept id=\"p2\">](https://github.com/nodatime/nodatime/pull/1240/commits)</ept>.","pos":[17696,17932],"source":" You can explore a larger real-world example of this process by examining the PR [Jon Skeet](https://github.com/jskeet) made to incorporate nullable reference types into [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits)."}]}