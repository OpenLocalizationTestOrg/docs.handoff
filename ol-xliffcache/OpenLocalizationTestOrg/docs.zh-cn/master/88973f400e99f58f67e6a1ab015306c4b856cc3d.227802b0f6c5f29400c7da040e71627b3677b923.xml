{"content":"---\ntitle: \"Order Preservation in PLINQ | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"PLINQ queries, order preservation\"\nms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca\ncaps.latest.revision: 19\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Order Preservation in PLINQ\nIn PLINQ, the goal is to maximize performance while maintaining correctness. A query should run as fast as possible but still produce the correct results. In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive. Therefore, by default, PLINQ does not preserve the order of the source sequence. In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering.  \n  \n To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence. You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method. With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential. For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).  \n  \n The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.  \n  \n [!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]\n [!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]  \n  \n This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition. PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks. If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order. Also, a partition may yield a subset of its results before it continues to process the remaining elements. The resulting order may be different every time. Your application cannot control this because it depends on how the operating system schedules the threads.  \n  \n The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence. This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition.  \n  \n [!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]\n [!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]  \n  \n However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent. Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it. When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off. The following example achieves this by composing two queries.  \n  \n [!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]\n [!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]  \n  \n Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query. In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.  \n  \n## Query Operators and Ordering  \n The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:  \n  \n-   <xref:System.Linq.ParallelEnumerable.OrderBy%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.ThenBy%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>  \n  \n The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:  \n  \n-   <xref:System.Linq.ParallelEnumerable.Reverse%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.TakeWhile%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.SkipWhile%2A>  \n  \n-   <xref:System.Linq.ParallelEnumerable.Zip%2A>  \n  \n Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered. The following table lists these operators.  \n  \n|Operator|Result when the source sequence is ordered|Result when the source sequence is unordered|  \n|--------------|------------------------------------------------|--------------------------------------------------|  \n|<xref:System.Linq.ParallelEnumerable.Aggregate%2A>|Nondeterministic output for nonassociative or noncommutative operations|Nondeterministic output for nonassociative or noncommutative operations|  \n|<xref:System.Linq.ParallelEnumerable.All%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Any%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Average%2A>|Nondeterministic output for nonassociative or noncommutative operations|Nondeterministic output for nonassociative or noncommutative operations|  \n|<xref:System.Linq.ParallelEnumerable.Cast%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Concat%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Count%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Distinct%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.ElementAt%2A>|Return specified element|Arbitrary element|  \n|<xref:System.Linq.ParallelEnumerable.ElementAtOrDefault%2A>|Return specified element|Arbitrary element|  \n|<xref:System.Linq.ParallelEnumerable.Except%2A>|Unordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.First%2A>|Return specified element|Arbitrary element|  \n|<xref:System.Linq.ParallelEnumerable.FirstOrDefault%2A>|Return specified element|Arbitrary element|  \n|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|Executes nondeterministically in parallel|Executes nondeterministically in parallel|  \n|<xref:System.Linq.ParallelEnumerable.GroupBy%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.GroupJoin%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Intersect%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Join%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Last%2A>|Return specified element|Arbitrary element|  \n|<xref:System.Linq.ParallelEnumerable.LastOrDefault%2A>|Return specified element|Arbitrary element|  \n|<xref:System.Linq.ParallelEnumerable.LongCount%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Min%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.OrderBy%2A>|Reorders the sequence|Starts new ordered section|  \n|<xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>|Reorders the sequence|Starts new ordered section|  \n|<xref:System.Linq.ParallelEnumerable.Range%2A>|Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Repeat%2A>|Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|Reverses|Does nothing|  \n|<xref:System.Linq.ParallelEnumerable.Select%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)|Ordered results|Unordered results.|  \n|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|Ordered results.|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)|Ordered results.|Unordered results.|  \n|<xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>|Ordered comparison|Unordered comparison|  \n|<xref:System.Linq.ParallelEnumerable.Single%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.SingleOrDefault%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.Skip%2A>|Skips first *n* elements|Skips any *n* elements|  \n|<xref:System.Linq.ParallelEnumerable.SkipWhile%2A>|Ordered results.|Nondeterministic. Performs SkipWhile on the current arbitrary order|  \n|<xref:System.Linq.ParallelEnumerable.Sum%2A>|Nondeterministic output for nonassociative or noncommutative operations|Nondeterministic output for nonassociative or noncommutative operations|  \n|<xref:System.Linq.ParallelEnumerable.Take%2A>|Takes first `n` elements|Takes any `n` elements|  \n|<xref:System.Linq.ParallelEnumerable.TakeWhile%2A>|Ordered results|Nondeterministic. Performs TakeWhile on the current arbitrary order|  \n|<xref:System.Linq.ParallelEnumerable.ThenBy%2A>|Supplements `OrderBy`|Supplements `OrderBy`|  \n|<xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>|Supplements `OrderBy`|Supplements `OrderBy`|  \n|<xref:System.Linq.ParallelEnumerable.ToArray%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.ToDictionary%2A>|Not applicable|Not applicable|  \n|<xref:System.Linq.ParallelEnumerable.ToList%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.ToLookup%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Union%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Where%2A>|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)|Ordered results|Unordered results|  \n|<xref:System.Linq.ParallelEnumerable.Zip%2A>|Ordered results|Unordered results|  \n  \n Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them. In some cases, an unordered query may retain the ordering of the source sequence. For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.  \n  \n## See Also  \n [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)   \n [Parallel Programming](../../../docs/standard/parallel-programming/index.md)","nodes":[{"pos":[4,403],"embed":true,"restype":"x-metadata","content":"title: \"Order Preservation in PLINQ | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"PLINQ queries, order preservation\"\nms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca\ncaps.latest.revision: 19\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","nodes":[{"content":"Order Preservation in PLINQ | Microsoft Docs","nodes":[{"pos":[0,44],"content":"Order Preservation in PLINQ | Microsoft Docs","nodes":[{"content":"Order Preservation in PLINQ | Microsoft Docs","pos":[0,44]}]}],"path":["title"]}],"yml":true},{"pos":[410,437],"content":"Order Preservation in PLINQ","linkify":"Order Preservation in PLINQ","nodes":[{"content":"Order Preservation in PLINQ","pos":[0,27]}]},{"content":"In PLINQ, the goal is to maximize performance while maintaining correctness.","pos":[438,514]},{"content":"A query should run as fast as possible but still produce the correct results.","pos":[515,592]},{"content":"In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive.","pos":[593,730]},{"content":"Therefore, by default, PLINQ does not preserve the order of the source sequence.","pos":[731,811]},{"content":"In this regard, PLINQ resembles <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)]</ph>, but is unlike LINQ to Objects, which does preserve ordering.","pos":[812,964],"source":" In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering."},{"content":"To override the default behavior, you can turn on order-preservation by using the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> operator on the source sequence.","pos":[971,1136],"source":"To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence."},{"content":"You can then turn off order preservation later in the query by using the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsUnordered%2A&gt;</ph> method.","pos":[1137,1270],"source":" You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method."},{"content":"With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential.","pos":[1271,1410]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Understanding Speedup in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)</ept>.","pos":[1411,1549],"source":" For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)."},{"content":"The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.","pos":[1556,1717]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PLINQ#8<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)</ept><ept id=\"p1\">]</ept>","pos":[1724,1825],"source":"[!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>PLINQ#8<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)</ept><ept id=\"p1\">]</ept>","pos":[1827,1926],"source":"[!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]"},{"content":"This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition.","pos":[1933,2102]},{"content":"PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks.","pos":[2103,2221]},{"content":"If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order.","pos":[2222,2362]},{"content":"Also, a partition may yield a subset of its results before it continues to process the remaining elements.","pos":[2363,2469]},{"content":"The resulting order may be different every time.","pos":[2470,2518]},{"content":"Your application cannot control this because it depends on how the operating system schedules the threads.","pos":[2519,2625]},{"content":"The following example overrides the default behavior by using the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> operator on the source sequence.","pos":[2632,2781],"source":"The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence."},{"content":"This ensures that the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.Take%2A&gt;</ph> method returns the first 1000 cities in the source sequence that meet the condition.","pos":[2782,2934],"source":" This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PLINQ#9<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)</ept><ept id=\"p1\">]</ept>","pos":[2941,3042],"source":"[!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>PLINQ#9<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)</ept><ept id=\"p1\">]</ept>","pos":[3044,3143],"source":"[!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]"},{"content":"However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent.","pos":[3150,3360]},{"content":"Therefore, we recommend that you use <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> only when it is required, and only for those parts of the query that require it.","pos":[3361,3529],"source":" Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it."},{"content":"When order preservation is no longer required, use <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsUnordered%2A&gt;</ph> to turn it off.","pos":[3530,3649],"source":" When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off."},{"content":"The following example achieves this by composing two queries.","pos":[3650,3711]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PLINQ#6<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)</ept><ept id=\"p1\">]</ept>","pos":[3718,3819],"source":"[!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>PLINQ#6<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)</ept><ept id=\"p1\">]</ept>","pos":[3821,3920],"source":"[!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]"},{"content":"Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query.","pos":[3927,4043]},{"content":"In other words, operators such as <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.OrderBy%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.ParallelEnumerable.ThenBy%2A&gt;</ph> are treated as if they were followed by a call to <ph id=\"ph3\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph>.","pos":[4044,4280],"source":" In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>."},{"pos":[4289,4317],"content":"Query Operators and Ordering","linkify":"Query Operators and Ordering","nodes":[{"content":"Query Operators and Ordering","pos":[0,28]}]},{"content":"The following query operators introduce order preservation into all subsequent operations in a query, or until <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsUnordered%2A&gt;</ph> is called:","pos":[4321,4495],"source":"The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:"},{"content":"The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:","pos":[4752,4866]},{"content":"Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered.","pos":[5169,5283]},{"content":"The following table lists these operators.","pos":[5284,5326]},{"content":"Operator","pos":[5333,5341]},{"content":"Result when the source sequence is ordered","pos":[5342,5384]},{"content":"Result when the source sequence is unordered","pos":[5385,5429]},{"content":"Nondeterministic output for nonassociative or noncommutative operations","pos":[5604,5675]},{"content":"Nondeterministic output for nonassociative or noncommutative operations","pos":[5676,5747]},{"content":"Not applicable","pos":[5797,5811]},{"content":"Not applicable","pos":[5812,5826]},{"content":"Not applicable","pos":[5876,5890]},{"content":"Not applicable","pos":[5891,5905]},{"content":"Not applicable","pos":[5964,5978]},{"content":"Not applicable","pos":[5979,5993]},{"content":"Nondeterministic output for nonassociative or noncommutative operations","pos":[6047,6118]},{"content":"Nondeterministic output for nonassociative or noncommutative operations","pos":[6119,6190]},{"content":"Ordered results","pos":[6241,6256]},{"content":"Unordered results","pos":[6257,6274]},{"content":"Ordered results","pos":[6327,6342]},{"content":"Unordered results","pos":[6343,6360]},{"content":"Not applicable","pos":[6412,6426]},{"content":"Not applicable","pos":[6427,6441]},{"content":"Not applicable","pos":[6502,6516]},{"content":"Not applicable","pos":[6517,6531]},{"content":"Ordered results","pos":[6586,6601]},{"content":"Unordered results","pos":[6602,6619]},{"content":"Return specified element","pos":[6675,6699]},{"content":"Arbitrary element","pos":[6700,6717]},{"content":"Return specified element","pos":[6782,6806]},{"content":"Arbitrary element","pos":[6807,6824]},{"content":"Unordered results","pos":[6877,6894]},{"content":"Unordered results","pos":[6895,6912]},{"content":"Return specified element","pos":[6964,6988]},{"content":"Arbitrary element","pos":[6989,7006]},{"content":"Return specified element","pos":[7067,7091]},{"content":"Arbitrary element","pos":[7092,7109]},{"content":"Executes nondeterministically in parallel","pos":[7162,7203]},{"content":"Executes nondeterministically in parallel","pos":[7204,7245]},{"content":"Ordered results","pos":[7299,7314]},{"content":"Unordered results","pos":[7315,7332]},{"content":"Ordered results","pos":[7388,7403]},{"content":"Unordered results","pos":[7404,7421]},{"content":"Ordered results","pos":[7477,7492]},{"content":"Unordered results","pos":[7493,7510]},{"content":"Ordered results","pos":[7561,7576]},{"content":"Unordered results","pos":[7577,7594]},{"content":"Return specified element","pos":[7645,7669]},{"content":"Arbitrary element","pos":[7670,7687]},{"content":"Return specified element","pos":[7747,7771]},{"content":"Arbitrary element","pos":[7772,7789]},{"content":"Not applicable","pos":[7845,7859]},{"content":"Not applicable","pos":[7860,7874]},{"content":"Not applicable","pos":[7924,7938]},{"content":"Not applicable","pos":[7939,7953]},{"content":"Reorders the sequence","pos":[8007,8028]},{"content":"Starts new ordered section","pos":[8029,8055]},{"content":"Reorders the sequence","pos":[8119,8140]},{"content":"Starts new ordered section","pos":[8141,8167]},{"content":"Not applicable (same default as <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsParallel%2A&gt;</ph> )","pos":[8219,8304],"source":"Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )"},{"content":"Not applicable","pos":[8305,8319]},{"content":"Not applicable (same default as <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsParallel%2A&gt;</ph>)","pos":[8372,8456],"source":"Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)"},{"content":"Not applicable","pos":[8457,8471]},{"content":"Reverses","pos":[8525,8533]},{"content":"Does nothing","pos":[8534,8546]},{"content":"Ordered results","pos":[8599,8614]},{"content":"Unordered results","pos":[8615,8632]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.Select%2A&gt;</ph> (indexed)","pos":[8637,8694],"source":"<xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)"},{"content":"Ordered results","pos":[8695,8710]},{"content":"Unordered results.","pos":[8711,8729]},{"content":"Ordered results.","pos":[8786,8802]},{"content":"Unordered results","pos":[8803,8820]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.SelectMany%2A&gt;</ph> (indexed)","pos":[8825,8886],"source":"<xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)"},{"content":"Ordered results.","pos":[8887,8903]},{"content":"Unordered results.","pos":[8904,8922]},{"content":"Ordered comparison","pos":[8982,9000]},{"content":"Unordered comparison","pos":[9001,9021]},{"content":"Not applicable","pos":[9074,9088]},{"content":"Not applicable","pos":[9089,9103]},{"content":"Not applicable","pos":[9165,9179]},{"content":"Not applicable","pos":[9180,9194]},{"pos":[9245,9269],"content":"Skips first <bpt id=\"p1\">*</bpt><ph id=\"ph1\">n</ph><ept id=\"p1\">*</ept> elements","source":"Skips first *n* elements"},{"pos":[9270,9292],"content":"Skips any <bpt id=\"p1\">*</bpt><ph id=\"ph1\">n</ph><ept id=\"p1\">*</ept> elements","source":"Skips any *n* elements"},{"content":"Ordered results.","pos":[9348,9364]},{"content":"Nondeterministic.","pos":[9365,9382]},{"content":"Performs SkipWhile on the current arbitrary order","pos":[9383,9432]},{"content":"Nondeterministic output for nonassociative or noncommutative operations","pos":[9482,9553]},{"content":"Nondeterministic output for nonassociative or noncommutative operations","pos":[9554,9625]},{"pos":[9676,9700],"content":"Takes first <ph id=\"ph1\">`n`</ph> elements","source":"Takes first `n` elements"},{"pos":[9701,9723],"content":"Takes any <ph id=\"ph1\">`n`</ph> elements","source":"Takes any `n` elements"},{"content":"Ordered results","pos":[9779,9794]},{"content":"Nondeterministic.","pos":[9795,9812]},{"content":"Performs TakeWhile on the current arbitrary order","pos":[9813,9862]},{"pos":[9915,9936],"content":"Supplements <ph id=\"ph1\">`OrderBy`</ph>","source":"Supplements `OrderBy`"},{"pos":[9937,9958],"content":"Supplements <ph id=\"ph1\">`OrderBy`</ph>","source":"Supplements `OrderBy`"},{"pos":[10021,10042],"content":"Supplements <ph id=\"ph1\">`OrderBy`</ph>","source":"Supplements `OrderBy`"},{"pos":[10043,10064],"content":"Supplements <ph id=\"ph1\">`OrderBy`</ph>","source":"Supplements `OrderBy`"},{"content":"Ordered results","pos":[10118,10133]},{"content":"Unordered results","pos":[10134,10151]},{"content":"Not applicable","pos":[10210,10224]},{"content":"Not applicable","pos":[10225,10239]},{"content":"Ordered results","pos":[10292,10307]},{"content":"Unordered results","pos":[10308,10325]},{"content":"Ordered results","pos":[10380,10395]},{"content":"Unordered results","pos":[10396,10413]},{"content":"Ordered results","pos":[10465,10480]},{"content":"Unordered results","pos":[10481,10498]},{"content":"Ordered results","pos":[10550,10565]},{"content":"Unordered results","pos":[10566,10583]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.Where%2A&gt;</ph> (indexed)","pos":[10588,10644],"source":"<xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)"},{"content":"Ordered results","pos":[10645,10660]},{"content":"Unordered results","pos":[10661,10678]},{"content":"Ordered results","pos":[10728,10743]},{"content":"Unordered results","pos":[10744,10761]},{"content":"Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them.","pos":[10769,10881]},{"content":"In some cases, an unordered query may retain the ordering of the source sequence.","pos":[10882,10963]},{"content":"For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.","pos":[10964,11185]},{"pos":[11194,11202],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Parallel LINQ (PLINQ)<ept id=\"p1\">](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)</ept><ph id=\"ph1\"> </ph>","pos":[11206,11298],"source":"[Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md) "},{"content":"<bpt id=\"p1\">[</bpt>Parallel Programming<ept id=\"p1\">](../../../docs/standard/parallel-programming/index.md)</ept>","pos":[11302,11378],"source":"[Parallel Programming](../../../docs/standard/parallel-programming/index.md)"}]}