{"content":"---\ntitle: \"Parameter Design\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"member design guidelines [.NET Framework], parameters\"\n  - \"members [.NET Framework], parameters\"\n  - \"names [.NET Framework], parameters\"\n  - \"parameters, design guidelines\"\n  - \"reserved parameters\"\nms.assetid: 3f33bf46-4a7b-43b3-bb78-1ffebe0dcfa6\nauthor: \"KrzysztofCwalina\"\n---\n# Parameter Design\nThis section provides broad guidelines on parameter design, including sections with guidelines for checking arguments. In addition, you should refer to the guidelines described in [Naming Parameters](../../../docs/standard/design-guidelines/naming-parameters.md).  \n  \n **✓ DO** use the least derived parameter type that provides the functionality required by the member.  \n  \n For example, suppose you want to design a method that enumerates a collection and prints each item to the console. Such a method should take <xref:System.Collections.IEnumerable> as the parameter, not <xref:System.Collections.ArrayList> or <xref:System.Collections.IList>, for example.  \n  \n **X DO NOT** use reserved parameters.  \n  \n If more input to a member is needed in some future version, a new overload can be added.  \n  \n **X DO NOT** have publicly exposed methods that take pointers, arrays of pointers, or multidimensional arrays as parameters.  \n  \n Pointers and multidimensional arrays are relatively difficult to use properly. In almost all cases, APIs can be redesigned to avoid taking these types as parameters.  \n  \n **✓ DO** place all `out` parameters following all of the by-value and `ref` parameters (excluding parameter arrays), even if it results in an inconsistency in parameter ordering between overloads (see [Member Overloading](../../../docs/standard/design-guidelines/member-overloading.md)).  \n  \n The `out` parameters can be seen as extra return values, and grouping them together makes the method signature easier to understand.  \n  \n **✓ DO** be consistent in naming parameters when overriding members or implementing interface members.  \n  \n This better communicates the relationship between the methods.  \n  \n### Choosing Between Enum and Boolean Parameters  \n **✓ DO** use enums if a member would otherwise have two or more Boolean parameters.  \n  \n **X DO NOT** use Booleans unless you are absolutely sure there will never be a need for more than two values.  \n  \n Enums give you some room for future addition of values, but you should be aware of all the implications of adding values to enums, which are described in [Enum Design](../../../docs/standard/design-guidelines/enum.md).  \n  \n **✓ CONSIDER** using Booleans for constructor parameters that are truly two-state values and are simply used to initialize Boolean properties.  \n  \n### Validating Arguments  \n **✓ DO** validate arguments passed to public, protected, or explicitly implemented members. Throw <xref:System.ArgumentException?displayProperty=nameWithType>, or one of its subclasses, if the validation fails.  \n  \n Note that the actual validation does not necessarily have to happen in the public or protected member itself. It could happen at a lower level in some private or internal routine. The main point is that the entire surface area that is exposed to the end users checks the arguments.  \n  \n **✓ DO** throw <xref:System.ArgumentNullException> if a null argument is passed and the member does not support null arguments.  \n  \n **✓ DO** validate enum parameters.  \n  \n Do not assume enum arguments will be in the range defined by the enum. The CLR allows casting any integer value into an enum value even if the value is not defined in the enum.  \n  \n **X DO NOT** use <xref:System.Enum.IsDefined%2A?displayProperty=nameWithType> for enum range checks.  \n  \n **✓ DO** be aware that mutable arguments might have changed after they were validated.  \n  \n If the member is security sensitive, you are encouraged to make a copy and then validate and process the argument.  \n  \n### Parameter Passing  \n From the perspective of a framework designer, there are three main groups of parameters: by-value parameters, `ref` parameters, and `out` parameters.  \n  \n When an argument is passed through a by-value parameter, the member receives a copy of the actual argument passed in. If the argument is a value type, a copy of the argument is put on the stack. If the argument is a reference type, a copy of the reference is put on the stack. Most popular CLR languages, such as C#, VB.NET, and C++, default to passing parameters by value.  \n  \n When an argument is passed through a `ref` parameter, the member receives a reference to the actual argument passed in. If the argument is a value type, a reference to the argument is put on the stack. If the argument is a reference type, a reference to the reference is put on the stack. `Ref` parameters can be used to allow the member to modify arguments passed by the caller.  \n  \n `Out` parameters are similar to `ref` parameters, with some small differences. The parameter is initially considered unassigned and cannot be read in the member body before it is assigned some value. Also, the parameter has to be assigned some value before the member returns.  \n  \n **X AVOID** using `out` or `ref` parameters.  \n  \n Using `out` or `ref` parameters requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between `out` and `ref` parameters is not widely understood. Framework architects designing for a general audience should not expect users to master working with `out` or `ref` parameters.  \n  \n **X DO NOT** pass reference types by reference.  \n  \n There are some limited exceptions to the rule, such as a method that can be used to swap references.  \n  \n### Members with Variable Number of Parameters  \n Members that can take a variable number of arguments are expressed by providing an array parameter. For example, <xref:System.String> provides the following method:  \n  \n```  \npublic class String {  \n    public static string Format(string format, object[] parameters);  \n}  \n```  \n  \n A user can then call the <xref:System.String.Format%2A?displayProperty=nameWithType> method, as follows:  \n  \n `String.Format(\"File {0} not found in {1}\",new object[]{filename,directory});`  \n  \n Adding the C# params keyword to an array parameter changes the parameter to a so-called params array parameter and provides a shortcut to creating a temporary array.  \n  \n```  \npublic class String {  \n    public static string Format(string format, params object[] parameters);  \n}  \n```  \n  \n Doing this allows the user to call the method by passing the array elements directly in the argument list.  \n  \n `String.Format(\"File {0} not found in {1}\",filename,directory);`  \n  \n Note that the params keyword can be added only to the last parameter in the parameter list.  \n  \n **✓ CONSIDER** adding the params keyword to array parameters if you expect the end users to pass arrays with a small number of elements. If it’s expected that lots of elements will be passed in common scenarios, users will probably not pass these elements inline anyway, and so the params keyword is not necessary.  \n  \n **X AVOID** using params arrays if the caller would almost always have the input already in an array.  \n  \n For example, members with byte array parameters would almost never be called by passing individual bytes. For this reason, byte array parameters in the .NET Framework do not use the params keyword.  \n  \n **X DO NOT** use params arrays if the array is modified by the member taking the params array parameter.  \n  \n Because of the fact that many compilers turn the arguments to the member into a temporary array at the call site, the array might be a temporary object, and therefore any modifications to the array will be lost.  \n  \n **✓ CONSIDER** using the params keyword in a simple overload, even if a more complex overload could not use it.  \n  \n Ask yourself if users would value having the params array in one overload even if it wasn’t in all overloads.  \n  \n **✓ DO** try to order parameters to make it possible to use the params keyword.  \n  \n **✓ CONSIDER** providing special overloads and code paths for calls with a small number of arguments in extremely performance-sensitive APIs.  \n  \n This makes it possible to avoid creating array objects when the API is called with a small number of arguments. Form the names of the parameters by taking a singular form of the array parameter and adding a numeric suffix.  \n  \n You should only do this if you are going to special-case the entire code path, not just create an array and call the more general method.  \n  \n **✓ DO** be aware that null could be passed as a params array argument.  \n  \n You should validate that the array is not null before processing.  \n  \n **X DO NOT** use the `varargs` methods, otherwise known as the ellipsis.  \n  \n Some CLR languages, such as C++, support an alternative convention for passing variable parameter lists called `varargs` methods. The convention should not be used in frameworks, because it is not CLS compliant.  \n  \n### Pointer Parameters  \n In general, pointers should not appear in the public surface area of a well-designed managed code framework. Most of the time, pointers should be encapsulated. However, in some cases pointers are required for interoperability reasons, and using pointers in such cases is appropriate.  \n  \n **✓ DO** provide an alternative for any member that takes a pointer argument, because pointers are not CLS-compliant.  \n  \n **X AVOID** doing expensive argument checking of pointer arguments.  \n  \n **✓ DO** follow common pointer-related conventions when designing members with pointers.  \n  \n For example, there is no need to pass the start index, because simple pointer arithmetic can be used to accomplish the same result.  \n  \n *Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*  \n  \n *Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*  \n  \n## See also\n\n- [Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)\n- [Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)\n","nodes":[{"pos":[4,386],"embed":true,"restype":"x-metadata","content":"title: \"Parameter Design\"\nms.date: \"10/22/2008\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"member design guidelines [.NET Framework], parameters\"\n  - \"members [.NET Framework], parameters\"\n  - \"names [.NET Framework], parameters\"\n  - \"parameters, design guidelines\"\n  - \"reserved parameters\"\nms.assetid: 3f33bf46-4a7b-43b3-bb78-1ffebe0dcfa6\nauthor: \"KrzysztofCwalina\"","nodes":[{"content":"Parameter Design","nodes":[{"pos":[0,16],"content":"Parameter Design","nodes":[{"content":"Parameter Design","pos":[0,16]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[393,409],"content":"Parameter Design","linkify":"Parameter Design","nodes":[{"content":"Parameter Design","pos":[0,16]}]},{"content":"This section provides broad guidelines on parameter design, including sections with guidelines for checking arguments.","pos":[410,528]},{"content":"In addition, you should refer to the guidelines described in <bpt id=\"p1\">[</bpt>Naming Parameters<ept id=\"p1\">](../../../docs/standard/design-guidelines/naming-parameters.md)</ept>.","pos":[529,673],"source":" In addition, you should refer to the guidelines described in [Naming Parameters](../../../docs/standard/design-guidelines/naming-parameters.md)."},{"pos":[680,781],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use the least derived parameter type that provides the functionality required by the member.","source":"**✓ DO** use the least derived parameter type that provides the functionality required by the member."},{"content":"For example, suppose you want to design a method that enumerates a collection and prints each item to the console.","pos":[788,902]},{"content":"Such a method should take <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph> as the parameter, not <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Collections.IList&gt;</ph>, for example.","pos":[903,1073],"source":" Such a method should take <xref:System.Collections.IEnumerable> as the parameter, not <xref:System.Collections.ArrayList> or <xref:System.Collections.IList>, for example."},{"pos":[1080,1117],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use reserved parameters.","source":"**X DO NOT** use reserved parameters."},{"content":"If more input to a member is needed in some future version, a new overload can be added.","pos":[1124,1212]},{"pos":[1219,1343],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> have publicly exposed methods that take pointers, arrays of pointers, or multidimensional arrays as parameters.","source":"**X DO NOT** have publicly exposed methods that take pointers, arrays of pointers, or multidimensional arrays as parameters."},{"content":"Pointers and multidimensional arrays are relatively difficult to use properly.","pos":[1350,1428]},{"content":"In almost all cases, APIs can be redesigned to avoid taking these types as parameters.","pos":[1429,1515]},{"pos":[1522,1809],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> place all <ph id=\"ph1\">`out`</ph> parameters following all of the by-value and <ph id=\"ph2\">`ref`</ph> parameters (excluding parameter arrays), even if it results in an inconsistency in parameter ordering between overloads (see <bpt id=\"p2\">[</bpt>Member Overloading<ept id=\"p2\">](../../../docs/standard/design-guidelines/member-overloading.md)</ept>).","source":"**✓ DO** place all `out` parameters following all of the by-value and `ref` parameters (excluding parameter arrays), even if it results in an inconsistency in parameter ordering between overloads (see [Member Overloading](../../../docs/standard/design-guidelines/member-overloading.md))."},{"pos":[1816,1948],"content":"The <ph id=\"ph1\">`out`</ph> parameters can be seen as extra return values, and grouping them together makes the method signature easier to understand.","source":"The `out` parameters can be seen as extra return values, and grouping them together makes the method signature easier to understand."},{"pos":[1955,2057],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> be consistent in naming parameters when overriding members or implementing interface members.","source":"**✓ DO** be consistent in naming parameters when overriding members or implementing interface members."},{"content":"This better communicates the relationship between the methods.","pos":[2064,2126]},{"pos":[2136,2180],"content":"Choosing Between Enum and Boolean Parameters","linkify":"Choosing Between Enum and Boolean Parameters","nodes":[{"content":"Choosing Between Enum and Boolean Parameters","pos":[0,44]}]},{"pos":[2184,2267],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> use enums if a member would otherwise have two or more Boolean parameters.","source":"**✓ DO** use enums if a member would otherwise have two or more Boolean parameters."},{"pos":[2274,2383],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use Booleans unless you are absolutely sure there will never be a need for more than two values.","source":"**X DO NOT** use Booleans unless you are absolutely sure there will never be a need for more than two values."},{"pos":[2390,2608],"content":"Enums give you some room for future addition of values, but you should be aware of all the implications of adding values to enums, which are described in <bpt id=\"p1\">[</bpt>Enum Design<ept id=\"p1\">](../../../docs/standard/design-guidelines/enum.md)</ept>.","source":"Enums give you some room for future addition of values, but you should be aware of all the implications of adding values to enums, which are described in [Enum Design](../../../docs/standard/design-guidelines/enum.md)."},{"pos":[2615,2757],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using Booleans for constructor parameters that are truly two-state values and are simply used to initialize Boolean properties.","source":"**✓ CONSIDER** using Booleans for constructor parameters that are truly two-state values and are simply used to initialize Boolean properties."},{"pos":[2767,2787],"content":"Validating Arguments","linkify":"Validating Arguments","nodes":[{"content":"Validating Arguments","pos":[0,20]}]},{"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> validate arguments passed to public, protected, or explicitly implemented members.","pos":[2791,2882],"source":"**✓ DO** validate arguments passed to public, protected, or explicitly implemented members."},{"content":"Throw <ph id=\"ph1\">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph>, or one of its subclasses, if the validation fails.","pos":[2883,3001],"source":" Throw <xref:System.ArgumentException?displayProperty=nameWithType>, or one of its subclasses, if the validation fails."},{"content":"Note that the actual validation does not necessarily have to happen in the public or protected member itself.","pos":[3008,3117]},{"content":"It could happen at a lower level in some private or internal routine.","pos":[3118,3187]},{"content":"The main point is that the entire surface area that is exposed to the end users checks the arguments.","pos":[3188,3289]},{"pos":[3296,3423],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> throw <ph id=\"ph1\">&lt;xref:System.ArgumentNullException&gt;</ph> if a null argument is passed and the member does not support null arguments.","source":"**✓ DO** throw <xref:System.ArgumentNullException> if a null argument is passed and the member does not support null arguments."},{"pos":[3430,3464],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> validate enum parameters.","source":"**✓ DO** validate enum parameters."},{"content":"Do not assume enum arguments will be in the range defined by the enum.","pos":[3471,3541]},{"content":"The CLR allows casting any integer value into an enum value even if the value is not defined in the enum.","pos":[3542,3647]},{"pos":[3654,3754],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use <ph id=\"ph1\">&lt;xref:System.Enum.IsDefined%2A?displayProperty=nameWithType&gt;</ph> for enum range checks.","source":"**X DO NOT** use <xref:System.Enum.IsDefined%2A?displayProperty=nameWithType> for enum range checks."},{"pos":[3761,3847],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> be aware that mutable arguments might have changed after they were validated.","source":"**✓ DO** be aware that mutable arguments might have changed after they were validated."},{"content":"If the member is security sensitive, you are encouraged to make a copy and then validate and process the argument.","pos":[3854,3968]},{"pos":[3978,3995],"content":"Parameter Passing","linkify":"Parameter Passing","nodes":[{"content":"Parameter Passing","pos":[0,17]}]},{"pos":[3999,4148],"content":"From the perspective of a framework designer, there are three main groups of parameters: by-value parameters, <ph id=\"ph1\">`ref`</ph> parameters, and <ph id=\"ph2\">`out`</ph> parameters.","source":"From the perspective of a framework designer, there are three main groups of parameters: by-value parameters, `ref` parameters, and `out` parameters."},{"content":"When an argument is passed through a by-value parameter, the member receives a copy of the actual argument passed in.","pos":[4155,4272]},{"content":"If the argument is a value type, a copy of the argument is put on the stack.","pos":[4273,4349]},{"content":"If the argument is a reference type, a copy of the reference is put on the stack.","pos":[4350,4431]},{"content":"Most popular CLR languages, such as C#, VB.NET, and C++, default to passing parameters by value.","pos":[4432,4528]},{"content":"When an argument is passed through a <ph id=\"ph1\">`ref`</ph> parameter, the member receives a reference to the actual argument passed in.","pos":[4535,4654],"source":"When an argument is passed through a `ref` parameter, the member receives a reference to the actual argument passed in."},{"content":"If the argument is a value type, a reference to the argument is put on the stack.","pos":[4655,4736]},{"content":"If the argument is a reference type, a reference to the reference is put on the stack.","pos":[4737,4823]},{"content":"<ph id=\"ph1\">`Ref`</ph> parameters can be used to allow the member to modify arguments passed by the caller.","pos":[4824,4914],"source":"`Ref` parameters can be used to allow the member to modify arguments passed by the caller."},{"content":"<ph id=\"ph1\">`Out`</ph> parameters are similar to <ph id=\"ph2\">`ref`</ph> parameters, with some small differences.","pos":[4921,4999],"source":"`Out` parameters are similar to `ref` parameters, with some small differences."},{"content":"The parameter is initially considered unassigned and cannot be read in the member body before it is assigned some value.","pos":[5000,5120]},{"content":"Also, the parameter has to be assigned some value before the member returns.","pos":[5121,5197]},{"pos":[5204,5248],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> using <ph id=\"ph1\">`out`</ph> or <ph id=\"ph2\">`ref`</ph> parameters.","source":"**X AVOID** using `out` or `ref` parameters."},{"content":"Using <ph id=\"ph1\">`out`</ph> or <ph id=\"ph2\">`ref`</ph> parameters requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values.","pos":[5255,5429],"source":"Using `out` or `ref` parameters requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values."},{"content":"Also, the difference between <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> parameters is not widely understood.","pos":[5430,5511],"source":" Also, the difference between `out` and `ref` parameters is not widely understood."},{"content":"Framework architects designing for a general audience should not expect users to master working with <ph id=\"ph1\">`out`</ph> or <ph id=\"ph2\">`ref`</ph> parameters.","pos":[5512,5639],"source":" Framework architects designing for a general audience should not expect users to master working with `out` or `ref` parameters."},{"pos":[5646,5693],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> pass reference types by reference.","source":"**X DO NOT** pass reference types by reference."},{"content":"There are some limited exceptions to the rule, such as a method that can be used to swap references.","pos":[5700,5800]},{"pos":[5810,5852],"content":"Members with Variable Number of Parameters","linkify":"Members with Variable Number of Parameters","nodes":[{"content":"Members with Variable Number of Parameters","pos":[0,42]}]},{"content":"Members that can take a variable number of arguments are expressed by providing an array parameter.","pos":[5856,5955]},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> provides the following method:","pos":[5956,6020],"source":" For example, <xref:System.String> provides the following method:"},{"pos":[6141,6245],"content":"A user can then call the <ph id=\"ph1\">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method, as follows:","source":"A user can then call the <xref:System.String.Format%2A?displayProperty=nameWithType> method, as follows:"},{"content":"Adding the C# params keyword to an array parameter changes the parameter to a so-called params array parameter and provides a shortcut to creating a temporary array.","pos":[6337,6502]},{"content":"Doing this allows the user to call the method by passing the array elements directly in the argument list.","pos":[6630,6736]},{"content":"Note that the params keyword can be added only to the last parameter in the parameter list.","pos":[6814,6905]},{"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> adding the params keyword to array parameters if you expect the end users to pass arrays with a small number of elements.","pos":[6912,7048],"source":"**✓ CONSIDER** adding the params keyword to array parameters if you expect the end users to pass arrays with a small number of elements."},{"content":"If it’s expected that lots of elements will be passed in common scenarios, users will probably not pass these elements inline anyway, and so the params keyword is not necessary.","pos":[7049,7226]},{"pos":[7233,7334],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> using params arrays if the caller would almost always have the input already in an array.","source":"**X AVOID** using params arrays if the caller would almost always have the input already in an array."},{"content":"For example, members with byte array parameters would almost never be called by passing individual bytes.","pos":[7341,7446]},{"content":"For this reason, byte array parameters in the .NET Framework do not use the params keyword.","pos":[7447,7538]},{"pos":[7545,7649],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use params arrays if the array is modified by the member taking the params array parameter.","source":"**X DO NOT** use params arrays if the array is modified by the member taking the params array parameter."},{"content":"Because of the fact that many compilers turn the arguments to the member into a temporary array at the call site, the array might be a temporary object, and therefore any modifications to the array will be lost.","pos":[7656,7867]},{"pos":[7874,7985],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> using the params keyword in a simple overload, even if a more complex overload could not use it.","source":"**✓ CONSIDER** using the params keyword in a simple overload, even if a more complex overload could not use it."},{"content":"Ask yourself if users would value having the params array in one overload even if it wasn’t in all overloads.","pos":[7992,8101]},{"pos":[8108,8187],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> try to order parameters to make it possible to use the params keyword.","source":"**✓ DO** try to order parameters to make it possible to use the params keyword."},{"pos":[8194,8335],"content":"<bpt id=\"p1\">**</bpt>✓ CONSIDER<ept id=\"p1\">**</ept> providing special overloads and code paths for calls with a small number of arguments in extremely performance-sensitive APIs.","source":"**✓ CONSIDER** providing special overloads and code paths for calls with a small number of arguments in extremely performance-sensitive APIs."},{"content":"This makes it possible to avoid creating array objects when the API is called with a small number of arguments.","pos":[8342,8453]},{"content":"Form the names of the parameters by taking a singular form of the array parameter and adding a numeric suffix.","pos":[8454,8564]},{"content":"You should only do this if you are going to special-case the entire code path, not just create an array and call the more general method.","pos":[8571,8708]},{"pos":[8715,8786],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> be aware that null could be passed as a params array argument.","source":"**✓ DO** be aware that null could be passed as a params array argument."},{"content":"You should validate that the array is not null before processing.","pos":[8793,8858]},{"pos":[8865,8937],"content":"<bpt id=\"p1\">**</bpt>X DO NOT<ept id=\"p1\">**</ept> use the <ph id=\"ph1\">`varargs`</ph> methods, otherwise known as the ellipsis.","source":"**X DO NOT** use the `varargs` methods, otherwise known as the ellipsis."},{"content":"Some CLR languages, such as C++, support an alternative convention for passing variable parameter lists called <ph id=\"ph1\">`varargs`</ph> methods.","pos":[8944,9073],"source":"Some CLR languages, such as C++, support an alternative convention for passing variable parameter lists called `varargs` methods."},{"content":"The convention should not be used in frameworks, because it is not CLS compliant.","pos":[9074,9155]},{"pos":[9165,9183],"content":"Pointer Parameters","linkify":"Pointer Parameters","nodes":[{"content":"Pointer Parameters","pos":[0,18]}]},{"content":"In general, pointers should not appear in the public surface area of a well-designed managed code framework.","pos":[9187,9295]},{"content":"Most of the time, pointers should be encapsulated.","pos":[9296,9346]},{"content":"However, in some cases pointers are required for interoperability reasons, and using pointers in such cases is appropriate.","pos":[9347,9470]},{"pos":[9477,9594],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> provide an alternative for any member that takes a pointer argument, because pointers are not CLS-compliant.","source":"**✓ DO** provide an alternative for any member that takes a pointer argument, because pointers are not CLS-compliant."},{"pos":[9601,9668],"content":"<bpt id=\"p1\">**</bpt>X AVOID<ept id=\"p1\">**</ept> doing expensive argument checking of pointer arguments.","source":"**X AVOID** doing expensive argument checking of pointer arguments."},{"pos":[9675,9763],"content":"<bpt id=\"p1\">**</bpt>✓ DO<ept id=\"p1\">**</ept> follow common pointer-related conventions when designing members with pointers.","source":"**✓ DO** follow common pointer-related conventions when designing members with pointers."},{"content":"For example, there is no need to pass the start index, because simple pointer arithmetic can be used to accomplish the same result.","pos":[9770,9901]},{"pos":[9908,9975],"content":"<bpt id=\"p1\">*</bpt>Portions © 2005, 2009 Microsoft Corporation. All rights reserved.<ept id=\"p1\">*</ept>","source":"*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*"},{"pos":[9982,10387],"content":"<bpt id=\"p1\">*</bpt>Reprinted by permission of Pearson Education, Inc. from <bpt id=\"p2\">[</bpt>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition<ept id=\"p2\">](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)</ept> by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.<ept id=\"p1\">*</ept>","source":"*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*"},{"pos":[10396,10404],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10408,10486],"content":"<bpt id=\"p1\">[</bpt>Member Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/member.md)</ept>","source":"[Member Design Guidelines](../../../docs/standard/design-guidelines/member.md)"},{"pos":[10489,10569],"content":"<bpt id=\"p1\">[</bpt>Framework Design Guidelines<ept id=\"p1\">](../../../docs/standard/design-guidelines/index.md)</ept>","source":"[Framework Design Guidelines](../../../docs/standard/design-guidelines/index.md)"}]}