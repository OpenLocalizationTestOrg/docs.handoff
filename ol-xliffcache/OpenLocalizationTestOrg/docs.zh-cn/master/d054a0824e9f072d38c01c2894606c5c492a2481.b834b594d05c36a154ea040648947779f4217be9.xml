{"content":"---\ntitle: \"group clause (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"group\"\n  - \"group_CSharpKeyword\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"group keyword [C#]\"\n  - \"group clause [C#]\"\nms.assetid: c817242e-b12c-4baa-a57e-73ee138f34d1\ncaps.latest.revision: 24\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# group clause (C# Reference)\nThe `group` clause returns a sequence of <xref:System.Linq.IGrouping%602> objects that contain zero or more items that match the key value for the group. For example, you can group a sequence of strings according to the first letter in each string. In this case, the first letter is the key and has a type [char](../../../csharp/language-reference/keywords/char.md), and is stored in the `Key` property of each <xref:System.Linq.IGrouping%602> object. The compiler infers the type of the key.  \n  \n You can end a query expression with a `group` clause, as shown in the following example:  \n  \n [!code-cs[cscsrefQueryKeywords#10](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_1.cs)]  \n  \n If you want to perform additional query operations on each group, you can specify a temporary identifier by using the [into](../../../csharp/language-reference/keywords/into.md) contextual keyword. When you use `into`, you must continue with the query, and eventually end it with either a `select` statement or another `group` clause, as shown in the following excerpt:  \n  \n [!code-cs[cscsrefQueryKeywords#11](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_2.cs)]  \n  \n More complete examples of the use of `group` with and without `into` are provided in the Example section of this topic.  \n  \n## Enumerating the Results of a Group Query  \n Because the <xref:System.Linq.IGrouping%602> objects produced by a `group` query are essentially a list of lists, you must use a nested [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to access the items in each group. The outer loop iterates over the group keys, and the inner loop iterates over each item in the group itself. A group may have a key but no elements. The following is the `foreach` loop that executes the query in the previous code examples:  \n  \n [!code-cs[cscsrefQueryKeywords#12](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_3.cs)]  \n  \n## Key Types  \n Group keys can be any type, such as a string, a built-in numeric type, or a user-defined named type or anonymous type.  \n  \n### Grouping by string  \n The previous code examples used a `char`. A string key could easily have been specified instead, for example the complete last name:  \n  \n [!code-cs[cscsrefQueryKeywords#13](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_4.cs)]  \n  \n### Grouping by bool  \n The following example shows the use of a bool value for a key to divide the results into two groups. Note that the value is produced by a sub-expression in the `group` clause.  \n  \n [!code-cs[cscsrefQueryKeywords#14](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_5.cs)]  \n  \n### Grouping by numeric range  \n The next example uses an expression to create numeric group keys that represent a percentile range. Note the use of [let](../../../csharp/language-reference/keywords/let-clause.md) as a convenient location to store a method call result, so that you do not have to call the method two times in the `group` clause. Note also in the `group` clause that to avoid a \"divide by zero\" exception the code checks to make sure that the student does not have an average of zero. For more information about how to safely use methods in query expressions, see [How to: Handle Exceptions in Query Expressions](../../../csharp/programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions.md).  \n  \n [!code-cs[cscsrefQueryKeywords#15](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_6.cs)]  \n  \n### Grouping by Composite Keys  \n Use a composite key when you want to group elements according to more than one key. You create a composite key by using an anonymous type or a named type to hold the key element. In the following example, assume that a class `Person` has been declared with members named `surname` and `city`. The `group` clause causes a separate group to be created for each set of persons with the same last name and the same city.  \n  \n```csharp  \ngroup person by new {name = person.surname, city = person.city};  \n```  \n  \n Use a named type if you must pass the query variable to another method. Create a special class using auto-implemented properties for the keys, and then override the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods. You can also use a struct, in which case you do not strictly have to override those methods. For more information see [How to: Implement a Lightweight Class with Auto-Implemented Properties](../../../csharp/programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties.md) and [How to: Query for Duplicate Files in a Directory Tree](../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq.md). The latter topic has a code example that demonstrates how to use a composite key with a named type.  \n  \n## Example  \n The following example shows the standard pattern for ordering source data into groups when no additional query logic is applied to the groups. This is called a grouping without a continuation. The elements in an array of strings are grouped according to their first letter. The result of the query is an <xref:System.Linq.IGrouping%602> type that contains a public `Key` property of type `char` and an <xref:System.Collections.Generic.IEnumerable%601> collection that contains each item in the grouping.  \n  \n The result of a `group` clause is a sequence of sequences. Therefore, to access the individual elements within each returned group, use a nested `foreach` loop inside the loop that iterates the group keys, as shown in the following example.  \n  \n [!code-cs[cscsrefQueryKeywords#16](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_7.cs)]  \n  \n## Example  \n This example shows how to perform additional logic on the groups after you have created them, by using a *continuation* with `into`. For more information, see [into](../../../csharp/language-reference/keywords/into.md). The following example queries each group to select only those whose key value is a vowel.  \n  \n [!code-cs[cscsrefQueryKeywords#17](../../../csharp/language-reference/keywords/codesnippet/CSharp/group-clause_8.cs)]  \n  \n## Remarks  \n At compile time, `group` clauses are translated into calls to the <xref:System.Linq.Enumerable.GroupBy%2A> method.  \n  \n## See Also  \n <xref:System.Linq.IGrouping%602>   \n <xref:System.Linq.Enumerable.GroupBy%2A>   \n <xref:System.Linq.Enumerable.ThenBy%2A>   \n <xref:System.Linq.Enumerable.ThenByDescending%2A>   \n [Query Keywords (LINQ)](../../../csharp/language-reference/keywords/query-keywords.md)   \n [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md)   \n [How to: Create a Nested Group](../../../csharp/programming-guide/linq-query-expressions/how-to-create-a-nested-group.md)   \n [How to: Group Query Results](../../../csharp/programming-guide/linq-query-expressions/how-to-group-query-results.md)   \n [How to: Perform a Subquery on a Grouping Operation](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-a-subquery-on-a-grouping-operation.md)\n","nodes":[{"pos":[4,595],"embed":true,"restype":"x-metadata","content":"title: \"group clause (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"group\"\n  - \"group_CSharpKeyword\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"group keyword [C#]\"\n  - \"group clause [C#]\"\nms.assetid: c817242e-b12c-4baa-a57e-73ee138f34d1\ncaps.latest.revision: 24\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","nodes":[{"content":"group clause (C# Reference) | Microsoft Docs","nodes":[{"pos":[0,44],"content":"group clause (C# Reference) | Microsoft Docs","nodes":[{"content":"group clause (C# Reference) | Microsoft Docs","pos":[0,44]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[602,629],"content":"group clause (C# Reference)","linkify":"group clause (C# Reference)","nodes":[{"content":"group clause (C# Reference)","pos":[0,27]}]},{"content":"The <ph id=\"ph1\">`group`</ph> clause returns a sequence of <ph id=\"ph2\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> objects that contain zero or more items that match the key value for the group.","pos":[630,783],"source":"The `group` clause returns a sequence of <xref:System.Linq.IGrouping%602> objects that contain zero or more items that match the key value for the group."},{"content":"For example, you can group a sequence of strings according to the first letter in each string.","pos":[784,878]},{"content":"In this case, the first letter is the key and has a type <bpt id=\"p1\">[</bpt>char<ept id=\"p1\">](../../../csharp/language-reference/keywords/char.md)</ept>, and is stored in the <ph id=\"ph1\">`Key`</ph> property of each <ph id=\"ph2\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> object.","pos":[879,1081],"source":" In this case, the first letter is the key and has a type [char](../../../csharp/language-reference/keywords/char.md), and is stored in the `Key` property of each <xref:System.Linq.IGrouping%602> object."},{"content":"The compiler infers the type of the key.","pos":[1082,1122]},{"pos":[1129,1217],"content":"You can end a query expression with a <ph id=\"ph1\">`group`</ph> clause, as shown in the following example:","source":"You can end a query expression with a `group` clause, as shown in the following example:"},{"content":"If you want to perform additional query operations on each group, you can specify a temporary identifier by using the <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](../../../csharp/language-reference/keywords/into.md)</ept> contextual keyword.","pos":[1348,1545],"source":"If you want to perform additional query operations on each group, you can specify a temporary identifier by using the [into](../../../csharp/language-reference/keywords/into.md) contextual keyword."},{"content":"When you use <ph id=\"ph1\">`into`</ph>, you must continue with the query, and eventually end it with either a <ph id=\"ph2\">`select`</ph> statement or another <ph id=\"ph3\">`group`</ph> clause, as shown in the following excerpt:","pos":[1546,1717],"source":" When you use `into`, you must continue with the query, and eventually end it with either a `select` statement or another `group` clause, as shown in the following excerpt:"},{"pos":[1848,1967],"content":"More complete examples of the use of <ph id=\"ph1\">`group`</ph> with and without <ph id=\"ph2\">`into`</ph> are provided in the Example section of this topic.","source":"More complete examples of the use of `group` with and without `into` are provided in the Example section of this topic."},{"pos":[1976,2016],"content":"Enumerating the Results of a Group Query","linkify":"Enumerating the Results of a Group Query","nodes":[{"content":"Enumerating the Results of a Group Query","pos":[0,40]}]},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> objects produced by a <ph id=\"ph2\">`group`</ph> query are essentially a list of lists, you must use a nested <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> loop to access the items in each group.","pos":[2020,2264],"source":"Because the <xref:System.Linq.IGrouping%602> objects produced by a `group` query are essentially a list of lists, you must use a nested [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to access the items in each group."},{"content":"The outer loop iterates over the group keys, and the inner loop iterates over each item in the group itself.","pos":[2265,2373]},{"content":"A group may have a key but no elements.","pos":[2374,2413]},{"content":"The following is the <ph id=\"ph1\">`foreach`</ph> loop that executes the query in the previous code examples:","pos":[2414,2504],"source":" The following is the `foreach` loop that executes the query in the previous code examples:"},{"pos":[2637,2646],"content":"Key Types","linkify":"Key Types","nodes":[{"content":"Key Types","pos":[0,9]}]},{"content":"Group keys can be any type, such as a string, a built-in numeric type, or a user-defined named type or anonymous type.","pos":[2650,2768]},{"pos":[2778,2796],"content":"Grouping by string","linkify":"Grouping by string","nodes":[{"content":"Grouping by string","pos":[0,18]}]},{"content":"The previous code examples used a <ph id=\"ph1\">`char`</ph>.","pos":[2800,2841],"source":"The previous code examples used a `char`."},{"content":"A string key could easily have been specified instead, for example the complete last name:","pos":[2842,2932]},{"pos":[3066,3082],"content":"Grouping by bool","linkify":"Grouping by bool","nodes":[{"content":"Grouping by bool","pos":[0,16]}]},{"content":"The following example shows the use of a bool value for a key to divide the results into two groups.","pos":[3086,3186]},{"content":"Note that the value is produced by a sub-expression in the <ph id=\"ph1\">`group`</ph> clause.","pos":[3187,3261],"source":" Note that the value is produced by a sub-expression in the `group` clause."},{"pos":[3395,3420],"content":"Grouping by numeric range","linkify":"Grouping by numeric range","nodes":[{"content":"Grouping by numeric range","pos":[0,25]}]},{"content":"The next example uses an expression to create numeric group keys that represent a percentile range.","pos":[3424,3523]},{"content":"Note the use of <bpt id=\"p1\">[</bpt>let<ept id=\"p1\">](../../../csharp/language-reference/keywords/let-clause.md)</ept> as a convenient location to store a method call result, so that you do not have to call the method two times in the <ph id=\"ph1\">`group`</ph> clause.","pos":[3524,3736],"source":" Note the use of [let](../../../csharp/language-reference/keywords/let-clause.md) as a convenient location to store a method call result, so that you do not have to call the method two times in the `group` clause."},{"content":"Note also in the <ph id=\"ph1\">`group`</ph> clause that to avoid a \"divide by zero\" exception the code checks to make sure that the student does not have an average of zero.","pos":[3737,3891],"source":" Note also in the `group` clause that to avoid a \"divide by zero\" exception the code checks to make sure that the student does not have an average of zero."},{"content":"For more information about how to safely use methods in query expressions, see <bpt id=\"p1\">[</bpt>How to: Handle Exceptions in Query Expressions<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions.md)</ept>.","pos":[3892,4127],"source":" For more information about how to safely use methods in query expressions, see [How to: Handle Exceptions in Query Expressions](../../../csharp/programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions.md)."},{"pos":[4261,4287],"content":"Grouping by Composite Keys","linkify":"Grouping by Composite Keys","nodes":[{"content":"Grouping by Composite Keys","pos":[0,26]}]},{"content":"Use a composite key when you want to group elements according to more than one key.","pos":[4291,4374]},{"content":"You create a composite key by using an anonymous type or a named type to hold the key element.","pos":[4375,4469]},{"content":"In the following example, assume that a class <ph id=\"ph1\">`Person`</ph> has been declared with members named <ph id=\"ph2\">`surname`</ph> and <ph id=\"ph3\">`city`</ph>.","pos":[4470,4583],"source":" In the following example, assume that a class `Person` has been declared with members named `surname` and `city`."},{"content":"The <ph id=\"ph1\">`group`</ph> clause causes a separate group to be created for each set of persons with the same last name and the same city.","pos":[4584,4707],"source":" The `group` clause causes a separate group to be created for each set of persons with the same last name and the same city."},{"content":"Use a named type if you must pass the query variable to another method.","pos":[4802,4873]},{"content":"Create a special class using auto-implemented properties for the keys, and then override the <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods.","pos":[4874,5046],"source":" Create a special class using auto-implemented properties for the keys, and then override the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods."},{"content":"You can also use a struct, in which case you do not strictly have to override those methods.","pos":[5047,5139]},{"content":"For more information see <bpt id=\"p1\">[</bpt>How to: Implement a Lightweight Class with Auto-Implemented Properties<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Query for Duplicate Files in a Directory Tree<ept id=\"p2\">](../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq.md)</ept>.","pos":[5140,5526],"source":" For more information see [How to: Implement a Lightweight Class with Auto-Implemented Properties](../../../csharp/programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties.md) and [How to: Query for Duplicate Files in a Directory Tree](../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq.md)."},{"content":"The latter topic has a code example that demonstrates how to use a composite key with a named type.","pos":[5527,5626]},{"pos":[5635,5642],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows the standard pattern for ordering source data into groups when no additional query logic is applied to the groups.","pos":[5646,5788]},{"content":"This is called a grouping without a continuation.","pos":[5789,5838]},{"content":"The elements in an array of strings are grouped according to their first letter.","pos":[5839,5919]},{"content":"The result of the query is an <ph id=\"ph1\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> type that contains a public <ph id=\"ph2\">`Key`</ph> property of type <ph id=\"ph3\">`char`</ph> and an <ph id=\"ph4\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection that contains each item in the grouping.","pos":[5920,6149],"source":" The result of the query is an <xref:System.Linq.IGrouping%602> type that contains a public `Key` property of type `char` and an <xref:System.Collections.Generic.IEnumerable%601> collection that contains each item in the grouping."},{"content":"The result of a <ph id=\"ph1\">`group`</ph> clause is a sequence of sequences.","pos":[6156,6214],"source":"The result of a `group` clause is a sequence of sequences."},{"content":"Therefore, to access the individual elements within each returned group, use a nested <ph id=\"ph1\">`foreach`</ph> loop inside the loop that iterates the group keys, as shown in the following example.","pos":[6215,6396],"source":" Therefore, to access the individual elements within each returned group, use a nested `foreach` loop inside the loop that iterates the group keys, as shown in the following example."},{"pos":[6529,6536],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example shows how to perform additional logic on the groups after you have created them, by using a <bpt id=\"p1\">*</bpt>continuation<ept id=\"p1\">*</ept> with <ph id=\"ph1\">`into`</ph>.","pos":[6540,6672],"source":"This example shows how to perform additional logic on the groups after you have created them, by using a *continuation* with `into`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](../../../csharp/language-reference/keywords/into.md)</ept>.","pos":[6673,6759],"source":" For more information, see [into](../../../csharp/language-reference/keywords/into.md)."},{"content":"The following example queries each group to select only those whose key value is a vowel.","pos":[6760,6849]},{"pos":[6982,6989],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[6993,7107],"content":"At compile time, <ph id=\"ph1\">`group`</ph> clauses are translated into calls to the <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.GroupBy%2A&gt;</ph> method.","source":"At compile time, `group` clauses are translated into calls to the <xref:System.Linq.Enumerable.GroupBy%2A> method."},{"pos":[7116,7124],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Query Keywords (LINQ)<ept id=\"p1\">](../../../csharp/language-reference/keywords/query-keywords.md)</ept><ph id=\"ph1\"> </ph>","pos":[7308,7395],"source":"[Query Keywords (LINQ)](../../../csharp/language-reference/keywords/query-keywords.md) "},{"content":"<bpt id=\"p1\">[</bpt>LINQ Query Expressions<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[7399,7491],"source":"[LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Create a Nested Group<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/how-to-create-a-nested-group.md)</ept><ph id=\"ph1\"> </ph>","pos":[7495,7617],"source":"[How to: Create a Nested Group](../../../csharp/programming-guide/linq-query-expressions/how-to-create-a-nested-group.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Group Query Results<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/how-to-group-query-results.md)</ept><ph id=\"ph1\"> </ph>","pos":[7621,7739],"source":"[How to: Group Query Results](../../../csharp/programming-guide/linq-query-expressions/how-to-group-query-results.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Perform a Subquery on a Grouping Operation<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-a-subquery-on-a-grouping-operation.md)</ept>","pos":[7743,7906],"source":"[How to: Perform a Subquery on a Grouping Operation](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-a-subquery-on-a-grouping-operation.md)"}]}