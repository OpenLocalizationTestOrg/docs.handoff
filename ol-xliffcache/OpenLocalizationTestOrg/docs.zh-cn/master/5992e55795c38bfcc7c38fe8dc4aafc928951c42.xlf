<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5992e55795c38bfcc7c38fe8dc4aafc928951c42</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\garbage-collection\performance.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e8e2c37136db147ad117902d1459e31ba7f2a3e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">703db3addd8e02f9b08b1fc782e2d1553783a4fc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Garbage Collection and Performance | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Garbage Collection and Performance</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> This topic describes issues related to garbage collection and memory usage.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It addresses issues that pertain to the managed heap and explains how to minimize the effect of garbage collection on your applications.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Each issue has links to procedures that you can use to investigate problems.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Performance Analysis Tools<ept id="p1">](#performance_analysis_tools)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Troubleshooting Performance Issues<ept id="p1">](#troubleshooting_performance_issues)</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Troubleshooting Guidelines<ept id="p1">](#troubleshooting_guidelines)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Performance Check Procedures<ept id="p1">](#performance_check_procedures)</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Performance Analysis Tools</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following sections describe the tools that are available for investigating memory usage and garbage collection issues.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>procedures<ept id="p1">](#performance_check_procedures)</ept> provided later in this topic refer to these tools.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Memory Performance Counters</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can use performance counters to gather performance data.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For instructions, see <bpt id="p1">[</bpt>Runtime Profiling<ept id="p1">](../../../docs/framework/debug-trace-profile/runtime-profiling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The .NET CLR Memory category of performance counters, as described in <bpt id="p1">[</bpt>Performance Counters in the .NET Framework<ept id="p1">](../../../docs/framework/debug-trace-profile/performance-counters.md)</ept>, provides information about the garbage collector.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Debugging with SOS</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">[</bpt>Windows Debugger (WinDbg)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=186482)</ept> to inspect objects on the managed heap.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To install WinDbg, install Debugging Tools for Windows from the <bpt id="p1">[</bpt>WDK and Developer Tools Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=103787)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Garbage Collection ETW Events</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Event tracing for Windows (ETW) is a tracing system that supplements the profiling and debugging support provided by the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, <bpt id="p1">[</bpt>garbage collection ETW events<ept id="p1">](../../../docs/framework/performance/garbage-collection-etw-events.md)</ept> capture useful information for analyzing the managed heap from a statistical point of view.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`GCStart_V1`</ph> event, which is raised when a garbage collection is about to occur, provides the following information:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Which generation of objects is being collected.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>What triggered the garbage collection.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Type of garbage collection (concurrent or not concurrent).</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>ETW event logging is efficient and will not mask any performance problems associated with garbage collection.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A process can provide its own events in conjunction with ETW events.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When logged, both the application's events and the garbage collection events can be correlated to determine how and when heap problems occur.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, a server application could provide events at the start and end of a client request.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The Profiling API</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The common language runtime (CLR) profiling interfaces provide detailed information about the objects that were affected during garbage collection.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A profiler can be notified when a garbage collection starts and ends.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It can provide reports about the objects on the managed heap, including an identification of objects in each generation.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Profiling Overview<ept id="p1">](../../../docs/framework/unmanaged-api/profiling/profiling-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Profilers can provide comprehensive information.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>However, complex profilers can potentially modify an application's behavior.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Application Domain Resource Monitoring</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Application Domain Resource Monitoring<ept id="p1">](../../../docs/standard/garbage-collection/app-domain-resource-monitoring.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Troubleshooting Performance Issues</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The first step is to <bpt id="p1">[</bpt>determine whether the issue is actually garbage collection<ept id="p1">](#IsGC)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If you determine that it is, select from the following list to troubleshoot the problem.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>An out-of-memory exception is thrown<ept id="p1">](#Issue_OOM)</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The process uses too much memory<ept id="p1">](#Issue_TooMuchMemory)</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The garbage collector does not reclaim objects fast enough<ept id="p1">](#Issue_NotFastEnough)</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The managed heap is too fragmented<ept id="p1">](#Issue_Fragmentation)</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage collection pauses are too long<ept id="p1">](#Issue_LongPauses)</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generation 0 is too big<ept id="p1">](#Issue_Gen0)</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>CPU usage during a garbage collection is too high<ept id="p1">](#Issue_HighCPU)</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Issue: An Out-of-Memory Exception Is Thrown</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>There are two legitimate cases for a managed <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> to be thrown:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Running out of virtual memory.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The garbage collector allocates memory from the system in segments of a pre-determined size.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If an allocation requires an additional segment, but there is no contiguous free block left in the process's virtual memory space, the allocation for the managed heap will fail.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Not having enough physical memory to allocate.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Performance checks</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether the out-of-memory exception is managed.<ept id="p1">](#OOMIsManaged)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much virtual memory can be reserved.<ept id="p1">](#GetVM)</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether there is enough physical memory.<ept id="p1">](#Physical)</ept></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If you determine that the exception is not legitimate, contact Microsoft Customer Service and Support with the following information:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The stack with the managed out-of-memory exception.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Full memory dump.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Data that proves that it is not a legitimate out-of-memory exception, including data that shows that virtual or physical memory is not an issue.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Issue: The Process Uses Too Much Memory</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A common assumption is that the memory usage display on the <bpt id="p1">**</bpt>Performance<ept id="p1">**</ept> tab of Windows Task Manager can indicate when too much memory is being used.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, that display pertains to the working set; it does not provide information about virtual memory usage.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you determine that the issue is caused by the managed heap, you must measure the managed heap over time to determine any patterns.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If you determine that the problem is not caused by the managed heap, you must use native debugging.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Performance checks</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much virtual memory can be reserved.<ept id="p1">](#GetVM)</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much memory the managed heap is committing.<ept id="p1">](#ManagedHeapCommit)</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much memory the managed heap reserves.<ept id="p1">](#ManagedHeapReserve)</ept></source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine large objects in generation 2.<ept id="p1">](#ExamineGen2)</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine references to objects.<ept id="p1">](#ObjRef)</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Issue: The Garbage Collector Does Not Reclaim Objects Fast Enough</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When it appears as if objects are not being reclaimed as expected for garbage collection, you must determine if there are any strong references to those objects.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You may also encounter this issue if there has been no garbage collection for the generation that contains a dead object, which indicates that the finalizer for the dead object has not been run.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, this is possible when you are running a single-threaded apartment (STA) application and the thread that services the finalizer queue cannot call into it.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Performance checks</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Check references to objects.<ept id="p1">](#ObjRef)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether a finalizer has been run.<ept id="p1">](#Induce)</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether there are objects waiting to be finalized.<ept id="p1">](#Finalize)</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Issue: The Managed Heap Is Too fragmented</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The fragmentation level is calculated as the ratio of free space over the total allocated memory for the generation.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For generation 2, an acceptable level of fragmentation is no more than 20%.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Because generation 2 can get very big, the ratio of fragmentation is more important than the absolute value.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Having lots of free space in generation 0 is not a problem because this is the generation where new objects are allocated.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Fragmentation always occurs in the large object heap because it is not compacted.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Free objects that are adjacent are naturally collapsed into a single space to satisfy large object allocation requests.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Fragmentation can become a problem in generation 1 and generation 2.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If these generations have a large amount of free space after a garbage collection, an application's object usage may need modification, and you should consider re-evaluating the lifetime of long-term objects.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Excessive pinning of objects can increase fragmentation.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If fragmentation is high, too many objects could be pinned.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If fragmentation of virtual memory is preventing the garbage collector from adding segments, the causes could be one of the following:</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Frequent loading and unloading of many small assemblies.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Holding too many references to COM objects when interoperating with unmanaged code.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Creation of large transient objects, which causes the large object heap to allocate and free heap segments frequently.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When hosting the CLR, an application can request that the garbage collector retain its segments.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This reduces the frequency of segment allocations.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This is accomplished by using the STARTUP_HOARD_GC_VM flag in the <bpt id="p1">[</bpt>STARTUP_FLAGS Enumeration<ept id="p1">](../../../docs/framework/unmanaged-api/hosting/startup-flags-enumeration.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Performance checks</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine the amount of free space in the managed heap.<ept id="p1">](#Fragmented)</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine the number of pinned objects.<ept id="p1">](#Pinned)</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If you think that there is no legitimate cause for the fragmentation, contact Microsoft Customer Service and Support.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Issue: Garbage Collection Pauses Are Too Long</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Garbage collection operates in soft real time, so an application must be able to tolerate some pauses.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A criterion for soft real time is that 95% of the operations must finish on time.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In concurrent garbage collection, managed threads are allowed to run during a collection, which means that pauses are very minimal.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Ephemeral garbage collections (generations 0 and 1) last only a few milliseconds, so decreasing pauses is usually not feasible.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>However, you can decrease the pauses in generation 2 collections by changing the pattern of allocation requests by an application.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Another, more accurate, method is to use <bpt id="p1">[</bpt>garbage collection ETW events<ept id="p1">](../../../docs/framework/performance/garbage-collection-etw-events.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can find the timings for collections by adding the time stamp differences for a sequence of events.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The whole collection sequence includes suspension of the execution engine, the garbage collection itself, and the resumption of the execution engine.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">[</bpt>Garbage Collection Notifications<ept id="p1">](../../../docs/standard/garbage-collection/notifications.md)</ept> to determine whether a server is about to have a generation 2 collection, and whether rerouting requests to another server could ease any problems with pauses.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Performance checks</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine the length of time in a garbage collection.<ept id="p1">](#TimeInGC)</ept></source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine what caused a garbage collection.<ept id="p1">](#Triggered)</ept></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Issue: Generation 0 Is Too Big</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Generation 0 is likely to have a larger number of objects on a 64-bit system, especially when you use server garbage collection instead of workstation garbage collection.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>This is because the threshold to trigger a generation 0 garbage collection is higher in these environments, and generation 0 collections can get much bigger.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Performance is improved when an application allocates more memory before a garbage collection is triggered.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Issue: CPU Usage During a Garbage Collection Is Too High</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>CPU usage will be high during a garbage collection.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If a significant amount of process time is spent in a garbage collection, the number of collections is too frequent or the collection is lasting too long.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>An increased allocation rate of objects on the managed heap causes garbage collection to occur more frequently.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Decreasing the allocation rate reduces the frequency of garbage collections.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You can monitor allocation rates by using the <ph id="ph1">`Allocated Bytes/second`</ph> performance counter.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Performance Counters in the .NET Framework<ept id="p1">](../../../docs/framework/debug-trace-profile/performance-counters.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The duration of a collection is primarily a factor of the number of objects that survive after allocation.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The garbage collector must go through a large amount of memory if many objects remain to be collected.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The work to compact the survivors is time-consuming.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>To determine how many objects were handled during a collection, set a breakpoint in the debugger at the end of a garbage collection for a specified generation.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Performance checks</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine if high CPU usage is caused by garbage collection.<ept id="p1">](#HighCPU)</ept></source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Set a breakpoint at the end of garbage collection.<ept id="p1">](#GenBreak)</ept></source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Troubleshooting Guidelines</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This section describes guidelines that you should consider as you begin your investigations.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Workstation or Server Garbage Collection</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Determine if you are using the correct type of garbage collection.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>If your application uses multiple threads and object instances, use server garbage collection instead of workstation garbage collection.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Server garbage collection operates on multiple threads, whereas workstation garbage collection requires multiple instances of an application to run their own garbage collection threads and compete for CPU time.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>An application that has a low load and that performs tasks infrequently in the background, such as a service, could use workstation garbage collection with concurrent garbage collection disabled.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>When to Measure the Managed Heap Size</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Unless you are using a profiler, you will have to establish a consistent measuring pattern to effectively diagnose performance issues.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Consider the following points to establish a schedule:</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If you measure after a generation 2 garbage collection, the entire managed heap will be free of garbage (dead objects).</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>If you measure immediately after a generation 0 garbage collection, the objects in generations 1 and 2 will not be collected yet.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If you measure immediately before a garbage collection, you will measure as much allocation as possible before the garbage collection starts.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Measuring during a garbage collection is problematic, because the garbage collector data structures are not in a valid state for traversal and may not be able to give you the complete results.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This is by design.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>When you are using workstation garbage collection with concurrent garbage collection, the reclaimed objects are not compacted, so the heap size can be the same or larger (fragmentation can make it appear to be larger).</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Concurrent garbage collection on generation 2 is delayed when the physical memory load is too high.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following procedure describes how to set a breakpoint so that you can measure the managed heap.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>To set a breakpoint at the end of garbage collection</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>In WinDbg with the SOS debugger extension loaded, type the following command:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>bp mscorwks!WKS::GCHeap::RestartEE "j (dwo(mscorwks!WKS::GCHeap::GcCondemnedGeneration)==2) 'kb';'g'"<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>where <bpt id="p1">**</bpt>GcCondemnedGeneration<ept id="p1">**</ept> is set to the desired generation.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This command requires private symbols.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This command forces a break if <bpt id="p1">**</bpt>RestartEE<ept id="p1">**</ept> is executed after generation 2 objects have been reclaimed for garbage collection.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>In server garbage collection, only one thread calls <bpt id="p1">**</bpt>RestartEE<ept id="p1">**</ept>, so the breakpoint will occur only once during a generation 2 garbage collection.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Performance Check Procedures</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This section describes the following procedures to isolate the cause of your performance issue:</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether the problem is caused by garbage collection.<ept id="p1">](#IsGC)</ept></source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether the out-of-memory exception is managed.<ept id="p1">](#OOMIsManaged)</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much virtual memory can be reserved.<ept id="p1">](#GetVM)</ept></source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether there is enough physical memory.<ept id="p1">](#Physical)</ept></source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much memory the managed heap is committing.<ept id="p1">](#ManagedHeapCommit)</ept></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine how much memory the managed heap reserves.<ept id="p1">](#ManagedHeapReserve)</ept></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine large objects in generation 2.<ept id="p1">](#ExamineGen2)</ept></source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine references to objects.<ept id="p1">](#ObjRef)</ept></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether a finalizer has been run.<ept id="p1">](#Induce)</ept></source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether there are objects waiting to be finalized.<ept id="p1">](#Finalize)</ept></source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine the amount of free space in the managed heap.<ept id="p1">](#Fragmented)</ept></source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine the number of pinned objects.<ept id="p1">](#Pinned)</ept></source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine the length of time in a garbage collection.<ept id="p1">](#TimeInGC)</ept></source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine what triggered a garbage collection.<ept id="p1">](#Triggered)</ept></source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Determine whether high CPU usage is caused by garbage collection.<ept id="p1">](#HighCPU)</ept></source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>To determine whether the problem is caused by garbage collection</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Examine the following two memory performance counters:</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>% Time in GC<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Displays the percentage of elapsed time that was spent performing a garbage collection after the last garbage collection cycle.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Use this counter to determine whether the garbage collector is spending too much time to make managed heap space available.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>If the time spent in garbage collection is relatively low, that could indicate a resource problem outside the managed heap.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>This counter may not be accurate when concurrent or background garbage collection is involved.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt># Total committed Bytes<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Displays the amount of virtual memory currently committed by the garbage collector.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Use this counter to determine whether the memory consumed by the garbage collector is an excessive portion of the memory that your application uses.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Most of the memory performance counters are updated at the end of each garbage collection.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Therefore, they may not reflect the current conditions that you want information about.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>To determine whether the out-of-memory exception is managed</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the print exception (<bpt id="p1">**</bpt>pe<ept id="p1">**</ept>) command:</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!pe<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>If the exception is managed, <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is displayed as the exception type, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>If the output does not specify an exception, you have to determine which thread the out-of-memory exception is from.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Type the following command in the debugger to show all the threads with their call stacks:</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">~</ph><ph id="ph2">\*</ph>kb<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The thread with the stack that has exception calls is indicated by the <ph id="ph1">`RaiseTheException`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>This is the managed exception object.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>You can use the following command to dump nested exceptions.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!pe -nested<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>If you do not find any exceptions, the out-of-memory exception originated from unmanaged code.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>To determine how much virtual memory can be reserved</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>In WinDbg with the SOS debugger extension loaded, type the following command to get the largest free region:</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!address -summary<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The largest free region is displayed as shown in the following output.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>In this example, the size of the largest free region is approximately 24000 KB (3A980 in hexadecimal).</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>This region is much smaller than what the garbage collector needs for a segment.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>vmstat<ept id="p1">**</ept> command:</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!vmstat<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The largest free region is the largest value in the MAXIMUM column, as shown in the following output.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>To determine whether there is enough physical memory</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Start Windows Task Manager.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>On the <bpt id="p1">**</bpt>Performance<ept id="p1">**</ept> tab, look at the committed value.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>(In Windows 7, look at <bpt id="p1">**</bpt>Commit (KB)<ept id="p1">**</ept> in the <bpt id="p2">**</bpt>System group<ept id="p2">**</ept>.)</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">**</bpt>Total<ept id="p1">**</ept> is close to the <bpt id="p2">**</bpt>Limit<ept id="p2">**</ept>, you are running low on physical memory.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>To determine how much memory the managed heap is committing</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`# Total committed bytes`</ph> memory performance counter to get the number of bytes that the managed heap is committing.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The garbage collector commits chunks on a segment as needed, not all at the same time.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Do not use the <ph id="ph1">`# Bytes in all Heaps`</ph> performance counter, because it does not represent actual memory usage by the managed heap.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The size of a generation is included in this value and is actually its threshold size, that is, the size that induces a garbage collection if the generation is filled with objects.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Therefore, this value is usually zero.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>To determine how much memory the managed heap reserves</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`# Total reserved bytes`</ph> memory performance counter.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The garbage collector reserves memory in segments, and you can determine where a segment starts by using the <bpt id="p1">**</bpt>eeheap<ept id="p1">**</ept> command.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Although you can determine the amount of memory the garbage collector allocates for each segment, segment size is implementation-specific and is subject to change at any time, including in periodic updates.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!eeheap -gc<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>The result is as follows.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The addresses indicated by "segment" are the starting addresses of the segments.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>To determine large objects in generation 2</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!dumpheap –stat<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>If the managed heap is big, <bpt id="p1">**</bpt>dumpheap<ept id="p1">**</ept> may take a while to finish.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>You can start analyzing from the last few lines of the output, because they list the objects that use the most space.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The last object listed is a string and occupies the most space.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>You can examine your application to see how your string objects can be optimized.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>To see strings that are between 150 and 200 bytes, type the following:</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!dumpheap -type System.String -min 150 -max 200<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>An example of the results is as follows.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Using an integer instead of a string for an ID can be more efficient.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>If the same string is being repeated thousands of times, consider string interning.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>For more information about string interning, see the reference topic for the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>To determine references to objects</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>In WinDbg with the SOS debugger extension loaded, type the following command to list references to objects:</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!gcroot<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>To determine the references for a specific object, include the address:</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!gcroot 1c37b2ac<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Roots found on stacks may be false positives.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For more information, use the command <ph id="ph1">`!help gcroot`</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>gcroot<ept id="p1">**</ept> command can take a long time to finish.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Any object that is not reclaimed by garbage collection is a live object.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>This means that some root is directly or indirectly holding onto the object, so <bpt id="p1">**</bpt>gcroot<ept id="p1">**</ept> should return path information to the object.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>You should examine the graphs returned and see why these objects are still referenced.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>To determine whether a finalizer has been run</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Run a test program that contains the following code:</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>If the test resolves the problem, this means that the garbage collector was not reclaiming objects, because the finalizers for those objects had been suspended.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=fullName&gt;</ph> method enables the finalizers to complete their tasks, and fixes the problem.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>To determine whether there are objects waiting to be finalized</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!finalizequeue<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Look at the number of objects that are ready for finalization.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>If the number is high, you must examine why these finalizers cannot progress at all or cannot progress fast enough.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>To get an output of threads, type the following command:</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>threads -special<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>This command provides output such as the following.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The finalizer thread indicates which finalizer, if any, is currently being run.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>When a finalizer thread is not running any finalizers, it is waiting for an event to tell it to do its work.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Most of the time you will see the finalizer thread in this state because it runs at THREAD_HIGHEST_PRIORITY and is supposed to finish running finalizers, if any, very quickly.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>To determine the amount of free space in the managed heap</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!dumpheap -type Free -stat<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>This command displays the total size of all the free objects on the managed heap, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>To determine the free space in generation 0, type the following command for memory consumption information by generation:</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!eeheap -gc<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>This command displays output similar to the following.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>The last line shows the ephemeral segment.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Calculate the space used by generation 0:</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>? 49e05d04-0x49521f8c<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The result is as follows.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Generation 0 is approximately 9 MB.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The following command dumps the free space within the generation 0 range:</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!dumpheap -type Free -stat 0x49521f8c 49e05d04<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>The result is as follows.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>This output shows that the generation 0 portion of the heap is using 9 MB of space for objects and has 7 MB free.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>This analysis shows the extent to which generation 0 contributes to fragmentation.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>This amount of heap usage should be discounted from the total amount as the cause of fragmentation by long-term objects.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>To determine the number of pinned objects</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command:</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!gchandles<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The statistics displayed includes the number of pinned handles, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>To determine the length of time in a garbage collection</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Examine the <ph id="ph1">`% Time in GC`</ph> memory performance counter.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The value is calculated by using a sample interval time.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Because the counters are updated at the end of each garbage collection, the current sample will have the same value as the previous sample if no collections occurred during the interval.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Collection time is obtained by multiplying the sample interval time with the percentage value.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The following data shows four sampling intervals of two seconds, for an 8-second study.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Gen0`</ph>, <ph id="ph2">`Gen1`</ph>, and <ph id="ph3">`Gen2`</ph> columns show the number of garbage collections that occurred during that interval for that generation.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>This information does not show when the garbage collection occurred, but you can determine the number of garbage collections that occurred in an interval of time.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Assuming the worst case, the tenth generation 0 garbage collection finished at the start of the second interval, and the eleventh generation 0 garbage collection finished at the end of the fifth interval.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The time between the end of the tenth and the end of the eleventh garbage collection is about 2 seconds, and the performance counter shows 3%, so the duration of the eleventh generation 0 garbage collection was (2 seconds * 3% = 60ms).</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>In this example, there are 5 periods.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The second generation 2 garbage collection started during the third interval and finished at the fifth interval.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Assuming the worst case, the last garbage collection was for a generation 0 collection that finished at the start of the second interval, and the generation 2 garbage collection finished at the end of the fifth interval.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Therefore, the time between the end of the generation 0 garbage collection and the end of the generation 2 garbage collection is 4 seconds.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`% Time in GC`</ph> counter is 20%, the maximum amount of time the generation 2 garbage collection could have taken is (4 seconds * 20% = 800ms).</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>Alternatively, you can determine the length of a garbage collection by using <bpt id="p1">[</bpt>garbage collection ETW events<ept id="p1">](../../../docs/framework/performance/garbage-collection-etw-events.md)</ept>, and analyze the information to determine the duration of garbage collection.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>For example, the following data shows an event sequence that occurred during a non-concurrent garbage collection.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Suspending the managed thread took 26us (<ph id="ph1">`GCSuspendEEEnd`</ph> – <ph id="ph2">`GCSuspendEEBegin_V1`</ph>).</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>The actual garbage collection took 4.8ms (<ph id="ph1">`GCEnd_V1`</ph> – <ph id="ph2">`GCStart_V1`</ph>).</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>Resuming the managed threads took 21us (<ph id="ph1">`GCRestartEEEnd`</ph> – <ph id="ph2">`GCRestartEEBegin`</ph>).</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The following output provides an example for background garbage collection, and includes the process, thread, and event fields.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>(Not all data is shown.)</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GCStart_V1`</ph> event at 42504816 indicates that this is a background garbage collection, because the last field is <ph id="ph2">`1`</ph>.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>This becomes garbage collection No.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>102019.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GCStart`</ph> event occurs because there is a need for an ephemeral garbage collection before you start a background garbage collection.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>This becomes garbage collection No.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>102020.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>At 42514170, garbage collection No.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>102020 finishes.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>The managed threads are restarted at this point.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>This is completed on thread 4372, which triggered this background garbage collection.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>On thread 4744, a suspension occurs.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>This is the only time at which the background garbage collection has to suspend managed threads.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>This duration is approximately 99ms ((63784407-63685394)/1000).</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GCEnd`</ph> event for the background garbage collection is at 89931423.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>This means that the background garbage collection lasted for about 47seconds ((89931423-42504816)/1000).</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>While the managed threads are running, you can see any number of ephemeral garbage collections occurring.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>To determine what triggered a garbage collection</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>In the WinDbg or Visual Studio debugger with the SOS debugger extension loaded, type the following command to show all the threads with their call stacks:</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt><ph id="ph1">~</ph><ph id="ph2">\*</ph>kb<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>This command displays output similar to the following.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>If the garbage collection was caused by a low memory notification from the operating system, the call stack is similar, except that the thread is the finalizer thread.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The finalizer thread gets an asynchronous low memory notification and induces the garbage collection.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>If the garbage collection was caused by memory allocation, the stack appears as follows:</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>A just-in-time helper (<ph id="ph1">`JIT_New*`</ph>) eventually calls <ph id="ph2">`GCHeap::GarbageCollectGeneration`</ph>.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>If you determine that generation 2 garbage collections are caused by allocations, you must determine which objects are collected by a generation 2 garbage collection and how to avoid them.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>That is, you want to determine the difference between the start and the end of a generation 2 garbage collection, and the objects that caused the generation 2 collection.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>For example, type the following command in the debugger to show the beginning of a generation 2 collection:</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!dumpheap –stat<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Example output (abridged to show the objects that use the most space):</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Repeat the command at the end of generation 2:</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>!dumpheap –stat<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Example output (abridged to show the objects that use the most space):</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`double[]`</ph> objects disappeared from the end of the output, which means that they were collected.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>These objects account for approximately 70 MB.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The remaining objects did not change much.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Therefore, these <ph id="ph1">`double[]`</ph> objects were the reason why this generation 2 garbage collection occurred.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Your next step is to determine why the <ph id="ph1">`double[]`</ph> objects are there and why they died.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>You can ask the code developer where these objects came from, or you can use the <bpt id="p1">**</bpt>gcroot<ept id="p1">**</ept> command.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>To determine whether high CPU usage is caused by garbage collection</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Correlate the <ph id="ph1">`% Time in GC`</ph> memory performance counter value with the process time.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`% Time in GC`</ph> value spikes at the same time as process time, garbage collection is causing a high CPU usage.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Otherwise, profile the application to find where the high usage is occurring.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Garbage Collection<ept id="p1">](../../../docs/standard/garbage-collection/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>