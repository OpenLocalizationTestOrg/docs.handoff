{"content":"---\ntitle: \"Synchronous and Asynchronous Operations\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"service contracts [WCF], synchronous operations\"\n  - \"service contracts [WCF], asynchronous operations\"\nms.assetid: db8a51cb-67e6-411b-9035-e5821ed350c9\n---\n# Synchronous and Asynchronous Operations\nThis topic discusses implementing and calling asynchronous service operations.  \n  \n Many applications call methods asynchronously because it enables the application to continue doing useful work while the method call runs. Windows Communication Foundation (WCF) services and clients can participate in asynchronous operation calls at two distinct levels of the application, which provide WCF applications even more flexibility to maximize throughput balanced against interactivity.  \n  \n## Types of Asynchronous Operations  \n All service contracts in WCF, no matter the parameters types and return values, use WCF attributes to specify a particular message exchange pattern between client and service. WCF automatically routes inbound and outbound messages to the appropriate service operation or running client code.  \n  \n The client possesses only the service contract, which specifies the message exchange pattern for a particular operation. Clients can offer the developer any programming model they choose, so long as the underlying message exchange pattern is observed. So, too, can services implement operations in any manner, so long as the specified message pattern is observed.  \n  \n The independence of the service contract from either the service or client implementation enables the following forms of asynchronous execution in WCF applications:  \n  \n-   Clients can invoke request/response operations asynchronously using a synchronous message exchange.  \n  \n-   Services can implement a request/response operation asynchronously using a synchronous message exchange.  \n  \n-   Message exchanges can be one-way, regardless of the implementation of the client or service.  \n  \n### Suggested Asynchronous Scenarios  \n Use an asynchronous approach in a service operation implementation if the operation service implementation makes a blocking call, such as doing I/O work. When you are in an asynchronous operation implementation, try to call asynchronous operations and methods to extend the asynchronous call path as far as possible. For example, call a `BeginOperationTwo()` from within `BeginOperationOne()`.  \n  \n-   Use an asynchronous approach in a client or calling application in the following cases:  \n  \n-   If you are invoking operations from a middle-tier application. (For more information about such scenarios, see [Middle-Tier Client Applications](../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md).)  \n  \n-   If you are invoking operations within an ASP.NET page, use asynchronous pages.  \n  \n-   If you are invoking operations from any application that is single threaded, such as Windows Forms or Windows Presentation Foundation (WPF). When using the event-based asynchronous calling model, the result event is raised on the UI thread, adding responsiveness to the application without requiring you to handle multiple threads yourself.  \n  \n-   In general, if you have a choice between a synchronous and asynchronous call, choose the asynchronous call.  \n  \n### Implementing an Asynchronous Service Operation  \n Asynchronous operations can be implemented by using one of the three following methods:  \n  \n1.  The task-based asynchronous pattern  \n  \n2.  The event-based asynchronous pattern  \n  \n3.  The IAsyncResult asynchronous pattern  \n  \n#### Task-Based Asynchronous Pattern  \n The task-based asynchronous pattern is the preferred way to implement asynchronous operations because it is the easiest and most straight forward. To use this method simply implement your service operation and specify a return type of Task\\<T>, where T is the type returned by the logical operation. For example:  \n  \n```csharp  \npublic class SampleService:ISampleService   \n{   \n   // ...  \n   public async Task<string> SampleMethodTaskAsync(string msg)   \n   {   \n      return Task<string>.Factory.StartNew(() =>   \n      {   \n         return msg;   \n      });   \n   }  \n   // ...  \n}  \n```  \n  \n The SampleMethodTaskAsync operation returns Task\\<string> because the logical operation returns a string. For more information about the task-based asynchronous pattern, see [The Task-Based Asynchronous Pattern](https://go.microsoft.com/fwlink/?LinkId=232504).  \n  \n> [!WARNING]\n>  When using the task-based asynchronous pattern, a T:System.AggregateException may be thrown if an exception occurs while waiting on the completion of the operation. This exception may occur on the client or services  \n  \n#### Event-Based Asynchronous Pattern  \n A service that supports the Event-based Asynchronous Pattern will have one or more operations named MethodNameAsync. These methods may mirror synchronous versions, which perform the same operation on the current thread. The class may also have a MethodNameCompleted event and it may have a MethodNameAsyncCancel (or simply CancelAsync) method. A client wishing to call the operation will define an event handler to be called when the operation completes,  \n  \n The following code snippet illustrates how to declare asynchronous operations using the event-based asynchronous pattern.  \n  \n```csharp  \npublic class AsyncExample  \n{  \n    // Synchronous methods.  \n    public int Method1(string param);  \n    public void Method2(double param);  \n  \n    // Asynchronous methods.  \n    public void Method1Async(string param);  \n    public void Method1Async(string param, object userState);  \n    public event Method1CompletedEventHandler Method1Completed;  \n  \n    public void Method2Async(double param);  \n    public void Method2Async(double param, object userState);  \n    public event Method2CompletedEventHandler Method2Completed;  \n  \n    public void CancelAsync(object userState);  \n  \n    public bool IsBusy { get; }  \n  \n    // Class implementation not shown.  \n}  \n```  \n  \n For more information about the Event-based Asynchronous Pattern, see [The Event-Based Asynchronous Pattern](https://go.microsoft.com/fwlink/?LinkId=232515).  \n  \n#### IAsyncResult Asynchronous Pattern  \n A service operation can be implemented in an asynchronous fashion using the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] asynchronous programming pattern and marking the `<Begin>` method with the <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> property set to `true`. In this case, the asynchronous operation is exposed in metadata in the same form as a synchronous operation: It is exposed as a single operation with a request message and a correlated response message. Client programming models then have a choice. They can represent this pattern as a synchronous operation or as an asynchronous one, so long as when the service is invoked a request-response message exchange takes place.  \n  \n In general, with the asynchronous nature of the systems, you should not take a dependency on the threads.  The most reliable way of passing data to various stages of operation dispatch processing is to use extensions.  \n  \n For an example, see [How to: Implement an Asynchronous Service Operation](../../../docs/framework/wcf/how-to-implement-an-asynchronous-service-operation.md).  \n  \n To define a contract operation `X` that is executed asynchronously regardless of how it is called in the client application:  \n  \n-   Define two methods using the pattern `BeginOperation` and `EndOperation`.  \n  \n-   The `BeginOperation` method includes `in` and `ref` parameters for the operation and returns an <xref:System.IAsyncResult> type.  \n  \n-   The `EndOperation` method includes an <xref:System.IAsyncResult> parameter as well as the `out` and `ref` parameters and returns the operations return type.  \n  \n For example, see the following method.  \n  \n```csharp  \nint DoWork(string data, ref string inout, out string outonly)  \n```  \n  \n```vb  \nFunction DoWork(ByVal data As String, ByRef inout As String, _out outonly As out) As Integer  \n```  \n  \n To create an asynchronous operation, the two methods would be:  \n  \n```csharp  \n[OperationContract(AsyncPattern=true)]\nIAsyncResult BeginDoWork(string data,\n                         ref string inout,\n                         AsyncCallback callback,\n                         object state);\nint EndDoWork(ref string inout, out string outonly, IAsyncResult result);  \n```  \n  \n```vb  \n<OperationContract(AsyncPattern := True)>\nFunction BeginDoWork(ByVal data As String, _\n                     ByRef inout As String, _\n                     ByVal callback As AsyncCallback, _\n                     ByVal state As Object) As IAsyncResult\nFunction EndDoWork(ByRef inout As String, ByRef outonly As String, ByVal result As IAsyncResult) As Integer  \n```  \n  \n> [!NOTE]\n>  The <xref:System.ServiceModel.OperationContractAttribute> attribute is applied only to the `BeginDoWork` method. The resulting contract has one WSDL operation named `DoWork`.  \n  \n### Client-Side Asynchronous Invocations  \n A WCF client application can use any of three asynchronous calling models described previously  \n  \n When using the task-based model, simply call the operation using the await keyword as shown in the following code snippet.  \n  \n```  \nawait simpleServiceClient.SampleMethodTaskAsync(\"hello, world\");  \n```  \n  \n Using the event-based asynchronous pattern only requires adding an event handler to receive a notification of the response -- and the resulting event is raised on the user interface thread automatically. To use this approach, specify both the **/async** and **/tcv:Version35** command options with the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md), as in the following example.  \n  \n```  \nsvcutil http://localhost:8000/servicemodelsamples/service/mex /async /tcv:Version35  \n```  \n  \n When this is done, Svcutil.exe generates a WCF client class with the event infrastructure that enables the calling application to implement and assign an event handler to receive the response and take the appropriate action. For a complete example, see [How to: Call Service Operations Asynchronously](../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md).  \n  \n The event-based asynchronous model, however, is only available in [!INCLUDE[netfx35_long](../../../includes/netfx35-long-md.md)]. In addition, it is not supported even in [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] when a WCF client channel is created by using a <xref:System.ServiceModel.ChannelFactory%601?displayProperty=nameWithType>. With WCF client channel objects, you must use <xref:System.IAsyncResult?displayProperty=nameWithType> objects to invoke your operations asynchronously. To use this approach, specify the **/async** command option with the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md), as in the following example.  \n  \n```  \nsvcutil http://localhost:8000/servicemodelsamples/service/mex /async   \n```  \n  \n This generates a service contract in which each operation is modeled as a `<Begin>` method with the <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> property set to `true` and a corresponding `<End>` method. For a complete example using a <xref:System.ServiceModel.ChannelFactory%601>, see [How to: Call Operations Asynchronously Using a Channel Factory](../../../docs/framework/wcf/feature-details/how-to-call-operations-asynchronously-using-a-channel-factory.md).  \n  \n In either case, applications can invoke an operation asynchronously even if the service is implemented synchronously, in the same way that an application can use the same pattern to invoke asynchronously a local synchronous method. How the operation is implemented is not significant to the client; when the response message arrives, its content is dispatched to the client's asynchronous <`End`> method and the client retrieves the information.  \n  \n### One-Way Message Exchange Patterns  \n You can also create an asynchronous message exchange pattern in which one-way operations (operations for which the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> is `true` have no correlated response) can be sent in either direction by the client or service independently of the other side. (This uses the duplex message exchange pattern with one-way messages.) In this case, the service contract specifies a one-way message exchange that either side can implement as asynchronous calls or implementations, or not, as appropriate. Generally, when the contract is an exchange of one-way messages, the implementations can largely be asynchronous because once a message is sent the application does not wait for a reply and can continue doing other work.  \n  \n### Event-based Asynchronous Clients and Message Contracts  \n The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the `Result` property and the others are returned as properties on the <xref:System.EventArgs> object. One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <xref:System.EventArgs> object returns one value as the `Result` property and the remainder are properties of the <xref:System.EventArgs> object.  \n  \n If you want to receive the message object as the `Result` property and have the returned values as properties on that object, use the **/messageContract** command option. This generates a signature that returns the response message as the `Result` property on the <xref:System.EventArgs> object. All internal return values are then properties of the response message object.  \n  \n## See also\n\n- <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A>\n- <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>\n","nodes":[{"pos":[4,288],"embed":true,"restype":"x-metadata","content":"title: \"Synchronous and Asynchronous Operations\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"service contracts [WCF], synchronous operations\"\n  - \"service contracts [WCF], asynchronous operations\"\nms.assetid: db8a51cb-67e6-411b-9035-e5821ed350c9","nodes":[{"content":"Synchronous and Asynchronous Operations","nodes":[{"pos":[0,39],"content":"Synchronous and Asynchronous Operations","nodes":[{"content":"Synchronous and Asynchronous Operations","pos":[0,39]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[295,334],"content":"Synchronous and Asynchronous Operations","linkify":"Synchronous and Asynchronous Operations","nodes":[{"content":"Synchronous and Asynchronous Operations","pos":[0,39]}]},{"content":"This topic discusses implementing and calling asynchronous service operations.","pos":[335,413]},{"content":"Many applications call methods asynchronously because it enables the application to continue doing useful work while the method call runs.","pos":[420,558]},{"content":"Windows Communication Foundation (WCF) services and clients can participate in asynchronous operation calls at two distinct levels of the application, which provide WCF applications even more flexibility to maximize throughput balanced against interactivity.","pos":[559,817]},{"pos":[826,858],"content":"Types of Asynchronous Operations","linkify":"Types of Asynchronous Operations","nodes":[{"content":"Types of Asynchronous Operations","pos":[0,32]}]},{"content":"All service contracts in WCF, no matter the parameters types and return values, use WCF attributes to specify a particular message exchange pattern between client and service.","pos":[862,1037]},{"content":"WCF automatically routes inbound and outbound messages to the appropriate service operation or running client code.","pos":[1038,1153]},{"content":"The client possesses only the service contract, which specifies the message exchange pattern for a particular operation.","pos":[1160,1280]},{"content":"Clients can offer the developer any programming model they choose, so long as the underlying message exchange pattern is observed.","pos":[1281,1411]},{"content":"So, too, can services implement operations in any manner, so long as the specified message pattern is observed.","pos":[1412,1523]},{"content":"The independence of the service contract from either the service or client implementation enables the following forms of asynchronous execution in WCF applications:","pos":[1530,1694]},{"content":"Clients can invoke request/response operations asynchronously using a synchronous message exchange.","pos":[1704,1803]},{"content":"Services can implement a request/response operation asynchronously using a synchronous message exchange.","pos":[1813,1917]},{"content":"Message exchanges can be one-way, regardless of the implementation of the client or service.","pos":[1927,2019]},{"pos":[2029,2061],"content":"Suggested Asynchronous Scenarios","linkify":"Suggested Asynchronous Scenarios","nodes":[{"content":"Suggested Asynchronous Scenarios","pos":[0,32]}]},{"content":"Use an asynchronous approach in a service operation implementation if the operation service implementation makes a blocking call, such as doing I/O work.","pos":[2065,2218]},{"content":"When you are in an asynchronous operation implementation, try to call asynchronous operations and methods to extend the asynchronous call path as far as possible.","pos":[2219,2381]},{"content":"For example, call a <ph id=\"ph1\">`BeginOperationTwo()`</ph> from within <ph id=\"ph2\">`BeginOperationOne()`</ph>.","pos":[2382,2458],"source":" For example, call a `BeginOperationTwo()` from within `BeginOperationOne()`."},{"content":"Use an asynchronous approach in a client or calling application in the following cases:","pos":[2468,2555]},{"content":"If you are invoking operations from a middle-tier application.","pos":[2565,2627]},{"content":"(For more information about such scenarios, see <bpt id=\"p1\">[</bpt>Middle-Tier Client Applications<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)</ept>.)","pos":[2628,2791],"source":" (For more information about such scenarios, see [Middle-Tier Client Applications](../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md).)"},{"content":"If you are invoking operations within an ASP.NET page, use asynchronous pages.","pos":[2801,2879]},{"content":"If you are invoking operations from any application that is single threaded, such as Windows Forms or Windows Presentation Foundation (WPF).","pos":[2889,3029]},{"content":"When using the event-based asynchronous calling model, the result event is raised on the UI thread, adding responsiveness to the application without requiring you to handle multiple threads yourself.","pos":[3030,3229]},{"content":"In general, if you have a choice between a synchronous and asynchronous call, choose the asynchronous call.","pos":[3239,3346]},{"pos":[3356,3402],"content":"Implementing an Asynchronous Service Operation","linkify":"Implementing an Asynchronous Service Operation","nodes":[{"content":"Implementing an Asynchronous Service Operation","pos":[0,46]}]},{"content":"Asynchronous operations can be implemented by using one of the three following methods:","pos":[3406,3493]},{"content":"The task-based asynchronous pattern","pos":[3503,3538]},{"content":"The event-based asynchronous pattern","pos":[3548,3584]},{"content":"The IAsyncResult asynchronous pattern","pos":[3594,3631]},{"pos":[3642,3673],"content":"Task-Based Asynchronous Pattern","linkify":"Task-Based Asynchronous Pattern","nodes":[{"content":"Task-Based Asynchronous Pattern","pos":[0,31]}]},{"content":"The task-based asynchronous pattern is the preferred way to implement asynchronous operations because it is the easiest and most straight forward.","pos":[3677,3823]},{"content":"To use this method simply implement your service operation and specify a return type of Task<ph id=\"ph1\">\\&lt;</ph>T&gt;, where T is the type returned by the logical operation.","pos":[3824,3976],"source":" To use this method simply implement your service operation and specify a return type of Task\\<T>, where T is the type returned by the logical operation."},{"content":"For example:","pos":[3977,3989]},{"content":"The SampleMethodTaskAsync operation returns Task<ph id=\"ph1\">\\&lt;</ph>string&gt; because the logical operation returns a string.","pos":[4276,4381],"source":"The SampleMethodTaskAsync operation returns Task\\<string> because the logical operation returns a string."},{"content":"For more information about the task-based asynchronous pattern, see <bpt id=\"p1\">[</bpt>The Task-Based Asynchronous Pattern<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=232504)</ept>.","pos":[4382,4536],"source":" For more information about the task-based asynchronous pattern, see [The Task-Based Asynchronous Pattern](https://go.microsoft.com/fwlink/?LinkId=232504)."},{"pos":[4544,4773],"content":"[!WARNING]\n When using the task-based asynchronous pattern, a T:System.AggregateException may be thrown if an exception occurs while waiting on the completion of the operation. This exception may occur on the client or services","leadings":["","> "],"nodes":[{"content":"When using the task-based asynchronous pattern, a T:System.AggregateException may be thrown if an exception occurs while waiting on the completion of the operation. This exception may occur on the client or services","pos":[12,227],"nodes":[{"content":"When using the task-based asynchronous pattern, a T:System.AggregateException may be thrown if an exception occurs while waiting on the completion of the operation.","pos":[0,164]},{"content":"This exception may occur on the client or services","pos":[165,215]}]}]},{"pos":[4784,4816],"content":"Event-Based Asynchronous Pattern","linkify":"Event-Based Asynchronous Pattern","nodes":[{"content":"Event-Based Asynchronous Pattern","pos":[0,32]}]},{"content":"A service that supports the Event-based Asynchronous Pattern will have one or more operations named MethodNameAsync.","pos":[4820,4936]},{"content":"These methods may mirror synchronous versions, which perform the same operation on the current thread.","pos":[4937,5039]},{"content":"The class may also have a MethodNameCompleted event and it may have a MethodNameAsyncCancel (or simply CancelAsync) method.","pos":[5040,5163]},{"content":"A client wishing to call the operation will define an event handler to be called when the operation completes,","pos":[5164,5274]},{"content":"The following code snippet illustrates how to declare asynchronous operations using the event-based asynchronous pattern.","pos":[5281,5402]},{"pos":[6099,6255],"content":"For more information about the Event-based Asynchronous Pattern, see <bpt id=\"p1\">[</bpt>The Event-Based Asynchronous Pattern<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=232515)</ept>.","source":"For more information about the Event-based Asynchronous Pattern, see [The Event-Based Asynchronous Pattern](https://go.microsoft.com/fwlink/?LinkId=232515)."},{"pos":[6266,6299],"content":"IAsyncResult Asynchronous Pattern","linkify":"IAsyncResult Asynchronous Pattern","nodes":[{"content":"IAsyncResult Asynchronous Pattern","pos":[0,33]}]},{"content":"A service operation can be implemented in an asynchronous fashion using the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> asynchronous programming pattern and marking the <ph id=\"ph2\">`&lt;Begin&gt;`</ph> method with the <ph id=\"ph3\">&lt;xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A&gt;</ph> property set to <ph id=\"ph4\">`true`</ph>.","pos":[6303,6608],"source":"A service operation can be implemented in an asynchronous fashion using the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] asynchronous programming pattern and marking the `<Begin>` method with the <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> property set to `true`."},{"content":"In this case, the asynchronous operation is exposed in metadata in the same form as a synchronous operation: It is exposed as a single operation with a request message and a correlated response message.","pos":[6609,6811]},{"content":"Client programming models then have a choice.","pos":[6812,6857]},{"content":"They can represent this pattern as a synchronous operation or as an asynchronous one, so long as when the service is invoked a request-response message exchange takes place.","pos":[6858,7031]},{"content":"In general, with the asynchronous nature of the systems, you should not take a dependency on the threads.","pos":[7038,7143]},{"content":"The most reliable way of passing data to various stages of operation dispatch processing is to use extensions.","pos":[7145,7255]},{"pos":[7262,7419],"content":"For an example, see <bpt id=\"p1\">[</bpt>How to: Implement an Asynchronous Service Operation<ept id=\"p1\">](../../../docs/framework/wcf/how-to-implement-an-asynchronous-service-operation.md)</ept>.","source":"For an example, see [How to: Implement an Asynchronous Service Operation](../../../docs/framework/wcf/how-to-implement-an-asynchronous-service-operation.md)."},{"pos":[7426,7550],"content":"To define a contract operation <ph id=\"ph1\">`X`</ph> that is executed asynchronously regardless of how it is called in the client application:","source":"To define a contract operation `X` that is executed asynchronously regardless of how it is called in the client application:"},{"pos":[7560,7633],"content":"Define two methods using the pattern <ph id=\"ph1\">`BeginOperation`</ph> and <ph id=\"ph2\">`EndOperation`</ph>.","source":"Define two methods using the pattern `BeginOperation` and `EndOperation`."},{"pos":[7643,7771],"content":"The <ph id=\"ph1\">`BeginOperation`</ph> method includes <ph id=\"ph2\">`in`</ph> and <ph id=\"ph3\">`ref`</ph> parameters for the operation and returns an <ph id=\"ph4\">&lt;xref:System.IAsyncResult&gt;</ph> type.","source":"The `BeginOperation` method includes `in` and `ref` parameters for the operation and returns an <xref:System.IAsyncResult> type."},{"pos":[7781,7937],"content":"The <ph id=\"ph1\">`EndOperation`</ph> method includes an <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> parameter as well as the <ph id=\"ph3\">`out`</ph> and <ph id=\"ph4\">`ref`</ph> parameters and returns the operations return type.","source":"The `EndOperation` method includes an <xref:System.IAsyncResult> parameter as well as the `out` and `ref` parameters and returns the operations return type."},{"content":"For example, see the following method.","pos":[7944,7982]},{"content":"To create an asynchronous operation, the two methods would be:","pos":[8186,8248]},{"pos":[8938,9123],"content":"[!NOTE]\n The <xref:System.ServiceModel.OperationContractAttribute> attribute is applied only to the `BeginDoWork` method. The resulting contract has one WSDL operation named `DoWork`.","leadings":["","> "],"nodes":[{"content":"The <xref:System.ServiceModel.OperationContractAttribute> attribute is applied only to the `BeginDoWork` method. The resulting contract has one WSDL operation named `DoWork`.","pos":[9,183],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute is applied only to the <ph id=\"ph2\">`BeginDoWork`</ph> method.","pos":[0,112],"source":"The <xref:System.ServiceModel.OperationContractAttribute> attribute is applied only to the `BeginDoWork` method."},{"content":"The resulting contract has one WSDL operation named <ph id=\"ph1\">`DoWork`</ph>.","pos":[113,174],"source":" The resulting contract has one WSDL operation named `DoWork`."}]}]},{"pos":[9133,9169],"content":"Client-Side Asynchronous Invocations","linkify":"Client-Side Asynchronous Invocations","nodes":[{"content":"Client-Side Asynchronous Invocations","pos":[0,36]}]},{"content":"A WCF client application can use any of three asynchronous calling models described previously","pos":[9173,9267]},{"content":"When using the task-based model, simply call the operation using the await keyword as shown in the following code snippet.","pos":[9274,9396]},{"content":"Using the event-based asynchronous pattern only requires adding an event handler to receive a notification of the response -- and the resulting event is raised on the user interface thread automatically.","pos":[9485,9688]},{"content":"To use this approach, specify both the <bpt id=\"p1\">**</bpt>/async<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>/tcv:Version35<ept id=\"p2\">**</ept> command options with the <bpt id=\"p3\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p3\">](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>, as in the following example.","pos":[9689,9946],"source":" To use this approach, specify both the **/async** and **/tcv:Version35** command options with the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md), as in the following example."},{"content":"When this is done, Svcutil.exe generates a WCF client class with the event infrastructure that enables the calling application to implement and assign an event handler to receive the response and take the appropriate action.","pos":[10054,10278]},{"content":"For a complete example, see <bpt id=\"p1\">[</bpt>How to: Call Service Operations Asynchronously<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)</ept>.","pos":[10279,10454],"source":" For a complete example, see [How to: Call Service Operations Asynchronously](../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)."},{"content":"The event-based asynchronous model, however, is only available in <ph id=\"ph1\">[!INCLUDE[netfx35_long](../../../includes/netfx35-long-md.md)]</ph>.","pos":[10461,10590],"source":"The event-based asynchronous model, however, is only available in [!INCLUDE[netfx35_long](../../../includes/netfx35-long-md.md)]."},{"content":"In addition, it is not supported even in <ph id=\"ph1\">[!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)]</ph> when a WCF client channel is created by using a <ph id=\"ph2\">&lt;xref:System.ServiceModel.ChannelFactory%601?displayProperty=nameWithType&gt;</ph>.","pos":[10591,10820],"source":" In addition, it is not supported even in [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] when a WCF client channel is created by using a <xref:System.ServiceModel.ChannelFactory%601?displayProperty=nameWithType>."},{"content":"With WCF client channel objects, you must use <ph id=\"ph1\">&lt;xref:System.IAsyncResult?displayProperty=nameWithType&gt;</ph> objects to invoke your operations asynchronously.","pos":[10821,10972],"source":" With WCF client channel objects, you must use <xref:System.IAsyncResult?displayProperty=nameWithType> objects to invoke your operations asynchronously."},{"content":"To use this approach, specify the <bpt id=\"p1\">**</bpt>/async<ept id=\"p1\">**</ept> command option with the <bpt id=\"p2\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p2\">](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>, as in the following example.","pos":[10973,11201],"source":" To use this approach, specify the **/async** command option with the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md), as in the following example."},{"content":"This generates a service contract in which each operation is modeled as a <ph id=\"ph1\">`&lt;Begin&gt;`</ph> method with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A&gt;</ph> property set to <ph id=\"ph3\">`true`</ph> and a corresponding <ph id=\"ph4\">`&lt;End&gt;`</ph> method.","pos":[11295,11523],"source":"This generates a service contract in which each operation is modeled as a `<Begin>` method with the <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> property set to `true` and a corresponding `<End>` method."},{"content":"For a complete example using a <ph id=\"ph1\">&lt;xref:System.ServiceModel.ChannelFactory%601&gt;</ph>, see <bpt id=\"p1\">[</bpt>How to: Call Operations Asynchronously Using a Channel Factory<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/how-to-call-operations-asynchronously-using-a-channel-factory.md)</ept>.","pos":[11524,11781],"source":" For a complete example using a <xref:System.ServiceModel.ChannelFactory%601>, see [How to: Call Operations Asynchronously Using a Channel Factory](../../../docs/framework/wcf/feature-details/how-to-call-operations-asynchronously-using-a-channel-factory.md)."},{"content":"In either case, applications can invoke an operation asynchronously even if the service is implemented synchronously, in the same way that an application can use the same pattern to invoke asynchronously a local synchronous method.","pos":[11788,12019]},{"content":"How the operation is implemented is not significant to the client; when the response message arrives, its content is dispatched to the client's asynchronous &lt;<ph id=\"ph1\">`End`</ph>&gt; method and the client retrieves the information.","pos":[12020,12233],"source":" How the operation is implemented is not significant to the client; when the response message arrives, its content is dispatched to the client's asynchronous <`End`> method and the client retrieves the information."},{"pos":[12243,12276],"content":"One-Way Message Exchange Patterns","linkify":"One-Way Message Exchange Patterns","nodes":[{"content":"One-Way Message Exchange Patterns","pos":[0,33]}]},{"content":"You can also create an asynchronous message exchange pattern in which one-way operations (operations for which the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType&gt;</ph> is <ph id=\"ph2\">`true`</ph> have no correlated response) can be sent in either direction by the client or service independently of the other side.","pos":[12280,12618],"source":"You can also create an asynchronous message exchange pattern in which one-way operations (operations for which the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> is `true` have no correlated response) can be sent in either direction by the client or service independently of the other side."},{"content":"(This uses the duplex message exchange pattern with one-way messages.) In this case, the service contract specifies a one-way message exchange that either side can implement as asynchronous calls or implementations, or not, as appropriate.","pos":[12619,12858]},{"content":"Generally, when the contract is an exchange of one-way messages, the implementations can largely be asynchronous because once a message is sent the application does not wait for a reply and can continue doing other work.","pos":[12859,13079]},{"pos":[13089,13143],"content":"Event-based Asynchronous Clients and Message Contracts","linkify":"Event-based Asynchronous Clients and Message Contracts","nodes":[{"content":"Event-based Asynchronous Clients and Message Contracts","pos":[0,54]}]},{"content":"The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the <ph id=\"ph1\">`Result`</ph> property and the others are returned as properties on the <ph id=\"ph2\">&lt;xref:System.EventArgs&gt;</ph> object.","pos":[13147,13382],"source":"The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the `Result` property and the others are returned as properties on the <xref:System.EventArgs> object."},{"content":"One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> object returns one value as the <ph id=\"ph2\">`Result`</ph> property and the remainder are properties of the <ph id=\"ph3\">&lt;xref:System.EventArgs&gt;</ph> object.","pos":[13383,13694],"source":" One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <xref:System.EventArgs> object returns one value as the `Result` property and the remainder are properties of the <xref:System.EventArgs> object."},{"content":"If you want to receive the message object as the <ph id=\"ph1\">`Result`</ph> property and have the returned values as properties on that object, use the <bpt id=\"p1\">**</bpt>/messageContract<ept id=\"p1\">**</ept> command option.","pos":[13701,13871],"source":"If you want to receive the message object as the `Result` property and have the returned values as properties on that object, use the **/messageContract** command option."},{"content":"This generates a signature that returns the response message as the <ph id=\"ph1\">`Result`</ph> property on the <ph id=\"ph2\">&lt;xref:System.EventArgs&gt;</ph> object.","pos":[13872,13996],"source":" This generates a signature that returns the response message as the `Result` property on the <xref:System.EventArgs> object."},{"content":"All internal return values are then properties of the response message object.","pos":[13997,14075]},{"pos":[14084,14092],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]}]}