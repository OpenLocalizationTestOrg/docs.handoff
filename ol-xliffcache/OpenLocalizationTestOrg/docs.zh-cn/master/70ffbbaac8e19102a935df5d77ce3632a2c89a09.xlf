<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="type-conversion-functions.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">70ffbbaac8e19102a935df5d77ce3632a2c89a09</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\language-reference\functions\type-conversion-functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">957f13afe640eeb373106a730b82e84bdc828687</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f49571f967c74e24287d6399a566b5a5e7a76b02</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Type Conversion Functions (Visual Basic) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Type Conversion Functions (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>These functions are compiled inline, meaning the conversion code is part of the code that evaluates the expression.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Sometimes there is no call to a procedure to accomplish the conversion, which improves performance.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Each function coerces an expression to a specific data type.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Part</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Required.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Any expression of the source data type.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Return Value Data Type</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The function name determines the data type of the value it returns, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Function name</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Return data type</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Range for <ph id="ph1">`expression`</ph> argument</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Any valid <ph id="ph1">`Char`</ph> or <ph id="ph2">`String`</ph> or numeric expression.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Byte Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/byte-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>0 through 255 (unsigned); fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Char Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/char-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Any valid <ph id="ph1">`Char`</ph> or <ph id="ph2">`String`</ph> expression; only first character of a <ph id="ph3">`String`</ph> is converted; value can be 0 through 65535 (unsigned).</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Date Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/date-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Any valid representation of a date and time.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Double Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/double-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>-1.79769313486231570E+308 through -4.94065645841246544E-324 for negative values; 4.94065645841246544E-324 through 1.79769313486231570E+308 for positive values.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Decimal Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>+/-79,228,162,514,264,337,593,543,950,335 for zero-scaled numbers, that is, numbers with no decimal places.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For numbers with 28 decimal places, the range is +/-7.9228162514264337593543950335.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The smallest possible non-zero number is 0.0000000000000000000000000001 (+/-1E-28).</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Integer Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/integer-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-2,147,483,648 through 2,147,483,647; fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Long Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/long-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>-9,223,372,036,854,775,808 through 9,223,372,036,854,775,807; fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Object Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/object-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Any valid expression.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>SByte Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/sbyte-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>-128 through 127; fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Short Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/short-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>-32,768 through 32,767; fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Single Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/single-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>-3.402823E+38 through -1.401298E-45 for negative values; 1.401298E-45 through 3.402823E+38 for positive values.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/string-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Returns for <ph id="ph1">`CStr`</ph> depend on the <ph id="ph2">`expression`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Return Values for the CStr Function<ept id="p1">](../../../visual-basic/language-reference/functions/return-values-for-the-cstr-function.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UInteger Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/uinteger-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>0 through 4,294,967,295 (unsigned); fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ULong Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/ulong-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>0 through 18,446,744,073,709,551,615 (unsigned); fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>UShort Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/ushort-data-type.md)</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>0 through 65,535 (unsigned); fractional parts are rounded.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> Fractional parts can be subject to a special type of rounding called <bpt id="p2">*</bpt>banker's rounding<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>See "Remarks" for more information.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>As a rule, you should use the Visual Basic type conversion functions in preference to the .NET Framework methods such as <ph id="ph1">`ToString()`</ph>, either on the <ph id="ph2">&lt;xref:System.Convert&gt;</ph> class or on an individual type structure or class.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The Visual Basic functions are designed for optimal interaction with Visual Basic code, and they also make your source code shorter and easier to read.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In addition, the .NET Framework conversion methods do not always produce the same results as the Visual Basic functions, for example when converting <ph id="ph1">`Boolean`</ph> to <ph id="ph2">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Troubleshooting Data Types<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Behavior</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Coercion.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In general, you can use the data type conversion functions to coerce the result of an operation to a particular data type rather than the default data type.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, use <ph id="ph1">`CDec`</ph> to force decimal arithmetic in cases where single-precision, double-precision, or integer arithmetic would normally take place.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Failed Conversions.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`expression`</ph> passed to the function is outside the range of the data type to which it is to be converted, an <ph id="ph2">&lt;xref:System.OverflowException&gt;</ph> occurs.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Fractional Parts.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When you convert a nonintegral value to an integral type, the integer conversion functions (<ph id="ph1">`CByte`</ph>, <ph id="ph2">`CInt`</ph>, <ph id="ph3">`CLng`</ph>, <ph id="ph4">`CSByte`</ph>, <ph id="ph5">`CShort`</ph>, <ph id="ph6">`CUInt`</ph>, <ph id="ph7">`CULng`</ph>, and <ph id="ph8">`CUShort`</ph>) remove the fractional part and round the value to the closest integer.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If the fractional part is exactly 0.5, the integer conversion functions round it to the nearest even integer.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For example, 0.5 rounds to 0, and 1.5 and 2.5 both round to 2.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This is sometimes called <bpt id="p1">*</bpt>banker's rounding<ept id="p1">*</ept>, and its purpose is to compensate for a bias that could accumulate when adding many such numbers together.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CInt`</ph> and <ph id="ph2">`CLng`</ph> differ from the <ph id="ph3">&lt;xref:Microsoft.VisualBasic.Conversion.Int%2A&gt;</ph> and <ph id="ph4">&lt;xref:Microsoft.VisualBasic.Conversion.Fix%2A&gt;</ph> functions, which truncate, rather than round, the fractional part of a number.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Also, <ph id="ph1">`Fix`</ph> and <ph id="ph2">`Int`</ph> always return a value of the same data type as you pass in.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Date/Time Conversions.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Information.IsDate%2A&gt;</ph> function to determine if a value can be converted to a date and time.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CDate`</ph> recognizes date literals and time literals but not numeric values.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>To convert a Visual Basic 6.0 <ph id="ph1">`Date`</ph> value to a <ph id="ph2">`Date`</ph> value in Visual Basic 2005 or later versions, you can use the <ph id="ph3">&lt;xref:System.DateTime.FromOADate%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Neutral Date/Time Values.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Date Data Type<ept id="p1">](../../../visual-basic/language-reference/data-types/date-data-type.md)</ept> always contains both date and time information.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For purposes of type conversion, Visual Basic considers 1/1/0001 (January 1 of the year 1) to be a <bpt id="p1">*</bpt>neutral value<ept id="p1">*</ept> for the date, and 00:00:00 (midnight) to be a neutral value for the time.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If you convert a <ph id="ph1">`Date`</ph> value to a string, <ph id="ph2">`CStr`</ph> does not include neutral values in the resulting string.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, if you convert <ph id="ph1">`#January 1, 0001 9:30:00#`</ph> to a string, the result is "9:30:00 AM"; the date information is suppressed.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>However, the date information is still present in the original <ph id="ph1">`Date`</ph> value and can be recovered with functions such as <ph id="ph2">&lt;xref:Microsoft.VisualBasic.DateAndTime.DatePart%2A&gt;</ph> function.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Culture Sensitivity.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The type conversion functions involving strings perform conversions based on the current culture settings for the application.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`CDate`</ph> recognizes date formats according to the locale setting of your system.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You must provide the day, month, and year in the correct order for your locale, or the date might not be interpreted correctly.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A long date format is not recognized if it contains a day-of-the-week string, such as "Wednesday".</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>If you need to convert to or from a string representation of a value in a format other than the one specified by your locale, you cannot use the Visual Basic type conversion functions.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To do this, use the <ph id="ph1">`ToString(IFormatProvider)`</ph> and <ph id="ph2">`Parse(String, IFormatProvider)`</ph> methods of that value's type.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>For example, use <ph id="ph1">&lt;xref:System.Double.Parse%2A?displayProperty=fullName&gt;</ph> when converting a string to a <ph id="ph2">`Double`</ph>, and use <ph id="ph3">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> when converting a value of type <ph id="ph4">`Double`</ph> to a string.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>CType Function</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>CType Function<ept id="p1">](../../../visual-basic/language-reference/functions/ctype-function.md)</ept> takes a second argument, <ph id="ph1">`typename`</ph>, and coerces <ph id="ph2">`expression`</ph> to <ph id="ph3">`typename`</ph>, where <ph id="ph4">`typename`</ph> can be any data type, structure, class, or interface to which there exists a valid conversion.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For a comparison of <ph id="ph1">`CType`</ph> with the other type conversion keywords, see <bpt id="p1">[</bpt>DirectCast Operator<ept id="p1">](../../../visual-basic/language-reference/operators/directcast-operator.md)</ept> and <bpt id="p2">[</bpt>TryCast Operator<ept id="p2">](../../../visual-basic/language-reference/operators/trycast-operator.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>CBool Example</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CBool`</ph> function to convert expressions to <ph id="ph2">`Boolean`</ph> values.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>If an expression evaluates to a nonzero value, <ph id="ph1">`CBool`</ph> returns <ph id="ph2">`True`</ph>; otherwise, it returns <ph id="ph3">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>CByte Example</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CByte`</ph> function to convert an expression to a <ph id="ph2">`Byte`</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>CChar Example</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CChar`</ph> function to convert the first character of a <ph id="ph2">`String`</ph> expression to a <ph id="ph3">`Char`</ph> type.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The input argument to <ph id="ph1">`CChar`</ph> must be of data type <ph id="ph2">`Char`</ph> or <ph id="ph3">`String`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You cannot use <ph id="ph1">`CChar`</ph> to convert a number to a character, because <ph id="ph2">`CChar`</ph> cannot accept a numeric data type.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The following example obtains a number representing a code point (character code) and converts it to the corresponding character.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>It uses the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Interaction.InputBox%2A&gt;</ph> function to obtain the string of digits, <ph id="ph2">`CInt`</ph> to convert the string to type <ph id="ph3">`Integer`</ph>, and <ph id="ph4">`ChrW`</ph> to convert the number to type <ph id="ph5">`Char`</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>CDate Example</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CDate`</ph> function to convert strings to <ph id="ph2">`Date`</ph> values.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In general, hard-coding dates and times as strings (as shown in this example) is not recommended.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Use date literals and time literals, such as #Feb 12, 1969# and #4:45:23 PM#, instead.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>CDbl Example</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>CDec Example</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CDec`</ph> function to convert a numeric value to <ph id="ph2">`Decimal`</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>CInt Example</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CInt`</ph> function to convert a value to <ph id="ph2">`Integer`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>CLng Example</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CLng`</ph> function to convert values to <ph id="ph2">`Long`</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>CObj Example</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CObj`</ph> function to convert a numeric value to <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Object`</ph> variable itself contains only a four-byte pointer, which points to the <ph id="ph2">`Double`</ph> value assigned to it.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>CSByte Example</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CSByte`</ph> function to convert a numeric value to <ph id="ph2">`SByte`</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>CShort Example</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CShort`</ph> function to convert a numeric value to <ph id="ph2">`Short`</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>CSng Example</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CSng`</ph> function to convert values to <ph id="ph2">`Single`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>CStr Example</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CStr`</ph> function to convert a numeric value to <ph id="ph2">`String`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CStr`</ph> function to convert <ph id="ph2">`Date`</ph> values to <ph id="ph3">`String`</ph> values.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CStr`</ph> always renders a <ph id="ph2">`Date`</ph> value in the standard short format for the current locale, for example, "6/15/2003 4:35:47 PM".</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">`CStr`</ph> suppresses the <bpt id="p1">*</bpt>neutral values<ept id="p1">*</ept> of 1/1/0001 for the date and 00:00:00 for the time.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>For more detail on the values returned by <ph id="ph1">`CStr`</ph>, see <bpt id="p1">[</bpt>Return Values for the CStr Function<ept id="p1">](../../../visual-basic/language-reference/functions/return-values-for-the-cstr-function.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>CUInt Example</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CUInt`</ph> function to convert a numeric value to <ph id="ph2">`UInteger`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>CULng Example</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CULng`</ph> function to convert a numeric value to <ph id="ph2">`ULong`</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>CUShort Example</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`CUShort`</ph> function to convert a numeric value to <ph id="ph2">`UShort`</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Strings.Asc%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Strings.AscW%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Strings.Chr%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Strings.ChrW%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.Int%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.Fix%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Strings.Format%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.Hex%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.Oct%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.Str%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.Val%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Conversion Functions<ept id="p1">](../../../visual-basic/language-reference/functions/conversion-functions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Type Conversions in Visual Basic<ept id="p1">](../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>