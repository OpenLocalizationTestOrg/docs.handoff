{"content":"---\ntitle: \"Creating a Class to Hold DLL Functions\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"COM interop, DLL functions\"\n  - \"unmanaged functions\"\n  - \"COM interop, platform invoke\"\n  - \"interoperation with unmanaged code, DLL functions\"\n  - \"interoperation with unmanaged code, platform invoke\"\n  - \"platform invoke, creating class for functions\"\n  - \"DLL functions\"\nms.assetid: e08e4c34-0223-45f7-aa55-a3d8dd979b0f\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Creating a Class to Hold DLL Functions\nWrapping a frequently used DLL function in a managed class is an effective approach to encapsulate platform functionality. Although it is not mandatory to do so in every case, providing a class wrapper is convenient because defining DLL functions can be cumbersome and error-prone. If you are programming in Visual Basic or C#, you must declare DLL functions within a class or Visual Basic module.  \n  \n Within a class, you define a static method for each DLL function you want to call. The definition can include additional information, such as the character set or the calling convention used in passing method arguments; by omitting this information, you select the default settings. For a complete list of declaration options and their default settings, see [Creating Prototypes in Managed Code](../../../docs/framework/interop/creating-prototypes-in-managed-code.md).  \n  \n Once wrapped, you can call the methods on the class as you call static methods on any other class. Platform invoke handles the underlying exported function automatically.  \n  \n When designing a managed class for platform invoke, consider the relationships between classes and DLL functions. For example, you can:  \n  \n-   Declare DLL functions within an existing class.  \n  \n-   Create an individual class for each DLL function, keeping functions isolated and easy to find.  \n  \n-   Create one class for a set of related DLL functions to form logical groupings and reduce overhead.  \n  \n You can name the class and its methods as you please. For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see [Marshaling Data with Platform Invoke](../../../docs/framework/interop/marshaling-data-with-platform-invoke.md).  \n  \n## See also\n\n- [Consuming Unmanaged DLL Functions](../../../docs/framework/interop/consuming-unmanaged-dll-functions.md)\n- [Identifying Functions in DLLs](../../../docs/framework/interop/identifying-functions-in-dlls.md)\n- [Creating Prototypes in Managed Code](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)\n- [Calling a DLL Function](../../../docs/framework/interop/calling-a-dll-function.md)\n","nodes":[{"pos":[4,464],"embed":true,"restype":"x-metadata","content":"title: \"Creating a Class to Hold DLL Functions\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"COM interop, DLL functions\"\n  - \"unmanaged functions\"\n  - \"COM interop, platform invoke\"\n  - \"interoperation with unmanaged code, DLL functions\"\n  - \"interoperation with unmanaged code, platform invoke\"\n  - \"platform invoke, creating class for functions\"\n  - \"DLL functions\"\nms.assetid: e08e4c34-0223-45f7-aa55-a3d8dd979b0f\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Creating a Class to Hold DLL Functions","nodes":[{"pos":[0,38],"content":"Creating a Class to Hold DLL Functions","nodes":[{"content":"Creating a Class to Hold DLL Functions","pos":[0,38]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[471,509],"content":"Creating a Class to Hold DLL Functions","linkify":"Creating a Class to Hold DLL Functions","nodes":[{"content":"Creating a Class to Hold DLL Functions","pos":[0,38]}]},{"content":"Wrapping a frequently used DLL function in a managed class is an effective approach to encapsulate platform functionality.","pos":[510,632]},{"content":"Although it is not mandatory to do so in every case, providing a class wrapper is convenient because defining DLL functions can be cumbersome and error-prone.","pos":[633,791]},{"content":"If you are programming in Visual Basic or C#, you must declare DLL functions within a class or Visual Basic module.","pos":[792,907]},{"content":"Within a class, you define a static method for each DLL function you want to call.","pos":[914,996]},{"content":"The definition can include additional information, such as the character set or the calling convention used in passing method arguments; by omitting this information, you select the default settings.","pos":[997,1196]},{"content":"For a complete list of declaration options and their default settings, see <bpt id=\"p1\">[</bpt>Creating Prototypes in Managed Code<ept id=\"p1\">](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)</ept>.","pos":[1197,1382],"source":" For a complete list of declaration options and their default settings, see [Creating Prototypes in Managed Code](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)."},{"content":"Once wrapped, you can call the methods on the class as you call static methods on any other class.","pos":[1389,1487]},{"content":"Platform invoke handles the underlying exported function automatically.","pos":[1488,1559]},{"content":"When designing a managed class for platform invoke, consider the relationships between classes and DLL functions.","pos":[1566,1679]},{"content":"For example, you can:","pos":[1680,1701]},{"content":"Declare DLL functions within an existing class.","pos":[1711,1758]},{"content":"Create an individual class for each DLL function, keeping functions isolated and easy to find.","pos":[1768,1862]},{"content":"Create one class for a set of related DLL functions to form logical groupings and reduce overhead.","pos":[1872,1970]},{"content":"You can name the class and its methods as you please.","pos":[1977,2030]},{"content":"For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see <bpt id=\"p1\">[</bpt>Marshaling Data with Platform Invoke<ept id=\"p1\">](../../../docs/framework/interop/marshaling-data-with-platform-invoke.md)</ept>.","pos":[2031,2251],"source":" For examples that demonstrate how to construct .NET-based declarations to be used with platform invoke, see [Marshaling Data with Platform Invoke](../../../docs/framework/interop/marshaling-data-with-platform-invoke.md)."},{"pos":[2260,2268],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2272,2377],"content":"<bpt id=\"p1\">[</bpt>Consuming Unmanaged DLL Functions<ept id=\"p1\">](../../../docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>","source":"[Consuming Unmanaged DLL Functions](../../../docs/framework/interop/consuming-unmanaged-dll-functions.md)"},{"pos":[2380,2477],"content":"<bpt id=\"p1\">[</bpt>Identifying Functions in DLLs<ept id=\"p1\">](../../../docs/framework/interop/identifying-functions-in-dlls.md)</ept>","source":"[Identifying Functions in DLLs](../../../docs/framework/interop/identifying-functions-in-dlls.md)"},{"pos":[2480,2589],"content":"<bpt id=\"p1\">[</bpt>Creating Prototypes in Managed Code<ept id=\"p1\">](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)</ept>","source":"[Creating Prototypes in Managed Code](../../../docs/framework/interop/creating-prototypes-in-managed-code.md)"},{"pos":[2592,2675],"content":"<bpt id=\"p1\">[</bpt>Calling a DLL Function<ept id=\"p1\">](../../../docs/framework/interop/calling-a-dll-function.md)</ept>","source":"[Calling a DLL Function](../../../docs/framework/interop/calling-a-dll-function.md)"}]}