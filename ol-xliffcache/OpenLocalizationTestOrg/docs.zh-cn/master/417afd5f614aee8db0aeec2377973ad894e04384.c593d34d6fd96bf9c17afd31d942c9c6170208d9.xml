{"content":"---\ntitle: \"Modifying Large-Value (max) Data in ADO.NET\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 8aca5f00-d80e-4320-81b3-016d0466f7ee\n---\n# Modifying Large-Value (max) Data in ADO.NET\nLarge object (LOB) data types are those that exceed the maximum row size of 8 kilobytes (KB). SQL Server provides a `max` specifier for `varchar`, `nvarchar`, and `varbinary` data types to allow storage of values as large as 2^32 bytes. Table columns and Transact-SQL variables may specify `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types. In ADO.NET, the `max` data types can be fetched by a `DataReader`, and can also be specified as both input and output parameter values without any special handling. For large `varchar` data types, data can be retrieved and updated incrementally.  \n  \n The `max` data types can be used for comparisons, as Transact-SQL variables, and for concatenation. They can also be used in the DISTINCT, ORDER BY, GROUP BY clauses of a SELECT statement as well as in aggregates, joins, and subqueries.  \n  \n The following table provides links to the documentation in SQL Server Books Online.  \n  \n **SQL Server Books Online**  \n  \n1.  [Using Large-Value Data Types](https://go.microsoft.com/fwlink/?LinkId=120498)  \n  \n## Large-Value Type Restrictions  \n The following restrictions apply to the `max` data types, which do not exist for smaller data types:  \n  \n-   A `sql_variant` cannot contain a large `varchar` data type.  \n  \n-   Large `varchar` columns cannot be specified as a key column in an index. They are allowed in an included column in a non-clustered index.  \n  \n-   Large `varchar` columns cannot be used as partitioning key columns.  \n  \n## Working with Large-Value Types in Transact-SQL  \n The Transact-SQL `OPENROWSET` function is a one-time method of connecting and accessing remote data. It includes all of the connection information necessary to access remote data from an OLE DB data source. `OPENROWSET` can be referenced in the FROM clause of a query as though it were a table name. It can also be referenced as the target table of an INSERT, UPDATE, or DELETE statement, subject to the capabilities of the OLE DB provider.  \n  \n The `OPENROWSET` function includes the `BULK` rowset provider, which allows you to read data directly from a file without loading the data into a target table. This enables you to use `OPENROWSET` in a simple INSERT SELECT statement.  \n  \n The `OPENROWSET BULK` option arguments provide significant control over where to begin and end reading data, how to deal with errors, and how data is interpreted. For example, you can specify that the data file be read as a single-row, single-column rowset of type `varbinary`, `varchar`, or `nvarchar`. For the complete syntax and options, see SQL Server Books Online.  \n  \n The following example inserts a photo into the ProductPhoto table in the AdventureWorks sample database. When using the `BULK OPENROWSET` provider, you must supply the named list of columns even if you aren't inserting values into every column. The primary key in this case is defined as an identity column, and may be omitted from the column list. Note that you must also supply a correlation name at the end of the `OPENROWSET` statement, which in this case is ThumbnailPhoto. This correlates with the column in the `ProductPhoto` table into which the file is being loaded.  \n  \n```  \nINSERT Production.ProductPhoto (  \n    ThumbnailPhoto,   \n    ThumbnailPhotoFilePath,   \n    LargePhoto,   \n    LargePhotoFilePath)  \nSELECT ThumbnailPhoto.*, null, null, N'tricycle_pink.gif'  \nFROM OPENROWSET   \n    (BULK 'c:\\images\\tricycle.jpg', SINGLE_BLOB) ThumbnailPhoto  \n```  \n  \n## Updating Data Using UPDATE .WRITE  \n The Transact-SQL UPDATE statement has new WRITE syntax for modifying the contents of `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` columns. This allows you to perform partial updates of the data. The UPDATE .WRITE syntax is shown here in abbreviated form:  \n  \n UPDATE  \n  \n { *\\<object>* }  \n  \n SET  \n  \n { *column_name* = { .WRITE ( *expression* , @Offset , @Length ) }  \n  \n The WRITE method specifies that a section of the value of the *column_name* will be modified. The expression is the value that will be copied to the *column_name*, the `@Offset` is the beginning point at which the expression will be written, and the `@Length` argument is the length of the section in the column.  \n  \n|If|Then|  \n|--------|----------|  \n|The expression is set to NULL|`@Length` is ignored and the value in *column_name* is truncated at the specified `@Offset`.|  \n|`@Offset` is NULL|The update operation appends the expression at the end of the existing *column_name* value and `@Length` is ignored.|  \n|`@Offset` is greater than the length of the column_name value|SQL Server returns an error.|  \n|`@Length` is NULL|The update operation removes all data from `@Offset` to the end of the `column_name` value.|  \n  \n> [!NOTE]\n>  Neither `@Offset` nor `@Length` can be a negative number.  \n  \n## Example  \n This Transact-SQL example updates a partial value in DocumentSummary, an `nvarchar(max)` column in the Document table in the AdventureWorks database. The word 'components' is replaced by the word 'features' by specifying the replacement word, the beginning location (offset) of the word to be replaced in the existing data, and the number of characters to be replaced (length). The example includes SELECT statements before and after the UPDATE statement to compare results.  \n  \n```  \nUSE AdventureWorks;  \nGO  \n--View the existing value.  \nSELECT DocumentSummary  \nFROM Production.Document  \nWHERE DocumentID = 3;  \nGO  \n-- The first sentence of the results will be:  \n-- Reflectors are vital safety components of your bicycle.  \n  \n--Modify a single word in the DocumentSummary column  \nUPDATE Production.Document  \nSET DocumentSummary .WRITE (N'features',28,10)  \nWHERE DocumentID = 3 ;  \nGO   \n--View the modified value.  \nSELECT DocumentSummary  \nFROM Production.Document  \nWHERE DocumentID = 3;  \nGO  \n-- The first sentence of the results will be:  \n-- Reflectors are vital safety features of your bicycle.  \n```  \n  \n## Working with Large-Value Types in ADO.NET  \n You can work with large value types in ADO.NET by specifying large value types as <xref:System.Data.SqlClient.SqlParameter> objects in a <xref:System.Data.SqlClient.SqlDataReader> to return a result set, or by using a <xref:System.Data.SqlClient.SqlDataAdapter> to fill a `DataSet`/`DataTable`. There is no difference between the way you work with a large value type and its related, smaller value data type.  \n  \n### Using GetSqlBytes to Retrieve Data  \n The `GetSqlBytes` method of the <xref:System.Data.SqlClient.SqlDataReader> can be used to retrieve the contents of a `varbinary(max)` column. The following code fragment assumes a <xref:System.Data.SqlClient.SqlCommand> object named `cmd` that selects `varbinary(max)` data from a table and a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data as <xref:System.Data.SqlTypes.SqlBytes>.  \n  \n```vb  \nreader = cmd.ExecuteReader(CommandBehavior.CloseConnection)  \nWhile reader.Read()  \n    Dim bytes As SqlBytes = reader.GetSqlBytes(0)  \nEnd While  \n```  \n  \n```csharp  \nreader = cmd.ExecuteReader(CommandBehavior.CloseConnection);  \nwhile (reader.Read())  \n    {  \n        SqlBytes bytes = reader.GetSqlBytes(0);  \n    }  \n```  \n  \n### Using GetSqlChars to Retrieve Data  \n The `GetSqlChars` method of the <xref:System.Data.SqlClient.SqlDataReader> can be used to retrieve the contents of a `varchar(max)` or `nvarchar(max)` column. The following code fragment assumes a <xref:System.Data.SqlClient.SqlCommand> object named `cmd` that selects `nvarchar(max)` data from a table and a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data.  \n  \n```vb  \nreader = cmd.ExecuteReader(CommandBehavior.CloseConnection)  \nWhile reader.Read()  \n    Dim buffer As SqlChars = reader.GetSqlChars(0)  \nEnd While  \n```  \n  \n```csharp  \nreader = cmd.ExecuteReader(CommandBehavior.CloseConnection);  \nwhile (reader.Read())  \n{  \n    SqlChars buffer = reader.GetSqlChars(0);  \n}  \n```  \n  \n### Using GetSqlBinary to Retrieve Data  \n The `GetSqlBinary` method of a <xref:System.Data.SqlClient.SqlDataReader> can be used to retrieve the contents of a `varbinary(max)` column. The following code fragment assumes a <xref:System.Data.SqlClient.SqlCommand> object named `cmd` that selects `varbinary(max)` data from a table and a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data as a <xref:System.Data.SqlTypes.SqlBinary> stream.  \n  \n```vb  \nreader = cmd.ExecuteReader(CommandBehavior.CloseConnection)  \nWhile reader.Read()  \n    Dim binaryStream As SqlBinary = reader.GetSqlBinary(0)  \nEnd While  \n```  \n  \n```csharp  \nreader = cmd.ExecuteReader(CommandBehavior.CloseConnection);  \nwhile (reader.Read())  \n    {  \n        SqlBinary binaryStream = reader.GetSqlBinary(0);  \n    }  \n```  \n  \n### Using GetBytes to Retrieve Data  \n The `GetBytes` method of a <xref:System.Data.SqlClient.SqlDataReader> reads a stream of bytes from the specified column offset into a byte array starting at the specified array offset. The following code fragment assumes a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves bytes into a byte array. Note that, unlike `GetSqlBytes`, `GetBytes` requires a size for the array buffer.  \n  \n```vb  \nWhile reader.Read()  \n    Dim buffer(4000) As Byte  \n    Dim byteCount As Integer = _  \n    CInt(reader.GetBytes(1, 0, buffer, 0, 4000))  \nEnd While  \n```  \n  \n```csharp  \nwhile (reader.Read())  \n{  \n    byte[] buffer = new byte[4000];  \n    long byteCount = reader.GetBytes(1, 0, buffer, 0, 4000);  \n}  \n```  \n  \n### Using GetValue to Retrieve Data  \n The `GetValue` method of a <xref:System.Data.SqlClient.SqlDataReader> reads the value from the specified column offset into an array. The following code fragment assumes a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves binary data from the first column offset, and then string data from the second column offset.  \n  \n```vb  \nWhile reader.Read()  \n    ' Read the data from varbinary(max) column  \n    Dim binaryData() As Byte = CByte(reader.GetValue(0))  \n  \n    ' Read the data from varchar(max) or nvarchar(max) column  \n    Dim stringData() As String = Cstr((reader.GetValue(1))  \nEnd While  \n```  \n  \n```csharp  \nwhile (reader.Read())  \n{  \n    // Read the data from varbinary(max) column  \n    byte[] binaryData = (byte[])reader.GetValue(0);  \n  \n    // Read the data from varchar(max) or nvarchar(max) column  \n    String stringData = (String)reader.GetValue(1);  \n}  \n```  \n  \n## Converting from Large Value Types to CLR Types  \n You can convert the contents of a `varchar(max)` or `nvarchar(max)` column using any of the string conversion methods, such as `ToString`. The following code fragment assumes a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data.  \n  \n```vb  \nWhile reader.Read()  \n    Dim str as String = reader(0).ToString()  \n    Console.WriteLine(str)  \nEnd While  \n```  \n  \n```csharp  \nwhile (reader.Read())  \n{  \n     string str = reader[0].ToString();  \n     Console.WriteLine(str);  \n}  \n```  \n  \n### Example  \n The following code retrieves the name and the `LargePhoto` object from the `ProductPhoto` table in the `AdventureWorks` database and saves it to a file. The assembly needs to be compiled with a reference to the <xref:System.Drawing> namespace.  The <xref:System.Data.SqlClient.SqlDataReader.GetSqlBytes%2A> method of the <xref:System.Data.SqlClient.SqlDataReader> returns a <xref:System.Data.SqlTypes.SqlBytes> object that exposes a `Stream` property. The code uses this to create a new `Bitmap` object, and then saves it in the Gif `ImageFormat`.  \n  \n [!code-csharp[DataWorks LargeValueType.Photo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks LargeValueType.Photo/CS/source.cs#1)]\n [!code-vb[DataWorks LargeValueType.Photo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks LargeValueType.Photo/VB/source.vb#1)]  \n  \n## Using Large Value Type Parameters  \n Large value types can be used in <xref:System.Data.SqlClient.SqlParameter> objects the same way you use smaller value types in <xref:System.Data.SqlClient.SqlParameter> objects. You can retrieve large value types as <xref:System.Data.SqlClient.SqlParameter> values, as shown in the following example. The code assumes that the following GetDocumentSummary stored procedure exists in the AdventureWorks sample database. The stored procedure takes an input parameter named @DocumentID and returns the contents of the DocumentSummary column in the @DocumentSummary output parameter.  \n  \n```  \nCREATE PROCEDURE GetDocumentSummary   \n(  \n    @DocumentID int,  \n    @DocumentSummary nvarchar(MAX) OUTPUT  \n)  \nAS  \nSET NOCOUNT ON  \nSELECT  @DocumentSummary=Convert(nvarchar(MAX), DocumentSummary)  \nFROM    Production.Document  \nWHERE   DocumentID=@DocumentID  \n```  \n  \n### Example  \n The ADO.NET code creates <xref:System.Data.SqlClient.SqlConnection> and <xref:System.Data.SqlClient.SqlCommand> objects to execute the GetDocumentSummary stored procedure and retrieve the document summary, which is stored as a large value type. The code passes a value for the @DocumentID input parameter, and displays the results passed back in the @DocumentSummary output parameter in the Console window.  \n  \n [!code-csharp[DataWorks LargeValueType.Param#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks LargeValueType.Param/CS/source.cs#1)]\n [!code-vb[DataWorks LargeValueType.Param#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks LargeValueType.Param/VB/source.vb#1)]  \n  \n## See also\n\n- [SQL Server Binary and Large-Value Data](../../../../../docs/framework/data/adonet/sql/sql-server-binary-and-large-value-data.md)\n- [SQL Server Data Type Mappings](../../../../../docs/framework/data/adonet/sql-server-data-type-mappings.md)\n- [SQL Server Data Operations in ADO.NET](../../../../../docs/framework/data/adonet/sql/sql-server-data-operations.md)\n- [ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)\n","nodes":[{"pos":[4,161],"embed":true,"restype":"x-metadata","content":"title: \"Modifying Large-Value (max) Data in ADO.NET\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 8aca5f00-d80e-4320-81b3-016d0466f7ee","nodes":[{"content":"Modifying Large-Value (max) Data in ADO.NET","nodes":[{"pos":[0,43],"content":"Modifying Large-Value (max) Data in ADO.NET","nodes":[{"content":"Modifying Large-Value (max) Data in ADO.NET","pos":[0,43]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[168,211],"content":"Modifying Large-Value (max) Data in ADO.NET","linkify":"Modifying Large-Value (max) Data in ADO.NET","nodes":[{"content":"Modifying Large-Value (max) Data in ADO.NET","pos":[0,43]}]},{"content":"Large object (LOB) data types are those that exceed the maximum row size of 8 kilobytes (KB).","pos":[212,305]},{"content":"SQL Server provides a <ph id=\"ph1\">`max`</ph> specifier for <ph id=\"ph2\">`varchar`</ph>, <ph id=\"ph3\">`nvarchar`</ph>, and <ph id=\"ph4\">`varbinary`</ph> data types to allow storage of values as large as 2^32 bytes.","pos":[306,448],"source":" SQL Server provides a `max` specifier for `varchar`, `nvarchar`, and `varbinary` data types to allow storage of values as large as 2^32 bytes."},{"content":"Table columns and Transact-SQL variables may specify <ph id=\"ph1\">`varchar(max)`</ph>, <ph id=\"ph2\">`nvarchar(max)`</ph>, or <ph id=\"ph3\">`varbinary(max)`</ph> data types.","pos":[449,566],"source":" Table columns and Transact-SQL variables may specify `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types."},{"content":"In ADO.NET, the <ph id=\"ph1\">`max`</ph> data types can be fetched by a <ph id=\"ph2\">`DataReader`</ph>, and can also be specified as both input and output parameter values without any special handling.","pos":[567,731],"source":" In ADO.NET, the `max` data types can be fetched by a `DataReader`, and can also be specified as both input and output parameter values without any special handling."},{"content":"For large <ph id=\"ph1\">`varchar`</ph> data types, data can be retrieved and updated incrementally.","pos":[732,812],"source":" For large `varchar` data types, data can be retrieved and updated incrementally."},{"content":"The <ph id=\"ph1\">`max`</ph> data types can be used for comparisons, as Transact-SQL variables, and for concatenation.","pos":[819,918],"source":"The `max` data types can be used for comparisons, as Transact-SQL variables, and for concatenation."},{"content":"They can also be used in the DISTINCT, ORDER BY, GROUP BY clauses of a SELECT statement as well as in aggregates, joins, and subqueries.","pos":[919,1055]},{"content":"The following table provides links to the documentation in SQL Server Books Online.","pos":[1062,1145]},{"pos":[1152,1179],"content":"<bpt id=\"p1\">**</bpt>SQL Server Books Online<ept id=\"p1\">**</ept>","source":"**SQL Server Books Online**"},{"pos":[1189,1267],"content":"<bpt id=\"p1\">[</bpt>Using Large-Value Data Types<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=120498)</ept>","source":"[Using Large-Value Data Types](https://go.microsoft.com/fwlink/?LinkId=120498)"},{"pos":[1276,1305],"content":"Large-Value Type Restrictions","linkify":"Large-Value Type Restrictions","nodes":[{"content":"Large-Value Type Restrictions","pos":[0,29]}]},{"pos":[1309,1409],"content":"The following restrictions apply to the <ph id=\"ph1\">`max`</ph> data types, which do not exist for smaller data types:","source":"The following restrictions apply to the `max` data types, which do not exist for smaller data types:"},{"pos":[1419,1478],"content":"A <ph id=\"ph1\">`sql_variant`</ph> cannot contain a large <ph id=\"ph2\">`varchar`</ph> data type.","source":"A `sql_variant` cannot contain a large `varchar` data type."},{"content":"Large <ph id=\"ph1\">`varchar`</ph> columns cannot be specified as a key column in an index.","pos":[1488,1560],"source":"Large `varchar` columns cannot be specified as a key column in an index."},{"content":"They are allowed in an included column in a non-clustered index.","pos":[1561,1625]},{"pos":[1635,1702],"content":"Large <ph id=\"ph1\">`varchar`</ph> columns cannot be used as partitioning key columns.","source":"Large `varchar` columns cannot be used as partitioning key columns."},{"pos":[1711,1757],"content":"Working with Large-Value Types in Transact-SQL","linkify":"Working with Large-Value Types in Transact-SQL","nodes":[{"content":"Working with Large-Value Types in Transact-SQL","pos":[0,46]}]},{"content":"The Transact-SQL <ph id=\"ph1\">`OPENROWSET`</ph> function is a one-time method of connecting and accessing remote data.","pos":[1761,1861],"source":"The Transact-SQL `OPENROWSET` function is a one-time method of connecting and accessing remote data."},{"content":"It includes all of the connection information necessary to access remote data from an OLE DB data source.","pos":[1862,1967]},{"content":"<ph id=\"ph1\">`OPENROWSET`</ph> can be referenced in the FROM clause of a query as though it were a table name.","pos":[1968,2060],"source":"`OPENROWSET` can be referenced in the FROM clause of a query as though it were a table name."},{"content":"It can also be referenced as the target table of an INSERT, UPDATE, or DELETE statement, subject to the capabilities of the OLE DB provider.","pos":[2061,2201]},{"content":"The <ph id=\"ph1\">`OPENROWSET`</ph> function includes the <ph id=\"ph2\">`BULK`</ph> rowset provider, which allows you to read data directly from a file without loading the data into a target table.","pos":[2208,2367],"source":"The `OPENROWSET` function includes the `BULK` rowset provider, which allows you to read data directly from a file without loading the data into a target table."},{"content":"This enables you to use <ph id=\"ph1\">`OPENROWSET`</ph> in a simple INSERT SELECT statement.","pos":[2368,2441],"source":" This enables you to use `OPENROWSET` in a simple INSERT SELECT statement."},{"content":"The <ph id=\"ph1\">`OPENROWSET BULK`</ph> option arguments provide significant control over where to begin and end reading data, how to deal with errors, and how data is interpreted.","pos":[2448,2610],"source":"The `OPENROWSET BULK` option arguments provide significant control over where to begin and end reading data, how to deal with errors, and how data is interpreted."},{"content":"For example, you can specify that the data file be read as a single-row, single-column rowset of type <ph id=\"ph1\">`varbinary`</ph>, <ph id=\"ph2\">`varchar`</ph>, or <ph id=\"ph3\">`nvarchar`</ph>.","pos":[2611,2751],"source":" For example, you can specify that the data file be read as a single-row, single-column rowset of type `varbinary`, `varchar`, or `nvarchar`."},{"content":"For the complete syntax and options, see SQL Server Books Online.","pos":[2752,2817]},{"content":"The following example inserts a photo into the ProductPhoto table in the AdventureWorks sample database.","pos":[2824,2928]},{"content":"When using the <ph id=\"ph1\">`BULK OPENROWSET`</ph> provider, you must supply the named list of columns even if you aren't inserting values into every column.","pos":[2929,3068],"source":" When using the `BULK OPENROWSET` provider, you must supply the named list of columns even if you aren't inserting values into every column."},{"content":"The primary key in this case is defined as an identity column, and may be omitted from the column list.","pos":[3069,3172]},{"content":"Note that you must also supply a correlation name at the end of the <ph id=\"ph1\">`OPENROWSET`</ph> statement, which in this case is ThumbnailPhoto.","pos":[3173,3302],"source":" Note that you must also supply a correlation name at the end of the `OPENROWSET` statement, which in this case is ThumbnailPhoto."},{"content":"This correlates with the column in the <ph id=\"ph1\">`ProductPhoto`</ph> table into which the file is being loaded.","pos":[3303,3399],"source":" This correlates with the column in the `ProductPhoto` table into which the file is being loaded."},{"pos":[3702,3735],"content":"Updating Data Using UPDATE .WRITE","linkify":"Updating Data Using UPDATE .WRITE","nodes":[{"content":"Updating Data Using UPDATE .WRITE","pos":[0,33]}]},{"content":"The Transact-SQL UPDATE statement has new WRITE syntax for modifying the contents of <ph id=\"ph1\">`varchar(max)`</ph>, <ph id=\"ph2\">`nvarchar(max)`</ph>, or <ph id=\"ph3\">`varbinary(max)`</ph> columns.","pos":[3739,3885],"source":"The Transact-SQL UPDATE statement has new WRITE syntax for modifying the contents of `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` columns."},{"content":"This allows you to perform partial updates of the data.","pos":[3886,3941]},{"content":"The UPDATE .WRITE syntax is shown here in abbreviated form:","pos":[3942,4001]},{"content":"UPDATE","pos":[4008,4014]},{"pos":[4021,4036],"content":"{ <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\&lt;</ph>object&gt;<ept id=\"p1\">*</ept> }","source":"{ *\\<object>* }"},{"content":"SET","pos":[4043,4046]},{"pos":[4053,4118],"content":"{ <bpt id=\"p1\">*</bpt>column_name<ept id=\"p1\">*</ept> = { .WRITE ( <bpt id=\"p2\">*</bpt>expression<ept id=\"p2\">*</ept> , <ph id=\"ph1\">@Offset</ph> , <ph id=\"ph2\">@Length</ph> ) }","source":"{ *column_name* = { .WRITE ( *expression* , @Offset , @Length ) }"},{"content":"The WRITE method specifies that a section of the value of the <bpt id=\"p1\">*</bpt>column_name<ept id=\"p1\">*</ept> will be modified.","pos":[4125,4218],"source":"The WRITE method specifies that a section of the value of the *column_name* will be modified."},{"content":"The expression is the value that will be copied to the <bpt id=\"p1\">*</bpt>column_name<ept id=\"p1\">*</ept>, the <ph id=\"ph1\">`@Offset`</ph> is the beginning point at which the expression will be written, and the <ph id=\"ph2\">`@Length`</ph> argument is the length of the section in the column.","pos":[4219,4437],"source":" The expression is the value that will be copied to the *column_name*, the `@Offset` is the beginning point at which the expression will be written, and the `@Length` argument is the length of the section in the column."},{"content":"If","pos":[4444,4446]},{"content":"Then","pos":[4447,4451]},{"content":"The expression is set to NULL","pos":[4480,4509]},{"pos":[4510,4602],"content":"<ph id=\"ph1\">`@Length`</ph> is ignored and the value in <bpt id=\"p1\">*</bpt>column_name<ept id=\"p1\">*</ept> is truncated at the specified <ph id=\"ph2\">`@Offset`</ph>.","source":"`@Length` is ignored and the value in *column_name* is truncated at the specified `@Offset`."},{"pos":[4607,4624],"content":"<ph id=\"ph1\">`@Offset`</ph> is NULL","source":"`@Offset` is NULL"},{"pos":[4625,4741],"content":"The update operation appends the expression at the end of the existing <bpt id=\"p1\">*</bpt>column_name<ept id=\"p1\">*</ept> value and <ph id=\"ph1\">`@Length`</ph> is ignored.","source":"The update operation appends the expression at the end of the existing *column_name* value and `@Length` is ignored."},{"pos":[4746,4807],"content":"<ph id=\"ph1\">`@Offset`</ph> is greater than the length of the column_name value","source":"`@Offset` is greater than the length of the column_name value"},{"content":"SQL Server returns an error.","pos":[4808,4836]},{"pos":[4841,4858],"content":"<ph id=\"ph1\">`@Length`</ph> is NULL","source":"`@Length` is NULL"},{"pos":[4859,4950],"content":"The update operation removes all data from <ph id=\"ph1\">`@Offset`</ph> to the end of the <ph id=\"ph2\">`column_name`</ph> value.","source":"The update operation removes all data from `@Offset` to the end of the `column_name` value."},{"pos":[4959,5027],"content":"[!NOTE]\n Neither `@Offset` nor `@Length` can be a negative number.","leadings":["","> "],"nodes":[{"content":"Neither <ph id=\"ph1\">`@Offset`</ph> nor <ph id=\"ph2\">`@Length`</ph> can be a negative number.","pos":[9,66],"source":"Neither `@Offset` nor `@Length` can be a negative number."}]},{"pos":[5036,5043],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This Transact-SQL example updates a partial value in DocumentSummary, an <ph id=\"ph1\">`nvarchar(max)`</ph> column in the Document table in the AdventureWorks database.","pos":[5047,5196],"source":"This Transact-SQL example updates a partial value in DocumentSummary, an `nvarchar(max)` column in the Document table in the AdventureWorks database."},{"content":"The word 'components' is replaced by the word 'features' by specifying the replacement word, the beginning location (offset) of the word to be replaced in the existing data, and the number of characters to be replaced (length).","pos":[5197,5424]},{"content":"The example includes SELECT statements before and after the UPDATE statement to compare results.","pos":[5425,5521]},{"pos":[6175,6216],"content":"Working with Large-Value Types in ADO.NET","linkify":"Working with Large-Value Types in ADO.NET","nodes":[{"content":"Working with Large-Value Types in ADO.NET","pos":[0,41]}]},{"content":"You can work with large value types in ADO.NET by specifying large value types as <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlParameter&gt;</ph> objects in a <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> to return a result set, or by using a <ph id=\"ph3\">&lt;xref:System.Data.SqlClient.SqlDataAdapter&gt;</ph> to fill a <ph id=\"ph4\">`DataSet`</ph><ph id=\"ph5\">/</ph><ph id=\"ph6\">`DataTable`</ph>.","pos":[6220,6514],"source":"You can work with large value types in ADO.NET by specifying large value types as <xref:System.Data.SqlClient.SqlParameter> objects in a <xref:System.Data.SqlClient.SqlDataReader> to return a result set, or by using a <xref:System.Data.SqlClient.SqlDataAdapter> to fill a `DataSet`/`DataTable`."},{"content":"There is no difference between the way you work with a large value type and its related, smaller value data type.","pos":[6515,6628]},{"pos":[6638,6672],"content":"Using GetSqlBytes to Retrieve Data","linkify":"Using GetSqlBytes to Retrieve Data","nodes":[{"content":"Using GetSqlBytes to Retrieve Data","pos":[0,34]}]},{"content":"The <ph id=\"ph1\">`GetSqlBytes`</ph> method of the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> can be used to retrieve the contents of a <ph id=\"ph3\">`varbinary(max)`</ph> column.","pos":[6676,6817],"source":"The `GetSqlBytes` method of the <xref:System.Data.SqlClient.SqlDataReader> can be used to retrieve the contents of a `varbinary(max)` column."},{"content":"The following code fragment assumes a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlCommand&gt;</ph> object named <ph id=\"ph2\">`cmd`</ph> that selects <ph id=\"ph3\">`varbinary(max)`</ph> data from a table and a <ph id=\"ph4\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> object named <ph id=\"ph5\">`reader`</ph> that retrieves the data as <ph id=\"ph6\">&lt;xref:System.Data.SqlTypes.SqlBytes&gt;</ph>.","pos":[6818,7098],"source":" The following code fragment assumes a <xref:System.Data.SqlClient.SqlCommand> object named `cmd` that selects `varbinary(max)` data from a table and a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data as <xref:System.Data.SqlTypes.SqlBytes>."},{"pos":[7447,7481],"content":"Using GetSqlChars to Retrieve Data","linkify":"Using GetSqlChars to Retrieve Data","nodes":[{"content":"Using GetSqlChars to Retrieve Data","pos":[0,34]}]},{"content":"The <ph id=\"ph1\">`GetSqlChars`</ph> method of the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> can be used to retrieve the contents of a <ph id=\"ph3\">`varchar(max)`</ph> or <ph id=\"ph4\">`nvarchar(max)`</ph> column.","pos":[7485,7643],"source":"The `GetSqlChars` method of the <xref:System.Data.SqlClient.SqlDataReader> can be used to retrieve the contents of a `varchar(max)` or `nvarchar(max)` column."},{"content":"The following code fragment assumes a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlCommand&gt;</ph> object named <ph id=\"ph2\">`cmd`</ph> that selects <ph id=\"ph3\">`nvarchar(max)`</ph> data from a table and a <ph id=\"ph4\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> object named <ph id=\"ph5\">`reader`</ph> that retrieves the data.","pos":[7644,7883],"source":" The following code fragment assumes a <xref:System.Data.SqlClient.SqlCommand> object named `cmd` that selects `nvarchar(max)` data from a table and a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data."},{"pos":[8222,8257],"content":"Using GetSqlBinary to Retrieve Data","linkify":"Using GetSqlBinary to Retrieve Data","nodes":[{"content":"Using GetSqlBinary to Retrieve Data","pos":[0,35]}]},{"content":"The <ph id=\"ph1\">`GetSqlBinary`</ph> method of a <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> can be used to retrieve the contents of a <ph id=\"ph3\">`varbinary(max)`</ph> column.","pos":[8261,8401],"source":"The `GetSqlBinary` method of a <xref:System.Data.SqlClient.SqlDataReader> can be used to retrieve the contents of a `varbinary(max)` column."},{"content":"The following code fragment assumes a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlCommand&gt;</ph> object named <ph id=\"ph2\">`cmd`</ph> that selects <ph id=\"ph3\">`varbinary(max)`</ph> data from a table and a <ph id=\"ph4\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> object named <ph id=\"ph5\">`reader`</ph> that retrieves the data as a <ph id=\"ph6\">&lt;xref:System.Data.SqlTypes.SqlBinary&gt;</ph> stream.","pos":[8402,8692],"source":" The following code fragment assumes a <xref:System.Data.SqlClient.SqlCommand> object named `cmd` that selects `varbinary(max)` data from a table and a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data as a <xref:System.Data.SqlTypes.SqlBinary> stream."},{"pos":[9059,9090],"content":"Using GetBytes to Retrieve Data","linkify":"Using GetBytes to Retrieve Data","nodes":[{"content":"Using GetBytes to Retrieve Data","pos":[0,31]}]},{"content":"The <ph id=\"ph1\">`GetBytes`</ph> method of a <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> reads a stream of bytes from the specified column offset into a byte array starting at the specified array offset.","pos":[9094,9278],"source":"The `GetBytes` method of a <xref:System.Data.SqlClient.SqlDataReader> reads a stream of bytes from the specified column offset into a byte array starting at the specified array offset."},{"content":"The following code fragment assumes a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> object named <ph id=\"ph2\">`reader`</ph> that retrieves bytes into a byte array.","pos":[9279,9421],"source":" The following code fragment assumes a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves bytes into a byte array."},{"content":"Note that, unlike <ph id=\"ph1\">`GetSqlBytes`</ph>, <ph id=\"ph2\">`GetBytes`</ph> requires a size for the array buffer.","pos":[9422,9503],"source":" Note that, unlike `GetSqlBytes`, `GetBytes` requires a size for the array buffer."},{"pos":[9835,9866],"content":"Using GetValue to Retrieve Data","linkify":"Using GetValue to Retrieve Data","nodes":[{"content":"Using GetValue to Retrieve Data","pos":[0,31]}]},{"content":"The <ph id=\"ph1\">`GetValue`</ph> method of a <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> reads the value from the specified column offset into an array.","pos":[9870,10003],"source":"The `GetValue` method of a <xref:System.Data.SqlClient.SqlDataReader> reads the value from the specified column offset into an array."},{"content":"The following code fragment assumes a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> object named <ph id=\"ph2\">`reader`</ph> that retrieves binary data from the first column offset, and then string data from the second column offset.","pos":[10004,10215],"source":" The following code fragment assumes a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves binary data from the first column offset, and then string data from the second column offset."},{"pos":[10790,10836],"content":"Converting from Large Value Types to CLR Types","linkify":"Converting from Large Value Types to CLR Types","nodes":[{"content":"Converting from Large Value Types to CLR Types","pos":[0,46]}]},{"content":"You can convert the contents of a <ph id=\"ph1\">`varchar(max)`</ph> or <ph id=\"ph2\">`nvarchar(max)`</ph> column using any of the string conversion methods, such as <ph id=\"ph3\">`ToString`</ph>.","pos":[10840,10978],"source":"You can convert the contents of a `varchar(max)` or `nvarchar(max)` column using any of the string conversion methods, such as `ToString`."},{"content":"The following code fragment assumes a <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> object named <ph id=\"ph2\">`reader`</ph> that retrieves the data.","pos":[10979,11106],"source":" The following code fragment assumes a <xref:System.Data.SqlClient.SqlDataReader> object named `reader` that retrieves the data."},{"pos":[11369,11376],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following code retrieves the name and the <ph id=\"ph1\">`LargePhoto`</ph> object from the <ph id=\"ph2\">`ProductPhoto`</ph> table in the <ph id=\"ph3\">`AdventureWorks`</ph> database and saves it to a file.","pos":[11380,11532],"source":"The following code retrieves the name and the `LargePhoto` object from the `ProductPhoto` table in the `AdventureWorks` database and saves it to a file."},{"content":"The assembly needs to be compiled with a reference to the <ph id=\"ph1\">&lt;xref:System.Drawing&gt;</ph> namespace.","pos":[11533,11623],"source":" The assembly needs to be compiled with a reference to the <xref:System.Drawing> namespace."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlDataReader.GetSqlBytes%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlDataReader&gt;</ph> returns a <ph id=\"ph3\">&lt;xref:System.Data.SqlTypes.SqlBytes&gt;</ph> object that exposes a <ph id=\"ph4\">`Stream`</ph> property.","pos":[11625,11831],"source":"  The <xref:System.Data.SqlClient.SqlDataReader.GetSqlBytes%2A> method of the <xref:System.Data.SqlClient.SqlDataReader> returns a <xref:System.Data.SqlTypes.SqlBytes> object that exposes a `Stream` property."},{"content":"The code uses this to create a new <ph id=\"ph1\">`Bitmap`</ph> object, and then saves it in the Gif <ph id=\"ph2\">`ImageFormat`</ph>.","pos":[11832,11927],"source":" The code uses this to create a new `Bitmap` object, and then saves it in the Gif `ImageFormat`."},{"pos":[12254,12287],"content":"Using Large Value Type Parameters","linkify":"Using Large Value Type Parameters","nodes":[{"content":"Using Large Value Type Parameters","pos":[0,33]}]},{"content":"Large value types can be used in <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlParameter&gt;</ph> objects the same way you use smaller value types in <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlParameter&gt;</ph> objects.","pos":[12291,12468],"source":"Large value types can be used in <xref:System.Data.SqlClient.SqlParameter> objects the same way you use smaller value types in <xref:System.Data.SqlClient.SqlParameter> objects."},{"content":"You can retrieve large value types as <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlParameter&gt;</ph> values, as shown in the following example.","pos":[12469,12591],"source":" You can retrieve large value types as <xref:System.Data.SqlClient.SqlParameter> values, as shown in the following example."},{"content":"The code assumes that the following GetDocumentSummary stored procedure exists in the AdventureWorks sample database.","pos":[12592,12709]},{"content":"The stored procedure takes an input parameter named <ph id=\"ph1\">@DocumentID</ph> and returns the contents of the DocumentSummary column in the <ph id=\"ph2\">@DocumentSummary</ph> output parameter.","pos":[12710,12870],"source":" The stored procedure takes an input parameter named @DocumentID and returns the contents of the DocumentSummary column in the @DocumentSummary output parameter."},{"pos":[13161,13168],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The ADO.NET code creates <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlCommand&gt;</ph> objects to execute the GetDocumentSummary stored procedure and retrieve the document summary, which is stored as a large value type.","pos":[13172,13416],"source":"The ADO.NET code creates <xref:System.Data.SqlClient.SqlConnection> and <xref:System.Data.SqlClient.SqlCommand> objects to execute the GetDocumentSummary stored procedure and retrieve the document summary, which is stored as a large value type."},{"content":"The code passes a value for the <ph id=\"ph1\">@DocumentID</ph> input parameter, and displays the results passed back in the <ph id=\"ph2\">@DocumentSummary</ph> output parameter in the Console window.","pos":[13417,13578],"source":" The code passes a value for the @DocumentID input parameter, and displays the results passed back in the @DocumentSummary output parameter in the Console window."},{"pos":[13905,13913],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13917,14046],"content":"<bpt id=\"p1\">[</bpt>SQL Server Binary and Large-Value Data<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/sql-server-binary-and-large-value-data.md)</ept>","source":"[SQL Server Binary and Large-Value Data](../../../../../docs/framework/data/adonet/sql/sql-server-binary-and-large-value-data.md)"},{"pos":[14049,14156],"content":"<bpt id=\"p1\">[</bpt>SQL Server Data Type Mappings<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql-server-data-type-mappings.md)</ept>","source":"[SQL Server Data Type Mappings](../../../../../docs/framework/data/adonet/sql-server-data-type-mappings.md)"},{"pos":[14159,14275],"content":"<bpt id=\"p1\">[</bpt>SQL Server Data Operations in ADO.NET<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/sql-server-data-operations.md)</ept>","source":"[SQL Server Data Operations in ADO.NET](../../../../../docs/framework/data/adonet/sql/sql-server-data-operations.md)"},{"pos":[14278,14382],"content":"<bpt id=\"p1\">[</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=217917)</ept>","source":"[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)"}]}