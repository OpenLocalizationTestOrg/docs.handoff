{"content":"---\ntitle: \"Versioning with the Override and New Keywords - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"C# language, versioning\"\n  - \"C# language, override and new\"\nms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5\n---\n# Versioning with the Override and New Keywords (C# Programming Guide)\nThe C# language is designed so that versioning between [base](../../../csharp/language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility. This means, for example, that the introduction of a new member in a base [class](../../../csharp/language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior. It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.  \n  \n In C#, derived classes can contain methods with the same name as base class methods.  \n  \n-   The base class method must be defined [virtual](../../../csharp/language-reference/keywords/virtual.md).  \n  \n-   If the method in the derived class is not preceded by [new](../../../csharp/language-reference/keywords/new.md) or [override](../../../csharp/language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.  \n  \n-   If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.  \n  \n-   If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.  \n  \n-   The base class method can be called from within the derived class using the `base` keyword.  \n  \n-   The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.  \n  \n By default, C# methods are not virtual. If a method is declared as virtual, any class inheriting the method can implement its own version. To make a method virtual, the `virtual` modifier is used in the method declaration of the base class. The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword. If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.  \n  \n To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses. The following is `GraphicsClass`:  \n  \n [!code-csharp[csProgGuideInheritance#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#27)]  \n  \n Your company uses this class, and you use it to derive your own class, adding a new method:  \n  \n [!code-csharp[csProgGuideInheritance#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#28)]  \n  \n Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:  \n  \n [!code-csharp[csProgGuideInheritance#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#29)]  \n  \n The new version of `GraphicsClass` now contains a method named `DrawRectangle`. Initially, nothing occurs. The new version is still binary compatible with the old version. Any software that you have deployed will continue to work, even if the new class is installed on those computer systems. Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.  \n  \n However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108. This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.  \n  \n If you want your method to override the new base class method, use the `override` keyword:  \n  \n [!code-csharp[csProgGuideInheritance#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#30)]  \n  \n The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`. Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:  \n  \n [!code-csharp[csProgGuideInheritance#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#44)]  \n  \n If you do not want your method to override the new base class method, the following considerations apply. To avoid confusion between the two methods, you can rename your method. This can be time-consuming and error-prone, and just not practical in some cases. However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method. For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer).  \n  \n Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:  \n  \n [!code-csharp[csProgGuideInheritance#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#31)]  \n  \n Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class. This is the default behavior.  \n  \n## Override and Method Selection  \n When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed. The following methods would be compatible:  \n  \n [!code-csharp[csProgGuideInheritance#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#32)]  \n  \n When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`. Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class. Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters. For example:  \n  \n [!code-csharp[csProgGuideInheritance#33](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#33)]  \n  \n Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`. There are two ways to avoid this. First, avoid declaring new methods with the same name as virtual methods. Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`. Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called. For example:  \n  \n [!code-csharp[csProgGuideInheritance#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#34)]  \n  \n For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).  \n  \n## See also\n\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)\n- [Methods](../../../csharp/programming-guide/classes-and-structs/methods.md)\n- [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md)\n","nodes":[{"pos":[4,258],"embed":true,"restype":"x-metadata","content":"title: \"Versioning with the Override and New Keywords - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"C# language, versioning\"\n  - \"C# language, override and new\"\nms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5","nodes":[{"content":"Versioning with the Override and New Keywords - C# Programming Guide","nodes":[{"pos":[0,68],"content":"Versioning with the Override and New Keywords - C# Programming Guide","nodes":[{"content":"Versioning with the Override and New Keywords - C# Programming Guide","pos":[0,68]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[265,333],"content":"Versioning with the Override and New Keywords (C# Programming Guide)","linkify":"Versioning with the Override and New Keywords (C# Programming Guide)","nodes":[{"content":"Versioning with the Override and New Keywords (C# Programming Guide)","pos":[0,68]}]},{"content":"The C# language is designed so that versioning between <bpt id=\"p1\">[</bpt>base<ept id=\"p1\">](../../../csharp/language-reference/keywords/base.md)</ept> and derived classes in different libraries can evolve and maintain backward compatibility.","pos":[334,539],"source":"The C# language is designed so that versioning between [base](../../../csharp/language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility."},{"content":"This means, for example, that the introduction of a new member in a base <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept> with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.","pos":[540,796],"source":" This means, for example, that the introduction of a new member in a base [class](../../../csharp/language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior."},{"content":"It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.","pos":[797,990]},{"content":"In C#, derived classes can contain methods with the same name as base class methods.","pos":[997,1081]},{"pos":[1091,1195],"content":"The base class method must be defined <bpt id=\"p1\">[</bpt>virtual<ept id=\"p1\">](../../../csharp/language-reference/keywords/virtual.md)</ept>.","source":"The base class method must be defined [virtual](../../../csharp/language-reference/keywords/virtual.md)."},{"pos":[1205,1496],"content":"If the method in the derived class is not preceded by <bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../../../csharp/language-reference/keywords/new.md)</ept> or <bpt id=\"p2\">[</bpt>override<ept id=\"p2\">](../../../csharp/language-reference/keywords/override.md)</ept> keywords, the compiler will issue a warning and the method will behave as if the <ph id=\"ph1\">`new`</ph> keyword were present.","source":"If the method in the derived class is not preceded by [new](../../../csharp/language-reference/keywords/new.md) or [override](../../../csharp/language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present."},{"pos":[1506,1652],"content":"If the method in the derived class is preceded with the <ph id=\"ph1\">`new`</ph> keyword, the method is defined as being independent of the method in the base class.","source":"If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class."},{"pos":[1662,1822],"content":"If the method in the derived class is preceded with the <ph id=\"ph1\">`override`</ph> keyword, objects of the derived class will call that method instead of the base class method.","source":"If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method."},{"pos":[1832,1923],"content":"The base class method can be called from within the derived class using the <ph id=\"ph1\">`base`</ph> keyword.","source":"The base class method can be called from within the derived class using the `base` keyword."},{"pos":[1933,2035],"content":"The <ph id=\"ph1\">`override`</ph>, <ph id=\"ph2\">`virtual`</ph>, and <ph id=\"ph3\">`new`</ph> keywords can also be applied to properties, indexers, and events.","source":"The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events."},{"content":"By default, C# methods are not virtual.","pos":[2042,2081]},{"content":"If a method is declared as virtual, any class inheriting the method can implement its own version.","pos":[2082,2180]},{"content":"To make a method virtual, the <ph id=\"ph1\">`virtual`</ph> modifier is used in the method declaration of the base class.","pos":[2181,2282],"source":" To make a method virtual, the `virtual` modifier is used in the method declaration of the base class."},{"content":"The derived class can then override the base virtual method by using the <ph id=\"ph1\">`override`</ph> keyword or hide the virtual method in the base class by using the <ph id=\"ph2\">`new`</ph> keyword.","pos":[2283,2447],"source":" The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword."},{"content":"If neither the <ph id=\"ph1\">`override`</ph> keyword nor the <ph id=\"ph2\">`new`</ph> keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.","pos":[2448,2627],"source":" If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class."},{"content":"To demonstrate this in practice, assume for a moment that Company A has created a class named <ph id=\"ph1\">`GraphicsClass`</ph>, which your program uses.","pos":[2634,2769],"source":"To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses."},{"content":"The following is <ph id=\"ph1\">`GraphicsClass`</ph>:","pos":[2770,2803],"source":" The following is `GraphicsClass`:"},{"content":"Your company uses this class, and you use it to derive your own class, adding a new method:","pos":[2950,3041]},{"pos":[3188,3325],"content":"Your application is used without problems, until Company A releases a new version of <ph id=\"ph1\">`GraphicsClass`</ph>, which resembles the following code:","source":"Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:"},{"content":"The new version of <ph id=\"ph1\">`GraphicsClass`</ph> now contains a method named <ph id=\"ph2\">`DrawRectangle`</ph>.","pos":[3472,3551],"source":"The new version of `GraphicsClass` now contains a method named `DrawRectangle`."},{"content":"Initially, nothing occurs.","pos":[3552,3578]},{"content":"The new version is still binary compatible with the old version.","pos":[3579,3643]},{"content":"Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.","pos":[3644,3764]},{"content":"Any existing calls to the method <ph id=\"ph1\">`DrawRectangle`</ph> will continue to reference your version, in your derived class.","pos":[3765,3877],"source":" Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class."},{"content":"However, as soon as you recompile your application by using the new version of <ph id=\"ph1\">`GraphicsClass`</ph>, you will receive a warning from the compiler, CS0108.","pos":[3884,4033],"source":"However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108."},{"content":"This warning informs you that you have to consider how you want your <ph id=\"ph1\">`DrawRectangle`</ph> method to behave in your application.","pos":[4034,4156],"source":" This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application."},{"pos":[4163,4253],"content":"If you want your method to override the new base class method, use the <ph id=\"ph1\">`override`</ph> keyword:","source":"If you want your method to override the new base class method, use the `override` keyword:"},{"content":"The <ph id=\"ph1\">`override`</ph> keyword makes sure that any objects derived from <ph id=\"ph2\">`YourDerivedGraphicsClass`</ph> will use the derived class version of <ph id=\"ph3\">`DrawRectangle`</ph>.","pos":[4400,4545],"source":"The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`."},{"content":"Objects derived from <ph id=\"ph1\">`YourDerivedGraphicsClass`</ph> can still access the base class version of <ph id=\"ph2\">`DrawRectangle`</ph> by using the base keyword:","pos":[4546,4679],"source":" Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:"},{"content":"If you do not want your method to override the new base class method, the following considerations apply.","pos":[4826,4931]},{"content":"To avoid confusion between the two methods, you can rename your method.","pos":[4932,5003]},{"content":"This can be time-consuming and error-prone, and just not practical in some cases.","pos":[5004,5085]},{"content":"However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.","pos":[5086,5201]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Refactoring Classes and Types (Class Designer)<ept id=\"p1\">](/visualstudio/ide/refactoring-classes-and-types-class-designer)</ept>.","pos":[5202,5341],"source":" For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/refactoring-classes-and-types-class-designer)."},{"pos":[5348,5451],"content":"Alternatively, you can prevent the warning by using the keyword <ph id=\"ph1\">`new`</ph> in your derived class definition:","source":"Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:"},{"content":"Using the <ph id=\"ph1\">`new`</ph> keyword tells the compiler that your definition hides the definition that is contained in the base class.","pos":[5598,5719],"source":"Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class."},{"content":"This is the default behavior.","pos":[5720,5749]},{"pos":[5758,5787],"content":"Override and Method Selection","linkify":"Override and Method Selection","nodes":[{"content":"Override and Method Selection","pos":[0,29]}]},{"content":"When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.","pos":[5791,6043]},{"content":"The following methods would be compatible:","pos":[6044,6086]},{"content":"When <ph id=\"ph1\">`DoWork`</ph> is called on an instance of <ph id=\"ph2\">`Derived`</ph>, the C# compiler will first try to make the call compatible with the versions of <ph id=\"ph3\">`DoWork`</ph> declared originally on <ph id=\"ph4\">`Derived`</ph>.","pos":[6233,6408],"source":"When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`."},{"content":"Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.","pos":[6409,6535]},{"content":"Only if the C# compiler cannot match the method call to an original method on <ph id=\"ph1\">`Derived`</ph> will it try to match the call to an overridden method with the same name and compatible parameters.","pos":[6536,6723],"source":" Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters."},{"content":"For example:","pos":[6724,6736]},{"content":"Because the variable <ph id=\"ph1\">`val`</ph> can be converted to a double implicitly, the C# compiler calls <ph id=\"ph2\">`DoWork(double)`</ph> instead of <ph id=\"ph3\">`DoWork(int)`</ph>.","pos":[6883,7015],"source":"Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`."},{"content":"There are two ways to avoid this.","pos":[7016,7049]},{"content":"First, avoid declaring new methods with the same name as virtual methods.","pos":[7050,7123]},{"content":"Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of <ph id=\"ph1\">`Derived`</ph> to <ph id=\"ph2\">`Base`</ph>.","pos":[7124,7286],"source":" Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`."},{"content":"Because the method is virtual, the implementation of <ph id=\"ph1\">`DoWork(int)`</ph> on <ph id=\"ph2\">`Derived`</ph> will be called.","pos":[7287,7382],"source":" Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called."},{"content":"For example:","pos":[7383,7395]},{"pos":[7542,7741],"content":"For more examples of <ph id=\"ph1\">`new`</ph> and <ph id=\"ph2\">`override`</ph>, see <bpt id=\"p1\">[</bpt>Knowing When to Use Override and New Keywords<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)</ept>.","source":"For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)."},{"pos":[7750,7758],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7762,7828],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[7831,7916],"content":"<bpt id=\"p1\">[</bpt>Classes and Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/index.md)</ept>","source":"[Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md)"},{"pos":[7919,7994],"content":"<bpt id=\"p1\">[</bpt>Methods<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/methods.md)</ept>","source":"[Methods](../../../csharp/programming-guide/classes-and-structs/methods.md)"},{"pos":[7997,8080],"content":"<bpt id=\"p1\">[</bpt>Inheritance<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept>","source":"[Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md)"}]}