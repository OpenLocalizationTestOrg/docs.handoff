<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3df033504a93a2d3eca5b252dbc47fb7d8b0ff9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\concepts\linq\comparison-of-xpath-and-linq-to-xml.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">18d4366b73447f289b297054c1f13198c827f0ab</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c43c0cd35a302df0be1c120abf0c7c59b9cdf8e7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Comparison of XPath and LINQ to XML2 | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Comparison of XPath and LINQ to XML</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>XPath and <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> offer some similar functionality.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Both can be used to query an XML tree, returning such results as a collection of elements, a collection of attributes, a collection of nodes, or the value of an element or attribute.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, there are also some differences.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Differences Between XPath and LINQ to XML</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>XPath does not allow projection of new types.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It can only return collections of nodes from the tree, whereas <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> can execute a query and project an object graph or an XML tree in a new shape.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries encompass much more functionality and are much more powerful than XPath expressions.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>XPath expressions exist in isolation within a string.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The C# compiler cannot help parse the XPath expression at compile time.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>By contrast, <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries are parsed and compiled by the C# compiler.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The compiler is able to catch many query errors.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>XPath results are not strongly typed.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In a number of circumstances, the result of evaluating an XPath expression is an object, and it is up to the developer to determine the proper type and cast the result as necessary.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By contrast, the projections from a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query are strongly typed.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Result Ordering</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 Recommendation states that a collection that is the result of evaluating an XPath expression is unordered.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, when iterating through a collection returned by a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> XPath axis method, the nodes in the collection are returned in document order.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This is the case even when accessing the XPath axes where predicates are expressed in terms of reverse document order, such as <ph id="ph1">`preceding`</ph> and <ph id="ph2">`preceding-sibling`</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>By contrast, most of the <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> axes return collections in document order, but two of them, <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.Ancestors%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A&gt;</ph>, return collections in reverse document order.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following table enumerates the axes, and indicates collection order for each:</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>LINQ to XML axis</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Ordering</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>XContainer.DescendantNodes</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>XContainer.Descendants</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>XContainer.Elements</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>XContainer.Nodes</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>XContainer.NodesAfterSelf</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>XContainer.NodesBeforeSelf</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>XElement.AncestorsAndSelf</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Reverse document order</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>XElement.Attributes</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>XElement.DescendantNodesAndSelf</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>XElement.DescendantsAndSelf</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>XNode.Ancestors</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Reverse document order</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>XNode.ElementsAfterSelf</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>XNode.ElementsBeforeSelf</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>XNode.NodesAfterSelf</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>XNode.NodesBeforeSelf</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Document order</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Positional Predicates</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Within an XPath expression, positional predicates are expressed in terms of document order for many axes, but are expressed in reverse document order for reverse axes, which are <ph id="ph1">`preceding`</ph>, <ph id="ph2">`preceding-sibling`</ph>, <ph id="ph3">`ancestor`</ph>, and <ph id="ph4">`ancestor-or-self`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, the XPath expression <ph id="ph1">`preceding-sibling::*[1]`</ph> returns the immediately preceding sibling.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This is the case even though the final result set is presented in document order.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By contrast, all positional predicates in LINQ to XML are always expressed in terms of the order of the axis.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`anElement.ElementsBeforeSelf().ToList()[0]`</ph> returns the first child element of the parent of the queried element, not the immediate preceding sibling.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Another example: <ph id="ph1">`anElement.Ancestors().ToList()[0]`</ph> returns the parent element.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Note that the above approach materializes the entire collection.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This is not the most efficient way to write that query.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It was written in that way to demonstrate the behavior of positional predicates.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>A more appropriate way to write the same query is to use the <ph id="ph1">&lt;xref:System.Linq.Enumerable.First%2A&gt;</ph> method, as follows: <ph id="ph2">`anElement.ElementsBeforeSelf().First()`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you wanted to find the immediately preceding element in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, you would write the following expression:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Performance Differences</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>XPath queries that use the XPath functionality in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> will not perform as well as <ph id="ph2">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Comparison of Composition</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Composition of a <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query is somewhat parallel to composition of an XPath expression, although very different in syntax.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, if you have an element in a variable named <ph id="ph1">`customers`</ph>, and you want to find a grandchild element named <ph id="ph2">`CompanyName`</ph> under all child elements named <ph id="ph3">`Customer`</ph>, you would write an XPath expression as follows:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The equivalent <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query is:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>There are similar parallels for each of the XPath axes.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>XPath axis</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>LINQ to XML axis</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>child (the default axis)</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Parent (..)</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>attribute axis (@)</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>ancestor axis</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>ancestor-or-self axis</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>descendant axis (//)</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>descendant-or-self</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>following-sibling</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>preceding-sibling</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>or</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>following</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>No direct equivalent.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>preceding</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>No direct equivalent.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ to XML for XPath Users (C#)<ept id="p1">](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-for-xpath-users.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>