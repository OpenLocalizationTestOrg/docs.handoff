<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="coding-conventions.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4bb5a8134bb9cbcdb70830628895338ec83b28a5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\inside-a-program\coding-conventions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">73dc36625f8506052ae16d0635cffd03daec32db</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ba6d44a10bd617af45fd8a0ad123704a77a3049</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>C# Coding Conventions - C# Programming Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>C# Coding Conventions (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Coding conventions serve the following purposes:</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>They create a consistent look to the code, so that readers can focus on content, not layout.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>They enable readers to understand the code more quickly by making assumptions based on previous experience.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>They facilitate copying, changing, and maintaining the code.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>They demonstrate C# best practices.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The guidelines in this topic are used by Microsoft to develop samples and documentation.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In short examples that do not include <bpt id="p1">[</bpt>using directives<ept id="p1">](../../../csharp/language-reference/keywords/using-directive.md)</ept>, use namespace qualifications.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you know that a namespace is imported by default in a project, you do not have to fully qualify the names from that namespace.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Qualified names can be broken after a dot (.) if they are too long for a single line, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You do not have to change the names of objects that were created by using the Visual Studio designer tools to make them fit other guidelines.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Layout Conventions</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Good layout uses formatting to emphasize the structure of your code and to make the code easier to read.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Microsoft examples and samples conform to the following conventions:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Use the default Code Editor settings (smart indenting, four-character indents, tabs saved as spaces).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Options, Text Editor, C#, Formatting<ept id="p1">](/visualstudio/ide/reference/options-text-editor-csharp-formatting)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Write only one statement per line.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Write only one declaration per line.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If continuation lines are not indented automatically, indent them one tab stop (four spaces).</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Add at least one blank line between method definitions and property definitions.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use parentheses to make clauses in an expression apparent, as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Commenting Conventions</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Place the comment on a separate line, not at the end of a line of code.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Begin comment text with an uppercase letter.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>End comment text with a period.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Insert one space between the comment delimiter (//) and the comment text, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Do not create formatted blocks of asterisks around comments.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Language Guidelines</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following sections describe practices that the C# team follows to prepare code examples and samples.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>String Data Type</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>string interpolation<ept id="p1">](../../language-reference/tokens/interpolated.md)</ept> to concatenate short strings, as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>To append strings in loops, especially when you are working with large amounts of text, use a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Implicitly Typed Local Variables</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>implicit typing<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)</ept> for local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Do not use <bpt id="p1">[</bpt>var<ept id="p1">](../../../csharp/language-reference/keywords/var.md)</ept> when the type is not apparent from the right side of the assignment.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Do not rely on the variable name to specify the type of the variable.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>It might not be correct.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Avoid the use of <ph id="ph1">`var`</ph> in place of <bpt id="p1">[</bpt>dynamic<ept id="p1">](../../../csharp/language-reference/keywords/dynamic.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Use implicit typing to determine the type of the loop variable in <bpt id="p1">[</bpt>for<ept id="p1">](../../../csharp/language-reference/keywords/for.md)</ept> and <bpt id="p2">[</bpt>foreach<ept id="p2">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> loops.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following example uses implicit typing in a <ph id="ph1">`for`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following example uses implicit typing in a <ph id="ph1">`foreach`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Unsigned Data Type</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In general, use <ph id="ph1">`int`</ph> rather than unsigned types.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The use of <ph id="ph1">`int`</ph> is common throughout C#, and it is easier to interact with other libraries when you use <ph id="ph2">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Arrays</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Use the concise syntax when you initialize arrays on the declaration line.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Delegates</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Use the concise syntax to create instances of a delegate type.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>try-catch and using Statements in Exception Handling</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Use a <bpt id="p1">[</bpt>try-catch<ept id="p1">](../../../csharp/language-reference/keywords/try-catch.md)</ept> statement for most exception handling.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Simplify your code by using the C# <bpt id="p1">[</bpt>using statement<ept id="p1">](../../../csharp/language-reference/keywords/using-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If you have a <bpt id="p1">[</bpt>try-finally<ept id="p1">](../../../csharp/language-reference/keywords/try-finally.md)</ept> statement in which the only code in the <ph id="ph1">`finally`</ph> block is a call to the <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method, use a <ph id="ph3">`using`</ph> statement instead.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>&amp;&amp; and &amp;#124;&amp;#124; Operators</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To avoid exceptions and increase performance by skipping unnecessary comparisons, use <bpt id="p1">[</bpt><ph id="ph1">&amp;&amp;</ph><ept id="p1">](../../../csharp/language-reference/operators/conditional-and-operator.md)</ept> instead of <bpt id="p2">[</bpt><ph id="ph2">&amp;</ph><ept id="p2">](../../../csharp/language-reference/operators/and-operator.md)</ept> and <bpt id="p3">[</bpt>&amp;#124;&amp;#124;<ept id="p3">](../../../csharp/language-reference/operators/conditional-or-operator.md)</ept> instead of <bpt id="p4">[</bpt>&amp;#124;<ept id="p4">](../../../csharp/language-reference/operators/or-operator.md)</ept> when you perform comparisons, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>New Operator</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Use the concise form of object instantiation, with implicit typing, as shown in the following declaration.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The previous line is equivalent to the following declaration.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Use object initializers to simplify object creation.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Event Handling</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If you are defining an event handler that you do not need to remove later, use a lambda expression.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Static Members</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt>static<ept id="p1">](../../../csharp/language-reference/keywords/static.md)</ept> members by using the class name: <bpt id="p2">*</bpt>ClassName.StaticMember<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This practice makes code more readable by making static access clear.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Do not qualify a static member defined in a base class with the name of a derived class.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>While that code compiles, the code readability is misleading, and the code may break in the future if you add a static member with the same name to the derived class.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>LINQ Queries</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Use meaningful names for query variables.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following example uses <ph id="ph1">`seattleCustomers`</ph> for customers who are located in Seattle.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Use aliases to make sure that property names of anonymous types are correctly capitalized, using Pascal casing.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Rename properties when the property names in the result would be ambiguous.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For example, if your query returns a customer name and a distributor ID, instead of leaving them as <ph id="ph1">`Name`</ph> and <ph id="ph2">`ID`</ph> in the result, rename them to clarify that <ph id="ph3">`Name`</ph> is the name of a customer, and <ph id="ph4">`ID`</ph> is the ID of a distributor.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Use implicit typing in the declaration of query variables and range variables.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Align query clauses under the <bpt id="p1">[</bpt>from<ept id="p1">](../../../csharp/language-reference/keywords/from-clause.md)</ept> clause, as shown in the previous examples.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>where<ept id="p1">](../../../csharp/language-reference/keywords/where-clause.md)</ept> clauses before other query clauses to ensure that later query clauses operate on the reduced, filtered set of data.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Use multiple <ph id="ph1">`from`</ph> clauses instead of a <bpt id="p1">[</bpt>join<ept id="p1">](../../../csharp/language-reference/keywords/join-clause.md)</ept> clause to access inner collections.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, a collection of <ph id="ph1">`Student`</ph> objects might each contain a collection of test scores.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When the following query is executed, it returns each score that is over 90, along with the last name of the student who received the score.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Security</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Follow the guidelines in <bpt id="p1">[</bpt>Secure Coding Guidelines<ept id="p1">](../../../standard/security/secure-coding-guidelines.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Visual Basic Coding Conventions<ept id="p1">](../../../visual-basic/programming-guide/program-structure/coding-conventions.md)</ept></source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Secure Coding Guidelines<ept id="p1">](../../../standard/security/secure-coding-guidelines.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>