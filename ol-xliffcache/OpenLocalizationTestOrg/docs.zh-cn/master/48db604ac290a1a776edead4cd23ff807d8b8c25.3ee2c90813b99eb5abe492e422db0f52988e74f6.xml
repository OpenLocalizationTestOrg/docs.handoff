{"content":"---\ntitle: \"The Managed Thread Pool | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"thread pooling [.NET Framework]\"\n  - \"thread pools [.NET Framework]\"\n  - \"threading [.NET Framework], thread pool\"\n  - \"threading [.NET Framework], pooling\"\nms.assetid: 2be05b06-a42e-4c9d-a739-96c21d673927\ncaps.latest.revision: 24\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# The Managed Thread Pool\nThe <xref:System.Threading.ThreadPool> class provides your application with a pool of worker threads that are managed by the system, allowing you to concentrate on application tasks rather than thread management. If you have short tasks that require background processing, the managed thread pool is an easy way to take advantage of multiple threads. For example, beginning with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] you can create <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects, which perform asynchronous tasks on thread pool threads.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)], the throughput of the thread pool is significantly improved in three key areas that were identified as bottlenecks in previous releases of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]: queuing tasks, dispatching thread pool threads, and dispatching I/O completion threads. To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)] or later.  \n  \n For background tasks that interact with the user interface, the .NET Framework version 2.0 also provides the <xref:System.ComponentModel.BackgroundWorker> class, which communicates using events raised on the user interface thread.  \n  \n The .NET Framework uses thread pool threads for many purposes, including asynchronous I/O completion, timer callbacks, registered wait operations, asynchronous method calls using delegates, and <xref:System.Net> socket connections.  \n  \n## When Not to Use Thread Pool Threads  \n There are several scenarios in which it is appropriate to create and manage your own threads instead of using thread pool threads:  \n  \n-   You require a foreground thread.  \n  \n-   You require a thread to have a particular priority.  \n  \n-   You have tasks that cause the thread to block for long periods of time. The thread pool has a maximum number of threads, so a large number of blocked thread pool threads might prevent tasks from starting.  \n  \n-   You need to place threads into a single-threaded apartment. All <xref:System.Threading.ThreadPool> threads are in the multithreaded apartment.  \n  \n-   You need to have a stable identity associated with the thread, or to dedicate a thread to a task.  \n  \n## Thread Pool Characteristics  \n Thread pool threads are background threads. See [Foreground and Background Threads](../../../docs/standard/threading/foreground-and-background-threads.md). Each thread uses the default stack size, runs at the default priority, and is in the multithreaded apartment.  \n  \n There is only one thread pool per process.  \n  \n### Exceptions in Thread Pool Threads  \n Unhandled exceptions on thread pool threads terminate the process. There are three exceptions to this rule:  \n  \n-   A <xref:System.Threading.ThreadAbortException> is thrown in a thread pool thread, because <xref:System.Threading.Thread.Abort%2A> was called.  \n  \n-   An <xref:System.AppDomainUnloadedException> is thrown in a thread pool thread, because the application domain is being unloaded.  \n  \n-   The common language runtime or a host process terminates the thread.  \n  \n For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).  \n  \n> [!NOTE]\n>  In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps unhandled exceptions in thread pool threads. This might corrupt application state and eventually cause applications to hang, which might be very difficult to debug.  \n  \n### Maximum Number of Thread Pool Threads  \n The number of operations that can be queued to the thread pool is limited only by available memory; however, the thread pool limits the number of threads that can be active in the process simultaneously. Beginning with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.  \n  \n You can control the maximum number of threads by using the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> and <xref:System.Threading.ThreadPool.SetMaxThreads%2A> methods.  \n  \n> [!NOTE]\n>  In the .NET Framework versions 1.0 and 1.1, the size of the thread pool cannot be set from managed code. Code that hosts the common language runtime can set the size using `CorSetMaxThreads`, defined in mscoree.h.  \n  \n### Thread Pool Minimums  \n The thread pool provides new worker threads or I/O completion threads on demand until it reaches a specified minimum for each category. You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.  \n  \n> [!NOTE]\n>  When demand is low, the actual number of thread pool threads can fall below the minimum values.  \n  \n When a minimum is reached, the thread pool can create additional threads or wait until some tasks complete. Beginning with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  \n  \n> [!CAUTION]\n>  You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of idle threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.  \n  \n## Skipping Security Checks  \n The thread pool also provides the <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName> and <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=fullName> methods. Use these methods only when you are certain that the caller's stack is irrelevant to any security checks performed during the execution of the queued task. <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>and <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> both capture the caller's stack, which is merged into the stack of the thread pool thread when the thread begins to execute a task. If a security check is required, the entire stack must be checked. Although the check provides safety, it also has a performance cost.  \n  \n## Using the Thread Pool  \n Beginning with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the easiest way to use the thread pool is to use the [Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md). By default, parallel library types like <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> use thread pool threads to run tasks. You can also use the thread pool by calling <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> from managed code (or `CorQueueUserWorkItem` from unmanaged code) and passing a <xref:System.Threading.WaitCallback> delegate representing the method that performs the task. Another way to use the thread pool is to queue work items that are related to a wait operation by using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=fullName> method and passing a <xref:System.Threading.WaitHandle> that, when signaled or when timed out, calls the method represented by the <xref:System.Threading.WaitOrTimerCallback> delegate. Thread pool threads are used to invoke callback methods.  \n  \n## ThreadPool Examples  \n The code examples in this section demonstrate the thread pool by using the <xref:System.Threading.Tasks.Task> class, the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> method, and the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=fullName> method.  \n  \n-   [Executing Asynchronous Tasks with the Task Parallel Library](#TaskParallelLibrary)  \n  \n-   [Executing Code Asynchronously with QueueUserWorkItem](#ExecuteCodeWithQUWI)  \n  \n-   [Supplying Task Data for QueueUserWorkItem](#TaskDataForQUWI)  \n  \n-   [Using RegisterWaitForSingleObject](#RegisterWaitForSingleObject)  \n  \n<a name=\"TaskParallelLibrary\"></a>   \n### Executing Asynchronous Tasks with the Task Parallel Library  \n The following example shows how to create and use a <xref:System.Threading.Tasks.Task> object by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> method. For an example that uses the <xref:System.Threading.Tasks.Task%601> class to return a value from an asynchronous task, see [How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).  \n  \n [!code-csharp[System.Threading.Tasks.Task#01](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]\n [!code-vb[System.Threading.Tasks.Task#01](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)]  \n  \n<a name=\"ExecuteCodeWithQUWI\"></a>   \n### Executing Code Asynchronously with QueueUserWorkItem  \n The following example queues a very simple task, represented by the `ThreadProc` method, using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.  \n  \n [!code-cpp[Conceptual.ThreadPool#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.threadpool/cpp/source1.cpp#1)]\n [!code-csharp[Conceptual.ThreadPool#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.threadpool/cs/source1.cs#1)]\n [!code-vb[Conceptual.ThreadPool#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.threadpool/vb/source1.vb#1)]  \n  \n<a name=\"TaskDataForQUWI\"></a>   \n### Supplying Task Data for QueueUserWorkItem  \n The following code example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a task and supply the data for the task.  \n  \n [!code-cpp[Conceptual.ThreadPool#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.threadpool/cpp/source2.cpp#2)]\n [!code-csharp[Conceptual.ThreadPool#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.threadpool/cs/source2.cs#2)]\n [!code-vb[Conceptual.ThreadPool#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.threadpool/vb/source2.vb#2)]  \n  \n<a name=\"RegisterWaitForSingleObject\"></a>   \n### Using RegisterWaitForSingleObject  \n The following example demonstrates several threading features.  \n  \n-   Queuing a task for execution by <xref:System.Threading.ThreadPool> threads, with the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.  \n  \n-   Signaling a task to execute, with <xref:System.Threading.AutoResetEvent>. See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  \n  \n-   Handling both time-outs and signals with a <xref:System.Threading.WaitOrTimerCallback> delegate.  \n  \n-   Canceling a queued task with <xref:System.Threading.RegisteredWaitHandle>.  \n  \n [!code-cpp[Conceptual.ThreadPool#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.threadpool/cpp/source3.cpp#3)]\n [!code-csharp[Conceptual.ThreadPool#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.threadpool/cs/source3.cs#3)]\n [!code-vb[Conceptual.ThreadPool#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.threadpool/vb/source3.vb#3)]  \n  \n## See Also  \n <xref:System.Threading.ThreadPool>   \n <xref:System.Threading.Tasks.Task>   \n <xref:System.Threading.Tasks.Task%601>   \n [Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)   \n [Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)   \n [How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)   \n [Threading Objects and Features](../../../docs/standard/threading/threading-objects-and-features.md)   \n [Threads and Threading](../../../docs/standard/threading/threads-and-threading.md)   \n [Asynchronous File I/O](../../../docs/standard/io/asynchronous-file-i-o.md)   \n [Timers](../../../docs/standard/threading/timers.md)","nodes":[{"pos":[4,521],"embed":true,"restype":"x-metadata","content":"title: \"The Managed Thread Pool | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"thread pooling [.NET Framework]\"\n  - \"thread pools [.NET Framework]\"\n  - \"threading [.NET Framework], thread pool\"\n  - \"threading [.NET Framework], pooling\"\nms.assetid: 2be05b06-a42e-4c9d-a739-96c21d673927\ncaps.latest.revision: 24\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","nodes":[{"content":"The Managed Thread Pool | Microsoft Docs","nodes":[{"pos":[0,40],"content":"The Managed Thread Pool | Microsoft Docs","nodes":[{"content":"The Managed Thread Pool | Microsoft Docs","pos":[0,40]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[528,551],"content":"The Managed Thread Pool","linkify":"The Managed Thread Pool","nodes":[{"content":"The Managed Thread Pool","pos":[0,23]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> class provides your application with a pool of worker threads that are managed by the system, allowing you to concentrate on application tasks rather than thread management.","pos":[552,764],"source":"The <xref:System.Threading.ThreadPool> class provides your application with a pool of worker threads that are managed by the system, allowing you to concentrate on application tasks rather than thread management."},{"content":"If you have short tasks that require background processing, the managed thread pool is an easy way to take advantage of multiple threads.","pos":[765,902]},{"content":"For example, beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph> you can create <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects, which perform asynchronous tasks on thread pool threads.","pos":[903,1156],"source":" For example, beginning with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] you can create <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects, which perform asynchronous tasks on thread pool threads."},{"pos":[1164,1690],"content":"[!NOTE]\n Starting with the [!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)], the throughput of the thread pool is significantly improved in three key areas that were identified as bottlenecks in previous releases of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]: queuing tasks, dispatching thread pool threads, and dispatching I/O completion threads. To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)] or later.","leadings":["","> "],"nodes":[{"content":"Starting with the [!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)], the throughput of the thread pool is significantly improved in three key areas that were identified as bottlenecks in previous releases of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]: queuing tasks, dispatching thread pool threads, and dispatching I/O completion threads. To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)] or later.","pos":[9,524],"nodes":[{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)]</ph>, the throughput of the thread pool is significantly improved in three key areas that were identified as bottlenecks in previous releases of the <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph>: queuing tasks, dispatching thread pool threads, and dispatching I/O completion threads.","pos":[0,380],"source":"Starting with the [!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)], the throughput of the thread pool is significantly improved in three key areas that were identified as bottlenecks in previous releases of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]: queuing tasks, dispatching thread pool threads, and dispatching I/O completion threads."},{"content":"To use this functionality, your application should target the <ph id=\"ph1\">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph> or later.","pos":[381,515],"source":" To use this functionality, your application should target the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)] or later."}]}]},{"pos":[1697,1927],"content":"For background tasks that interact with the user interface, the .NET Framework version 2.0 also provides the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> class, which communicates using events raised on the user interface thread.","source":"For background tasks that interact with the user interface, the .NET Framework version 2.0 also provides the <xref:System.ComponentModel.BackgroundWorker> class, which communicates using events raised on the user interface thread."},{"pos":[1934,2165],"content":"The .NET Framework uses thread pool threads for many purposes, including asynchronous I/O completion, timer callbacks, registered wait operations, asynchronous method calls using delegates, and <ph id=\"ph1\">&lt;xref:System.Net&gt;</ph> socket connections.","source":"The .NET Framework uses thread pool threads for many purposes, including asynchronous I/O completion, timer callbacks, registered wait operations, asynchronous method calls using delegates, and <xref:System.Net> socket connections."},{"pos":[2174,2209],"content":"When Not to Use Thread Pool Threads","linkify":"When Not to Use Thread Pool Threads","nodes":[{"content":"When Not to Use Thread Pool Threads","pos":[0,35]}]},{"content":"There are several scenarios in which it is appropriate to create and manage your own threads instead of using thread pool threads:","pos":[2213,2343]},{"content":"You require a foreground thread.","pos":[2353,2385]},{"content":"You require a thread to have a particular priority.","pos":[2395,2446]},{"content":"You have tasks that cause the thread to block for long periods of time.","pos":[2456,2527]},{"content":"The thread pool has a maximum number of threads, so a large number of blocked thread pool threads might prevent tasks from starting.","pos":[2528,2660]},{"content":"You need to place threads into a single-threaded apartment.","pos":[2670,2729]},{"content":"All <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads are in the multithreaded apartment.","pos":[2730,2812],"source":" All <xref:System.Threading.ThreadPool> threads are in the multithreaded apartment."},{"content":"You need to have a stable identity associated with the thread, or to dedicate a thread to a task.","pos":[2822,2919]},{"pos":[2928,2955],"content":"Thread Pool Characteristics","linkify":"Thread Pool Characteristics","nodes":[{"content":"Thread Pool Characteristics","pos":[0,27]}]},{"content":"Thread pool threads are background threads.","pos":[2959,3002]},{"content":"See <bpt id=\"p1\">[</bpt>Foreground and Background Threads<ept id=\"p1\">](../../../docs/standard/threading/foreground-and-background-threads.md)</ept>.","pos":[3003,3114],"source":" See [Foreground and Background Threads](../../../docs/standard/threading/foreground-and-background-threads.md)."},{"content":"Each thread uses the default stack size, runs at the default priority, and is in the multithreaded apartment.","pos":[3115,3224]},{"content":"There is only one thread pool per process.","pos":[3231,3273]},{"pos":[3283,3316],"content":"Exceptions in Thread Pool Threads","linkify":"Exceptions in Thread Pool Threads","nodes":[{"content":"Exceptions in Thread Pool Threads","pos":[0,33]}]},{"content":"Unhandled exceptions on thread pool threads terminate the process.","pos":[3320,3386]},{"content":"There are three exceptions to this rule:","pos":[3387,3427]},{"pos":[3437,3578],"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is thrown in a thread pool thread, because <ph id=\"ph2\">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> was called.","source":"A <xref:System.Threading.ThreadAbortException> is thrown in a thread pool thread, because <xref:System.Threading.Thread.Abort%2A> was called."},{"pos":[3588,3716],"content":"An <ph id=\"ph1\">&lt;xref:System.AppDomainUnloadedException&gt;</ph> is thrown in a thread pool thread, because the application domain is being unloaded.","source":"An <xref:System.AppDomainUnloadedException> is thrown in a thread pool thread, because the application domain is being unloaded."},{"content":"The common language runtime or a host process terminates the thread.","pos":[3726,3794]},{"pos":[3801,3926],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exceptions in Managed Threads<ept id=\"p1\">](../../../docs/standard/threading/exceptions-in-managed-threads.md)</ept>.","source":"For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md)."},{"pos":[3934,4196],"content":"[!NOTE]\n In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps unhandled exceptions in thread pool threads. This might corrupt application state and eventually cause applications to hang, which might be very difficult to debug.","leadings":["","> "],"nodes":[{"content":"In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps unhandled exceptions in thread pool threads. This might corrupt application state and eventually cause applications to hang, which might be very difficult to debug.","pos":[9,260],"nodes":[{"content":"In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps unhandled exceptions in thread pool threads.","pos":[0,131]},{"content":"This might corrupt application state and eventually cause applications to hang, which might be very difficult to debug.","pos":[132,251]}]}]},{"pos":[4206,4243],"content":"Maximum Number of Thread Pool Threads","linkify":"Maximum Number of Thread Pool Threads","nodes":[{"content":"Maximum Number of Thread Pool Threads","pos":[0,37]}]},{"content":"The number of operations that can be queued to the thread pool is limited only by available memory; however, the thread pool limits the number of threads that can be active in the process simultaneously.","pos":[4247,4450]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.","pos":[4451,4658],"source":" Beginning with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space."},{"content":"A process can call the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.GetMaxThreads%2A&gt;</ph> method to determine the number of threads.","pos":[4659,4776],"source":" A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads."},{"pos":[4783,4958],"content":"You can control the maximum number of threads by using the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.GetMaxThreads%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.SetMaxThreads%2A&gt;</ph> methods.","source":"You can control the maximum number of threads by using the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> and <xref:System.Threading.ThreadPool.SetMaxThreads%2A> methods."},{"pos":[4966,5190],"content":"[!NOTE]\n In the .NET Framework versions 1.0 and 1.1, the size of the thread pool cannot be set from managed code. Code that hosts the common language runtime can set the size using `CorSetMaxThreads`, defined in mscoree.h.","leadings":["","> "],"nodes":[{"content":"In the .NET Framework versions 1.0 and 1.1, the size of the thread pool cannot be set from managed code. Code that hosts the common language runtime can set the size using `CorSetMaxThreads`, defined in mscoree.h.","pos":[9,222],"nodes":[{"content":"In the .NET Framework versions 1.0 and 1.1, the size of the thread pool cannot be set from managed code.","pos":[0,104]},{"content":"Code that hosts the common language runtime can set the size using <ph id=\"ph1\">`CorSetMaxThreads`</ph>, defined in mscoree.h.","pos":[105,213],"source":" Code that hosts the common language runtime can set the size using `CorSetMaxThreads`, defined in mscoree.h."}]}]},{"pos":[5200,5220],"content":"Thread Pool Minimums","linkify":"Thread Pool Minimums","nodes":[{"content":"Thread Pool Minimums","pos":[0,20]}]},{"content":"The thread pool provides new worker threads or I/O completion threads on demand until it reaches a specified minimum for each category.","pos":[5224,5359]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.GetMinThreads%2A&gt;</ph> method to obtain these minimum values.","pos":[5360,5466],"source":" You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values."},{"pos":[5474,5580],"content":"[!NOTE]\n When demand is low, the actual number of thread pool threads can fall below the minimum values.","leadings":["","> "],"nodes":[{"content":"When demand is low, the actual number of thread pool threads can fall below the minimum values.","pos":[9,104]}]},{"content":"When a minimum is reached, the thread pool can create additional threads or wait until some tasks complete.","pos":[5587,5694]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.","pos":[5695,5936],"source":" Beginning with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time."},{"content":"Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.","pos":[5937,6064]},{"pos":[6072,6463],"content":"[!CAUTION]\n You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of idle threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.","leadings":["","> "],"nodes":[{"content":"You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of idle threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.","pos":[12,389],"nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.SetMinThreads%2A&gt;</ph> method to increase the minimum number of idle threads.","pos":[0,122],"source":"You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of idle threads."},{"content":"However, unnecessarily increasing these values can cause performance problems.","pos":[123,201]},{"content":"If too many tasks start at the same time, all of them might appear to be slow.","pos":[202,280]},{"content":"In most cases the thread pool will perform better with its own algorithm for allocating threads.","pos":[281,377]}]}]},{"pos":[6472,6496],"content":"Skipping Security Checks","linkify":"Skipping Security Checks","nodes":[{"content":"Skipping Security Checks","pos":[0,24]}]},{"content":"The thread pool also provides the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=fullName&gt;</ph> methods.","pos":[6500,6730],"source":"The thread pool also provides the <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName> and <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A?displayProperty=fullName> methods."},{"content":"Use these methods only when you are certain that the caller's stack is irrelevant to any security checks performed during the execution of the queued task.","pos":[6731,6886]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt;</ph>and <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt;</ph> both capture the caller's stack, which is merged into the stack of the thread pool thread when the thread begins to execute a task.","pos":[6887,7143],"source":"<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>and <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> both capture the caller's stack, which is merged into the stack of the thread pool thread when the thread begins to execute a task."},{"content":"If a security check is required, the entire stack must be checked.","pos":[7144,7210]},{"content":"Although the check provides safety, it also has a performance cost.","pos":[7211,7278]},{"pos":[7287,7308],"content":"Using the Thread Pool","linkify":"Using the Thread Pool","nodes":[{"content":"Using the Thread Pool","pos":[0,21]}]},{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, the easiest way to use the thread pool is to use the <bpt id=\"p1\">[</bpt>Task Parallel Library (TPL)<ept id=\"p1\">](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)</ept>.","pos":[7312,7554],"source":"Beginning with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the easiest way to use the thread pool is to use the [Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)."},{"content":"By default, parallel library types like <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> use thread pool threads to run tasks.","pos":[7555,7710],"source":" By default, parallel library types like <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> use thread pool threads to run tasks."},{"content":"You can also use the thread pool by calling <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName&gt;</ph> from managed code (or <ph id=\"ph2\">`CorQueueUserWorkItem`</ph> from unmanaged code) and passing a <ph id=\"ph3\">&lt;xref:System.Threading.WaitCallback&gt;</ph> delegate representing the method that performs the task.","pos":[7711,8009],"source":" You can also use the thread pool by calling <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> from managed code (or `CorQueueUserWorkItem` from unmanaged code) and passing a <xref:System.Threading.WaitCallback> delegate representing the method that performs the task."},{"content":"Another way to use the thread pool is to queue work items that are related to a wait operation by using the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=fullName&gt;</ph> method and passing a <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> that, when signaled or when timed out, calls the method represented by the <ph id=\"ph3\">&lt;xref:System.Threading.WaitOrTimerCallback&gt;</ph> delegate.","pos":[8010,8393],"source":" Another way to use the thread pool is to queue work items that are related to a wait operation by using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=fullName> method and passing a <xref:System.Threading.WaitHandle> that, when signaled or when timed out, calls the method represented by the <xref:System.Threading.WaitOrTimerCallback> delegate."},{"content":"Thread pool threads are used to invoke callback methods.","pos":[8394,8450]},{"pos":[8459,8478],"content":"ThreadPool Examples","linkify":"ThreadPool Examples","nodes":[{"content":"ThreadPool Examples","pos":[0,19]}]},{"pos":[8482,8798],"content":"The code examples in this section demonstrate the thread pool by using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class, the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName&gt;</ph> method, and the <ph id=\"ph3\">&lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=fullName&gt;</ph> method.","source":"The code examples in this section demonstrate the thread pool by using the <xref:System.Threading.Tasks.Task> class, the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> method, and the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A?displayProperty=fullName> method."},{"pos":[8808,8891],"content":"<bpt id=\"p1\">[</bpt>Executing Asynchronous Tasks with the Task Parallel Library<ept id=\"p1\">](#TaskParallelLibrary)</ept>","source":"[Executing Asynchronous Tasks with the Task Parallel Library](#TaskParallelLibrary)"},{"pos":[8901,8977],"content":"<bpt id=\"p1\">[</bpt>Executing Code Asynchronously with QueueUserWorkItem<ept id=\"p1\">](#ExecuteCodeWithQUWI)</ept>","source":"[Executing Code Asynchronously with QueueUserWorkItem](#ExecuteCodeWithQUWI)"},{"pos":[8987,9048],"content":"<bpt id=\"p1\">[</bpt>Supplying Task Data for QueueUserWorkItem<ept id=\"p1\">](#TaskDataForQUWI)</ept>","source":"[Supplying Task Data for QueueUserWorkItem](#TaskDataForQUWI)"},{"pos":[9058,9123],"content":"<bpt id=\"p1\">[</bpt>Using RegisterWaitForSingleObject<ept id=\"p1\">](#RegisterWaitForSingleObject)</ept>","source":"[Using RegisterWaitForSingleObject](#RegisterWaitForSingleObject)"},{"pos":[9171,9230],"content":"Executing Asynchronous Tasks with the Task Parallel Library","linkify":"Executing Asynchronous Tasks with the Task Parallel Library","nodes":[{"content":"Executing Asynchronous Tasks with the Task Parallel Library","pos":[0,59]}]},{"content":"The following example shows how to create and use a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object by calling the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName&gt;</ph> method.","pos":[9234,9429],"source":"The following example shows how to create and use a <xref:System.Threading.Tasks.Task> object by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> method."},{"content":"For an example that uses the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class to return a value from an asynchronous task, see <bpt id=\"p1\">[</bpt>How to: Return a Value from a Task<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)</ept>.","pos":[9430,9672],"source":" For an example that uses the <xref:System.Threading.Tasks.Task%601> class to return a value from an asynchronous task, see [How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)."},{"pos":[10028,10080],"content":"Executing Code Asynchronously with QueueUserWorkItem","linkify":"Executing Code Asynchronously with QueueUserWorkItem","nodes":[{"content":"Executing Code Asynchronously with QueueUserWorkItem","pos":[0,52]}]},{"pos":[10084,10246],"content":"The following example queues a very simple task, represented by the <ph id=\"ph1\">`ThreadProc`</ph> method, using the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt;</ph> method.","source":"The following example queues a very simple task, represented by the `ThreadProc` method, using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method."},{"pos":[10679,10720],"content":"Supplying Task Data for QueueUserWorkItem","linkify":"Supplying Task Data for QueueUserWorkItem","nodes":[{"content":"Supplying Task Data for QueueUserWorkItem","pos":[0,41]}]},{"pos":[10724,10872],"content":"The following code example uses the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A&gt;</ph> method to queue a task and supply the data for the task.","source":"The following code example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a task and supply the data for the task."},{"pos":[11317,11350],"content":"Using RegisterWaitForSingleObject","linkify":"Using RegisterWaitForSingleObject","nodes":[{"content":"Using RegisterWaitForSingleObject","pos":[0,33]}]},{"content":"The following example demonstrates several threading features.","pos":[11354,11416]},{"pos":[11426,11584],"content":"Queuing a task for execution by <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads, with the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A&gt;</ph> method.","source":"Queuing a task for execution by <xref:System.Threading.ThreadPool> threads, with the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method."},{"content":"Signaling a task to execute, with <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>.","pos":[11594,11667],"source":"Signaling a task to execute, with <xref:System.Threading.AutoResetEvent>."},{"content":"See <bpt id=\"p1\">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id=\"p1\">](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.","pos":[11668,11840],"source":" See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)."},{"pos":[11850,11946],"content":"Handling both time-outs and signals with a <ph id=\"ph1\">&lt;xref:System.Threading.WaitOrTimerCallback&gt;</ph> delegate.","source":"Handling both time-outs and signals with a <xref:System.Threading.WaitOrTimerCallback> delegate."},{"pos":[11956,12030],"content":"Canceling a queued task with <ph id=\"ph1\">&lt;xref:System.Threading.RegisteredWaitHandle&gt;</ph>.","source":"Canceling a queued task with <xref:System.Threading.RegisteredWaitHandle>."},{"pos":[12037,12419],"content":"[!code-cpp[Conceptual.ThreadPool#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.threadpool/cpp/source3.cpp#3)]\n[!code-csharp[Conceptual.ThreadPool#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.threadpool/cs/source3.cs#3)]\n[!code-vb[Conceptual.ThreadPool#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.threadpool/vb/source3.vb#3)]","leadings":[""," "," "],"nodes":[]},{"pos":[12428,12436],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Task Parallel Library (TPL)<ept id=\"p1\">](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)</ept><ph id=\"ph1\"> </ph>","pos":[12561,12665],"source":"[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md) "},{"content":"<bpt id=\"p1\">[</bpt>Task Parallel Library (TPL)<ept id=\"p1\">](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)</ept><ph id=\"ph1\"> </ph>","pos":[12669,12773],"source":"[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Return a Value from a Task<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)</ept><ph id=\"ph1\"> </ph>","pos":[12777,12896],"source":"[How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md) "},{"content":"<bpt id=\"p1\">[</bpt>Threading Objects and Features<ept id=\"p1\">](../../../docs/standard/threading/threading-objects-and-features.md)</ept><ph id=\"ph1\"> </ph>","pos":[12900,13001],"source":"[Threading Objects and Features](../../../docs/standard/threading/threading-objects-and-features.md) "},{"content":"<bpt id=\"p1\">[</bpt>Threads and Threading<ept id=\"p1\">](../../../docs/standard/threading/threads-and-threading.md)</ept><ph id=\"ph1\"> </ph>","pos":[13005,13088],"source":"[Threads and Threading](../../../docs/standard/threading/threads-and-threading.md) "},{"content":"<bpt id=\"p1\">[</bpt>Asynchronous File I/O<ept id=\"p1\">](../../../docs/standard/io/asynchronous-file-i-o.md)</ept><ph id=\"ph1\"> </ph>","pos":[13092,13168],"source":"[Asynchronous File I/O](../../../docs/standard/io/asynchronous-file-i-o.md) "},{"content":"<bpt id=\"p1\">[</bpt>Timers<ept id=\"p1\">](../../../docs/standard/threading/timers.md)</ept>","pos":[13172,13224],"source":"[Timers](../../../docs/standard/threading/timers.md)"}]}