{"content":"---\ntitle: \"Client Channel-Level Programming\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 3b787719-4e77-4e77-96a6-5b15a11b995a\n---\n# Client Channel-Level Programming\nThis topic describes how to write a Windows Communication Foundation (WCF) client application without using the <xref:System.ServiceModel.ClientBase%601?displayProperty=nameWithType> class and its associated object model.  \n  \n## Sending Messages  \n To be ready to send messages and receive and process replies, the following steps are required:  \n  \n1.  Create a binding.  \n  \n2.  Build a channel factory.  \n  \n3.  Create a channel.  \n  \n4.  Send a request and read the reply.  \n  \n5.  Close all channel objects.  \n  \n#### Creating a Binding  \n Similar to the receiving case (see [Service Channel-Level Programming](../../../../docs/framework/wcf/extending/service-channel-level-programming.md)), sending messages starts by creating a binding. This example creates a new <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType> and adds an <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType> to its Elements collection.  \n  \n#### Building a ChannelFactory  \n Instead of creating a <xref:System.ServiceModel.Channels.IChannelListener?displayProperty=nameWithType>, this time we create a <xref:System.ServiceModel.ChannelFactory%601?displayProperty=nameWithType> by calling <xref:System.ServiceModel.ChannelFactory.CreateFactory%2A?displayProperty=nameWithType> on the binding where the type parameter is <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>. While channel listeners are used by the side that waits for incoming messages, channel factories are used by the side that initiates the communication to create a channel. Just like channel listeners, channel factories must be opened first before they can be used.  \n  \n#### Creating a Channel  \n We then call <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType> to create an <xref:System.ServiceModel.Channels.IRequestChannel>. This call takes the address of the endpoint with which we want to communicate using the new channel being created. Once we have a channel, we call Open on it to put it in a state ready for communication. Depending on the nature of the transport, this call to Open may initiate a connection with the target endpoint or may do nothing at all on the network.  \n  \n#### Sending a Request and Reading the Reply  \n Once we have an opened channel, we can create a message and use the channel’s Request method to send the request and wait for the reply to come back. When this method returns, we have a reply message that we can read to find out what the endpoint’s reply was.  \n  \n#### Closing Objects  \n To avoid leaking resources, we close objects used in communications when they are no longer required.  \n  \n The following code example shows a basic client using the channel factory to send a message and read the reply.  \n  \n [!code-csharp[ChannelProgrammingBasic#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/channelprogrammingbasic/cs/clientprogram.cs#2)]\n [!code-vb[ChannelProgrammingBasic#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/channelprogrammingbasic/vb/clientprogram.vb#2)]\n","nodes":[{"pos":[4,150],"embed":true,"restype":"x-metadata","content":"title: \"Client Channel-Level Programming\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 3b787719-4e77-4e77-96a6-5b15a11b995a","nodes":[{"content":"Client Channel-Level Programming","nodes":[{"pos":[0,32],"content":"Client Channel-Level Programming","nodes":[{"content":"Client Channel-Level Programming","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[157,189],"content":"Client Channel-Level Programming","linkify":"Client Channel-Level Programming","nodes":[{"content":"Client Channel-Level Programming","pos":[0,32]}]},{"pos":[190,411],"content":"This topic describes how to write a Windows Communication Foundation (WCF) client application without using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ClientBase%601?displayProperty=nameWithType&gt;</ph> class and its associated object model.","source":"This topic describes how to write a Windows Communication Foundation (WCF) client application without using the <xref:System.ServiceModel.ClientBase%601?displayProperty=nameWithType> class and its associated object model."},{"pos":[420,436],"content":"Sending Messages","linkify":"Sending Messages","nodes":[{"content":"Sending Messages","pos":[0,16]}]},{"content":"To be ready to send messages and receive and process replies, the following steps are required:","pos":[440,535]},{"content":"Create a binding.","pos":[545,562]},{"content":"Build a channel factory.","pos":[572,596]},{"content":"Create a channel.","pos":[606,623]},{"content":"Send a request and read the reply.","pos":[633,667]},{"content":"Close all channel objects.","pos":[677,703]},{"pos":[714,732],"content":"Creating a Binding","linkify":"Creating a Binding","nodes":[{"content":"Creating a Binding","pos":[0,18]}]},{"content":"Similar to the receiving case (see <bpt id=\"p1\">[</bpt>Service Channel-Level Programming<ept id=\"p1\">](../../../../docs/framework/wcf/extending/service-channel-level-programming.md)</ept>), sending messages starts by creating a binding.","pos":[736,934],"source":"Similar to the receiving case (see [Service Channel-Level Programming](../../../../docs/framework/wcf/extending/service-channel-level-programming.md)), sending messages starts by creating a binding."},{"content":"This example creates a new <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType&gt;</ph> and adds an <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType&gt;</ph> to its Elements collection.","pos":[935,1173],"source":" This example creates a new <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType> and adds an <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType> to its Elements collection."},{"pos":[1184,1209],"content":"Building a ChannelFactory","linkify":"Building a ChannelFactory","nodes":[{"content":"Building a ChannelFactory","pos":[0,25]}]},{"content":"Instead of creating a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener?displayProperty=nameWithType&gt;</ph>, this time we create a <ph id=\"ph2\">&lt;xref:System.ServiceModel.ChannelFactory%601?displayProperty=nameWithType&gt;</ph> by calling <ph id=\"ph3\">&lt;xref:System.ServiceModel.ChannelFactory.CreateFactory%2A?displayProperty=nameWithType&gt;</ph> on the binding where the type parameter is <ph id=\"ph4\">&lt;xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType&gt;</ph>.","pos":[1213,1638],"source":"Instead of creating a <xref:System.ServiceModel.Channels.IChannelListener?displayProperty=nameWithType>, this time we create a <xref:System.ServiceModel.ChannelFactory%601?displayProperty=nameWithType> by calling <xref:System.ServiceModel.ChannelFactory.CreateFactory%2A?displayProperty=nameWithType> on the binding where the type parameter is <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>."},{"content":"While channel listeners are used by the side that waits for incoming messages, channel factories are used by the side that initiates the communication to create a channel.","pos":[1639,1810]},{"content":"Just like channel listeners, channel factories must be opened first before they can be used.","pos":[1811,1903]},{"pos":[1914,1932],"content":"Creating a Channel","linkify":"Creating a Channel","nodes":[{"content":"Creating a Channel","pos":[0,18]}]},{"content":"We then call <ph id=\"ph1\">&lt;xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType&gt;</ph> to create an <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IRequestChannel&gt;</ph>.","pos":[1936,2106],"source":"We then call <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType> to create an <xref:System.ServiceModel.Channels.IRequestChannel>."},{"content":"This call takes the address of the endpoint with which we want to communicate using the new channel being created.","pos":[2107,2221]},{"content":"Once we have a channel, we call Open on it to put it in a state ready for communication.","pos":[2222,2310]},{"content":"Depending on the nature of the transport, this call to Open may initiate a connection with the target endpoint or may do nothing at all on the network.","pos":[2311,2462]},{"pos":[2473,2512],"content":"Sending a Request and Reading the Reply","linkify":"Sending a Request and Reading the Reply","nodes":[{"content":"Sending a Request and Reading the Reply","pos":[0,39]}]},{"content":"Once we have an opened channel, we can create a message and use the channel’s Request method to send the request and wait for the reply to come back.","pos":[2516,2665]},{"content":"When this method returns, we have a reply message that we can read to find out what the endpoint’s reply was.","pos":[2666,2775]},{"pos":[2786,2801],"content":"Closing Objects","linkify":"Closing Objects","nodes":[{"content":"Closing Objects","pos":[0,15]}]},{"content":"To avoid leaking resources, we close objects used in communications when they are no longer required.","pos":[2805,2906]},{"content":"The following code example shows a basic client using the channel factory to send a message and read the reply.","pos":[2913,3024]}]}