{"content":"---\ntitle: \"Understanding XAML Node Stream Structures and Concepts\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords:\n  - \"XAML node streams [XAML Services]\"\n  - \"nodes [XAML Services], XAML node stream\"\n  - \"XAML [XAML Services], XAML node streams\"\nms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3\n---\n\n# Understanding XAML Node Stream Structures and Concepts\n\nXAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream. The XAML node stream is a conceptualization of a set of XAML nodes. In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time. At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position. The current node in a XAML node stream can be described as being an object, a member, or a value. By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML. XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes. This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.\n\n<a name=\"loading_into_a_xaml_reader\"></a>\n\n## Loading XAML into a XAML Reader\n\nThe base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader. Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML. For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base. The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.\n\nThe most prominent .NET Framework XAML Servicesâ€“defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>. <xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>. The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded. However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML. When first loaded, the first single node you encounter is the root of the XAML, and its start object.\n\n### The XAML Node Stream Concept\n\nIf you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows. Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly. As you advance through the nodes, you might be traversing \"in\" or \"out\" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream. The node stream has a \"current\" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.\n\nThe XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation. For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation. In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph. This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go \"back\" in the node stream. Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.\n\n<a name=\"a_basic_reading_node_loop\"></a>\n\n## A Basic Reading Node Loop\n\nA basic reading node loop for examining a XAML node stream consists of the following concepts. For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>. The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.\n\n- Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value). If you are at the end of the stream, there is no current node and you should exit.\n\n- Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.\n\n- If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.\n\n- Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:\n\n    - For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member. Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object. For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.\n\n    - For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.\n\n    - For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>. A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).\n\n    - For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.\n\n- Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.\n\nThe XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes. Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.\n\nIf the node stream is at end of file, the current node is null.\n\nThe simplest loop that uses a reader and writer resembles the following example.\n\n```csharp\nXamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));\n//where xamlStringToLoad is a string of well formed XAML\nXamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);\nwhile (xxr.Read()) {\n  xow.WriteNode(xxr);\n}\n```\n\nThis basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>. But this basic structure is then expanded to apply to your reading or writing scenario. Some possible scenarios are as follows:\n\n- Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>. Perform different actions depending on which node type is being read.\n\n- Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases. Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.\n\n- Within the logic for a particular node type, analyze the specifics of that node and act on them. For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace. Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.\n\n- Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.\n\n- Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.\n\n### Accessing XAML Beyond the Node Loop Concept\n\nThere are potentially other ways to work with a XAML representation other than as a XAML node loop. For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers. .NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types. For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.\n\n> [!TIP]\n> Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit. This out-of-band release is still in its pre-release stages. However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML. The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight. For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).\n\n<a name=\"working_with_the_current_node\"></a>\n\n## Working with the Current Node\n\nMost scenarios that use a XAML node loop do not only read the nodes. Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.\n\nIn the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>. You then integrate the resulting object graph into your application or framework.\n\nIn a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file. The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.\n\n### Frames and Scope\n\nA XAML node loop walks through a XAML node stream in a linear way. The node stream traverses into objects, into members that contain other objects, and so on. It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept. This is particularly true if you are actively adjusting the node stream while you are in it. The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.\n\n<a name=\"traversing_and_entering_object_nodes\"></a>\n\n## Traversing and Entering Object Nodes\n\nThe first node in a node stream when it is opened by a XAML reader is the start-object node of the root object. By definition, this object is always a single object node and has no peers. In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes. The member nodes then have one or more object nodes, or might also terminate in a value node instead. The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.\n\nConsider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework). Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.\n\n|XAML markup|Resulting XAML node stream|\n|-----------------|--------------------------------|\n|`<Party`|`Namespace` node for `Party`|\n|`xmlns=\"PartyXamlNamespace\">`|`StartObject` node for `Party`|\n|`<Party.Favors>`|`StartMember` node for `Party.Favors`|\n||`StartObject` node for implicit `FavorCollection`|\n||`StartMember` node for implicit `FavorCollection` items property.|\n|`<Balloon`|`StartObject` node for `Balloon`|\n|`Color=\"Red\"`|`StartMember` node for `Color`<br /><br /> `Value` node for the attribute value string `\"Red\"`<br /><br /> `EndMember` for `Color`|\n|`HasHelium=\"True\"`|`StartMember` node for `HasHelium`<br /><br /> `Value` node for the attribute value string `\"True\"`<br /><br /> `EndMember` for `HasHelium`|\n|`>`|`EndObject` for `Balloon`|\n|`<NoiseMaker>Loudest</NoiseMaker>`|`StartObject` node for `NoiseMaker`<br /><br /> `StartMember` node for `_Initialization`<br /><br /> `Value` node for the initialization value string `\"Loudest\"`<br /><br /> `EndMember` node for `_Initialization`<br /><br /> `EndObject` for `NoiseMaker`|\n||`EndMember` node for implicit `FavorCollection` items property.|\n||`EndObject` node for implicit `FavorCollection`|\n|`</Party.Favors>`|`EndMember` for `Favors`|\n|`</Party>`|`EndObject` for `Party`|\n\nIn the XAML node stream, you can rely on the following behavior:\n\n- If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`. Look at the previous table with the XAML and example node stream again. Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup. This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream. The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object. Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.\n\n- Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.\n\n- A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`. It is never followed immediately by another `StartObject`.\n\n- A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`. It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value. It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`. It is never followed immediately by another `StartMember`.\n\n- A `Value` node represents the value itself; there is no \"EndValue\". It can be followed only by an `EndMember`.\n\n    - XAML initialization text of the object as might be used by construction does not result in an Object-Value structure. Instead, a dedicated member node for a member named `_Initialization` is created. and that member node contains the initialization value string. If it exists, `_Initialization` is always the first `StartMember`. `_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.\n\n    - A Member-Value combination represents an attribute setting of the value. There might eventually be a value converter involved in processing this value, and the value is a plain string. However, that is not evaluated until a XAML object writer processes this node stream. The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.\n\n- An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.\n\n- An `EndObject` node can be followed by an `EndMember` node. It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items. Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.\n\n    - For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.\n\n<a name=\"value_converters_and_the_xaml_node_stream\"></a>\n\n## Value Converters and the XAML Node Stream\n\nA value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system. In the XAML node stream, a type converter usage and a markup extension usage have very different representations.\n\n### Type Converters in the XAML Node Stream\n\nAn attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member. The XAML node stream does not attempt to produce a type converter instance object and pass the value to it. Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping. Even determining which type converter class should be used to process the value requires the XAML schema context indirectly. When you use the default XAML schema context, that information is available from the XAML type system. If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set. But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.\n\nFor example, consider the following class definition outline and XAML usage for it:\n\n```csharp\npublic class BoardSizeConverter : TypeConverter {\n  //converts from string to an int[2] by splitting on an \"x\" char\n}\npublic class GameBoard {\n  [TypeConverter(typeof(BoardSizeConverter))]\n  public int[] BoardSize; //2x2 array, initialization not shown\n}\n```\n\n```xaml\n<GameBoard BoardSize=\"8x8\"/>\n```\n\nA text representation of the XAML node stream for this usage could be expressed as the following:\n\n`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`\n\n`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`\n\n`Value` node, with text string \"`8x8`\"\n\n`EndMember` matches `BoardSize`\n\n`EndObject` matches `GameBoard`\n\nNotice that there is no type converter instance in this node stream. But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`. If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.\n\n### Markup Extensions in the XAML Node Stream\n\nA markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance. Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information. <xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.\n\nThe node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case). Markup extension usages that used an explicit object element form are treated the same way.\n\nWithin a markup extension object node, there may be members of that markup extension. The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.\n\nFor a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage. This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint. The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it. To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.\n\nFor a named parameter usage, each named parameter is represented as a member node of that name in the node stream. The member values are not necessarily strings, because there could be a nested markup extension usage.\n\n`ProvideValue` from the markup extension is not yet invoked. However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream. For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path. Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.\n\n<a name=\"xaml_and_xml_languagedefined_members_in_the_xaml_node_stream\"></a>\n\n## XAML and XML Language-Defined Members in the XAML Node Stream\n\nCertain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction. Often, these members are XAML directives. In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream. In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.\n\nThe following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.\n\n- **Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace. You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.\n\n- **Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace. It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML. You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.\n\n- **Unknown content:** The name of this member node is `_UnknownContent`. Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace. This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context. You can detect this case in a XAML node stream by checking for members named `_UnknownContent`. If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object. The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit. You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.\n\n- **Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution. Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type. In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`. A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.\n\n    Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context. For example,\n\n- **XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations. The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`. Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.\n\n## Node Order\n\nIn some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML. This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.  In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.\n\nCertain directives are intended specifically to provide more information for the creation of an object from an object element. These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`. The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.\n\n### XamlObjectWriter Behavior and Node Order\n\n`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance. XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a default constructor to produce the initial object, and only then setting properties. These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009). Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.\n\n### GetObject\n\n`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property. A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model. In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.\n\n## See also\n\n- <xref:System.Xaml.XamlObjectReader>\n- [XAML Services](index.md)\n- [XAML Namespaces](xaml-namespaces-for-net-framework-xaml-services.md)\n","nodes":[{"pos":[4,291],"embed":true,"restype":"x-metadata","content":"title: \"Understanding XAML Node Stream Structures and Concepts\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords:\n  - \"XAML node streams [XAML Services]\"\n  - \"nodes [XAML Services], XAML node stream\"\n  - \"XAML [XAML Services], XAML node streams\"\nms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3","nodes":[{"content":"Understanding XAML Node Stream Structures and Concepts","nodes":[{"pos":[0,54],"content":"Understanding XAML Node Stream Structures and Concepts","nodes":[{"content":"Understanding XAML Node Stream Structures and Concepts","pos":[0,54]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[299,353],"content":"Understanding XAML Node Stream Structures and Concepts","linkify":"Understanding XAML Node Stream Structures and Concepts","nodes":[{"content":"Understanding XAML Node Stream Structures and Concepts","pos":[0,54]}]},{"content":"XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.","pos":[355,486]},{"content":"The XAML node stream is a conceptualization of a set of XAML nodes.","pos":[487,554]},{"content":"In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.","pos":[555,679]},{"content":"At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.","pos":[680,858]},{"content":"The current node in a XAML node stream can be described as being an object, a member, or a value.","pos":[859,956]},{"content":"By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.","pos":[957,1203]},{"content":"XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the <ph id=\"ph1\">[!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)]</ph> and the <ph id=\"ph2\">&lt;xref:System.Xml.XmlReader&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Xml.XmlWriter&gt;</ph> classes.","pos":[1204,1502],"source":" XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes."},{"content":"This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.","pos":[1503,1654]},{"pos":[1702,1733],"content":"Loading XAML into a XAML Reader","linkify":"Loading XAML into a XAML Reader","nodes":[{"content":"Loading XAML into a XAML Reader","pos":[0,31]}]},{"content":"The base <ph id=\"ph1\">&lt;xref:System.Xaml.XamlReader&gt;</ph> class does not declare a particular technique for loading the initial XAML into a XAML reader.","pos":[1735,1868],"source":"The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader."},{"content":"Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.","pos":[1869,2024]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectReader&gt;</ph> reads an object graph, starting from the input source of a single object that represents the root or base.","pos":[2025,2182],"source":" For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectReader&gt;</ph> then produces a XAML node stream from the object graph.","pos":[2183,2278],"source":" The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph."},{"content":"The most prominent .NET Framework XAML Servicesâ€“defined <ph id=\"ph1\">&lt;xref:System.Xaml.XamlReader&gt;</ph> subclass is <ph id=\"ph2\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph>.","pos":[2280,2411],"source":"The most prominent .NET Framework XAML Servicesâ€“defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <ph id=\"ph2\">&lt;xref:System.IO.TextReader&gt;</ph>.","pos":[2412,2620],"source":"<xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xaml.XamlReader&gt;</ph> can be thought of as containing the entirety of the XAML input source after it has loaded.","pos":[2621,2745],"source":" The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Xaml.XamlReader&gt;</ph> base API is designed so that the reader is interacting with a single node of the XAML.","pos":[2746,2875],"source":" However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML."},{"content":"When first loaded, the first single node you encounter is the root of the XAML, and its start object.","pos":[2876,2977]},{"pos":[2983,3011],"content":"The XAML Node Stream Concept","linkify":"The XAML Node Stream Concept","nodes":[{"content":"The XAML Node Stream Concept","pos":[0,28]}]},{"content":"If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.","pos":[3013,3205]},{"content":"Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.","pos":[3206,3333]},{"content":"As you advance through the nodes, you might be traversing \"in\" or \"out\" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.","pos":[3334,3568]},{"content":"The node stream has a \"current\" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.","pos":[3569,3772]},{"content":"The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.","pos":[3774,4120]},{"content":"For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.","pos":[4121,4374]},{"content":"In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.","pos":[4375,4569]},{"content":"This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go \"back\" in the node stream.","pos":[4570,4731]},{"content":"Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.","pos":[4732,4858]},{"pos":[4905,4930],"content":"A Basic Reading Node Loop","linkify":"A Basic Reading Node Loop","nodes":[{"content":"A Basic Reading Node Loop","pos":[0,25]}]},{"content":"A basic reading node loop for examining a XAML node stream consists of the following concepts.","pos":[4932,5026]},{"content":"For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph>.","pos":[5027,5188],"source":" For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>."},{"content":"The links in this section refer to the particular XAML node loop API implemented by <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph>.","pos":[5189,5306],"source":" The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>."},{"content":"Make sure that you are not at the end of the XAML node stream (check <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.IsEof%2A&gt;</ph>, or use the <ph id=\"ph2\">&lt;xref:System.Xaml.XamlXmlReader.Read%2A&gt;</ph> return value).","pos":[5310,5488],"source":"Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value)."},{"content":"If you are at the end of the stream, there is no current node and you should exit.","pos":[5489,5571]},{"pos":[5575,5694],"content":"Check what type of node the XAML node stream currently exposes by calling <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph>.","source":"Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>."},{"pos":[5698,5847],"content":"If you have an associated XAML object writer that is connected directly, you generally call <ph id=\"ph1\">&lt;xref:System.Xaml.XamlWriter.WriteNode%2A&gt;</ph> at this point.","source":"If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point."},{"pos":[5851,6021],"content":"Based on which <ph id=\"ph1\">&lt;xref:System.Xaml.XamlNodeType&gt;</ph> is reported as the current node or current record, call one of the following to obtain information about the node contents:","source":"Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:"},{"content":"For a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph> of <ph id=\"ph2\">&lt;xref:System.Xaml.XamlNodeType.StartMember&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Xaml.XamlNodeType.EndMember&gt;</ph>, call <ph id=\"ph4\">&lt;xref:System.Xaml.XamlXmlReader.Member%2A&gt;</ph> to obtain <ph id=\"ph5\">&lt;xref:System.Xaml.XamlMember&gt;</ph> information about a member.","pos":[6029,6288],"source":"For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member."},{"content":"Note that the member might be a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlDirective&gt;</ph>, and thus might not necessarily be a conventional type-defined member of the preceding object.","pos":[6289,6448],"source":" Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object."},{"content":"For example, <ph id=\"ph1\">`x:Name`</ph> applied to an object appears as a XAML member where <ph id=\"ph2\">&lt;xref:System.Xaml.XamlMember.IsDirective%2A&gt;</ph> is true and the <ph id=\"ph3\">&lt;xref:System.Xaml.XamlMember.Name%2A&gt;</ph> of the member is <ph id=\"ph4\">`Name`</ph>, with other properties indicating that this directive is under the XAML language XAML namespace.","pos":[6449,6742],"source":" For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace."},{"pos":[6750,7006],"content":"For a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph> of <ph id=\"ph2\">&lt;xref:System.Xaml.XamlNodeType.StartObject&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Xaml.XamlNodeType.EndObject&gt;</ph>, call <ph id=\"ph4\">&lt;xref:System.Xaml.XamlXmlReader.Type%2A&gt;</ph> to obtain <ph id=\"ph5\">&lt;xref:System.Xaml.XamlType&gt;</ph> information about an object.","source":"For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object."},{"content":"For a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph> of <ph id=\"ph2\">&lt;xref:System.Xaml.XamlNodeType.Value&gt;</ph>, call <ph id=\"ph3\">&lt;xref:System.Xaml.XamlXmlReader.Value%2A&gt;</ph>.","pos":[7014,7154],"source":"For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>."},{"content":"A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).","pos":[7155,7387]},{"pos":[7395,7607],"content":"For a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph> of <ph id=\"ph2\">&lt;xref:System.Xaml.XamlNodeType.NamespaceDeclaration&gt;</ph>, call <ph id=\"ph3\">&lt;xref:System.Xaml.XamlXmlReader.Namespace%2A&gt;</ph> to obtain namespace information for a namespace node.","source":"For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node."},{"pos":[7611,7753],"content":"Call <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.Read%2A&gt;</ph> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.","source":"Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again."},{"content":"The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.","pos":[7755,7891]},{"content":"Typical flow-control techniques for a XAML node loop include defining a body within <ph id=\"ph1\">`while (reader.Read())`</ph>, and switching on <ph id=\"ph2\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph> at each node point in the node loop.","pos":[7892,8099],"source":" Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop."},{"content":"If the node stream is at end of file, the current node is null.","pos":[8101,8164]},{"content":"The simplest loop that uses a reader and writer resembles the following example.","pos":[8166,8246]},{"content":"This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <ph id=\"ph1\">&lt;xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType&gt;</ph>.","pos":[8504,8724],"source":"This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>."},{"content":"But this basic structure is then expanded to apply to your reading or writing scenario.","pos":[8725,8812]},{"content":"Some possible scenarios are as follows:","pos":[8813,8852]},{"content":"Switch on <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph>.","pos":[8856,8911],"source":"Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>."},{"content":"Perform different actions depending on which node type is being read.","pos":[8912,8981]},{"content":"Do not call <ph id=\"ph1\">&lt;xref:System.Xaml.XamlWriter.WriteNode%2A&gt;</ph> in all cases.","pos":[8985,9053],"source":"Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases."},{"content":"Only call <ph id=\"ph1\">&lt;xref:System.Xaml.XamlWriter.WriteNode%2A&gt;</ph> in some <ph id=\"ph2\">&lt;xref:System.Xaml.XamlXmlReader.NodeType%2A&gt;</ph> cases.","pos":[9054,9166],"source":" Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases."},{"content":"Within the logic for a particular node type, analyze the specifics of that node and act on them.","pos":[9170,9266]},{"content":"For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.","pos":[9267,9417]},{"content":"Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.","pos":[9418,9552]},{"pos":[9556,9708],"content":"Define a custom <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph> that overrides <ph id=\"ph2\">`Write*`</ph> methods, possibly performing type mapping that bypasses XAML schema context.","source":"Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context."},{"pos":[9712,9891],"content":"Construct the <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.","source":"Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer."},{"pos":[9897,9940],"content":"Accessing XAML Beyond the Node Loop Concept","linkify":"Accessing XAML Beyond the Node Loop Concept","nodes":[{"content":"Accessing XAML Beyond the Node Loop Concept","pos":[0,43]}]},{"content":"There are potentially other ways to work with a XAML representation other than as a XAML node loop.","pos":[9942,10041]},{"content":"For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by <ph id=\"ph1\">`x:Name`</ph>, by <ph id=\"ph2\">`x:Uid`</ph>, or through other identifiers.","pos":[10042,10213],"source":" For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers."},{"content":".NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.","pos":[10214,10351]},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Xaml.IXamlIndexingReader&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Xaml.XamlNodeList&gt;</ph>.","pos":[10352,10453],"source":" For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>."},{"pos":[10457,10997],"content":"[!TIP]\nMicrosoft also produces an out-of-band release known as the Microsoft XAML Toolkit. This out-of-band release is still in its pre-release stages. However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML. The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight. For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).","leadings":["","> "],"nodes":[{"content":"Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit. This out-of-band release is still in its pre-release stages. However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML. The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight. For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML).","pos":[7,538],"nodes":[{"content":"Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit.","pos":[0,83]},{"content":"This out-of-band release is still in its pre-release stages.","pos":[84,144]},{"content":"However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML.","pos":[145,318]},{"content":"The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight.","pos":[319,441]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Microsoft XAML Toolkit<ept id=\"p1\">](https://code.msdn.microsoft.com/XAML)</ept>.","pos":[442,531],"source":" For more information, see [Microsoft XAML Toolkit](https://code.msdn.microsoft.com/XAML)."}]}]},{"pos":[11048,11077],"content":"Working with the Current Node","linkify":"Working with the Current Node","nodes":[{"content":"Working with the Current Node","pos":[0,29]}]},{"content":"Most scenarios that use a XAML node loop do not only read the nodes.","pos":[11079,11147]},{"content":"Most scenarios process current nodes and pass each node one at a time to an implementation of <ph id=\"ph1\">&lt;xref:System.Xaml.XamlWriter&gt;</ph>.","pos":[11148,11272],"source":" Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>."},{"content":"In the typical load path scenario, a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <ph id=\"ph2\">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph>.","pos":[11274,11517],"source":"In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>."},{"content":"You then integrate the resulting object graph into your application or framework.","pos":[11518,11599]},{"content":"In a typical save path scenario, a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectReader&gt;</ph> reads the object graph, individual XAML nodes are processed, and a <ph id=\"ph2\">&lt;xref:System.Xaml.XamlXmlWriter&gt;</ph> outputs the serialized result as a XAML text file.","pos":[11601,11822],"source":"In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file."},{"content":"The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.","pos":[11823,12068]},{"pos":[12074,12090],"content":"Frames and Scope","linkify":"Frames and Scope","nodes":[{"content":"Frames and Scope","pos":[0,16]}]},{"content":"A XAML node loop walks through a XAML node stream in a linear way.","pos":[12092,12158]},{"content":"The node stream traverses into objects, into members that contain other objects, and so on.","pos":[12159,12250]},{"content":"It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.","pos":[12251,12363]},{"content":"This is particularly true if you are actively adjusting the node stream while you are in it.","pos":[12364,12456]},{"content":"The frame and stack support that you implement as part of your node loop logic could count <ph id=\"ph1\">`StartObject`</ph> (or <ph id=\"ph2\">`GetObject`</ph>) and <ph id=\"ph3\">`EndObject`</ph> scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.","pos":[12457,12698],"source":" The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective."},{"pos":[12756,12792],"content":"Traversing and Entering Object Nodes","linkify":"Traversing and Entering Object Nodes","nodes":[{"content":"Traversing and Entering Object Nodes","pos":[0,36]}]},{"content":"The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.","pos":[12794,12905]},{"content":"By definition, this object is always a single object node and has no peers.","pos":[12906,12981]},{"content":"In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.","pos":[12982,13135]},{"content":"The member nodes then have one or more object nodes, or might also terminate in a value node instead.","pos":[13136,13237]},{"content":"The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a <ph id=\"ph1\">`Namescope`</ph> node type in the XAML node stream representation.","pos":[13238,13434],"source":" The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation."},{"content":"Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).","pos":[13436,13549]},{"content":"Assume that in this object model, <ph id=\"ph1\">`FavorCollection`</ph> is <ph id=\"ph2\">`List&lt;T&gt;`</ph> of <ph id=\"ph3\">`Favor`</ph>, <ph id=\"ph4\">`Balloon`</ph> and <ph id=\"ph5\">`NoiseMaker`</ph> are assignable to <ph id=\"ph6\">`Favor`</ph>, the <ph id=\"ph7\">`Balloon.Color`</ph> property is backed by a <ph id=\"ph8\">`Color`</ph> object similar to how WPF defines colors as known color names, and <ph id=\"ph9\">`Color`</ph> supports a type converter for attribute syntax.","pos":[13550,13855],"source":" Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax."},{"content":"XAML markup","pos":[13858,13869]},{"content":"Resulting XAML node stream","pos":[13870,13896]},{"pos":[13961,13989],"content":"<ph id=\"ph1\">`Namespace`</ph> node for <ph id=\"ph2\">`Party`</ph>","source":"`Namespace` node for `Party`"},{"pos":[14022,14052],"content":"<ph id=\"ph1\">`StartObject`</ph> node for <ph id=\"ph2\">`Party`</ph>","source":"`StartObject` node for `Party`"},{"pos":[14072,14109],"content":"<ph id=\"ph1\">`StartMember`</ph> node for <ph id=\"ph2\">`Party.Favors`</ph>","source":"`StartMember` node for `Party.Favors`"},{"pos":[14113,14162],"content":"<ph id=\"ph1\">`StartObject`</ph> node for implicit <ph id=\"ph2\">`FavorCollection`</ph>","source":"`StartObject` node for implicit `FavorCollection`"},{"pos":[14166,14231],"content":"<ph id=\"ph1\">`StartMember`</ph> node for implicit <ph id=\"ph2\">`FavorCollection`</ph> items property.","source":"`StartMember` node for implicit `FavorCollection` items property."},{"pos":[14245,14277],"content":"<ph id=\"ph1\">`StartObject`</ph> node for <ph id=\"ph2\">`Balloon`</ph>","source":"`StartObject` node for `Balloon`"},{"content":"<ph id=\"ph1\">`StartMember`</ph> node for <ph id=\"ph2\">`Color`</ph>","pos":[14294,14324],"source":"`StartMember` node for `Color`"},{"content":"<ph id=\"ph1\">`Value`</ph> node for the attribute value string <ph id=\"ph2\">`\"Red\"`</ph>","pos":[14337,14388],"source":"`Value` node for the attribute value string `\"Red\"`"},{"content":"<ph id=\"ph1\">`EndMember`</ph> for <ph id=\"ph2\">`Color`</ph>","pos":[14401,14424],"source":"`EndMember` for `Color`"},{"content":"<ph id=\"ph1\">`StartMember`</ph> node for <ph id=\"ph2\">`HasHelium`</ph>","pos":[14446,14480],"source":"`StartMember` node for `HasHelium`"},{"content":"<ph id=\"ph1\">`Value`</ph> node for the attribute value string <ph id=\"ph2\">`\"True\"`</ph>","pos":[14493,14545],"source":"`Value` node for the attribute value string `\"True\"`"},{"content":"<ph id=\"ph1\">`EndMember`</ph> for <ph id=\"ph2\">`HasHelium`</ph>","pos":[14558,14585],"source":"`EndMember` for `HasHelium`"},{"pos":[14592,14617],"content":"<ph id=\"ph1\">`EndObject`</ph> for <ph id=\"ph2\">`Balloon`</ph>","source":"`EndObject` for `Balloon`"},{"content":"<ph id=\"ph1\">`StartObject`</ph> node for <ph id=\"ph2\">`NoiseMaker`</ph>","pos":[14655,14690],"source":"`StartObject` node for `NoiseMaker`"},{"content":"<ph id=\"ph1\">`StartMember`</ph> node for <ph id=\"ph2\">`_Initialization`</ph>","pos":[14703,14743],"source":"`StartMember` node for `_Initialization`"},{"content":"<ph id=\"ph1\">`Value`</ph> node for the initialization value string <ph id=\"ph2\">`\"Loudest\"`</ph>","pos":[14756,14816],"source":"`Value` node for the initialization value string `\"Loudest\"`"},{"content":"<ph id=\"ph1\">`EndMember`</ph> node for <ph id=\"ph2\">`_Initialization`</ph>","pos":[14829,14867],"source":"`EndMember` node for `_Initialization`"},{"content":"<ph id=\"ph1\">`EndObject`</ph> for <ph id=\"ph2\">`NoiseMaker`</ph>","pos":[14880,14908],"source":"`EndObject` for `NoiseMaker`"},{"pos":[14912,14975],"content":"<ph id=\"ph1\">`EndMember`</ph> node for implicit <ph id=\"ph2\">`FavorCollection`</ph> items property.","source":"`EndMember` node for implicit `FavorCollection` items property."},{"pos":[14979,15026],"content":"<ph id=\"ph1\">`EndObject`</ph> node for implicit <ph id=\"ph2\">`FavorCollection`</ph>","source":"`EndObject` node for implicit `FavorCollection`"},{"pos":[15047,15071],"content":"<ph id=\"ph1\">`EndMember`</ph> for <ph id=\"ph2\">`Favors`</ph>","source":"`EndMember` for `Favors`"},{"pos":[15085,15108],"content":"<ph id=\"ph1\">`EndObject`</ph> for <ph id=\"ph2\">`Party`</ph>","source":"`EndObject` for `Party`"},{"content":"In the XAML node stream, you can rely on the following behavior:","pos":[15111,15175]},{"content":"If a <ph id=\"ph1\">`Namespace`</ph> node exists, it is added to the stream immediately before the <ph id=\"ph2\">`StartObject`</ph> that declared the XAML namespace with <ph id=\"ph3\">`xmlns`</ph>.","pos":[15179,15318],"source":"If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`."},{"content":"Look at the previous table with the XAML and example node stream again.","pos":[15319,15390]},{"content":"Notice how the <ph id=\"ph1\">`StartObject`</ph> and <ph id=\"ph2\">`Namespace`</ph> nodes seem to be transposed versus their declaration positions in text markup.","pos":[15391,15514],"source":" Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup."},{"content":"This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.","pos":[15515,15645]},{"content":"The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.","pos":[15646,15842]},{"content":"Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.","pos":[15843,16001]},{"pos":[16005,16201],"content":"Because of the above consideration, it is one or more <ph id=\"ph1\">`Namespace`</ph> nodes that you read first in most real-world markup cases when traversing nodes from the start, not the <ph id=\"ph2\">`StartObject`</ph> of the root.","source":"Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root."},{"content":"A <ph id=\"ph1\">`StartObject`</ph> node can be followed by <ph id=\"ph2\">`StartMember`</ph>, <ph id=\"ph3\">`Value`</ph>, or an immediate <ph id=\"ph4\">`EndObject`</ph>.","pos":[16205,16297],"source":"A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`."},{"content":"It is never followed immediately by another <ph id=\"ph1\">`StartObject`</ph>.","pos":[16298,16356],"source":" It is never followed immediately by another `StartObject`."},{"content":"A <ph id=\"ph1\">`StartMember`</ph> can be followed by a <ph id=\"ph2\">`StartObject`</ph>, <ph id=\"ph3\">`Value`</ph>, or an immediate <ph id=\"ph4\">`EndMember`</ph>.","pos":[16360,16449],"source":"A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`."},{"content":"It can be followed by <ph id=\"ph1\">`GetObject`</ph>, for members where the value is supposed to come from an existing value of the parent object rather than a <ph id=\"ph2\">`StartObject`</ph> that would instantiate a new value.","pos":[16450,16640],"source":" It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value."},{"content":"It can also be followed by a <ph id=\"ph1\">`Namespace`</ph> node, which applies to an upcoming <ph id=\"ph2\">`StartObject`</ph>.","pos":[16641,16731],"source":" It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`."},{"content":"It is never followed immediately by another <ph id=\"ph1\">`StartMember`</ph>.","pos":[16732,16790],"source":" It is never followed immediately by another `StartMember`."},{"content":"A <ph id=\"ph1\">`Value`</ph> node represents the value itself; there is no \"EndValue\".","pos":[16794,16861],"source":"A `Value` node represents the value itself; there is no \"EndValue\"."},{"content":"It can be followed only by an <ph id=\"ph1\">`EndMember`</ph>.","pos":[16862,16904],"source":" It can be followed only by an `EndMember`."},{"content":"XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.","pos":[16912,17029]},{"content":"Instead, a dedicated member node for a member named <ph id=\"ph1\">`_Initialization`</ph> is created.","pos":[17030,17111],"source":" Instead, a dedicated member node for a member named `_Initialization` is created."},{"content":"and that member node contains the initialization value string.","pos":[17112,17174]},{"content":"If it exists, <ph id=\"ph1\">`_Initialization`</ph> is always the first <ph id=\"ph2\">`StartMember`</ph>.","pos":[17175,17241],"source":" If it exists, `_Initialization` is always the first `StartMember`."},{"content":"<ph id=\"ph1\">`_Initialization`</ph> may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that <ph id=\"ph2\">`_Initialization`</ph> is not a defined property in backing types.","pos":[17242,17431],"source":"`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types."},{"content":"A Member-Value combination represents an attribute setting of the value.","pos":[17439,17511]},{"content":"There might eventually be a value converter involved in processing this value, and the value is a plain string.","pos":[17512,17623]},{"content":"However, that is not evaluated until a XAML object writer processes this node stream.","pos":[17624,17709]},{"content":"The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.","pos":[17710,17846]},{"pos":[17850,17982],"content":"An <ph id=\"ph1\">`EndMember`</ph> node can be followed by a <ph id=\"ph2\">`StartMember`</ph> node for a subsequent member, or by an <ph id=\"ph3\">`EndObject`</ph> node for the member owner.","source":"An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner."},{"content":"An <ph id=\"ph1\">`EndObject`</ph> node can be followed by an <ph id=\"ph2\">`EndMember`</ph> node.","pos":[17986,18045],"source":"An `EndObject` node can be followed by an `EndMember` node."},{"content":"It can also be followed by a <ph id=\"ph1\">`StartObject`</ph> node for cases where the objects are peers in a collection's items.","pos":[18046,18156],"source":" It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items."},{"content":"Or it can be followed by a <ph id=\"ph1\">`Namespace`</ph> node, which applies to an upcoming <ph id=\"ph2\">`StartObject`</ph>.","pos":[18157,18245],"source":" Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`."},{"pos":[18253,18454],"content":"For the unique case of closing the entire node stream, the <ph id=\"ph1\">`EndObject`</ph> of the root is not followed by anything; the reader is now end-of-file, and <ph id=\"ph2\">&lt;xref:System.Xaml.XamlReader.Read%2A&gt;</ph> returns <ph id=\"ph3\">`false`</ph>.","source":"For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`."},{"pos":[18517,18558],"content":"Value Converters and the XAML Node Stream","linkify":"Value Converters and the XAML Node Stream","nodes":[{"content":"Value Converters and the XAML Node Stream","pos":[0,41]}]},{"content":"A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.","pos":[18560,18761]},{"content":"In the XAML node stream, a type converter usage and a markup extension usage have very different representations.","pos":[18762,18875]},{"pos":[18881,18920],"content":"Type Converters in the XAML Node Stream","linkify":"Type Converters in the XAML Node Stream","nodes":[{"content":"Type Converters in the XAML Node Stream","pos":[0,39]}]},{"content":"An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.","pos":[18922,19048]},{"content":"The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.","pos":[19049,19156]},{"content":"Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.","pos":[19157,19280]},{"content":"Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.","pos":[19281,19405]},{"content":"When you use the default XAML schema context, that information is available from the XAML type system.","pos":[19406,19508]},{"content":"If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember&gt;</ph> information of the member being set.","pos":[19509,19717],"source":" If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set."},{"content":"But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.","pos":[19718,19981]},{"content":"For example, consider the following class definition outline and XAML usage for it:","pos":[19983,20066]},{"content":"A text representation of the XAML node stream for this usage could be expressed as the following:","pos":[20380,20477]},{"pos":[20479,20550],"content":"<ph id=\"ph1\">`StartObject`</ph> with <ph id=\"ph2\">&lt;xref:System.Xaml.XamlType&gt;</ph> representing <ph id=\"ph3\">`GameBoard`</ph>","source":"`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`"},{"pos":[20552,20625],"content":"<ph id=\"ph1\">`StartMember`</ph> with <ph id=\"ph2\">&lt;xref:System.Xaml.XamlMember&gt;</ph> representing <ph id=\"ph3\">`BoardSize`</ph>","source":"`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`"},{"pos":[20627,20665],"content":"<ph id=\"ph1\">`Value`</ph> node, with text string \"<ph id=\"ph2\">`8x8`</ph>\"","source":"`Value` node, with text string \"`8x8`\""},{"pos":[20667,20698],"content":"<ph id=\"ph1\">`EndMember`</ph> matches <ph id=\"ph2\">`BoardSize`</ph>","source":"`EndMember` matches `BoardSize`"},{"pos":[20700,20731],"content":"<ph id=\"ph1\">`EndObject`</ph> matches <ph id=\"ph2\">`GameBoard`</ph>","source":"`EndObject` matches `GameBoard`"},{"content":"Notice that there is no type converter instance in this node stream.","pos":[20733,20801]},{"content":"But you can get type converter information by calling <ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType&gt;</ph> on the <ph id=\"ph2\">&lt;xref:System.Xaml.XamlMember&gt;</ph> for <ph id=\"ph3\">`BoardSize`</ph>.","pos":[20802,20985],"source":" But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`."},{"content":"If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <ph id=\"ph1\">&lt;xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A&gt;</ph>.","pos":[20986,21169],"source":" If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>."},{"pos":[21175,21216],"content":"Markup Extensions in the XAML Node Stream","linkify":"Markup Extensions in the XAML Node Stream","nodes":[{"content":"Markup Extensions in the XAML Node Stream","pos":[0,41]}]},{"content":"A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.","pos":[21218,21370]},{"content":"Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.","pos":[21371,21525]},{"content":"<ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember&gt;</ph> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.","pos":[21526,21791],"source":"<xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters."},{"content":"The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).","pos":[21793,21985]},{"content":"Markup extension usages that used an explicit object element form are treated the same way.","pos":[21986,22077]},{"content":"Within a markup extension object node, there may be members of that markup extension.","pos":[22079,22164]},{"content":"The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.","pos":[22165,22334]},{"content":"For a positional parameter usage, the XAML node stream contains a XAML language-defined property <ph id=\"ph1\">`_PositionalParameters`</ph> that records the usage.","pos":[22336,22480],"source":"For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage."},{"content":"This property is a generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> with <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> constraint.","pos":[22481,22588],"source":" This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint."},{"content":"The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.","pos":[22589,22733]},{"content":"To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.","pos":[22734,22869]},{"content":"For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.","pos":[22871,22985]},{"content":"The member values are not necessarily strings, because there could be a nested markup extension usage.","pos":[22986,23088]},{"content":"<ph id=\"ph1\">`ProvideValue`</ph> from the markup extension is not yet invoked.","pos":[23090,23150],"source":"`ProvideValue` from the markup extension is not yet invoked."},{"content":"However, it is invoked if you connect a XAML reader and XAML writer so that <ph id=\"ph1\">`WriteEndObject`</ph> is invoked on the markup extension node when you examine it in the node stream.","pos":[23151,23323],"source":" However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream."},{"content":"For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.","pos":[23324,23467]},{"content":"Otherwise, <ph id=\"ph1\">`ProvideValue`</ph> from any markup extension can throw exceptions here, because it does not have expected services available.","pos":[23468,23600],"source":" Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available."},{"pos":[23682,23743],"content":"XAML and XML Language-Defined Members in the XAML Node Stream","linkify":"XAML and XML Language-Defined Members in the XAML Node Stream","nodes":[{"content":"XAML and XML Language-Defined Members in the XAML Node Stream","pos":[0,61]}]},{"content":"Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember&gt;</ph> lookup or construction.","pos":[23745,23943],"source":"Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction."},{"content":"Often, these members are XAML directives.","pos":[23944,23985]},{"content":"In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.","pos":[23986,24091]},{"content":"In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.","pos":[24092,24356]},{"content":"The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.","pos":[24358,24559]},{"content":"<bpt id=\"p1\">**</bpt>Initialization text for an object node:<ept id=\"p1\">**</ept> The name of this member node is <ph id=\"ph1\">`_Initialization`</ph>, it represents a XAML directive, and it is defined in the XAML language XAML namespace.","pos":[24563,24744],"source":"**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace."},{"content":"You can get a static entity for it from <ph id=\"ph1\">&lt;xref:System.Xaml.XamlLanguage.Initialization%2A&gt;</ph>.","pos":[24745,24835],"source":" You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>."},{"content":"<bpt id=\"p1\">**</bpt>Positional parameters for a markup extension:<ept id=\"p1\">**</ept> The name of this member node is <ph id=\"ph1\">`_PositionalParameters`</ph>, and it is defined in the XAML language XAML namespace.","pos":[24839,25000],"source":"**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace."},{"content":"It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the <ph id=\"ph1\">`,`</ph> delimiter character as supplied in the input XAML.","pos":[25001,25175],"source":" It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML."},{"content":"You can get a static entity for the positional parameters directive from <ph id=\"ph1\">&lt;xref:System.Xaml.XamlLanguage.PositionalParameters%2A&gt;</ph>.","pos":[25176,25305],"source":" You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>."},{"content":"<bpt id=\"p1\">**</bpt>Unknown content:<ept id=\"p1\">**</ept> The name of this member node is <ph id=\"ph1\">`_UnknownContent`</ph>.","pos":[25309,25380],"source":"**Unknown content:** The name of this member node is `_UnknownContent`."},{"content":"Strictly speaking, it is a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlDirective&gt;</ph>, and it is defined in the XAML language XAML namespace.","pos":[25381,25496],"source":" Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace."},{"content":"This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.","pos":[25497,25700]},{"content":"You can detect this case in a XAML node stream by checking for members named <ph id=\"ph1\">`_UnknownContent`</ph>.","pos":[25701,25796],"source":" You can detect this case in a XAML node stream by checking for members named `_UnknownContent`."},{"content":"If no other action is taken in a load path XAML node stream, the default <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph> throws on attempted <ph id=\"ph2\">`WriteEndObject`</ph> when it encounters the <ph id=\"ph3\">`_UnknownContent`</ph> member on any object.","pos":[25797,26005],"source":" If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object."},{"content":"The default <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlWriter&gt;</ph> does not throw, and treats the member as implicit.","pos":[26006,26101],"source":" The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit."},{"content":"You can get a static entity for <ph id=\"ph1\">`_UnknownContent`</ph> from <ph id=\"ph2\">&lt;xref:System.Xaml.XamlLanguage.UnknownContent%2A&gt;</ph>.","pos":[26102,26207],"source":" You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>."},{"content":"<bpt id=\"p1\">**</bpt>Collection property of a collection:<ept id=\"p1\">**</ept> Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.","pos":[26211,26480],"source":"**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution."},{"content":"Instead, the XAML node stream introduces an <ph id=\"ph1\">`Items`</ph> placeholder as a member of the collection XAML type.","pos":[26481,26585],"source":" Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type."},{"content":"In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is <ph id=\"ph1\">`_Items`</ph>.","pos":[26586,26704],"source":" In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`."},{"content":"A constant for this directive can be obtained from <ph id=\"ph1\">&lt;xref:System.Xaml.XamlLanguage.Items%2A&gt;</ph>.","pos":[26705,26797],"source":" A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>."},{"content":"Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.","pos":[26803,26969]},{"content":"For example,","pos":[26970,26982]},{"content":"<bpt id=\"p1\">**</bpt>XML-defined members:<ept id=\"p1\">**</ept> The XML-defined <ph id=\"ph1\">`xml:base`</ph>, <ph id=\"ph2\">`xml:lang`</ph> and <ph id=\"ph3\">`xml:space`</ph> members are reported as XAML directives named <ph id=\"ph4\">`base`</ph>, <ph id=\"ph5\">`lang`</ph>, and <ph id=\"ph6\">`space`</ph> in the .NET Framework XAML Services implementations.","pos":[26986,27192],"source":"**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations."},{"content":"The namespace for these is the XML namespace <ph id=\"ph1\">`http://www.w3.org/XML/1998/namespace`</ph>.","pos":[27193,27277],"source":" The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`."},{"content":"Constants for each of these can be obtained from <ph id=\"ph1\">&lt;xref:System.Xaml.XamlLanguage&gt;</ph>.","pos":[27278,27359],"source":" Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>."},{"pos":[27364,27374],"content":"Node Order","linkify":"Node Order","nodes":[{"content":"Node Order","pos":[0,10]}]},{"content":"In some cases, <ph id=\"ph1\">&lt;xref:System.Xaml.XamlXmlReader&gt;</ph> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.","pos":[27376,27562],"source":"In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML."},{"content":"This is done in order to order the nodes such that a <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph> can process the node stream in a forward-only manner.","pos":[27563,27705],"source":" This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner."},{"content":"In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.","pos":[27707,27903]},{"content":"Certain directives are intended specifically to provide more information for the creation of an object from an object element.","pos":[27905,28031]},{"content":"These directives are: <ph id=\"ph1\">`Initialization`</ph>, <ph id=\"ph2\">`PositionalParameters`</ph>, <ph id=\"ph3\">`TypeArguments`</ph>, <ph id=\"ph4\">`FactoryMethod`</ph>, <ph id=\"ph5\">`Arguments`</ph>.","pos":[28032,28142],"source":" These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`."},{"content":"The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's <ph id=\"ph1\">`StartObject`</ph>, for reasons that are explained in the next section.","pos":[28143,28351],"source":" The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section."},{"pos":[28357,28397],"content":"XamlObjectWriter Behavior and Node Order","linkify":"XamlObjectWriter Behavior and Node Order","nodes":[{"content":"XamlObjectWriter Behavior and Node Order","pos":[0,40]}]},{"content":"<ph id=\"ph1\">`StartObject`</ph> to a <ph id=\"ph2\">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph> is not necessarily a signal to the XAML object writer to immediately construct the object instance.","pos":[28399,28553],"source":"`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance."},{"content":"XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a default constructor to produce the initial object, and only then setting properties.","pos":[28554,28786]},{"content":"These features include: <ph id=\"ph1\">&lt;xref:System.Windows.Markup.XamlDeferLoadAttribute&gt;</ph>; initialization text; <bpt id=\"p1\">[</bpt>x:TypeArguments<ept id=\"p1\">](x-typearguments-directive.md)</ept>; positional parameters of a markup extension; factory methods and associated <bpt id=\"p2\">[</bpt>x:Arguments<ept id=\"p2\">](x-arguments-directive.md)</ept> nodes (XAML 2009).","pos":[28787,29068],"source":" These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009)."},{"content":"Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.","pos":[29069,29363]},{"pos":[29369,29378],"content":"GetObject","linkify":"GetObject","nodes":[{"content":"GetObject","pos":[0,9]}]},{"content":"<ph id=\"ph1\">`GetObject`</ph> represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.","pos":[29380,29546],"source":"`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property."},{"content":"A typical  case where a <ph id=\"ph1\">`GetObject`</ph> node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.","pos":[29547,29766],"source":" A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model."},{"content":"In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.","pos":[29767,29909]},{"pos":[29914,29922],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[29964,29989],"content":"<bpt id=\"p1\">[</bpt>XAML Services<ept id=\"p1\">](index.md)</ept>","source":"[XAML Services](index.md)"},{"pos":[29992,30061],"content":"<bpt id=\"p1\">[</bpt>XAML Namespaces<ept id=\"p1\">](xaml-namespaces-for-net-framework-xaml-services.md)</ept>","source":"[XAML Namespaces](xaml-namespaces-for-net-framework-xaml-services.md)"}]}