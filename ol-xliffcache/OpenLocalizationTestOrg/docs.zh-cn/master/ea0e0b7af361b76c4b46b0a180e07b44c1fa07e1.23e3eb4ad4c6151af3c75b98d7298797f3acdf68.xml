{"content":"---\ntitle: Common Patterns for Delegates\ndescription: Learn about common patterns for using delegates in your code to avoid strong coupling between your components.\nms.date: 06/20/2016\nms.assetid: 0ff8fdfd-6a11-4327-b061-0f2526f35b43\n---\n\n# Common Patterns for Delegates\n\n[Previous](delegates-strongly-typed.md)\n\nDelegates provide a mechanism that enables software designs\ninvolving minimal coupling between components.\n\nOne excellent example for this kind of design is LINQ. The LINQ\nQuery Expression Pattern relies on delegates for all of its\nfeatures. Consider this simple example:\n\n```csharp\nvar smallNumbers = numbers.Where(n => n < 10);\n```\n\nThis filters the sequence of numbers to only those less than the value 10.\nThe `Where` method uses a delegate that determines which elements of a\nsequence pass the filter. When you create a LINQ query, you supply the\nimplementation of the delegate for this specific purpose.\n\nThe prototype for the Where method is:\n\n```csharp\npublic static IEnumerable<TSource> Where<TSource> (this IEnumerable<TSource> source, Func<TSource, bool> predicate);\n```\n\nThis example is repeated with all the methods that are part of LINQ. They\nall rely on delegates for the code that manages the specific query. This API\ndesign pattern is a very powerful one to learn and understand.\n\nThis simple example illustrates how delegates require very little coupling\nbetween components. You don't need to create a class that derives from a\nparticular base class. You don't need to implement a specific interface.\nThe only requirement is to provide the implementation of one method that\nis fundamental to the task at hand.\n\n## Building Your Own Components with Delegates\n\nLet's build on that example by creating a component using a design that\nrelies on delegates.\n\nLet's define a component that could be used for log messages in a large\nsystem. The library components could be used in many different environments,\non multiple different platforms. There are a lot of common features in the\ncomponent that manages the logs. It will need to accept messages from any\ncomponent in the system. Those messages will have different priorities, which\nthe core component can manage. The messages should have timestamps in their\nfinal archived form. For more advanced scenarios, you could filter messages by\nthe source component.\n\nThere is one aspect of the feature that will change often: where messages are\nwritten. In some environments, they may be written to the error console. In\nothers, a file. Other possibilities include database storage, OS event logs,\nor other document storage.\n\nThere are also combinations of output that might be used in different\nscenarios. You may want to write messages to the console and to a file.\n\nA design based on delegates will provide a great deal of flexibility, and\nmake it easy to support storage mechanisms that may be added in the future.\n\nUnder this design, the primary log component can be a non-virtual, even\nsealed class. You can plug in any set of delegates to write the messages\nto different storage media. The built in support for multicast delegates\nmakes it easy to support scenarios where messages must be written to multiple\nlocations (a file, and a console).\n\n## A First Implementation\n\nLet's start small: the initial implementation will accept new messages,\nand write them using any attached delegate. You can start with one delegate\nthat writes messages to the console.\n\n[!code-csharp[LoggerImplementation](../../samples/csharp/delegates-and-events/Logger.cs#FirstImplementation \"A first Logger implementation.\")]\n\nThe static class above is the simplest thing that can work. We need to\nwrite the single implementation for the method that writes messages\nto the console: \n\n[!code-csharp[LogToConsole](../../samples/csharp/delegates-and-events/Program.cs#LogToConsole \"A Console logger.\")]\n\nFinally, you need to hook up the delegate by attaching it to\nthe WriteMessage delegate declared in the logger:\n\n[!code-csharp[ConnectDelegate](../../samples/csharp/delegates-and-events/Program.cs#ConnectDelegate \"Connect to the delegate\")]\n\n## Practices\n\nOur sample so far is fairly simple, but it still demonstrates some\nof the important guidelines for designs involving delegates.\n\nUsing the delegate types defined in the Core Framework makes it easier\nfor users to work with the delegates. You don't need to define new types,\nand developers using your library do not need to learn new, specialized\ndelegate types.\n\nThe interfaces used are as minimal and as flexible as possible: To create\na new output logger, you must create one method. That method may be a static\nmethod, or an instance method. It may have any access.\n\n## Formatting Output\n\nLet's make this first version a bit more robust, and then start\ncreating other logging mechanisms.\n\nNext, let's add a few arguments to the `LogMessage()` method so that\nyour log class creates more structured messages:\n\n[!code-csharp[Severity](../../samples/csharp/delegates-and-events/Logger.cs#Severity \"Define severities\")]\n[!code-csharp[NextLogger](../../samples/csharp/delegates-and-events/Logger.cs#LoggerTwo \"Refine the Logger\")]\n\nNext, let's make use of that `Severity` argument to filter the messages\nthat are sent to the log's output. \n\n[!code-csharp[FinalLogger](../../samples/csharp/delegates-and-events/Logger.cs#LoggerFinal \"Finish the Logger\")]\n\n## Practices\n\nYou've added new features to the logging infrastructure. Because\nthe logger component is very loosely coupled to any output mechanism,\nthese new features can be added with no impact on any of the code\nimplementing the logger delegate.\n\nAs you keep building this, you'll see more examples of how this loose\ncoupling enables greater flexibility in updating parts of the site without\nany changes to other locations. In fact, in a larger application, the logger\noutput classes might be in a different assembly, and not even need to be\nrebuilt.\n\n## Building a Second Output Engine\n\nThe Log component is coming along well. Let's add one more output\nengine that logs messages to a file. This will be a slightly more\ninvolved output engine. It will be a class that encapsulates the\nfile operations, and ensures that the file is always closed after\neach write. That ensures that all the data is flushed to disk after\neach message is generated.\n\nHere is that file based logger:\n\n[!code-csharp[FileLogger](../../samples/csharp/delegates-and-events/FileLogger.cs#FileLogger \"Log to files\")]\n\nOnce you've created this class, you can instantiate it and it attaches\nits LogMessage method to the Logger component:\n\n[!code-csharp[FileLogger](../../samples/csharp/delegates-and-events/Program.cs#FileLogger \"Log to files\")]\n\nThese two are not mutually exclusive. You could attach both log\nmethods and generate messages to the console and a file:\n\n```csharp\nvar fileOutput = new FileLogger(\"log.txt\");\nLogger.WriteMessage += LogToConsole;\n```\n\nLater, even in the same application, you can remove one of the\ndelegates without any other issues to the system:\n\n```csharp\nLogger.WriteMessage -= LogToConsole;\n```\n\n## Practices\n\nNow, you've added a second output handler for the logging sub-system.\nThis one needs a bit more infrastructure to correctly support the file\nsystem. The delegate is an instance method. It's also a private method.\nThere's no need for greater accessibility because the delegate\ninfrastructure can connect the delegates.\n\nSecond, the delegate-based design enables multiple output methods\nwithout any extra code. You don't need to build any additional infrastructure\nto support multiple output methods. They simply become another method\non the invocation list.\n\nPay special attention to the code in the file logging output method. It\nis coded to ensure that it does not throw any exceptions. While this isn't\nalways strictly necessary, it's often a good practice. If either of the\ndelegate methods throws an exception, the remaining delegates that are\non the invocation won't be invoked.\n\nAs a last note, the file logger must manage its resources by opening and\nclosing the file on each log message. You could choose to keep the file\nopen and implement IDisposable to close the file when you are completed.\nEither method has its advantages and disadvantages. Both do create a bit\nmore coupling between the classes.\n\nNone of the code in the Logger class would need to be updated\nin order to support either scenario.\n\n## Handling Null Delegates\n\nFinally, let's update the LogMessage method so that it is robust\nfor those cases when no output mechanism is selected. The current\nimplementation will throw a `NullReferenceException` when the\n`WriteMessage` delegate does not have an invocation list attached.\nYou may prefer a design that silently continues when no methods\nhave been attached. This is easy using the null conditional operator,\ncombined with the `Delegate.Invoke()` method:\n\n```csharp\npublic static void LogMessage(string msg)\n{\n    WriteMessage?.Invoke(msg);\n}\n```\n\nThe null conditional operator (`?.`) short-circuits when the left operand\n(`WriteMessage` in this case) is null, which means no attempt is made\nto log a message.\n\nYou won't find the `Invoke()` method listed in the documentation for\n`System.Delegate` or `System.MulticastDelegate`. The compiler generates\na type safe `Invoke` method for any delegate type declared. In this example,\nthat means `Invoke` takes a single `string` argument, and has a void\nreturn type.\n\n## Summary of Practices\n\nYou've seen the beginnings of a log component that could be expanded\nwith other writers, and other features. By using delegates in the design\nthese different components are very loosely coupled. This provides\nseveral advantages. It's very easy to create new output mechanisms\nand attach them to the system. These other mechanisms only need one\nmethod: the method that writes the log message. It's a design that\nis very resilient when new features are added. The contract required\nfor any writer is to implement one method. That method could be a\nstatic or instance method. It could be public, private, or any other\nlegal access.\n\nThe Logger class can make any number of enhancements or changes without\nintroducing breaking changes. Like any class, you cannot modify the\npublic API without the risk of breaking changes. But, because the\ncoupling between the logger and any output engines is only through\nthe delegate, no other types (like interfaces or base classes) are\ninvolved. The coupling is as small as possible.\n\n[Next](events-overview.md)\n","nodes":[{"pos":[4,233],"embed":true,"restype":"x-metadata","content":"title: Common Patterns for Delegates\ndescription: Learn about common patterns for using delegates in your code to avoid strong coupling between your components.\nms.date: 06/20/2016\nms.assetid: 0ff8fdfd-6a11-4327-b061-0f2526f35b43","nodes":[{"content":"Common Patterns for Delegates","nodes":[{"pos":[0,29],"content":"Common Patterns for Delegates","nodes":[{"content":"Common Patterns for Delegates","pos":[0,29]}]}],"path":["title"],"nosxs":false},{"content":"Learn about common patterns for using delegates in your code to avoid strong coupling between your components.","nodes":[{"pos":[0,110],"content":"Learn about common patterns for using delegates in your code to avoid strong coupling between your components.","nodes":[{"content":"Learn about common patterns for using delegates in your code to avoid strong coupling between your components.","pos":[0,110]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[241,270],"content":"Common Patterns for Delegates","linkify":"Common Patterns for Delegates","nodes":[{"content":"Common Patterns for Delegates","pos":[0,29]}]},{"pos":[272,311],"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](delegates-strongly-typed.md)</ept>","source":"[Previous](delegates-strongly-typed.md)"},{"pos":[313,419],"content":"Delegates provide a mechanism that enables software designs involving minimal coupling between components.","source":"Delegates provide a mechanism that enables software designs\ninvolving minimal coupling between components."},{"content":"One excellent example for this kind of design is LINQ.","pos":[421,475]},{"content":"The LINQ Query Expression Pattern relies on delegates for all of its features.","pos":[476,554],"source":" The LINQ\nQuery Expression Pattern relies on delegates for all of its\nfeatures."},{"content":"Consider this simple example:","pos":[555,584]},{"content":"This filters the sequence of numbers to only those less than the value 10.","pos":[648,722]},{"content":"The <ph id=\"ph1\">`Where`</ph> method uses a delegate that determines which elements of a sequence pass the filter.","pos":[723,819],"source":"\nThe `Where` method uses a delegate that determines which elements of a\nsequence pass the filter."},{"content":"When you create a LINQ query, you supply the implementation of the delegate for this specific purpose.","pos":[820,922],"source":" When you create a LINQ query, you supply the\nimplementation of the delegate for this specific purpose."},{"content":"The prototype for the Where method is:","pos":[924,962]},{"content":"This example is repeated with all the methods that are part of LINQ.","pos":[1096,1164]},{"content":"They all rely on delegates for the code that manages the specific query.","pos":[1165,1237],"source":" They\nall rely on delegates for the code that manages the specific query."},{"content":"This API design pattern is a very powerful one to learn and understand.","pos":[1238,1309],"source":" This API\ndesign pattern is a very powerful one to learn and understand."},{"content":"This simple example illustrates how delegates require very little coupling between components.","pos":[1311,1405],"source":"This simple example illustrates how delegates require very little coupling\nbetween components."},{"content":"You don't need to create a class that derives from a particular base class.","pos":[1406,1481],"source":" You don't need to create a class that derives from a\nparticular base class."},{"content":"You don't need to implement a specific interface.","pos":[1482,1531]},{"content":"The only requirement is to provide the implementation of one method that is fundamental to the task at hand.","pos":[1532,1640],"source":"\nThe only requirement is to provide the implementation of one method that\nis fundamental to the task at hand."},{"pos":[1645,1688],"content":"Building Your Own Components with Delegates","linkify":"Building Your Own Components with Delegates","nodes":[{"content":"Building Your Own Components with Delegates","pos":[0,43]}]},{"pos":[1690,1782],"content":"Let's build on that example by creating a component using a design that relies on delegates.","source":"Let's build on that example by creating a component using a design that\nrelies on delegates."},{"content":"Let's define a component that could be used for log messages in a large system.","pos":[1784,1863],"source":"Let's define a component that could be used for log messages in a large\nsystem."},{"content":"The library components could be used in many different environments, on multiple different platforms.","pos":[1864,1965],"source":" The library components could be used in many different environments,\non multiple different platforms."},{"content":"There are a lot of common features in the component that manages the logs.","pos":[1966,2040],"source":" There are a lot of common features in the\ncomponent that manages the logs."},{"content":"It will need to accept messages from any component in the system.","pos":[2041,2106],"source":" It will need to accept messages from any\ncomponent in the system."},{"content":"Those messages will have different priorities, which the core component can manage.","pos":[2107,2190],"source":" Those messages will have different priorities, which\nthe core component can manage."},{"content":"The messages should have timestamps in their final archived form.","pos":[2191,2256],"source":" The messages should have timestamps in their\nfinal archived form."},{"content":"For more advanced scenarios, you could filter messages by the source component.","pos":[2257,2336],"source":" For more advanced scenarios, you could filter messages by\nthe source component."},{"content":"There is one aspect of the feature that will change often: where messages are written.","pos":[2338,2424],"source":"There is one aspect of the feature that will change often: where messages are\nwritten."},{"content":"In some environments, they may be written to the error console.","pos":[2425,2488]},{"content":"In others, a file.","pos":[2489,2507],"source":" In\nothers, a file."},{"content":"Other possibilities include database storage, OS event logs, or other document storage.","pos":[2508,2595],"source":" Other possibilities include database storage, OS event logs,\nor other document storage."},{"content":"There are also combinations of output that might be used in different scenarios.","pos":[2597,2677],"source":"There are also combinations of output that might be used in different\nscenarios."},{"content":"You may want to write messages to the console and to a file.","pos":[2678,2738]},{"pos":[2740,2889],"content":"A design based on delegates will provide a great deal of flexibility, and make it easy to support storage mechanisms that may be added in the future.","source":"A design based on delegates will provide a great deal of flexibility, and\nmake it easy to support storage mechanisms that may be added in the future."},{"content":"Under this design, the primary log component can be a non-virtual, even sealed class.","pos":[2891,2976],"source":"Under this design, the primary log component can be a non-virtual, even\nsealed class."},{"content":"You can plug in any set of delegates to write the messages to different storage media.","pos":[2977,3063],"source":" You can plug in any set of delegates to write the messages\nto different storage media."},{"content":"The built in support for multicast delegates makes it easy to support scenarios where messages must be written to multiple locations (a file, and a console).","pos":[3064,3221],"source":" The built in support for multicast delegates\nmakes it easy to support scenarios where messages must be written to multiple\nlocations (a file, and a console)."},{"pos":[3226,3248],"content":"A First Implementation","linkify":"A First Implementation","nodes":[{"content":"A First Implementation","pos":[0,22]}]},{"content":"Let's start small: the initial implementation will accept new messages, and write them using any attached delegate.","pos":[3250,3365],"source":"Let's start small: the initial implementation will accept new messages,\nand write them using any attached delegate."},{"content":"You can start with one delegate that writes messages to the console.","pos":[3366,3434],"source":" You can start with one delegate\nthat writes messages to the console."},{"content":"The static class above is the simplest thing that can work.","pos":[3580,3639]},{"content":"We need to write the single implementation for the method that writes messages to the console:","pos":[3640,3734],"source":" We need to\nwrite the single implementation for the method that writes messages\nto the console:"},{"pos":[3854,3964],"content":"Finally, you need to hook up the delegate by attaching it to the WriteMessage delegate declared in the logger:","source":"Finally, you need to hook up the delegate by attaching it to\nthe WriteMessage delegate declared in the logger:"},{"pos":[4098,4107],"content":"Practices","linkify":"Practices","nodes":[{"content":"Practices","pos":[0,9]}]},{"pos":[4109,4236],"content":"Our sample so far is fairly simple, but it still demonstrates some of the important guidelines for designs involving delegates.","source":"Our sample so far is fairly simple, but it still demonstrates some\nof the important guidelines for designs involving delegates."},{"content":"Using the delegate types defined in the Core Framework makes it easier for users to work with the delegates.","pos":[4238,4346],"source":"Using the delegate types defined in the Core Framework makes it easier\nfor users to work with the delegates."},{"content":"You don't need to define new types, and developers using your library do not need to learn new, specialized delegate types.","pos":[4347,4470],"source":" You don't need to define new types,\nand developers using your library do not need to learn new, specialized\ndelegate types."},{"content":"The interfaces used are as minimal and as flexible as possible: To create a new output logger, you must create one method.","pos":[4472,4594],"source":"The interfaces used are as minimal and as flexible as possible: To create\na new output logger, you must create one method."},{"content":"That method may be a static method, or an instance method.","pos":[4595,4653],"source":" That method may be a static\nmethod, or an instance method."},{"content":"It may have any access.","pos":[4654,4677]},{"pos":[4682,4699],"content":"Formatting Output","linkify":"Formatting Output","nodes":[{"content":"Formatting Output","pos":[0,17]}]},{"pos":[4701,4799],"content":"Let's make this first version a bit more robust, and then start creating other logging mechanisms.","source":"Let's make this first version a bit more robust, and then start\ncreating other logging mechanisms."},{"pos":[4801,4918],"content":"Next, let's add a few arguments to the <ph id=\"ph1\">`LogMessage()`</ph> method so that your log class creates more structured messages:","source":"Next, let's add a few arguments to the `LogMessage()` method so that\nyour log class creates more structured messages:"},{"pos":[5138,5244],"content":"Next, let's make use of that <ph id=\"ph1\">`Severity`</ph> argument to filter the messages that are sent to the log's output.","source":"Next, let's make use of that `Severity` argument to filter the messages\nthat are sent to the log's output."},{"pos":[5364,5373],"content":"Practices","linkify":"Practices","nodes":[{"content":"Practices","pos":[0,9]}]},{"content":"You've added new features to the logging infrastructure.","pos":[5375,5431]},{"content":"Because the logger component is very loosely coupled to any output mechanism, these new features can be added with no impact on any of the code implementing the logger delegate.","pos":[5432,5609],"source":" Because\nthe logger component is very loosely coupled to any output mechanism,\nthese new features can be added with no impact on any of the code\nimplementing the logger delegate."},{"content":"As you keep building this, you'll see more examples of how this loose coupling enables greater flexibility in updating parts of the site without any changes to other locations.","pos":[5611,5787],"source":"As you keep building this, you'll see more examples of how this loose\ncoupling enables greater flexibility in updating parts of the site without\nany changes to other locations."},{"content":"In fact, in a larger application, the logger output classes might be in a different assembly, and not even need to be rebuilt.","pos":[5788,5914],"source":" In fact, in a larger application, the logger\noutput classes might be in a different assembly, and not even need to be\nrebuilt."},{"pos":[5919,5950],"content":"Building a Second Output Engine","linkify":"Building a Second Output Engine","nodes":[{"content":"Building a Second Output Engine","pos":[0,31]}]},{"content":"The Log component is coming along well.","pos":[5952,5991]},{"content":"Let's add one more output engine that logs messages to a file.","pos":[5992,6054],"source":" Let's add one more output\nengine that logs messages to a file."},{"content":"This will be a slightly more involved output engine.","pos":[6055,6107],"source":" This will be a slightly more\ninvolved output engine."},{"content":"It will be a class that encapsulates the file operations, and ensures that the file is always closed after each write.","pos":[6108,6226],"source":" It will be a class that encapsulates the\nfile operations, and ensures that the file is always closed after\neach write."},{"content":"That ensures that all the data is flushed to disk after each message is generated.","pos":[6227,6309],"source":" That ensures that all the data is flushed to disk after\neach message is generated."},{"content":"Here is that file based logger:","pos":[6311,6342]},{"pos":[6455,6572],"content":"Once you've created this class, you can instantiate it and it attaches its LogMessage method to the Logger component:","source":"Once you've created this class, you can instantiate it and it attaches\nits LogMessage method to the Logger component:"},{"content":"These two are not mutually exclusive.","pos":[6682,6719]},{"content":"You could attach both log methods and generate messages to the console and a file:","pos":[6720,6802],"source":" You could attach both log\nmethods and generate messages to the console and a file:"},{"pos":[6900,7012],"content":"Later, even in the same application, you can remove one of the delegates without any other issues to the system:","source":"Later, even in the same application, you can remove one of the\ndelegates without any other issues to the system:"},{"pos":[7069,7078],"content":"Practices","linkify":"Practices","nodes":[{"content":"Practices","pos":[0,9]}]},{"content":"Now, you've added a second output handler for the logging sub-system.","pos":[7080,7149]},{"content":"This one needs a bit more infrastructure to correctly support the file system.","pos":[7150,7228],"source":"\nThis one needs a bit more infrastructure to correctly support the file\nsystem."},{"content":"The delegate is an instance method.","pos":[7229,7264]},{"content":"It's also a private method.","pos":[7265,7292]},{"content":"There's no need for greater accessibility because the delegate infrastructure can connect the delegates.","pos":[7293,7397],"source":"\nThere's no need for greater accessibility because the delegate\ninfrastructure can connect the delegates."},{"content":"Second, the delegate-based design enables multiple output methods without any extra code.","pos":[7399,7488],"source":"Second, the delegate-based design enables multiple output methods\nwithout any extra code."},{"content":"You don't need to build any additional infrastructure to support multiple output methods.","pos":[7489,7578],"source":" You don't need to build any additional infrastructure\nto support multiple output methods."},{"content":"They simply become another method on the invocation list.","pos":[7579,7636],"source":" They simply become another method\non the invocation list."},{"content":"Pay special attention to the code in the file logging output method.","pos":[7638,7706]},{"content":"It is coded to ensure that it does not throw any exceptions.","pos":[7707,7767],"source":" It\nis coded to ensure that it does not throw any exceptions."},{"content":"While this isn't always strictly necessary, it's often a good practice.","pos":[7768,7839],"source":" While this isn't\nalways strictly necessary, it's often a good practice."},{"content":"If either of the delegate methods throws an exception, the remaining delegates that are on the invocation won't be invoked.","pos":[7840,7963],"source":" If either of the\ndelegate methods throws an exception, the remaining delegates that are\non the invocation won't be invoked."},{"content":"As a last note, the file logger must manage its resources by opening and closing the file on each log message.","pos":[7965,8075],"source":"As a last note, the file logger must manage its resources by opening and\nclosing the file on each log message."},{"content":"You could choose to keep the file open and implement IDisposable to close the file when you are completed.","pos":[8076,8182],"source":" You could choose to keep the file\nopen and implement IDisposable to close the file when you are completed."},{"content":"Either method has its advantages and disadvantages.","pos":[8183,8234],"source":"\nEither method has its advantages and disadvantages."},{"content":"Both do create a bit more coupling between the classes.","pos":[8235,8290],"source":" Both do create a bit\nmore coupling between the classes."},{"pos":[8292,8390],"content":"None of the code in the Logger class would need to be updated in order to support either scenario.","source":"None of the code in the Logger class would need to be updated\nin order to support either scenario."},{"pos":[8395,8418],"content":"Handling Null Delegates","linkify":"Handling Null Delegates","nodes":[{"content":"Handling Null Delegates","pos":[0,23]}]},{"content":"Finally, let's update the LogMessage method so that it is robust for those cases when no output mechanism is selected.","pos":[8420,8538],"source":"Finally, let's update the LogMessage method so that it is robust\nfor those cases when no output mechanism is selected."},{"content":"The current implementation will throw a <ph id=\"ph1\">`NullReferenceException`</ph> when the <ph id=\"ph2\">`WriteMessage`</ph> delegate does not have an invocation list attached.","pos":[8539,8679],"source":" The current\nimplementation will throw a `NullReferenceException` when the\n`WriteMessage` delegate does not have an invocation list attached."},{"content":"You may prefer a design that silently continues when no methods have been attached.","pos":[8680,8763],"source":"\nYou may prefer a design that silently continues when no methods\nhave been attached."},{"content":"This is easy using the null conditional operator, combined with the <ph id=\"ph1\">`Delegate.Invoke()`</ph> method:","pos":[8764,8859],"source":" This is easy using the null conditional operator,\ncombined with the `Delegate.Invoke()` method:"},{"pos":[8953,9114],"content":"The null conditional operator (<ph id=\"ph1\">`?.`</ph>) short-circuits when the left operand (<ph id=\"ph2\">`WriteMessage`</ph> in this case) is null, which means no attempt is made to log a message.","source":"The null conditional operator (`?.`) short-circuits when the left operand\n(`WriteMessage` in this case) is null, which means no attempt is made\nto log a message."},{"content":"You won't find the <ph id=\"ph1\">`Invoke()`</ph> method listed in the documentation for <ph id=\"ph2\">`System.Delegate`</ph> or <ph id=\"ph3\">`System.MulticastDelegate`</ph>.","pos":[9116,9233],"source":"You won't find the `Invoke()` method listed in the documentation for\n`System.Delegate` or `System.MulticastDelegate`."},{"content":"The compiler generates a type safe <ph id=\"ph1\">`Invoke`</ph> method for any delegate type declared.","pos":[9234,9316],"source":" The compiler generates\na type safe `Invoke` method for any delegate type declared."},{"content":"In this example, that means <ph id=\"ph1\">`Invoke`</ph> takes a single <ph id=\"ph2\">`string`</ph> argument, and has a void return type.","pos":[9317,9415],"source":" In this example,\nthat means `Invoke` takes a single `string` argument, and has a void\nreturn type."},{"pos":[9420,9440],"content":"Summary of Practices","linkify":"Summary of Practices","nodes":[{"content":"Summary of Practices","pos":[0,20]}]},{"content":"You've seen the beginnings of a log component that could be expanded with other writers, and other features.","pos":[9442,9550],"source":"You've seen the beginnings of a log component that could be expanded\nwith other writers, and other features."},{"content":"By using delegates in the design these different components are very loosely coupled.","pos":[9551,9636],"source":" By using delegates in the design\nthese different components are very loosely coupled."},{"content":"This provides several advantages.","pos":[9637,9670],"source":" This provides\nseveral advantages."},{"content":"It's very easy to create new output mechanisms and attach them to the system.","pos":[9671,9748],"source":" It's very easy to create new output mechanisms\nand attach them to the system."},{"content":"These other mechanisms only need one method: the method that writes the log message.","pos":[9749,9833],"source":" These other mechanisms only need one\nmethod: the method that writes the log message."},{"content":"It's a design that is very resilient when new features are added.","pos":[9834,9899],"source":" It's a design that\nis very resilient when new features are added."},{"content":"The contract required for any writer is to implement one method.","pos":[9900,9964],"source":" The contract required\nfor any writer is to implement one method."},{"content":"That method could be a static or instance method.","pos":[9965,10014],"source":" That method could be a\nstatic or instance method."},{"content":"It could be public, private, or any other legal access.","pos":[10015,10070],"source":" It could be public, private, or any other\nlegal access."},{"content":"The Logger class can make any number of enhancements or changes without introducing breaking changes.","pos":[10072,10173],"source":"The Logger class can make any number of enhancements or changes without\nintroducing breaking changes."},{"content":"Like any class, you cannot modify the public API without the risk of breaking changes.","pos":[10174,10260],"source":" Like any class, you cannot modify the\npublic API without the risk of breaking changes."},{"content":"But, because the coupling between the logger and any output engines is only through the delegate, no other types (like interfaces or base classes) are involved.","pos":[10261,10421],"source":" But, because the\ncoupling between the logger and any output engines is only through\nthe delegate, no other types (like interfaces or base classes) are\ninvolved."},{"content":"The coupling is as small as possible.","pos":[10422,10459]},{"pos":[10461,10487],"content":"<bpt id=\"p1\">[</bpt>Next<ept id=\"p1\">](events-overview.md)</ept>","source":"[Next](events-overview.md)"}]}