{"content":"---\ntitle: \"WPF Architecture\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"properties [WPF], attached\"\n  - \"attached properties [WPF]\"\n  - \"architecture [WPF]\"\n  - \"unmanaged components [WPF]\"\n  - \"affinity thread [WPF]\"\n  - \"Storyboards [WPF]\"\n  - \"milcore [WPF]\"\n  - \"components [WPF], unmanaged\"\n  - \"painter's algorithm\"\n  - \"interfaces [WPF], INotifyPropertyChange\"\n  - \"CommandBindings [WPF]\"\n  - \"data templates [WPF]\"\n  - \"thread [WPF], affinity\"\nms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8\n---\n# WPF Architecture\nThis topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy. It covers most of the major subsystems of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], and describes how they interact. It also details some of the choices made by the architects of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  \n\n<a name=\"System_Object\"></a>   \n## System.Object  \n The primary [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] programming model is exposed through managed code. Early in the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones. The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.  \n  \n The major components of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] are illustrated in the figure below. The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]. Of these, only one is an unmanaged component – milcore. Milcore is written in unmanaged code in order to enable tight integration with [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)]. All display in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is done through the [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] engine, allowing for efficient hardware and software rendering. [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] also required fine control over memory and execution. The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] to gain performance.  \n  \n ![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG \"wpf_architect1\")  \n  \n Communication between the managed and unmanaged portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is discussed later in this topic. The remainder of the managed programming model is described below.  \n  \n<a name=\"System_Threading_DispatcherObject\"></a>   \n## System.Threading.DispatcherObject  \n Most objects in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading. [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is based on a messaging system implemented by the dispatcher. This works much like the familiar [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] message pump; in fact, the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] dispatcher uses User32 messages for performing cross thread calls.  \n  \n There are really two core concepts to understand when discussing concurrency in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – the dispatcher and thread affinity.  \n  \n During the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the goal was to move to a single thread of execution, but a non-thread \"affinitized\" model. Thread affinity happens when a component uses the identity of the executing thread to store some type of state. The most common form of this is to use the thread local store (TLS) to store state. Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive. In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity. The primary reason for this was interoperability – systems like [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], the clipboard, and Internet Explorer all require single thread affinity (STA) execution.  \n  \n Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread. Herein lies the role of the dispatcher. The dispatcher is a basic message dispatching system, with multiple prioritized queues. Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method). By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] object that has STA behavior, and will be given a pointer to a dispatcher at creation time.  \n  \n<a name=\"System_Windows_DependencyObject\"></a>   \n## System.Windows.DependencyObject  \n One of the primary architectural philosophies used in building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] was a preference for properties over methods or events. Properties are declarative and allow you to more easily specify intent instead of action. This also supported a model driven, or data driven, system for displaying user interface content. This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.  \n  \n In order to have more of the system driven by properties, a richer property system than what the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides was needed. A simple example of this richness is change notifications. In order to enable two way binding, you need both sides of the bind to support change notification. In order to have behavior tied to property values, you need to be notified when the property value changes. The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.  \n  \n [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type. The property system is truly a \"dependency\" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change. For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.  \n  \n The foundation of the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] property system is the concept of a property expression. In this first release of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the property expression system is closed, and the expressions are all provided as part of the framework. Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.  \n  \n The property system also provides for sparse storage of property values. Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.  \n  \n The final new feature of the property system is the notion of attached properties. [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] elements are built on the principle of composition and component reuse. It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information). Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object. This is similar to the \"expando\" features of JavaScript.  \n  \n<a name=\"System_Windows_Media_Visual\"></a>   \n## System.Windows.Media.Visual  \n With a system defined, the next step is getting pixels drawn to the screen. The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.). <xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure and rely heavily on protected callback functions.  \n  \n <xref:System.Windows.Media.Visual> is really the entry point to the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] composition system. <xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] and the unmanaged milcore.  \n  \n [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] displays data by traversing the unmanaged data structures managed by the milcore. These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node. This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.  \n  \n When programming [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol. Each <xref:System.Windows.Media.Visual> in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] may create one, none, or several composition nodes.  \n  \n ![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG \"wpf_architecture2\")  \n  \n There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached. In graphics terms, [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a retained rendering system. This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code. This helps prevent the appearance of an unresponsive application.  \n  \n Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.  \n  \n In User32 and [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)], the system works on an immediate mode clipping system. When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box. This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.  \n  \n [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a \"painter's algorithm\" painting model. This means that instead of clipping each component, each component is asked to render from the back to the front of the display. This allows each component to paint over the previous component's display. The advantage of this model is that you can have complex, partially transparent shapes. With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] were created).  \n  \n As mentioned previously, a core philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is to move to a more declarative, \"property centric\" model of programming. In the visual system, this shows up in a couple of interesting places.  \n  \n First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line(). This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties. The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.  \n  \n Second, if you evaluate the animation system, you'll see that it is almost completely declarative. Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object. These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.  \n  \n<a name=\"System_Windows_UIElement\"></a>   \n## System.Windows.UIElement  \n <xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.  \n  \n Layout is a core concept in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]. In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning). [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic. At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.  \n  \n <xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take. This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size. The fact that parent elements ask child elements to measure demonstrates another key philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – size to content. All controls in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] support the ability to size to the natural size of their content. This makes localization much easier, and allows for dynamic layout of elements as things resize. The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.  \n  \n A lot of time is often spent talking about the output side of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> and related objects. However there is a tremendous amount of innovation on the input side as well. Probably the most fundamental change in the input model for [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the consistent model by which input events are routed through the system.  \n  \n Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32. Once the User32 message corresponding to the input is routed to [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], it is converted into a [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] raw input message and sent to the dispatcher. [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] allows for raw input events to be converted to multiple actual events, enabling features like \"MouseEnter\" to be implemented at a low level of the system with guaranteed delivery.  \n  \n Each input event is converted to at least two events – a \"preview\" event and the actual event. All events in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] have a notion of routing through the element tree. Events are said to \"bubble\" if they traverse from a target up the tree to the root, and are said to \"tunnel\" if they start at the root and traverse down to a target. Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event. The regular (non-preview) events then bubble from the target up to the root.  \n  \n This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world. In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to \"New\"). In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator. In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] this wouldn’t work because the system is fully \"composable\" – any element can handle and use any keyboard accelerator. Having this two phase model for input allows components to implement their own \"TranslateAccelerator\".  \n  \n To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings. The [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>. Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New). Both the input gestures and command definitions are extensible, and can be wired together at usage time. This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.  \n  \n To this point in the topic, \"core\" features of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – features implemented in the PresentationCore assembly, have been the focus. When building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome. The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.  \n  \n<a name=\"System_Windows_FrameworkElement\"></a>   \n## System.Windows.FrameworkElement  \n <xref:System.Windows.FrameworkElement> can be looked at in two different ways. It introduces a set of policies and customizations on the subsystems introduced in lower layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]. It also introduces a set of new subsystems.  \n  \n The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout. <xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout \"slot\" that makes it easier for layout authors to have a consistent set of property driven layout semantics. Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.  \n  \n <xref:System.Windows.FrameworkElement> also provides easier [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure to many features found in the core layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]. For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method. A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.  \n  \n The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.  \n  \n The data binding subsystem in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]. In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data. [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] has full support for property binding, transformation, and list binding.  \n  \n One of the most interesting features of data binding in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the introduction of data templates. Data templates allow you to declaratively specify how a piece of data should be visualized. Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.  \n  \n Styling is really a lightweight form of data binding. Using styling you can bind a set of properties from a shared definition to one or more instances of an element. Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] type of the element.  \n  \n<a name=\"System_Windows_Controls_Control\"></a>   \n## System.Windows.Controls.Control  \n Control’s most significant feature is templating. If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner. A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.  \n  \n <xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control. The implementation of a control provides a data model and interaction model. The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window). The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).  \n  \n This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.  \n  \n A common aspect of the data model of controls is the content model. If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named \"Content\" of type <xref:System.Object>. In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)], this property would typically be a string – however that limits the type of content you can put in a button. Content for a button can either be a simple string, a complex data object, or an entire element tree. In the case of a data object, the data template is used to construct a display.  \n  \n<a name=\"Summary\"></a>   \n## Summary  \n [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is designed to allow you to create dynamic, data driven presentation systems. Every part of the system is designed to create objects through property sets that drive behavior. Data binding is a fundamental part of the system, and is integrated at every layer.  \n  \n Traditional applications create a display and then bind to some data. In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], everything about the control, every aspect of the display, is generated by some type of data binding. The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.  \n  \n When you begin developing [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] based applications, it should feel very familiar. You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]. With a deeper investigation into the architecture of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.  \n  \n## See also\n\n- <xref:System.Windows.Media.Visual>\n- <xref:System.Windows.UIElement>\n- <xref:System.Windows.Input.ICommand>\n- <xref:System.Windows.FrameworkElement>\n- <xref:System.Windows.Threading.DispatcherObject>\n- <xref:System.Windows.Input.CommandBinding>\n- <xref:System.Windows.Controls.Control>\n- [Data Binding Overview](../data/data-binding-overview.md)\n- [Layout](layout.md)\n- [Animation Overview](../graphics-multimedia/animation-overview.md)\n","nodes":[{"pos":[4,507],"embed":true,"restype":"x-metadata","content":"title: \"WPF Architecture\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"properties [WPF], attached\"\n  - \"attached properties [WPF]\"\n  - \"architecture [WPF]\"\n  - \"unmanaged components [WPF]\"\n  - \"affinity thread [WPF]\"\n  - \"Storyboards [WPF]\"\n  - \"milcore [WPF]\"\n  - \"components [WPF], unmanaged\"\n  - \"painter's algorithm\"\n  - \"interfaces [WPF], INotifyPropertyChange\"\n  - \"CommandBindings [WPF]\"\n  - \"data templates [WPF]\"\n  - \"thread [WPF], affinity\"\nms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8","nodes":[{"content":"WPF Architecture","nodes":[{"pos":[0,16],"content":"WPF Architecture","nodes":[{"content":"WPF Architecture","pos":[0,16]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[514,530],"content":"WPF Architecture","linkify":"WPF Architecture","nodes":[{"content":"WPF Architecture","pos":[0,16]}]},{"content":"This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.","pos":[531,626]},{"content":"It covers most of the major subsystems of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, and describes how they interact.","pos":[627,772],"source":" It covers most of the major subsystems of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], and describes how they interact."},{"content":"It also details some of the choices made by the architects of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>.","pos":[773,905],"source":" It also details some of the choices made by the architects of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]."},{"pos":[944,957],"content":"System.Object","linkify":"System.Object","nodes":[{"content":"System.Object","pos":[0,13]}]},{"content":"The primary <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> programming model is exposed through managed code.","pos":[961,1093],"source":"The primary [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] programming model is exposed through managed code."},{"content":"Early in the design phase of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.","pos":[1094,1329],"source":" Early in the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones."},{"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.","pos":[1330,1579],"source":" The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost."},{"content":"The major components of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> are illustrated in the figure below.","pos":[1586,1716],"source":"The major components of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] are illustrated in the figure below."},{"content":"The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>.","pos":[1717,1905],"source":" The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]."},{"content":"Of these, only one is an unmanaged component – milcore.","pos":[1906,1961]},{"content":"Milcore is written in unmanaged code in order to enable tight integration with <ph id=\"ph1\">[!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)]</ph>.","pos":[1962,2109],"source":" Milcore is written in unmanaged code in order to enable tight integration with [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)]."},{"content":"All display in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is done through the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)]</ph> engine, allowing for efficient hardware and software rendering.","pos":[2110,2346],"source":" All display in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is done through the [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] engine, allowing for efficient hardware and software rendering."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> also required fine control over memory and execution.","pos":[2347,2470],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] also required fine control over memory and execution."},{"content":"The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> to gain performance.","pos":[2471,2677],"source":" The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] to gain performance."},{"pos":[2684,2778],"content":"<bpt id=\"p1\">![</bpt>The position of WPF within the .NET Framework.<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/wpf-architect1.PNG \"</bpt>wpf_architect1<ept id=\"p2\">\")</ept>","source":"![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG \"wpf_architect1\")"},{"content":"Communication between the managed and unmanaged portions of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is discussed later in this topic.","pos":[2785,2948],"source":"Communication between the managed and unmanaged portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is discussed later in this topic."},{"content":"The remainder of the managed programming model is described below.","pos":[2949,3015]},{"pos":[3076,3109],"content":"System.Threading.DispatcherObject","linkify":"System.Threading.DispatcherObject","nodes":[{"content":"System.Threading.DispatcherObject","pos":[0,33]}]},{"content":"Most objects in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> derive from <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph>, which provides the basic constructs for dealing with concurrency and threading.","pos":[3113,3340],"source":"Most objects in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is based on a messaging system implemented by the dispatcher.","pos":[3341,3472],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is based on a messaging system implemented by the dispatcher."},{"content":"This works much like the familiar <ph id=\"ph1\">[!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]</ph> message pump; in fact, the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> dispatcher uses User32 messages for performing cross thread calls.","pos":[3473,3742],"source":" This works much like the familiar [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] message pump; in fact, the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] dispatcher uses User32 messages for performing cross thread calls."},{"pos":[3749,3936],"content":"There are really two core concepts to understand when discussing concurrency in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> – the dispatcher and thread affinity.","source":"There are really two core concepts to understand when discussing concurrency in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – the dispatcher and thread affinity."},{"content":"During the design phase of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, the goal was to move to a single thread of execution, but a non-thread \"affinitized\" model.","pos":[3943,4132],"source":"During the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the goal was to move to a single thread of execution, but a non-thread \"affinitized\" model."},{"content":"Thread affinity happens when a component uses the identity of the executing thread to store some type of state.","pos":[4133,4244]},{"content":"The most common form of this is to use the thread local store (TLS) to store state.","pos":[4245,4328]},{"content":"Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.","pos":[4329,4488]},{"content":"In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.","pos":[4489,4631]},{"content":"The primary reason for this was interoperability – systems like <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)]</ph>, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.","pos":[4632,4861],"source":" The primary reason for this was interoperability – systems like [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], the clipboard, and Internet Explorer all require single thread affinity (STA) execution."},{"content":"Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.","pos":[4868,5011]},{"content":"Herein lies the role of the dispatcher.","pos":[5012,5051]},{"content":"The dispatcher is a basic message dispatching system, with multiple prioritized queues.","pos":[5052,5139]},{"content":"Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).","pos":[5140,5277]},{"content":"By deriving from <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph>, you create a <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> object that has STA behavior, and will be given a pointer to a dispatcher at creation time.","pos":[5278,5519],"source":" By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] object that has STA behavior, and will be given a pointer to a dispatcher at creation time."},{"pos":[5578,5609],"content":"System.Windows.DependencyObject","linkify":"System.Windows.DependencyObject","nodes":[{"content":"System.Windows.DependencyObject","pos":[0,31]}]},{"content":"One of the primary architectural philosophies used in building <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> was a preference for properties over methods or events.","pos":[5613,5801],"source":"One of the primary architectural philosophies used in building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] was a preference for properties over methods or events."},{"content":"Properties are declarative and allow you to more easily specify intent instead of action.","pos":[5802,5891]},{"content":"This also supported a model driven, or data driven, system for displaying user interface content.","pos":[5892,5989]},{"content":"This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.","pos":[5990,6140]},{"content":"In order to have more of the system driven by properties, a richer property system than what the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> provides was needed.","pos":[6147,6334],"source":"In order to have more of the system driven by properties, a richer property system than what the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides was needed."},{"content":"A simple example of this richness is change notifications.","pos":[6335,6393]},{"content":"In order to enable two way binding, you need both sides of the bind to support change notification.","pos":[6394,6493]},{"content":"In order to have behavior tied to property values, you need to be notified when the property value changes.","pos":[6494,6601]},{"content":"The Microsoft .NET Framework has an interface, <bpt id=\"p1\">**</bpt>INotifyPropertyChange<ept id=\"p1\">**</ept>, which allows an object to publish change notifications, however it is optional.","pos":[6602,6755],"source":" The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> provides a richer property system, derived from the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject&gt;</ph> type.","pos":[6762,6928],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type."},{"content":"The property system is truly a \"dependency\" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.","pos":[6929,7120]},{"content":"For example, if you have a property that inherits (like <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.FontSize%2A&gt;</ph>), the system is automatically updated if the property changes on a parent of an element that inherits the value.","pos":[7121,7340],"source":" For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value."},{"content":"The foundation of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> property system is the concept of a property expression.","pos":[7347,7495],"source":"The foundation of the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] property system is the concept of a property expression."},{"content":"In this first release of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, the property expression system is closed, and the expressions are all provided as part of the framework.","pos":[7496,7696],"source":" In this first release of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the property expression system is closed, and the expressions are all provided as part of the framework."},{"content":"Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.","pos":[7697,7857]},{"content":"The property system also provides for sparse storage of property values.","pos":[7864,7936]},{"content":"Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.","pos":[7937,8180]},{"content":"The final new feature of the property system is the notion of attached properties.","pos":[8187,8269]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> elements are built on the principle of composition and component reuse.","pos":[8270,8411],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] elements are built on the principle of composition and component reuse."},{"content":"It is often the case that some containing element (like a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Grid&gt;</ph> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).","pos":[8412,8620],"source":" It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information)."},{"content":"Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.","pos":[8621,8763]},{"content":"This is similar to the \"expando\" features of JavaScript.","pos":[8764,8820]},{"pos":[8875,8902],"content":"System.Windows.Media.Visual","linkify":"System.Windows.Media.Visual","nodes":[{"content":"System.Windows.Media.Visual","pos":[0,27]}]},{"content":"With a system defined, the next step is getting pixels drawn to the screen.","pos":[8906,8981]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).","pos":[8982,9208],"source":" The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> is designed to be extremely lightweight and flexible, so most of the features have no public <ph id=\"ph2\">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> exposure and rely heavily on protected callback functions.","pos":[9209,9465],"source":"<xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure and rely heavily on protected callback functions."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> is really the entry point to the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> composition system.","pos":[9472,9629],"source":"<xref:System.Windows.Media.Visual> is really the entry point to the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] composition system."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> is the point of connection between these two subsystems, the managed <ph id=\"ph2\">[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]</ph> and the unmanaged milcore.","pos":[9630,9828],"source":"<xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] and the unmanaged milcore."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> displays data by traversing the unmanaged data structures managed by the milcore.","pos":[9835,9986],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] displays data by traversing the unmanaged data structures managed by the milcore."},{"content":"These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.","pos":[9987,10110]},{"content":"This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.","pos":[10111,10226]},{"content":"When programming <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, you create <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.","pos":[10233,10481],"source":"When programming [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> in <ph id=\"ph2\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> may create one, none, or several composition nodes.","pos":[10482,10646],"source":" Each <xref:System.Windows.Media.Visual> in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] may create one, none, or several composition nodes."},{"pos":[10653,10755],"content":"<bpt id=\"p1\">![</bpt>The Windows Presentation Foundation Visual Tree.<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/wpf-architecture2.PNG \"</bpt>wpf_architecture2<ept id=\"p2\">\")</ept>","source":"![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG \"wpf_architecture2\")"},{"content":"There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.","pos":[10762,10888]},{"content":"In graphics terms, <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> uses a retained rendering system.","pos":[10889,11011],"source":" In graphics terms, [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a retained rendering system."},{"content":"This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.","pos":[11012,11135]},{"content":"This helps prevent the appearance of an unresponsive application.","pos":[11136,11201]},{"content":"Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.","pos":[11208,11325]},{"content":"In User32 and <ph id=\"ph1\">[!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)]</ph>, the system works on an immediate mode clipping system.","pos":[11332,11471],"source":"In User32 and [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)], the system works on an immediate mode clipping system."},{"content":"When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.","pos":[11472,11678]},{"content":"This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.","pos":[11679,11881]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> uses a \"painter's algorithm\" painting model.","pos":[11888,12002],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a \"painter's algorithm\" painting model."},{"content":"This means that instead of clipping each component, each component is asked to render from the back to the front of the display.","pos":[12003,12131]},{"content":"This allows each component to paint over the previous component's display.","pos":[12132,12206]},{"content":"The advantage of this model is that you can have complex, partially transparent shapes.","pos":[12207,12294]},{"content":"With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ <ph id=\"ph1\">[!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)]</ph> were created).","pos":[12295,12484],"source":" With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] were created)."},{"content":"As mentioned previously, a core philosophy of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is to move to a more declarative, \"property centric\" model of programming.","pos":[12491,12681],"source":"As mentioned previously, a core philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is to move to a more declarative, \"property centric\" model of programming."},{"content":"In the visual system, this shows up in a couple of interesting places.","pos":[12682,12752]},{"content":"First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().","pos":[12759,12944]},{"content":"This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.","pos":[12945,13067]},{"content":"The types deriving from <ph id=\"ph1\">&lt;xref:System.Windows.Media.Drawing&gt;</ph> are effectively the object model for rendering.","pos":[13068,13175],"source":" The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering."},{"content":"Second, if you evaluate the animation system, you'll see that it is almost completely declarative.","pos":[13182,13280]},{"content":"Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.","pos":[13281,13432]},{"content":"These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.","pos":[13433,13630]},{"pos":[13682,13706],"content":"System.Windows.UIElement","linkify":"System.Windows.UIElement","nodes":[{"content":"System.Windows.UIElement","pos":[0,24]}]},{"pos":[13710,13802],"content":"<ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> defines core subsystems including Layout, Input, and Events.","source":"<xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events."},{"content":"Layout is a core concept in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>.","pos":[13809,13907],"source":"Layout is a core concept in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]."},{"content":"In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).","pos":[13908,14111]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.","pos":[14112,14354],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic."},{"content":"At the <ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> level, the basic contract for layout is introduced – a two phase model with <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> passes.","pos":[14355,14567],"source":" At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> allows a component to determine how much size it would like to take.","pos":[14574,14685],"source":"<xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take."},{"content":"This is a separate phase from <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.","pos":[14686,14901],"source":" This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size."},{"content":"The fact that parent elements ask child elements to measure demonstrates another key philosophy of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> – size to content.","pos":[14902,15089],"source":" The fact that parent elements ask child elements to measure demonstrates another key philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – size to content."},{"content":"All controls in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> support the ability to size to the natural size of their content.","pos":[15090,15241],"source":" All controls in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] support the ability to size to the natural size of their content."},{"content":"This makes localization much easier, and allows for dynamic layout of elements as things resize.","pos":[15242,15338]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> phase allows a parent to position and determine the final size of each child.","pos":[15339,15463],"source":" The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child."},{"content":"A lot of time is often spent talking about the output side of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> – <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> and related objects.","pos":[15470,15659],"source":"A lot of time is often spent talking about the output side of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> and related objects."},{"content":"However there is a tremendous amount of innovation on the input side as well.","pos":[15660,15737]},{"content":"Probably the most fundamental change in the input model for <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is the consistent model by which input events are routed through the system.","pos":[15738,15944],"source":" Probably the most fundamental change in the input model for [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the consistent model by which input events are routed through the system."},{"content":"Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.","pos":[15951,16130]},{"content":"Once the User32 message corresponding to the input is routed to <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, it is converted into a <ph id=\"ph2\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> raw input message and sent to the dispatcher.","pos":[16131,16404],"source":" Once the User32 message corresponding to the input is routed to [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], it is converted into a [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] raw input message and sent to the dispatcher."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> allows for raw input events to be converted to multiple actual events, enabling features like \"MouseEnter\" to be implemented at a low level of the system with guaranteed delivery.","pos":[16405,16654],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] allows for raw input events to be converted to multiple actual events, enabling features like \"MouseEnter\" to be implemented at a low level of the system with guaranteed delivery."},{"content":"Each input event is converted to at least two events – a \"preview\" event and the actual event.","pos":[16661,16755]},{"content":"All events in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> have a notion of routing through the element tree.","pos":[16756,16890],"source":" All events in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] have a notion of routing through the element tree."},{"content":"Events are said to \"bubble\" if they traverse from a target up the tree to the root, and are said to \"tunnel\" if they start at the root and traverse down to a target.","pos":[16891,17056]},{"content":"Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.","pos":[17057,17172]},{"content":"The regular (non-preview) events then bubble from the target up to the root.","pos":[17173,17249]},{"content":"This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.","pos":[17256,17413]},{"content":"In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to \"New\").","pos":[17414,17578]},{"content":"In the dispatcher for your application you would call <bpt id=\"p1\">**</bpt>TranslateAccelerator<ept id=\"p1\">**</ept> which would sniff the input messages in User32 and determine if any matched a registered accelerator.","pos":[17579,17759],"source":" In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator."},{"content":"In <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> this wouldn’t work because the system is fully \"composable\" – any element can handle and use any keyboard accelerator.","pos":[17760,17951],"source":" In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] this wouldn’t work because the system is fully \"composable\" – any element can handle and use any keyboard accelerator."},{"content":"Having this two phase model for input allows components to implement their own \"TranslateAccelerator\".","pos":[17952,18054]},{"content":"To take this one step further, <ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> also introduces the notion of CommandBindings.","pos":[18061,18170],"source":"To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings."},{"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> command system allows developers to define functionality in terms of a command end point – something that implements <ph id=\"ph2\">&lt;xref:System.Windows.Input.ICommand&gt;</ph>.","pos":[18171,18399],"source":" The [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>."},{"content":"Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).","pos":[18400,18509]},{"content":"Both the input gestures and command definitions are extensible, and can be wired together at usage time.","pos":[18510,18614]},{"content":"This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.","pos":[18615,18746]},{"content":"To this point in the topic, \"core\" features of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> – features implemented in the PresentationCore assembly, have been the focus.","pos":[18753,18947],"source":"To this point in the topic, \"core\" features of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – features implemented in the PresentationCore assembly, have been the focus."},{"content":"When building <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, a clean separation between foundational pieces (like the contract for layout with <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept>) and framework pieces (like the implementation of a specific layout like <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Grid&gt;</ph>) was the desired outcome.","pos":[18948,19277],"source":" When building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome."},{"content":"The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.","pos":[19278,19420]},{"pos":[19479,19510],"content":"System.Windows.FrameworkElement","linkify":"System.Windows.FrameworkElement","nodes":[{"content":"System.Windows.FrameworkElement","pos":[0,31]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> can be looked at in two different ways.","pos":[19514,19592],"source":"<xref:System.Windows.FrameworkElement> can be looked at in two different ways."},{"content":"It introduces a set of policies and customizations on the subsystems introduced in lower layers of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>.","pos":[19593,19762],"source":" It introduces a set of policies and customizations on the subsystems introduced in lower layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]."},{"content":"It also introduces a set of new subsystems.","pos":[19763,19806]},{"content":"The primary policy introduced by <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is around application layout.","pos":[19813,19914],"source":"The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> builds on the basic layout contract introduced by <ph id=\"ph2\">&lt;xref:System.Windows.UIElement&gt;</ph> and adds the notion of a layout \"slot\" that makes it easier for layout authors to have a consistent set of property driven layout semantics.","pos":[19915,20176],"source":"<xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout \"slot\" that makes it easier for layout authors to have a consistent set of property driven layout semantics."},{"content":"Properties like <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> (to name a few) give all components derived from <ph id=\"ph5\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> consistent behavior inside of layout containers.","pos":[20177,20558],"source":" Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> also provides easier <ph id=\"ph2\">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> exposure to many features found in the core layers of <ph id=\"ph3\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>.","pos":[20565,20819],"source":"<xref:System.Windows.FrameworkElement> also provides easier [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure to many features found in the core layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> provides direct access to animation through the <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.BeginStoryboard%2A&gt;</ph> method.","pos":[20820,20985],"source":" For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> provides a way to script multiple animations against a set of properties.","pos":[20986,21110],"source":" A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties."},{"pos":[21117,21229],"content":"The two most critical things that <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> introduces are data binding and styles.","source":"The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles."},{"content":"The data binding subsystem in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> should be relatively familiar to anyone that has used <ph id=\"ph2\">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]</ph> or <ph id=\"ph3\">[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]</ph> for creating an application <ph id=\"ph4\">[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]</ph>.","pos":[21236,21639],"source":"The data binding subsystem in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]."},{"content":"In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.","pos":[21640,21788]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> has full support for property binding, transformation, and list binding.","pos":[21789,21931],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] has full support for property binding, transformation, and list binding."},{"content":"One of the most interesting features of data binding in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is the introduction of data templates.","pos":[21938,22102],"source":"One of the most interesting features of data binding in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the introduction of data templates."},{"content":"Data templates allow you to declaratively specify how a piece of data should be visualized.","pos":[22103,22194]},{"content":"Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.","pos":[22195,22366]},{"content":"Styling is really a lightweight form of data binding.","pos":[22373,22426]},{"content":"Using styling you can bind a set of properties from a shared definition to one or more instances of an element.","pos":[22427,22538]},{"content":"Styles get applied to an element either by explicit reference (by setting the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property) or implicitly by associating a style with the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> type of the element.","pos":[22539,22811],"source":" Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] type of the element."},{"pos":[22870,22901],"content":"System.Windows.Controls.Control","linkify":"System.Windows.Controls.Control","nodes":[{"content":"System.Windows.Controls.Control","pos":[0,31]}]},{"content":"Control’s most significant feature is templating.","pos":[22905,22954]},{"content":"If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.","pos":[22955,23129]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.","pos":[23130,23302],"source":" A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control&gt;</ph> provides a set of stock properties, <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control.Foreground%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>, to name a few, which template authors can then use to customize the display of a control.","pos":[23309,23632],"source":"<xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control."},{"content":"The implementation of a control provides a data model and interaction model.","pos":[23633,23709]},{"content":"The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).","pos":[23710,23875]},{"content":"The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).","pos":[23876,24016]},{"content":"This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.","pos":[24023,24206]},{"content":"A common aspect of the data model of controls is the content model.","pos":[24213,24280]},{"content":"If you look at a control like <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph>, you will see that it has a property named \"Content\" of type <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[24281,24431],"source":" If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named \"Content\" of type <xref:System.Object>."},{"content":"In <ph id=\"ph1\">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]</ph>, this property would typically be a string – however that limits the type of content you can put in a button.","pos":[24432,24700],"source":" In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)], this property would typically be a string – however that limits the type of content you can put in a button."},{"content":"Content for a button can either be a simple string, a complex data object, or an entire element tree.","pos":[24701,24802]},{"content":"In the case of a data object, the data template is used to construct a display.","pos":[24803,24882]},{"pos":[24917,24924],"content":"Summary","linkify":"Summary","nodes":[{"content":"Summary","pos":[0,7]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> is designed to allow you to create dynamic, data driven presentation systems.","pos":[24928,25075],"source":"[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is designed to allow you to create dynamic, data driven presentation systems."},{"content":"Every part of the system is designed to create objects through property sets that drive behavior.","pos":[25076,25173]},{"content":"Data binding is a fundamental part of the system, and is integrated at every layer.","pos":[25174,25257]},{"content":"Traditional applications create a display and then bind to some data.","pos":[25264,25333]},{"content":"In <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, everything about the control, every aspect of the display, is generated by some type of data binding.","pos":[25334,25509],"source":" In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], everything about the control, every aspect of the display, is generated by some type of data binding."},{"content":"The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.","pos":[25510,25663]},{"content":"When you begin developing <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph> based applications, it should feel very familiar.","pos":[25670,25815],"source":"When you begin developing [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] based applications, it should feel very familiar."},{"content":"You can set properties, use objects, and data bind in much the same way that you can using <ph id=\"ph1\">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]</ph> or <ph id=\"ph2\">[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]</ph>.","pos":[25816,26062],"source":" You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]."},{"content":"With a deeper investigation into the architecture of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]</ph>, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.","pos":[26063,26333],"source":" With a deeper investigation into the architecture of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application."},{"pos":[26342,26350],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[26642,26699],"content":"<bpt id=\"p1\">[</bpt>Data Binding Overview<ept id=\"p1\">](../data/data-binding-overview.md)</ept>","source":"[Data Binding Overview](../data/data-binding-overview.md)"},{"pos":[26702,26721],"content":"<bpt id=\"p1\">[</bpt>Layout<ept id=\"p1\">](layout.md)</ept>","source":"[Layout](layout.md)"},{"pos":[26724,26790],"content":"<bpt id=\"p1\">[</bpt>Animation Overview<ept id=\"p1\">](../graphics-multimedia/animation-overview.md)</ept>","source":"[Animation Overview](../graphics-multimedia/animation-overview.md)"}]}