{"content":"---\ntitle: \"Partial Classes and Methods (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"partial methods [C#]\"\n  - \"partial classes [C#]\"\n  - \"C# language, partial classes and methods\"\nms.assetid: 804cecb7-62db-4f97-a99f-60975bd59fa1\ncaps.latest.revision: 35\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Partial Classes and Methods (C# Programming Guide)\nIt is possible to split the definition of a [class](../../../csharp/language-reference/keywords/class.md) or a [struct](../../../csharp/language-reference/keywords/struct.md), an [interface](../../../csharp/language-reference/keywords/interface.md) or a method over two or more source files. Each source file contains a section of the type or method definition, and all parts are combined when the application is compiled.  \n  \n## Partial Classes  \n There are several situations when splitting a class definition is desirable:  \n  \n-   When working on large projects, spreading a class over separate files enables multiple programmers to work on it at the same time.  \n  \n-   When working with automatically generated source, code can be added to the class without having to recreate the source file. Visual Studio uses this approach when it creates Windows Forms, Web service wrapper code, and so on. You can create code that uses these classes without having to modify the file created by Visual Studio.  \n  \n-   To split a class definition, use the [partial](../../../csharp/language-reference/keywords/partial-type.md) keyword modifier, as shown here:  \n  \n [!code-cs[csProgGuideObjects#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_1.cs)]  \n  \n The `partial` keyword indicates that other parts of the class, struct, or interface can be defined in the namespace. All the parts must use the `partial` keyword. All the parts must be available at compile time to form the final type. All the parts must have the same accessibility, such as `public`, `private`, and so on.  \n  \n If any part is declared abstract, then the whole type is considered abstract. If any part is declared sealed, then the whole type is considered sealed. If any part declares a base type, then the whole type inherits that class.  \n  \n All the parts that specify a base class must agree, but parts that omit a base class still inherit the base type. Parts can specify different base interfaces, and the final type implements all the interfaces listed by all the partial declarations. Any class, struct, or interface members declared in a partial definition are available to all the other parts. The final type is the combination of all the parts at compile time.  \n  \n> [!NOTE]\n>  The `partial` modifier is not available on delegate or enumeration declarations.  \n  \n The following example shows that nested types can be partial, even if the type they are nested within is not partial itself.  \n  \n [!code-cs[csProgGuideObjects#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_2.cs)]  \n  \n At compile time, attributes of partial-type definitions are merged. For example, consider the following declarations:  \n  \n [!code-cs[csProgGuideObjects#23](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_3.cs)]  \n  \n They are equivalent to the following declarations:  \n  \n [!code-cs[csProgGuideObjects#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_4.cs)]  \n  \n The following are merged from all the partial-type definitions:  \n  \n-   XML comments  \n  \n-   interfaces  \n  \n-   generic-type parameter attributes  \n  \n-   class attributes  \n  \n-   members  \n  \n For example, consider the following declarations:  \n  \n [!code-cs[csProgGuideObjects#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_5.cs)]  \n  \n They are equivalent to the following declarations:  \n  \n [!code-cs[csProgGuideObjects#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_6.cs)]  \n  \n### Restrictions  \n There are several rules to follow when you are working with partial class definitions:  \n  \n-   All partial-type definitions meant to be parts of the same type must be modified with `partial`. For example, the following class declarations generate an error:  \n  \n     [!code-cs[csProgGuideObjects#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_7.cs)]  \n  \n-   The `partial` modifier can only appear immediately before the keywords `class`, `struct`, or `interface`.  \n  \n-   Nested partial types are allowed in partial-type definitions as illustrated in the following example:  \n  \n     [!code-cs[csProgGuideObjects#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_8.cs)]  \n  \n-   All partial-type definitions meant to be parts of the same type must be defined in the same assembly and the same module (.exe or .dll file). Partial definitions cannot span multiple modules.  \n  \n-   The class name and generic-type parameters must match on all partial-type definitions. Generic types can be partial. Each partial declaration must use the same parameter names in the same order.  \n  \n-   The following keywords on a partial-type definition are optional, but if present on one partial-type definition, cannot conflict with the keywords specified on another partial definition for the same type:  \n  \n    -   [public](../../../csharp/language-reference/keywords/public.md)  \n  \n    -   [private](../../../csharp/language-reference/keywords/private.md)  \n  \n    -   [protected](../../../csharp/language-reference/keywords/protected.md)  \n  \n    -   [internal](../../../csharp/language-reference/keywords/internal.md)  \n  \n    -   [abstract](../../../csharp/language-reference/keywords/abstract.md)  \n  \n    -   [sealed](../../../csharp/language-reference/keywords/sealed.md)  \n  \n    -   base class  \n  \n    -   [new](../../../csharp/language-reference/keywords/new.md) modifier (nested parts)  \n  \n    -   generic constraints  \n  \n         For more information, see [Constraints on Type Parameters](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md).  \n  \n## Example 1  \n  \n### Description  \n In the following example, the fields and the constructor of the class, `CoOrds`, are declared in one partial class definition, and the member, `PrintCoOrds`, is declared in another partial class definition.  \n  \n### Code  \n [!code-cs[csProgGuideObjects#17](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_9.cs)]  \n  \n## Example 2  \n  \n### Description  \n The following example shows that you can also develop partial structs and interfaces.  \n  \n### Code  \n [!code-cs[csProgGuideObjects#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_10.cs)]  \n  \n## Partial Methods  \n A partial class or struct may contain a partial method. One part of the class contains the signature of the method. An optional implementation may be defined in the same part or another part. If the implementation is not supplied, then the method and all calls to the method are removed at compile time.  \n  \n Partial methods enable the implementer of one part of a class to define a method, similar to an event. The implementer of the other part of the class can decide whether to implement the method or not. If the method is not implemented, then the compiler removes the method signature and all calls to the method. The calls to the method, including any results that would occur from evaluation of arguments in the calls, have no effect at run time. Therefore, any code in the partial class can freely use a partial method, even if the implementation is not supplied. No compile-time or run-time errors will result if the method is called but not implemented.  \n  \n Partial methods are especially useful as a way to customize generated code. They allow for a method name and signature to be reserved, so that generated code can call the method but the developer can decide whether to implement the method. Much like partial classes, partial methods enable code created by a code generator and code created by a human developer to work together without run-time costs.  \n  \n A partial method declaration consists of two parts: the definition, and the implementation. These may be in separate parts of a partial class, or in the same part. If there is no implementation declaration, then the compiler optimizes away both the defining declaration and all calls to the method.  \n  \n```  \n// Definition in file1.cs  \npartial void onNameChanged();  \n  \n// Implementation in file2.cs  \npartial void onNameChanged()  \n{  \n  // method body  \n}  \n```  \n  \n-   Partial method declarations must begin with the contextual keyword [partial](../../../csharp/language-reference/keywords/partial-type.md) and the method must return [void](../../../csharp/language-reference/keywords/void.md).  \n  \n-   Partial methods can have [ref](../../../csharp/language-reference/keywords/ref.md) but not [out](../../../csharp/language-reference/keywords/out.md) parameters.  \n  \n-   Partial methods are implicitly [private](../../../csharp/language-reference/keywords/private.md), and therefore they cannot be [virtual](../../../csharp/language-reference/keywords/virtual.md).  \n  \n-   Partial methods cannot be [extern](../../../csharp/language-reference/keywords/extern.md), because the presence of the body determines whether they are defining or implementing.  \n  \n-   Partial methods can have [static](../../../csharp/language-reference/keywords/static.md) and [unsafe](../../../csharp/language-reference/keywords/unsafe.md) modifiers.  \n  \n-   Partial methods can be generic. Constraints are put on the defining partial method declaration, and may optionally be repeated on the implementing one. Parameter and type parameter names do not have to be the same in the implementing declaration as in the defining one.  \n  \n-   You can make a [delegate](../../../csharp/language-reference/keywords/delegate.md) to a partial method that has been defined and implemented, but not to a partial method that has only been defined.  \n  \n## C# Language Specification  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## See Also  \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Classes](../../../csharp/programming-guide/classes-and-structs/classes.md)   \n [Structs](../../../csharp/programming-guide/classes-and-structs/structs.md)   \n [Interfaces](../../../csharp/programming-guide/interfaces/index.md)   \n [partial (Type)](../../../csharp/language-reference/keywords/partial-type.md)","nodes":[{"pos":[12,79],"content":"Partial Classes and Methods (C# Programming Guide) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Partial Classes and Methods (C# Programming Guide) | Microsoft Docs","pos":[0,67]}]},{"pos":[630,680],"content":"Partial Classes and Methods (C# Programming Guide)","linkify":"Partial Classes and Methods (C# Programming Guide)","nodes":[{"content":"Partial Classes and Methods (C# Programming Guide)","pos":[0,50]}]},{"content":"It is possible to split the definition of a <bpt id=\"p1\">[</bpt>class<ept id=\"p1\">](../../../csharp/language-reference/keywords/class.md)</ept> or a <bpt id=\"p2\">[</bpt>struct<ept id=\"p2\">](../../../csharp/language-reference/keywords/struct.md)</ept>, an <bpt id=\"p3\">[</bpt>interface<ept id=\"p3\">](../../../csharp/language-reference/keywords/interface.md)</ept> or a method over two or more source files.","pos":[681,972],"source":"It is possible to split the definition of a [class](../../../csharp/language-reference/keywords/class.md) or a [struct](../../../csharp/language-reference/keywords/struct.md), an [interface](../../../csharp/language-reference/keywords/interface.md) or a method over two or more source files."},{"content":"Each source file contains a section of the type or method definition, and all parts are combined when the application is compiled.","pos":[973,1103]},{"pos":[1112,1127],"content":"Partial Classes","linkify":"Partial Classes","nodes":[{"content":"Partial Classes","pos":[0,15]}]},{"content":"There are several situations when splitting a class definition is desirable:","pos":[1131,1207]},{"content":"When working on large projects, spreading a class over separate files enables multiple programmers to work on it at the same time.","pos":[1217,1347]},{"content":"When working with automatically generated source, code can be added to the class without having to recreate the source file.","pos":[1357,1481]},{"content":"Visual Studio uses this approach when it creates Windows Forms, Web service wrapper code, and so on.","pos":[1482,1582]},{"content":"You can create code that uses these classes without having to modify the file created by Visual Studio.","pos":[1583,1686]},{"pos":[1696,1836],"content":"To split a class definition, use the <bpt id=\"p1\">[</bpt>partial<ept id=\"p1\">](../../../csharp/language-reference/keywords/partial-type.md)</ept> keyword modifier, as shown here:","source":"To split a class definition, use the [partial](../../../csharp/language-reference/keywords/partial-type.md) keyword modifier, as shown here:"},{"pos":[1843,1983],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#26<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_1.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_1.cs)]"},{"content":"The <ph id=\"ph1\">`partial`</ph> keyword indicates that other parts of the class, struct, or interface can be defined in the namespace.","pos":[1990,2106],"source":"The `partial` keyword indicates that other parts of the class, struct, or interface can be defined in the namespace."},{"content":"All the parts must use the <ph id=\"ph1\">`partial`</ph> keyword.","pos":[2107,2152],"source":" All the parts must use the `partial` keyword."},{"content":"All the parts must be available at compile time to form the final type.","pos":[2153,2224]},{"content":"All the parts must have the same accessibility, such as <ph id=\"ph1\">`public`</ph>, <ph id=\"ph2\">`private`</ph>, and so on.","pos":[2225,2312],"source":" All the parts must have the same accessibility, such as `public`, `private`, and so on."},{"content":"If any part is declared abstract, then the whole type is considered abstract.","pos":[2319,2396]},{"content":"If any part is declared sealed, then the whole type is considered sealed.","pos":[2397,2470]},{"content":"If any part declares a base type, then the whole type inherits that class.","pos":[2471,2545]},{"content":"All the parts that specify a base class must agree, but parts that omit a base class still inherit the base type.","pos":[2552,2665]},{"content":"Parts can specify different base interfaces, and the final type implements all the interfaces listed by all the partial declarations.","pos":[2666,2799]},{"content":"Any class, struct, or interface members declared in a partial definition are available to all the other parts.","pos":[2800,2910]},{"content":"The final type is the combination of all the parts at compile time.","pos":[2911,2978]},{"pos":[2986,3077],"content":"[!NOTE]\n The `partial` modifier is not available on delegate or enumeration declarations.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">`partial`</ph> modifier is not available on delegate or enumeration declarations.","pos":[9,89],"source":" The `partial` modifier is not available on delegate or enumeration declarations."}]},{"content":"The following example shows that nested types can be partial, even if the type they are nested within is not partial itself.","pos":[3084,3208]},{"pos":[3215,3355],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#25<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_2.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_2.cs)]"},{"content":"At compile time, attributes of partial-type definitions are merged.","pos":[3362,3429]},{"content":"For example, consider the following declarations:","pos":[3430,3479]},{"pos":[3486,3626],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#23<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_3.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#23](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_3.cs)]"},{"content":"They are equivalent to the following declarations:","pos":[3633,3683]},{"pos":[3690,3830],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#24<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_4.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_4.cs)]"},{"content":"The following are merged from all the partial-type definitions:","pos":[3837,3900]},{"content":"XML comments","pos":[3910,3922]},{"content":"interfaces","pos":[3932,3942]},{"content":"generic-type parameter attributes","pos":[3952,3985]},{"content":"class attributes","pos":[3995,4011]},{"content":"members","pos":[4021,4028]},{"content":"For example, consider the following declarations:","pos":[4035,4084]},{"pos":[4091,4231],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#21<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_5.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_5.cs)]"},{"content":"They are equivalent to the following declarations:","pos":[4238,4288]},{"pos":[4295,4435],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#22<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_6.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_6.cs)]"},{"pos":[4445,4457],"content":"Restrictions","linkify":"Restrictions","nodes":[{"content":"Restrictions","pos":[0,12]}]},{"content":"There are several rules to follow when you are working with partial class definitions:","pos":[4461,4547]},{"content":"All partial-type definitions meant to be parts of the same type must be modified with <ph id=\"ph1\">`partial`</ph>.","pos":[4557,4653],"source":"All partial-type definitions meant to be parts of the same type must be modified with `partial`."},{"content":"For example, the following class declarations generate an error:","pos":[4654,4718]},{"pos":[4729,4869],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#20<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_7.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_7.cs)]"},{"pos":[4879,4984],"content":"The <ph id=\"ph1\">`partial`</ph> modifier can only appear immediately before the keywords <ph id=\"ph2\">`class`</ph>, <ph id=\"ph3\">`struct`</ph>, or <ph id=\"ph4\">`interface`</ph>.","source":"The `partial` modifier can only appear immediately before the keywords `class`, `struct`, or `interface`."},{"content":"Nested partial types are allowed in partial-type definitions as illustrated in the following example:","pos":[4994,5095]},{"pos":[5106,5246],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#19<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_8.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_8.cs)]"},{"content":"All partial-type definitions meant to be parts of the same type must be defined in the same assembly and the same module (.exe or .dll file).","pos":[5256,5397]},{"content":"Partial definitions cannot span multiple modules.","pos":[5398,5447]},{"content":"The class name and generic-type parameters must match on all partial-type definitions.","pos":[5457,5543]},{"content":"Generic types can be partial.","pos":[5544,5573]},{"content":"Each partial declaration must use the same parameter names in the same order.","pos":[5574,5651]},{"content":"The following keywords on a partial-type definition are optional, but if present on one partial-type definition, cannot conflict with the keywords specified on another partial definition for the same type:","pos":[5661,5866]},{"pos":[5880,5943],"content":"<bpt id=\"p1\">[</bpt>public<ept id=\"p1\">](../../../csharp/language-reference/keywords/public.md)</ept>","source":"[public](../../../csharp/language-reference/keywords/public.md)"},{"pos":[5957,6022],"content":"<bpt id=\"p1\">[</bpt>private<ept id=\"p1\">](../../../csharp/language-reference/keywords/private.md)</ept>","source":"[private](../../../csharp/language-reference/keywords/private.md)"},{"pos":[6036,6105],"content":"<bpt id=\"p1\">[</bpt>protected<ept id=\"p1\">](../../../csharp/language-reference/keywords/protected.md)</ept>","source":"[protected](../../../csharp/language-reference/keywords/protected.md)"},{"pos":[6119,6186],"content":"<bpt id=\"p1\">[</bpt>internal<ept id=\"p1\">](../../../csharp/language-reference/keywords/internal.md)</ept>","source":"[internal](../../../csharp/language-reference/keywords/internal.md)"},{"pos":[6200,6267],"content":"<bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](../../../csharp/language-reference/keywords/abstract.md)</ept>","source":"[abstract](../../../csharp/language-reference/keywords/abstract.md)"},{"pos":[6281,6344],"content":"<bpt id=\"p1\">[</bpt>sealed<ept id=\"p1\">](../../../csharp/language-reference/keywords/sealed.md)</ept>","source":"[sealed](../../../csharp/language-reference/keywords/sealed.md)"},{"content":"base class","pos":[6358,6368]},{"pos":[6382,6463],"content":"<bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../../../csharp/language-reference/keywords/new.md)</ept> modifier (nested parts)","source":"[new](../../../csharp/language-reference/keywords/new.md) modifier (nested parts)"},{"content":"generic constraints","pos":[6477,6496]},{"pos":[6511,6648],"content":"For more information, see <bpt id=\"p1\">[</bpt>Constraints on Type Parameters<ept id=\"p1\">](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md)</ept>.","source":"For more information, see [Constraints on Type Parameters](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md)."},{"pos":[6657,6666],"content":"Example 1","linkify":"Example 1","nodes":[{"content":"Example 1","pos":[0,9]}]},{"pos":[6676,6687],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[6691,6897],"content":"In the following example, the fields and the constructor of the class, <ph id=\"ph1\">`CoOrds`</ph>, are declared in one partial class definition, and the member, <ph id=\"ph2\">`PrintCoOrds`</ph>, is declared in another partial class definition.","source":"In the following example, the fields and the constructor of the class, `CoOrds`, are declared in one partial class definition, and the member, `PrintCoOrds`, is declared in another partial class definition."},{"pos":[6907,6911],"content":"Code","linkify":"Code","nodes":[{"content":"Code","pos":[0,4]}]},{"pos":[6915,7055],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#17<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_9.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#17](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_9.cs)]"},{"pos":[7064,7073],"content":"Example 2","linkify":"Example 2","nodes":[{"content":"Example 2","pos":[0,9]}]},{"pos":[7083,7094],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"content":"The following example shows that you can also develop partial structs and interfaces.","pos":[7098,7183]},{"pos":[7193,7197],"content":"Code","linkify":"Code","nodes":[{"content":"Code","pos":[0,4]}]},{"pos":[7201,7342],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csProgGuideObjects#18<ept id=\"p2\">](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_10.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csProgGuideObjects#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/partial-classes-and-methods_10.cs)]"},{"pos":[7351,7366],"content":"Partial Methods","linkify":"Partial Methods","nodes":[{"content":"Partial Methods","pos":[0,15]}]},{"content":"A partial class or struct may contain a partial method.","pos":[7370,7425]},{"content":"One part of the class contains the signature of the method.","pos":[7426,7485]},{"content":"An optional implementation may be defined in the same part or another part.","pos":[7486,7561]},{"content":"If the implementation is not supplied, then the method and all calls to the method are removed at compile time.","pos":[7562,7673]},{"content":"Partial methods enable the implementer of one part of a class to define a method, similar to an event.","pos":[7680,7782]},{"content":"The implementer of the other part of the class can decide whether to implement the method or not.","pos":[7783,7880]},{"content":"If the method is not implemented, then the compiler removes the method signature and all calls to the method.","pos":[7881,7990]},{"content":"The calls to the method, including any results that would occur from evaluation of arguments in the calls, have no effect at run time.","pos":[7991,8125]},{"content":"Therefore, any code in the partial class can freely use a partial method, even if the implementation is not supplied.","pos":[8126,8243]},{"content":"No compile-time or run-time errors will result if the method is called but not implemented.","pos":[8244,8335]},{"content":"Partial methods are especially useful as a way to customize generated code.","pos":[8342,8417]},{"content":"They allow for a method name and signature to be reserved, so that generated code can call the method but the developer can decide whether to implement the method.","pos":[8418,8581]},{"content":"Much like partial classes, partial methods enable code created by a code generator and code created by a human developer to work together without run-time costs.","pos":[8582,8743]},{"content":"A partial method declaration consists of two parts: the definition, and the implementation.","pos":[8750,8841]},{"content":"These may be in separate parts of a partial class, or in the same part.","pos":[8842,8913]},{"content":"If there is no implementation declaration, then the compiler optimizes away both the defining declaration and all calls to the method.","pos":[8914,9048]},{"pos":[9226,9451],"content":"Partial method declarations must begin with the contextual keyword <bpt id=\"p1\">[</bpt>partial<ept id=\"p1\">](../../../csharp/language-reference/keywords/partial-type.md)</ept> and the method must return <bpt id=\"p2\">[</bpt>void<ept id=\"p2\">](../../../csharp/language-reference/keywords/void.md)</ept>.","source":"Partial method declarations must begin with the contextual keyword [partial](../../../csharp/language-reference/keywords/partial-type.md) and the method must return [void](../../../csharp/language-reference/keywords/void.md)."},{"pos":[9461,9621],"content":"Partial methods can have <bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](../../../csharp/language-reference/keywords/ref.md)</ept> but not <bpt id=\"p2\">[</bpt>out<ept id=\"p2\">](../../../csharp/language-reference/keywords/out.md)</ept> parameters.","source":"Partial methods can have [ref](../../../csharp/language-reference/keywords/ref.md) but not [out](../../../csharp/language-reference/keywords/out.md) parameters."},{"pos":[9631,9824],"content":"Partial methods are implicitly <bpt id=\"p1\">[</bpt>private<ept id=\"p1\">](../../../csharp/language-reference/keywords/private.md)</ept>, and therefore they cannot be <bpt id=\"p2\">[</bpt>virtual<ept id=\"p2\">](../../../csharp/language-reference/keywords/virtual.md)</ept>.","source":"Partial methods are implicitly [private](../../../csharp/language-reference/keywords/private.md), and therefore they cannot be [virtual](../../../csharp/language-reference/keywords/virtual.md)."},{"pos":[9834,10011],"content":"Partial methods cannot be <bpt id=\"p1\">[</bpt>extern<ept id=\"p1\">](../../../csharp/language-reference/keywords/extern.md)</ept>, because the presence of the body determines whether they are defining or implementing.","source":"Partial methods cannot be [extern](../../../csharp/language-reference/keywords/extern.md), because the presence of the body determines whether they are defining or implementing."},{"pos":[10021,10188],"content":"Partial methods can have <bpt id=\"p1\">[</bpt>static<ept id=\"p1\">](../../../csharp/language-reference/keywords/static.md)</ept> and <bpt id=\"p2\">[</bpt>unsafe<ept id=\"p2\">](../../../csharp/language-reference/keywords/unsafe.md)</ept> modifiers.","source":"Partial methods can have [static](../../../csharp/language-reference/keywords/static.md) and [unsafe](../../../csharp/language-reference/keywords/unsafe.md) modifiers."},{"content":"Partial methods can be generic.","pos":[10198,10229]},{"content":"Constraints are put on the defining partial method declaration, and may optionally be repeated on the implementing one.","pos":[10230,10349]},{"content":"Parameter and type parameter names do not have to be the same in the implementing declaration as in the defining one.","pos":[10350,10467]},{"pos":[10477,10674],"content":"You can make a <bpt id=\"p1\">[</bpt>delegate<ept id=\"p1\">](../../../csharp/language-reference/keywords/delegate.md)</ept> to a partial method that has been defined and implemented, but not to a partial method that has only been defined.","source":"You can make a [delegate](../../../csharp/language-reference/keywords/delegate.md) to a partial method that has been defined and implemented, but not to a partial method that has only been defined."},{"pos":[10683,10708],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[10822,10830],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[10834,10901],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Classes<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/classes.md)</ept><ph id=\"ph1\"> </ph>","pos":[10904,10981],"source":" [Classes](../../../csharp/programming-guide/classes-and-structs/classes.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Structs<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/structs.md)</ept><ph id=\"ph1\"> </ph>","pos":[10984,11061],"source":" [Structs](../../../csharp/programming-guide/classes-and-structs/structs.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Interfaces<ept id=\"p1\">](../../../csharp/programming-guide/interfaces/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[11064,11133],"source":" [Interfaces](../../../csharp/programming-guide/interfaces/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>partial (Type)<ept id=\"p1\">](../../../csharp/language-reference/keywords/partial-type.md)</ept>","pos":[11136,11214],"source":" [partial (Type)](../../../csharp/language-reference/keywords/partial-type.md)"}]}