<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="durable-instance-context.md" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-3be5d15" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bc3952eabd048d5b1142fc45c91bd404ad203277</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\samples\durable-instance-context.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2a89b324f8c5943d5c9806f669e36f1e95c7488d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2f9a4432515afa5788c1683c14164a642950a7d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Durable Instance Context | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Durable Instance Context</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This sample demonstrates how to customize the <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> runtime to enable durable instance contexts.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>It uses SQL Server 2005 as its backing store (SQL Server 2005 Express in this case).</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, it also provides a way to access custom storage mechanisms.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The setup procedure and build instructions for this sample are located at the end of this topic.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This sample involves extending both the channel layer and the service model layer of the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Therefore it is necessary to understand the underlying concepts before going into the implementation details.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Durable instance contexts can be found in the real world scenarios quite often.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>A shopping cart application for example, has the ability to pause shopping halfway through and continue it on another day.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>So that when we visit the shopping cart the next day, our original context is restored.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>It is important to note that the shopping cart application (on the server) does not maintain the shopping cart instance while we are disconnected.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Instead, it persists its state into a durable storage media and uses it when constructing a new instance for the restored context.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Therefore the service instance that may service for the same context is not the same as the previous instance (that is, it does not have the same memory address).</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Durable instance context is made possible by a small protocol that exchanges a context ID between the client and service.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This context ID is created on the client and transmitted to the service.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When the service instance is created, the service runtime tries to load the persisted state that corresponds to this context ID from a persistent storage (by default it is a SQL Server 2005 database).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If no state is available the new instance has its default state.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The service implementation uses a custom attribute to mark operations that change the state of the service implementation so that the runtime can save the service instance after invoking them.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>By the previous description, two steps can easily be distinguished to achieve the goal:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Change the message that goes on the wire to carry the context ID.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Change the service local behavior to implement custom instancing logic.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Because the first one in the list affects the messages on the wire it should be implemented as a custom channel and be hooked up to the channel layer.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The latter only affects the service local behavior and therefore can be implemented by extending several service extensibility points.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In the next few sections, each of these extensions are discussed.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Durable InstanceContext Channel</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The first thing to look at is a channel layer extension.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The first step in writing a custom channel is to decide the communication structure of the channel.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>As a new wire protocol is being introduced the channel should work with almost any other channel in the channel stack.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Therefore it should support all the message exchange patterns.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>However, the core functionality of the channel is the same regardless of its communication structure.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>More specifically, from the client it should write the context ID to the messages and from the service it should read this context ID from the messages and pass it to the upper levels.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Because of that, a <ph id="ph1">`DurableInstanceContextChannelBase`</ph> class is created that acts as the abstract base class for all durable instance context channel implementations.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This class contains the common state machine management functions and two protected members to apply and read the context information to and from messages.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>These two methods make use of <ph id="ph1">`IContextManager`</ph> implementations to write and read the context ID to or from the message.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">`IContextManager`</ph> is a custom interface used to define the contract for all context managers.) The channel can either include the context ID in a custom SOAP header or in a HTTP cookie header.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Each context manager implementation inherits from the <ph id="ph1">`ContextManagerBase`</ph> class that contains the common functionality for all context managers.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`GetContextId`</ph> method in this class is used to originate the context ID from the client.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When a context ID is originated for the first time, this method saves it into a text file whose name is constructed by the remote endpoint address (the invalid file name characters in the typical URIs are replaced with @ characters).</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Later when the context ID is required for the same remote endpoint, it checks whether an appropriate file exists.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If it does, it reads the context ID and returns.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Otherwise it returns a newly generated context ID and saves it to a file.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>With the default configuration, these files are placed in a directory called ContextStore, which resides in the current user’s temp directory.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>However this location is configurable using the binding element.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The mechanism used to transport the context ID is configurable.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>It could be either written to the HTTP cookie header or to a custom SOAP header.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The custom SOAP header approach makes it possible to use this protocol with non-HTTP protocols (for example, TCP or Named Pipes).</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There are two classes, namely <ph id="ph1">`MessageHeaderContextManager`</ph> and <ph id="ph2">`HttpCookieContextManager`</ph>, which implement these two options.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Both of them write the context ID to the message appropriately.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`MessageHeaderContextManager`</ph> class writes it to a SOAP header in the <ph id="ph2">`WriteContext`</ph> method.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Both the <ph id="ph1">`ApplyContext`</ph> and <ph id="ph2">`ReadContextId`</ph> methods in the <ph id="ph3">`DurableInstanceContextChannelBase`</ph> class invoke the <ph id="ph4">`IContextManager.ReadContext`</ph> and <ph id="ph5">`IContextManager.WriteContext`</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>However, these context managers are not directly created by the <ph id="ph1">`DurableInstanceContextChannelBase`</ph> class.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Instead it uses the <ph id="ph1">`ContextManagerFactory`</ph> class to do that job.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ApplyContext`</ph> method is invoked by the sending channels.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It injects the context ID to the outgoing messages.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ReadContextId`</ph> method is invoked by the receiving channels.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This method ensures that the context ID is available in the incoming messages and adds it to the <ph id="ph1">`Properties`</ph> collection of the <ph id="ph2">`Message`</ph> class.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>It also throws a <ph id="ph1">`CommunicationException`</ph> in case of a failure to read the context ID and thus causes the channel to be aborted.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Before proceeding, it is important to understand the usage of the <ph id="ph1">`Properties`</ph> collection in the <ph id="ph2">`Message`</ph> class.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Typically, this <ph id="ph1">`Properties`</ph> collection is used when passing data from lower to the upper levels from the channel layer.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This way the desired data can be provided to the upper levels in a consistent manner regardless of the protocol details.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>In other words, the channel layer can send and receive the context ID either as a SOAP header or a HTTP cookie header.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>But it is not necessary for the upper levels to know about these details because the channel layer makes this information available in the <ph id="ph1">`Properties`</ph> collection.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Now with the <ph id="ph1">`DurableInstanceContextChannelBase`</ph> class in place all ten of the necessary interfaces (IOutputChannel, IInputChannel, IOutputSessionChannel, IInputSessionChannel, IRequestChannel, IReplyChannel, IRequestSessionChannel, IReplySessionChannel, IDuplexChannel, IDuplexSessionChannel) must be implemented.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>They resemble every available message exchange pattern (datagram, simplex, duplex and their sessionful variants).</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Each of these implementations inherit the base class previously described and calls <ph id="ph1">`ApplyContext`</ph> and <ph id="ph2">`ReadContexId`</ph> appropriately.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">`DurableInstanceContextOutputChannel`</ph> - which implements the IOutputChannel interface - calls the <ph id="ph2">`ApplyContext`</ph> method from each method that sends the messages.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>On the other hand, <ph id="ph1">`DurableInstanceContextInputChannel`</ph> - which implements the <ph id="ph2">`IInputChannel`</ph> interface - calls the <ph id="ph3">`ReadContextId`</ph> method in each method which receives the messages.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Apart from this, these channel implementations delegate the method invocations to the channel below them in the channel stack.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>However, sessionful variants have a basic logic to make sure that the context ID is sent and is read only for the first message that causes the session to be created.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>These channel implementations are then added to the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> channel runtime by the <ph id="ph2">`DurableInstanceContextBindingElement`</ph> class and <ph id="ph3">`DurableInstanceContextBindingElementSection`</ph> class appropriately.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>See the <bpt id="p1">[</bpt>HttpCookieSession<ept id="p1">](../../../../docs/framework/wcf/samples/httpcookiesession.md)</ept> channel sample documentation for more details about binding elements and binding element sections.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Service Model Layer Extensions</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Now that the context ID has traveled through the channel layer, the service behavior can be implemented to customize the instantiation.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In this sample, a storage manager is used to load and save state from or to the persistent store.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>As explained previously, this sample provides a storage manager that uses SQL Server 2005 as its backing store.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, it is also possible to add custom storage mechanisms to this extension.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To do that a public interface is declared, which must be implemented by all storage managers.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SqlServerStorageManager`</ph> class contains the default <ph id="ph2">`IStorageManager`</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In its <ph id="ph1">`SaveInstance`</ph> method the given object is serialized using the XmlSerializer and is saved to the SQL Server database.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`GetInstance`</ph> method the serialized data is read for a given context ID and the object constructed from it is returned to the caller.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Users of these storage managers are not supposed to instantiate them directly.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>They use the <ph id="ph1">`StorageManagerFactory`</ph> class, which abstracts from the storage manager creation details.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This class has one static member, <ph id="ph1">`GetStorageManager`</ph>, which creates an instance of a given storage manager type.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>If the type parameter is <ph id="ph1">`null`</ph>, this method creates an instance of the default <ph id="ph2">`SqlServerStorageManager`</ph> class and returns it.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>It also validates the given type to make sure that it implements the <ph id="ph1">`IStorageManager`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The necessary infrastructure to read and write instances from the persistent storage is implemented.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Now the necessary steps to change the service behavior have to be taken.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>As the first step of this process we have to save the context ID, which came through the channel layer to the current InstanceContext.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>InstanceContext is a runtime component that acts as the link between the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> dispatcher and the service instance.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>It can be used to provide additional state and behavior to the service instance.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This is essential because in sessionful communication the context ID is sent only with the first message.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> allows extending its InstanceContext runtime component by adding a new state and behavior using its extensible object pattern.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The extensible object pattern is used in <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> to either extend existing runtime classes with new functionality or to add new state features to an object.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>There are three interfaces in the extensible object pattern - IExtensibleObject<ph id="ph1">\&lt;</ph>T&gt;, IExtension<ph id="ph2">\&lt;</ph>T&gt;, and IExtensionCollection<ph id="ph3">\&lt;</ph>T&gt;:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The IExtensibleObject<ph id="ph1">\&lt;</ph>T&gt; interface is implemented by objects that allow extensions that customize their functionality.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The IExtension<ph id="ph1">\&lt;</ph>T&gt; interface is implemented by objects that are extensions of classes of type T.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The IExtensionCollection<ph id="ph1">\&lt;</ph>T&gt; interface is a collection of IExtensions that allows for retrieving IExtensions by their type.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Therefore an InstanceContextExtension class should be created that implements the IExtension interface and defines the required state to save the context ID.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This class also provides the state to hold the storage manager being used.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Once the new state is saved, it should not be possible to modify it.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Therefore the state is provided and saved to the instance at the time it is being constructed and then only accessible using read-only properties.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The InstanceContextInitializer class implements the IInstanceContextInitializer interface and adds the instance context extension to the Extensions collection of the InstanceContext being constructed.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>As described earlier the context ID is read from the <ph id="ph1">`Properties`</ph> collection of the <ph id="ph2">`Message`</ph> class and passed to the constructor of the extension class.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This demonstrates how information can be exchanged between the layers in a consistent manner.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The next important step is overriding the service instance creation process.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> allows implementing custom instantiation behaviors and hooking them up to the runtime using the IInstanceProvider interface.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">`InstanceProvider`</ph> class is implemented to do that job.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In the constructor the service type expected from the instance provider is accepted.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Later this is used to create new instances.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`GetInstance`</ph> implementation an instance of a storage manager is created looking for a persisted instance.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If it returns <ph id="ph1">`null`</ph> then a new instance of the service type is instantiated and returned to the caller.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The next important step is to install the <ph id="ph1">`InstanceContextExtension`</ph>, <ph id="ph2">`InstanceContextInitializer`</ph> and <ph id="ph3">`InstanceProvider`</ph> classes into the service model runtime.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A custom attribute could be used to mark the service implementation classes to install the behavior.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DurableInstanceContextAttribute`</ph> contains the implementation for this attribute and it implements the <ph id="ph2">`IServiceBehavior`</ph> interface to extend the entire service runtime.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This class has a property that accepts the type of the storage manager to be used.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>In this way the implementation enables the users to specify their own <ph id="ph1">`IStorageManager`</ph> implementation as parameter of this attribute.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`ApplyDispatchBehavior`</ph> implementation the <ph id="ph2">`InstanceContextMode`</ph> of the current <ph id="ph3">`ServiceBehavior`</ph> attribute is being verified.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>If this property is set to Singleton, enabling durable instancing is not possible and an <ph id="ph1">`InvalidOperationException`</ph> is thrown to notify the host.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>After this the instances of the storage manager, instance context initializer, and the instance provider are created and installed in the <ph id="ph1">`DispatchRuntime`</ph> created for every endpoint.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>In summary so far, this sample has produced a channel that enabled the custom wire protocol for custom context ID exchange and it also overwrites the default instancing behavior to load the instances from the persistent storage.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>What is left is a way to save the service instance to the persistent storage.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>As discussed previously, there is already the required functionality to save the state in an <ph id="ph1">`IStorageManager`</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>We now must integrate this with the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Another attribute is required that is applicable to the methods in the service implementation class.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This attribute is supposed to be applied to the methods that change the state of the service instance.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`SaveStateAttribute`</ph> class implements this functionality.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It also implements <ph id="ph1">`IOperationBehavior`</ph> class to modify the <ph id="ph2">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime for each operation.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When a method is marked with this attribute, the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime invokes the <ph id="ph2">`ApplyBehavior`</ph> method while the appropriate <ph id="ph3">`DispatchOperation`</ph> is being constructed.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In this method implementation there is single line of code:</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This instruction creates an instance of <ph id="ph1">`OperationInvoker`</ph> type and assigns it to the <ph id="ph2">`Invoker`</ph> property of the <ph id="ph3">`DispatchOperation`</ph> being constructed.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`OperationInvoker`</ph> class is a wrapper for the default operation invoker created for the <ph id="ph2">`DispatchOperation`</ph>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>This class implements the <ph id="ph1">`IOperationInvoker`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">`Invoke`</ph> method implementation the actual method invocation is delegated to the inner operation invoker.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>However, before returning the results the storage manager in the <ph id="ph1">`InstanceContext`</ph> is used to save the service instance.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Using the Extension</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Both the channel layer and service model layer extensions are done and they can now be used in <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Services have to add the channel into the channel stack using a custom binding and then mark the service implementation classes with the appropriate attributes.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Client applications must add the DurableInstanceContextChannel into the channel stack using a custom binding.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>To configure the channel declaratively in the configuration file, the binding element section has to be added to the binding element extensions collection.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Now the binding element can be used with a custom binding just like other standard binding elements:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This sample showed how to create a custom protocol channel and how to customize the service behavior to enable it.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The extension can be further improved by letting users specify the <ph id="ph1">`IStorageManager`</ph> implementation using a configuration section.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This makes it possible to modify the backing store without recompiling the service code.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Furthermore you could try to implement a class (for example, <ph id="ph1">`StateBag`</ph>), which encapsulates the state of the instance.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>That class is responsible for persisting the state whenever it changes.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This way you can avoid using the <ph id="ph1">`SaveState`</ph> attribute and perform the persisting work more accurately (for example, you could persist the state when the state is actually changed rather than saving it each time when a method with the <ph id="ph2">`SaveState`</ph> attribute is called).</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>When you run the sample, the following output is displayed.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The client adds two items to its shopping cart and then gets the list of items in its shopping cart from the service.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Press ENTER in each console window to shut down the service and client.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Rebuilding the service overwrites the database file.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>To observe state preserved across multiple runs of the sample, be sure not to rebuild the sample between runs.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>To set up, build, and run the sample</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Ensure that you have performed the <bpt id="p1">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>To build the solution, follow the instructions in <bpt id="p1">[</bpt>Building the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id="p1">[</bpt>Running the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>You must be running SQL Server 2005 or SQL Express 2005 to run this sample.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If you are running SQL Server 2005, you must modify the configuration of the service's connection string.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When running cross-machine, SQL Server is only required on the server machine.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The samples may already be installed on your machine.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Check for the following (default) directory before continuing.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If this directory does not exist, go to <bpt id="p1">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> and <ph id="ph2">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>This sample is located in the following directory.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>