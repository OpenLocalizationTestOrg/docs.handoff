{"content":"---\ntitle: \"Safe Constructor Patterns for DependencyObjects\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"constructor patterns for dependency objects [WPF]\"\n  - \"dependency objects [WPF], constructor patterns\"\n  - \"FXCop tool [WPF]\"\nms.assetid: f704b81c-449a-47a4-ace1-9332e3cc6d60\n---\n# Safe Constructor Patterns for DependencyObjects\nGenerally, class constructors should not call callbacks such as virtual methods or delegates, because constructors can be called as base initialization of constructors for a derived class. Entering the virtual might be done at an incomplete initialization state of any given object. However, the property system itself calls and exposes callbacks internally, as part of the dependency property system. As simple an operation as setting a dependency property value with <xref:System.Windows.DependencyObject.SetValue%2A> call potentially includes a callback somewhere in the determination. For this reason, you should be careful when setting dependency property values within the body of a constructor, which can become problematic if your type is used as a base class. There is a particular pattern for implementing <xref:System.Windows.DependencyObject> constructors that avoids specific problems with dependency property states and the inherent callbacks, which is documented here.  \n\n<a name=\"Property_System_Virtual_Methods\"></a>   \n## Property System Virtual Methods  \n The following virtual methods or callbacks are potentially called during the computations of the <xref:System.Windows.DependencyObject.SetValue%2A> call that sets a dependency property value: <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.PropertyChangedCallback>, <xref:System.Windows.CoerceValueCallback>, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>. Each of these virtual methods or callbacks serves a particular purpose in expanding the versatility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system and dependency properties. For more information on how to use these virtuals to customize property value determination, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).  \n  \n### FXCop Rule Enforcement vs. Property System Virtuals  \n If you use the Microsoft tool FXCop as part of your build process, and you either derive from certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework classes calling the base constructor, or implement your own dependency properties on derived classes, you might encounter a particular FXCop rule violation. The name string for this violation is:  \n  \n `DoNotCallOverridableMethodsInConstructors`  \n  \n This is a rule that is part of the default public rule set for FXCop. What this rule might be reporting is a trace through the dependency property system that eventually calls a dependency property system virtual method. This rule violation might continue to appear even after following the recommended constructor patterns documented in this topic, so you might need to disable or suppress that rule in your FXCop rule set configuration.  \n  \n### Most Issues Come From Deriving Classes, Not Using Existing Classes  \n The issues reported by this rule occur when a class that you implement with virtual methods in its construction sequence is then derived from. If you seal your class, or otherwise know or enforce that your class will not be derived from, the considerations explained here and the issues that motivated the FXCop rule do not apply to you. However, if you are authoring classes in such a way that they are intended to be used as base classes, for instance if you are creating templates, or an expandable control library set, you should follow the patterns recommended here for constructors.  \n  \n### Default Constructors Must Initialize All Values Requested By Callbacks  \n Any instance members that are used by your class overrides or callbacks (the callbacks from the list in the Property System Virtuals section) must be initialized in your class default constructor, even if some of those values are filled by \"real\" values through parameters of the nondefault constructors.  \n  \n The following example code (and subsequent examples) is a pseudo-C# example that violates this rule and explains the problem:  \n  \n```  \npublic class MyClass : DependencyObject  \n{  \n    public MyClass() {}  \n    public MyClass(object toSetWobble)  \n        : this()  \n    {  \n        Wobble = toSetWobble; //this is backed by a DependencyProperty  \n        _myList = new ArrayList();    // this line should be in the default ctor  \n    }  \n    public static readonly DependencyProperty WobbleProperty =   \n        DependencyProperty.Register(\"Wobble\", typeof(object), typeof(MyClass));  \n    public object Wobble  \n    {  \n        get { return GetValue(WobbleProperty); }  \n        set { SetValue(WobbleProperty, value); }  \n    }  \n    protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)  \n    {  \n        int count = _myList.Count;    // null-reference exception  \n    }  \n    private ArrayList _myList;  \n}  \n```  \n  \n When application code calls `new MyClass(objectvalue)`, this calls the default constructor and base class constructors. Then it sets `Property1 = object1`, which calls the virtual method `OnPropertyChanged` on the owning `MyClass` <xref:System.Windows.DependencyObject>.  The override refers to `_myList`, which has not been initialized yet.  \n  \n One way to avoid these issues is to make sure that callbacks use only other dependency properties, and that each such dependency property has an established default value as part of its registered metadata.  \n  \n<a name=\"Safe_Constructor_Patterns\"></a>   \n## Safe Constructor Patterns  \n To avoid the risks of incomplete initialization if your class is used as a base class, follow these patterns:  \n  \n#### Default constructors calling base initialization  \n Implement these constructors calling the base default:  \n  \n```  \npublic MyClass : SomeBaseClass {  \n    public MyClass() : base() {  \n        // ALL class initialization, including initial defaults for   \n        // possible values that other ctors specify or that callbacks need.  \n    }  \n}  \n```  \n  \n#### Non-default (convenience) constructors, not matching any base signatures  \n If these constructors use the parameters to set dependency properties in the initialization, first call your own class default constructor for initialization, and then use the parameters to set dependency properties. These could either be dependency properties defined by your class, or dependency properties inherited from base classes, but in either case use the following pattern:  \n  \n```  \npublic MyClass : SomeBaseClass {  \n    public MyClass(object toSetProperty1) : this() {  \n        // Class initialization NOT done by default.  \n        // Then, set properties to values as passed in ctor parameters.  \n        Property1 = toSetProperty1;  \n    }  \n}  \n```  \n  \n#### Non-default (convenience) constructors, which do match base signatures  \n Instead of calling the base constructor with the same parameterization, again call your own class' default constructor. Do not call the base initializer; instead you should call `this()`. Then reproduce the original constructor behavior by using the passed parameters as values for setting the relevant properties. Use the original base constructor documentation for guidance in determining the properties that the particular parameters are intended to set:  \n  \n```  \npublic MyClass : SomeBaseClass {  \n    public MyClass(object toSetProperty1) : this() {  \n        // Class initialization NOT done by default.  \n        // Then, set properties to values as passed in ctor parameters.  \n        Property1 = toSetProperty1;  \n    }  \n}  \n```  \n  \n#### Must match all signatures  \n For cases where the base type has multiple signatures, you must deliberately match all possible signatures with a constructor implementation of your own that uses the recommended pattern of calling the class default constructor before setting further properties.  \n  \n#### Setting dependency properties with SetValue  \n These same patterns apply if you are setting a property that does not have a wrapper for property setting convenience, and set values with <xref:System.Windows.DependencyObject.SetValue%2A>. Your calls to <xref:System.Windows.DependencyObject.SetValue%2A> that pass through constructor parameters should also call the class' default constructor for initialization.  \n  \n## See also\n\n- [Custom Dependency Properties](custom-dependency-properties.md)\n- [Dependency Properties Overview](dependency-properties-overview.md)\n- [Dependency Property Security](dependency-property-security.md)\n","nodes":[{"pos":[4,285],"embed":true,"restype":"x-metadata","content":"title: \"Safe Constructor Patterns for DependencyObjects\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"constructor patterns for dependency objects [WPF]\"\n  - \"dependency objects [WPF], constructor patterns\"\n  - \"FXCop tool [WPF]\"\nms.assetid: f704b81c-449a-47a4-ace1-9332e3cc6d60","nodes":[{"content":"Safe Constructor Patterns for DependencyObjects","nodes":[{"pos":[0,47],"content":"Safe Constructor Patterns for DependencyObjects","nodes":[{"content":"Safe Constructor Patterns for DependencyObjects","pos":[0,47]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[292,339],"content":"Safe Constructor Patterns for DependencyObjects","linkify":"Safe Constructor Patterns for DependencyObjects","nodes":[{"content":"Safe Constructor Patterns for DependencyObjects","pos":[0,47]}]},{"content":"Generally, class constructors should not call callbacks such as virtual methods or delegates, because constructors can be called as base initialization of constructors for a derived class.","pos":[340,528]},{"content":"Entering the virtual might be done at an incomplete initialization state of any given object.","pos":[529,622]},{"content":"However, the property system itself calls and exposes callbacks internally, as part of the dependency property system.","pos":[623,741]},{"content":"As simple an operation as setting a dependency property value with <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> call potentially includes a callback somewhere in the determination.","pos":[742,928],"source":" As simple an operation as setting a dependency property value with <xref:System.Windows.DependencyObject.SetValue%2A> call potentially includes a callback somewhere in the determination."},{"content":"For this reason, you should be careful when setting dependency property values within the body of a constructor, which can become problematic if your type is used as a base class.","pos":[929,1108]},{"content":"There is a particular pattern for implementing <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> constructors that avoids specific problems with dependency property states and the inherent callbacks, which is documented here.","pos":[1109,1323],"source":" There is a particular pattern for implementing <xref:System.Windows.DependencyObject> constructors that avoids specific problems with dependency property states and the inherent callbacks, which is documented here."},{"pos":[1380,1411],"content":"Property System Virtual Methods","linkify":"Property System Virtual Methods","nodes":[{"content":"Property System Virtual Methods","pos":[0,31]}]},{"content":"The following virtual methods or callbacks are potentially called during the computations of the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> call that sets a dependency property value: <ph id=\"ph2\">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>.","pos":[1415,1802],"source":"The following virtual methods or callbacks are potentially called during the computations of the <xref:System.Windows.DependencyObject.SetValue%2A> call that sets a dependency property value: <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.PropertyChangedCallback>, <xref:System.Windows.CoerceValueCallback>, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>."},{"content":"Each of these virtual methods or callbacks serves a particular purpose in expanding the versatility of the <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> property system and dependency properties.","pos":[1803,2032],"source":" Each of these virtual methods or callbacks serves a particular purpose in expanding the versatility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system and dependency properties."},{"content":"For more information on how to use these virtuals to customize property value determination, see <bpt id=\"p1\">[</bpt>Dependency Property Callbacks and Validation<ept id=\"p1\">](dependency-property-callbacks-and-validation.md)</ept>.","pos":[2033,2226],"source":" For more information on how to use these virtuals to customize property value determination, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md)."},{"pos":[2236,2287],"content":"FXCop Rule Enforcement vs. Property System Virtuals","linkify":"FXCop Rule Enforcement vs. Property System Virtuals","nodes":[{"content":"FXCop Rule Enforcement vs. Property System Virtuals","pos":[0,51]}]},{"content":"If you use the Microsoft tool FXCop as part of your build process, and you either derive from certain <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> framework classes calling the base constructor, or implement your own dependency properties on derived classes, you might encounter a particular FXCop rule violation.","pos":[2291,2641],"source":"If you use the Microsoft tool FXCop as part of your build process, and you either derive from certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework classes calling the base constructor, or implement your own dependency properties on derived classes, you might encounter a particular FXCop rule violation."},{"content":"The name string for this violation is:","pos":[2642,2680]},{"content":"This is a rule that is part of the default public rule set for FXCop.","pos":[2737,2806]},{"content":"What this rule might be reporting is a trace through the dependency property system that eventually calls a dependency property system virtual method.","pos":[2807,2957]},{"content":"This rule violation might continue to appear even after following the recommended constructor patterns documented in this topic, so you might need to disable or suppress that rule in your FXCop rule set configuration.","pos":[2958,3175]},{"pos":[3185,3251],"content":"Most Issues Come From Deriving Classes, Not Using Existing Classes","linkify":"Most Issues Come From Deriving Classes, Not Using Existing Classes","nodes":[{"content":"Most Issues Come From Deriving Classes, Not Using Existing Classes","pos":[0,66]}]},{"content":"The issues reported by this rule occur when a class that you implement with virtual methods in its construction sequence is then derived from.","pos":[3255,3397]},{"content":"If you seal your class, or otherwise know or enforce that your class will not be derived from, the considerations explained here and the issues that motivated the FXCop rule do not apply to you.","pos":[3398,3592]},{"content":"However, if you are authoring classes in such a way that they are intended to be used as base classes, for instance if you are creating templates, or an expandable control library set, you should follow the patterns recommended here for constructors.","pos":[3593,3843]},{"pos":[3853,3923],"content":"Default Constructors Must Initialize All Values Requested By Callbacks","linkify":"Default Constructors Must Initialize All Values Requested By Callbacks","nodes":[{"content":"Default Constructors Must Initialize All Values Requested By Callbacks","pos":[0,70]}]},{"content":"Any instance members that are used by your class overrides or callbacks (the callbacks from the list in the Property System Virtuals section) must be initialized in your class default constructor, even if some of those values are filled by \"real\" values through parameters of the nondefault constructors.","pos":[3927,4231]},{"content":"The following example code (and subsequent examples) is a pseudo-C# example that violates this rule and explains the problem:","pos":[4238,4363]},{"content":"When application code calls <ph id=\"ph1\">`new MyClass(objectvalue)`</ph>, this calls the default constructor and base class constructors.","pos":[5189,5308],"source":"When application code calls `new MyClass(objectvalue)`, this calls the default constructor and base class constructors."},{"content":"Then it sets <ph id=\"ph1\">`Property1 = object1`</ph>, which calls the virtual method <ph id=\"ph2\">`OnPropertyChanged`</ph> on the owning <ph id=\"ph3\">`MyClass`</ph> <ph id=\"ph4\">&lt;xref:System.Windows.DependencyObject&gt;</ph>.","pos":[5309,5459],"source":" Then it sets `Property1 = object1`, which calls the virtual method `OnPropertyChanged` on the owning `MyClass` <xref:System.Windows.DependencyObject>."},{"content":"The override refers to <ph id=\"ph1\">`_myList`</ph>, which has not been initialized yet.","pos":[5461,5530],"source":"  The override refers to `_myList`, which has not been initialized yet."},{"content":"One way to avoid these issues is to make sure that callbacks use only other dependency properties, and that each such dependency property has an established default value as part of its registered metadata.","pos":[5537,5743]},{"pos":[5796,5821],"content":"Safe Constructor Patterns","linkify":"Safe Constructor Patterns","nodes":[{"content":"Safe Constructor Patterns","pos":[0,25]}]},{"content":"To avoid the risks of incomplete initialization if your class is used as a base class, follow these patterns:","pos":[5825,5934]},{"pos":[5945,5993],"content":"Default constructors calling base initialization","linkify":"Default constructors calling base initialization","nodes":[{"content":"Default constructors calling base initialization","pos":[0,48]}]},{"content":"Implement these constructors calling the base default:","pos":[5997,6051]},{"pos":[6307,6379],"content":"Non-default (convenience) constructors, not matching any base signatures","linkify":"Non-default (convenience) constructors, not matching any base signatures","nodes":[{"content":"Non-default (convenience) constructors, not matching any base signatures","pos":[0,72]}]},{"content":"If these constructors use the parameters to set dependency properties in the initialization, first call your own class default constructor for initialization, and then use the parameters to set dependency properties.","pos":[6383,6599]},{"content":"These could either be dependency properties defined by your class, or dependency properties inherited from base classes, but in either case use the following pattern:","pos":[6600,6766]},{"pos":[7061,7131],"content":"Non-default (convenience) constructors, which do match base signatures","linkify":"Non-default (convenience) constructors, which do match base signatures","nodes":[{"content":"Non-default (convenience) constructors, which do match base signatures","pos":[0,70]}]},{"content":"Instead of calling the base constructor with the same parameterization, again call your own class' default constructor.","pos":[7135,7254]},{"content":"Do not call the base initializer; instead you should call <ph id=\"ph1\">`this()`</ph>.","pos":[7255,7322],"source":" Do not call the base initializer; instead you should call `this()`."},{"content":"Then reproduce the original constructor behavior by using the passed parameters as values for setting the relevant properties.","pos":[7323,7449]},{"content":"Use the original base constructor documentation for guidance in determining the properties that the particular parameters are intended to set:","pos":[7450,7592]},{"pos":[7887,7912],"content":"Must match all signatures","linkify":"Must match all signatures","nodes":[{"content":"Must match all signatures","pos":[0,25]}]},{"content":"For cases where the base type has multiple signatures, you must deliberately match all possible signatures with a constructor implementation of your own that uses the recommended pattern of calling the class default constructor before setting further properties.","pos":[7916,8178]},{"pos":[8189,8232],"content":"Setting dependency properties with SetValue","linkify":"Setting dependency properties with SetValue","nodes":[{"content":"Setting dependency properties with SetValue","pos":[0,43]}]},{"content":"These same patterns apply if you are setting a property that does not have a wrapper for property setting convenience, and set values with <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>.","pos":[8236,8426],"source":"These same patterns apply if you are setting a property that does not have a wrapper for property setting convenience, and set values with <xref:System.Windows.DependencyObject.SetValue%2A>."},{"content":"Your calls to <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> that pass through constructor parameters should also call the class' default constructor for initialization.","pos":[8427,8600],"source":" Your calls to <xref:System.Windows.DependencyObject.SetValue%2A> that pass through constructor parameters should also call the class' default constructor for initialization."},{"pos":[8609,8617],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8621,8684],"content":"<bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](custom-dependency-properties.md)</ept>","source":"[Custom Dependency Properties](custom-dependency-properties.md)"},{"pos":[8687,8754],"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>","source":"[Dependency Properties Overview](dependency-properties-overview.md)"},{"pos":[8757,8820],"content":"<bpt id=\"p1\">[</bpt>Dependency Property Security<ept id=\"p1\">](dependency-property-security.md)</ept>","source":"[Dependency Property Security](dependency-property-security.md)"}]}