{"content":"---\ntitle: Pattern Matching | C# Guide\ndescription: Learn about pattern matching expressions in C#\nkeywords: .NET, .NET Core, C#\nms.date: 01/24/2017\nms.author: wiwagn\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b\n---\n\n# Pattern Matching #\n\nPatterns test that a value has a certain *shape*, and can *extract*\ninformation from the value when it has the matching shape. Pattern\nmatching provides more concise syntax for algorithms you already use\ntoday. You already create pattern matching algorithms using existing\nsyntax. You write `if` or `switch` statements that test values. Then,\nwhen those statements match, you extract and use information from that\nvalue. The new syntax elements are extensions to statements you are already\nfamiliar with: `is` and `switch`. These new extensions combine testing\na value and extracting that information.\n\nIn this topic, we'll look at the new syntax to show you how it enables\nreadable, concise code. Pattern matching enables idioms where data and\nthe code are separated, unlike object oriented designs where data \nand the methods that manipulate them are tightly coupled.\n\nTo illustrate these new idioms, let's work with structures that represent\ngeometric shapes using pattern matching statements. You are probably\nfamiliar with building class hierarchies and creating\n[virtual methods and overridden methods](methods.md#inherited) to\ncustomize object behavior based on the runtime type of the object.\n\nThose techniques aren't possible for data that isn't structured in a class\nhierarchy. When data and methods are separate, you need other tools. The new\n*pattern matching* constructs enable cleaner syntax to examine data\nand manipulate control flow based on any condition of that data. You already\nwrite `if` statements and `switch` that test a variable's value. You write `is`\nstatements that test a variable's type. *Pattern matching* adds new capabilities\nto those statements.\n\nIn this topic, you'll build a method  that computes the area of\ndifferent geometric shapes. But, you'll do it without resorting to object\noriented techniques and building a class hierarchy for the different shapes.\nYou'll use *pattern matching* instead. To further emphasize that we're not\nusing inheritance, you'll make each shape a `struct` instead of a class. \nNote that different `struct` types cannot specify a common user defined\nbase type, so inheritance is not a possible design.\nAs you go through this sample, contrast this code with how it would\nbe structured as an object hierarchy. When the data you must\nquery and manipulate is not a class hierarchy, pattern matching enables\nvery elegant designs.\n\nRather than starting with an abstract shape definition and adding different\nspecific shape classes, let's start instead with simple data only definitions\nfor each of the geometric shapes:\n\n[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions \"Shape definitions\")]\n\nFrom these structures, let's write a method that computes the area\nof some shape.\n\n## The `is` type pattern expression\n\nBefore C# 7, you'd need to test each type in a series of `if` and `is`\nstatements:\n\n[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression \"Classic type pattern using is\")]\n\nThat code above is a classic expression of the *type pattern*: You're testing a variable\nto determine its type and taking a different action based on that type.\n\nThis code becomes simpler using extensions to the `is` expression to assign\na variable if the test succeeds:\n\n[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression \"is pattern expression\")]\n\nIn this updated version, the `is` expression both tests the variable and assigns\nit to a new variable of the proper type. Also, notice that this version includes\nthe `Rectangle` type, which is a `struct`. The new `is` expression works with\nvalue types as well as reference types.\n\nLanguage rules for pattern matching expressions help you avoid misusing\nthe results of a match expression. In the example above, the variables `s`,\n `c`, and `r` are only in scope and definitely assigned when the respective\npattern match expressions have `true` results. If you try to use either\nvariable in another location, your code generates compiler errors.\n\nLet's examine both of those rules in detail, beginning with scope. The variable\n`c` is in scope only in the `else` branch of the first `if` statement. The variable\n`s` is in scope in the method `ComputeArea`. That's because each \nbranch of an `if` statement establishes a separate scope for variables. However, the `if` statement\nitself does not. That means variables declared in the `if` statement are in the\nsame scope as the `if` statement (the method in this case.) This behavior is not\nspecific to pattern matching, but is the defined behavior for variable scopes \nand `if` and `else` statements.\n\nThe variables `c` and `s` are assigned when the respective `if` statements are true\nbecause of the definitely assigned when true mechanism.\n\n> [!TIP]\n> The samples in this topic use the recommended construct where\n> a pattern match `is` expression definitely assigns the match\n> variable in the `true` branch of the `if` statement.\n> You could reverse the logic by saying `if (!(shape is Square s))`\n> and the variable `s` would be definitely assigned only in the\n> `false` branch. While this is valid C#, it is not recommended\n> because it is more confusing to follow the logic.\n\nThese rules mean that you are unlikely to accidentally access the result\nof a pattern match expression when that pattern was not met.\n\n## Using pattern matching `switch` statements\n\nAs time goes on, you may need to support other shape types. As the number\nof conditions you are testing grows, you'll find that using the `is` pattern\nmatching expressions can become cumbersome. In addition to requiring `if`\nstatements on each type you want to check, the `is` expressions are limited\nto testing if the input matches a single type. In this case, you'll find that the `switch` pattern\nmatching expressions becomes a better choice. \n\nThe traditional `switch`\nstatement was a pattern expression: it supported the constant pattern.\nYou could compare a variable to any constant used in a `case` statement:\n\n[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch \"Classic switch statement\")]\n\nThe only pattern supported by the `switch` statement was the constant\npattern. It was further limited to numeric types and the `string` type.\nThose restrictions have been removed, and you can now write a `switch`\nstatement using the type pattern:\n\n[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern \"Compute with `switch` expression\")]\n\nThe pattern matching `switch` statement uses familiar syntax to developers\nwho have used the traditional C-style `switch` statement. Each `case` is evaluated\nand the code beneath the condition that matches the input variable is\nexecuted. Code execution cannot \"fall through\" from one case expression\nto the next; the syntax of the `case` statement requires that each `case`\nend with a `break`, `return`, or `goto`.\n\n> [!NOTE]\n> The `goto` statements to jump to another label are valid only\n> for the constant pattern, the classic switch statement.\n\nThere are important new rules governing the `switch` statement. The restrictions\non the type of the variable in the `switch` expression have been removed.\nAny type, such as `object` in this example, may be used. The case expressions\nare no longer limited to constant values. Removing that limitation means\nthat reordering `switch` sections may change a program's behavior.\n\nWhen limited to constant values, no more than one `case`\nlabel could match the value of the `switch` expression. Combine that with the \nrule that every `switch` section must not fall through to the next section, and \nit followed that the\n`switch` sections could be rearranged in any order without affecting behavior.\nNow, with more generalized `switch` expressions, the order of each section\nmatters. The `switch` expressions are evaluated in textual order. Execution\ntransfers to the first `switch` label that matches the `switch` expression.  \nNote that the `default` case will only be executed if no other\ncase labels match. The `default` case is evaluated last, regardless\nof its textual order. If there is no `default` case, and none of the\nother `case` statements match, execution continues at the statement\nfollowing the `switch` statement. None of the `case` labels code is\nexecuted.\n\n## `when` clauses in `case` expressions\n\nYou can make special cases for those shapes that have 0 area by using\na `when` clause on the `case` label. A square with a side length of 0, or\na circle with a radius of 0 has a 0 area. You specify that condition\nusing a `when` clause on the `case` label:  \n\n[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes \"Compute shapes with 0 area\")]\n\nThis change demonstrates a few important points about the new syntax. First,\nmultiple `case` labels can be applied to one `switch` section. The statement\nblock is executed when any of those labels is `true`. In this instance,\nif the `switch` expression is either a circle or a square with 0 area, the\nmethod returns the constant 0.\n\nThis example introduces two different variables in the two `case` labels\nfor the first `switch` block. Notice that the statements in this `switch` block\ndo not use either the variables `c` (for the circle) or `s` (for the square).\nNeither of those variables is definitely assigned in this `switch` block.\nIf either of these cases match, clearly one of the variables has been assigned.\nHowever, it is impossible to tell *which* has been assigned at compile-time,\nbecause either case could match at runtime. For that reason,\nmost times when you use multiple `case` labels for the same block, you won't\nintroduce a new variable in the `case` statement, or you will only use the\nvariable in the `when` clause.\n\nHaving added those shapes with 0 area, let's add a couple more shape types:\na rectangle and a triangle:\n\n[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle \"Add rectangle and triangle\")]\n\n This set of changes adds `case` labels for the degenerate case, and labels\n and blocks for each of the new shapes. \n\nFinally, you can add a `null` case to ensure the argument is not `null`:\n\n[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase \"Add null case\")]\n\nThe special case for the `null` pattern is interesting because the constant `null` does\nnot have a type, but can be converted to any reference type or nullable\ntype. \n\n## Conclusions\n\n*Pattern Matching constructs* enable you to easily manage control flow\namong different variables and types that are not related by an inheritance\nhierarchy. You can also control logic to use any condition you test on\nthe variable. It enables patterns and idioms that you'll need more often\nas you build more distributed applications, where data and the methods that\nmanipulate that data are separate. You'll notice that the shape structs\nused in this sample do not contain any methods, just read-only properties.\nPattern Matching works with any data type. You write expressions that examine\nthe object, and make control flow decisions based on those conditions.\n\nCompare the code from this sample with the design that would follow from\ncreating a class hierarchy for an abstract `Shape` and specific derived\nshapes each with their own implementation of a virtual method to calculate\nthe area. You'll often find that pattern matching expressions can be a very\nuseful tool when you are working with data and want to separate the data\nstorage concerns from the behavior concerns.\n\n","nodes":[{"pos":[11,38],"content":"Pattern Matching | C# Guide","needQuote":true,"needEscape":true,"nodes":[{"content":"Pattern Matching | C# Guide","pos":[0,27]}]},{"pos":[52,98],"content":"Learn about pattern matching expressions in C#","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn about pattern matching expressions in C#","pos":[0,46]}]},{"pos":[109,128],"content":".NET, .NET Core, C#","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core, C#","pos":[0,19]}]},{"pos":[304,320],"content":"Pattern Matching","linkify":"Pattern Matching","nodes":[{"content":"Pattern Matching","pos":[0,16]}]},{"content":"Patterns test that a value has a certain <bpt id=\"p1\">*</bpt>shape<ept id=\"p1\">*</ept>, and can <bpt id=\"p2\">*</bpt>extract<ept id=\"p2\">*</ept> information from the value when it has the matching shape.","pos":[324,450],"source":"Patterns test that a value has a certain *shape*, and can *extract*\ninformation from the value when it has the matching shape."},{"content":"Pattern matching provides more concise syntax for algorithms you already use today.","pos":[451,534],"source":" Pattern\nmatching provides more concise syntax for algorithms you already use\ntoday."},{"content":"You already create pattern matching algorithms using existing syntax.","pos":[535,604],"source":" You already create pattern matching algorithms using existing\nsyntax."},{"content":"You write <ph id=\"ph1\">`if`</ph> or <ph id=\"ph2\">`switch`</ph> statements that test values.","pos":[605,660],"source":" You write `if` or `switch` statements that test values."},{"content":"Then, when those statements match, you extract and use information from that value.","pos":[661,744],"source":" Then,\nwhen those statements match, you extract and use information from that\nvalue."},{"content":"The new syntax elements are extensions to statements you are already familiar with: <ph id=\"ph1\">`is`</ph> and <ph id=\"ph2\">`switch`</ph>.","pos":[745,847],"source":" The new syntax elements are extensions to statements you are already\nfamiliar with: `is` and `switch`."},{"content":"These new extensions combine testing a value and extracting that information.","pos":[848,925],"source":" These new extensions combine testing\na value and extracting that information."},{"content":"In this topic, we'll look at the new syntax to show you how it enables readable, concise code.","pos":[927,1021],"source":"In this topic, we'll look at the new syntax to show you how it enables\nreadable, concise code."},{"content":"Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.","pos":[1022,1193],"source":" Pattern matching enables idioms where data and\nthe code are separated, unlike object oriented designs where data \nand the methods that manipulate them are tightly coupled."},{"content":"To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.","pos":[1195,1320],"source":"To illustrate these new idioms, let's work with structures that represent\ngeometric shapes using pattern matching statements."},{"content":"You are probably familiar with building class hierarchies and creating <bpt id=\"p1\">[</bpt>virtual methods and overridden methods<ept id=\"p1\">](methods.md#inherited)</ept> to customize object behavior based on the runtime type of the object.","pos":[1321,1524],"source":" You are probably\nfamiliar with building class hierarchies and creating\n[virtual methods and overridden methods](methods.md#inherited) to\ncustomize object behavior based on the runtime type of the object."},{"content":"Those techniques aren't possible for data that isn't structured in a class hierarchy.","pos":[1526,1611],"source":"Those techniques aren't possible for data that isn't structured in a class\nhierarchy."},{"content":"When data and methods are separate, you need other tools.","pos":[1612,1669]},{"content":"The new <bpt id=\"p1\">*</bpt>pattern matching<ept id=\"p1\">*</ept> constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.","pos":[1670,1810],"source":" The new\n*pattern matching* constructs enable cleaner syntax to examine data\nand manipulate control flow based on any condition of that data."},{"content":"You already write <ph id=\"ph1\">`if`</ph> statements and <ph id=\"ph2\">`switch`</ph> that test a variable's value.","pos":[1811,1887],"source":" You already\nwrite `if` statements and `switch` that test a variable's value."},{"content":"You write <ph id=\"ph1\">`is`</ph> statements that test a variable's type.","pos":[1888,1942],"source":" You write `is`\nstatements that test a variable's type."},{"content":"<bpt id=\"p1\">*</bpt>Pattern matching<ept id=\"p1\">*</ept> adds new capabilities to those statements.","pos":[1943,2004],"source":"*Pattern matching* adds new capabilities\nto those statements."},{"content":"In this topic, you'll build a method  that computes the area of different geometric shapes.","pos":[2006,2097],"source":"In this topic, you'll build a method  that computes the area of\ndifferent geometric shapes."},{"content":"But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.","pos":[2098,2220],"source":" But, you'll do it without resorting to object\noriented techniques and building a class hierarchy for the different shapes."},{"content":"You'll use <bpt id=\"p1\">*</bpt>pattern matching<ept id=\"p1\">*</ept> instead.","pos":[2221,2259],"source":"\nYou'll use *pattern matching* instead."},{"content":"To further emphasize that we're not using inheritance, you'll make each shape a <ph id=\"ph1\">`struct`</ph> instead of a class.","pos":[2260,2368],"source":" To further emphasize that we're not\nusing inheritance, you'll make each shape a `struct` instead of a class."},{"content":"Note that different <ph id=\"ph1\">`struct`</ph> types cannot specify a common user defined base type, so inheritance is not a possible design.","pos":[2369,2493],"source":" \nNote that different `struct` types cannot specify a common user defined\nbase type, so inheritance is not a possible design."},{"content":"As you go through this sample, contrast this code with how it would be structured as an object hierarchy.","pos":[2494,2599],"source":"\nAs you go through this sample, contrast this code with how it would\nbe structured as an object hierarchy."},{"content":"When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.","pos":[2600,2716],"source":" When the data you must\nquery and manipulate is not a class hierarchy, pattern matching enables\nvery elegant designs."},{"pos":[2718,2905],"content":"Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:","source":"Rather than starting with an abstract shape definition and adding different\nspecific shape classes, let's start instead with simple data only definitions\nfor each of the geometric shapes:"},{"pos":[2907,3027],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ShapeDefinitions<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions \"</bpt>Shape definitions<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions \"Shape definitions\")]"},{"pos":[3029,3110],"content":"From these structures, let's write a method that computes the area of some shape.","source":"From these structures, let's write a method that computes the area\nof some shape."},{"pos":[3115,3147],"content":"The <ph id=\"ph1\">`is`</ph> type pattern expression","linkify":"The `is` type pattern expression","source":"The `is` type pattern expression"},{"pos":[3149,3231],"content":"Before C# 7, you'd need to test each type in a series of <ph id=\"ph1\">`if`</ph> and <ph id=\"ph2\">`is`</ph> statements:","source":"Before C# 7, you'd need to test each type in a series of `if` and `is`\nstatements:"},{"pos":[3233,3383],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ClassicIsExpression<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression \"</bpt>Classic type pattern using is<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression \"Classic type pattern using is\")]"},{"pos":[3385,3545],"content":"That code above is a classic expression of the <bpt id=\"p1\">*</bpt>type pattern<ept id=\"p1\">*</ept>: You're testing a variable to determine its type and taking a different action based on that type.","source":"That code above is a classic expression of the *type pattern*: You're testing a variable\nto determine its type and taking a different action based on that type."},{"pos":[3547,3655],"content":"This code becomes simpler using extensions to the <ph id=\"ph1\">`is`</ph> expression to assign a variable if the test succeeds:","source":"This code becomes simpler using extensions to the `is` expression to assign\na variable if the test succeeds:"},{"pos":[3657,3799],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>IsPatternExpression<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression \"</bpt>is pattern expression<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression \"is pattern expression\")]"},{"content":"In this updated version, the <ph id=\"ph1\">`is`</ph> expression both tests the variable and assigns it to a new variable of the proper type.","pos":[3801,3922],"source":"In this updated version, the `is` expression both tests the variable and assigns\nit to a new variable of the proper type."},{"content":"Also, notice that this version includes the <ph id=\"ph1\">`Rectangle`</ph> type, which is a <ph id=\"ph2\">`struct`</ph>.","pos":[3923,4005],"source":" Also, notice that this version includes\nthe `Rectangle` type, which is a `struct`."},{"content":"The new <ph id=\"ph1\">`is`</ph> expression works with value types as well as reference types.","pos":[4006,4080],"source":" The new `is` expression works with\nvalue types as well as reference types."},{"content":"Language rules for pattern matching expressions help you avoid misusing the results of a match expression.","pos":[4082,4188],"source":"Language rules for pattern matching expressions help you avoid misusing\nthe results of a match expression."},{"content":"In the example above, the variables <ph id=\"ph1\">`s`</ph>, <ph id=\"ph2\"> `c`</ph>, and <ph id=\"ph3\">`r`</ph> are only in scope and definitely assigned when the respective pattern match expressions have <ph id=\"ph4\">`true`</ph> results.","pos":[4189,4352],"source":" In the example above, the variables `s`,\n `c`, and `r` are only in scope and definitely assigned when the respective\npattern match expressions have `true` results."},{"content":"If you try to use either variable in another location, your code generates compiler errors.","pos":[4353,4444],"source":" If you try to use either\nvariable in another location, your code generates compiler errors."},{"content":"Let's examine both of those rules in detail, beginning with scope.","pos":[4446,4512]},{"content":"The variable <ph id=\"ph1\">`c`</ph> is in scope only in the <ph id=\"ph2\">`else`</ph> branch of the first <ph id=\"ph3\">`if`</ph> statement.","pos":[4513,4596],"source":" The variable\n`c` is in scope only in the `else` branch of the first `if` statement."},{"content":"The variable <ph id=\"ph1\">`s`</ph> is in scope in the method <ph id=\"ph2\">`ComputeArea`</ph>.","pos":[4597,4654],"source":" The variable\n`s` is in scope in the method `ComputeArea`."},{"content":"That's because each branch of an <ph id=\"ph1\">`if`</ph> statement establishes a separate scope for variables.","pos":[4655,4747],"source":" That's because each \nbranch of an `if` statement establishes a separate scope for variables."},{"content":"However, the <ph id=\"ph1\">`if`</ph> statement itself does not.","pos":[4748,4792],"source":" However, the `if` statement\nitself does not."},{"content":"That means variables declared in the <ph id=\"ph1\">`if`</ph> statement are in the same scope as the <ph id=\"ph2\">`if`</ph> statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and <ph id=\"ph3\">`if`</ph> and <ph id=\"ph4\">`else`</ph> statements.","pos":[4793,5047],"source":" That means variables declared in the `if` statement are in the\nsame scope as the `if` statement (the method in this case.) This behavior is not\nspecific to pattern matching, but is the defined behavior for variable scopes \nand `if` and `else` statements."},{"pos":[5049,5188],"content":"The variables <ph id=\"ph1\">`c`</ph> and <ph id=\"ph2\">`s`</ph> are assigned when the respective <ph id=\"ph3\">`if`</ph> statements are true because of the definitely assigned when true mechanism.","source":"The variables `c` and `s` are assigned when the respective `if` statements are true\nbecause of the definitely assigned when true mechanism."},{"pos":[5192,5628],"content":"[!TIP]\nThe samples in this topic use the recommended construct where\na pattern match `is` expression definitely assigns the match\nvariable in the `true` branch of the `if` statement.\nYou could reverse the logic by saying `if (!(shape is Square s))`\nand the variable `s` would be definitely assigned only in the\n`false` branch. While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic.","leadings":["","> ","> ","> ","> ","> ","> ","> "],"nodes":[{"content":"The samples in this topic use the recommended construct where\na pattern match `is` expression definitely assigns the match\nvariable in the `true` branch of the `if` statement.\nYou could reverse the logic by saying `if (!(shape is Square s))`\nand the variable `s` would be definitely assigned only in the\n`false` branch. While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic.","pos":[7,422],"nodes":[{"content":"The samples in this topic use the recommended construct where a pattern match <ph id=\"ph1\">`is`</ph> expression definitely assigns the match variable in the <ph id=\"ph2\">`true`</ph> branch of the <ph id=\"ph3\">`if`</ph> statement.","pos":[0,175],"source":"The samples in this topic use the recommended construct where\na pattern match `is` expression definitely assigns the match\nvariable in the `true` branch of the `if` statement."},{"content":"You could reverse the logic by saying <ph id=\"ph1\">`if (!(shape is Square s))`</ph> and the variable <ph id=\"ph2\">`s`</ph> would be definitely assigned only in the <ph id=\"ph3\">`false`</ph> branch.","pos":[176,319],"source":"\nYou could reverse the logic by saying `if (!(shape is Square s))`\nand the variable `s` would be definitely assigned only in the\n`false` branch."},{"content":"While this is valid C#, it is not recommended because it is more confusing to follow the logic.","pos":[320,415],"source":" While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic."}]}]},{"pos":[5630,5763],"content":"These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.","source":"These rules mean that you are unlikely to accidentally access the result\nof a pattern match expression when that pattern was not met."},{"pos":[5768,5810],"content":"Using pattern matching <ph id=\"ph1\">`switch`</ph> statements","linkify":"Using pattern matching `switch` statements","source":"Using pattern matching `switch` statements"},{"content":"As time goes on, you may need to support other shape types.","pos":[5812,5871]},{"content":"As the number of conditions you are testing grows, you'll find that using the <ph id=\"ph1\">`is`</ph> pattern matching expressions can become cumbersome.","pos":[5872,6006],"source":" As the number\nof conditions you are testing grows, you'll find that using the `is` pattern\nmatching expressions can become cumbersome."},{"content":"In addition to requiring <ph id=\"ph1\">`if`</ph> statements on each type you want to check, the <ph id=\"ph2\">`is`</ph> expressions are limited to testing if the input matches a single type.","pos":[6007,6159],"source":" In addition to requiring `if`\nstatements on each type you want to check, the `is` expressions are limited\nto testing if the input matches a single type."},{"content":"In this case, you'll find that the <ph id=\"ph1\">`switch`</ph> pattern matching expressions becomes a better choice.","pos":[6160,6257],"source":" In this case, you'll find that the `switch` pattern\nmatching expressions becomes a better choice."},{"content":"The traditional <ph id=\"ph1\">`switch`</ph> statement was a pattern expression: it supported the constant pattern.","pos":[6260,6355],"source":"The traditional `switch`\nstatement was a pattern expression: it supported the constant pattern."},{"content":"You could compare a variable to any constant used in a <ph id=\"ph1\">`case`</ph> statement:","pos":[6356,6428],"source":"\nYou could compare a variable to any constant used in a `case` statement:"},{"pos":[6430,6563],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ClassicSwitch<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch \"</bpt>Classic switch statement<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch \"Classic switch statement\")]"},{"content":"The only pattern supported by the <ph id=\"ph1\">`switch`</ph> statement was the constant pattern.","pos":[6565,6643],"source":"The only pattern supported by the `switch` statement was the constant\npattern."},{"content":"It was further limited to numeric types and the <ph id=\"ph1\">`string`</ph> type.","pos":[6644,6706],"source":" It was further limited to numeric types and the `string` type."},{"content":"Those restrictions have been removed, and you can now write a <ph id=\"ph1\">`switch`</ph> statement using the type pattern:","pos":[6707,6811],"source":"\nThose restrictions have been removed, and you can now write a `switch`\nstatement using the type pattern:"},{"pos":[6813,6964],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Switch Type Pattern<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern \"</bpt>Compute with `switch` expression<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern \"Compute with `switch` expression\")]"},{"content":"The pattern matching <ph id=\"ph1\">`switch`</ph> statement uses familiar syntax to developers who have used the traditional C-style <ph id=\"ph2\">`switch`</ph> statement.","pos":[6966,7098],"source":"The pattern matching `switch` statement uses familiar syntax to developers\nwho have used the traditional C-style `switch` statement."},{"content":"Each <ph id=\"ph1\">`case`</ph> is evaluated and the code beneath the condition that matches the input variable is executed.","pos":[7099,7203],"source":" Each `case` is evaluated\nand the code beneath the condition that matches the input variable is\nexecuted."},{"content":"Code execution cannot \"fall through\" from one case expression to the next; the syntax of the <ph id=\"ph1\">`case`</ph> statement requires that each <ph id=\"ph2\">`case`</ph> end with a <ph id=\"ph3\">`break`</ph>, <ph id=\"ph4\">`return`</ph>, or <ph id=\"ph5\">`goto`</ph>.","pos":[7204,7380],"source":" Code execution cannot \"fall through\" from one case expression\nto the next; the syntax of the `case` statement requires that each `case`\nend with a `break`, `return`, or `goto`."},{"pos":[7384,7513],"content":"[!NOTE]\nThe `goto` statements to jump to another label are valid only\nfor the constant pattern, the classic switch statement.","leadings":["","> ","> "],"nodes":[{"content":"The <ph id=\"ph1\">`goto`</ph> statements to jump to another label are valid only for the constant pattern, the classic switch statement.","pos":[8,125],"source":"The `goto` statements to jump to another label are valid only\nfor the constant pattern, the classic switch statement."}]},{"content":"There are important new rules governing the <ph id=\"ph1\">`switch`</ph> statement.","pos":[7515,7578],"source":"There are important new rules governing the `switch` statement."},{"content":"The restrictions on the type of the variable in the <ph id=\"ph1\">`switch`</ph> expression have been removed.","pos":[7579,7669],"source":" The restrictions\non the type of the variable in the `switch` expression have been removed."},{"content":"Any type, such as <ph id=\"ph1\">`object`</ph> in this example, may be used.","pos":[7670,7726],"source":"\nAny type, such as `object` in this example, may be used."},{"content":"The case expressions are no longer limited to constant values.","pos":[7727,7789],"source":" The case expressions\nare no longer limited to constant values."},{"content":"Removing that limitation means that reordering <ph id=\"ph1\">`switch`</ph> sections may change a program's behavior.","pos":[7790,7887],"source":" Removing that limitation means\nthat reordering `switch` sections may change a program's behavior."},{"content":"When limited to constant values, no more than one <ph id=\"ph1\">`case`</ph> label could match the value of the <ph id=\"ph2\">`switch`</ph> expression.","pos":[7889,8001],"source":"When limited to constant values, no more than one `case`\nlabel could match the value of the `switch` expression."},{"content":"Combine that with the rule that every <ph id=\"ph1\">`switch`</ph> section must not fall through to the next section, and it followed that the <ph id=\"ph2\">`switch`</ph> sections could be rearranged in any order without affecting behavior.","pos":[8002,8205],"source":" Combine that with the \nrule that every `switch` section must not fall through to the next section, and \nit followed that the\n`switch` sections could be rearranged in any order without affecting behavior."},{"content":"Now, with more generalized <ph id=\"ph1\">`switch`</ph> expressions, the order of each section matters.","pos":[8206,8289],"source":"\nNow, with more generalized `switch` expressions, the order of each section\nmatters."},{"content":"The <ph id=\"ph1\">`switch`</ph> expressions are evaluated in textual order.","pos":[8290,8346],"source":" The `switch` expressions are evaluated in textual order."},{"content":"Execution transfers to the first <ph id=\"ph1\">`switch`</ph> label that matches the <ph id=\"ph2\">`switch`</ph> expression.","pos":[8347,8432],"source":" Execution\ntransfers to the first `switch` label that matches the `switch` expression."},{"content":"Note that the <ph id=\"ph1\">`default`</ph> case will only be executed if no other case labels match.","pos":[8435,8516],"source":"Note that the `default` case will only be executed if no other\ncase labels match."},{"content":"The <ph id=\"ph1\">`default`</ph> case is evaluated last, regardless of its textual order.","pos":[8517,8587],"source":" The `default` case is evaluated last, regardless\nof its textual order."},{"content":"If there is no <ph id=\"ph1\">`default`</ph> case, and none of the other <ph id=\"ph2\">`case`</ph> statements match, execution continues at the statement following the <ph id=\"ph3\">`switch`</ph> statement.","pos":[8588,8736],"source":" If there is no `default` case, and none of the\nother `case` statements match, execution continues at the statement\nfollowing the `switch` statement."},{"content":"None of the <ph id=\"ph1\">`case`</ph> labels code is executed.","pos":[8737,8780],"source":" None of the `case` labels code is\nexecuted."},{"pos":[8785,8821],"content":"<ph id=\"ph1\">`when`</ph> clauses in <ph id=\"ph2\">`case`</ph> expressions","linkify":"`when` clauses in `case` expressions","source":"`when` clauses in `case` expressions"},{"content":"You can make special cases for those shapes that have 0 area by using a <ph id=\"ph1\">`when`</ph> clause on the <ph id=\"ph2\">`case`</ph> label.","pos":[8823,8929],"source":"You can make special cases for those shapes that have 0 area by using\na `when` clause on the `case` label."},{"content":"A square with a side length of 0, or a circle with a radius of 0 has a 0 area.","pos":[8930,9008],"source":" A square with a side length of 0, or\na circle with a radius of 0 has a 0 area."},{"content":"You specify that condition using a <ph id=\"ph1\">`when`</ph> clause on the <ph id=\"ph2\">`case`</ph> label:","pos":[9009,9078],"source":" You specify that condition\nusing a `when` clause on the `case` label:"},{"pos":[9082,9237],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ComputeDegenerateShapes<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes \"</bpt>Compute shapes with 0 area<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes \"Compute shapes with 0 area\")]"},{"content":"This change demonstrates a few important points about the new syntax.","pos":[9239,9308]},{"content":"First, multiple <ph id=\"ph1\">`case`</ph> labels can be applied to one <ph id=\"ph2\">`switch`</ph> section.","pos":[9309,9378],"source":" First,\nmultiple `case` labels can be applied to one `switch` section."},{"content":"The statement block is executed when any of those labels is <ph id=\"ph1\">`true`</ph>.","pos":[9379,9446],"source":" The statement\nblock is executed when any of those labels is `true`."},{"content":"In this instance, if the <ph id=\"ph1\">`switch`</ph> expression is either a circle or a square with 0 area, the method returns the constant 0.","pos":[9447,9570],"source":" In this instance,\nif the `switch` expression is either a circle or a square with 0 area, the\nmethod returns the constant 0."},{"content":"This example introduces two different variables in the two <ph id=\"ph1\">`case`</ph> labels for the first <ph id=\"ph2\">`switch`</ph> block.","pos":[9572,9674],"source":"This example introduces two different variables in the two `case` labels\nfor the first `switch` block."},{"content":"Notice that the statements in this <ph id=\"ph1\">`switch`</ph> block do not use either the variables <ph id=\"ph2\">`c`</ph> (for the circle) or <ph id=\"ph3\">`s`</ph> (for the square).","pos":[9675,9802],"source":" Notice that the statements in this `switch` block\ndo not use either the variables `c` (for the circle) or `s` (for the square)."},{"content":"Neither of those variables is definitely assigned in this <ph id=\"ph1\">`switch`</ph> block.","pos":[9803,9876],"source":"\nNeither of those variables is definitely assigned in this `switch` block."},{"content":"If either of these cases match, clearly one of the variables has been assigned.","pos":[9877,9956],"source":"\nIf either of these cases match, clearly one of the variables has been assigned."},{"content":"However, it is impossible to tell <bpt id=\"p1\">*</bpt>which<ept id=\"p1\">*</ept> has been assigned at compile-time, because either case could match at runtime.","pos":[9957,10077],"source":"\nHowever, it is impossible to tell *which* has been assigned at compile-time,\nbecause either case could match at runtime."},{"content":"For that reason, most times when you use multiple <ph id=\"ph1\">`case`</ph> labels for the same block, you won't introduce a new variable in the <ph id=\"ph2\">`case`</ph> statement, or you will only use the variable in the <ph id=\"ph3\">`when`</ph> clause.","pos":[10078,10277],"source":" For that reason,\nmost times when you use multiple `case` labels for the same block, you won't\nintroduce a new variable in the `case` statement, or you will only use the\nvariable in the `when` clause."},{"pos":[10279,10382],"content":"Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:","source":"Having added those shapes with 0 area, let's add a couple more shape types:\na rectangle and a triangle:"},{"pos":[10384,10539],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>AddRectangleAndTriangle<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle \"</bpt>Add rectangle and triangle<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle \"Add rectangle and triangle\")]"},{"pos":[10542,10656],"content":"This set of changes adds <ph id=\"ph1\">`case`</ph> labels for the degenerate case, and labels and blocks for each of the new shapes.","source":"This set of changes adds `case` labels for the degenerate case, and labels\n and blocks for each of the new shapes."},{"pos":[10659,10731],"content":"Finally, you can add a <ph id=\"ph1\">`null`</ph> case to ensure the argument is not <ph id=\"ph2\">`null`</ph>:","source":"Finally, you can add a `null` case to ensure the argument is not `null`:"},{"pos":[10733,10845],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>NullCase<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase \"</bpt>Add null case<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase \"Add null case\")]"},{"pos":[10847,11012],"content":"The special case for the <ph id=\"ph1\">`null`</ph> pattern is interesting because the constant <ph id=\"ph2\">`null`</ph> does not have a type, but can be converted to any reference type or nullable type.","source":"The special case for the `null` pattern is interesting because the constant `null` does\nnot have a type, but can be converted to any reference type or nullable\ntype."},{"pos":[11018,11029],"content":"Conclusions","linkify":"Conclusions","nodes":[{"content":"Conclusions","pos":[0,11]}]},{"content":"<bpt id=\"p1\">*</bpt>Pattern Matching constructs<ept id=\"p1\">*</ept> enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.","pos":[11031,11187],"source":"*Pattern Matching constructs* enable you to easily manage control flow\namong different variables and types that are not related by an inheritance\nhierarchy."},{"content":"You can also control logic to use any condition you test on the variable.","pos":[11188,11261],"source":" You can also control logic to use any condition you test on\nthe variable."},{"content":"It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.","pos":[11262,11431],"source":" It enables patterns and idioms that you'll need more often\nas you build more distributed applications, where data and the methods that\nmanipulate that data are separate."},{"content":"You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.","pos":[11432,11543],"source":" You'll notice that the shape structs\nused in this sample do not contain any methods, just read-only properties."},{"content":"Pattern Matching works with any data type.","pos":[11544,11586],"source":"\nPattern Matching works with any data type."},{"content":"You write expressions that examine the object, and make control flow decisions based on those conditions.","pos":[11587,11692],"source":" You write expressions that examine\nthe object, and make control flow decisions based on those conditions."},{"content":"Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract <ph id=\"ph1\">`Shape`</ph> and specific derived shapes each with their own implementation of a virtual method to calculate the area.","pos":[11694,11923],"source":"Compare the code from this sample with the design that would follow from\ncreating a class hierarchy for an abstract `Shape` and specific derived\nshapes each with their own implementation of a virtual method to calculate\nthe area."},{"content":"You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.","pos":[11924,12107],"source":" You'll often find that pattern matching expressions can be a very\nuseful tool when you are working with data and want to separate the data\nstorage concerns from the behavior concerns."}]}