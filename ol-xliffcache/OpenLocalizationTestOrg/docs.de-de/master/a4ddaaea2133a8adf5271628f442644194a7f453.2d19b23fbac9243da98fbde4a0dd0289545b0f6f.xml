{"content":"---\ntitle: \"Data Contract Schema Reference\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"data contracts [WCF], schema reference\"\nms.assetid: 9ebb0ebe-8166-4c93-980a-7c8f1f38f7c0\n---\n# Data Contract Schema Reference\nThis topic describes the subset of the XML Schema (XSD) used by <xref:System.Runtime.Serialization.DataContractSerializer> to describe common language runtime (CLR) types for XML serialization.  \n  \n## DataContractSerializer Mappings  \n The `DataContractSerializer` maps CLR types to XSD when metadata is exported from a Windows Communication Foundation (WCF) service using a metadata endpoint or the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). For more information, see [Data Contract Serializer](../../../../docs/framework/wcf/feature-details/data-contract-serializer.md).  \n  \n The `DataContractSerializer` also maps XSD to CLR types when Svcutil.exe is used to access Web Services Description Language (WSDL) or XSD documents and generate data contracts for services or clients.  \n  \n Only XML Schema instances that conform to requirements stated in this document can be mapped to CLR types using `DataContractSerializer`.  \n  \n### Support Levels  \n The `DataContractSerializer` provides the following levels of support for a given XML Schema feature:  \n  \n-   **Supported**. There is explicit mapping from this feature to CLR types or attributes (or both) using `DataContractSerializer`.  \n  \n-   **Ignored**. The feature is allowed in schemas imported by the `DataContractSerializer`, but has no effect on code generation.  \n  \n-   **Forbidden**. The `DataContractSerializer` does not support importing a schema using the feature. For example, Svcutil.exe, when accessing a WSDL with a schema that uses such a feature, falls back to using the <xref:System.Xml.Serialization.XmlSerializer> instead. This is by default.  \n  \n## General Information  \n  \n-   The schema namespace is described at [XML Schema](https://go.microsoft.com/fwlink/?LinkId=95475). The prefix \"xs\" is used in this document.  \n  \n-   Any attributes with a non-schema namespace are ignored.  \n  \n-   Any annotations (except for those described in this document) are ignored.  \n  \n### \\<xs:schema>: attributes  \n  \n|Attribute|DataContract|  \n|---------------|------------------|  \n|`attributeFormDefault`|Ignored.|  \n|`blockDefault`|Ignored.|  \n|`elementFormDefault`|Must be qualified. All elements must be qualified for a schema to be supported by `DataContractSerializer`. This can be accomplished by either setting xs:schema/@elementFormDefault to \"qualified\" or by setting xs:element/@form to \"qualified\" on each individual element declaration.|  \n|`finalDefault`|Ignored.|  \n|`Id`|Ignored.|  \n|`targetNamespace`|Supported and mapped to the data contract namespace. If this attribute is not specified, the blank namespace is used. Cannot be the reserved namespace `http://schemas.microsoft.com/2003/10/Serialization/`.|  \n|`version`|Ignored.|  \n  \n### \\<xs:schema>: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`include`|Supported. `DataContractSerializer` supports xs:include and xs:import. However, Svcutil.exe restricts following `xs:include/@schemaLocation` and `xs:import/@location` references when metadata is loaded from a local file. The list of schema files must be passed through an out-of-band mechanism and not through `include` in this case; `include`d schema documents are ignored.|  \n|`redefine`|Forbidden. The use of `xs:redefine` is forbidden by `DataContractSerializer` for security reasons: `x:redefine` requires `schemaLocation` to be followed. In certain circumstances, Svcutil.exe using DataContract restricts use of `schemaLocation`.|  \n|`import`|Supported. `DataContractSerializer` supports `xs:include` and `xs:import`. However, Svcutil.exe restricts following `xs:include/@schemaLocation` and `xs:import/@location` references when metadata is loaded from a local file. The list of schema files must be passed through an out-of-band mechanism and not through `include` in this case; `include`d schema documents are ignored.|  \n|`simpleType`|Supported. See the `xs:simpleType` section.|  \n|`complexType`|Supported, maps to data contracts. See the `xs:complexType` section.|  \n|`group`|Ignored. `DataContractSerializer` does not support use of `xs:group`, `xs:attributeGroup`, and `xs:attribute`. These declarations are ignored as children of `xs:schema`, but cannot be referenced from within `complexType` or other supported constructs.|  \n|`attributeGroup`|Ignored. `DataContractSerializer` does not support use of `xs:group`, `xs:attributeGroup`, and `xs:attribute`. These declarations are ignored as children of `xs:schema`, but cannot be referenced from within `complexType` or other supported constructs.|  \n|`element`|Supported. See Global Element Declaration (GED).|  \n|`attribute`|Ignored. `DataContractSerializer` does not support use of `xs:group`, `xs:attributeGroup`, and `xs:attribute`. These declarations are ignored as children of `xs:schema`, but cannot be referenced from within `complexType` or other supported constructs.|  \n|`notation`|Ignored.|  \n  \n## Complex Types – \\<xs:complexType>  \n  \n### General Information  \n Each complex type \\<xs:complexType> maps to a data contract.  \n  \n### \\<xs:complexType>: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`abstract`|Must be false (default).|  \n|`block`|Forbidden.|  \n|`final`|Ignored.|  \n|`id`|Ignored.|  \n|`mixed`|Must be false (default).|  \n|`name`|Supported and mapped to the data contract name. If there are periods in the name, an attempt is made to map the type to an inner type. For example, a complex type named `A.B` maps to a data contract type that is an inner type of a type with the data contract name `A`, but only if such a data contract type exists. More than one level of nesting is possible: for example, `A.B.C` can be an inner type, but only if `A` and `A.B` both exist.|  \n  \n### \\<xs:complexType>: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`simpleContent`|Extensions are forbidden.<br /><br /> Restriction is allowed only from `anySimpleType`.|  \n|`complexContent`|Supported. See \"Inheritance\".|  \n|`group`|Forbidden.|  \n|`all`|Forbidden.|  \n|`choice`|Forbidden|  \n|`sequence`|Supported, maps to data members of a data contract.|  \n|`attribute`|Forbidden, even if use=\"prohibited\" (with one exception). Only optional attributes from the Standard Serialization Schema namespace are supported. They do not map to data members in the data contract programming model. Currently, only one such attribute has meaning and is discussed in the ISerializable section. All others are ignored.|  \n|`attributeGroup`|Forbidden. In the WCF v1 release, `DataContractSerializer` ignores the presence of `attributeGroup` inside `xs:complexType`.|  \n|`anyAttribute`|Forbidden.|  \n|(empty)|Maps to a data contract with no data members.|  \n  \n### \\<xs:sequence> in a complex type: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`id`|Ignored.|  \n|`maxOccurs`|Must be 1 (default).|  \n|`minOccurs`|Must be 1 (default).|  \n  \n### \\<xs:sequence> in a complex type: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`element`|Each instance maps to a data member.|  \n|`group`|Forbidden.|  \n|`choice`|Forbidden.|  \n|`sequence`|Forbidden.|  \n|`any`|Forbidden.|  \n|(empty)|Maps to a data contract with no data members.|  \n  \n## Elements – \\<xs:element>  \n  \n### General Information  \n `<xs:element>` can occur in the following contexts:  \n  \n-   It can occur within an `<xs:sequence>`, which describes a data member of a regular (non-collection) data contract. In this case, the `maxOccurs` attribute must be 1. (A value of 0 is not allowed).  \n  \n-   It can occur within an `<xs:sequence>`, which describes a data member of a collection data contract. In this case, the `maxOccurs` attribute must be greater than 1 or \"unbounded\".  \n  \n-   It can occur within an `<xs:schema>` as a Global Element Declaration (GED).  \n  \n### \\<xs:element> with maxOccurs=1 within an \\<xs:sequence> (Data Members)  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`ref`|Forbidden.|  \n|`name`|Supported, maps to the data member name.|  \n|`type`|Supported, maps to the data member type. For more information, see Type/primitive mapping. If not specified (and the element does not contain an anonymous type), `xs:anyType` is assumed.|  \n|`block`|Ignored.|  \n|`default`|Forbidden.|  \n|`fixed`|Forbidden.|  \n|`form`|Must be qualified. This attribute can be set through `elementFormDefault` on `xs:schema`.|  \n|`id`|Ignored.|  \n|`maxOccurs`|1|  \n|`minOccurs`|Maps to the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of a data member (`IsRequired` is true when `minOccurs` is 1).|  \n|`nillable`|Affects type mapping. See Type/primitive mapping.|  \n  \n### \\<xs:element> with maxOccurs>1 within an \\<xs:sequence> (Collections)  \n  \n-   Maps to a <xref:System.Runtime.Serialization.CollectionDataContractAttribute>.  \n  \n-   In collection types, only one xs:element is allowed within an xs:sequence.  \n  \n Collections can be of the following types:  \n  \n-   Regular collections (for example, arrays).  \n  \n-   Dictionary collections (mapping one value to another; for example, a <xref:System.Collections.Hashtable>).  \n  \n-   The only difference between a dictionary and an array of a key/value pair type is in the generated programming model. There is a schema annotation mechanism that can be used to indicate that a given type is a dictionary collection.  \n  \n The rules for the `ref`, `block`, `default`, `fixed`, `form`, and `id` attributes are the same as for the non-collection case. Other attributes include those in the following table.  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`name`|Supported, maps to the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property in the `CollectionDataContractAttribute` attribute.|  \n|`type`|Supported, maps to the type stored in the collection.|  \n|`maxOccurs`|Greater than 1 or \"unbounded\". The DC schema should use \"unbounded\".|  \n|`minOccurs`|Ignored.|  \n|`nillable`|Affects type mapping. This attribute is ignored for dictionary collections.|  \n  \n### \\<xs:element> within an \\<xs:schema> Global Element Declaration  \n  \n-   A Global Element Declaration (GED) that has the same name and namespace as a type in schema, or that defines an anonymous type inside itself, is said to be associated with the type.  \n  \n-   Schema export: associated GEDs are generated for every generated type, both simple and complex.  \n  \n-   Deserialization/serialization: associated GEDs are used as root elements for the type.  \n  \n-   Schema import: associated GEDs are not required and are ignored if they follow the following rules (unless they define types).  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`abstract`|Must be false for associated GEDs.|  \n|`block`|Forbidden in associated GEDs.|  \n|`default`|Forbidden in associated GEDs.|  \n|`final`|Must be false for associated GEDs.|  \n|`fixed`|Forbidden in associated GEDs.|  \n|`id`|Ignored.|  \n|`name`|Supported. See the definition of associated GEDs.|  \n|`nillable`|Must be true for associated GEDs.|  \n|`substitutionGroup`|Forbidden in associated GEDs.|  \n|`type`|Supported, and must match the associated type for associated GEDs (unless the element contains an anonymous type).|  \n  \n### \\<xs:element>: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`simpleType`|Supported.*|  \n|`complexType`|Supported.*|  \n|`unique`|Ignored.|  \n|`key`|Ignored.|  \n|`keyref`|Ignored.|  \n|(blank)|Supported.|  \n  \n \\* When using the `simpleType` and `complexType,` mapping for anonymous types is the same as for non-anonymous types, except that there is no anonymous data contracts, and so a named data contract is created, with a generated name derived from the element name. The rules for anonymous types are in the following list:  \n  \n-   WCF implementation detail: If the `xs:element` name does not contain periods, the anonymous type maps to an inner type of the outer data contract type. If the name contains periods, the resulting data contract type is independent (not an inner type).  \n  \n-   The generated data contract name of the inner type is the data contract name of the outer type followed by a period, the name of the element, and the string \"Type\".  \n  \n-   If a data contract with such a name already exists, the name is made unique by appending \"1\", \"2\", \"3\", and so on until a unique name is created.  \n  \n## Simple Types - \\<xs:simpleType>  \n  \n### \\<xs:simpleType>: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`final`|Ignored.|  \n|`id`|Ignored.|  \n|`name`|Supported, maps to the data contract name.|  \n  \n### \\<xs:simpleType>: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`restriction`|Supported. Maps to enumeration data contracts. This attribute is ignored if it does not match the enumeration pattern. See the `xs:simpleType` restrictions section.|  \n|`list`|Supported. Maps to flag enumeration data contracts. See the `xs:simpleType` lists section.|  \n|`union`|Forbidden.|  \n  \n### \\<xs:restriction>  \n  \n-   Complex type restrictions are supported only for base=\"`xs:anyType`\".  \n  \n-   Simple type restrictions of `xs:string` that do not have any restriction facets other than `xs:enumeration` are mapped to enumeration data contracts.  \n  \n-   All other simple type restrictions are mapped to the types they restrict. For example, a restriction of `xs:int` maps to an integer, just as `xs:int` itself does. For more information about primitive type mapping, see Type/primitive mapping.  \n  \n### \\<xs:restriction>: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`base`|Must be a supported simple type or `xs:anyType`.|  \n|`id`|Ignored.|  \n  \n### \\<xs:restriction> for all other cases: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`simpleType`|If present, must be derived from a supported primitive type.|  \n|`minExclusive`|Ignored.|  \n|`minInclusive`|Ignored.|  \n|`maxExclusive`|Ignored.|  \n|`maxInclusive`|Ignored.|  \n|`totalDigits`|Ignored.|  \n|`fractionDigits`|Ignored.|  \n|`length`|Ignored.|  \n|`minLength`|Ignored.|  \n|`maxLength`|Ignored.|  \n|`enumeration`|Ignored.|  \n|`whiteSpace`|Ignored.|  \n|`pattern`|Ignored.|  \n|(blank)|Supported.|  \n  \n## Enumeration  \n  \n### \\<xs:restriction> for enumerations: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`base`|If present, must be `xs:string`.|  \n|`id`|Ignored.|  \n  \n### \\<xs:restriction> for enumerations: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`simpleType`|If present, must be an enumeration restriction supported by the data contract (this section).|  \n|`minExclusive`|Ignored.|  \n|`minInclusive`|Ignored.|  \n|`maxExclusive`|Ignored.|  \n|`maxInclusive`|Ignored.|  \n|`totalDigits`|Ignored.|  \n|`fractionDigits`|Ignored.|  \n|`length`|Forbidden.|  \n|`minLength`|Forbidden.|  \n|`maxLength`|Forbidden.|  \n|`enumeration`|Supported. Enumeration \"id\" is ignored, and \"value\" maps to the value name in the enumeration data contract.|  \n|`whiteSpace`|Forbidden.|  \n|`pattern`|Forbidden.|  \n|(empty)|Supported, maps to empty enumeration type.|  \n  \n The following code shows a C# enumeration class.  \n  \n```csharp  \npublic enum MyEnum  \n{  \n  first = 3,  \n  second = 4,  \n  third =5  \n}  \n```  \n  \n This class maps to the following schema by the `DataContractSerializer`. If enumeration values start from 1, `xs:annotation` blocks are not generated.  \n  \n```xml  \n<xs:simpleType name=\"MyEnum\">  \n<xs:restriction base=\"xs:string\">  \n <xs:enumeration value=\"first\">  \n  <xs:annotation>  \n   <xs:appinfo>  \n    <EnumerationValue   \n     xmlns=\"http://schemas.microsoft.com/2003/10/Serialization/\">  \n     3  \n    </EnumerationValue>  \n   </xs:appinfo>  \n  </xs:annotation>  \n </xs:enumeration>  \n <xs:enumeration value=\"second\">  \n  <xs:annotation>  \n   <xs:appinfo>  \n    <EnumerationValue   \n     xmlns=\"http://schemas.microsoft.com/2003/10/Serialization/\">  \n     4  \n    </EnumerationValue>  \n   </xs:appinfo>  \n  </xs:annotation>  \n </xs:enumeration>  \n</xs:restriction>  \n</xs:simpleType>  \n```  \n  \n### \\<xs:list>  \n `DataContractSerializer` maps enumeration types marked with `System.FlagsAttribute` to `xs:list` derived from `xs:string`. No other `xs:list` variations are supported.  \n  \n### \\<xs:list>: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`itemType`|Forbidden.|  \n|`id`|Ignored.|  \n  \n### \\<xs:list>: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`simpleType`|Must be restriction from `xs:string` using `xs:enumeration` facet.|  \n  \n If enumeration value does not follow a power of 2 progression (default for Flags), the value is stored in the `xs:annotation/xs:appInfo/ser:EnumerationValue` element.  \n  \n For example, the following code flags an enumeration type.  \n  \n```csharp  \n[Flags]  \npublic enum AuthFlags  \n{    \n  AuthAnonymous = 1,  \n  AuthBasic = 2,  \n  AuthNTLM = 4,  \n  AuthMD5 = 16,  \n  AuthWindowsLiveID = 64,  \n}  \n```  \n  \n This type maps to the following schema.  \n  \n```xml  \n<xs:simpleType name=\"AuthFlags\">  \n    <xs:list>  \n      <xs:simpleType>  \n        <xs:restriction base=\"xs:string\">  \n          <xs:enumeration value=\"AuthAnonymous\" />  \n          <xs:enumeration value=\"AuthBasic\" />  \n          <xs:enumeration value=\"AuthNTLM\" />  \n          <xs:enumeration value=\"AuthMD5\">  \n            <xs:annotation>  \n              <xs:appinfo>  \n                <EnumerationValue xmlns=\"http://schemas.microsoft.com/2003/10/Se  \nrialization/\">16</EnumerationValue>  \n              </xs:appinfo>  \n            </xs:annotation>  \n          </xs:enumeration>  \n          <xs:enumeration value=\"AuthWindowsLiveID\">  \n            <xs:annotation>  \n              <xs:appinfo>  \n                <EnumerationValue xmlns=\"http://schemas.microsoft.com/2003/10/Se  \nrialization/\">64</EnumerationValue>  \n              </xs:appinfo>  \n            </xs:annotation>  \n          </xs:enumeration>  \n        </xs:restriction>  \n      </xs:simpleType>  \n    </xs:list>  \n  </xs:simpleType>  \n```  \n  \n## Inheritance  \n  \n### General rules  \n A data contract can inherit from another data contract. Such data contracts map to a base and are derived by extension types using the `<xs:extension>` XML Schema construct.  \n  \n A data contract cannot inherit from a collection data contract.  \n  \n For example, the following code is a data contract.  \n  \n```csharp  \n[DataContract]  \npublic class Person  \n{  \n  [DataMember]  \n  public string Name;  \n}  \n[DataContract]  \npublic class Employee : Person   \n{      \n  [DataMember]  \n  public int ID;  \n}  \n```  \n  \n This data contract maps to the following XML Schema type declaration.  \n  \n```xml  \n<xs:complexType name=\"Employee\">  \n <xs:complexContent mixed=\"false\">  \n  <xs:extension base=\"tns:Person\">  \n   <xs:sequence>  \n    <xs:element minOccurs=\"0\" name=\"ID\" type=\"xs:int\"/>  \n   </xs:sequence>  \n  </xs:extension>  \n </xs:complexContent>  \n</xs:complexType>  \n<xs:complexType name=\"Person\">  \n <xs:sequence>  \n  <xs:element minOccurs=\"0\" name=\"Name\"   \n    nillable=\"true\" type=\"xs:string\"/>  \n </xs:sequence>  \n</xs:complexType>  \n```  \n  \n### \\<xs:complexContent>: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`id`|Ignored.|  \n|`mixed`|Must be false.|  \n  \n### \\<xs:complexContent>: contents  \n  \n|Contents|Schema|  \n|--------------|------------|  \n|`restriction`|Forbidden, except when base=\"`xs:anyType`\". The latter is equivalent to placing the content of the `xs:restriction` directly under the container of the `xs:complexContent`.|  \n|`extension`|Supported. Maps to data contract inheritance.|  \n  \n### \\<xs:extension> in \\<xs:complexContent>: attributes  \n  \n|Attribute|Schema|  \n|---------------|------------|  \n|`id`|Ignored.|  \n|`base`|Supported. Maps to the base data contract type that this type inherits from.|  \n  \n### \\<xs:extension> in \\<xs:complexContent>: contents  \n The rules are the same as for `<xs:complexType>` contents.  \n  \n If an `<xs:sequence>` is provided, its member elements map to additional data members that are present in the derived data contract.  \n  \n If a derived type contains an element with the same name as an element in a base type, the duplicate element declaration maps to a data member with a name that is generated to be unique. Positive integer numbers are added to the data member name (\"member1\", \"member2\", and so on) until a unique name is found. Conversely:  \n  \n-   If a derived data contract has a data member with the same name and type as a data member in a base data contract, `DataContractSerializer` generates this corresponding element in the derived type.  \n  \n-   If a derived data contract has a data member with the same name as a data member in a base data contract but a different type, the `DataContractSerializer` imports a schema with an element of the type `xs:anyType` in both base type and derived type declarations. The original type name is preserved in `xs:annotations/xs:appInfo/ser:ActualType/@Name`.  \n  \n Both variations may lead to a schema with an ambiguous content model, which depends on the order of the respective data members.  \n  \n## Type/primitive mapping  \n The `DataContractSerializer` uses the following mapping for XML Schema primitive types.  \n  \n|XSD type|.NET type|  \n|--------------|---------------|  \n|`anyType`|<xref:System.Object>.|  \n|`anySimpleType`|<xref:System.String>.|  \n|`duration`|<xref:System.TimeSpan>.|  \n|`dateTime`|<xref:System.DateTime>.|  \n|`dateTimeOffset`|<xref:System.DateTime> and <xref:System.TimeSpan> for the offset. See DateTimeOffset Serialization below.|  \n|`time`|<xref:System.String>.|  \n|`date`|<xref:System.String>.|  \n|`gYearMonth`|<xref:System.String>.|  \n|`gYear`|<xref:System.String>.|  \n|`gMonthDay`|<xref:System.String>.|  \n|`gDay`|<xref:System.String>.|  \n|`gMonth`|<xref:System.String>.|  \n|`boolean`|<xref:System.Boolean>|  \n|`base64Binary`|<xref:System.Byte> array.|  \n|`hexBinary`|<xref:System.String>.|  \n|`float`|<xref:System.Single>.|  \n|`double`|<xref:System.Double>.|  \n|`anyURI`|<xref:System.Uri>.|  \n|`QName`|<xref:System.Xml.XmlQualifiedName>.|  \n|`string`|<xref:System.String>.|  \n|`normalizedString`|<xref:System.String>.|  \n|`token`|<xref:System.String>.|  \n|`language`|<xref:System.String>.|  \n|`Name`|<xref:System.String>.|  \n|`NCName`|<xref:System.String>.|  \n|`ID`|<xref:System.String>.|  \n|`IDREF`|<xref:System.String>.|  \n|`IDREFS`|<xref:System.String>.|  \n|`ENTITY`|<xref:System.String>.|  \n|`ENTITIES`|<xref:System.String>.|  \n|`NMTOKEN`|<xref:System.String>.|  \n|`NMTOKENS`|<xref:System.String>.|  \n|`decimal`|<xref:System.Decimal>.|  \n|`integer`|<xref:System.Int64>.|  \n|`nonPositiveInteger`|<xref:System.Int64>.|  \n|`negativeInteger`|<xref:System.Int64>.|  \n|`long`|<xref:System.Int64>.|  \n|`int`|<xref:System.Int32>.|  \n|`short`|<xref:System.Int16>.|  \n|`Byte`|<xref:System.SByte>.|  \n|`nonNegativeInteger`|<xref:System.Int64>.|  \n|`unsignedLong`|<xref:System.UInt64>.|  \n|`unsignedInt`|<xref:System.UInt32>.|  \n|`unsignedShort`|<xref:System.UInt16>.|  \n|`unsignedByte`|<xref:System.Byte>.|  \n|`positiveInteger`|<xref:System.Int64>.|  \n  \n## ISerializable types mapping  \n In [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] version 1.0, <xref:System.Runtime.Serialization.ISerializable> was introduced as a general mechanism to serialize objects for persistence or data transfer. There are many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types that implement `ISerializable` and that can be passed between applications. <xref:System.Runtime.Serialization.DataContractSerializer> naturally provides support for `ISerializable` classes. The `DataContractSerializer` maps `ISerializable` implementation schema types that differ only by the QName (qualified name) of the type and are effectively property collections. For example, the `DataContractSerializer` maps <xref:System.Exception> to the following XSD type in the `http://schemas.datacontract.org/2004/07/System` namespace.  \n  \n```xml  \n<xs:complexType name=\"Exception\">  \n <xs:sequence>  \n  <xs:any minOccurs=\"0\" maxOccurs=\"unbounded\"   \n      namespace=\"##local\" processContents=\"skip\"/>  \n </xs:sequence>  \n <xs:attribute ref=\"ser:FactoryType\"/>  \n</xs:complexType>  \n```  \n  \n The optional attribute `ser:FactoryType` declared in the Data Contract Serialization schema references a factory class that can deserialize the type. The factory class must be part of the known types collection of the `DataContractSerializer` instance being used. For more information about known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).  \n  \n## DataContract Serialization Schema  \n A number of schemas exported by the `DataContractSerializer` use types, elements, and attributes from a special Data Contract Serialization namespace:  \n  \n `http://schemas.microsoft.com/2003/10/Serialization`\n  \n The following is a complete Data Contract Serialization schema declaration.  \n  \n```xml  \n<xs:schema attributeFormDefault=\"qualified\"          \n   elementFormDefault=\"qualified\"        \n   targetNamespace =   \n    \"http://schemas.microsoft.com/2003/10/Serialization/\"   \n   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"        \n   xmlns:tns=\"http://schemas.microsoft.com/2003/10/Serialization/\">  \n  \n <!-- Top-level elements for primitive types. -->  \n <xs:element name=\"anyType\" nillable=\"true\" type=\"xs:anyType\"/>  \n <xs:element name=\"anyURI\" nillable=\"true\" type=\"xs:anyURI\"/>  \n <xs:element name=\"base64Binary\"  \n       nillable=\"true\" type=\"xs:base64Binary\"/>  \n <xs:element name=\"boolean\" nillable=\"true\" type=\"xs:boolean\"/>  \n <xs:element name=\"byte\" nillable=\"true\" type=\"xs:byte\"/>  \n <xs:element name=\"dateTime\" nillable=\"true\" type=\"xs:dateTime\"/>  \n <xs:element name=\"decimal\" nillable=\"true\" type=\"xs:decimal\"/>  \n <xs:element name=\"double\" nillable=\"true\" type=\"xs:double\"/>  \n <xs:element name=\"float\" nillable=\"true\" type=\"xs:float\"/>  \n <xs:element name=\"int\" nillable=\"true\" type=\"xs:int\"/>  \n <xs:element name=\"long\" nillable=\"true\" type=\"xs:long\"/>  \n <xs:element name=\"QName\" nillable=\"true\" type=\"xs:QName\"/>  \n <xs:element name=\"short\" nillable=\"true\" type=\"xs:short\"/>  \n <xs:element name=\"string\" nillable=\"true\" type=\"xs:string\"/>  \n <xs:element name=\"unsignedByte\"  \n       nillable=\"true\" type=\"xs:unsignedByte\"/>  \n <xs:element name=\"unsignedInt\"  \n       nillable=\"true\" type=\"xs:unsignedInt\"/>  \n <xs:element name=\"unsignedLong\"  \n       nillable=\"true\" type=\"xs:unsignedLong\"/>  \n <xs:element name=\"unsignedShort\"  \n       nillable=\"true\" type=\"xs:unsignedShort\"/>  \n  \n <!-- Primitive types introduced for certain .NET simple types. -->  \n <xs:element name=\"char\" nillable=\"true\" type=\"tns:char\"/>  \n <xs:simpleType name=\"char\">  \n  <xs:restriction base=\"xs:int\"/>  \n </xs:simpleType>  \n  \n <!-- xs:duration is restricted to an ordered value space,  \n    to map to System.TimeSpan -->  \n <xs:element name=\"duration\" nillable=\"true\" type=\"tns:duration\"/>  \n <xs:simpleType name=\"duration\">  \n  <xs:restriction base=\"xs:duration\">  \n   <xs:pattern   \n     value=\"\\-?P(\\d*D)?(T(\\d*H)?(\\d*M)?(\\d*(\\.\\d*)?S)?)?\"/>  \n   <xs:minInclusive value=\"-P10675199DT2H48M5.4775808S\"/>  \n   <xs:maxInclusive value=\"P10675199DT2H48M5.4775807S\"/>  \n  </xs:restriction>  \n </xs:simpleType>  \n  \n <xs:element name=\"guid\" nillable=\"true\" type=\"tns:guid\"/>  \n <xs:simpleType name=\"guid\">  \n  <xs:restriction base=\"xs:string\">  \n   <xs:pattern value=\"[\\da-fA-F]{8}-[\\da-fA-F]{4}-[\\da-fA-F]{4}-[\\da-fA-F]{4}-[\\da-fA-F]{12}\"/>  \n  </xs:restriction>  \n </xs:simpleType>  \n  \n <!-- This is used for schemas exported from ISerializable type. -->  \n <xs:attribute name=\"FactoryType\" type=\"xs:QName\"/>  \n</xs:schema>  \n```  \n  \n The following should be noted:  \n  \n-   `ser:char` is introduced to represent Unicode characters of type <xref:System.Char>.  \n  \n-   The `valuespace` of `xs:duration` is reduced to an ordered set so that it can be mapped to a <xref:System.TimeSpan>.  \n  \n-   `FactoryType` is used in schemas exported from types that are derived from <xref:System.Runtime.Serialization.ISerializable>.  \n  \n## Importing non-DataContract schemas  \n `DataContractSerializer` has the `ImportXmlTypes` option to allow import of schemas that do not conform to the `DataContractSerializer` XSD profile (see the <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> property). Setting this option to `true` enables acceptance of non-conforming schema types and mapping them to the following implementation, <xref:System.Xml.Serialization.IXmlSerializable> wrapping an array of <xref:System.Xml.XmlNode> (only the class name differs).  \n  \n```csharp  \n[GeneratedCodeAttribute(\"System.Runtime.Serialization\", \"3.0.0.0\")]  \n[System.Xml.Serialization.XmlSchemaProviderAttribute(\"ExportSchema\")]  \n[System.Xml.Serialization.XmlRootAttribute(IsNullable=false)]  \npublic partial class Person : object, IXmlSerializable  \n{    \n  private XmlNode[] nodesField;    \n  private static XmlQualifiedName typeName =   \nnew XmlQualifiedName(\"Person\",\"http://Microsoft.ServiceModel.Samples\");    \n  public XmlNode[] Nodes  \n  {  \n    get {return this.nodesField;}  \n    set {this.nodesField = value;}  \n  }    \n  public void ReadXml(XmlReader reader)  \n  {  \n    this.nodesField = XmlSerializableServices.ReadNodes(reader);  \n  }    \n  public void WriteXml(XmlWriter writer)  \n  {  \n    XmlSerializableServices.WriteNodes(writer, this.Nodes);  \n  }    \n  public System.Xml.Schema.XmlSchema GetSchema()  \n  {  \n    return null;  \n  }    \n  public static XmlQualifiedName ExportSchema(XmlSchemaSet schemas)  \n  {  \n    XmlSerializableServices.AddDefaultSchema(schemas, typeName);  \n    return typeName;  \n  }  \n}  \n```  \n  \n## DateTimeOffset Serialization  \n The <xref:System.DateTimeOffset> is not treated as a primitive type. Instead, it is serialized as a complex element with two parts. The first part represents the date time, and the second part represents the offset from the date time. An example of a serialized DateTimeOffset value is shown in the following code.  \n  \n```xml  \n<OffSet xmlns:a=\"http://schemas.datacontract.org/2004/07/System\">  \n  <DateTime i:type=\"b:dateTime\" xmlns=\"\"   \n    xmlns:b=\"http://www.w3.org/2001/XMLSchema\">2008-08-28T08:00:00    \n  </DateTime>   \n  <OffsetMinutes i:type=\"b:short\" xmlns=\"\"   \n   xmlns:b=\"http://www.w3.org/2001/XMLSchema\">-480  \n   </OffsetMinutes>   \n</OffSet>  \n```  \n  \n The schema is as follows.  \n  \n```xml  \n<xs:schema targetNamespace=\"http://schemas.datacontract.org/2004/07/System\">  \n   <xs:complexType name=\"DateTimeOffset\">  \n      <xs:sequence minOccurs=\"1\" maxOccurs=\"1\">  \n         <xs:element name=\"DateTime\" type=\"xs:dateTime\"  \n         minOccurs=\"1\" maxOccurs=\"1\" />  \n         <xs:element name=\"OffsetMinutes\" type=\"xs:short\"  \n         minOccurs=\"1\" maxOccurs=\"1\" />  \n      </xs:sequence>  \n   </xs:complexType>  \n</xs:schema>  \n```  \n  \n## See also\n\n- <xref:System.Runtime.Serialization.DataContractSerializer>\n- <xref:System.Runtime.Serialization.DataContractAttribute>\n- <xref:System.Runtime.Serialization.DataMemberAttribute>\n- <xref:System.Runtime.Serialization.XsdDataContractImporter>\n- [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)\n","nodes":[{"pos":[4,181],"embed":true,"restype":"x-metadata","content":"title: \"Data Contract Schema Reference\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"data contracts [WCF], schema reference\"\nms.assetid: 9ebb0ebe-8166-4c93-980a-7c8f1f38f7c0","nodes":[{"content":"Data Contract Schema Reference","nodes":[{"pos":[0,30],"content":"Data Contract Schema Reference","nodes":[{"content":"Data Contract Schema Reference","pos":[0,30]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[188,218],"content":"Data Contract Schema Reference","linkify":"Data Contract Schema Reference","nodes":[{"content":"Data Contract Schema Reference","pos":[0,30]}]},{"pos":[219,412],"content":"This topic describes the subset of the XML Schema (XSD) used by <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> to describe common language runtime (CLR) types for XML serialization.","source":"This topic describes the subset of the XML Schema (XSD) used by <xref:System.Runtime.Serialization.DataContractSerializer> to describe common language runtime (CLR) types for XML serialization."},{"pos":[421,452],"content":"DataContractSerializer Mappings","linkify":"DataContractSerializer Mappings","nodes":[{"content":"DataContractSerializer Mappings","pos":[0,31]}]},{"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> maps CLR types to XSD when metadata is exported from a Windows Communication Foundation (WCF) service using a metadata endpoint or the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.","pos":[456,753],"source":"The `DataContractSerializer` maps CLR types to XSD when metadata is exported from a Windows Communication Foundation (WCF) service using a metadata endpoint or the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Data Contract Serializer<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-serializer.md)</ept>.","pos":[754,883],"source":" For more information, see [Data Contract Serializer](../../../../docs/framework/wcf/feature-details/data-contract-serializer.md)."},{"pos":[890,1091],"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> also maps XSD to CLR types when Svcutil.exe is used to access Web Services Description Language (WSDL) or XSD documents and generate data contracts for services or clients.","source":"The `DataContractSerializer` also maps XSD to CLR types when Svcutil.exe is used to access Web Services Description Language (WSDL) or XSD documents and generate data contracts for services or clients."},{"pos":[1098,1235],"content":"Only XML Schema instances that conform to requirements stated in this document can be mapped to CLR types using <ph id=\"ph1\">`DataContractSerializer`</ph>.","source":"Only XML Schema instances that conform to requirements stated in this document can be mapped to CLR types using `DataContractSerializer`."},{"pos":[1245,1259],"content":"Support Levels","linkify":"Support Levels","nodes":[{"content":"Support Levels","pos":[0,14]}]},{"pos":[1263,1364],"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> provides the following levels of support for a given XML Schema feature:","source":"The `DataContractSerializer` provides the following levels of support for a given XML Schema feature:"},{"content":"<bpt id=\"p1\">**</bpt>Supported<ept id=\"p1\">**</ept>.","pos":[1374,1388],"source":"**Supported**."},{"content":"There is explicit mapping from this feature to CLR types or attributes (or both) using <ph id=\"ph1\">`DataContractSerializer`</ph>.","pos":[1389,1501],"source":" There is explicit mapping from this feature to CLR types or attributes (or both) using `DataContractSerializer`."},{"content":"<bpt id=\"p1\">**</bpt>Ignored<ept id=\"p1\">**</ept>.","pos":[1511,1523],"source":"**Ignored**."},{"content":"The feature is allowed in schemas imported by the <ph id=\"ph1\">`DataContractSerializer`</ph>, but has no effect on code generation.","pos":[1524,1637],"source":" The feature is allowed in schemas imported by the `DataContractSerializer`, but has no effect on code generation."},{"content":"<bpt id=\"p1\">**</bpt>Forbidden<ept id=\"p1\">**</ept>.","pos":[1647,1661],"source":"**Forbidden**."},{"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> does not support importing a schema using the feature.","pos":[1662,1745],"source":" The `DataContractSerializer` does not support importing a schema using the feature."},{"content":"For example, Svcutil.exe, when accessing a WSDL with a schema that uses such a feature, falls back to using the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> instead.","pos":[1746,1912],"source":" For example, Svcutil.exe, when accessing a WSDL with a schema that uses such a feature, falls back to using the <xref:System.Xml.Serialization.XmlSerializer> instead."},{"content":"This is by default.","pos":[1913,1932]},{"pos":[1941,1960],"content":"General Information","linkify":"General Information","nodes":[{"content":"General Information","pos":[0,19]}]},{"content":"The schema namespace is described at <bpt id=\"p1\">[</bpt>XML Schema<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=95475)</ept>.","pos":[1970,2067],"source":"The schema namespace is described at [XML Schema](https://go.microsoft.com/fwlink/?LinkId=95475)."},{"content":"The prefix \"xs\" is used in this document.","pos":[2068,2109]},{"content":"Any attributes with a non-schema namespace are ignored.","pos":[2119,2174]},{"content":"Any annotations (except for those described in this document) are ignored.","pos":[2184,2258]},{"pos":[2268,2292],"content":"\\<xs:schema>: attributes","linkify":"\\<xs:schema>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:schema&gt;: attributes","pos":[0,24],"source":"\\<xs:schema>: attributes"}]},{"content":"Attribute","pos":[2299,2308]},{"content":"DataContract","pos":[2309,2321]},{"content":"Ignored.","pos":[2388,2396]},{"content":"Ignored.","pos":[2416,2424]},{"content":"Must be qualified.","pos":[2450,2468]},{"content":"All elements must be qualified for a schema to be supported by <ph id=\"ph1\">`DataContractSerializer`</ph>.","pos":[2469,2557],"source":" All elements must be qualified for a schema to be supported by `DataContractSerializer`."},{"content":"This can be accomplished by either setting <ph id=\"ph1\">xs:schema/@elementFormDefault</ph> to \"qualified\" or by setting <ph id=\"ph2\">xs:element/@form</ph> to \"qualified\" on each individual element declaration.","pos":[2558,2731],"source":" This can be accomplished by either setting xs:schema/@elementFormDefault to \"qualified\" or by setting xs:element/@form to \"qualified\" on each individual element declaration."},{"content":"Ignored.","pos":[2751,2759]},{"content":"Ignored.","pos":[2769,2777]},{"content":"Supported and mapped to the data contract namespace.","pos":[2800,2852]},{"content":"If this attribute is not specified, the blank namespace is used.","pos":[2853,2917]},{"content":"Cannot be the reserved namespace <ph id=\"ph1\">`http://schemas.microsoft.com/2003/10/Serialization/`</ph>.","pos":[2918,3005],"source":" Cannot be the reserved namespace `http://schemas.microsoft.com/2003/10/Serialization/`."},{"content":"Ignored.","pos":[3020,3028]},{"pos":[3039,3061],"content":"\\<xs:schema>: contents","linkify":"\\<xs:schema>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:schema&gt;: contents","pos":[0,22],"source":"\\<xs:schema>: contents"}]},{"content":"Contents","pos":[3068,3076]},{"content":"Schema","pos":[3077,3083]},{"content":"Supported.","pos":[3130,3140]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> supports xs:include and xs:import.","pos":[3141,3200],"source":"`DataContractSerializer` supports xs:include and xs:import."},{"content":"However, Svcutil.exe restricts following <ph id=\"ph1\">`xs:include/@schemaLocation`</ph> and <ph id=\"ph2\">`xs:import/@location`</ph> references when metadata is loaded from a local file.","pos":[3201,3350],"source":" However, Svcutil.exe restricts following `xs:include/@schemaLocation` and `xs:import/@location` references when metadata is loaded from a local file."},{"content":"The list of schema files must be passed through an out-of-band mechanism and not through <ph id=\"ph1\">`include`</ph> in this case; <ph id=\"ph2\">`include`</ph>d schema documents are ignored.","pos":[3351,3504],"source":" The list of schema files must be passed through an out-of-band mechanism and not through `include` in this case; `include`d schema documents are ignored."},{"content":"Forbidden.","pos":[3520,3530]},{"content":"The use of <ph id=\"ph1\">`xs:redefine`</ph> is forbidden by <ph id=\"ph2\">`DataContractSerializer`</ph> for security reasons: <ph id=\"ph3\">`x:redefine`</ph> requires <ph id=\"ph4\">`schemaLocation`</ph> to be followed.","pos":[3531,3673],"source":" The use of `xs:redefine` is forbidden by `DataContractSerializer` for security reasons: `x:redefine` requires `schemaLocation` to be followed."},{"content":"In certain circumstances, Svcutil.exe using DataContract restricts use of <ph id=\"ph1\">`schemaLocation`</ph>.","pos":[3674,3765],"source":" In certain circumstances, Svcutil.exe using DataContract restricts use of `schemaLocation`."},{"content":"Supported.","pos":[3779,3789]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> supports <ph id=\"ph2\">`xs:include`</ph> and <ph id=\"ph3\">`xs:import`</ph>.","pos":[3790,3853],"source":"`DataContractSerializer` supports `xs:include` and `xs:import`."},{"content":"However, Svcutil.exe restricts following <ph id=\"ph1\">`xs:include/@schemaLocation`</ph> and <ph id=\"ph2\">`xs:import/@location`</ph> references when metadata is loaded from a local file.","pos":[3854,4003],"source":" However, Svcutil.exe restricts following `xs:include/@schemaLocation` and `xs:import/@location` references when metadata is loaded from a local file."},{"content":"The list of schema files must be passed through an out-of-band mechanism and not through <ph id=\"ph1\">`include`</ph> in this case; <ph id=\"ph2\">`include`</ph>d schema documents are ignored.","pos":[4004,4157],"source":" The list of schema files must be passed through an out-of-band mechanism and not through `include` in this case; `include`d schema documents are ignored."},{"content":"Supported.","pos":[4175,4185]},{"content":"See the <ph id=\"ph1\">`xs:simpleType`</ph> section.","pos":[4186,4218],"source":" See the `xs:simpleType` section."},{"content":"Supported, maps to data contracts.","pos":[4237,4271]},{"content":"See the <ph id=\"ph1\">`xs:complexType`</ph> section.","pos":[4272,4305],"source":" See the `xs:complexType` section."},{"content":"Ignored.","pos":[4318,4326]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> does not support use of <ph id=\"ph2\">`xs:group`</ph>, <ph id=\"ph3\">`xs:attributeGroup`</ph>, and <ph id=\"ph4\">`xs:attribute`</ph>.","pos":[4327,4428],"source":"`DataContractSerializer` does not support use of `xs:group`, `xs:attributeGroup`, and `xs:attribute`."},{"content":"These declarations are ignored as children of <ph id=\"ph1\">`xs:schema`</ph>, but cannot be referenced from within <ph id=\"ph2\">`complexType`</ph> or other supported constructs.","pos":[4429,4569],"source":" These declarations are ignored as children of `xs:schema`, but cannot be referenced from within `complexType` or other supported constructs."},{"content":"Ignored.","pos":[4591,4599]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> does not support use of <ph id=\"ph2\">`xs:group`</ph>, <ph id=\"ph3\">`xs:attributeGroup`</ph>, and <ph id=\"ph4\">`xs:attribute`</ph>.","pos":[4600,4701],"source":"`DataContractSerializer` does not support use of `xs:group`, `xs:attributeGroup`, and `xs:attribute`."},{"content":"These declarations are ignored as children of <ph id=\"ph1\">`xs:schema`</ph>, but cannot be referenced from within <ph id=\"ph2\">`complexType`</ph> or other supported constructs.","pos":[4702,4842],"source":" These declarations are ignored as children of `xs:schema`, but cannot be referenced from within `complexType` or other supported constructs."},{"content":"Supported.","pos":[4857,4867]},{"content":"See Global Element Declaration (GED).","pos":[4868,4905]},{"content":"Ignored.","pos":[4922,4930]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> does not support use of <ph id=\"ph2\">`xs:group`</ph>, <ph id=\"ph3\">`xs:attributeGroup`</ph>, and <ph id=\"ph4\">`xs:attribute`</ph>.","pos":[4931,5032],"source":"`DataContractSerializer` does not support use of `xs:group`, `xs:attributeGroup`, and `xs:attribute`."},{"content":"These declarations are ignored as children of <ph id=\"ph1\">`xs:schema`</ph>, but cannot be referenced from within <ph id=\"ph2\">`complexType`</ph> or other supported constructs.","pos":[5033,5173],"source":" These declarations are ignored as children of `xs:schema`, but cannot be referenced from within `complexType` or other supported constructs."},{"content":"Ignored.","pos":[5189,5197]},{"pos":[5207,5240],"content":"Complex Types – \\<xs:complexType>","linkify":"Complex Types – \\<xs:complexType>","nodes":[{"content":"Complex Types – <ph id=\"ph1\">\\&lt;</ph>xs:complexType&gt;","pos":[0,33],"source":"Complex Types – \\<xs:complexType>"}]},{"pos":[5250,5269],"content":"General Information","linkify":"General Information","nodes":[{"content":"General Information","pos":[0,19]}]},{"content":"Each complex type <ph id=\"ph1\">\\&lt;</ph>xs:complexType&gt; maps to a data contract.","pos":[5273,5333],"source":"Each complex type \\<xs:complexType> maps to a data contract."},{"pos":[5343,5372],"content":"\\<xs:complexType>: attributes","linkify":"\\<xs:complexType>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:complexType&gt;: attributes","pos":[0,29],"source":"\\<xs:complexType>: attributes"}]},{"content":"Attribute","pos":[5379,5388]},{"content":"Schema","pos":[5389,5395]},{"content":"Must be false (default).","pos":[5444,5468]},{"content":"Forbidden.","pos":[5481,5491]},{"content":"Ignored.","pos":[5504,5512]},{"content":"Ignored.","pos":[5522,5530]},{"content":"Must be false (default).","pos":[5543,5567]},{"content":"Supported and mapped to the data contract name.","pos":[5579,5626]},{"content":"If there are periods in the name, an attempt is made to map the type to an inner type.","pos":[5627,5713]},{"content":"For example, a complex type named <ph id=\"ph1\">`A.B`</ph> maps to a data contract type that is an inner type of a type with the data contract name <ph id=\"ph2\">`A`</ph>, but only if such a data contract type exists.","pos":[5714,5893],"source":" For example, a complex type named `A.B` maps to a data contract type that is an inner type of a type with the data contract name `A`, but only if such a data contract type exists."},{"content":"More than one level of nesting is possible: for example, <ph id=\"ph1\">`A.B.C`</ph> can be an inner type, but only if <ph id=\"ph2\">`A`</ph> and <ph id=\"ph3\">`A.B`</ph> both exist.","pos":[5894,6018],"source":" More than one level of nesting is possible: for example, `A.B.C` can be an inner type, but only if `A` and `A.B` both exist."},{"pos":[6029,6056],"content":"\\<xs:complexType>: contents","linkify":"\\<xs:complexType>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:complexType&gt;: contents","pos":[0,27],"source":"\\<xs:complexType>: contents"}]},{"content":"Contents","pos":[6063,6071]},{"content":"Schema","pos":[6072,6078]},{"content":"Extensions are forbidden.","pos":[6131,6156]},{"content":"Restriction is allowed only from <ph id=\"ph1\">`anySimpleType`</ph>.","pos":[6169,6218],"source":"Restriction is allowed only from `anySimpleType`."},{"content":"Supported.","pos":[6240,6250]},{"content":"See \"Inheritance\".","pos":[6251,6269]},{"content":"Forbidden.","pos":[6282,6292]},{"content":"Forbidden.","pos":[6303,6313]},{"content":"Forbidden","pos":[6327,6336]},{"content":"Supported, maps to data members of a data contract.","pos":[6352,6403]},{"content":"Forbidden, even if use=\"prohibited\" (with one exception).","pos":[6420,6477]},{"content":"Only optional attributes from the Standard Serialization Schema namespace are supported.","pos":[6478,6566]},{"content":"They do not map to data members in the data contract programming model.","pos":[6567,6638]},{"content":"Currently, only one such attribute has meaning and is discussed in the ISerializable section.","pos":[6639,6732]},{"content":"All others are ignored.","pos":[6733,6756]},{"content":"Forbidden.","pos":[6778,6788]},{"content":"In the WCF v1 release, <ph id=\"ph1\">`DataContractSerializer`</ph> ignores the presence of <ph id=\"ph2\">`attributeGroup`</ph> inside <ph id=\"ph3\">`xs:complexType`</ph>.","pos":[6789,6902],"source":" In the WCF v1 release, `DataContractSerializer` ignores the presence of `attributeGroup` inside `xs:complexType`."},{"content":"Forbidden.","pos":[6922,6932]},{"content":"(empty)","pos":[6937,6944]},{"content":"Maps to a data contract with no data members.","pos":[6945,6990]},{"pos":[7001,7045],"content":"\\<xs:sequence> in a complex type: attributes","linkify":"\\<xs:sequence> in a complex type: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:sequence&gt; in a complex type: attributes","pos":[0,44],"source":"\\<xs:sequence> in a complex type: attributes"}]},{"content":"Attribute","pos":[7052,7061]},{"content":"Schema","pos":[7062,7068]},{"content":"Ignored.","pos":[7111,7119]},{"content":"Must be 1 (default).","pos":[7136,7156]},{"content":"Must be 1 (default).","pos":[7173,7193]},{"pos":[7204,7246],"content":"\\<xs:sequence> in a complex type: contents","linkify":"\\<xs:sequence> in a complex type: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:sequence&gt; in a complex type: contents","pos":[0,42],"source":"\\<xs:sequence> in a complex type: contents"}]},{"content":"Contents","pos":[7253,7261]},{"content":"Schema","pos":[7262,7268]},{"content":"Each instance maps to a data member.","pos":[7315,7351]},{"content":"Forbidden.","pos":[7364,7374]},{"content":"Forbidden.","pos":[7388,7398]},{"content":"Forbidden.","pos":[7414,7424]},{"content":"Forbidden.","pos":[7435,7445]},{"content":"(empty)","pos":[7450,7457]},{"content":"Maps to a data contract with no data members.","pos":[7458,7503]},{"pos":[7513,7537],"content":"Elements – \\<xs:element>","linkify":"Elements – \\<xs:element>","nodes":[{"content":"Elements – <ph id=\"ph1\">\\&lt;</ph>xs:element&gt;","pos":[0,24],"source":"Elements – \\<xs:element>"}]},{"pos":[7547,7566],"content":"General Information","linkify":"General Information","nodes":[{"content":"General Information","pos":[0,19]}]},{"pos":[7570,7621],"content":"<ph id=\"ph1\">`&lt;xs:element&gt;`</ph> can occur in the following contexts:","source":"`<xs:element>` can occur in the following contexts:"},{"content":"It can occur within an <ph id=\"ph1\">`&lt;xs:sequence&gt;`</ph>, which describes a data member of a regular (non-collection) data contract.","pos":[7631,7745],"source":"It can occur within an `<xs:sequence>`, which describes a data member of a regular (non-collection) data contract."},{"content":"In this case, the <ph id=\"ph1\">`maxOccurs`</ph> attribute must be 1.","pos":[7746,7796],"source":" In this case, the `maxOccurs` attribute must be 1."},{"content":"(A value of 0 is not allowed).","pos":[7797,7827]},{"content":"It can occur within an <ph id=\"ph1\">`&lt;xs:sequence&gt;`</ph>, which describes a data member of a collection data contract.","pos":[7837,7937],"source":"It can occur within an `<xs:sequence>`, which describes a data member of a collection data contract."},{"content":"In this case, the <ph id=\"ph1\">`maxOccurs`</ph> attribute must be greater than 1 or \"unbounded\".","pos":[7938,8016],"source":" In this case, the `maxOccurs` attribute must be greater than 1 or \"unbounded\"."},{"pos":[8026,8101],"content":"It can occur within an <ph id=\"ph1\">`&lt;xs:schema&gt;`</ph> as a Global Element Declaration (GED).","source":"It can occur within an `<xs:schema>` as a Global Element Declaration (GED)."},{"pos":[8111,8181],"content":"\\<xs:element> with maxOccurs=1 within an \\<xs:sequence> (Data Members)","linkify":"\\<xs:element> with maxOccurs=1 within an \\<xs:sequence> (Data Members)","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:element&gt; with maxOccurs=1 within an <ph id=\"ph2\">\\&lt;</ph>xs:sequence&gt; (Data Members)","pos":[0,70],"source":"\\<xs:element> with maxOccurs=1 within an \\<xs:sequence> (Data Members)"}]},{"content":"Attribute","pos":[8188,8197]},{"content":"Schema","pos":[8198,8204]},{"content":"Forbidden.","pos":[8248,8258]},{"content":"Supported, maps to the data member name.","pos":[8270,8310]},{"content":"Supported, maps to the data member type.","pos":[8322,8362]},{"content":"For more information, see Type/primitive mapping.","pos":[8363,8412]},{"content":"If not specified (and the element does not contain an anonymous type), <ph id=\"ph1\">`xs:anyType`</ph> is assumed.","pos":[8413,8508],"source":" If not specified (and the element does not contain an anonymous type), `xs:anyType` is assumed."},{"content":"Ignored.","pos":[8521,8529]},{"content":"Forbidden.","pos":[8544,8554]},{"content":"Forbidden.","pos":[8567,8577]},{"content":"Must be qualified.","pos":[8589,8607]},{"content":"This attribute can be set through <ph id=\"ph1\">`elementFormDefault`</ph> on <ph id=\"ph2\">`xs:schema`</ph>.","pos":[8608,8678],"source":" This attribute can be set through `elementFormDefault` on `xs:schema`."},{"content":"Ignored.","pos":[8688,8696]},{"content":"1","pos":[8713,8714]},{"pos":[8731,8884],"content":"Maps to the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> property of a data member (<ph id=\"ph2\">`IsRequired`</ph> is true when <ph id=\"ph3\">`minOccurs`</ph> is 1).","source":"Maps to the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of a data member (`IsRequired` is true when `minOccurs` is 1)."},{"content":"Affects type mapping.","pos":[8900,8921]},{"content":"See Type/primitive mapping.","pos":[8922,8949]},{"pos":[8960,9029],"content":"\\<xs:element> with maxOccurs>1 within an \\<xs:sequence> (Collections)","linkify":"\\<xs:element> with maxOccurs>1 within an \\<xs:sequence> (Collections)","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:element&gt; with maxOccurs&gt;1 within an <ph id=\"ph2\">\\&lt;</ph>xs:sequence&gt; (Collections)","pos":[0,69],"source":"\\<xs:element> with maxOccurs>1 within an \\<xs:sequence> (Collections)"}]},{"pos":[9039,9117],"content":"Maps to a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute&gt;</ph>.","source":"Maps to a <xref:System.Runtime.Serialization.CollectionDataContractAttribute>."},{"content":"In collection types, only one xs:element is allowed within an xs:sequence.","pos":[9127,9201]},{"content":"Collections can be of the following types:","pos":[9208,9250]},{"content":"Regular collections (for example, arrays).","pos":[9260,9302]},{"pos":[9312,9418],"content":"Dictionary collections (mapping one value to another; for example, a <ph id=\"ph1\">&lt;xref:System.Collections.Hashtable&gt;</ph>).","source":"Dictionary collections (mapping one value to another; for example, a <xref:System.Collections.Hashtable>)."},{"content":"The only difference between a dictionary and an array of a key/value pair type is in the generated programming model.","pos":[9428,9545]},{"content":"There is a schema annotation mechanism that can be used to indicate that a given type is a dictionary collection.","pos":[9546,9659]},{"content":"The rules for the <ph id=\"ph1\">`ref`</ph>, <ph id=\"ph2\">`block`</ph>, <ph id=\"ph3\">`default`</ph>, <ph id=\"ph4\">`fixed`</ph>, <ph id=\"ph5\">`form`</ph>, and <ph id=\"ph6\">`id`</ph> attributes are the same as for the non-collection case.","pos":[9666,9792],"source":"The rules for the `ref`, `block`, `default`, `fixed`, `form`, and `id` attributes are the same as for the non-collection case."},{"content":"Other attributes include those in the following table.","pos":[9793,9847]},{"content":"Attribute","pos":[9854,9863]},{"content":"Schema","pos":[9864,9870]},{"pos":[9915,10078],"content":"Supported, maps to the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A&gt;</ph> property in the <ph id=\"ph2\">`CollectionDataContractAttribute`</ph> attribute.","source":"Supported, maps to the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property in the `CollectionDataContractAttribute` attribute."},{"content":"Supported, maps to the type stored in the collection.","pos":[10090,10143]},{"content":"Greater than 1 or \"unbounded\".","pos":[10160,10190]},{"content":"The DC schema should use \"unbounded\".","pos":[10191,10228]},{"content":"Ignored.","pos":[10245,10253]},{"content":"Affects type mapping.","pos":[10269,10290]},{"content":"This attribute is ignored for dictionary collections.","pos":[10291,10344]},{"pos":[10355,10418],"content":"\\<xs:element> within an \\<xs:schema> Global Element Declaration","linkify":"\\<xs:element> within an \\<xs:schema> Global Element Declaration","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:element&gt; within an <ph id=\"ph2\">\\&lt;</ph>xs:schema&gt; Global Element Declaration","pos":[0,63],"source":"\\<xs:element> within an \\<xs:schema> Global Element Declaration"}]},{"content":"A Global Element Declaration (GED) that has the same name and namespace as a type in schema, or that defines an anonymous type inside itself, is said to be associated with the type.","pos":[10428,10609]},{"content":"Schema export: associated GEDs are generated for every generated type, both simple and complex.","pos":[10619,10714]},{"content":"Deserialization/serialization: associated GEDs are used as root elements for the type.","pos":[10724,10810]},{"content":"Schema import: associated GEDs are not required and are ignored if they follow the following rules (unless they define types).","pos":[10820,10946]},{"content":"Attribute","pos":[10953,10962]},{"content":"Schema","pos":[10963,10969]},{"content":"Must be false for associated GEDs.","pos":[11018,11052]},{"content":"Forbidden in associated GEDs.","pos":[11065,11094]},{"content":"Forbidden in associated GEDs.","pos":[11109,11138]},{"content":"Must be false for associated GEDs.","pos":[11151,11185]},{"content":"Forbidden in associated GEDs.","pos":[11198,11227]},{"content":"Ignored.","pos":[11237,11245]},{"content":"Supported.","pos":[11257,11267]},{"content":"See the definition of associated GEDs.","pos":[11268,11306]},{"content":"Must be true for associated GEDs.","pos":[11322,11355]},{"content":"Forbidden in associated GEDs.","pos":[11380,11409]},{"content":"Supported, and must match the associated type for associated GEDs (unless the element contains an anonymous type).","pos":[11421,11535]},{"pos":[11546,11569],"content":"\\<xs:element>: contents","linkify":"\\<xs:element>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:element&gt;: contents","pos":[0,23],"source":"\\<xs:element>: contents"}]},{"content":"Contents","pos":[11576,11584]},{"content":"Schema","pos":[11585,11591]},{"content":"Supported.*","pos":[11641,11652]},{"content":"Supported.*","pos":[11671,11682]},{"content":"Ignored.","pos":[11696,11704]},{"content":"Ignored.","pos":[11715,11723]},{"content":"Ignored.","pos":[11737,11745]},{"content":"(blank)","pos":[11750,11757]},{"content":"Supported.","pos":[11758,11768]},{"content":"<ph id=\"ph1\">\\*</ph> When using the <ph id=\"ph2\">`simpleType`</ph> and <ph id=\"ph3\">`complexType,`</ph> mapping for anonymous types is the same as for non-anonymous types, except that there is no anonymous data contracts, and so a named data contract is created, with a generated name derived from the element name.","pos":[11776,12037],"source":"\\* When using the `simpleType` and `complexType,` mapping for anonymous types is the same as for non-anonymous types, except that there is no anonymous data contracts, and so a named data contract is created, with a generated name derived from the element name."},{"content":"The rules for anonymous types are in the following list:","pos":[12038,12094]},{"content":"WCF implementation detail: If the <ph id=\"ph1\">`xs:element`</ph> name does not contain periods, the anonymous type maps to an inner type of the outer data contract type.","pos":[12104,12255],"source":"WCF implementation detail: If the `xs:element` name does not contain periods, the anonymous type maps to an inner type of the outer data contract type."},{"content":"If the name contains periods, the resulting data contract type is independent (not an inner type).","pos":[12256,12354]},{"content":"The generated data contract name of the inner type is the data contract name of the outer type followed by a period, the name of the element, and the string \"Type\".","pos":[12364,12528]},{"content":"If a data contract with such a name already exists, the name is made unique by appending \"1\", \"2\", \"3\", and so on until a unique name is created.","pos":[12538,12683]},{"pos":[12692,12723],"content":"Simple Types - \\<xs:simpleType>","linkify":"Simple Types - \\<xs:simpleType>","nodes":[{"content":"Simple Types - <ph id=\"ph1\">\\&lt;</ph>xs:simpleType&gt;","pos":[0,31],"source":"Simple Types - \\<xs:simpleType>"}]},{"pos":[12733,12761],"content":"\\<xs:simpleType>: attributes","linkify":"\\<xs:simpleType>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:simpleType&gt;: attributes","pos":[0,28],"source":"\\<xs:simpleType>: attributes"}]},{"content":"Attribute","pos":[12768,12777]},{"content":"Schema","pos":[12778,12784]},{"content":"Ignored.","pos":[12830,12838]},{"content":"Ignored.","pos":[12848,12856]},{"content":"Supported, maps to the data contract name.","pos":[12868,12910]},{"pos":[12921,12947],"content":"\\<xs:simpleType>: contents","linkify":"\\<xs:simpleType>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:simpleType&gt;: contents","pos":[0,26],"source":"\\<xs:simpleType>: contents"}]},{"content":"Contents","pos":[12954,12962]},{"content":"Schema","pos":[12963,12969]},{"content":"Supported.","pos":[13020,13030]},{"content":"Maps to enumeration data contracts.","pos":[13031,13066]},{"content":"This attribute is ignored if it does not match the enumeration pattern.","pos":[13067,13138]},{"content":"See the <ph id=\"ph1\">`xs:simpleType`</ph> restrictions section.","pos":[13139,13184],"source":" See the `xs:simpleType` restrictions section."},{"content":"Supported.","pos":[13196,13206]},{"content":"Maps to flag enumeration data contracts.","pos":[13207,13247]},{"content":"See the <ph id=\"ph1\">`xs:simpleType`</ph> lists section.","pos":[13248,13286],"source":" See the `xs:simpleType` lists section."},{"content":"Forbidden.","pos":[13299,13309]},{"pos":[13320,13337],"content":"\\<xs:restriction>","linkify":"\\<xs:restriction>","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:restriction&gt;","pos":[0,17],"source":"\\<xs:restriction>"}]},{"pos":[13347,13416],"content":"Complex type restrictions are supported only for base=\"<ph id=\"ph1\">`xs:anyType`</ph>\".","source":"Complex type restrictions are supported only for base=\"`xs:anyType`\"."},{"pos":[13426,13575],"content":"Simple type restrictions of <ph id=\"ph1\">`xs:string`</ph> that do not have any restriction facets other than <ph id=\"ph2\">`xs:enumeration`</ph> are mapped to enumeration data contracts.","source":"Simple type restrictions of `xs:string` that do not have any restriction facets other than `xs:enumeration` are mapped to enumeration data contracts."},{"content":"All other simple type restrictions are mapped to the types they restrict.","pos":[13585,13658]},{"content":"For example, a restriction of <ph id=\"ph1\">`xs:int`</ph> maps to an integer, just as <ph id=\"ph2\">`xs:int`</ph> itself does.","pos":[13659,13747],"source":" For example, a restriction of `xs:int` maps to an integer, just as `xs:int` itself does."},{"content":"For more information about primitive type mapping, see Type/primitive mapping.","pos":[13748,13826]},{"pos":[13836,13865],"content":"\\<xs:restriction>: attributes","linkify":"\\<xs:restriction>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:restriction&gt;: attributes","pos":[0,29],"source":"\\<xs:restriction>: attributes"}]},{"content":"Attribute","pos":[13872,13881]},{"content":"Schema","pos":[13882,13888]},{"pos":[13933,13981],"content":"Must be a supported simple type or <ph id=\"ph1\">`xs:anyType`</ph>.","source":"Must be a supported simple type or `xs:anyType`."},{"content":"Ignored.","pos":[13991,13999]},{"pos":[14010,14057],"content":"\\<xs:restriction> for all other cases: contents","linkify":"\\<xs:restriction> for all other cases: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:restriction&gt; for all other cases: contents","pos":[0,47],"source":"\\<xs:restriction> for all other cases: contents"}]},{"content":"Contents","pos":[14064,14072]},{"content":"Schema","pos":[14073,14079]},{"content":"If present, must be derived from a supported primitive type.","pos":[14129,14189]},{"content":"Ignored.","pos":[14209,14217]},{"content":"Ignored.","pos":[14237,14245]},{"content":"Ignored.","pos":[14265,14273]},{"content":"Ignored.","pos":[14293,14301]},{"content":"Ignored.","pos":[14320,14328]},{"content":"Ignored.","pos":[14350,14358]},{"content":"Ignored.","pos":[14372,14380]},{"content":"Ignored.","pos":[14397,14405]},{"content":"Ignored.","pos":[14422,14430]},{"content":"Ignored.","pos":[14449,14457]},{"content":"Ignored.","pos":[14475,14483]},{"content":"Ignored.","pos":[14498,14506]},{"content":"(blank)","pos":[14511,14518]},{"content":"Supported.","pos":[14519,14529]},{"pos":[14539,14550],"content":"Enumeration","linkify":"Enumeration","nodes":[{"content":"Enumeration","pos":[0,11]}]},{"pos":[14560,14606],"content":"\\<xs:restriction> for enumerations: attributes","linkify":"\\<xs:restriction> for enumerations: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:restriction&gt; for enumerations: attributes","pos":[0,46],"source":"\\<xs:restriction> for enumerations: attributes"}]},{"content":"Attribute","pos":[14613,14622]},{"content":"Schema","pos":[14623,14629]},{"pos":[14674,14706],"content":"If present, must be <ph id=\"ph1\">`xs:string`</ph>.","source":"If present, must be `xs:string`."},{"content":"Ignored.","pos":[14716,14724]},{"pos":[14735,14779],"content":"\\<xs:restriction> for enumerations: contents","linkify":"\\<xs:restriction> for enumerations: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:restriction&gt; for enumerations: contents","pos":[0,44],"source":"\\<xs:restriction> for enumerations: contents"}]},{"content":"Contents","pos":[14786,14794]},{"content":"Schema","pos":[14795,14801]},{"content":"If present, must be an enumeration restriction supported by the data contract (this section).","pos":[14851,14944]},{"content":"Ignored.","pos":[14964,14972]},{"content":"Ignored.","pos":[14992,15000]},{"content":"Ignored.","pos":[15020,15028]},{"content":"Ignored.","pos":[15048,15056]},{"content":"Ignored.","pos":[15075,15083]},{"content":"Ignored.","pos":[15105,15113]},{"content":"Forbidden.","pos":[15127,15137]},{"content":"Forbidden.","pos":[15154,15164]},{"content":"Forbidden.","pos":[15181,15191]},{"content":"Supported.","pos":[15210,15220]},{"content":"Enumeration \"id\" is ignored, and \"value\" maps to the value name in the enumeration data contract.","pos":[15221,15318]},{"content":"Forbidden.","pos":[15336,15346]},{"content":"Forbidden.","pos":[15361,15371]},{"content":"(empty)","pos":[15376,15383]},{"content":"Supported, maps to empty enumeration type.","pos":[15384,15426]},{"content":"The following code shows a C# enumeration class.","pos":[15434,15482]},{"content":"This class maps to the following schema by the <ph id=\"ph1\">`DataContractSerializer`</ph>.","pos":[15583,15655],"source":"This class maps to the following schema by the `DataContractSerializer`."},{"content":"If enumeration values start from 1, <ph id=\"ph1\">`xs:annotation`</ph> blocks are not generated.","pos":[15656,15733],"source":" If enumeration values start from 1, `xs:annotation` blocks are not generated."},{"pos":[16391,16401],"content":"\\<xs:list>","linkify":"\\<xs:list>","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:list&gt;","pos":[0,10],"source":"\\<xs:list>"}]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> maps enumeration types marked with <ph id=\"ph2\">`System.FlagsAttribute`</ph> to <ph id=\"ph3\">`xs:list`</ph> derived from <ph id=\"ph4\">`xs:string`</ph>.","pos":[16405,16527],"source":"`DataContractSerializer` maps enumeration types marked with `System.FlagsAttribute` to `xs:list` derived from `xs:string`."},{"content":"No other <ph id=\"ph1\">`xs:list`</ph> variations are supported.","pos":[16528,16572],"source":" No other `xs:list` variations are supported."},{"pos":[16582,16604],"content":"\\<xs:list>: attributes","linkify":"\\<xs:list>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:list&gt;: attributes","pos":[0,22],"source":"\\<xs:list>: attributes"}]},{"content":"Attribute","pos":[16611,16620]},{"content":"Schema","pos":[16621,16627]},{"content":"Forbidden.","pos":[16676,16686]},{"content":"Ignored.","pos":[16696,16704]},{"pos":[16715,16735],"content":"\\<xs:list>: contents","linkify":"\\<xs:list>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:list&gt;: contents","pos":[0,20],"source":"\\<xs:list>: contents"}]},{"content":"Contents","pos":[16742,16750]},{"content":"Schema","pos":[16751,16757]},{"pos":[16807,16873],"content":"Must be restriction from <ph id=\"ph1\">`xs:string`</ph> using <ph id=\"ph2\">`xs:enumeration`</ph> facet.","source":"Must be restriction from `xs:string` using `xs:enumeration` facet."},{"pos":[16881,17047],"content":"If enumeration value does not follow a power of 2 progression (default for Flags), the value is stored in the <ph id=\"ph1\">`xs:annotation/xs:appInfo/ser:EnumerationValue`</ph> element.","source":"If enumeration value does not follow a power of 2 progression (default for Flags), the value is stored in the `xs:annotation/xs:appInfo/ser:EnumerationValue` element."},{"content":"For example, the following code flags an enumeration type.","pos":[17054,17112]},{"content":"This type maps to the following schema.","pos":[17290,17329]},{"pos":[18358,18369],"content":"Inheritance","linkify":"Inheritance","nodes":[{"content":"Inheritance","pos":[0,11]}]},{"pos":[18379,18392],"content":"General rules","linkify":"General rules","nodes":[{"content":"General rules","pos":[0,13]}]},{"content":"A data contract can inherit from another data contract.","pos":[18396,18451]},{"content":"Such data contracts map to a base and are derived by extension types using the <ph id=\"ph1\">`&lt;xs:extension&gt;`</ph> XML Schema construct.","pos":[18452,18569],"source":" Such data contracts map to a base and are derived by extension types using the `<xs:extension>` XML Schema construct."},{"content":"A data contract cannot inherit from a collection data contract.","pos":[18576,18639]},{"content":"For example, the following code is a data contract.","pos":[18646,18697]},{"content":"This data contract maps to the following XML Schema type declaration.","pos":[18912,18981]},{"pos":[19451,19483],"content":"\\<xs:complexContent>: attributes","linkify":"\\<xs:complexContent>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:complexContent&gt;: attributes","pos":[0,32],"source":"\\<xs:complexContent>: attributes"}]},{"content":"Attribute","pos":[19490,19499]},{"content":"Schema","pos":[19500,19506]},{"content":"Ignored.","pos":[19549,19557]},{"content":"Must be false.","pos":[19570,19584]},{"pos":[19595,19625],"content":"\\<xs:complexContent>: contents","linkify":"\\<xs:complexContent>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:complexContent&gt;: contents","pos":[0,30],"source":"\\<xs:complexContent>: contents"}]},{"content":"Contents","pos":[19632,19640]},{"content":"Schema","pos":[19641,19647]},{"content":"Forbidden, except when base=\"<ph id=\"ph1\">`xs:anyType`</ph>\".","pos":[19698,19741],"source":"Forbidden, except when base=\"`xs:anyType`\"."},{"content":"The latter is equivalent to placing the content of the <ph id=\"ph1\">`xs:restriction`</ph> directly under the container of the <ph id=\"ph2\">`xs:complexContent`</ph>.","pos":[19742,19870],"source":" The latter is equivalent to placing the content of the `xs:restriction` directly under the container of the `xs:complexContent`."},{"content":"Supported.","pos":[19887,19897]},{"content":"Maps to data contract inheritance.","pos":[19898,19932]},{"pos":[19943,19994],"content":"\\<xs:extension> in \\<xs:complexContent>: attributes","linkify":"\\<xs:extension> in \\<xs:complexContent>: attributes","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:extension&gt; in <ph id=\"ph2\">\\&lt;</ph>xs:complexContent&gt;: attributes","pos":[0,51],"source":"\\<xs:extension> in \\<xs:complexContent>: attributes"}]},{"content":"Attribute","pos":[20001,20010]},{"content":"Schema","pos":[20011,20017]},{"content":"Ignored.","pos":[20060,20068]},{"content":"Supported.","pos":[20080,20090]},{"content":"Maps to the base data contract type that this type inherits from.","pos":[20091,20156]},{"pos":[20167,20216],"content":"\\<xs:extension> in \\<xs:complexContent>: contents","linkify":"\\<xs:extension> in \\<xs:complexContent>: contents","nodes":[{"content":"<ph id=\"ph1\">\\&lt;</ph>xs:extension&gt; in <ph id=\"ph2\">\\&lt;</ph>xs:complexContent&gt;: contents","pos":[0,49],"source":"\\<xs:extension> in \\<xs:complexContent>: contents"}]},{"pos":[20220,20278],"content":"The rules are the same as for <ph id=\"ph1\">`&lt;xs:complexType&gt;`</ph> contents.","source":"The rules are the same as for `<xs:complexType>` contents."},{"pos":[20285,20417],"content":"If an <ph id=\"ph1\">`&lt;xs:sequence&gt;`</ph> is provided, its member elements map to additional data members that are present in the derived data contract.","source":"If an `<xs:sequence>` is provided, its member elements map to additional data members that are present in the derived data contract."},{"content":"If a derived type contains an element with the same name as an element in a base type, the duplicate element declaration maps to a data member with a name that is generated to be unique.","pos":[20424,20610]},{"content":"Positive integer numbers are added to the data member name (\"member1\", \"member2\", and so on) until a unique name is found.","pos":[20611,20733]},{"content":"Conversely:","pos":[20734,20745]},{"pos":[20755,20952],"content":"If a derived data contract has a data member with the same name and type as a data member in a base data contract, <ph id=\"ph1\">`DataContractSerializer`</ph> generates this corresponding element in the derived type.","source":"If a derived data contract has a data member with the same name and type as a data member in a base data contract, `DataContractSerializer` generates this corresponding element in the derived type."},{"content":"If a derived data contract has a data member with the same name as a data member in a base data contract but a different type, the <ph id=\"ph1\">`DataContractSerializer`</ph> imports a schema with an element of the type <ph id=\"ph2\">`xs:anyType`</ph> in both base type and derived type declarations.","pos":[20962,21224],"source":"If a derived data contract has a data member with the same name as a data member in a base data contract but a different type, the `DataContractSerializer` imports a schema with an element of the type `xs:anyType` in both base type and derived type declarations."},{"content":"The original type name is preserved in <ph id=\"ph1\">`xs:annotations/xs:appInfo/ser:ActualType/@Name`</ph>.","pos":[21225,21313],"source":" The original type name is preserved in `xs:annotations/xs:appInfo/ser:ActualType/@Name`."},{"content":"Both variations may lead to a schema with an ambiguous content model, which depends on the order of the respective data members.","pos":[21320,21448]},{"pos":[21457,21479],"content":"Type/primitive mapping","linkify":"Type/primitive mapping","nodes":[{"content":"Type/primitive mapping","pos":[0,22]}]},{"pos":[21483,21570],"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> uses the following mapping for XML Schema primitive types.","source":"The `DataContractSerializer` uses the following mapping for XML Schema primitive types."},{"content":"XSD type","pos":[21577,21585]},{"content":".NET type","pos":[21586,21595]},{"pos":[21645,21666],"content":"<ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","source":"<xref:System.Object>."},{"pos":[21687,21708],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[21724,21747],"content":"<ph id=\"ph1\">&lt;xref:System.TimeSpan&gt;</ph>.","source":"<xref:System.TimeSpan>."},{"pos":[21763,21786],"content":"<ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph>.","source":"<xref:System.DateTime>."},{"content":"<ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.TimeSpan&gt;</ph> for the offset.","pos":[21808,21873],"source":"<xref:System.DateTime> and <xref:System.TimeSpan> for the offset."},{"content":"See DateTimeOffset Serialization below.","pos":[21874,21913]},{"pos":[21925,21946],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[21958,21979],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[21997,22018],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22031,22052],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22069,22090],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22102,22123],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22137,22158],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22214,22239],"content":"<ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph> array.","source":"<xref:System.Byte> array."},{"pos":[22256,22277],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22290,22311],"content":"<ph id=\"ph1\">&lt;xref:System.Single&gt;</ph>.","source":"<xref:System.Single>."},{"pos":[22325,22346],"content":"<ph id=\"ph1\">&lt;xref:System.Double&gt;</ph>.","source":"<xref:System.Double>."},{"pos":[22360,22378],"content":"<ph id=\"ph1\">&lt;xref:System.Uri&gt;</ph>.","source":"<xref:System.Uri>."},{"pos":[22391,22426],"content":"<ph id=\"ph1\">&lt;xref:System.Xml.XmlQualifiedName&gt;</ph>.","source":"<xref:System.Xml.XmlQualifiedName>."},{"pos":[22440,22461],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22485,22506],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22519,22540],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22556,22577],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22589,22610],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22624,22645],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22655,22676],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22689,22710],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22724,22745],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22759,22780],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22796,22817],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22832,22853],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22869,22890],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String>."},{"pos":[22905,22927],"content":"<ph id=\"ph1\">&lt;xref:System.Decimal&gt;</ph>.","source":"<xref:System.Decimal>."},{"pos":[22942,22962],"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>.","source":"<xref:System.Int64>."},{"pos":[22988,23008],"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>.","source":"<xref:System.Int64>."},{"pos":[23031,23051],"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>.","source":"<xref:System.Int64>."},{"pos":[23063,23083],"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>.","source":"<xref:System.Int64>."},{"pos":[23094,23114],"content":"<ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>.","source":"<xref:System.Int32>."},{"pos":[23127,23147],"content":"<ph id=\"ph1\">&lt;xref:System.Int16&gt;</ph>.","source":"<xref:System.Int16>."},{"pos":[23159,23179],"content":"<ph id=\"ph1\">&lt;xref:System.SByte&gt;</ph>.","source":"<xref:System.SByte>."},{"pos":[23205,23225],"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>.","source":"<xref:System.Int64>."},{"pos":[23245,23266],"content":"<ph id=\"ph1\">&lt;xref:System.UInt64&gt;</ph>.","source":"<xref:System.UInt64>."},{"pos":[23285,23306],"content":"<ph id=\"ph1\">&lt;xref:System.UInt32&gt;</ph>.","source":"<xref:System.UInt32>."},{"pos":[23327,23348],"content":"<ph id=\"ph1\">&lt;xref:System.UInt16&gt;</ph>.","source":"<xref:System.UInt16>."},{"pos":[23368,23387],"content":"<ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph>.","source":"<xref:System.Byte>."},{"pos":[23410,23430],"content":"<ph id=\"ph1\">&lt;xref:System.Int64&gt;</ph>.","source":"<xref:System.Int64>."},{"pos":[23440,23467],"content":"ISerializable types mapping","linkify":"ISerializable types mapping","nodes":[{"content":"ISerializable types mapping","pos":[0,27]}]},{"content":"In <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> version 1.0, <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> was introduced as a general mechanism to serialize objects for persistence or data transfer.","pos":[23471,23693],"source":"In [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] version 1.0, <xref:System.Runtime.Serialization.ISerializable> was introduced as a general mechanism to serialize objects for persistence or data transfer."},{"content":"There are many <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types that implement <ph id=\"ph2\">`ISerializable`</ph> and that can be passed between applications.","pos":[23694,23854],"source":" There are many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types that implement `ISerializable` and that can be passed between applications."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> naturally provides support for <ph id=\"ph2\">`ISerializable`</ph> classes.","pos":[23855,23969],"source":"<xref:System.Runtime.Serialization.DataContractSerializer> naturally provides support for `ISerializable` classes."},{"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> maps <ph id=\"ph2\">`ISerializable`</ph> implementation schema types that differ only by the QName (qualified name) of the type and are effectively property collections.","pos":[23970,24148],"source":" The `DataContractSerializer` maps `ISerializable` implementation schema types that differ only by the QName (qualified name) of the type and are effectively property collections."},{"content":"For example, the <ph id=\"ph1\">`DataContractSerializer`</ph> maps <ph id=\"ph2\">&lt;xref:System.Exception&gt;</ph> to the following XSD type in the <ph id=\"ph3\">`http://schemas.datacontract.org/2004/07/System`</ph> namespace.","pos":[24149,24312],"source":" For example, the `DataContractSerializer` maps <xref:System.Exception> to the following XSD type in the `http://schemas.datacontract.org/2004/07/System` namespace."},{"content":"The optional attribute <ph id=\"ph1\">`ser:FactoryType`</ph> declared in the Data Contract Serialization schema references a factory class that can deserialize the type.","pos":[24571,24720],"source":"The optional attribute `ser:FactoryType` declared in the Data Contract Serialization schema references a factory class that can deserialize the type."},{"content":"The factory class must be part of the known types collection of the <ph id=\"ph1\">`DataContractSerializer`</ph> instance being used.","pos":[24721,24834],"source":" The factory class must be part of the known types collection of the `DataContractSerializer` instance being used."},{"content":"For more information about known types, see <bpt id=\"p1\">[</bpt>Data Contract Known Types<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>.","pos":[24835,24984],"source":" For more information about known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)."},{"pos":[24993,25026],"content":"DataContract Serialization Schema","linkify":"DataContract Serialization Schema","nodes":[{"content":"DataContract Serialization Schema","pos":[0,33]}]},{"pos":[25030,25180],"content":"A number of schemas exported by the <ph id=\"ph1\">`DataContractSerializer`</ph> use types, elements, and attributes from a special Data Contract Serialization namespace:","source":"A number of schemas exported by the `DataContractSerializer` use types, elements, and attributes from a special Data Contract Serialization namespace:"},{"content":"The following is a complete Data Contract Serialization schema declaration.","pos":[25244,25319]},{"content":"The following should be noted:","pos":[28074,28104]},{"pos":[28114,28198],"content":"<ph id=\"ph1\">`ser:char`</ph> is introduced to represent Unicode characters of type <ph id=\"ph2\">&lt;xref:System.Char&gt;</ph>.","source":"`ser:char` is introduced to represent Unicode characters of type <xref:System.Char>."},{"pos":[28208,28324],"content":"The <ph id=\"ph1\">`valuespace`</ph> of <ph id=\"ph2\">`xs:duration`</ph> is reduced to an ordered set so that it can be mapped to a <ph id=\"ph3\">&lt;xref:System.TimeSpan&gt;</ph>.","source":"The `valuespace` of `xs:duration` is reduced to an ordered set so that it can be mapped to a <xref:System.TimeSpan>."},{"pos":[28334,28459],"content":"<ph id=\"ph1\">`FactoryType`</ph> is used in schemas exported from types that are derived from <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>.","source":"`FactoryType` is used in schemas exported from types that are derived from <xref:System.Runtime.Serialization.ISerializable>."},{"pos":[28468,28502],"content":"Importing non-DataContract schemas","linkify":"Importing non-DataContract schemas","nodes":[{"content":"Importing non-DataContract schemas","pos":[0,34]}]},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> has the <ph id=\"ph2\">`ImportXmlTypes`</ph> option to allow import of schemas that do not conform to the <ph id=\"ph3\">`DataContractSerializer`</ph> XSD profile (see the <ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A&gt;</ph> property).","pos":[28506,28744],"source":"`DataContractSerializer` has the `ImportXmlTypes` option to allow import of schemas that do not conform to the `DataContractSerializer` XSD profile (see the <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> property)."},{"content":"Setting this option to <ph id=\"ph1\">`true`</ph> enables acceptance of non-conforming schema types and mapping them to the following implementation, <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> wrapping an array of <ph id=\"ph3\">&lt;xref:System.Xml.XmlNode&gt;</ph> (only the class name differs).","pos":[28745,29001],"source":" Setting this option to `true` enables acceptance of non-conforming schema types and mapping them to the following implementation, <xref:System.Xml.Serialization.IXmlSerializable> wrapping an array of <xref:System.Xml.XmlNode> (only the class name differs)."},{"pos":[30076,30104],"content":"DateTimeOffset Serialization","linkify":"DateTimeOffset Serialization","nodes":[{"content":"DateTimeOffset Serialization","pos":[0,28]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.DateTimeOffset&gt;</ph> is not treated as a primitive type.","pos":[30108,30176],"source":"The <xref:System.DateTimeOffset> is not treated as a primitive type."},{"content":"Instead, it is serialized as a complex element with two parts.","pos":[30177,30239]},{"content":"The first part represents the date time, and the second part represents the offset from the date time.","pos":[30240,30342]},{"content":"An example of a serialized DateTimeOffset value is shown in the following code.","pos":[30343,30422]},{"content":"The schema is as follows.","pos":[30781,30806]},{"pos":[31269,31277],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[31522,31616],"content":"<bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>","source":"[Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)"}]}