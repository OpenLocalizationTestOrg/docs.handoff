{"content":"---\ntitle: \"Retrieving Binary Data | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-ado\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 56c5a9e3-31f1-482f-bce0-ff1c41a658d0\ncaps.latest.revision: 5\nauthor: \"JennieHubbard\"\nms.author: \"jhubbard\"\nmanager: \"jhubbard\"\n---\n# Retrieving Binary Data\nBy default, the **DataReader** loads incoming data as a row as soon as an entire row of data is available. Binary large objects (BLOBs) need different treatment, however, because they can contain gigabytes of data that cannot be contained in a single row. The **Command.ExecuteReader** method has an overload that will take a <xref:System.Data.CommandBehavior> argument to modify the default behavior of the **DataReader**. You can pass <xref:System.Data.CommandBehavior> to the **ExecuteReader** method to modify the default behavior of the **DataReader** so that instead of loading rows of data, it will load data sequentially as it is received. This is ideal for loading BLOBs or other large data structures. Note that this behavior may depend on your data source. For example, returning a BLOB from Microsoft Access will load the entire BLOB being loaded into memory, rather than sequentially as it is received.  \n  \n When setting the **DataReader** to use **SequentialAccess**, it is important to note the sequence in which you access the fields returned. The default behavior of the **DataReader**, which loads an entire row as soon as it is available, allows you to access the fields returned in any order until the next row is read. When using **SequentialAccess** however, you must access the fields returned by the **DataReader** in order. For example, if your query returns three columns, the third of which is a BLOB, you must return the values of the first and second fields before accessing the BLOB data in the third field. If you access the third field before the first or second fields, the first and second field values are no longer available. This is because **SequentialAccess** has modified the **DataReader** to return data in sequence and the data is not available after the **DataReader** has read past it.  \n  \n When accessing the data in the BLOB field, use the **GetBytes** or **GetChars** typed accessors of the **DataReader**, which fill an array with data. You can also use **GetString** for character data; however. to conserve system resources you might not want to load an entire BLOB value into a single string variable. You can instead specify a specific buffer size of data to be returned, and a starting location for the first byte or character to be read from the returned data. **GetBytes** and **GetChars** will return a `long` value, which represents the number of bytes or characters returned. If you pass a null array to **GetBytes** or **GetChars**, the long value returned will be the total number of bytes or characters in the BLOB. You can optionally specify an index in the array as a starting position for the data being read.  \n  \n## Example  \n The following example returns the publisher ID and logo from the **pubs** sample database in Microsoft SQL Server. The publisher ID (`pub_id`) is a character field, and the logo is an image, which is a BLOB. Because the **logo** field is a bitmap, the example returns binary data using **GetBytes**. Notice that the publisher ID is accessed for the current row of data before the logo, because the fields must be accessed sequentially.  \n  \n```vb  \n' Assumes that connection is a valid SqlConnection object.  \nDim command As SqlCommand = New SqlCommand( _  \n  \"SELECT pub_id, logo FROM pub_info\", connection)  \n  \n' Writes the BLOB to a file (*.bmp).  \nDim stream As FileStream                   \n' Streams the binary data to the FileStream object.  \nDim writer As BinaryWriter                 \n' The size of the BLOB buffer.  \nDim bufferSize As Integer = 100        \n' The BLOB byte() buffer to be filled by GetBytes.  \nDim outByte(bufferSize - 1) As Byte    \n' The bytes returned from GetBytes.  \nDim retval As Long                     \n' The starting position in the BLOB output.  \nDim startIndex As Long = 0             \n  \n' The publisher id to use in the file name.  \nDim pubID As String = \"\"              \n  \n' Open the connection and read data into the DataReader.  \nconnection.Open()  \nDim reader As SqlDataReader = command.ExecuteReader(CommandBehavior.SequentialAccess)  \n  \nDo While reader.Read()  \n  ' Get the publisher id, which must occur before getting the logo.  \n  pubID = reader.GetString(0)  \n  \n  ' Create a file to hold the output.  \n  stream = New FileStream( _  \n    \"logo\" & pubID & \".bmp\", FileMode.OpenOrCreate, FileAccess.Write)  \n  writer = New BinaryWriter(stream)  \n  \n  ' Reset the starting byte for a new BLOB.  \n  startIndex = 0  \n  \n  ' Read bytes into outByte() and retain the number of bytes returned.  \n  retval = reader.GetBytes(1, startIndex, outByte, 0, bufferSize)  \n  \n  ' Continue while there are bytes beyond the size of the buffer.  \n  Do While retval = bufferSize  \n    writer.Write(outByte)  \n    writer.Flush()  \n  \n    ' Reposition start index to end of the last buffer and fill buffer.  \n    startIndex += bufferSize  \n    retval = reader.GetBytes(1, startIndex, outByte, 0, bufferSize)  \n  Loop  \n  \n  ' Write the remaining buffer.  \n  writer.Write(outByte, 0 , retval - 1)  \n  writer.Flush()  \n  \n  ' Close the output file.  \n  writer.Close()  \n  stream.Close()  \nLoop  \n  \n' Close the reader and the connection.  \nreader.Close()  \nconnection.Close()  \n  \n```  \n  \n```csharp  \n// Assumes that connection is a valid SqlConnection object.  \nSqlCommand command = new SqlCommand(  \n  \"SELECT pub_id, logo FROM pub_info\", connection);  \n  \n// Writes the BLOB to a file (*.bmp).  \nFileStream stream;                            \n// Streams the BLOB to the FileStream object.  \nBinaryWriter writer;                          \n  \n// Size of the BLOB buffer.  \nint bufferSize = 100;                     \n// The BLOB byte[] buffer to be filled by GetBytes.  \nbyte[] outByte = new byte[bufferSize];    \n// The bytes returned from GetBytes.  \nlong retval;                              \n// The starting position in the BLOB output.  \nlong startIndex = 0;                      \n  \n// The publisher id to use in the file name.  \nstring pubID = \"\";                       \n  \n// Open the connection and read data into the DataReader.  \nconnection.Open();  \nSqlDataReader reader = command.ExecuteReader(CommandBehavior.SequentialAccess);  \n  \nwhile (reader.Read())  \n{  \n  // Get the publisher id, which must occur before getting the logo.  \n  pubID = reader.GetString(0);    \n  \n  // Create a file to hold the output.  \n  stream = new FileStream(  \n    \"logo\" + pubID + \".bmp\", FileMode.OpenOrCreate, FileAccess.Write);  \n  writer = new BinaryWriter(stream);  \n  \n  // Reset the starting byte for the new BLOB.  \n  startIndex = 0;  \n  \n  // Read bytes into outByte[] and retain the number of bytes returned.  \n  retval = reader.GetBytes(1, startIndex, outByte, 0, bufferSize);  \n  \n  // Continue while there are bytes beyond the size of the buffer.  \n  while (retval == bufferSize)  \n  {  \n    writer.Write(outByte);  \n    writer.Flush();  \n  \n    // Reposition start index to end of last buffer and fill buffer.  \n    startIndex += bufferSize;  \n    retval = reader.GetBytes(1, startIndex, outByte, 0, bufferSize);  \n  }  \n  \n  // Write the remaining buffer.  \n  writer.Write(outByte, 0, (int)retval - 1);  \n  writer.Flush();  \n  \n  // Close the output file.  \n  writer.Close();  \n  stream.Close();  \n}  \n  \n// Close the reader and the connection.  \nreader.Close();  \nconnection.Close();  \n```  \n  \n## See Also  \n [Working with DataReaders](http://msdn.microsoft.com/en-us/126a966a-d08d-4d22-a19f-f432908b2b54)   \n [SQL Server Binary and Large-Value Data](../../../../docs/framework/data/adonet/sql/sql-server-binary-and-large-value-data.md)   \n [ADO.NET Managed Providers and DataSet Developer Center](http://go.microsoft.com/fwlink/?LinkId=217917)","nodes":[{"pos":[12,51],"content":"Retrieving Binary Data | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Retrieving Binary Data | Microsoft Docs","pos":[0,39]}]},{"pos":[360,382],"content":"Retrieving Binary Data","linkify":"Retrieving Binary Data","nodes":[{"content":"Retrieving Binary Data","pos":[0,22]}]},{"content":"By default, the <bpt id=\"p1\">**</bpt>DataReader<ept id=\"p1\">**</ept> loads incoming data as a row as soon as an entire row of data is available.","pos":[383,489],"source":"By default, the **DataReader** loads incoming data as a row as soon as an entire row of data is available."},{"content":"Binary large objects (BLOBs) need different treatment, however, because they can contain gigabytes of data that cannot be contained in a single row.","pos":[490,638]},{"content":"The <bpt id=\"p1\">**</bpt>Command.ExecuteReader<ept id=\"p1\">**</ept> method has an overload that will take a <ph id=\"ph1\">&lt;xref:System.Data.CommandBehavior&gt;</ph> argument to modify the default behavior of the <bpt id=\"p2\">**</bpt>DataReader<ept id=\"p2\">**</ept>.","pos":[639,806],"source":" The **Command.ExecuteReader** method has an overload that will take a <xref:System.Data.CommandBehavior> argument to modify the default behavior of the **DataReader**."},{"content":"You can pass <ph id=\"ph1\">&lt;xref:System.Data.CommandBehavior&gt;</ph> to the <bpt id=\"p1\">**</bpt>ExecuteReader<ept id=\"p1\">**</ept> method to modify the default behavior of the <bpt id=\"p2\">**</bpt>DataReader<ept id=\"p2\">**</ept> so that instead of loading rows of data, it will load data sequentially as it is received.","pos":[807,1030],"source":" You can pass <xref:System.Data.CommandBehavior> to the **ExecuteReader** method to modify the default behavior of the **DataReader** so that instead of loading rows of data, it will load data sequentially as it is received."},{"content":"This is ideal for loading BLOBs or other large data structures.","pos":[1031,1094]},{"content":"Note that this behavior may depend on your data source.","pos":[1095,1150]},{"content":"For example, returning a BLOB from Microsoft Access will load the entire BLOB being loaded into memory, rather than sequentially as it is received.","pos":[1151,1298]},{"content":"When setting the <bpt id=\"p1\">**</bpt>DataReader<ept id=\"p1\">**</ept> to use <bpt id=\"p2\">**</bpt>SequentialAccess<ept id=\"p2\">**</ept>, it is important to note the sequence in which you access the fields returned.","pos":[1305,1443],"source":"When setting the **DataReader** to use **SequentialAccess**, it is important to note the sequence in which you access the fields returned."},{"content":"The default behavior of the <bpt id=\"p1\">**</bpt>DataReader<ept id=\"p1\">**</ept>, which loads an entire row as soon as it is available, allows you to access the fields returned in any order until the next row is read.","pos":[1444,1623],"source":" The default behavior of the **DataReader**, which loads an entire row as soon as it is available, allows you to access the fields returned in any order until the next row is read."},{"content":"When using <bpt id=\"p1\">**</bpt>SequentialAccess<ept id=\"p1\">**</ept> however, you must access the fields returned by the <bpt id=\"p2\">**</bpt>DataReader<ept id=\"p2\">**</ept> in order.","pos":[1624,1732],"source":" When using **SequentialAccess** however, you must access the fields returned by the **DataReader** in order."},{"content":"For example, if your query returns three columns, the third of which is a BLOB, you must return the values of the first and second fields before accessing the BLOB data in the third field.","pos":[1733,1921]},{"content":"If you access the third field before the first or second fields, the first and second field values are no longer available.","pos":[1922,2045]},{"content":"This is because <bpt id=\"p1\">**</bpt>SequentialAccess<ept id=\"p1\">**</ept> has modified the <bpt id=\"p2\">**</bpt>DataReader<ept id=\"p2\">**</ept> to return data in sequence and the data is not available after the <bpt id=\"p3\">**</bpt>DataReader<ept id=\"p3\">**</ept> has read past it.","pos":[2046,2214],"source":" This is because **SequentialAccess** has modified the **DataReader** to return data in sequence and the data is not available after the **DataReader** has read past it."},{"content":"When accessing the data in the BLOB field, use the <bpt id=\"p1\">**</bpt>GetBytes<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>GetChars<ept id=\"p2\">**</ept> typed accessors of the <bpt id=\"p3\">**</bpt>DataReader<ept id=\"p3\">**</ept>, which fill an array with data.","pos":[2221,2370],"source":"When accessing the data in the BLOB field, use the **GetBytes** or **GetChars** typed accessors of the **DataReader**, which fill an array with data."},{"content":"You can also use <bpt id=\"p1\">**</bpt>GetString<ept id=\"p1\">**</ept> for character data; however.","pos":[2371,2430],"source":" You can also use **GetString** for character data; however."},{"content":"to conserve system resources you might not want to load an entire BLOB value into a single string variable.","pos":[2431,2538]},{"content":"You can instead specify a specific buffer size of data to be returned, and a starting location for the first byte or character to be read from the returned data.","pos":[2539,2700]},{"content":"<bpt id=\"p1\">**</bpt>GetBytes<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>GetChars<ept id=\"p2\">**</ept> will return a <ph id=\"ph1\">`long`</ph> value, which represents the number of bytes or characters returned.","pos":[2701,2819],"source":"**GetBytes** and **GetChars** will return a `long` value, which represents the number of bytes or characters returned."},{"content":"If you pass a null array to <bpt id=\"p1\">**</bpt>GetBytes<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>GetChars<ept id=\"p2\">**</ept>, the long value returned will be the total number of bytes or characters in the BLOB.","pos":[2820,2962],"source":" If you pass a null array to **GetBytes** or **GetChars**, the long value returned will be the total number of bytes or characters in the BLOB."},{"content":"You can optionally specify an index in the array as a starting position for the data being read.","pos":[2963,3059]},{"pos":[3068,3075],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example returns the publisher ID and logo from the <bpt id=\"p1\">**</bpt>pubs<ept id=\"p1\">**</ept> sample database in Microsoft SQL Server.","pos":[3079,3193],"source":"The following example returns the publisher ID and logo from the **pubs** sample database in Microsoft SQL Server."},{"content":"The publisher ID (<ph id=\"ph1\">`pub_id`</ph>) is a character field, and the logo is an image, which is a BLOB.","pos":[3194,3286],"source":" The publisher ID (`pub_id`) is a character field, and the logo is an image, which is a BLOB."},{"content":"Because the <bpt id=\"p1\">**</bpt>logo<ept id=\"p1\">**</ept> field is a bitmap, the example returns binary data using <bpt id=\"p2\">**</bpt>GetBytes<ept id=\"p2\">**</ept>.","pos":[3287,3378],"source":" Because the **logo** field is a bitmap, the example returns binary data using **GetBytes**."},{"content":"Notice that the publisher ID is accessed for the current row of data before the logo, because the fields must be accessed sequentially.","pos":[3379,3514]},{"pos":[7716,7724],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Working with DataReaders<ept id=\"p1\">](http://msdn.microsoft.com/en-us/126a966a-d08d-4d22-a19f-f432908b2b54)</ept><ph id=\"ph1\"> </ph>","pos":[7728,7825],"source":"[Working with DataReaders](http://msdn.microsoft.com/en-us/126a966a-d08d-4d22-a19f-f432908b2b54) "},{"content":"<bpt id=\"p1\"> [</bpt>SQL Server Binary and Large-Value Data<ept id=\"p1\">](../../../../docs/framework/data/adonet/sql/sql-server-binary-and-large-value-data.md)</ept><ph id=\"ph1\"> </ph>","pos":[7828,7956],"source":" [SQL Server Binary and Large-Value Data](../../../../docs/framework/data/adonet/sql/sql-server-binary-and-large-value-data.md) "},{"content":"<bpt id=\"p1\"> [</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=217917)</ept>","pos":[7959,8063],"source":" [ADO.NET Managed Providers and DataSet Developer Center](http://go.microsoft.com/fwlink/?LinkId=217917)"}]}