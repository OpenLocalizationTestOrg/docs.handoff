{"content":"---\ntitle: \"Task-based Asynchronous Pattern (TAP)\"\nms.date: \"02/26/2019\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \".NET Framework, and TAP\"\n  - \"asynchronous design patterns, .NET Framework\"\n  - \"TAP, .NET Framework support for\"\n  - \"Task-based Asynchronous Pattern, .NET Framework support for\"\n  - \".NET Framework, asynchronous design patterns\"\nms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Task-based asynchronous pattern (TAP)\nThe Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations. TAP is the recommended asynchronous design pattern for new development.  \n  \n## Naming, parameters, and return types\n\nTAP uses a single method to represent the initiation and completion of an asynchronous operation. This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP). APM requires `Begin` and `End` methods. EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types. Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>. For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`. If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead. For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`. If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.  \n  \n A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.  \n  \n The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.  However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely. Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values. You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.\n \n Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*. Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).  \n  \n For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).  \n  \n## Initiating an asynchronous operation  \n An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task. Synchronous work should be kept to the minimum so the asynchronous method can return quickly. Reasons for a quick return include the following:  \n  \n-   Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.  \n  \n-   Multiple asynchronous methods may be launched concurrently. Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.  \n  \n In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously. Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario. In such cases, the operation may complete synchronously, and may return a task that has already been completed.  \n  \n## Exceptions  \n An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error. Usage errors should never occur in production code. For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed. For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned. Typically, a task contains at most one exception. However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.  \n  \n## Target environment  \n When you implement a TAP method, you can determine where asynchronous execution occurs. You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts. A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).\n \n The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes. The creator of the continuation code has control over where that code executes. You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).  \n  \n## Task status  \n The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration. To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method. Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances. \n \n All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>. All tasks that are returned from TAP methods must be activated. **If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.** Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method. Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.  \n  \n## Cancellation (optional)  \n In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers. If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance). By convention, the parameter is named `cancellationToken`.  \n  \n [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]\n [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  \n  \n The asynchronous operation monitors this token for cancellation requests. If it receives a cancellation request, it may choose to honor that request and cancel the operation. If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.  The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states. Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`. When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation. Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it. Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.  \n  \n If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.  However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.  The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request. If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state. \n \n For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token. For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.  Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value. <xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.  \n  \n## Progress reporting (optional)  \n Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation. \n \n In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.  Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).  More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.  For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread. All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.  As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications. \n \n For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:  \n  \n [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]\n [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  \n  \n If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.  It could do this either with a tuple:  \n  \n [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]\n [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  \n  \n or with a data type that is specific to the API:  \n  \n [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]\n [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  \n  \n In the latter case, the special data type is usually suffixed with `ProgressInfo`.  \n  \n If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported. TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information. For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.  \n  \n## IProgress\\<T> implementations  \n The [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>. The <xref:System.Progress%601> class is declared as follows:  \n  \n```csharp  \npublic class Progress<T> : IProgress<T>  \n{  \n    public Progress();  \n    public Progress(Action<T> handler);  \n    protected virtual void OnReport(T value);  \n    public event EventHandler<T> ProgressChanged;  \n}  \n```  \n  \n```vb  \nPublic Class Progress(Of T) : Inherits IProgress(Of T)  \n    Public Sub New()  \n    Public Sub New(handler As Action(Of T))  \n    Protected Overridable Sub OnReport(value As T)  \n    Public Event ProgressChanged As EventHandler(Of T>  \nEnd Class  \n```  \n  \n An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update. The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated. If no synchronization context was available, a default context that targets the thread pool is used. Handlers may be registered with this event. A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event. Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing. Another <xref:System.IProgress%601> implementation could choose to apply different semantics.  \n  \n## Choosing the overloads to provide  \n If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:  \n  \n```csharp  \npublic Task MethodNameAsync(…);  \npublic Task MethodNameAsync(…, CancellationToken cancellationToken);  \npublic Task MethodNameAsync(…, IProgress<T> progress);   \npublic Task MethodNameAsync(…,   \n    CancellationToken cancellationToken, IProgress<T> progress);  \n```  \n  \n```vb  \nPublic MethodNameAsync(…) As Task  \nPublic MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  \nPublic MethodNameAsync(…, progress As IProgress(Of T)) As Task   \nPublic MethodNameAsync(…, cancellationToken As CancellationToken,   \n                       progress As IProgress(Of T)) As Task  \n```  \n  \n However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:  \n  \n```csharp  \npublic Task MethodNameAsync(…);  \n```  \n  \n```vb  \nPublic MethodNameAsync(…) As Task  \n```  \n  \n If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:  \n  \n```csharp  \npublic Task MethodNameAsync(…);  \npublic Task MethodNameAsync(…, CancellationToken cancellationToken);  \n  \n// … or …  \n  \npublic Task MethodNameAsync(…);  \npublic Task MethodNameAsync(…, IProgress<T> progress);  \n```  \n  \n```vb  \nPublic MethodNameAsync(…) As Task  \nPublic MethodNameAsync(…, cancellationToken As CancellationToken) As Task  \n  \n' … or …  \n  \nPublic MethodNameAsync(…) As Task  \nPublic MethodNameAsync(…, progress As IProgress(Of T)) As Task  \n```  \n  \n If a TAP implementation supports both cancellation and progress, it may expose all four overloads. However, it may provide only the following two:  \n  \n```csharp  \npublic Task MethodNameAsync(…);  \npublic Task MethodNameAsync(…,   \n    CancellationToken cancellationToken, IProgress<T> progress);  \n```  \n  \n```vb  \nPublic MethodNameAsync(…) As Task  \nPublic MethodNameAsync(…, cancellationToken As CancellationToken,   \n                       progress As IProgress(Of T)) As Task  \n```  \n  \n To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.  \n  \n If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.  \n  \n If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.  \n  \n## Related topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md)|Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).|  \n|[Implementing the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.|  \n|[Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|Describes how you can use tasks and callbacks to achieve waiting without blocking.|  \n|[Interop with Other Asynchronous Patterns and Types](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).|\n","nodes":[{"pos":[4,484],"embed":true,"restype":"x-metadata","content":"title: \"Task-based Asynchronous Pattern (TAP)\"\nms.date: \"02/26/2019\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \".NET Framework, and TAP\"\n  - \"asynchronous design patterns, .NET Framework\"\n  - \"TAP, .NET Framework support for\"\n  - \"Task-based Asynchronous Pattern, .NET Framework support for\"\n  - \".NET Framework, asynchronous design patterns\"\nms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Task-based Asynchronous Pattern (TAP)","nodes":[{"pos":[0,37],"content":"Task-based Asynchronous Pattern (TAP)","nodes":[{"content":"Task-based Asynchronous Pattern (TAP)","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[491,528],"content":"Task-based asynchronous pattern (TAP)","linkify":"Task-based asynchronous pattern (TAP)","nodes":[{"content":"Task-based asynchronous pattern (TAP)","pos":[0,37]}]},{"content":"The Task-based Asynchronous Pattern (TAP) is based on the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType&gt;</ph> types in the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks?displayProperty=nameWithType&gt;</ph> namespace, which are used to represent arbitrary asynchronous operations.","pos":[529,868],"source":"The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations."},{"content":"TAP is the recommended asynchronous design pattern for new development.","pos":[869,940]},{"pos":[949,985],"content":"Naming, parameters, and return types","linkify":"Naming, parameters, and return types","nodes":[{"content":"Naming, parameters, and return types","pos":[0,36]}]},{"content":"TAP uses a single method to represent the initiation and completion of an asynchronous operation.","pos":[987,1084]},{"content":"This contrasts with both the Asynchronous Programming Model (APM or <ph id=\"ph1\">`IAsyncResult`</ph>) pattern and the Event-based Asynchronous Pattern (EAP).","pos":[1085,1224],"source":" This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP)."},{"content":"APM requires <ph id=\"ph1\">`Begin`</ph> and <ph id=\"ph2\">`End`</ph> methods.","pos":[1225,1264],"source":" APM requires `Begin` and `End` methods."},{"content":"EAP requires a method that has the <ph id=\"ph1\">`Async`</ph> suffix and also requires one or more events, event handler delegate types, and <ph id=\"ph2\">`EventArg`</ph>-derived types.","pos":[1265,1412],"source":" EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types."},{"content":"Asynchronous methods in TAP include the <ph id=\"ph1\">`Async`</ph> suffix after the operation name for methods that return awaitable types, such as <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.ValueTask&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.Threading.Tasks.ValueTask%601&gt;</ph>.","pos":[1413,1707],"source":" Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>."},{"content":"For example, an asynchronous <ph id=\"ph1\">`Get`</ph> operation that returns a <ph id=\"ph2\">`Task&lt;String&gt;`</ph> can be named <ph id=\"ph3\">`GetAsync`</ph>.","pos":[1708,1807],"source":" For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`."},{"content":"If you're adding a TAP method to a class that already contains an EAP method name with the <ph id=\"ph1\">`Async`</ph> suffix, use the suffix <ph id=\"ph2\">`TaskAsync`</ph> instead.","pos":[1808,1950],"source":" If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead."},{"content":"For example, if the class already has a <ph id=\"ph1\">`GetAsync`</ph> method, use the name <ph id=\"ph2\">`GetTaskAsync`</ph>.","pos":[1951,2038],"source":" For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`."},{"content":"If a method starts an asynchronous operation but does not return an awaitable type, its name should start with <ph id=\"ph1\">`Begin`</ph>, <ph id=\"ph2\">`Start`</ph>, or some other verb to suggest that this method does not return or throw the result of the operation.","pos":[2039,2268],"source":" If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation."},{"pos":[2275,2530],"content":"A TAP method returns either a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> or a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType&gt;</ph>, based on whether the corresponding synchronous method returns void or a type <ph id=\"ph3\">`TResult`</ph>.","source":"A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`."},{"content":"The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.","pos":[2537,2668]},{"content":"However, <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> parameters are exempt from this rule and should be avoided entirely.","pos":[2670,2763],"source":"  However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely."},{"content":"Any data that would have been returned through an <ph id=\"ph1\">`out`</ph> or <ph id=\"ph2\">`ref`</ph> parameter should instead be returned as part of the <ph id=\"ph3\">`TResult`</ph> returned by <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, and should use a tuple or a custom data structure to accommodate multiple values.","pos":[2764,3024],"source":" Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values."},{"content":"You should also consider adding a <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken&gt;</ph> parameter even if the TAP method's synchronous counterpart does not offer one.","pos":[3025,3179],"source":" You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one."},{"content":"Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as <bpt id=\"p1\">*</bpt>combinators<ept id=\"p1\">*</ept>.","pos":[3183,3493],"source":"Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*."},{"content":"Examples of combinators include <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph>, and are discussed in the <bpt id=\"p1\">[</bpt>Using the Built-in Task-based Combinators<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators)</ept> section of the article <bpt id=\"p2\">[</bpt>Consuming the Task-based Asynchronous Pattern<ept id=\"p2\">](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)</ept>.","pos":[3494,3989],"source":" Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)."},{"pos":[3996,4308],"content":"For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see <bpt id=\"p1\">[</bpt>Asynchronous Programming Patterns<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/index.md)</ept>.","source":"For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md)."},{"pos":[4317,4353],"content":"Initiating an asynchronous operation","linkify":"Initiating an asynchronous operation","nodes":[{"content":"Initiating an asynchronous operation","pos":[0,36]}]},{"content":"An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.","pos":[4357,4555]},{"content":"Synchronous work should be kept to the minimum so the asynchronous method can return quickly.","pos":[4556,4649]},{"content":"Reasons for a quick return include the following:","pos":[4650,4699]},{"content":"Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.","pos":[4709,4866]},{"content":"Multiple asynchronous methods may be launched concurrently.","pos":[4876,4935]},{"content":"Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.","pos":[4936,5130]},{"content":"In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.","pos":[5137,5286]},{"content":"Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.","pos":[5287,5427]},{"content":"In such cases, the operation may complete synchronously, and may return a task that has already been completed.","pos":[5428,5539]},{"pos":[5548,5558],"content":"Exceptions","linkify":"Exceptions","nodes":[{"content":"Exceptions","pos":[0,10]}]},{"content":"An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.","pos":[5562,5694]},{"content":"Usage errors should never occur in production code.","pos":[5695,5746]},{"content":"For example, if passing a null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <ph id=\"ph2\">&lt;xref:System.ArgumentNullException&gt;</ph> exception), you can modify the calling code to ensure that a null reference is never passed.","pos":[5747,6026],"source":" For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed."},{"content":"For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.","pos":[6027,6245]},{"content":"Typically, a task contains at most one exception.","pos":[6246,6295]},{"content":"However, if the task represents multiple operations (for example, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>), multiple exceptions may be associated with a single task.","pos":[6296,6467],"source":" However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task."},{"pos":[6476,6494],"content":"Target environment","linkify":"Target environment","nodes":[{"content":"Target environment","pos":[0,18]}]},{"content":"When you implement a TAP method, you can determine where asynchronous execution occurs.","pos":[6498,6585]},{"content":"You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.","pos":[6586,6858]},{"content":"A TAP method may even have nothing to execute, and may just return a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).","pos":[6859,7112],"source":" A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure)."},{"content":"The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.","pos":[7116,7326]},{"content":"The creator of the continuation code has control over where that code executes.","pos":[7327,7406]},{"content":"You may create the continuation code either explicitly, through methods on the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class (for example, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>) or implicitly, by using language support built on top of continuations (for example, <ph id=\"ph3\">`await`</ph> in C#, <ph id=\"ph4\">`Await`</ph> in Visual Basic, <ph id=\"ph5\">`AwaitValue`</ph> in F#).","pos":[7407,7738],"source":" You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#)."},{"pos":[7747,7758],"content":"Task status","linkify":"Task status","nodes":[{"content":"Task status","pos":[0,11]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class provides a life cycle for asynchronous operations, and that cycle is represented by the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus&gt;</ph> enumeration.","pos":[7762,7948],"source":"The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration."},{"content":"To support corner cases of types that derive from <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>,  and to support the separation of construction from scheduling, the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class exposes a <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method.","pos":[7949,8248],"source":" To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method."},{"content":"Tasks that are created by the public <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructors are referred to as <bpt id=\"p1\">*</bpt>cold tasks<ept id=\"p1\">*</ept>, because they begin their life cycle in the non-scheduled <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state and are scheduled only when <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> is called on these instances.","pos":[8249,8580],"source":" Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances."},{"content":"All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType&gt;</ph>.","pos":[8585,8863],"source":"All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>."},{"content":"All tasks that are returned from TAP methods must be activated.","pos":[8864,8927]},{"content":"<bpt id=\"p1\">**</bpt>If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> on the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object before returning it.<ept id=\"p1\">**</ept>","pos":[8928,9163],"source":"**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**"},{"content":"Consumers of a TAP method may safely assume that the returned task is active and should not try to call <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> on any <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> that is returned from a TAP method.","pos":[9164,9389],"source":" Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method."},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> on an active task results in an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph> exception.","pos":[9390,9524],"source":" Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception."},{"pos":[9533,9556],"content":"Cancellation (optional)","linkify":"Cancellation (optional)","nodes":[{"content":"Cancellation (optional)","pos":[0,23]}]},{"content":"In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.","pos":[9560,9669]},{"content":"If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken&gt;</ph> instance).","pos":[9670,9844],"source":" If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance)."},{"content":"By convention, the parameter is named <ph id=\"ph1\">`cancellationToken`</ph>.","pos":[9845,9903],"source":" By convention, the parameter is named `cancellationToken`."},{"content":"The asynchronous operation monitors this token for cancellation requests.","pos":[10150,10223]},{"content":"If it receives a cancellation request, it may choose to honor that request and cancel the operation.","pos":[10224,10324]},{"content":"If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state; there is no available result and no exception is thrown.","pos":[10325,10554],"source":" If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state is considered to be a final (completed) state for a task, along with the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> states.","pos":[10556,10806],"source":"  The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states."},{"content":"Therefore, if a task is in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state, its <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> property returns <ph id=\"ph3\">`true`</ph>.","pos":[10807,10973],"source":" Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`."},{"content":"When a task completes in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled&gt;</ph> was specified to opt out of continuation.","pos":[10974,11276],"source":" When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation."},{"content":"Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <ph id=\"ph1\">&lt;xref:System.OperationCanceledException&gt;</ph> or an exception derived from it.","pos":[11277,11476],"source":" Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it."},{"content":"Code that is blocked synchronously waiting on the task through methods such as <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> also continue to run with an exception.","pos":[11477,11688],"source":" Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception."},{"content":"If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> task.","pos":[11695,11889],"source":"If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task."},{"content":"However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.","pos":[11891,12042]},{"content":"The returned task should end in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state only if the operation ends as a result of the cancellation request.","pos":[12044,12203],"source":"  The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request."},{"content":"If cancellation is requested but a result or an exception is still produced, the task should end in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state.","pos":[12204,12423],"source":" If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state."},{"content":"For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.","pos":[12428,12600]},{"content":"For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.","pos":[12601,12780]},{"content":"Consumer code that does not desire cancellation may call a method that accepts a <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken&gt;</ph> and provide <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken.None%2A&gt;</ph> as the argument value.","pos":[12782,12989],"source":"  Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.None%2A&gt;</ph> is functionally equivalent to the default <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken&gt;</ph>.","pos":[12990,13124],"source":"<xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>."},{"pos":[13133,13162],"content":"Progress reporting (optional)","linkify":"Progress reporting (optional)","nodes":[{"content":"Progress reporting (optional)","pos":[0,29]}]},{"content":"Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.","pos":[13166,13360]},{"content":"In TAP, progress is handled through an <ph id=\"ph1\">&lt;xref:System.IProgress%601&gt;</ph> interface, which is passed to the asynchronous method as a parameter that is usually named <ph id=\"ph2\">`progress`</ph>.","pos":[13365,13534],"source":"In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`."},{"content":"Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).","pos":[13536,13780]},{"content":"More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.","pos":[13782,13905]},{"content":"For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.","pos":[13907,14153]},{"content":"All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.","pos":[14154,14288]},{"content":"As with cancellation, TAP implementations should provide an <ph id=\"ph1\">&lt;xref:System.IProgress%601&gt;</ph> parameter only if the API supports progress notifications.","pos":[14290,14436],"source":"  As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications."},{"pos":[14441,14676],"content":"For example, if the <ph id=\"ph1\">`ReadAsync`</ph> method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <ph id=\"ph2\">&lt;xref:System.IProgress%601&gt;</ph> interface:","source":"For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:"},{"content":"If a <ph id=\"ph1\">`FindFilesAsync`</ph> method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.","pos":[14923,15149],"source":"If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results."},{"content":"It could do this either with a tuple:","pos":[15151,15188]},{"content":"or with a data type that is specific to the API:","pos":[15435,15483]},{"pos":[15730,15812],"content":"In the latter case, the special data type is usually suffixed with <ph id=\"ph1\">`ProgressInfo`</ph>.","source":"In the latter case, the special data type is usually suffixed with `ProgressInfo`."},{"content":"If TAP implementations provide overloads that accept a <ph id=\"ph1\">`progress`</ph> parameter, they must allow the argument to be <ph id=\"ph2\">`null`</ph>, in which case no progress will be reported.","pos":[15819,15982],"source":"If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported."},{"content":"TAP implementations should report the progress to the <ph id=\"ph1\">&lt;xref:System.Progress%601&gt;</ph> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.","pos":[15983,16250],"source":" TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information."},{"content":"For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.","pos":[16251,16375]},{"pos":[16384,16413],"content":"IProgress\\<T> implementations","linkify":"IProgress\\<T> implementations","nodes":[{"content":"IProgress<ph id=\"ph1\">\\&lt;</ph>T&gt; implementations","pos":[0,29],"source":"IProgress\\<T> implementations"}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> provides a single <ph id=\"ph2\">&lt;xref:System.IProgress%601&gt;</ph> implementation: <ph id=\"ph3\">&lt;xref:System.Progress%601&gt;</ph>.","pos":[16417,16563],"source":"The [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Progress%601&gt;</ph> class is declared as follows:","pos":[16564,16624],"source":" The <xref:System.Progress%601> class is declared as follows:"},{"content":"An instance of <ph id=\"ph1\">&lt;xref:System.Progress%601&gt;</ph> exposes a <ph id=\"ph2\">&lt;xref:System.Progress%601.ProgressChanged&gt;</ph> event, which is raised every time the asynchronous operation reports a progress update.","pos":[17134,17316],"source":"An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Progress%601.ProgressChanged&gt;</ph> event is raised on the <ph id=\"ph2\">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object that was captured when the <ph id=\"ph3\">&lt;xref:System.Progress%601&gt;</ph> instance was instantiated.","pos":[17317,17521],"source":" The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated."},{"content":"If no synchronization context was available, a default context that targets the thread pool is used.","pos":[17522,17622]},{"content":"Handlers may be registered with this event.","pos":[17623,17666]},{"content":"A single handler may also be provided to the <ph id=\"ph1\">&lt;xref:System.Progress%601&gt;</ph> constructor for convenience, and behaves just like an event handler for the <ph id=\"ph2\">&lt;xref:System.Progress%601.ProgressChanged&gt;</ph> event.","pos":[17667,17864],"source":" A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event."},{"content":"Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.","pos":[17865,17988]},{"content":"Another <ph id=\"ph1\">&lt;xref:System.IProgress%601&gt;</ph> implementation could choose to apply different semantics.","pos":[17989,18082],"source":" Another <xref:System.IProgress%601> implementation could choose to apply different semantics."},{"pos":[18091,18124],"content":"Choosing the overloads to provide","linkify":"Choosing the overloads to provide","nodes":[{"content":"Choosing the overloads to provide","pos":[0,33]}]},{"pos":[18128,18341],"content":"If a TAP implementation uses both the optional <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> and optional <ph id=\"ph2\">&lt;xref:System.IProgress%601&gt;</ph> parameters, it could potentially require up to four overloads:","source":"If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:"},{"content":"However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:","pos":[18977,19098]},{"content":"If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:","pos":[19213,19321]},{"content":"If a TAP implementation supports both cancellation and progress, it may expose all four overloads.","pos":[19810,19908]},{"content":"However, it may provide only the following two:","pos":[19909,19956]},{"pos":[20303,20567],"content":"To compensate for the two missing intermediate combinations, developers may pass <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.None%2A&gt;</ph> or a default <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken&gt;</ph> for the <ph id=\"ph3\">`cancellationToken`</ph> parameter and <ph id=\"ph4\">`null`</ph> for the <ph id=\"ph5\">`progress`</ph> parameter.","source":"To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter."},{"content":"If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.","pos":[20574,20723]},{"pos":[20730,21036],"content":"If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.None%2A&gt;</ph> for cancellation or <ph id=\"ph2\">`null`</ph> for progress to the overload that does support these.","source":"If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these."},{"pos":[21045,21059],"content":"Related topics","linkify":"Related topics","nodes":[{"content":"Related topics","pos":[0,14]}]},{"content":"Title","pos":[21066,21071]},{"content":"Description","pos":[21072,21083]},{"pos":[21122,21224],"content":"<bpt id=\"p1\">[</bpt>Asynchronous Programming Patterns<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/index.md)</ept>","source":"[Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md)"},{"content":"Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).","pos":[21225,21427]},{"pos":[21432,21592],"content":"<bpt id=\"p1\">[</bpt>Implementing the Task-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)</ept>","source":"[Implementing the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)"},{"content":"Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.","pos":[21593,21808]},{"pos":[21813,21967],"content":"<bpt id=\"p1\">[</bpt>Consuming the Task-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)</ept>","source":"[Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)"},{"content":"Describes how you can use tasks and callbacks to achieve waiting without blocking.","pos":[21968,22050]},{"pos":[22055,22219],"content":"<bpt id=\"p1\">[</bpt>Interop with Other Asynchronous Patterns and Types<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)</ept>","source":"[Interop with Other Asynchronous Patterns and Types](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)"},{"content":"Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).","pos":[22220,22380]}]}