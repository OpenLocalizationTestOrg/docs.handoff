{"content":"---\ntitle: Deconstructing tuples and other types\ndescription: Learn how to deconstruct tuples and other types.\nauthor: rpetrusha\nms.author: ronpet\nms.date: 07/18/2016\nms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960\n---\n\n# Deconstructing tuples and other types\n\nA tuple provides a light-weight way to retrieve multiple values from a method call. But once you retrieve the tuple, you have to handle its individual elements. Doing this on an element-by-element basis is cumbersome, as the following example shows. The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.\n\n[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]\n\nRetrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.\n\nStarting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation. When you deconstruct a tuple, you assign its elements to individual variables. When you deconstruct an object, you assign selected values to individual variables.\n\n## Deconstructing a tuple\n\nC# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation. The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement. For example, the following statement assigns the elements of a 4-tuple to four separate variables:\n\n```csharp\nvar (name, address, city, zip) = contact.GetAddressInfo();\n```\n\nThere are three ways to deconstruct a tuple:\n\n- You can explicitly declare the type of each field inside parentheses. The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.\n\n    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]\n\n- You can use the `var` keyword so that C# infers the type of each variable. You place the `var` keyword outside of the parentheses. The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.\n\n    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]\n\n    You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.\n\n    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]\n\n    This is cumbersome and is not recommended.\n\n- Lastly, you may deconstruct the tuple into variables that have already been declared.\n\n    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]\n\nNote that you cannot specify a specific type outside the parentheses even if every field in the tuple has the\nsame type. This generates compiler error CS8136, \"Deconstruction 'var (...)' form disallows a specific type for 'var'.\".\n\nNote that you must also assign each element of the tuple to a variable. If you omit any elements, the compiler generates error CS8132, \"Cannot deconstruct a tuple of 'x' elements into 'y' variables.\"\n\nNote that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction. The compiler generates error CS8184, \"a deconstruction cannot mix declarations and expressions on the left-hand-side.\" when the members include newly declared and existing variables.\n\n## Deconstructing tuple elements with discards\n\nOften when deconstructing a tuple, you're interested in the values of only some elements. Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore. A discard is designated by an underscore character (\"\\_\") in an assignment. You can discard as many values as you like; all are represented by the single discard, `_`.\n\nThe following example illustrates the use of tuples with discards. The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year. The example shows the change in population between those two years. Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time. As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.  \n\n[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]\n\n### Deconstructing user-defined types\n\nNon-tuple types do not offer built-in support for discards. However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods. The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature. For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:\n\n[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]\n\nYou can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:\n\n[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]\n\nThe following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object. Individual overloads return:\n\n- A first and last name.\n- A first, last, and middle name.\n- A first name, a last name, a city name, and a state name.\n\n[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]\n\nBecause you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous. Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.\n\nThe overloaded `Deconstruct` method in the following example illustrates one possible source of confusion. The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order. The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order. This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.\n\n[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]\n\n## Deconstructing a user-defined type with discards\n\nJust as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method. Each discard is defined by a variable named \"\\_\", and a single deconstruction operation can include multiple discards.\n\nThe following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.\n\n[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]\n\n## Deconstructing a user-defined type with an extension method\n\nIf you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.\n\nThe following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class. The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed. The second indicates the property's accessibility. Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility. If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole. Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.\n\n[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]\n\n## See also\n\n- [Discards](discards.md)\n- [Tuples](tuples.md)\n","nodes":[{"pos":[4,215],"embed":true,"restype":"x-metadata","content":"title: Deconstructing tuples and other types\ndescription: Learn how to deconstruct tuples and other types.\nauthor: rpetrusha\nms.author: ronpet\nms.date: 07/18/2016\nms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960","nodes":[{"content":"Deconstructing tuples and other types","nodes":[{"pos":[0,37],"content":"Deconstructing tuples and other types","nodes":[{"content":"Deconstructing tuples and other types","pos":[0,37]}]}],"path":["title"],"nosxs":false},{"content":"Learn how to deconstruct tuples and other types.","nodes":[{"pos":[0,48],"content":"Learn how to deconstruct tuples and other types.","nodes":[{"content":"Learn how to deconstruct tuples and other types.","pos":[0,48]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[223,260],"content":"Deconstructing tuples and other types","linkify":"Deconstructing tuples and other types","nodes":[{"content":"Deconstructing tuples and other types","pos":[0,37]}]},{"content":"A tuple provides a light-weight way to retrieve multiple values from a method call.","pos":[262,345]},{"content":"But once you retrieve the tuple, you have to handle its individual elements.","pos":[346,422]},{"content":"Doing this on an element-by-element basis is cumbersome, as the following example shows.","pos":[423,511]},{"content":"The <ph id=\"ph1\">`QueryCityData`</ph> method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.","pos":[512,633],"source":" The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation."},{"content":"Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.","pos":[767,942]},{"content":"Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single <bpt id=\"p1\">*</bpt>deconstruct<ept id=\"p1\">*</ept> operation.","pos":[944,1123],"source":"Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation."},{"content":"When you deconstruct a tuple, you assign its elements to individual variables.","pos":[1124,1202]},{"content":"When you deconstruct an object, you assign selected values to individual variables.","pos":[1203,1286]},{"pos":[1291,1313],"content":"Deconstructing a tuple","linkify":"Deconstructing a tuple","nodes":[{"content":"Deconstructing a tuple","pos":[0,22]}]},{"content":"C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.","pos":[1315,1443]},{"content":"The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.","pos":[1444,1658]},{"content":"For example, the following statement assigns the elements of a 4-tuple to four separate variables:","pos":[1659,1757]},{"content":"There are three ways to deconstruct a tuple:","pos":[1833,1877]},{"content":"You can explicitly declare the type of each field inside parentheses.","pos":[1881,1950]},{"content":"The following example uses this approach to deconstruct the 3-tuple returned by the <ph id=\"ph1\">`QueryCityData`</ph> method.","pos":[1951,2058],"source":" The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method."},{"content":"You can use the <ph id=\"ph1\">`var`</ph> keyword so that C# infers the type of each variable.","pos":[2202,2276],"source":"You can use the `var` keyword so that C# infers the type of each variable."},{"content":"You place the <ph id=\"ph1\">`var`</ph> keyword outside of the parentheses.","pos":[2277,2332],"source":" You place the `var` keyword outside of the parentheses."},{"content":"The following example uses type inference when deconstructing the 3-tuple returned by the <ph id=\"ph1\">`QueryCityData`</ph> method.","pos":[2333,2446],"source":" The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method."},{"pos":[2589,2705],"content":"You can also use the <ph id=\"ph1\">`var`</ph> keyword individually with any or all of the variable declarations inside the parentheses.","source":"You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses."},{"content":"This is cumbersome and is not recommended.","pos":[2853,2895]},{"content":"Lastly, you may deconstruct the tuple into variables that have already been declared.","pos":[2899,2984]},{"content":"Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.","pos":[3126,3246],"source":"Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the\nsame type."},{"content":"This generates compiler error CS8136, \"Deconstruction 'var (...)' form disallows a specific type for 'var'.\".","pos":[3247,3356]},{"content":"Note that you must also assign each element of the tuple to a variable.","pos":[3358,3429]},{"content":"If you omit any elements, the compiler generates error CS8132, \"Cannot deconstruct a tuple of 'x' elements into 'y' variables.\"","pos":[3430,3557]},{"content":"Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.","pos":[3559,3677]},{"content":"The compiler generates error CS8184, \"a deconstruction cannot mix declarations and expressions on the left-hand-side.\"","pos":[3678,3796]},{"content":"when the members include newly declared and existing variables.","pos":[3797,3860]},{"pos":[3865,3908],"content":"Deconstructing tuple elements with discards","linkify":"Deconstructing tuple elements with discards","nodes":[{"content":"Deconstructing tuple elements with discards","pos":[0,43]}]},{"content":"Often when deconstructing a tuple, you're interested in the values of only some elements.","pos":[3910,3999]},{"content":"Starting with C# 7.0, you can take advantage of C#'s support for <bpt id=\"p1\">*</bpt>discards<ept id=\"p1\">*</ept>, which are write-only variables whose values you've chosen to ignore.","pos":[4000,4145],"source":" Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore."},{"content":"A discard is designated by an underscore character (\"<ph id=\"ph1\">\\_</ph>\") in an assignment.","pos":[4146,4221],"source":" A discard is designated by an underscore character (\"\\_\") in an assignment."},{"content":"You can discard as many values as you like; all are represented by the single discard, <ph id=\"ph1\">`_`</ph>.","pos":[4222,4313],"source":" You can discard as many values as you like; all are represented by the single discard, `_`."},{"content":"The following example illustrates the use of tuples with discards.","pos":[4315,4381]},{"content":"The <ph id=\"ph1\">`QueryCityDataForYears`</ph> method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.","pos":[4382,4577],"source":" The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year."},{"content":"The example shows the change in population between those two years.","pos":[4578,4645]},{"content":"Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.","pos":[4646,4781]},{"content":"As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.","pos":[4782,4915]},{"pos":[5043,5076],"content":"Deconstructing user-defined types","linkify":"Deconstructing user-defined types","nodes":[{"content":"Deconstructing user-defined types","pos":[0,33]}]},{"content":"Non-tuple types do not offer built-in support for discards.","pos":[5078,5137]},{"content":"However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more <ph id=\"ph1\">`Deconstruct`</ph> methods.","pos":[5138,5306],"source":" However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods."},{"content":"The method returns void, and each value to be deconstructed is indicated by an <bpt id=\"p1\">[</bpt>out<ept id=\"p1\">](language-reference/keywords/out-parameter-modifier.md)</ept> parameter in the method signature.","pos":[5307,5481],"source":" The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature."},{"content":"For example, the following <ph id=\"ph1\">`Deconstruct`</ph> method of a <ph id=\"ph2\">`Person`</ph> class returns the first, middle, and last name:","pos":[5482,5591],"source":" For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:"},{"pos":[5723,5830],"content":"You can then deconstruct an instance of the <ph id=\"ph1\">`Person`</ph> class named <ph id=\"ph2\">`p`</ph> with an assignment like the following:","source":"You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:"},{"content":"The following example overloads the <ph id=\"ph1\">`Deconstruct`</ph> method to return various combinations of properties of a <ph id=\"ph2\">`Person`</ph> object.","pos":[5962,6085],"source":"The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object."},{"content":"Individual overloads return:","pos":[6086,6114]},{"content":"A first and last name.","pos":[6118,6140]},{"content":"A first, last, and middle name.","pos":[6143,6174]},{"content":"A first name, a last name, a city name, and a state name.","pos":[6177,6234]},{"content":"Because you can overload the <ph id=\"ph1\">`Deconstruct`</ph> method to reflect groups of data that are commonly extracted from an object, you should be careful to define <ph id=\"ph2\">`Deconstruct`</ph> methods with signatures that are distinctive and unambiguous.","pos":[6364,6591],"source":"Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous."},{"content":"Multiple <ph id=\"ph1\">`Deconstruct`</ph> methods that have the same number of <ph id=\"ph2\">`out`</ph> parameters or the same number and type of <ph id=\"ph3\">`out`</ph> parameters in a different order can cause confusion.","pos":[6592,6758],"source":" Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion."},{"content":"The overloaded <ph id=\"ph1\">`Deconstruct`</ph> method in the following example illustrates one possible source of confusion.","pos":[6760,6866],"source":"The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion."},{"content":"The first overload returns the first name, middle name, last name, and age of a <ph id=\"ph1\">`Person`</ph> object, in that order.","pos":[6867,6978],"source":" The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order."},{"content":"The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.","pos":[6979,7117]},{"content":"This makes it easy to confuse the order of arguments when deconstructing a <ph id=\"ph1\">`Person`</ph> instance.","pos":[7118,7211],"source":" This makes it easy to confuse the order of arguments when deconstructing a `Person` instance."},{"pos":[7351,7399],"content":"Deconstructing a user-defined type with discards","linkify":"Deconstructing a user-defined type with discards","nodes":[{"content":"Deconstructing a user-defined type with discards","pos":[0,48]}]},{"content":"Just as you do with <bpt id=\"p1\">[</bpt>tuples<ept id=\"p1\">](#deconstructing-tuple-elements-with-discards)</ept>, you can use discards to ignore selected items returned by a <ph id=\"ph1\">`Deconstruct`</ph> method.","pos":[7401,7558],"source":"Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method."},{"content":"Each discard is defined by a variable named \"<ph id=\"ph1\">\\_</ph>\", and a single deconstruction operation can include multiple discards.","pos":[7559,7677],"source":" Each discard is defined by a variable named \"\\_\", and a single deconstruction operation can include multiple discards."},{"pos":[7679,7843],"content":"The following example deconstructs a <ph id=\"ph1\">`Person`</ph> object into four strings (the first and last names, the city, and the state) but discards the last name and the state.","source":"The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state."},{"pos":[7970,8029],"content":"Deconstructing a user-defined type with an extension method","linkify":"Deconstructing a user-defined type with an extension method","nodes":[{"content":"Deconstructing a user-defined type with an extension method","pos":[0,59]}]},{"pos":[8031,8300],"content":"If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more <ph id=\"ph1\">`Deconstruct`</ph> <bpt id=\"p1\">[</bpt>extension methods<ept id=\"p1\">](programming-guide/classes-and-structs/extension-methods.md)</ept> to return the values in which you're interested.","source":"If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested."},{"content":"The following example defines two <ph id=\"ph1\">`Deconstruct`</ph> extension methods for the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo?displayProperty=nameWithType&gt;</ph> class.","pos":[8302,8449],"source":"The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class."},{"content":"The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.","pos":[8450,8637]},{"content":"The second indicates the property's accessibility.","pos":[8638,8688]},{"content":"Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.","pos":[8689,8890]},{"content":"If there is only one accessor or both the get and the set accessor have the same accessibility, the <ph id=\"ph1\">`access`</ph> variable indicates the accessibility of the property as a whole.","pos":[8891,9064],"source":" If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole."},{"content":"Otherwise, the accessibility of the get and set accessors are indicated by the <ph id=\"ph1\">`getAccess`</ph> and <ph id=\"ph2\">`setAccess`</ph> variables.","pos":[9065,9182],"source":" Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables."},{"pos":[9323,9331],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9335,9358],"content":"<bpt id=\"p1\">[</bpt>Discards<ept id=\"p1\">](discards.md)</ept>","source":"[Discards](discards.md)"},{"pos":[9361,9380],"content":"<bpt id=\"p1\">[</bpt>Tuples<ept id=\"p1\">](tuples.md)</ept>","source":"[Tuples](tuples.md)"}]}