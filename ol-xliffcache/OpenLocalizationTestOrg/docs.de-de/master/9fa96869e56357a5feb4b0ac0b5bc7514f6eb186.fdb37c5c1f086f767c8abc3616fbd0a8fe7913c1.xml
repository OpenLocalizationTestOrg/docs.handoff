{"content":"---\ntitle: \"Using Async for File Access (C#)\"\nms.date: 07/20/2015\nms.assetid: bb018fea-5313-4c80-ab3f-7c24b2145bd9\n---\n# Using Async for File Access (C#)\nYou can use the async feature to access files. By using the async feature, you can call into asynchronous methods without using callbacks or splitting your code across multiple methods or lambda expressions. To make synchronous code asynchronous, you just call an asynchronous method instead of a synchronous method and add a few keywords to the code.  \n  \n You might consider the following reasons for adding asynchrony to file access calls:  \n  \n-   Asynchrony makes UI applications more responsive because the UI thread that launches the operation can perform other work. If the UI thread must execute code that takes a long time (for example, more than 50 milliseconds), the UI may freeze until the I/O is complete and the UI thread can again process keyboard and mouse input and other events.  \n  \n-   Asynchrony improves the scalability of ASP.NET and other server-based applications by reducing the need for threads. If the application uses a dedicated thread per response and a thousand requests are being handled simultaneously, a thousand threads are needed. Asynchronous operations often don’t need to use a thread during the wait. They use the existing I/O completion thread briefly at the end.  \n  \n-   The latency of a file access operation might be very low under current conditions, but the latency may greatly increase in the future. For example, a file may be moved to a server that's across the world.  \n  \n-   The added overhead of using the Async feature is small.  \n  \n-   Asynchronous tasks can easily be run in parallel.  \n  \n## Running the Examples  \n To run the examples in this topic, you can create a **WPF Application** or a **Windows Forms Application** and then add a **Button**. In the button's `Click` event, add a call to the first method in each example.  \n  \n In the following examples, include the following `using` statements.  \n  \n```csharp  \nusing System;  \nusing System.Collections.Generic;  \nusing System.Diagnostics;  \nusing System.IO;  \nusing System.Text;  \nusing System.Threading.Tasks;  \n```  \n  \n## Use of the FileStream Class  \n The examples in this topic use the <xref:System.IO.FileStream> class, which has an option that causes asynchronous I/O to occur at the operating system level. By using this option, you can avoid blocking a ThreadPool thread in many cases. To enable this option, you specify the `useAsync=true` or `options=FileOptions.Asynchronous` argument in the constructor call.  \n  \n You can’t use this option with <xref:System.IO.StreamReader> and <xref:System.IO.StreamWriter> if you open them directly by specifying a file path. However, you can use this option if you provide them a <xref:System.IO.Stream> that the <xref:System.IO.FileStream> class opened. Note that asynchronous calls are faster in UI apps even if a ThreadPool thread is blocked, because the UI thread isn’t blocked during the wait.  \n  \n## Writing Text  \n The following example writes text to a file. At each await statement, the method immediately exits. When the file I/O is complete, the method resumes at the statement that follows the await statement. Note that the async modifier is in the definition of methods that use the await statement.  \n  \n```csharp  \npublic async void ProcessWrite()  \n{  \n    string filePath = @\"temp2.txt\";  \n    string text = \"Hello World\\r\\n\";  \n  \n    await WriteTextAsync(filePath, text);  \n}  \n  \nprivate async Task WriteTextAsync(string filePath, string text)  \n{  \n    byte[] encodedText = Encoding.Unicode.GetBytes(text);  \n  \n    using (FileStream sourceStream = new FileStream(filePath,  \n        FileMode.Append, FileAccess.Write, FileShare.None,  \n        bufferSize: 4096, useAsync: true))  \n    {  \n        await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);  \n    };  \n}  \n```  \n  \n The original example has the statement `await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);`, which is a contraction of the following two statements:  \n  \n```csharp  \nTask theTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);  \nawait theTask;  \n```  \n  \n The first statement returns a task and causes file processing to start. The second statement with the await causes the method to immediately exit and return a different task. When the file processing later completes, execution returns to the statement that follows the await. For more information, see  [Control Flow in Async Programs (C#)](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md).  \n  \n## Reading Text  \n The following example reads text from a file. The text is buffered and, in this case, placed into a <xref:System.Text.StringBuilder>. Unlike in the previous example, the evaluation of the await produces a value. The <xref:System.IO.Stream.ReadAsync%2A> method returns a <xref:System.Threading.Tasks.Task>\\<<xref:System.Int32>>, so the evaluation of the await produces an `Int32` value (`numRead`) after the operation completes. For more information, see [Async Return Types (C#)](../../../../csharp/programming-guide/concepts/async/async-return-types.md).  \n  \n```csharp  \npublic async void ProcessRead()  \n{  \n    string filePath = @\"temp2.txt\";  \n  \n    if (File.Exists(filePath) == false)  \n    {  \n        Debug.WriteLine(\"file not found: \" + filePath);  \n    }  \n    else  \n    {  \n        try  \n        {  \n            string text = await ReadTextAsync(filePath);  \n            Debug.WriteLine(text);  \n        }  \n        catch (Exception ex)  \n        {  \n            Debug.WriteLine(ex.Message);  \n        }  \n    }  \n}  \n  \nprivate async Task<string> ReadTextAsync(string filePath)  \n{  \n    using (FileStream sourceStream = new FileStream(filePath,  \n        FileMode.Open, FileAccess.Read, FileShare.Read,  \n        bufferSize: 4096, useAsync: true))  \n    {  \n        StringBuilder sb = new StringBuilder();  \n  \n        byte[] buffer = new byte[0x1000];  \n        int numRead;  \n        while ((numRead = await sourceStream.ReadAsync(buffer, 0, buffer.Length)) != 0)  \n        {  \n            string text = Encoding.Unicode.GetString(buffer, 0, numRead);  \n            sb.Append(text);  \n        }  \n  \n        return sb.ToString();  \n    }  \n}  \n```  \n  \n## Parallel Asynchronous I/O  \n The following example demonstrates parallel processing by writing 10 text files. For each file, the <xref:System.IO.Stream.WriteAsync%2A> method returns a task that is then added to a list of tasks. The `await Task.WhenAll(tasks);` statement exits the method and resumes within the method when file processing is complete for all of the tasks.  \n  \n The example closes all <xref:System.IO.FileStream> instances in a `finally` block after the tasks are complete. If each `FileStream` was instead created in a `using` statement, the `FileStream` might be disposed of before the task was complete.  \n  \n Note that any performance boost is almost entirely from the parallel processing and not the asynchronous processing. The advantages of asynchrony are that it doesn’t tie up multiple threads, and that it doesn’t tie up the user interface thread.  \n  \n```csharp  \npublic async void ProcessWriteMult()  \n{  \n    string folder = @\"tempfolder\\\";  \n    List<Task> tasks = new List<Task>();  \n    List<FileStream> sourceStreams = new List<FileStream>();  \n  \n    try  \n    {  \n        for (int index = 1; index <= 10; index++)  \n        {  \n            string text = \"In file \" + index.ToString() + \"\\r\\n\";  \n  \n            string fileName = \"thefile\" + index.ToString(\"00\") + \".txt\";  \n            string filePath = folder + fileName;  \n  \n            byte[] encodedText = Encoding.Unicode.GetBytes(text);  \n  \n            FileStream sourceStream = new FileStream(filePath,  \n                FileMode.Append, FileAccess.Write, FileShare.None,  \n                bufferSize: 4096, useAsync: true);  \n  \n            Task theTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);  \n            sourceStreams.Add(sourceStream);  \n  \n            tasks.Add(theTask);  \n        }  \n  \n        await Task.WhenAll(tasks);  \n    }  \n  \n    finally  \n    {  \n        foreach (FileStream sourceStream in sourceStreams)  \n        {  \n            sourceStream.Close();  \n        }  \n    }  \n}  \n```  \n  \n When using the <xref:System.IO.Stream.WriteAsync%2A> and <xref:System.IO.Stream.ReadAsync%2A> methods, you can specify a <xref:System.Threading.CancellationToken>, which you can use to cancel the operation mid-stream. For more information, see [Fine-Tuning Your Async Application (C#)](../../../../csharp/programming-guide/concepts/async/fine-tuning-your-async-application.md) and [Cancellation in Managed Threads](../../../../standard/threading/cancellation-in-managed-threads.md).  \n  \n## See also\n\n- [Asynchronous Programming with async and await (C#)](../../../../csharp/programming-guide/concepts/async/index.md)\n- [Async Return Types (C#)](../../../../csharp/programming-guide/concepts/async/async-return-types.md)\n- [Control Flow in Async Programs (C#)](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)\n","nodes":[{"pos":[4,114],"embed":true,"restype":"x-metadata","content":"title: \"Using Async for File Access (C#)\"\nms.date: 07/20/2015\nms.assetid: bb018fea-5313-4c80-ab3f-7c24b2145bd9","nodes":[{"content":"Using Async for File Access (C#)","nodes":[{"pos":[0,32],"content":"Using Async for File Access (C#)","nodes":[{"content":"Using Async for File Access (C#)","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[121,153],"content":"Using Async for File Access (C#)","linkify":"Using Async for File Access (C#)","nodes":[{"content":"Using Async for File Access (C#)","pos":[0,32]}]},{"content":"You can use the async feature to access files.","pos":[154,200]},{"content":"By using the async feature, you can call into asynchronous methods without using callbacks or splitting your code across multiple methods or lambda expressions.","pos":[201,361]},{"content":"To make synchronous code asynchronous, you just call an asynchronous method instead of a synchronous method and add a few keywords to the code.","pos":[362,505]},{"content":"You might consider the following reasons for adding asynchrony to file access calls:","pos":[512,596]},{"content":"Asynchrony makes UI applications more responsive because the UI thread that launches the operation can perform other work.","pos":[606,728]},{"content":"If the UI thread must execute code that takes a long time (for example, more than 50 milliseconds), the UI may freeze until the I/O is complete and the UI thread can again process keyboard and mouse input and other events.","pos":[729,951]},{"content":"Asynchrony improves the scalability of ASP.NET and other server-based applications by reducing the need for threads.","pos":[961,1077]},{"content":"If the application uses a dedicated thread per response and a thousand requests are being handled simultaneously, a thousand threads are needed.","pos":[1078,1222]},{"content":"Asynchronous operations often don’t need to use a thread during the wait.","pos":[1223,1296]},{"content":"They use the existing I/O completion thread briefly at the end.","pos":[1297,1360]},{"content":"The latency of a file access operation might be very low under current conditions, but the latency may greatly increase in the future.","pos":[1370,1504]},{"content":"For example, a file may be moved to a server that's across the world.","pos":[1505,1574]},{"content":"The added overhead of using the Async feature is small.","pos":[1584,1639]},{"content":"Asynchronous tasks can easily be run in parallel.","pos":[1649,1698]},{"pos":[1707,1727],"content":"Running the Examples","linkify":"Running the Examples","nodes":[{"content":"Running the Examples","pos":[0,20]}]},{"content":"To run the examples in this topic, you can create a <bpt id=\"p1\">**</bpt>WPF Application<ept id=\"p1\">**</ept> or a <bpt id=\"p2\">**</bpt>Windows Forms Application<ept id=\"p2\">**</ept> and then add a <bpt id=\"p3\">**</bpt>Button<ept id=\"p3\">**</ept>.","pos":[1731,1864],"source":"To run the examples in this topic, you can create a **WPF Application** or a **Windows Forms Application** and then add a **Button**."},{"content":"In the button's <ph id=\"ph1\">`Click`</ph> event, add a call to the first method in each example.","pos":[1865,1943],"source":" In the button's `Click` event, add a call to the first method in each example."},{"pos":[1950,2018],"content":"In the following examples, include the following <ph id=\"ph1\">`using`</ph> statements.","source":"In the following examples, include the following `using` statements."},{"pos":[2200,2227],"content":"Use of the FileStream Class","linkify":"Use of the FileStream Class","nodes":[{"content":"Use of the FileStream Class","pos":[0,27]}]},{"content":"The examples in this topic use the <ph id=\"ph1\">&lt;xref:System.IO.FileStream&gt;</ph> class, which has an option that causes asynchronous I/O to occur at the operating system level.","pos":[2231,2389],"source":"The examples in this topic use the <xref:System.IO.FileStream> class, which has an option that causes asynchronous I/O to occur at the operating system level."},{"content":"By using this option, you can avoid blocking a ThreadPool thread in many cases.","pos":[2390,2469]},{"content":"To enable this option, you specify the <ph id=\"ph1\">`useAsync=true`</ph> or <ph id=\"ph2\">`options=FileOptions.Asynchronous`</ph> argument in the constructor call.","pos":[2470,2596],"source":" To enable this option, you specify the `useAsync=true` or `options=FileOptions.Asynchronous` argument in the constructor call."},{"content":"You can’t use this option with <ph id=\"ph1\">&lt;xref:System.IO.StreamReader&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IO.StreamWriter&gt;</ph> if you open them directly by specifying a file path.","pos":[2603,2750],"source":"You can’t use this option with <xref:System.IO.StreamReader> and <xref:System.IO.StreamWriter> if you open them directly by specifying a file path."},{"content":"However, you can use this option if you provide them a <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph> that the <ph id=\"ph2\">&lt;xref:System.IO.FileStream&gt;</ph> class opened.","pos":[2751,2880],"source":" However, you can use this option if you provide them a <xref:System.IO.Stream> that the <xref:System.IO.FileStream> class opened."},{"content":"Note that asynchronous calls are faster in UI apps even if a ThreadPool thread is blocked, because the UI thread isn’t blocked during the wait.","pos":[2881,3024]},{"pos":[3033,3045],"content":"Writing Text","linkify":"Writing Text","nodes":[{"content":"Writing Text","pos":[0,12]}]},{"content":"The following example writes text to a file.","pos":[3049,3093]},{"content":"At each await statement, the method immediately exits.","pos":[3094,3148]},{"content":"When the file I/O is complete, the method resumes at the statement that follows the await statement.","pos":[3149,3249]},{"content":"Note that the async modifier is in the definition of methods that use the await statement.","pos":[3250,3340]},{"pos":[3939,4103],"content":"The original example has the statement <ph id=\"ph1\">`await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);`</ph>, which is a contraction of the following two statements:","source":"The original example has the statement `await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);`, which is a contraction of the following two statements:"},{"content":"The first statement returns a task and causes file processing to start.","pos":[4226,4297]},{"content":"The second statement with the await causes the method to immediately exit and return a different task.","pos":[4298,4400]},{"content":"When the file processing later completes, execution returns to the statement that follows the await.","pos":[4401,4501]},{"content":"For more information, see  <bpt id=\"p1\">[</bpt>Control Flow in Async Programs (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)</ept>.","pos":[4502,4654],"source":" For more information, see  [Control Flow in Async Programs (C#)](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)."},{"pos":[4663,4675],"content":"Reading Text","linkify":"Reading Text","nodes":[{"content":"Reading Text","pos":[0,12]}]},{"content":"The following example reads text from a file.","pos":[4679,4724]},{"content":"The text is buffered and, in this case, placed into a <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder&gt;</ph>.","pos":[4725,4812],"source":" The text is buffered and, in this case, placed into a <xref:System.Text.StringBuilder>."},{"content":"Unlike in the previous example, the evaluation of the await produces a value.","pos":[4813,4890]},{"content":"The <ph id=\"ph1\">&lt;xref:System.IO.Stream.ReadAsync%2A&gt;</ph> method returns a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph><ph id=\"ph3\">\\&lt;</ph><ph id=\"ph4\">&lt;xref:System.Int32&gt;</ph>&gt;, so the evaluation of the await produces an <ph id=\"ph5\">`Int32`</ph> value (<ph id=\"ph6\">`numRead`</ph>) after the operation completes.","pos":[4891,5106],"source":" The <xref:System.IO.Stream.ReadAsync%2A> method returns a <xref:System.Threading.Tasks.Task>\\<<xref:System.Int32>>, so the evaluation of the await produces an `Int32` value (`numRead`) after the operation completes."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Async Return Types (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/async/async-return-types.md)</ept>.","pos":[5107,5234],"source":" For more information, see [Async Return Types (C#)](../../../../csharp/programming-guide/concepts/async/async-return-types.md)."},{"pos":[6352,6377],"content":"Parallel Asynchronous I/O","linkify":"Parallel Asynchronous I/O","nodes":[{"content":"Parallel Asynchronous I/O","pos":[0,25]}]},{"content":"The following example demonstrates parallel processing by writing 10 text files.","pos":[6381,6461]},{"content":"For each file, the <ph id=\"ph1\">&lt;xref:System.IO.Stream.WriteAsync%2A&gt;</ph> method returns a task that is then added to a list of tasks.","pos":[6462,6579],"source":" For each file, the <xref:System.IO.Stream.WriteAsync%2A> method returns a task that is then added to a list of tasks."},{"content":"The <ph id=\"ph1\">`await Task.WhenAll(tasks);`</ph> statement exits the method and resumes within the method when file processing is complete for all of the tasks.","pos":[6580,6724],"source":" The `await Task.WhenAll(tasks);` statement exits the method and resumes within the method when file processing is complete for all of the tasks."},{"content":"The example closes all <ph id=\"ph1\">&lt;xref:System.IO.FileStream&gt;</ph> instances in a <ph id=\"ph2\">`finally`</ph> block after the tasks are complete.","pos":[6731,6842],"source":"The example closes all <xref:System.IO.FileStream> instances in a `finally` block after the tasks are complete."},{"content":"If each <ph id=\"ph1\">`FileStream`</ph> was instead created in a <ph id=\"ph2\">`using`</ph> statement, the <ph id=\"ph3\">`FileStream`</ph> might be disposed of before the task was complete.","pos":[6843,6975],"source":" If each `FileStream` was instead created in a `using` statement, the `FileStream` might be disposed of before the task was complete."},{"content":"Note that any performance boost is almost entirely from the parallel processing and not the asynchronous processing.","pos":[6982,7098]},{"content":"The advantages of asynchrony are that it doesn’t tie up multiple threads, and that it doesn’t tie up the user interface thread.","pos":[7099,7226]},{"content":"When using the <ph id=\"ph1\">&lt;xref:System.IO.Stream.WriteAsync%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IO.Stream.ReadAsync%2A&gt;</ph> methods, you can specify a <ph id=\"ph3\">&lt;xref:System.Threading.CancellationToken&gt;</ph>, which you can use to cancel the operation mid-stream.","pos":[8379,8596],"source":"When using the <xref:System.IO.Stream.WriteAsync%2A> and <xref:System.IO.Stream.ReadAsync%2A> methods, you can specify a <xref:System.Threading.CancellationToken>, which you can use to cancel the operation mid-stream."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Fine-Tuning Your Async Application (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/async/fine-tuning-your-async-application.md)</ept> and <bpt id=\"p2\">[</bpt>Cancellation in Managed Threads<ept id=\"p2\">](../../../../standard/threading/cancellation-in-managed-threads.md)</ept>.","pos":[8597,8861],"source":" For more information, see [Fine-Tuning Your Async Application (C#)](../../../../csharp/programming-guide/concepts/async/fine-tuning-your-async-application.md) and [Cancellation in Managed Threads](../../../../standard/threading/cancellation-in-managed-threads.md)."},{"pos":[8870,8878],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8882,8996],"content":"<bpt id=\"p1\">[</bpt>Asynchronous Programming with async and await (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/async/index.md)</ept>","source":"[Asynchronous Programming with async and await (C#)](../../../../csharp/programming-guide/concepts/async/index.md)"},{"pos":[8999,9099],"content":"<bpt id=\"p1\">[</bpt>Async Return Types (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/async/async-return-types.md)</ept>","source":"[Async Return Types (C#)](../../../../csharp/programming-guide/concepts/async/async-return-types.md)"},{"pos":[9102,9226],"content":"<bpt id=\"p1\">[</bpt>Control Flow in Async Programs (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)</ept>","source":"[Control Flow in Async Programs (C#)](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)"}]}