{"content":"---\ntitle: \"Cryptographic Services\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords:\n  - \"cryptography [.NET Framework]\"\n  - \"pattern of derived class inheritance\"\n  - \"digital signatures\"\n  - \"asymmetric cryptographic algorithms\"\n  - \"digital signatures, public-key systems\"\n  - \"public keys\"\n  - \"decryption [.NET Framework]\"\n  - \"private keys\"\n  - \"MAC algorithms\"\n  - \"cryptographic algorithms\"\n  - \"private keys, overview\"\n  - \"encryption [.NET Framework]\"\n  - \"security [.NET Framework], encryption\"\n  - \"cryptographic services\"\n  - \"symmetric cryptographic algorithms\"\n  - \"hash\"\n  - \"message authentication codes\"\n  - \"derived class inheritance\"\n  - \"cryptography [.NET Framework], about\"\n  - \"random number generation\"\nms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n\n# Cryptographic Services\n\n<a name=\"top\"></a> Public networks such as the Internet do not provide a means of secure communication between entities. Communication over such networks is susceptible to being read or even modified by unauthorized third parties. Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels. For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party. If a third party intercepts the encrypted data, it will be difficult to decipher.\n\nIn the .NET Framework, the classes in the <xref:System.Security.Cryptography?displayProperty=nameWithType> namespace manage many details of cryptography for you. Some are wrappers for the unmanaged Microsoft Cryptography API (CryptoAPI), while others are purely managed implementations. You do not need to be an expert in cryptography to use these classes. When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.\n\nThis overview provides a synopsis of the encryption methods and practices supported by the .NET Framework, including the ClickOnce manifests, Suite B, and Cryptography Next Generation (CNG) support introduced in the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)].\n\nThis overview contains the following sections:\n\n- [Cryptographic Primitives](#primitives)\n\n- [Secret-Key Encryption](#secret_key)\n\n- [Public-Key Encryption](#public_key)\n\n- [Digital Signatures](#digital_signatures)\n\n- [Hash Values](#hash_values)\n\n- [Random Number Generation](#random_numbers)\n\n- [ClickOnce Manifests](#clickonce)\n\n- [Suite B Support](#suite_b)\n\n- [Related Topics](#related_topics)\n\nFor additional information about cryptography and about Microsoft services, components, and tools that enable you to add cryptographic security to your applications, see the Win32 and COM Development, Security section of this documentation.\n\n<a name=\"primitives\"></a>\n\n## Cryptographic Primitives\n\nIn a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel. Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening. Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission. In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.\n\nCryptography is used to achieve the following goals:\n\n- Confidentiality: To help protect a user's identity or data from being read.\n\n- Data integrity: To help protect data from being changed.\n\n- Authentication: To ensure that data originates from a particular party.\n\n- Non-repudiation: To prevent a particular party from denying that they sent a message.\n\nTo achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme. The following table lists the cryptographic primitives and their uses.\n\n|Cryptographic primitive|Use|\n|-----------------------------|---------|\n|Secret-key encryption (symmetric cryptography)|Performs a transformation on data to keep it from being read by third parties. This type of encryption uses a single shared, secret key to encrypt and decrypt data.|\n|Public-key encryption (asymmetric cryptography)|Performs a transformation on data to keep it from being read by third parties. This type of encryption uses a public/private key pair to encrypt and decrypt data.|\n|Cryptographic signing|Helps verify that data originates from a specific party by creating a digital signature that is unique to that party. This process also uses hash functions.|\n|Cryptographic hashes|Maps data from any length to a fixed-length byte sequence. Hashes are statistically unique; a different two-byte sequence will not hash to the same value.|\n\n[Back to top](#top)\n\n<a name=\"secret_key\"></a>\n\n## Secret-Key Encryption\n\nSecret-key encryption algorithms use a single secret key to encrypt and decrypt data. You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.\n\nSecret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption. Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data. Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt. Symmetric encryption algorithms do not generally have those problems.\n\nA type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time. Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes. If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block. Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time. Data values that are smaller than *n* have to be expanded to *n* in order to be processed.\n\nOne simple form of block cipher is called the electronic codebook (ECB) mode. ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block. For a given secret key *k*, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext. Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream. These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack. The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.\n\nThe block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.\n\nCBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext. Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted. Each ciphertext block is therefore dependent on all previous blocks. When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.\n\nOne way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key. Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible. Larger key sizes are more difficult to decipher. Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this. If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.\n\nThe disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values. The IV is not considered a secret and can be transmitted in plaintext with the message. However, the key must be kept secret from unauthorized users. Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.\n\nAssuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV. Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message. Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet. Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key. If the transmission is intercepted, the interceptor cannot recover the original message, because he does not know the key. In this scenario, only the key must remain secret. In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party. For more information about public-key encryption, see the next section.\n\nThe [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement secret-key encryption algorithms:\n\n- <xref:System.Security.Cryptography.AesManaged> (introduced in the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]).\n\n- <xref:System.Security.Cryptography.DESCryptoServiceProvider>.\n\n- <xref:System.Security.Cryptography.HMACSHA1> (This is technically a secret-key algorithm because it represents message authentication code that is calculated by using a cryptographic hash function combined with a secret key. See [Hash Values](#hash_values), later in this topic.)\n\n- <xref:System.Security.Cryptography.RC2CryptoServiceProvider>.\n\n- <xref:System.Security.Cryptography.RijndaelManaged>.\n\n- <xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>.\n\n[Back to top](#top)\n\n<a name=\"public_key\"></a>\n\n## Public-Key Encryption\n\nPublic-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone. The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key. The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key. Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data. A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session. However, in practice, asymmetric keys are generally long-lived.\n\nTwo parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair. If Bob wants to send Alice an encrypted message, he asks her for her public key. Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message. Bob sends the encrypted message to Alice, and she decrypts it by using her private key. If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack. Therefore, Bob must verify with Alice that he has a correct copy of her public key.\n\nDuring the transmission of Alice's public key, an unauthorized agent might intercept the key. Furthermore, the same agent might intercept the encrypted message from Bob. However, the agent cannot decrypt the message with the public key. The message can be decrypted only with Alice's private key, which has not been transmitted. Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message. If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key. Bob then decrypts the message using his associated private key.\n\nIn this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.\n\nThe following list offers comparisons between public-key and secret-key cryptographic algorithms:\n\n- Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.\n\n- Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted. Therefore, asymmetric operations do not use the same streaming model as symmetric operations.\n\n- Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption. Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.\n\n- Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.\n\n- Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.\n\n- Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data. Public-key algorithms are useful only for transferring very small amounts of data. Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm. After the key and IV are transferred, secret-key encryption is used for the remainder of the session.\n\nThe [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement public-key encryption algorithms:\n\n- <xref:System.Security.Cryptography.DSACryptoServiceProvider>\n\n- <xref:System.Security.Cryptography.RSACryptoServiceProvider>\n\n- <xref:System.Security.Cryptography.ECDiffieHellman> (base class)\n\n- <xref:System.Security.Cryptography.ECDiffieHellmanCng>\n\n- <xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey> (base class)\n\n- <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> (base class)\n\n- <xref:System.Security.Cryptography.ECDsaCng>\n\nRSA allows both encryption and signing, but DSA can be used only for signing, and Diffie-Hellman can be used only for key generation. In general, public-key algorithms are more limited in their uses than private-key algorithms.\n\n[Back to top](#top)\n\n<a name=\"digital_signatures\"></a>\n\n## Digital Signatures\n\nPublic-key algorithms can also be used to form digital signatures. Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data. Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.\n\nTo use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest. The message digest is a compact and unique representation of data. Alice then encrypts the message digest with her private key to create her personal signature. Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used. If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified. If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.\n\n> [!NOTE]\n> A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format. This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.\n\nThe [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement digital signature algorithms:\n\n- <xref:System.Security.Cryptography.DSACryptoServiceProvider>\n\n- <xref:System.Security.Cryptography.RSACryptoServiceProvider>\n\n- <xref:System.Security.Cryptography.ECDsa> (base class)\n\n- <xref:System.Security.Cryptography.ECDsaCng>\n\n [Back to top](#top)\n\n<a name=\"hash_values\"></a>\n\n## Hash Values\n\nHash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values. A hash value is a numerical representation of a piece of data. If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value. If the hash is cryptographically strong, its value will change significantly. For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent. Many input values may hash to the same output value. However, it is computationally infeasible to find two distinct inputs that hash to the same value.\n\nTwo parties (Alice and Bob) could use a hash function to ensure message integrity. They would select a hash algorithm to sign their messages. Alice would write a message, and then create a hash of that message by using the selected algorithm. They would then follow one of the following methods:\n\n- Alice sends the plaintext message and the hashed message (digital signature) to Bob. Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice. If the hash values are identical, the message was not altered. If the values are not identical, the message was altered after Alice wrote it.\n\n    Unfortunately, this method does not establish the authenticity of the sender. Anyone can impersonate Alice and send a message to Bob. They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature. This is one form of a man-in-the-middle attack. For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100)).\n\n- Alice sends the plaintext message to Bob over a nonsecure public channel. She sends the hashed message to Bob over a secure private channel. Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash. If the hashes match, Bob knows two things:\n\n    - The message was not altered.\n\n    - The sender of the message (Alice) is authentic.\n\n    For this system to work, Alice must hide her original hash value from all parties except Bob.\n\n- Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.\n\n    This method prevents message tampering by preventing anyone from modifying the hash value. Although the message and its hash can be read by anyone, the hash value can be changed only by Alice. An attacker who wants to impersonate Alice would require access to Alice's Web site.\n\nNone of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext. Full security typically requires digital signatures (message signing) and encryption.\n\nThe [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement hashing algorithms:\n\n- <xref:System.Security.Cryptography.HMACSHA1>.\n\n- <xref:System.Security.Cryptography.MACTripleDES>.\n\n- <xref:System.Security.Cryptography.MD5CryptoServiceProvider>.\n\n- <xref:System.Security.Cryptography.RIPEMD160>.\n\n- <xref:System.Security.Cryptography.SHA1Managed>.\n\n- <xref:System.Security.Cryptography.SHA256Managed>.\n\n- <xref:System.Security.Cryptography.SHA384Managed>.\n\n- <xref:System.Security.Cryptography.SHA512Managed>.\n\n- HMAC variants of all of the Secure Hash Algorithm (SHA), Message Digest 5 (MD5), and RIPEMD-160 algorithms.\n\n- CryptoServiceProvider implementations (managed code wrappers) of all the SHA algorithms.\n\n- Cryptography Next Generation (CNG) implementations of all the MD5 and SHA algorithms.\n\n> [!NOTE]\n> MD5 design flaws were discovered in 1996, and SHA-1 was recommended instead. In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure. The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.\n\n[Back to top](#top)\n\n<a name=\"random_numbers\"></a>\n\n## Random Number Generation\n\nRandom number generation is integral to many cryptographic operations. For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them. Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half. Therefore, any method of predicting the next output bit must not perform better than random guessing. The classes in the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] use random number generators to generate cryptographic keys.\n\nThe <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class is an implementation of a random number generator algorithm.\n\n[Back to top](#top)\n\n<a name=\"clickonce\"></a>\n\n## ClickOnce Manifests\n\nIn the [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)], the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):\n\n- The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads.\n\n- You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify. The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values.\n\n- The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures.\n\n In addition, the following classes provide specific signature information:\n\n- <xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest.\n\n- <xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest.\n\n- <xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature.\n\n- <xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted.\n\n[Back to top](#top)\n\n<a name=\"suite_b\"></a>\n\n## Suite B Support\n\nThe [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] supports the Suite B set of cryptographic algorithms published by the National Security Agency (NSA). For more information about Suite B, see the [NSA Suite B Cryptography Fact Sheet](https://www.nsa.gov/what-we-do/information-assurance/).\n\nThe following algorithms are included:\n\n- Advanced Encryption Standard (AES) algorithm with key sizes of 128, 192, , and 256 bits for encryption.\n\n- Secure Hash Algorithms SHA-1, SHA-256, SHA-384, and SHA-512 for hashing. (The last three are generally grouped together and referred to as SHA-2.)\n\n- Elliptic Curve Digital Signature Algorithm (ECDSA), using curves of 256-bit, 384-bit, and 521-bit prime moduli for signing. The NSA documentation specifically defines these curves, and calls them P-256, P-384, and P-521. This algorithm is provided by the <xref:System.Security.Cryptography.ECDsaCng> class. It enables you to sign with a private key and verify the signature with a public key.\n\n- Elliptic Curve Diffie-Hellman (ECDH) algorithm, using curves of 256-bit, 384-bit, and 521-bit prime moduli for the key exchange and secret agreement. This algorithm is provided by the <xref:System.Security.Cryptography.ECDiffieHellmanCng> class.\n\nManaged code wrappers for the Federal Information Processing Standard (FIPS) certified implementations of the AES, SHA-256, SHA-384, and SHA-512 implementations are available in the new <xref:System.Security.Cryptography.AesCryptoServiceProvider>, <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>, <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>, and <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> classes.\n\n[Back to top](#top)\n\n<a name=\"cng\"></a>\n\n## Cryptography Next Generation (CNG) Classes\n\nThe Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions. (CNG is the replacement for CryptoAPI.) These classes have \"Cng\" as part of their names. Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys. This class lets you store a key pair or a public key securely and refer to it by using a simple string name. The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects.\n\nThe <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys. It also provides access to the underlying key handle to use when calling native functions directly.\n\nThe [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] also includes a variety of supporting CNG classes, such as the following:\n\n- <xref:System.Security.Cryptography.CngProvider> maintains a key storage provider.\n\n- <xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm.\n\n- <xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties.\n\n[Back to top](#top)\n\n<a name=\"related_topics\"></a>\n\n## Related Topics\n\n|Title|Description|\n|-----------|-----------------|\n|[Cryptography Model](../../../docs/standard/security/cryptography-model.md)|Describes how cryptography is implemented in the base class library.|\n|[Walkthrough: Creating a Cryptographic Application](../../../docs/standard/security/walkthrough-creating-a-cryptographic-application.md)|Demonstrates basic encryption and decryption tasks.|\n|[Configuring Cryptography Classes](../../../docs/framework/configure-apps/configure-cryptography-classes.md)|Describes how to map algorithm names to cryptographic classes and map object identifiers to a cryptographic algorithm.|\n","nodes":[{"pos":[4,838],"embed":true,"restype":"x-metadata","content":"title: \"Cryptographic Services\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords:\n  - \"cryptography [.NET Framework]\"\n  - \"pattern of derived class inheritance\"\n  - \"digital signatures\"\n  - \"asymmetric cryptographic algorithms\"\n  - \"digital signatures, public-key systems\"\n  - \"public keys\"\n  - \"decryption [.NET Framework]\"\n  - \"private keys\"\n  - \"MAC algorithms\"\n  - \"cryptographic algorithms\"\n  - \"private keys, overview\"\n  - \"encryption [.NET Framework]\"\n  - \"security [.NET Framework], encryption\"\n  - \"cryptographic services\"\n  - \"symmetric cryptographic algorithms\"\n  - \"hash\"\n  - \"message authentication codes\"\n  - \"derived class inheritance\"\n  - \"cryptography [.NET Framework], about\"\n  - \"random number generation\"\nms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Cryptographic Services","nodes":[{"pos":[0,22],"content":"Cryptographic Services","nodes":[{"content":"Cryptographic Services","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[846,868],"content":"Cryptographic Services","linkify":"Cryptographic Services","nodes":[{"content":"Cryptographic Services","pos":[0,22]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Public networks such as the Internet do not provide a means of secure communication between entities.","pos":[870,990],"source":"<a name=\"top\"></a> Public networks such as the Internet do not provide a means of secure communication between entities."},{"content":"Communication over such networks is susceptible to being read or even modified by unauthorized third parties.","pos":[991,1100]},{"content":"Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.","pos":[1101,1292]},{"content":"For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.","pos":[1293,1441]},{"content":"If a third party intercepts the encrypted data, it will be difficult to decipher.","pos":[1442,1523]},{"content":"In the .NET Framework, the classes in the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography?displayProperty=nameWithType&gt;</ph> namespace manage many details of cryptography for you.","pos":[1525,1686],"source":"In the .NET Framework, the classes in the <xref:System.Security.Cryptography?displayProperty=nameWithType> namespace manage many details of cryptography for you."},{"content":"Some are wrappers for the unmanaged Microsoft Cryptography API (CryptoAPI), while others are purely managed implementations.","pos":[1687,1811]},{"content":"You do not need to be an expert in cryptography to use these classes.","pos":[1812,1881]},{"content":"When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.","pos":[1882,2055]},{"pos":[2057,2336],"content":"This overview provides a synopsis of the encryption methods and practices supported by the .NET Framework, including the ClickOnce manifests, Suite B, and Cryptography Next Generation (CNG) support introduced in the <ph id=\"ph1\">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph>.","source":"This overview provides a synopsis of the encryption methods and practices supported by the .NET Framework, including the ClickOnce manifests, Suite B, and Cryptography Next Generation (CNG) support introduced in the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]."},{"content":"This overview contains the following sections:","pos":[2338,2384]},{"pos":[2388,2427],"content":"<bpt id=\"p1\">[</bpt>Cryptographic Primitives<ept id=\"p1\">](#primitives)</ept>","source":"[Cryptographic Primitives](#primitives)"},{"pos":[2431,2467],"content":"<bpt id=\"p1\">[</bpt>Secret-Key Encryption<ept id=\"p1\">](#secret_key)</ept>","source":"[Secret-Key Encryption](#secret_key)"},{"pos":[2471,2507],"content":"<bpt id=\"p1\">[</bpt>Public-Key Encryption<ept id=\"p1\">](#public_key)</ept>","source":"[Public-Key Encryption](#public_key)"},{"pos":[2511,2552],"content":"<bpt id=\"p1\">[</bpt>Digital Signatures<ept id=\"p1\">](#digital_signatures)</ept>","source":"[Digital Signatures](#digital_signatures)"},{"pos":[2556,2583],"content":"<bpt id=\"p1\">[</bpt>Hash Values<ept id=\"p1\">](#hash_values)</ept>","source":"[Hash Values](#hash_values)"},{"pos":[2587,2630],"content":"<bpt id=\"p1\">[</bpt>Random Number Generation<ept id=\"p1\">](#random_numbers)</ept>","source":"[Random Number Generation](#random_numbers)"},{"pos":[2634,2667],"content":"<bpt id=\"p1\">[</bpt>ClickOnce Manifests<ept id=\"p1\">](#clickonce)</ept>","source":"[ClickOnce Manifests](#clickonce)"},{"pos":[2671,2698],"content":"<bpt id=\"p1\">[</bpt>Suite B Support<ept id=\"p1\">](#suite_b)</ept>","source":"[Suite B Support](#suite_b)"},{"pos":[2702,2735],"content":"<bpt id=\"p1\">[</bpt>Related Topics<ept id=\"p1\">](#related_topics)</ept>","source":"[Related Topics](#related_topics)"},{"content":"For additional information about cryptography and about Microsoft services, components, and tools that enable you to add cryptographic security to your applications, see the Win32 and COM Development, Security section of this documentation.","pos":[2737,2977]},{"pos":[3009,3033],"content":"Cryptographic Primitives","linkify":"Cryptographic Primitives","nodes":[{"content":"Cryptographic Primitives","pos":[0,24]}]},{"content":"In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.","pos":[3035,3151]},{"content":"Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.","pos":[3152,3264]},{"content":"Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.","pos":[3265,3441]},{"content":"In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.","pos":[3442,3572]},{"content":"Cryptography is used to achieve the following goals:","pos":[3574,3626]},{"content":"Confidentiality: To help protect a user's identity or data from being read.","pos":[3630,3705]},{"content":"Data integrity: To help protect data from being changed.","pos":[3709,3765]},{"content":"Authentication: To ensure that data originates from a particular party.","pos":[3769,3840]},{"content":"Non-repudiation: To prevent a particular party from denying that they sent a message.","pos":[3844,3929]},{"content":"To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.","pos":[3931,4076]},{"content":"The following table lists the cryptographic primitives and their uses.","pos":[4077,4147]},{"content":"Cryptographic primitive","pos":[4150,4173]},{"content":"Use","pos":[4174,4177]},{"content":"Secret-key encryption (symmetric cryptography)","pos":[4222,4268]},{"content":"Performs a transformation on data to keep it from being read by third parties.","pos":[4269,4347]},{"content":"This type of encryption uses a single shared, secret key to encrypt and decrypt data.","pos":[4348,4433]},{"content":"Public-key encryption (asymmetric cryptography)","pos":[4436,4483]},{"content":"Performs a transformation on data to keep it from being read by third parties.","pos":[4484,4562]},{"content":"This type of encryption uses a public/private key pair to encrypt and decrypt data.","pos":[4563,4646]},{"content":"Cryptographic signing","pos":[4649,4670]},{"content":"Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.","pos":[4671,4788]},{"content":"This process also uses hash functions.","pos":[4789,4827]},{"content":"Cryptographic hashes","pos":[4830,4850]},{"content":"Maps data from any length to a fixed-length byte sequence.","pos":[4851,4909]},{"content":"Hashes are statistically unique; a different two-byte sequence will not hash to the same value.","pos":[4910,5005]},{"pos":[5008,5027],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[5059,5080],"content":"Secret-Key Encryption","linkify":"Secret-Key Encryption","nodes":[{"content":"Secret-Key Encryption","pos":[0,21]}]},{"content":"Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.","pos":[5082,5167]},{"content":"You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.","pos":[5168,5354]},{"content":"Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.","pos":[5356,5481]},{"content":"Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.","pos":[5482,5657]},{"content":"Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.","pos":[5658,5764]},{"content":"Symmetric encryption algorithms do not generally have those problems.","pos":[5765,5834]},{"content":"A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.","pos":[5836,5936]},{"content":"Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> bytes into an output block of encrypted bytes.","pos":[5937,6137],"source":" Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes."},{"content":"If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.","pos":[6138,6226]},{"content":"Because <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept> have to be encrypted one block at a time.","pos":[6227,6414],"source":" Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time."},{"content":"Data values that are smaller than <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> have to be expanded to <bpt id=\"p2\">*</bpt>n<ept id=\"p2\">*</ept> in order to be processed.","pos":[6415,6505],"source":" Data values that are smaller than *n* have to be expanded to *n* in order to be processed."},{"content":"One simple form of block cipher is called the electronic codebook (ECB) mode.","pos":[6507,6584]},{"content":"ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.","pos":[6585,6709]},{"content":"For a given secret key <bpt id=\"p1\">*</bpt>k<ept id=\"p1\">*</ept>, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.","pos":[6710,6891],"source":" For a given secret key *k*, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext."},{"content":"Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.","pos":[6892,7028]},{"content":"These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.","pos":[7029,7191]},{"content":"The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.","pos":[7192,7285]},{"content":"The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.","pos":[7287,7469]},{"content":"CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.","pos":[7471,7612]},{"content":"Each subsequent block of plaintext undergoes a bitwise exclusive OR (<ph id=\"ph1\">`XOR`</ph>) operation with the previous ciphertext block before it is encrypted.","pos":[7613,7757],"source":" Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted."},{"content":"Each ciphertext block is therefore dependent on all previous blocks.","pos":[7758,7826]},{"content":"When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.","pos":[7827,7961]},{"content":"One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.","pos":[7963,8083]},{"content":"Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.","pos":[8084,8257]},{"content":"Larger key sizes are more difficult to decipher.","pos":[8258,8306]},{"content":"Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.","pos":[8307,8455]},{"content":"If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.","pos":[8456,8614]},{"content":"The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.","pos":[8616,8749]},{"content":"The IV is not considered a secret and can be transmitted in plaintext with the message.","pos":[8750,8837]},{"content":"However, the key must be kept secret from unauthorized users.","pos":[8838,8899]},{"content":"Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.","pos":[8900,9053]},{"content":"Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.","pos":[9055,9298]},{"content":"Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message.","pos":[9299,9422]},{"content":"Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.","pos":[9423,9537]},{"content":"Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.","pos":[9538,9633]},{"content":"If the transmission is intercepted, the interceptor cannot recover the original message, because he does not know the key.","pos":[9634,9756]},{"content":"In this scenario, only the key must remain secret.","pos":[9757,9807]},{"content":"In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.","pos":[9808,9979]},{"content":"For more information about public-key encryption, see the next section.","pos":[9980,10051]},{"pos":[10053,10197],"content":"The <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement secret-key encryption algorithms:","source":"The [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement secret-key encryption algorithms:"},{"pos":[10201,10331],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.AesManaged&gt;</ph> (introduced in the <ph id=\"ph2\">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph>).","source":"<xref:System.Security.Cryptography.AesManaged> (introduced in the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)])."},{"pos":[10335,10396],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.DESCryptoServiceProvider&gt;</ph>.","source":"<xref:System.Security.Cryptography.DESCryptoServiceProvider>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph> (This is technically a secret-key algorithm because it represents message authentication code that is calculated by using a cryptographic hash function combined with a secret key.","pos":[10400,10624],"source":"<xref:System.Security.Cryptography.HMACSHA1> (This is technically a secret-key algorithm because it represents message authentication code that is calculated by using a cryptographic hash function combined with a secret key."},{"content":"See <bpt id=\"p1\">[</bpt>Hash Values<ept id=\"p1\">](#hash_values)</ept>, later in this topic.)","pos":[10625,10679],"source":" See [Hash Values](#hash_values), later in this topic.)"},{"pos":[10683,10744],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RC2CryptoServiceProvider&gt;</ph>.","source":"<xref:System.Security.Cryptography.RC2CryptoServiceProvider>."},{"pos":[10748,10800],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RijndaelManaged&gt;</ph>.","source":"<xref:System.Security.Cryptography.RijndaelManaged>."},{"pos":[10804,10871],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.TripleDESCryptoServiceProvider&gt;</ph>.","source":"<xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>."},{"pos":[10873,10892],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[10924,10945],"content":"Public-Key Encryption","linkify":"Public-Key Encryption","nodes":[{"content":"Public-Key Encryption","pos":[0,21]}]},{"content":"Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.","pos":[10947,11088]},{"content":"The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.","pos":[11089,11324]},{"content":"The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.","pos":[11325,11448]},{"content":"Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.","pos":[11449,11614]},{"content":"A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.","pos":[11615,11725]},{"content":"However, in practice, asymmetric keys are generally long-lived.","pos":[11726,11789]},{"content":"Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.","pos":[11791,11912]},{"content":"If Bob wants to send Alice an encrypted message, he asks her for her public key.","pos":[11913,11993]},{"content":"Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.","pos":[11994,12094]},{"content":"Bob sends the encrypted message to Alice, and she decrypts it by using her private key.","pos":[12095,12182]},{"content":"If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.","pos":[12183,12305]},{"content":"Therefore, Bob must verify with Alice that he has a correct copy of her public key.","pos":[12306,12389]},{"content":"During the transmission of Alice's public key, an unauthorized agent might intercept the key.","pos":[12391,12484]},{"content":"Furthermore, the same agent might intercept the encrypted message from Bob.","pos":[12485,12560]},{"content":"However, the agent cannot decrypt the message with the public key.","pos":[12561,12627]},{"content":"The message can be decrypted only with Alice's private key, which has not been transmitted.","pos":[12628,12719]},{"content":"Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.","pos":[12720,12851]},{"content":"If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.","pos":[12852,12977]},{"content":"Bob then decrypts the message using his associated private key.","pos":[12978,13041]},{"content":"In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.","pos":[13043,13216]},{"content":"The following list offers comparisons between public-key and secret-key cryptographic algorithms:","pos":[13218,13315]},{"content":"Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.","pos":[13319,13453]},{"content":"Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.","pos":[13457,13617]},{"content":"Therefore, asymmetric operations do not use the same streaming model as symmetric operations.","pos":[13618,13711]},{"content":"Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.","pos":[13715,13830]},{"content":"Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.","pos":[13831,13934]},{"content":"Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.","pos":[13938,14080]},{"content":"Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.","pos":[14084,14243]},{"content":"Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.","pos":[14247,14374]},{"content":"Public-key algorithms are useful only for transferring very small amounts of data.","pos":[14375,14457]},{"content":"Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.","pos":[14458,14560]},{"content":"After the key and IV are transferred, secret-key encryption is used for the remainder of the session.","pos":[14561,14662]},{"pos":[14664,14808],"content":"The <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement public-key encryption algorithms:","source":"The [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement public-key encryption algorithms:"},{"pos":[14940,15004],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDiffieHellman&gt;</ph> (base class)","source":"<xref:System.Security.Cryptography.ECDiffieHellman> (base class)"},{"pos":[15066,15142],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey&gt;</ph> (base class)","source":"<xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey> (base class)"},{"pos":[15146,15231],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction&gt;</ph> (base class)","source":"<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> (base class)"},{"content":"RSA allows both encryption and signing, but DSA can be used only for signing, and Diffie-Hellman can be used only for key generation.","pos":[15281,15414]},{"content":"In general, public-key algorithms are more limited in their uses than private-key algorithms.","pos":[15415,15508]},{"pos":[15510,15529],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[15569,15587],"content":"Digital Signatures","linkify":"Digital Signatures","nodes":[{"content":"Digital Signatures","pos":[0,18]}]},{"content":"Public-key algorithms can also be used to form digital signatures.","pos":[15589,15655]},{"content":"Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.","pos":[15656,15791]},{"content":"Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.","pos":[15792,15965]},{"content":"To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.","pos":[15967,16106]},{"content":"The message digest is a compact and unique representation of data.","pos":[16107,16173]},{"content":"Alice then encrypts the message digest with her private key to create her personal signature.","pos":[16174,16267]},{"content":"Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.","pos":[16268,16461]},{"content":"If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.","pos":[16462,16673]},{"content":"If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.","pos":[16674,16778]},{"pos":[16782,17053],"content":"[!NOTE]\nA signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format. This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.","leadings":["","> "],"nodes":[{"content":"A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format. This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.","pos":[8,269],"nodes":[{"content":"A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.","pos":[0,148]},{"content":"This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.","pos":[149,261]}]}]},{"pos":[17055,17195],"content":"The <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement digital signature algorithms:","source":"The [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement digital signature algorithms:"},{"pos":[17327,17381],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDsa&gt;</ph> (base class)","source":"<xref:System.Security.Cryptography.ECDsa> (base class)"},{"pos":[17432,17451],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[17484,17495],"content":"Hash Values","linkify":"Hash Values","nodes":[{"content":"Hash Values","pos":[0,11]}]},{"content":"Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.","pos":[17497,17619]},{"content":"A hash value is a numerical representation of a piece of data.","pos":[17620,17682]},{"content":"If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.","pos":[17683,17814]},{"content":"If the hash is cryptographically strong, its value will change significantly.","pos":[17815,17892]},{"content":"For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.","pos":[17893,18019]},{"content":"Many input values may hash to the same output value.","pos":[18020,18072]},{"content":"However, it is computationally infeasible to find two distinct inputs that hash to the same value.","pos":[18073,18171]},{"content":"Two parties (Alice and Bob) could use a hash function to ensure message integrity.","pos":[18173,18255]},{"content":"They would select a hash algorithm to sign their messages.","pos":[18256,18314]},{"content":"Alice would write a message, and then create a hash of that message by using the selected algorithm.","pos":[18315,18415]},{"content":"They would then follow one of the following methods:","pos":[18416,18468]},{"content":"Alice sends the plaintext message and the hashed message (digital signature) to Bob.","pos":[18472,18556]},{"content":"Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.","pos":[18557,18667]},{"content":"If the hash values are identical, the message was not altered.","pos":[18668,18730]},{"content":"If the values are not identical, the message was altered after Alice wrote it.","pos":[18731,18809]},{"content":"Unfortunately, this method does not establish the authenticity of the sender.","pos":[18815,18892]},{"content":"Anyone can impersonate Alice and send a message to Bob.","pos":[18893,18948]},{"content":"They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.","pos":[18949,19077]},{"content":"This is one form of a man-in-the-middle attack.","pos":[19078,19125]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Cryptography Next Generation (CNG) Secure Communication Example<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100))</ept>.","pos":[19126,19283],"source":" For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100))."},{"content":"Alice sends the plaintext message to Bob over a nonsecure public channel.","pos":[19287,19360]},{"content":"She sends the hashed message to Bob over a secure private channel.","pos":[19361,19427]},{"content":"Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.","pos":[19428,19529]},{"content":"If the hashes match, Bob knows two things:","pos":[19530,19572]},{"content":"The message was not altered.","pos":[19580,19608]},{"content":"The sender of the message (Alice) is authentic.","pos":[19616,19663]},{"content":"For this system to work, Alice must hide her original hash value from all parties except Bob.","pos":[19669,19762]},{"content":"Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.","pos":[19766,19903]},{"content":"This method prevents message tampering by preventing anyone from modifying the hash value.","pos":[19909,19999]},{"content":"Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.","pos":[20000,20101]},{"content":"An attacker who wants to impersonate Alice would require access to Alice's Web site.","pos":[20102,20186]},{"content":"None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.","pos":[20188,20311]},{"content":"Full security typically requires digital signatures (message signing) and encryption.","pos":[20312,20397]},{"pos":[20399,20529],"content":"The <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> provides the following classes that implement hashing algorithms:","source":"The [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides the following classes that implement hashing algorithms:"},{"pos":[20533,20578],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph>.","source":"<xref:System.Security.Cryptography.HMACSHA1>."},{"pos":[20582,20631],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.MACTripleDES&gt;</ph>.","source":"<xref:System.Security.Cryptography.MACTripleDES>."},{"pos":[20635,20696],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.MD5CryptoServiceProvider&gt;</ph>.","source":"<xref:System.Security.Cryptography.MD5CryptoServiceProvider>."},{"pos":[20700,20746],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RIPEMD160&gt;</ph>.","source":"<xref:System.Security.Cryptography.RIPEMD160>."},{"pos":[20750,20798],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.SHA1Managed&gt;</ph>.","source":"<xref:System.Security.Cryptography.SHA1Managed>."},{"pos":[20802,20852],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.SHA256Managed&gt;</ph>.","source":"<xref:System.Security.Cryptography.SHA256Managed>."},{"pos":[20856,20906],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.SHA384Managed&gt;</ph>.","source":"<xref:System.Security.Cryptography.SHA384Managed>."},{"pos":[20910,20960],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.SHA512Managed&gt;</ph>.","source":"<xref:System.Security.Cryptography.SHA512Managed>."},{"content":"HMAC variants of all of the Secure Hash Algorithm (SHA), Message Digest 5 (MD5), and RIPEMD-160 algorithms.","pos":[20964,21071]},{"content":"CryptoServiceProvider implementations (managed code wrappers) of all the SHA algorithms.","pos":[21075,21163]},{"content":"Cryptography Next Generation (CNG) implementations of all the MD5 and SHA algorithms.","pos":[21167,21252]},{"pos":[21256,21533],"content":"[!NOTE]\nMD5 design flaws were discovered in 1996, and SHA-1 was recommended instead. In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure. The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.","leadings":["","> "],"nodes":[{"content":"MD5 design flaws were discovered in 1996, and SHA-1 was recommended instead. In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure. The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.","pos":[8,275],"nodes":[{"content":"MD5 design flaws were discovered in 1996, and SHA-1 was recommended instead.","pos":[0,76]},{"content":"In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure.","pos":[77,173]},{"content":"The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.","pos":[174,267]}]}]},{"pos":[21535,21554],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[21590,21614],"content":"Random Number Generation","linkify":"Random Number Generation","nodes":[{"content":"Random Number Generation","pos":[0,24]}]},{"content":"Random number generation is integral to many cryptographic operations.","pos":[21616,21686]},{"content":"For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.","pos":[21687,21795]},{"content":"Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.","pos":[21796,21950]},{"content":"Therefore, any method of predicting the next output bit must not perform better than random guessing.","pos":[21951,22052]},{"content":"The classes in the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> use random number generators to generate cryptographic keys.","pos":[22053,22193],"source":" The classes in the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] use random number generators to generate cryptographic keys."},{"pos":[22195,22326],"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class is an implementation of a random number generator algorithm.","source":"The <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class is an implementation of a random number generator algorithm."},{"pos":[22328,22347],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[22378,22397],"content":"ClickOnce Manifests","linkify":"ClickOnce Manifests","nodes":[{"content":"ClickOnce Manifests","pos":[0,19]}]},{"pos":[22399,22695],"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph>, the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using <bpt id=\"p1\">[</bpt>ClickOnce technology<ept id=\"p1\">](/visualstudio/deployment/clickonce-security-and-deployment)</ept>:","source":"In the [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)], the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):"},{"pos":[22699,22939],"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ManifestSignatureInformation&gt;</ph> class obtains information about a manifest signature when you use its <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A&gt;</ph> method overloads.","source":"The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Security.ManifestKinds&gt;</ph> enumeration to specify which manifests to verify.","pos":[22943,23045],"source":"You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify."},{"content":"The result of the verification is one of the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.SignatureVerificationResult&gt;</ph> enumeration values.","pos":[23046,23174],"source":" The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values."},{"pos":[23178,23398],"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ManifestSignatureInformationCollection&gt;</ph> class provides a read-only collection of <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.ManifestSignatureInformation&gt;</ph> objects of the verified signatures.","source":"The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures."},{"content":"In addition, the following classes provide specific signature information:","pos":[23401,23475]},{"pos":[23479,23605],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.StrongNameSignatureInformation&gt;</ph> holds the strong name signature information for a manifest.","source":"<xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest."},{"pos":[23609,23760],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation&gt;</ph> represents the Authenticode signature information for a manifest.","source":"<xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest."},{"pos":[23764,23909],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.X509Certificates.TimestampInformation&gt;</ph> contains information about the time stamp on an Authenticode signature.","source":"<xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature."},{"pos":[23913,24054],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.X509Certificates.TrustStatus&gt;</ph> provides a simple way to check whether an Authenticode signature is trusted.","source":"<xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted."},{"pos":[24056,24075],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[24104,24119],"content":"Suite B Support","linkify":"Suite B Support","nodes":[{"content":"Suite B Support","pos":[0,15]}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph> supports the Suite B set of cryptographic algorithms published by the National Security Agency (NSA).","pos":[24121,24291],"source":"The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] supports the Suite B set of cryptographic algorithms published by the National Security Agency (NSA)."},{"content":"For more information about Suite B, see the <bpt id=\"p1\">[</bpt>NSA Suite B Cryptography Fact Sheet<ept id=\"p1\">](https://www.nsa.gov/what-we-do/information-assurance/)</ept>.","pos":[24292,24429],"source":" For more information about Suite B, see the [NSA Suite B Cryptography Fact Sheet](https://www.nsa.gov/what-we-do/information-assurance/)."},{"content":"The following algorithms are included:","pos":[24431,24469]},{"content":"Advanced Encryption Standard (AES) algorithm with key sizes of 128, 192, , and 256 bits for encryption.","pos":[24473,24576]},{"content":"Secure Hash Algorithms SHA-1, SHA-256, SHA-384, and SHA-512 for hashing.","pos":[24580,24652]},{"content":"(The last three are generally grouped together and referred to as SHA-2.)","pos":[24653,24726]},{"content":"Elliptic Curve Digital Signature Algorithm (ECDSA), using curves of 256-bit, 384-bit, and 521-bit prime moduli for signing.","pos":[24730,24853]},{"content":"The NSA documentation specifically defines these curves, and calls them P-256, P-384, and P-521.","pos":[24854,24950]},{"content":"This algorithm is provided by the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDsaCng&gt;</ph> class.","pos":[24951,25036],"source":" This algorithm is provided by the <xref:System.Security.Cryptography.ECDsaCng> class."},{"content":"It enables you to sign with a private key and verify the signature with a public key.","pos":[25037,25122]},{"content":"Elliptic Curve Diffie-Hellman (ECDH) algorithm, using curves of 256-bit, 384-bit, and 521-bit prime moduli for the key exchange and secret agreement.","pos":[25126,25275]},{"content":"This algorithm is provided by the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCng&gt;</ph> class.","pos":[25276,25371],"source":" This algorithm is provided by the <xref:System.Security.Cryptography.ECDiffieHellmanCng> class."},{"pos":[25373,25827],"content":"Managed code wrappers for the Federal Information Processing Standard (FIPS) certified implementations of the AES, SHA-256, SHA-384, and SHA-512 implementations are available in the new <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.AesCryptoServiceProvider&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.SHA256CryptoServiceProvider&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Security.Cryptography.SHA384CryptoServiceProvider&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Security.Cryptography.SHA512CryptoServiceProvider&gt;</ph> classes.","source":"Managed code wrappers for the Federal Information Processing Standard (FIPS) certified implementations of the AES, SHA-256, SHA-384, and SHA-512 implementations are available in the new <xref:System.Security.Cryptography.AesCryptoServiceProvider>, <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>, <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>, and <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> classes."},{"pos":[25829,25848],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[25873,25915],"content":"Cryptography Next Generation (CNG) Classes","linkify":"Cryptography Next Generation (CNG) Classes","nodes":[{"content":"Cryptography Next Generation (CNG) Classes","pos":[0,42]}]},{"content":"The Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.","pos":[25917,26022]},{"content":"(CNG is the replacement for CryptoAPI.) These classes have \"Cng\" as part of their names.","pos":[26023,26111]},{"content":"Central to the CNG wrapper classes is the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CngKey&gt;</ph> key container class, which abstracts the storage and use of CNG keys.","pos":[26112,26266],"source":" Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys."},{"content":"This class lets you store a key pair or a public key securely and refer to it by using a simple string name.","pos":[26267,26375]},{"content":"The elliptic curve-based <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDsaCng&gt;</ph> signature class and the <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCng&gt;</ph> encryption class can use <ph id=\"ph3\">&lt;xref:System.Security.Cryptography.CngKey&gt;</ph> objects.","pos":[26376,26601],"source":" The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CngKey&gt;</ph> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.","pos":[26603,26762],"source":"The <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys."},{"content":"It also provides access to the underlying key handle to use when calling native functions directly.","pos":[26763,26862]},{"pos":[26864,27006],"content":"The <ph id=\"ph1\">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph> also includes a variety of supporting CNG classes, such as the following:","source":"The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] also includes a variety of supporting CNG classes, such as the following:"},{"pos":[27010,27091],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CngProvider&gt;</ph> maintains a key storage provider.","source":"<xref:System.Security.Cryptography.CngProvider> maintains a key storage provider."},{"pos":[27095,27170],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CngAlgorithm&gt;</ph> maintains a CNG algorithm.","source":"<xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm."},{"pos":[27174,27263],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CngProperty&gt;</ph> maintains frequently used key properties.","source":"<xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties."},{"pos":[27265,27284],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[27320,27334],"content":"Related Topics","linkify":"Related Topics","nodes":[{"content":"Related Topics","pos":[0,14]}]},{"content":"Title","pos":[27337,27342]},{"content":"Description","pos":[27343,27354]},{"pos":[27389,27464],"content":"<bpt id=\"p1\">[</bpt>Cryptography Model<ept id=\"p1\">](../../../docs/standard/security/cryptography-model.md)</ept>","source":"[Cryptography Model](../../../docs/standard/security/cryptography-model.md)"},{"content":"Describes how cryptography is implemented in the base class library.","pos":[27465,27533]},{"pos":[27536,27672],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Creating a Cryptographic Application<ept id=\"p1\">](../../../docs/standard/security/walkthrough-creating-a-cryptographic-application.md)</ept>","source":"[Walkthrough: Creating a Cryptographic Application](../../../docs/standard/security/walkthrough-creating-a-cryptographic-application.md)"},{"content":"Demonstrates basic encryption and decryption tasks.","pos":[27673,27724]},{"pos":[27727,27835],"content":"<bpt id=\"p1\">[</bpt>Configuring Cryptography Classes<ept id=\"p1\">](../../../docs/framework/configure-apps/configure-cryptography-classes.md)</ept>","source":"[Configuring Cryptography Classes](../../../docs/framework/configure-apps/configure-cryptography-classes.md)"},{"content":"Describes how to map algorithm names to cryptographic classes and map object identifiers to a cryptographic algorithm.","pos":[27836,27954]}]}