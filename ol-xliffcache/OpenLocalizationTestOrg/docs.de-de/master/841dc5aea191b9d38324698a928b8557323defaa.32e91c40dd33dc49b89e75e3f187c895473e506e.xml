{"content":"---\ntitle: \"streamWriterBufferedDataLost MDA | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"StreamWriter class, data buffering problems\"\n  - \"managed debugging assistants (MDAs), StreamWriter data buffering\"\n  - \"buffers, StreamWriter problems\"\n  - \"MDAs (managed debugging assistants), StreamWriter data buffering\"\n  - \"StreamWriter buffered data lost\"\n  - \"data buffering problems\"\n  - \"streamWriterBufferedDataLost MDA\"\nms.assetid: 6e5c07be-bc5b-437a-8398-8779e23126ab\ncaps.latest.revision: 8\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# streamWriterBufferedDataLost MDA\nThe `streamWriterBufferedDataLost` managed debugging assistant (MDA) is activated when a <xref:System.IO.StreamWriter> is written to, but the <xref:System.IO.StreamWriter.Flush%2A> or <xref:System.IO.StreamWriter.Close%2A> method is not subsequently called before the instance of the <xref:System.IO.StreamWriter> is destroyed. When this MDA is enabled, the runtime determines whether any buffered data still exists within the <xref:System.IO.StreamWriter>. If buffered data does exist, the MDA is activated. Calling the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods can force finalizers to run. Finalizers will otherwise run at seemingly arbitrary times, and possibly not at all on process exit. Explicitly running finalizers with this MDA enabled will help to more reliably reproduce this type of problem.  \n  \n## Symptoms  \n A <xref:System.IO.StreamWriter> does not write the last 1–4 KB of data to a file.  \n  \n## Cause  \n The <xref:System.IO.StreamWriter> buffers data internally, which requires that the <xref:System.IO.StreamWriter.Close%2A> or <xref:System.IO.StreamWriter.Flush%2A> method be called to write the buffered data to the underlying data store. If <xref:System.IO.StreamWriter.Close%2A> or <xref:System.IO.StreamWriter.Flush%2A> is not appropriately called, data buffered in the <xref:System.IO.StreamWriter> instance might not be written as expected.  \n  \n The following is an example of poorly written code that this MDA should catch.  \n  \n```csharp  \n// Poorly written code.  \nvoid Write()   \n{  \n    StreamWriter sw = new StreamWriter(\"file.txt\");  \n    sw.WriteLine(\"Data\");  \n    // Problem: forgot to close the StreamWriter.  \n}  \n```  \n  \n The preceding code will activate this MDA more reliably if a garbage collection is triggered and then suspended until finalizers have finished. To track down this type of problem, you can add the following code to the end of the preceding method in a debug build. This will help to reliably activate the MDA, but of course it does not fix the cause of the problem.  \n  \n```csharp\nGC.Collect();  \nGC.WaitForPendingFinalizers();  \n```  \n  \n## Resolution  \n Make sure you call <xref:System.IO.StreamWriter.Close%2A> or <xref:System.IO.StreamWriter.Flush%2A> on the <xref:System.IO.StreamWriter> before closing an application or any code block that has an instance of a <xref:System.IO.StreamWriter>. One of the best mechanisms for achieving this is creating the instance with a C# `using` block (`Using` in Visual Basic), which will ensure the <xref:System.IO.StreamWriter.Dispose%2A> method for the writer is invoked, resulting in the instance being correctly closed.  \n  \n```csharp\nusing(StreamWriter sw = new StreamWriter(\"file.txt\"))   \n{  \n    sw.WriteLine(\"Data\");  \n}  \n```  \n  \n The following code shows the same solution, using `try/finally` instead of `using`.  \n  \n```csharp\nStreamWriter sw;  \ntry   \n{  \n    sw = new StreamWriter(\"file.txt\"));  \n    sw.WriteLine(\"Data\");  \n}  \nfinally   \n{  \n    if (sw != null)  \n        sw.Close();  \n}  \n```  \n  \n If neither of these solutions can be used (for example, if a <xref:System.IO.StreamWriter> is stored in a static variable and you cannot easily run code at the end of its lifetime), then calling <xref:System.IO.StreamWriter.Flush%2A> on the <xref:System.IO.StreamWriter> after its last use or setting the <xref:System.IO.StreamWriter.AutoFlush%2A> property to `true` before its first use should avoid this problem.  \n  \n```csharp\nprivate static StreamWriter log;  \n// static class constructor.  \nstatic WriteToFile()   \n{  \n    StreamWriter sw = new StreamWriter(\"log.txt\");  \n    sw.AutoFlush = true;  \n  \n    // Publish the StreamWriter for other threads.  \n    log = sw;  \n}  \n```  \n  \n## Effect on the Runtime  \n This MDA has no effect on the runtime.  \n  \n## Output  \n A message indicating that this violation occurred.  \n  \n## Configuration  \n  \n```  \n<mdaConfig>  \n  <assistants>  \n    <streamWriterBufferedDataLost />  \n  </assistants>  \n</mdaConfig>  \n```  \n  \n## See Also  \n <xref:System.IO.StreamWriter>   \n [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)","nodes":[{"pos":[12,61],"content":"streamWriterBufferedDataLost MDA | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"streamWriterBufferedDataLost MDA | Microsoft Docs","pos":[0,49]}]},{"pos":[776,808],"content":"streamWriterBufferedDataLost MDA","linkify":"streamWriterBufferedDataLost MDA","nodes":[{"content":"streamWriterBufferedDataLost MDA","pos":[0,32]}]},{"content":"The <ph id=\"ph1\">`streamWriterBufferedDataLost`</ph> managed debugging assistant (MDA) is activated when a <ph id=\"ph2\">&lt;xref:System.IO.StreamWriter&gt;</ph> is written to, but the <ph id=\"ph3\">&lt;xref:System.IO.StreamWriter.Flush%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.IO.StreamWriter.Close%2A&gt;</ph> method is not subsequently called before the instance of the <ph id=\"ph5\">&lt;xref:System.IO.StreamWriter&gt;</ph> is destroyed.","pos":[809,1136],"source":"The `streamWriterBufferedDataLost` managed debugging assistant (MDA) is activated when a <xref:System.IO.StreamWriter> is written to, but the <xref:System.IO.StreamWriter.Flush%2A> or <xref:System.IO.StreamWriter.Close%2A> method is not subsequently called before the instance of the <xref:System.IO.StreamWriter> is destroyed."},{"content":"When this MDA is enabled, the runtime determines whether any buffered data still exists within the <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph>.","pos":[1137,1266],"source":" When this MDA is enabled, the runtime determines whether any buffered data still exists within the <xref:System.IO.StreamWriter>."},{"content":"If buffered data does exist, the MDA is activated.","pos":[1267,1317]},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> methods can force finalizers to run.","pos":[1318,1443],"source":" Calling the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods can force finalizers to run."},{"content":"Finalizers will otherwise run at seemingly arbitrary times, and possibly not at all on process exit.","pos":[1444,1544]},{"content":"Explicitly running finalizers with this MDA enabled will help to more reliably reproduce this type of problem.","pos":[1545,1655]},{"pos":[1664,1672],"content":"Symptoms","linkify":"Symptoms","nodes":[{"content":"Symptoms","pos":[0,8]}]},{"content":"A <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph> does not write the last 1–4 KB of data to a file.","pos":[1676,1757],"source":"A <xref:System.IO.StreamWriter> does not write the last 1–4 KB of data to a file."},{"pos":[1766,1771],"content":"Cause","linkify":"Cause","nodes":[{"content":"Cause","pos":[0,5]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph> buffers data internally, which requires that the <ph id=\"ph2\">&lt;xref:System.IO.StreamWriter.Close%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.IO.StreamWriter.Flush%2A&gt;</ph> method be called to write the buffered data to the underlying data store.","pos":[1775,2012],"source":"The <xref:System.IO.StreamWriter> buffers data internally, which requires that the <xref:System.IO.StreamWriter.Close%2A> or <xref:System.IO.StreamWriter.Flush%2A> method be called to write the buffered data to the underlying data store."},{"content":"If <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IO.StreamWriter.Flush%2A&gt;</ph> is not appropriately called, data buffered in the <ph id=\"ph3\">&lt;xref:System.IO.StreamWriter&gt;</ph> instance might not be written as expected.","pos":[2013,2219],"source":" If <xref:System.IO.StreamWriter.Close%2A> or <xref:System.IO.StreamWriter.Flush%2A> is not appropriately called, data buffered in the <xref:System.IO.StreamWriter> instance might not be written as expected."},{"content":"The following is an example of poorly written code that this MDA should catch.","pos":[2226,2304]},{"content":"The preceding code will activate this MDA more reliably if a garbage collection is triggered and then suspended until finalizers have finished.","pos":[2516,2659]},{"content":"To track down this type of problem, you can add the following code to the end of the preceding method in a debug build.","pos":[2660,2779]},{"content":"This will help to reliably activate the MDA, but of course it does not fix the cause of the problem.","pos":[2780,2880]},{"pos":[2957,2967],"content":"Resolution","linkify":"Resolution","nodes":[{"content":"Resolution","pos":[0,10]}]},{"content":"Make sure you call <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IO.StreamWriter.Flush%2A&gt;</ph> on the <ph id=\"ph3\">&lt;xref:System.IO.StreamWriter&gt;</ph> before closing an application or any code block that has an instance of a <ph id=\"ph4\">&lt;xref:System.IO.StreamWriter&gt;</ph>.","pos":[2971,3212],"source":"Make sure you call <xref:System.IO.StreamWriter.Close%2A> or <xref:System.IO.StreamWriter.Flush%2A> on the <xref:System.IO.StreamWriter> before closing an application or any code block that has an instance of a <xref:System.IO.StreamWriter>."},{"content":"One of the best mechanisms for achieving this is creating the instance with a C# <ph id=\"ph1\">`using`</ph> block (<ph id=\"ph2\">`Using`</ph> in Visual Basic), which will ensure the <ph id=\"ph3\">&lt;xref:System.IO.StreamWriter.Dispose%2A&gt;</ph> method for the writer is invoked, resulting in the instance being correctly closed.","pos":[3213,3481],"source":" One of the best mechanisms for achieving this is creating the instance with a C# `using` block (`Using` in Visual Basic), which will ensure the <xref:System.IO.StreamWriter.Dispose%2A> method for the writer is invoked, resulting in the instance being correctly closed."},{"pos":[3600,3683],"content":"The following code shows the same solution, using <ph id=\"ph1\">`try/finally`</ph> instead of <ph id=\"ph2\">`using`</ph>.","source":"The following code shows the same solution, using `try/finally` instead of `using`."},{"pos":[3876,4290],"content":"If neither of these solutions can be used (for example, if a <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph> is stored in a static variable and you cannot easily run code at the end of its lifetime), then calling <ph id=\"ph2\">&lt;xref:System.IO.StreamWriter.Flush%2A&gt;</ph> on the <ph id=\"ph3\">&lt;xref:System.IO.StreamWriter&gt;</ph> after its last use or setting the <ph id=\"ph4\">&lt;xref:System.IO.StreamWriter.AutoFlush%2A&gt;</ph> property to <ph id=\"ph5\">`true`</ph> before its first use should avoid this problem.","source":"If neither of these solutions can be used (for example, if a <xref:System.IO.StreamWriter> is stored in a static variable and you cannot easily run code at the end of its lifetime), then calling <xref:System.IO.StreamWriter.Flush%2A> on the <xref:System.IO.StreamWriter> after its last use or setting the <xref:System.IO.StreamWriter.AutoFlush%2A> property to `true` before its first use should avoid this problem."},{"pos":[4568,4589],"content":"Effect on the Runtime","linkify":"Effect on the Runtime","nodes":[{"content":"Effect on the Runtime","pos":[0,21]}]},{"content":"This MDA has no effect on the runtime.","pos":[4593,4631]},{"pos":[4640,4646],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"A message indicating that this violation occurred.","pos":[4650,4700]},{"pos":[4709,4722],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"pos":[4849,4857],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph>","pos":[4861,4890],"source":"<xref:System.IO.StreamWriter> "},{"content":"<bpt id=\"p1\"> [</bpt>Diagnosing Errors with Managed Debugging Assistants<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)</ept>","pos":[4894,5048],"source":" [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)"}]}