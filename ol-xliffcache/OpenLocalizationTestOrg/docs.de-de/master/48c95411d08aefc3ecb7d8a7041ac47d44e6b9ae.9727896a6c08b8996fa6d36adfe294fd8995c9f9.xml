{"content":"---\ntitle: \"Standard Query Operator Translation\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: a60c30fa-1e68-45fe-b984-f6abb9ede40e\n---\n# Standard Query Operator Translation\n[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translates Standard Query Operators to SQL commands. The query processor of the database determines the execution semantics of SQL translation.  \n  \n Standard Query Operators are defined against *sequences*. A sequence is *ordered* and relies on reference identity for each element of the sequence. For more information, see [Standard Query Operators Overview (C#)](../../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md) or [Standard Query Operators Overview (Visual Basic)](../../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md).  \n  \n SQL deals primarily with *unordered sets of values*. Ordering is typically an explicitly stated, post-processing operation that is applied to the final result of a query rather than to intermediate results. Identity is defined by values. For this reason, SQL queries are understood to deal with multisets (*bags*) instead of *sets*.  \n  \n The following paragraphs describe the differences between the Standard Query Operators and their SQL translation for the SQL Server provider for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].  \n  \n## Operator Support  \n  \n### Concat  \n The <xref:System.Linq.Enumerable.Concat%2A> method is defined for ordered multisets where the order of the receiver and the order of the argument are the same. <xref:System.Linq.Enumerable.Concat%2A> works as `UNION ALL` over the multisets followed by the common order.  \n  \n The final step is ordering in SQL before results are produced. <xref:System.Linq.Enumerable.Concat%2A> does not preserve the order of its arguments. To ensure appropriate ordering, you must explicitly order the results of <xref:System.Linq.Enumerable.Concat%2A>.  \n  \n### Intersect, Except, Union  \n The <xref:System.Linq.Enumerable.Intersect%2A> and <xref:System.Linq.Enumerable.Except%2A> methods are well defined only on sets. The semantics for multisets is undefined.  \n  \n The <xref:System.Linq.Enumerable.Union%2A> method is defined for multisets as the unordered concatenation of the multisets (effectively the result of the UNION ALL clause in SQL).  \n  \n### Take, Skip  \n <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> methods are well defined only against *ordered sets*. The semantics for unordered sets or multisets are undefined.  \n  \n> [!NOTE]\n>  <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against SQL Server 2000. For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).  \n  \n Because of limitations on ordering in SQL, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tries to move the ordering of the argument of these methods to the result of the method. For example, consider the following [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] query:  \n  \n [!code-csharp[DLinqSQOTranslation#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#1)]\n [!code-vb[DLinqSQOTranslation#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#1)]  \n  \n The generated SQL for this code moves the ordering to the end, as follows:  \n  \n```  \nSELECT TOP 1 [t0].[CustomerID], [t0].[CompanyName],  \nFROM [Customers] AS [t0]  \nWHERE (NOT (EXISTS(  \n    SELECT NULL AS [EMPTY]  \n    FROM (  \n        SELECT TOP 1 [t1].[CustomerID]  \n        FROM [Customers] AS [t1]  \n        WHERE [t1].[City] = @p0  \n        ORDER BY [t1].[CustomerID]  \n        ) AS [t2]  \n    WHERE [t0].[CustomerID] = [t2].[CustomerID]  \n    ))) AND ([t0].[City] = @p1)  \nORDER BY [t0].[CustomerID]  \n```  \n  \n It becomes obvious that all the specified ordering must be consistent when <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> are chained together. Otherwise, the results are undefined.  \n  \n Both <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> are well-defined for non-negative, constant integral arguments based on the Standard Query Operator specification.  \n  \n### Operators with No Translation  \n The following methods are not translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]. The most common reason is the difference between unordered multisets and sequences.  \n  \n|Operators|Rationale|  \n|---------------|---------------|  \n|<xref:System.Linq.Enumerable.TakeWhile%2A>, <xref:System.Linq.Enumerable.SkipWhile%2A>|SQL queries operate on multisets, not on sequences. `ORDER BY` must be the last clause applied to the results. For this reason, there is no general-purpose translation for these two methods.|  \n|<xref:System.Linq.Enumerable.Reverse%2A>|Translation of this method is possible for an ordered set but is not currently translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].|  \n|<xref:System.Linq.Enumerable.Last%2A>, <xref:System.Linq.Enumerable.LastOrDefault%2A>|Translation of these methods is possible for an ordered set but is not currently translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].|  \n|<xref:System.Linq.Enumerable.ElementAt%2A>, <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>|SQL queries operate on multisets, not on indexable sequences.|  \n|<xref:System.Linq.Enumerable.DefaultIfEmpty%2A> (overload with default arg)|In general, a default value cannot be specified for an arbitrary tuple. Null values for tuples are possible in some cases through outer joins.|  \n  \n## Expression Translation  \n  \n### Null semantics  \n [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not impose null comparison semantics on SQL. Comparison operators are syntactically translated to their SQL equivalents. For this reason, the semantics reflect SQL semantics that are defined by server or connection settings. For example, two null values are considered unequal under default SQL Server settings, but you can change the settings to change the semantics. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not consider server settings when it translates queries.  \n  \n A comparison with the literal null is translated to the appropriate SQL version (`is null` or `is not null`).  \n  \n The value of `null` in collation is defined by SQL Server. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not change the collation.  \n  \n### Aggregates  \n The Standard Query Operator aggregate method <xref:System.Linq.Enumerable.Sum%2A> evaluates to zero for an empty sequence or for a sequence that contains only nulls. In [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], the semantics of SQL are left unchanged, and <xref:System.Linq.Enumerable.Sum%2A> evaluates to `null` instead of zero for an empty sequence or for a sequence that contains only nulls.  \n  \n SQL limitations on intermediate results apply to aggregates in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]. The <xref:System.Linq.Enumerable.Sum%2A> of 32-bit integer quantities is not computed by using 64-bit results. Overflow might occur for a [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translation of <xref:System.Linq.Enumerable.Sum%2A>, even if the Standard Query Operator implementation does not cause an overflow for the corresponding in-memory sequence.  \n  \n Likewise, the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translation of <xref:System.Linq.Enumerable.Average%2A> of integer values is computed as an `integer`, not as a `double`.  \n  \n### Entity Arguments  \n [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] enables entity types to be used in the <xref:System.Linq.Enumerable.GroupBy%2A> and <xref:System.Linq.Enumerable.OrderBy%2A> methods. In the translation of these operators, the use of an argument of a type is considered to be the equivalent to specifying all members of that type. For example, the following code is equivalent:  \n  \n [!code-csharp[DLinqSQOTranslation#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#2)]\n [!code-vb[DLinqSQOTranslation#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#2)]  \n  \n### Equatable / Comparable Arguments  \n Equality of arguments is required in the implementation of the following methods:  \n  \n <xref:System.Linq.Enumerable.Contains%2A>  \n  \n <xref:System.Linq.Enumerable.Skip%2A>  \n  \n <xref:System.Linq.Enumerable.Union%2A>  \n  \n <xref:System.Linq.Enumerable.Intersect%2A>  \n  \n <xref:System.Linq.Enumerable.Except%2A>  \n  \n [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] supports equality and comparison for *flat* arguments, but not for arguments that are or contain sequences. A flat argument is a type that can be mapped to a SQL row. A projection of one or more entity types that can be statically determined not to contain a sequence is considered a flat argument.  \n  \n Following are examples of flat arguments:  \n  \n [!code-csharp[DLinqSQOTranslation#3](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#3)]\n [!code-vb[DLinqSQOTranslation#3](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#3)]  \n  \n The following are examples of non-flat (hierarchical) arguments.  \n  \n [!code-csharp[DLinqSQOTranslation#4](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqSQOTranslation/cs/Program.cs#4)]\n [!code-vb[DLinqSQOTranslation#4](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqSQOTranslation/vb/Module1.vb#4)]  \n  \n### Visual Basic Function Translation  \n The following helper functions that are used by the Visual Basic compiler are translated to corresponding SQL operators and functions:  \n  \n `CompareString`  \n  \n `DateTime.Compare`  \n  \n `Decimal.Compare`  \n  \n `IIf (in Microsoft.VisualBasic.Interaction)`  \n  \n Conversion methods:  \n  \n|||||  \n|-|-|-|-|  \n|ToBoolean|ToSByte|ToByte|ToChar|  \n|ToCharArrayRankOne|ToDate|ToDecimal|ToDouble|  \n|ToInteger|ToUInteger|ToLong|ToULong|  \n|ToShort|ToUShort|ToSingle|ToString|  \n  \n## Inheritance Support  \n  \n### Inheritance Mapping Restrictions  \n For more information, see [How to: Map Inheritance Hierarchies](../../../../../../docs/framework/data/adonet/sql/linq/how-to-map-inheritance-hierarchies.md).  \n  \n### Inheritance in Queries  \n C# casts are supported only in projection. Casts that are used elsewhere are not translated and are ignored. Aside from SQL function names, SQL really only performs the equivalent of the common language runtime (CLR) <xref:System.Convert>. That is, SQL can change the value of one type to another. There is no equivalent of CLR cast because there is no concept of reinterpreting the same bits as those of another type. That is why a C# cast works only locally. It is not remoted.  \n  \n The operators, `is` and `as`, and the `GetType` method are not restricted to the `Select` operator. They can be used in other query operators also.  \n  \n## SQL Server 2008 Support  \n Starting with the .NET Framework 3.5 SP1, LINQ to SQL supports mapping to new date and time types introduced with SQL Server 2008. But, there are some limitations to the LINQ to SQL query operators that you can use when operating against values mapped to these new types.  \n  \n### Unsupported Query Operators  \n The following query operators are not supported on values mapped to the new SQL Server date and time types: `DATETIME2`, `DATE`, `TIME`, and `DATETIMEOFFSET`.  \n  \n-   `Aggregate`  \n  \n-   `Average`  \n  \n-   `LastOrDefault`  \n  \n-   `OfType`  \n  \n-   `Sum`  \n  \n For more information about mapping to these SQL Server date and time types, see [SQL-CLR Type Mapping](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md).  \n  \n## SQL Server 2005 Support  \n [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not support the following SQL Server 2005 features:  \n  \n-   Stored procedures written for SQL CLR.  \n  \n-   User-defined type.  \n  \n-   XML query features.  \n  \n## SQL Server 2000 Support  \n The following [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] limitations (compared to [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]) affect [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] support.  \n  \n### Cross Apply and Outer Apply Operators  \n These operators are not available in [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tries a series of rewrites to replace them with appropriate joins.  \n  \n `Cross Apply` and `Outer Apply` are generated for relationship navigations. The set of queries for which such rewrites are possible is not well defined. For this reason, the minimal set of queries that is supported for [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] is the set that does not involve relationship navigation.  \n  \n### text / ntext  \n Data types `text` / `ntext` cannot be used in certain query operations against `varchar(max)` / `nvarchar(max)`, which are supported by [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)].  \n  \n No resolution is available for this limitation. Specifically, you cannot use `Distinct()` on any result that contains members that are mapped to `text` or `ntext` columns.  \n  \n### Behavior Triggered by Nested Queries  \n [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] (through SP4) binder has some idiosyncrasies that are triggered by nested queries. The set of SQL queries that triggers these idiosyncrasies is not well defined. For this reason, you cannot define the set of [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] queries that might cause SQL Server exceptions.  \n  \n### Skip and Take Operators  \n <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]. For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).  \n  \n## Object Materialization  \n Materialization creates CLR objects from rows that are returned by one or more SQL queries.  \n  \n-   The following calls are *executed locally* as a part of materialization:  \n  \n    -   Constructors  \n  \n    -   `ToString` methods in projections  \n  \n    -   Type casts in projections  \n  \n-   Methods that follow the <xref:System.Linq.Enumerable.AsEnumerable%2A> method are *executed locally*. This method does not cause immediate execution.  \n  \n-   You can use a `struct` as the return type of a query result or as a member of the result type. Entities are required to be classes. Anonymous types are materialized as class instances, but named structs (non-entities) can be used in projection.  \n  \n-   A member of the return type of a query result can be of type <xref:System.Linq.IQueryable%601>. It is materialized as a local collection.  \n  \n-   The following methods cause the *immediate materialization* of the sequence that the methods are applied to:  \n  \n    -   <xref:System.Linq.Enumerable.ToList%2A>  \n  \n    -   <xref:System.Linq.Enumerable.ToDictionary%2A>  \n  \n    -   <xref:System.Linq.Enumerable.ToArray%2A>  \n  \n## See also\n\n- [Reference](../../../../../../docs/framework/data/adonet/sql/linq/reference.md)\n- [Return Or Skip Elements in a Sequence](../../../../../../docs/framework/data/adonet/sql/linq/return-or-skip-elements-in-a-sequence.md)\n- [Concatenate Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/concatenate-two-sequences.md)\n- [Return the Set Difference Between Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-difference-between-two-sequences.md)\n- [Return the Set Intersection of Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-intersection-of-two-sequences.md)\n- [Return the Set Union of Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-union-of-two-sequences.md)\n","nodes":[{"pos":[4,153],"embed":true,"restype":"x-metadata","content":"title: \"Standard Query Operator Translation\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: a60c30fa-1e68-45fe-b984-f6abb9ede40e","nodes":[{"content":"Standard Query Operator Translation","nodes":[{"pos":[0,35],"content":"Standard Query Operator Translation","nodes":[{"content":"Standard Query Operator Translation","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[160,195],"content":"Standard Query Operator Translation","linkify":"Standard Query Operator Translation","nodes":[{"content":"Standard Query Operator Translation","pos":[0,35]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> translates Standard Query Operators to SQL commands.","pos":[196,316],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translates Standard Query Operators to SQL commands."},{"content":"The query processor of the database determines the execution semantics of SQL translation.","pos":[317,407]},{"content":"Standard Query Operators are defined against <bpt id=\"p1\">*</bpt>sequences<ept id=\"p1\">*</ept>.","pos":[414,471],"source":"Standard Query Operators are defined against *sequences*."},{"content":"A sequence is <bpt id=\"p1\">*</bpt>ordered<ept id=\"p1\">*</ept> and relies on reference identity for each element of the sequence.","pos":[472,562],"source":" A sequence is *ordered* and relies on reference identity for each element of the sequence."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Standard Query Operators Overview (C#)<ept id=\"p1\">](../../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept> or <bpt id=\"p2\">[</bpt>Standard Query Operators Overview (Visual Basic)<ept id=\"p2\">](../../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>.","pos":[563,874],"source":" For more information, see [Standard Query Operators Overview (C#)](../../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md) or [Standard Query Operators Overview (Visual Basic)](../../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)."},{"content":"SQL deals primarily with <bpt id=\"p1\">*</bpt>unordered sets of values<ept id=\"p1\">*</ept>.","pos":[881,933],"source":"SQL deals primarily with *unordered sets of values*."},{"content":"Ordering is typically an explicitly stated, post-processing operation that is applied to the final result of a query rather than to intermediate results.","pos":[934,1087]},{"content":"Identity is defined by values.","pos":[1088,1118]},{"content":"For this reason, SQL queries are understood to deal with multisets (<bpt id=\"p1\">*</bpt>bags<ept id=\"p1\">*</ept>) instead of <bpt id=\"p2\">*</bpt>sets<ept id=\"p2\">*</ept>.","pos":[1119,1213],"source":" For this reason, SQL queries are understood to deal with multisets (*bags*) instead of *sets*."},{"pos":[1220,1433],"content":"The following paragraphs describe the differences between the Standard Query Operators and their SQL translation for the SQL Server provider for <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph>.","source":"The following paragraphs describe the differences between the Standard Query Operators and their SQL translation for the SQL Server provider for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]."},{"pos":[1442,1458],"content":"Operator Support","linkify":"Operator Support","nodes":[{"content":"Operator Support","pos":[0,16]}]},{"pos":[1468,1474],"content":"Concat","linkify":"Concat","nodes":[{"content":"Concat","pos":[0,6]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Concat%2A&gt;</ph> method is defined for ordered multisets where the order of the receiver and the order of the argument are the same.","pos":[1478,1637],"source":"The <xref:System.Linq.Enumerable.Concat%2A> method is defined for ordered multisets where the order of the receiver and the order of the argument are the same."},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Concat%2A&gt;</ph> works as <ph id=\"ph2\">`UNION ALL`</ph> over the multisets followed by the common order.","pos":[1638,1747],"source":"<xref:System.Linq.Enumerable.Concat%2A> works as `UNION ALL` over the multisets followed by the common order."},{"content":"The final step is ordering in SQL before results are produced.","pos":[1754,1816]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Concat%2A&gt;</ph> does not preserve the order of its arguments.","pos":[1817,1902],"source":"<xref:System.Linq.Enumerable.Concat%2A> does not preserve the order of its arguments."},{"content":"To ensure appropriate ordering, you must explicitly order the results of <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Concat%2A&gt;</ph>.","pos":[1903,2016],"source":" To ensure appropriate ordering, you must explicitly order the results of <xref:System.Linq.Enumerable.Concat%2A>."},{"pos":[2026,2050],"content":"Intersect, Except, Union","linkify":"Intersect, Except, Union","nodes":[{"content":"Intersect, Except, Union","pos":[0,24]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Intersect%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Except%2A&gt;</ph> methods are well defined only on sets.","pos":[2054,2183],"source":"The <xref:System.Linq.Enumerable.Intersect%2A> and <xref:System.Linq.Enumerable.Except%2A> methods are well defined only on sets."},{"content":"The semantics for multisets is undefined.","pos":[2184,2225]},{"pos":[2232,2411],"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Union%2A&gt;</ph> method is defined for multisets as the unordered concatenation of the multisets (effectively the result of the UNION ALL clause in SQL).","source":"The <xref:System.Linq.Enumerable.Union%2A> method is defined for multisets as the unordered concatenation of the multisets (effectively the result of the UNION ALL clause in SQL)."},{"pos":[2421,2431],"content":"Take, Skip","linkify":"Take, Skip","nodes":[{"content":"Take, Skip","pos":[0,10]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> methods are well defined only against <bpt id=\"p1\">*</bpt>ordered sets<ept id=\"p1\">*</ept>.","pos":[2435,2568],"source":"<xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> methods are well defined only against *ordered sets*."},{"content":"The semantics for unordered sets or multisets are undefined.","pos":[2569,2629]},{"pos":[2637,2985],"content":"[!NOTE]\n <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against SQL Server 2000. For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).","leadings":["","> "],"nodes":[{"content":"<xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against SQL Server 2000. For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md).","pos":[9,346],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> have certain limitations when they are used in queries against SQL Server 2000.","pos":[0,159],"source":"<xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against SQL Server 2000."},{"content":"For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in <bpt id=\"p1\">[</bpt>Troubleshooting<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md)</ept>.","pos":[160,337],"source":" For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md)."}]}]},{"content":"Because of limitations on ordering in SQL, <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> tries to move the ordering of the argument of these methods to the result of the method.","pos":[2992,3191],"source":"Because of limitations on ordering in SQL, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tries to move the ordering of the argument of these methods to the result of the method."},{"content":"For example, consider the following <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> query:","pos":[3192,3302],"source":" For example, consider the following [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] query:"},{"content":"The generated SQL for this code moves the ordering to the end, as follows:","pos":[3585,3659]},{"content":"It becomes obvious that all the specified ordering must be consistent when <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> are chained together.","pos":[4106,4282],"source":"It becomes obvious that all the specified ordering must be consistent when <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> are chained together."},{"content":"Otherwise, the results are undefined.","pos":[4283,4320]},{"pos":[4327,4526],"content":"Both <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> are well-defined for non-negative, constant integral arguments based on the Standard Query Operator specification.","source":"Both <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> are well-defined for non-negative, constant integral arguments based on the Standard Query Operator specification."},{"pos":[4536,4565],"content":"Operators with No Translation","linkify":"Operators with No Translation","nodes":[{"content":"Operators with No Translation","pos":[0,29]}]},{"content":"The following methods are not translated by <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph>.","pos":[4569,4681],"source":"The following methods are not translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]."},{"content":"The most common reason is the difference between unordered multisets and sequences.","pos":[4682,4765]},{"content":"Operators","pos":[4772,4781]},{"content":"Rationale","pos":[4782,4791]},{"pos":[4832,4918],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.TakeWhile%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.SkipWhile%2A&gt;</ph>","source":"<xref:System.Linq.Enumerable.TakeWhile%2A>, <xref:System.Linq.Enumerable.SkipWhile%2A>"},{"content":"SQL queries operate on multisets, not on sequences.","pos":[4919,4970]},{"content":"<ph id=\"ph1\">`ORDER BY`</ph> must be the last clause applied to the results.","pos":[4971,5029],"source":"`ORDER BY` must be the last clause applied to the results."},{"content":"For this reason, there is no general-purpose translation for these two methods.","pos":[5030,5109]},{"pos":[5155,5316],"content":"Translation of this method is possible for an ordered set but is not currently translated by <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph>.","source":"Translation of this method is possible for an ordered set but is not currently translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]."},{"pos":[5321,5406],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Last%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.LastOrDefault%2A&gt;</ph>","source":"<xref:System.Linq.Enumerable.Last%2A>, <xref:System.Linq.Enumerable.LastOrDefault%2A>"},{"pos":[5407,5570],"content":"Translation of these methods is possible for an ordered set but is not currently translated by <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph>.","source":"Translation of these methods is possible for an ordered set but is not currently translated by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]."},{"pos":[5575,5670],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ElementAt%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.ElementAtOrDefault%2A&gt;</ph>","source":"<xref:System.Linq.Enumerable.ElementAt%2A>, <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>"},{"content":"SQL queries operate on multisets, not on indexable sequences.","pos":[5671,5732]},{"pos":[5737,5812],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.DefaultIfEmpty%2A&gt;</ph> (overload with default arg)","source":"<xref:System.Linq.Enumerable.DefaultIfEmpty%2A> (overload with default arg)"},{"content":"In general, a default value cannot be specified for an arbitrary tuple.","pos":[5813,5884]},{"content":"Null values for tuples are possible in some cases through outer joins.","pos":[5885,5955]},{"pos":[5965,5987],"content":"Expression Translation","linkify":"Expression Translation","nodes":[{"content":"Expression Translation","pos":[0,22]}]},{"pos":[5997,6011],"content":"Null semantics","linkify":"Null semantics","nodes":[{"content":"Null semantics","pos":[0,14]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> does not impose null comparison semantics on SQL.","pos":[6015,6132],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not impose null comparison semantics on SQL."},{"content":"Comparison operators are syntactically translated to their SQL equivalents.","pos":[6133,6208]},{"content":"For this reason, the semantics reflect SQL semantics that are defined by server or connection settings.","pos":[6209,6312]},{"content":"For example, two null values are considered unequal under default SQL Server settings, but you can change the settings to change the semantics.","pos":[6313,6456]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> does not consider server settings when it translates queries.","pos":[6457,6586],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not consider server settings when it translates queries."},{"pos":[6593,6702],"content":"A comparison with the literal null is translated to the appropriate SQL version (<ph id=\"ph1\">`is null`</ph> or <ph id=\"ph2\">`is not null`</ph>).","source":"A comparison with the literal null is translated to the appropriate SQL version (`is null` or `is not null`)."},{"content":"The value of <ph id=\"ph1\">`null`</ph> in collation is defined by SQL Server.","pos":[6709,6767],"source":"The value of `null` in collation is defined by SQL Server."},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> does not change the collation.","pos":[6768,6866],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not change the collation."},{"pos":[6876,6886],"content":"Aggregates","linkify":"Aggregates","nodes":[{"content":"Aggregates","pos":[0,10]}]},{"content":"The Standard Query Operator aggregate method <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Sum%2A&gt;</ph> evaluates to zero for an empty sequence or for a sequence that contains only nulls.","pos":[6890,7055],"source":"The Standard Query Operator aggregate method <xref:System.Linq.Enumerable.Sum%2A> evaluates to zero for an empty sequence or for a sequence that contains only nulls."},{"content":"In <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph>, the semantics of SQL are left unchanged, and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Sum%2A&gt;</ph> evaluates to <ph id=\"ph3\">`null`</ph> instead of zero for an empty sequence or for a sequence that contains only nulls.","pos":[7056,7311],"source":" In [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], the semantics of SQL are left unchanged, and <xref:System.Linq.Enumerable.Sum%2A> evaluates to `null` instead of zero for an empty sequence or for a sequence that contains only nulls."},{"content":"SQL limitations on intermediate results apply to aggregates in <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph>.","pos":[7318,7449],"source":"SQL limitations on intermediate results apply to aggregates in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Sum%2A&gt;</ph> of 32-bit integer quantities is not computed by using 64-bit results.","pos":[7450,7560],"source":" The <xref:System.Linq.Enumerable.Sum%2A> of 32-bit integer quantities is not computed by using 64-bit results."},{"content":"Overflow might occur for a <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> translation of <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Sum%2A&gt;</ph>, even if the Standard Query Operator implementation does not cause an overflow for the corresponding in-memory sequence.","pos":[7561,7828],"source":" Overflow might occur for a [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translation of <xref:System.Linq.Enumerable.Sum%2A>, even if the Standard Query Operator implementation does not cause an overflow for the corresponding in-memory sequence."},{"pos":[7835,8038],"content":"Likewise, the <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> translation of <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Average%2A&gt;</ph> of integer values is computed as an <ph id=\"ph3\">`integer`</ph>, not as a <ph id=\"ph4\">`double`</ph>.","source":"Likewise, the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] translation of <xref:System.Linq.Enumerable.Average%2A> of integer values is computed as an `integer`, not as a `double`."},{"pos":[8048,8064],"content":"Entity Arguments","linkify":"Entity Arguments","nodes":[{"content":"Entity Arguments","pos":[0,16]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> enables entity types to be used in the <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.GroupBy%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph> methods.","pos":[8068,8269],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] enables entity types to be used in the <xref:System.Linq.Enumerable.GroupBy%2A> and <xref:System.Linq.Enumerable.OrderBy%2A> methods."},{"content":"In the translation of these operators, the use of an argument of a type is considered to be the equivalent to specifying all members of that type.","pos":[8270,8416]},{"content":"For example, the following code is equivalent:","pos":[8417,8463]},{"pos":[8749,8781],"content":"Equatable / Comparable Arguments","linkify":"Equatable / Comparable Arguments","nodes":[{"content":"Equatable / Comparable Arguments","pos":[0,32]}]},{"content":"Equality of arguments is required in the implementation of the following methods:","pos":[8785,8866]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> supports equality and comparison for <bpt id=\"p1\">*</bpt>flat<ept id=\"p1\">*</ept> arguments, but not for arguments that are or contain sequences.","pos":[9105,9280],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] supports equality and comparison for *flat* arguments, but not for arguments that are or contain sequences."},{"content":"A flat argument is a type that can be mapped to a SQL row.","pos":[9281,9339]},{"content":"A projection of one or more entity types that can be statically determined not to contain a sequence is considered a flat argument.","pos":[9340,9471]},{"content":"Following are examples of flat arguments:","pos":[9478,9519]},{"content":"The following are examples of non-flat (hierarchical) arguments.","pos":[9802,9866]},{"pos":[10152,10185],"content":"Visual Basic Function Translation","linkify":"Visual Basic Function Translation","nodes":[{"content":"Visual Basic Function Translation","pos":[0,33]}]},{"content":"The following helper functions that are used by the Visual Basic compiler are translated to corresponding SQL operators and functions:","pos":[10189,10323]},{"content":"Conversion methods:","pos":[10452,10471]},{"content":"ToBoolean","pos":[10498,10507]},{"content":"ToSByte","pos":[10508,10515]},{"content":"ToByte","pos":[10516,10522]},{"content":"ToChar","pos":[10523,10529]},{"content":"ToCharArrayRankOne","pos":[10534,10552]},{"content":"ToDate","pos":[10553,10559]},{"content":"ToDecimal","pos":[10560,10569]},{"content":"ToDouble","pos":[10570,10578]},{"content":"ToInteger","pos":[10583,10592]},{"content":"ToUInteger","pos":[10593,10603]},{"content":"ToLong","pos":[10604,10610]},{"content":"ToULong","pos":[10611,10618]},{"content":"ToShort","pos":[10623,10630]},{"content":"ToUShort","pos":[10631,10639]},{"content":"ToSingle","pos":[10640,10648]},{"content":"ToString","pos":[10649,10657]},{"pos":[10667,10686],"content":"Inheritance Support","linkify":"Inheritance Support","nodes":[{"content":"Inheritance Support","pos":[0,19]}]},{"pos":[10696,10728],"content":"Inheritance Mapping Restrictions","linkify":"Inheritance Mapping Restrictions","nodes":[{"content":"Inheritance Mapping Restrictions","pos":[0,32]}]},{"pos":[10732,10889],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Map Inheritance Hierarchies<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/how-to-map-inheritance-hierarchies.md)</ept>.","source":"For more information, see [How to: Map Inheritance Hierarchies](../../../../../../docs/framework/data/adonet/sql/linq/how-to-map-inheritance-hierarchies.md)."},{"pos":[10899,10921],"content":"Inheritance in Queries","linkify":"Inheritance in Queries","nodes":[{"content":"Inheritance in Queries","pos":[0,22]}]},{"content":"C# casts are supported only in projection.","pos":[10925,10967]},{"content":"Casts that are used elsewhere are not translated and are ignored.","pos":[10968,11033]},{"content":"Aside from SQL function names, SQL really only performs the equivalent of the common language runtime (CLR) <ph id=\"ph1\">&lt;xref:System.Convert&gt;</ph>.","pos":[11034,11164],"source":" Aside from SQL function names, SQL really only performs the equivalent of the common language runtime (CLR) <xref:System.Convert>."},{"content":"That is, SQL can change the value of one type to another.","pos":[11165,11222]},{"content":"There is no equivalent of CLR cast because there is no concept of reinterpreting the same bits as those of another type.","pos":[11223,11343]},{"content":"That is why a C# cast works only locally.","pos":[11344,11385]},{"content":"It is not remoted.","pos":[11386,11404]},{"content":"The operators, <ph id=\"ph1\">`is`</ph> and <ph id=\"ph2\">`as`</ph>, and the <ph id=\"ph3\">`GetType`</ph> method are not restricted to the <ph id=\"ph4\">`Select`</ph> operator.","pos":[11411,11510],"source":"The operators, `is` and `as`, and the `GetType` method are not restricted to the `Select` operator."},{"content":"They can be used in other query operators also.","pos":[11511,11558]},{"pos":[11567,11590],"content":"SQL Server 2008 Support","linkify":"SQL Server 2008 Support","nodes":[{"content":"SQL Server 2008 Support","pos":[0,23]}]},{"content":"Starting with the .NET Framework 3.5 SP1, LINQ to SQL supports mapping to new date and time types introduced with SQL Server 2008.","pos":[11594,11724]},{"content":"But, there are some limitations to the LINQ to SQL query operators that you can use when operating against values mapped to these new types.","pos":[11725,11865]},{"pos":[11875,11902],"content":"Unsupported Query Operators","linkify":"Unsupported Query Operators","nodes":[{"content":"Unsupported Query Operators","pos":[0,27]}]},{"pos":[11906,12064],"content":"The following query operators are not supported on values mapped to the new SQL Server date and time types: <ph id=\"ph1\">`DATETIME2`</ph>, <ph id=\"ph2\">`DATE`</ph>, <ph id=\"ph3\">`TIME`</ph>, and <ph id=\"ph4\">`DATETIMEOFFSET`</ph>.","source":"The following query operators are not supported on values mapped to the new SQL Server date and time types: `DATETIME2`, `DATE`, `TIME`, and `DATETIMEOFFSET`."},{"pos":[12169,12351],"content":"For more information about mapping to these SQL Server date and time types, see <bpt id=\"p1\">[</bpt>SQL-CLR Type Mapping<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md)</ept>.","source":"For more information about mapping to these SQL Server date and time types, see [SQL-CLR Type Mapping](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md)."},{"pos":[12360,12383],"content":"SQL Server 2005 Support","linkify":"SQL Server 2005 Support","nodes":[{"content":"SQL Server 2005 Support","pos":[0,23]}]},{"pos":[12387,12511],"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> does not support the following SQL Server 2005 features:","source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] does not support the following SQL Server 2005 features:"},{"content":"Stored procedures written for SQL CLR.","pos":[12521,12559]},{"content":"User-defined type.","pos":[12569,12587]},{"content":"XML query features.","pos":[12597,12616]},{"pos":[12625,12648],"content":"SQL Server 2000 Support","linkify":"SQL Server 2000 Support","nodes":[{"content":"SQL Server 2000 Support","pos":[0,23]}]},{"pos":[12652,12897],"content":"The following <ph id=\"ph1\">[!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]</ph> limitations (compared to <ph id=\"ph2\">[!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]</ph>) affect <ph id=\"ph3\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> support.","source":"The following [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] limitations (compared to [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]) affect [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] support."},{"pos":[12907,12944],"content":"Cross Apply and Outer Apply Operators","linkify":"Cross Apply and Outer Apply Operators","nodes":[{"content":"Cross Apply and Outer Apply Operators","pos":[0,37]}]},{"content":"These operators are not available in <ph id=\"ph1\">[!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]</ph>.","pos":[12948,13041],"source":"These operators are not available in [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]."},{"content":"<ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> tries a series of rewrites to replace them with appropriate joins.","pos":[13042,13176],"source":"[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] tries a series of rewrites to replace them with appropriate joins."},{"content":"<ph id=\"ph1\">`Cross Apply`</ph> and <ph id=\"ph2\">`Outer Apply`</ph> are generated for relationship navigations.","pos":[13183,13258],"source":"`Cross Apply` and `Outer Apply` are generated for relationship navigations."},{"content":"The set of queries for which such rewrites are possible is not well defined.","pos":[13259,13335]},{"content":"For this reason, the minimal set of queries that is supported for <ph id=\"ph1\">[!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]</ph> is the set that does not involve relationship navigation.","pos":[13336,13515],"source":" For this reason, the minimal set of queries that is supported for [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] is the set that does not involve relationship navigation."},{"pos":[13525,13537],"content":"text / ntext","linkify":"text / ntext","nodes":[{"content":"text / ntext","pos":[0,12]}]},{"pos":[13541,13743],"content":"Data types <ph id=\"ph1\">`text`</ph><ph id=\"ph2\"> / </ph><ph id=\"ph3\">`ntext`</ph> cannot be used in certain query operations against <ph id=\"ph4\">`varchar(max)`</ph><ph id=\"ph5\"> / </ph><ph id=\"ph6\">`nvarchar(max)`</ph>, which are supported by <ph id=\"ph7\">[!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]</ph>.","source":"Data types `text` / `ntext` cannot be used in certain query operations against `varchar(max)` / `nvarchar(max)`, which are supported by [!INCLUDE[sqprsqext](../../../../../../includes/sqprsqext-md.md)]."},{"content":"No resolution is available for this limitation.","pos":[13750,13797]},{"content":"Specifically, you cannot use <ph id=\"ph1\">`Distinct()`</ph> on any result that contains members that are mapped to <ph id=\"ph2\">`text`</ph> or <ph id=\"ph3\">`ntext`</ph> columns.","pos":[13798,13921],"source":" Specifically, you cannot use `Distinct()` on any result that contains members that are mapped to `text` or `ntext` columns."},{"pos":[13931,13967],"content":"Behavior Triggered by Nested Queries","linkify":"Behavior Triggered by Nested Queries","nodes":[{"content":"Behavior Triggered by Nested Queries","pos":[0,36]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]</ph> (through SP4) binder has some idiosyncrasies that are triggered by nested queries.","pos":[13971,14109],"source":"[!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)] (through SP4) binder has some idiosyncrasies that are triggered by nested queries."},{"content":"The set of SQL queries that triggers these idiosyncrasies is not well defined.","pos":[14110,14188]},{"content":"For this reason, you cannot define the set of <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> queries that might cause SQL Server exceptions.","pos":[14189,14350],"source":" For this reason, you cannot define the set of [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] queries that might cause SQL Server exceptions."},{"pos":[14360,14383],"content":"Skip and Take Operators","linkify":"Skip and Take Operators","nodes":[{"content":"Skip and Take Operators","pos":[0,23]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Take%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph> have certain limitations when they are used in queries against <ph id=\"ph3\">[!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]</ph>.","pos":[14387,14586],"source":"<xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> have certain limitations when they are used in queries against [!INCLUDE[ss2k](../../../../../../includes/ss2k-md.md)]."},{"content":"For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in <bpt id=\"p1\">[</bpt>Troubleshooting<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md)</ept>.","pos":[14587,14764],"source":" For more information, see the \"Skip and Take Exceptions in SQL Server 2000\" entry in [Troubleshooting](../../../../../../docs/framework/data/adonet/sql/linq/troubleshooting.md)."},{"pos":[14773,14795],"content":"Object Materialization","linkify":"Object Materialization","nodes":[{"content":"Object Materialization","pos":[0,22]}]},{"content":"Materialization creates CLR objects from rows that are returned by one or more SQL queries.","pos":[14799,14890]},{"pos":[14900,14972],"content":"The following calls are <bpt id=\"p1\">*</bpt>executed locally<ept id=\"p1\">*</ept> as a part of materialization:","source":"The following calls are *executed locally* as a part of materialization:"},{"content":"Constructors","pos":[14986,14998]},{"pos":[15012,15045],"content":"<ph id=\"ph1\">`ToString`</ph> methods in projections","source":"`ToString` methods in projections"},{"content":"Type casts in projections","pos":[15059,15084]},{"content":"Methods that follow the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.AsEnumerable%2A&gt;</ph> method are <bpt id=\"p1\">*</bpt>executed locally<ept id=\"p1\">*</ept>.","pos":[15094,15194],"source":"Methods that follow the <xref:System.Linq.Enumerable.AsEnumerable%2A> method are *executed locally*."},{"content":"This method does not cause immediate execution.","pos":[15195,15242]},{"content":"You can use a <ph id=\"ph1\">`struct`</ph> as the return type of a query result or as a member of the result type.","pos":[15252,15346],"source":"You can use a `struct` as the return type of a query result or as a member of the result type."},{"content":"Entities are required to be classes.","pos":[15347,15383]},{"content":"Anonymous types are materialized as class instances, but named structs (non-entities) can be used in projection.","pos":[15384,15496]},{"content":"A member of the return type of a query result can be of type <ph id=\"ph1\">&lt;xref:System.Linq.IQueryable%601&gt;</ph>.","pos":[15506,15601],"source":"A member of the return type of a query result can be of type <xref:System.Linq.IQueryable%601>."},{"content":"It is materialized as a local collection.","pos":[15602,15643]},{"pos":[15653,15761],"content":"The following methods cause the <bpt id=\"p1\">*</bpt>immediate materialization<ept id=\"p1\">*</ept> of the sequence that the methods are applied to:","source":"The following methods cause the *immediate materialization* of the sequence that the methods are applied to:"},{"pos":[15936,15944],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[15948,16027],"content":"<bpt id=\"p1\">[</bpt>Reference<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/reference.md)</ept>","source":"[Reference](../../../../../../docs/framework/data/adonet/sql/linq/reference.md)"},{"pos":[16030,16165],"content":"<bpt id=\"p1\">[</bpt>Return Or Skip Elements in a Sequence<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/return-or-skip-elements-in-a-sequence.md)</ept>","source":"[Return Or Skip Elements in a Sequence](../../../../../../docs/framework/data/adonet/sql/linq/return-or-skip-elements-in-a-sequence.md)"},{"pos":[16168,16279],"content":"<bpt id=\"p1\">[</bpt>Concatenate Two Sequences<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/concatenate-two-sequences.md)</ept>","source":"[Concatenate Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/concatenate-two-sequences.md)"},{"pos":[16282,16437],"content":"<bpt id=\"p1\">[</bpt>Return the Set Difference Between Two Sequences<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-difference-between-two-sequences.md)</ept>","source":"[Return the Set Difference Between Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-difference-between-two-sequences.md)"},{"pos":[16440,16589],"content":"<bpt id=\"p1\">[</bpt>Return the Set Intersection of Two Sequences<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-intersection-of-two-sequences.md)</ept>","source":"[Return the Set Intersection of Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-intersection-of-two-sequences.md)"},{"pos":[16592,16727],"content":"<bpt id=\"p1\">[</bpt>Return the Set Union of Two Sequences<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-union-of-two-sequences.md)</ept>","source":"[Return the Set Union of Two Sequences](../../../../../../docs/framework/data/adonet/sql/linq/return-the-set-union-of-two-sequences.md)"}]}