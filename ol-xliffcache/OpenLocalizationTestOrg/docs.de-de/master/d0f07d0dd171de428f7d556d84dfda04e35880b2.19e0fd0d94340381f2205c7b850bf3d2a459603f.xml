{"content":"---\ntitle: \"Routing Introduction\"\nms.date: \"03/30/2017\"\nms.assetid: bf6ceb38-6622-433b-9ee7-f79bc93497a1\n---\n# Routing Introduction\nThe Routing Service provides a generic pluggable SOAP intermediary that is capable of routing messages based on message content. With the Routing Service, you can create complex routing logic that allows you to implement scenarios such as service aggregation, service versioning, priority routing, and multicast routing. The Routing Service also provides error handling that allows you to set up lists of backup endpoints, to which messages are sent if a failure occurs when sending to the primary destination endpoint.  \n  \n This topic is intended for those new to the Routing Service and covers basic configuration and hosting of the Routing Service.  \n  \n## Configuration  \n The Routing Service is implemented as a WCF service that exposes one or more service endpoints that receive messages from client applications and route the messages to one or more destination endpoints. The service provides a <xref:System.ServiceModel.Routing.RoutingBehavior>, which is applied to the service endpoints exposed by the service. This behavior is used to configure various aspects of how the service operates. For ease of configuration when using a configuration file, the parameters are specified on the **RoutingBehavior**. In code-based scenarios, these parameters would be specified as part of a <xref:System.ServiceModel.Routing.RoutingConfiguration> object, which can then be passed to a **RoutingBehavior**.  \n  \n When starting, this behavior adds the <xref:System.ServiceModel.Routing.SoapProcessingBehavior>, which is used to perform SOAP processing of messages, to the client endpoints. This allows the Routing Service to transmit messages to endpoints that require a different **MessageVersion** than the endpoint the message was received over. The **RoutingBehavior** also registers a service extension, the <xref:System.ServiceModel.Routing.RoutingExtension>, which provides an accessibility point for modifying the Routing Service configuration at run time.  \n  \n The **RoutingConfiguration** class provides a consistent means of configuring and updating the configuration of the Routing Service.  It contains parameters that act as the settings for the Routing Service and is used to configure the **RoutingBehavior** when the service starts, or is passed to the **RoutingExtension** to modify routing configuration at run time.  \n  \n The routing logic used to perform content-based routing of messages is defined by grouping multiple <xref:System.ServiceModel.Dispatcher.MessageFilter> objects together into filter tables (<xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> objects). Incoming messages are evaluated against the message filters contained in the filter table, and for each **MessageFilter** that matches the message, forwarded to a destination endpoint. The filter table that should be used to route messages is specified by using either the **RoutingBehavior** in configuration or through code by using the **RoutingConfiguration** object.  \n  \n### Defining Endpoints  \n While it may seem that you should start your configuration by defining the routing logic you will use, your first step should actually be to determine the shape of the endpoints you will be routing messages to. The Routing Service uses contracts that define the shape of the channels used to receive and send messages, and therefore the shape of the input channel must match that of the output channel.  For example, if you are routing to endpoints that use the request-reply channel shape, then you must use a compatible contract on the inbound endpoints, such as the <xref:System.ServiceModel.Routing.IRequestReplyRouter>.  \n  \n This means that if your destination endpoints use contracts with multiple communication patterns (such as mixing one-way and two-way operations,) you cannot create a single service endpoint that can receive and route messages to all of them. You must determine which endpoints have compatible shapes and define one or more service endpoints that will be used to receive messages to be routed to the destination endpoints.  \n  \n> [!NOTE]\n> When working with contracts that specify multiple communication patterns (such as a mix of one-way and two-way operations,) a workaround is to use a duplex contract at the Routing Service such as <xref:System.ServiceModel.Routing.IDuplexSessionRouter>. However this means that the binding must be capable of duplex communication, which may not be possible for all scenarios. In scenarios where this is not possible, factoring the communication into multiple endpoints or modifying the application may be necessary.  \n  \n For more information about routing contracts, see [Routing Contracts](routing-contracts.md).  \n  \n After the service endpoint is defined, you can use the **RoutingBehavior** to associate a specific **RoutingConfiguration** with the endpoint. When configuring the Routing Service by using a configuration file, the **RoutingBehavior** is used to specify the filter table that contains the routing logic used to process messages received on this endpoint. If you are configuring the Routing Service programmatically you can specify the filter table by using the **RoutingConfiguration**.  \n  \n The following example defines the service and client endpoints that are used by the Routing Service both programmatically and by using a configuration file.  \n  \n```xml  \n    <services>  \n      <!--ROUTING SERVICE -->  \n      <service behaviorConfiguration=\"routingData\"  \n               name=\"System.ServiceModel.Routing.RoutingService\">  \n        <host>  \n          <baseAddresses>  \n            <add baseAddress=\"http://localhost:8000/routingservice/router\"/>  \n          </baseAddresses>  \n        </host>  \n        <!-- Define the service endpoints that are receive messages -->  \n        <endpoint address=\"\"  \n                  binding=\"wsHttpBinding\"  \n                  name=\"reqReplyEndpoint\"  \n                  contract=\"System.ServiceModel.Routing.IRequestReplyRouter\" />\n      </service>  \n    </services>  \n    <behaviors>  \n      <serviceBehaviors>  \n        <behavior name=\"routingData\">  \n          <serviceMetadata httpGetEnabled=\"True\"/>  \n          <!-- Add the RoutingBehavior and specify the Routing Table to use -->  \n          <routing filterTableName=\"routingTable1\" />  \n        </behavior>  \n      </serviceBehaviors>  \n    </behaviors>  \n    <client>  \n    <!-- Define the client endpoint(s) to route messages to -->  \n      <endpoint name=\"CalculatorService\"  \n                address=\"http://localhost:8000/servicemodelsamples/service\"  \n                binding=\"wsHttpBinding\" contract=\"*\" />  \n    </client>  \n```  \n  \n```csharp  \n//set up some communication defaults  \nstring clientAddress = \"http://localhost:8000/servicemodelsamples/service\";  \nstring routerAddress = \"http://localhost:8000/routingservice/router\";  \nBinding routerBinding = new WSHttpBinding();  \nBinding clientBinding = new WSHttpBinding();  \n//add the endpoint the router uses to receive messages  \nserviceHost.AddServiceEndpoint(  \n     typeof(IRequestReplyRouter),   \n     routerBinding,   \n     routerAddress);  \n//create the client endpoint the router routes messages to  \nContractDescription contract = ContractDescription.GetContract(  \n     typeof(IRequestReplyRouter));  \nServiceEndpoint client = new ServiceEndpoint(  \n     contract,   \n     clientBinding,   \n     new EndpointAddress(clientAddress));  \n//create a new routing configuration object  \nRoutingConfiguration rc = new RoutingConfiguration();  \n….  \nrc.FilterTable.Add(new MatchAllMessageFilter(), endpointList);  \n//attach the behavior to the service host  \nserviceHost.Description.Behaviors.Add(  \n     new RoutingBehavior(rc));  \n```  \n  \n This example configures the Routing Service to expose a single endpoint with an address of `http://localhost:8000/routingservice/router`, which is used to receive messages to be routed. Because the messages are routed to request-reply endpoints, the service endpoint uses the <xref:System.ServiceModel.Routing.IRequestReplyRouter> contract. This configuration also defines a single client endpoint of `http://localhost:8000/servicemodelsample/service` that messages are routed to. The filter table (not shown) named \"routingTable1\" contains the routing logic used to route messages, and is associated with the service endpoint by using the **RoutingBehavior** (for a configuration file) or **RoutingConfiguration** (for programmatic configuration).  \n  \n### Routing Logic  \n To define the routing logic used to route messages, you must determine what data contained within the incoming messages can be uniquely acted upon. For example, if all the destination endpoints you are routing to share the same SOAP Actions, the value of the Action contained within the message is not a good indicator of which specific endpoint the message should be routed to. If you must uniquely route messages to one specific endpoint, you should filter upon data that uniquely identifies the destination endpoint that the message is routed to.  \n  \n The Routing Service provides several **MessageFilter** implementations that inspect specific values within the message, such as the address, action, endpoint name, or even an XPath query. If none of these implementations meet your needs you can create a custom **MessageFilter** implementation. For more information about message filters and a comparison of the implementations used by the Routing Service, see [Message Filters](message-filters.md) and [Choosing a Filter](choosing-a-filter.md).  \n  \n Multiple message filters are organized together into filter tables, which associate each **MessageFilter** with a destination endpoint. Optionally, the filter table can also be used to specify a list of back-up endpoints that the Routing Service will attempt to send the message to in the event of a transmission failure.  \n  \n By default all message filters within a filter table are evaluated simultaneously; however, you can specify a <xref:System.ServiceModel.Routing.Configuration.FilterTableEntryElement.Priority%2A> that causes the message filters to be evaluated in a specific order. All entries with the highest priority are evaluated first, and message filters of lower priorities are not evaluated if a match is found at a higher priority level. For more information about filter tables, see [Message Filters](message-filters.md).  \n  \n The following examples use the <xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter>, which evaluates to `true` for all messages. This **MessageFilter** is added to the \"routingTable1\" filter table, which associates the **MessageFilter** with the client endpoint named \"CalculatorService\". The **RoutingBehavior** then specifies that this table should be used to route messages processed by the service endpoint.  \n  \n```xml  \n<behaviors>  \n  <serviceBehaviors>  \n    <behavior name=\"routingData\">  \n      <serviceMetadata httpGetEnabled=\"True\"/>  \n      <!-- Add the RoutingBehavior and specify the Routing Table to use -->  \n      <routing filterTableName=\"routingTable1\" />  \n    </behavior>  \n  </serviceBehaviors>  \n</behaviors>  \n<!--ROUTING SECTION -->  \n<routing>  \n  <filters>  \n    <filter name=\"MatchAllFilter1\" filterType=\"MatchAll\" />  \n  </filters>  \n  <filterTables>  \n    <table name=\"routingTable1\">  \n      <filters>  \n        <add filterName=\"MatchAllFilter1\" endpointName=\"CalculatorService\" />  \n      </filters>  \n    </table>  \n  </filterTables>  \n</routing>  \n```  \n  \n```csharp  \n//create a new routing configuration object  \nRoutingConfiguration rc = new RoutingConfiguration();  \n//create the endpoint list that contains the endpoints to route to  \n//in this case we have only one  \nList<ServiceEndpoint> endpointList = new List<ServiceEndpoint>();  \nendpointList.Add(client);  \n//add a MatchAll filter to the Router's filter table  \n//map it to the endpoint list defined earlier  \n//when a message matches this filter, it is sent to the endpoint contained in the list  \nrc.FilterTable.Add(new MatchAllMessageFilter(), endpointList);  \n```  \n  \n> [!NOTE]\n>  By default, the Routing Service only evaluates the headers of the message. To allow the filters to access the message body, you must set <xref:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly%2A> to `false`.  \n  \n **Multicast**  \n  \n While many Routing Service configurations use exclusive filter logic that routes messages to only one specific endpoint, you may need to route a given message to multiple destination endpoints. To multicast a message to multiple destinations, the following conditions must be true:  \n  \n-   The channel shape must not be request-reply (though may be one-way or duplex,) because only one reply can be received by the client application in response to the request.  \n  \n-   Multiple filters must return `true` when evaluating the message.  \n  \n If these conditions are met, the message is routed to all endpoints of all filters that evaluate to `true`. The following example defines a routing configuration that results in messages being routed to both endpoints if the endpoint address in the message is `http://localhost:8000/routingservice/router/rounding`.  \n  \n```xml  \n<!--ROUTING SECTION -->  \n<routing>  \n  <filters>  \n    <filter name=\"MatchAllFilter1\" filterType=\"MatchAll\" />  \n    <filter name=\"RoundingFilter1\" filterType=\"EndpointAddress\"  \n            filterData=\"http://localhost:8000/routingservice/router/rounding\" />  \n  </filters>  \n  <filterTables>  \n    <table name=\"routingTable1\">  \n      <filters>  \n        <add filterName=\"MatchAllFilter1\" endpointName=\"CalculatorService\" />  \n        <add filterName=\"RoundingFilter1\" endpointName=\"RoundingCalcService\" />  \n      </filters>  \n    </table>  \n  </filterTables>  \n</routing>  \n```  \n  \n```csharp  \nrc.FilterTable.Add(new MatchAllMessageFilter(), calculatorEndpointList);  \nrc.FilterTable.Add(new EndpointAddressMessageFilter(new EndpointAddress(  \n    \"http://localhost:8000/routingservice/router/rounding\")),  \n    roundingCalcEndpointList);  \n```  \n  \n### SOAP Processing  \n To support the routing of messages between dissimilar protocols, the **RoutingBehavior** by default adds the <xref:System.ServiceModel.Routing.SoapProcessingBehavior> to all client endpoint(s) that messages are routed to. This behavior automatically creates a new **MessageVersion** before routing the message to the endpoint, as well as creating a compatible **MessageVersion** for any response document before returning it to the requesting client application.  \n  \n The steps taken to create a new **MessageVersion** for the outbound message are as follows:  \n  \n **Request processing**  \n  \n-   Get the **MessageVersion** of the outbound binding/channel.  \n  \n-   Get the body reader for the original message.  \n  \n-   Create a new message with the same action, body reader, and a new **MessageVersion**.  \n  \n-   If <xref:System.ServiceModel.Channels.MessageVersion.Addressing%2A> != **Addressing.None**, copy the To, From, FaultTo, and RelatesTo headers to the new message.  \n  \n-   Copy all message properties to the new message.  \n  \n-   Store the original request message to use when processing the response.  \n  \n-   Return the new request message.  \n  \n **Response processing**  \n  \n-   Get the **MessageVersion** of the original request message.  \n  \n-   Get the body reader for the received response message.  \n  \n-   Create a new response message with the same action, body reader, and the **MessageVersion** of the original request message.  \n  \n-   If <xref:System.ServiceModel.Channels.MessageVersion.Addressing%2A> != **Addressing.None**, copy the To, From, FaultTo, and RelatesTo headers to the new message.  \n  \n-   Copy the message properties to the new message.  \n  \n-   Return the new response message.  \n  \n By default, the **SoapProcessingBehavior** is automatically added to the client endpoints by the <xref:System.ServiceModel.Routing.RoutingBehavior> when the service starts; however, you can control whether SOAP processing is added to all client endpoints by using the <xref:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled%2A> property. You can also add the behavior directly to a specific endpoint and enable or disable this behavior at the endpoint level if a more granular control of SOAP processing is required.  \n  \n> [!NOTE]\n>  If SOAP processing is disabled for an endpoint that requires a different MessageVersion than that of the original request message, you must provide a custom mechanism for performing any SOAP modifications that are required before sending the message to the destination endpoint.  \n  \n In the following examples, the **soapProcessingEnabled** property is used to prevent the **SoapProcessingBehavior** from being automatically added to all client endpoints.  \n  \n```xml  \n<behaviors>  \n  <!--default routing service behavior definition-->  \n  <serviceBehaviors>  \n    <behavior name=\"routingConfiguration\">  \n      <routing filterTableName=\"filterTable1\" soapProcessingEnabled=\"false\"/>  \n    </behavior>  \n  </serviceBehaviors>  \n</behaviors>  \n```  \n  \n```csharp  \n//create the default RoutingConfiguration  \nRoutingConfiguration rc = new RoutingConfiguration();  \nrc.SoapProcessingEnabled = false;  \n```  \n  \n### Dynamic Configuration  \n When you add additional client endpoints, or need to modify the filters that are used to route messages, you must have a way to update the configuration dynamically at run time to prevent interrupting the service to the endpoints currently receiving messages through the Routing Service. Modifying a configuration file or the code of the host application is not always sufficient, because either method requires recycling the application, which would lead to the potential loss of any messages currently in transit and the potential for downtime while waiting on the service to restart.  \n  \n You can only modify the **RoutingConfiguration** programmatically. While you can initially configure the service by using a configuration file, you can only modify the configuration at run time by constructing a new **RoutingConfigution** and passing it as a parameter to the <xref:System.ServiceModel.Routing.RoutingExtension.ApplyConfiguration%2A> method exposed by the <xref:System.ServiceModel.Routing.RoutingExtension> service extension. Any messages currently in transit continue to be routed using the previous configuration, while messages received after the call to **ApplyConfiguration** use the new configuration. The following example demonstrates creating an instance of the Routing Service and then subsequently modifying the configuration.  \n  \n```csharp  \nRoutingConfiguration routingConfig = new RoutingConfiguration();  \nroutingConfig.RouteOnHeadersOnly = true;  \nroutingConfig.FilterTable.Add(new MatchAllMessageFilter(), endpointList);  \nRoutingBehavior routing = new RoutingBehavior(routingConfig);  \nrouterHost.Description.Behaviors.Add(routing);  \nrouterHost.Open();  \n// Construct a new RoutingConfiguration  \nRoutingConfiguration rc2 = new RoutingConfiguration();  \nServiceEndpoint clientEndpoint = new ServiceEndpoint();  \nServiceEndpoint clientEndpoint2 = new ServiceEndpoint();  \n// Add filters to the FilterTable in the new configuration  \nrc2.FilterTable.add(new MatchAllMessageFilter(),  \n       new List<ServiceEndpoint>() { clientEndpoint });  \nrc2.FilterTable.add(new MatchAllMessageFilter(),  \n       new List<ServiceEndpoint>() { clientEndpoint2 });  \nrc2.RouteOnHeadersOnly = false;  \n// Apply the new configuration to the Routing Service hosted in  \nrouterHost.routerHost.Extensions.Find<RoutingExtension>().ApplyConfiguration(rc2);  \n```  \n  \n> [!NOTE]\n>  When updating the Routing Service in this manner it is only possible to pass a new configuration. It is not possible to modify only select elements of the current configuration or append new entries to the current configuration; you must create and pass a new configuration that replaces the existing one.  \n  \n> [!NOTE]\n>  Any sessions opened using the previous configuration continue using the previous configuration. The new configuration is only used by new sessions.  \n  \n## Error Handling  \n If any <xref:System.ServiceModel.CommunicationException> is encountered while attempting to send a message, error handling take place. These exceptions typically indicate that a problem was encountered while attempting to communicate with the defined client endpoint, such as an <xref:System.ServiceModel.EndpointNotFoundException>, <xref:System.ServiceModel.ServerTooBusyException>, or <xref:System.ServiceModel.CommunicationObjectFaultedException>. The error handling-code will also catch and attempt to retry sending when a <xref:System.TimeoutException> occurs, which is another common exception that is not derived from **CommunicationException**.  \n  \n When one of the preceding exceptions occurs, the Routing Service fails over to a list of backup endpoints. If all backup endpoints fail with a communications failure, or if an endpoint returns an exception that indicates a failure within the destination service, the Routing Service returns a fault to the client application.  \n  \n> [!NOTE]\n>  The error-handling functionality captures and handles exceptions that occur when attempting to send a message and when attempting to close a channel. The error-handling code is not intended to detect or handle exceptions created by the application endpoints it is communicating with; a <xref:System.ServiceModel.FaultException> thrown by a service appears at the Routing Service as a **FaultMessage** and is flowed back to the client.  \n>   \n>  If an error occurs when the routing service tries to relay a message, you may  get a <xref:System.ServiceModel.FaultException> on the client side, rather than a <xref:System.ServiceModel.EndpointNotFoundException> you would normally get in the absence of the routing service. A routing service may thus mask exceptions and not provide full transparency unless you examine nested exceptions.  \n  \n### Tracing Exceptions  \n When sending a message to an endpoint in a list fails, the Routing Service traces the resulting exception data and attaches the exception details as a message property named **Exceptions**. This preserves the exception data and allows a user programmatic access through a message inspector.  The exception data is stored per message in a dictionary that maps the endpoint name to the exception details encountered when trying to send a message to it.  \n  \n### Backup Endpoints  \n Each filter entry within the filter table can optionally specify a list of backup endpoints, which are used in the event of a transmission failure when sending to the primary endpoint. If such a failure occurs, the Routing Service attempts to transmit the message to the first entry in the backup endpoint list. If this send attempt also encounters a transmission failure, the next endpoint in the backup list is tried. The Routing Service continues sending the message to each endpoint in the list until the message is successfully received, all endpoints return a transmission failure, or a non-transmission failure is returned by an endpoint.  \n  \n The following examples configure the Routing Service to use a backup list.  \n  \n```xml  \n<routing>  \n  <filters>  \n    <!-- Create a MatchAll filter that catches all messages -->  \n    <filter name=\"MatchAllFilter1\" filterType=\"MatchAll\" />  \n  </filters>  \n  <filterTables>  \n    <!-- Set up the Routing Service's Message Filter Table -->  \n    <filterTable name=\"filterTable1\">  \n        <!-- Add an entry that maps the MatchAllMessageFilter to the dead destination -->  \n        <!-- If that endpoint is down, tell the Routing Service to try the endpoints -->  \n        <!-- Listed in the backupEndpointList -->  \n        <add filterName=\"MatchAllFilter1\" endpointName=\"deadDestination\" backupList=\"backupEndpointList\"/>  \n    </filterTable>  \n  </filterTables>  \n  <!-- Create the backup endpoint list -->  \n  <backupLists>  \n    <!-- Add an endpoint list that contains the backup destinations -->  \n    <backupList name=\"backupEndpointList\">  \n      <add endpointName=\"realDestination\" />  \n      <add endpointName=\"backupDestination\" />  \n    </backupList>  \n  </backupLists>  \n</routing>  \n```  \n  \n```csharp  \n//create the endpoint list that contains the service endpoints we want to route to  \nList<ServiceEndpoint> backupList = new List<ServiceEndpoint>();  \n//add the endpoints in the order that the Routing Service should contact them  \n//first add the endpoint that we know is down  \n//clearly, normally you wouldn't know that this endpoint was down by default  \nbackupList.Add(fakeDestination);  \n//then add the real Destination endpoint  \n//the Routing Service attempts to send to this endpoint only if it   \n//encounters a TimeOutException or CommunicationException when sending  \n//to the previous endpoint in the list.  \nbackupList.Add(realDestination);  \n//add the backupDestination endpoint  \n//the Routing Service attempts to send to this endpoint only if it  \n//encounters a TimeOutException or CommunicationsException when sending  \n//to the previous endpoints in the list  \nbackupList.Add(backupDestination);  \n//create the default RoutingConfiguration option              \nRoutingConfiguration rc = new RoutingConfiguration();  \n//add a MatchAll filter to the Routing Configuration's filter table  \n//map it to the list of endpoints defined above  \n//when a message matches this filter, it is sent to the endpoints in the list in order  \n//if an endpoint is down or does not respond (which the first endpoint won't  \n//since the client does not exist), the Routing Service automatically moves the message  \n//to the next endpoint in the list and try again.  \nrc.FilterTable.Add(new MatchAllMessageFilter(), backupList);  \n```  \n  \n### Supported Error Patterns  \n The following table describes the patterns that are compatible with the use of backup endpoint lists, along with notes describing the details of error handling for specific patterns.  \n  \n|Pattern|Session|Transaction|Receive Context|Backup List Supported|Notes|  \n|-------------|-------------|-----------------|---------------------|---------------------------|-----------|  \n|One-Way||||Yes|Attempts to resend the message on a backup endpoint. If this message is being multicast, only the message on the failed channel is moved to its backup destination.|  \n|One-Way||✓||No|An exception is thrown and the transaction is rolled back.|  \n|One-Way|||✓|Yes|Attempts to resend the message on a backup endpoint. After the message is successfully received, complete all receive contexts. If the message is not successfully received by any endpoint, do not complete the receive context.<br /><br /> When this message is being multicast, the receive context is only completed if the message is successfully received by at least one endpoint (primary or backup). If none of the endpoints in any of the multicast paths successfully receive the message, do not complete the receive context.|  \n|One-Way||✓|✓|Yes|Abort the previous transaction, create a new transaction, and resend all messages. Messages that encountered an error are transmitted to a backup destination.<br /><br /> After a transaction has been created in which all transmissions succeed, complete the receive contexts and commit the transaction.|  \n|One-Way|✓|||Yes|Attempts to resend the message on a backup endpoint. In a multicast scenario only the messages in a session that encountered an error or in a session whose session close failed are resent to backup destinations.|  \n|One-Way|✓|✓||No|An exception is thrown and the transaction is rolled back.|  \n|One-Way|✓||✓|Yes|Attempts to resend the message on a backup endpoint. After all message sends complete without error, the session indicates no more messages and the Routing Service successfully closes all outbound session channel(s), all receive contexts are completed, and the inbound session channel is closed.|  \n|One-Way|✓|✓|✓|Yes|Abort the current transaction and create a new one. Resend all previous messages in the session. After a transaction has been created in which all messages have been successfully sent and the session indicates no more messages, all the outbound session channels are closed, receive contexts are all completed with the transaction, the inbound session channel is closed, and the transaction is committed.<br /><br /> When the sessions are being multicast the messages that had no error are resent to the same destination as before, and messages that encountered an error are sent to backup destinations.|  \n|Two-Way||||Yes|Send to a backup destination.  After a channel returns a response message, return the response to the original client.|  \n|Two-Way|✓|||Yes|Send all messages on the channel to a backup destination.  After a channel returns a response message, return the response to the original client.|  \n|Two-Way||✓||No|An exception is thrown and the transaction is rolled back.|  \n|Two-Way|✓|✓||No|An exception is thrown and the transaction is rolled back.|  \n|Duplex||||No|Non-session duplex communication is not currently supported.|  \n|Duplex|✓|||Yes|Send to a backup destination.|  \n  \n## Hosting  \n Because the Routing Service is implemented as a WCF service, it must be either self-hosted within an application or hosted by IIS or WAS. It is recommended that the Routing Service be hosted in either IIS, WAS, or a Windows Service application to take advantage of the automatic start and life-cycle management features available in these hosting environments.  \n  \n The following example demonstrates hosting the Routing Service in an application.  \n  \n```csharp  \nusing (ServiceHost serviceHost =  \n                new ServiceHost(typeof(RoutingService)))  \n```  \n  \n To host the Routing Service within IIS or WAS, you must either create a service file (.svc) or use configuration-based activation of the service. When using a service file, you must specify the <xref:System.ServiceModel.Routing.RoutingService> using the Service parameter. The following example contains a sample service file that can be used to host the Routing Service with IIS or WAS.  \n  \n```  \n<%@ ServiceHost Language=\"C#\" Debug=\"true\" Service=\"System.ServiceModel.Routing.RoutingService,   \n     System.ServiceModel.Routing, version=4.0.0.0, Culture=neutral,   \n     PublicKeyToken=31bf3856ad364e35\" %>  \n```  \n  \n## Routing Service and Impersonation  \n The WCF Routing Service can be used with impersonation for both sending and receiving messages. All of the usual Windows constraints of impersonation apply. If you would have needed to set up service or account permissions to use impersonation when writing your own service, then you’ll have to do those same steps to use impersonation with the routing service. For more information, see [Delegation and Impersonation](delegation-and-impersonation-with-wcf.md).  \n  \n Impersonation with the routing service requires either the use of ASP.NET impersonation while in ASP.NET compatibility mode or the use of Windows credentials that have been configured to allow impersonation. For more information about ASP.NET compatibility mode, see [WCF Services and ASP.NET](wcf-services-and-aspnet.md).  \n  \n> [!WARNING]\n>  The WCF Routing Service does not support impersonation with basic authentication.  \n  \n To use ASP.NET impersonation with the routing service, enable ASP.NET compatibility mode on the service hosting environment. The routing service has already been marked as allowing ASP.NET compatibility mode and impersonation will automatically be enabled. Impersonation is the only supported use of ASP.NET integration with the routing service.  \n  \n To use Windows credential impersonation with the routing service you need to configure both the credentials and the service. The client credentials object (<xref:System.ServiceModel.Security.WindowsClientCredential>, accessable from the <xref:System.ServiceModel.ChannelFactory>) defines an <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property that must be set to permit impersonation. Finally, on the service you need to configure the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior> behavior to set `ImpersonateCallerForAllOperations` to `true`. The routing service uses this flag to decide whether to create the clients for forwarding messages with impersonation enabled.  \n  \n## See also\n\n- [Message Filters](message-filters.md)\n- [Routing Contracts](routing-contracts.md)\n- [Choosing a Filter](choosing-a-filter.md)\n","nodes":[{"pos":[4,104],"embed":true,"restype":"x-metadata","content":"title: \"Routing Introduction\"\nms.date: \"03/30/2017\"\nms.assetid: bf6ceb38-6622-433b-9ee7-f79bc93497a1","nodes":[{"content":"Routing Introduction","nodes":[{"pos":[0,20],"content":"Routing Introduction","nodes":[{"content":"Routing Introduction","pos":[0,20]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[111,131],"content":"Routing Introduction","linkify":"Routing Introduction","nodes":[{"content":"Routing Introduction","pos":[0,20]}]},{"content":"The Routing Service provides a generic pluggable SOAP intermediary that is capable of routing messages based on message content.","pos":[132,260]},{"content":"With the Routing Service, you can create complex routing logic that allows you to implement scenarios such as service aggregation, service versioning, priority routing, and multicast routing.","pos":[261,452]},{"content":"The Routing Service also provides error handling that allows you to set up lists of backup endpoints, to which messages are sent if a failure occurs when sending to the primary destination endpoint.","pos":[453,651]},{"content":"This topic is intended for those new to the Routing Service and covers basic configuration and hosting of the Routing Service.","pos":[658,784]},{"pos":[793,806],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"content":"The Routing Service is implemented as a WCF service that exposes one or more service endpoints that receive messages from client applications and route the messages to one or more destination endpoints.","pos":[810,1012]},{"content":"The service provides a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingBehavior&gt;</ph>, which is applied to the service endpoints exposed by the service.","pos":[1013,1153],"source":" The service provides a <xref:System.ServiceModel.Routing.RoutingBehavior>, which is applied to the service endpoints exposed by the service."},{"content":"This behavior is used to configure various aspects of how the service operates.","pos":[1154,1233]},{"content":"For ease of configuration when using a configuration file, the parameters are specified on the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept>.","pos":[1234,1349],"source":" For ease of configuration when using a configuration file, the parameters are specified on the **RoutingBehavior**."},{"content":"In code-based scenarios, these parameters would be specified as part of a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingConfiguration&gt;</ph> object, which can then be passed to a <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept>.","pos":[1350,1538],"source":" In code-based scenarios, these parameters would be specified as part of a <xref:System.ServiceModel.Routing.RoutingConfiguration> object, which can then be passed to a **RoutingBehavior**."},{"content":"When starting, this behavior adds the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.SoapProcessingBehavior&gt;</ph>, which is used to perform SOAP processing of messages, to the client endpoints.","pos":[1545,1720],"source":"When starting, this behavior adds the <xref:System.ServiceModel.Routing.SoapProcessingBehavior>, which is used to perform SOAP processing of messages, to the client endpoints."},{"content":"This allows the Routing Service to transmit messages to endpoints that require a different <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept> than the endpoint the message was received over.","pos":[1721,1879],"source":" This allows the Routing Service to transmit messages to endpoints that require a different **MessageVersion** than the endpoint the message was received over."},{"content":"The <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> also registers a service extension, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingExtension&gt;</ph>, which provides an accessibility point for modifying the Routing Service configuration at run time.","pos":[1880,2095],"source":" The **RoutingBehavior** also registers a service extension, the <xref:System.ServiceModel.Routing.RoutingExtension>, which provides an accessibility point for modifying the Routing Service configuration at run time."},{"content":"The <bpt id=\"p1\">**</bpt>RoutingConfiguration<ept id=\"p1\">**</ept> class provides a consistent means of configuring and updating the configuration of the Routing Service.","pos":[2102,2234],"source":"The **RoutingConfiguration** class provides a consistent means of configuring and updating the configuration of the Routing Service."},{"content":"It contains parameters that act as the settings for the Routing Service and is used to configure the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> when the service starts, or is passed to the <bpt id=\"p2\">**</bpt>RoutingExtension<ept id=\"p2\">**</ept> to modify routing configuration at run time.","pos":[2236,2467],"source":"  It contains parameters that act as the settings for the Routing Service and is used to configure the **RoutingBehavior** when the service starts, or is passed to the **RoutingExtension** to modify routing configuration at run time."},{"content":"The routing logic used to perform content-based routing of messages is defined by grouping multiple <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph> objects together into filter tables (<ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.MessageFilterTable%601&gt;</ph> objects).","pos":[2474,2733],"source":"The routing logic used to perform content-based routing of messages is defined by grouping multiple <xref:System.ServiceModel.Dispatcher.MessageFilter> objects together into filter tables (<xref:System.ServiceModel.Dispatcher.MessageFilterTable%601> objects)."},{"content":"Incoming messages are evaluated against the message filters contained in the filter table, and for each <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> that matches the message, forwarded to a destination endpoint.","pos":[2734,2918],"source":" Incoming messages are evaluated against the message filters contained in the filter table, and for each **MessageFilter** that matches the message, forwarded to a destination endpoint."},{"content":"The filter table that should be used to route messages is specified by using either the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> in configuration or through code by using the <bpt id=\"p2\">**</bpt>RoutingConfiguration<ept id=\"p2\">**</ept> object.","pos":[2919,3105],"source":" The filter table that should be used to route messages is specified by using either the **RoutingBehavior** in configuration or through code by using the **RoutingConfiguration** object."},{"pos":[3115,3133],"content":"Defining Endpoints","linkify":"Defining Endpoints","nodes":[{"content":"Defining Endpoints","pos":[0,18]}]},{"content":"While it may seem that you should start your configuration by defining the routing logic you will use, your first step should actually be to determine the shape of the endpoints you will be routing messages to.","pos":[3137,3347]},{"content":"The Routing Service uses contracts that define the shape of the channels used to receive and send messages, and therefore the shape of the input channel must match that of the output channel.","pos":[3348,3539]},{"content":"For example, if you are routing to endpoints that use the request-reply channel shape, then you must use a compatible contract on the inbound endpoints, such as the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.IRequestReplyRouter&gt;</ph>.","pos":[3541,3761],"source":"  For example, if you are routing to endpoints that use the request-reply channel shape, then you must use a compatible contract on the inbound endpoints, such as the <xref:System.ServiceModel.Routing.IRequestReplyRouter>."},{"content":"This means that if your destination endpoints use contracts with multiple communication patterns (such as mixing one-way and two-way operations,) you cannot create a single service endpoint that can receive and route messages to all of them.","pos":[3768,4009]},{"content":"You must determine which endpoints have compatible shapes and define one or more service endpoints that will be used to receive messages to be routed to the destination endpoints.","pos":[4010,4189]},{"pos":[4197,4721],"content":"[!NOTE]\nWhen working with contracts that specify multiple communication patterns (such as a mix of one-way and two-way operations,) a workaround is to use a duplex contract at the Routing Service such as <xref:System.ServiceModel.Routing.IDuplexSessionRouter>. However this means that the binding must be capable of duplex communication, which may not be possible for all scenarios. In scenarios where this is not possible, factoring the communication into multiple endpoints or modifying the application may be necessary.","leadings":["","> "],"nodes":[{"content":"When working with contracts that specify multiple communication patterns (such as a mix of one-way and two-way operations,) a workaround is to use a duplex contract at the Routing Service such as <xref:System.ServiceModel.Routing.IDuplexSessionRouter>. However this means that the binding must be capable of duplex communication, which may not be possible for all scenarios. In scenarios where this is not possible, factoring the communication into multiple endpoints or modifying the application may be necessary.","pos":[8,522],"nodes":[{"content":"When working with contracts that specify multiple communication patterns (such as a mix of one-way and two-way operations,) a workaround is to use a duplex contract at the Routing Service such as <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.IDuplexSessionRouter&gt;</ph>.","pos":[0,252],"source":"When working with contracts that specify multiple communication patterns (such as a mix of one-way and two-way operations,) a workaround is to use a duplex contract at the Routing Service such as <xref:System.ServiceModel.Routing.IDuplexSessionRouter>."},{"content":"However this means that the binding must be capable of duplex communication, which may not be possible for all scenarios.","pos":[253,374]},{"content":"In scenarios where this is not possible, factoring the communication into multiple endpoints or modifying the application may be necessary.","pos":[375,514]}]}]},{"pos":[4728,4820],"content":"For more information about routing contracts, see <bpt id=\"p1\">[</bpt>Routing Contracts<ept id=\"p1\">](routing-contracts.md)</ept>.","source":"For more information about routing contracts, see [Routing Contracts](routing-contracts.md)."},{"content":"After the service endpoint is defined, you can use the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> to associate a specific <bpt id=\"p2\">**</bpt>RoutingConfiguration<ept id=\"p2\">**</ept> with the endpoint.","pos":[4827,4969],"source":"After the service endpoint is defined, you can use the **RoutingBehavior** to associate a specific **RoutingConfiguration** with the endpoint."},{"content":"When configuring the Routing Service by using a configuration file, the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> is used to specify the filter table that contains the routing logic used to process messages received on this endpoint.","pos":[4970,5181],"source":" When configuring the Routing Service by using a configuration file, the **RoutingBehavior** is used to specify the filter table that contains the routing logic used to process messages received on this endpoint."},{"content":"If you are configuring the Routing Service programmatically you can specify the filter table by using the <bpt id=\"p1\">**</bpt>RoutingConfiguration<ept id=\"p1\">**</ept>.","pos":[5182,5313],"source":" If you are configuring the Routing Service programmatically you can specify the filter table by using the **RoutingConfiguration**."},{"content":"The following example defines the service and client endpoints that are used by the Routing Service both programmatically and by using a configuration file.","pos":[5320,5476]},{"content":"This example configures the Routing Service to expose a single endpoint with an address of <ph id=\"ph1\">`http://localhost:8000/routingservice/router`</ph>, which is used to receive messages to be routed.","pos":[7838,8023],"source":"This example configures the Routing Service to expose a single endpoint with an address of `http://localhost:8000/routingservice/router`, which is used to receive messages to be routed."},{"content":"Because the messages are routed to request-reply endpoints, the service endpoint uses the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.IRequestReplyRouter&gt;</ph> contract.","pos":[8024,8178],"source":" Because the messages are routed to request-reply endpoints, the service endpoint uses the <xref:System.ServiceModel.Routing.IRequestReplyRouter> contract."},{"content":"This configuration also defines a single client endpoint of <ph id=\"ph1\">`http://localhost:8000/servicemodelsample/service`</ph> that messages are routed to.","pos":[8179,8318],"source":" This configuration also defines a single client endpoint of `http://localhost:8000/servicemodelsample/service` that messages are routed to."},{"content":"The filter table (not shown) named \"routingTable1\" contains the routing logic used to route messages, and is associated with the service endpoint by using the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> (for a configuration file) or <bpt id=\"p2\">**</bpt>RoutingConfiguration<ept id=\"p2\">**</ept> (for programmatic configuration).","pos":[8319,8586],"source":" The filter table (not shown) named \"routingTable1\" contains the routing logic used to route messages, and is associated with the service endpoint by using the **RoutingBehavior** (for a configuration file) or **RoutingConfiguration** (for programmatic configuration)."},{"pos":[8596,8609],"content":"Routing Logic","linkify":"Routing Logic","nodes":[{"content":"Routing Logic","pos":[0,13]}]},{"content":"To define the routing logic used to route messages, you must determine what data contained within the incoming messages can be uniquely acted upon.","pos":[8613,8760]},{"content":"For example, if all the destination endpoints you are routing to share the same SOAP Actions, the value of the Action contained within the message is not a good indicator of which specific endpoint the message should be routed to.","pos":[8761,8991]},{"content":"If you must uniquely route messages to one specific endpoint, you should filter upon data that uniquely identifies the destination endpoint that the message is routed to.","pos":[8992,9162]},{"content":"The Routing Service provides several <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> implementations that inspect specific values within the message, such as the address, action, endpoint name, or even an XPath query.","pos":[9169,9356],"source":"The Routing Service provides several **MessageFilter** implementations that inspect specific values within the message, such as the address, action, endpoint name, or even an XPath query."},{"content":"If none of these implementations meet your needs you can create a custom <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> implementation.","pos":[9357,9463],"source":" If none of these implementations meet your needs you can create a custom **MessageFilter** implementation."},{"content":"For more information about message filters and a comparison of the implementations used by the Routing Service, see <bpt id=\"p1\">[</bpt>Message Filters<ept id=\"p1\">](message-filters.md)</ept> and <bpt id=\"p2\">[</bpt>Choosing a Filter<ept id=\"p2\">](choosing-a-filter.md)</ept>.","pos":[9464,9664],"source":" For more information about message filters and a comparison of the implementations used by the Routing Service, see [Message Filters](message-filters.md) and [Choosing a Filter](choosing-a-filter.md)."},{"content":"Multiple message filters are organized together into filter tables, which associate each <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> with a destination endpoint.","pos":[9671,9806],"source":"Multiple message filters are organized together into filter tables, which associate each **MessageFilter** with a destination endpoint."},{"content":"Optionally, the filter table can also be used to specify a list of back-up endpoints that the Routing Service will attempt to send the message to in the event of a transmission failure.","pos":[9807,9992]},{"content":"By default all message filters within a filter table are evaluated simultaneously; however, you can specify a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.Configuration.FilterTableEntryElement.Priority%2A&gt;</ph> that causes the message filters to be evaluated in a specific order.","pos":[9999,10262],"source":"By default all message filters within a filter table are evaluated simultaneously; however, you can specify a <xref:System.ServiceModel.Routing.Configuration.FilterTableEntryElement.Priority%2A> that causes the message filters to be evaluated in a specific order."},{"content":"All entries with the highest priority are evaluated first, and message filters of lower priorities are not evaluated if a match is found at a higher priority level.","pos":[10263,10427]},{"content":"For more information about filter tables, see <bpt id=\"p1\">[</bpt>Message Filters<ept id=\"p1\">](message-filters.md)</ept>.","pos":[10428,10512],"source":" For more information about filter tables, see [Message Filters](message-filters.md)."},{"content":"The following examples use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter&gt;</ph>, which evaluates to <ph id=\"ph2\">`true`</ph> for all messages.","pos":[10519,10654],"source":"The following examples use the <xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter>, which evaluates to `true` for all messages."},{"content":"This <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> is added to the \"routingTable1\" filter table, which associates the <bpt id=\"p2\">**</bpt>MessageFilter<ept id=\"p2\">**</ept> with the client endpoint named \"CalculatorService\".","pos":[10655,10814],"source":" This **MessageFilter** is added to the \"routingTable1\" filter table, which associates the **MessageFilter** with the client endpoint named \"CalculatorService\"."},{"content":"The <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> then specifies that this table should be used to route messages processed by the service endpoint.","pos":[10815,10937],"source":" The **RoutingBehavior** then specifies that this table should be used to route messages processed by the service endpoint."},{"pos":[12199,12436],"content":"[!NOTE]\n By default, the Routing Service only evaluates the headers of the message. To allow the filters to access the message body, you must set <xref:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly%2A> to `false`.","leadings":["","> "],"nodes":[{"content":"By default, the Routing Service only evaluates the headers of the message. To allow the filters to access the message body, you must set <xref:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly%2A> to `false`.","pos":[9,235],"nodes":[{"content":"By default, the Routing Service only evaluates the headers of the message.","pos":[0,74]},{"content":"To allow the filters to access the message body, you must set <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly%2A&gt;</ph> to <ph id=\"ph2\">`false`</ph>.","pos":[75,226],"source":" To allow the filters to access the message body, you must set <xref:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly%2A> to `false`."}]}]},{"pos":[12443,12456],"content":"<bpt id=\"p1\">**</bpt>Multicast<ept id=\"p1\">**</ept>","source":"**Multicast**"},{"content":"While many Routing Service configurations use exclusive filter logic that routes messages to only one specific endpoint, you may need to route a given message to multiple destination endpoints.","pos":[12463,12656]},{"content":"To multicast a message to multiple destinations, the following conditions must be true:","pos":[12657,12744]},{"content":"The channel shape must not be request-reply (though may be one-way or duplex,) because only one reply can be received by the client application in response to the request.","pos":[12754,12925]},{"pos":[12935,12999],"content":"Multiple filters must return <ph id=\"ph1\">`true`</ph> when evaluating the message.","source":"Multiple filters must return `true` when evaluating the message."},{"content":"If these conditions are met, the message is routed to all endpoints of all filters that evaluate to <ph id=\"ph1\">`true`</ph>.","pos":[13006,13113],"source":"If these conditions are met, the message is routed to all endpoints of all filters that evaluate to `true`."},{"content":"The following example defines a routing configuration that results in messages being routed to both endpoints if the endpoint address in the message is <ph id=\"ph1\">`http://localhost:8000/routingservice/router/rounding`</ph>.","pos":[13114,13321],"source":" The following example defines a routing configuration that results in messages being routed to both endpoints if the endpoint address in the message is `http://localhost:8000/routingservice/router/rounding`."},{"pos":[14196,14211],"content":"SOAP Processing","linkify":"SOAP Processing","nodes":[{"content":"SOAP Processing","pos":[0,15]}]},{"content":"To support the routing of messages between dissimilar protocols, the <bpt id=\"p1\">**</bpt>RoutingBehavior<ept id=\"p1\">**</ept> by default adds the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.SoapProcessingBehavior&gt;</ph> to all client endpoint(s) that messages are routed to.","pos":[14215,14436],"source":"To support the routing of messages between dissimilar protocols, the **RoutingBehavior** by default adds the <xref:System.ServiceModel.Routing.SoapProcessingBehavior> to all client endpoint(s) that messages are routed to."},{"content":"This behavior automatically creates a new <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept> before routing the message to the endpoint, as well as creating a compatible <bpt id=\"p2\">**</bpt>MessageVersion<ept id=\"p2\">**</ept> for any response document before returning it to the requesting client application.","pos":[14437,14677],"source":" This behavior automatically creates a new **MessageVersion** before routing the message to the endpoint, as well as creating a compatible **MessageVersion** for any response document before returning it to the requesting client application."},{"pos":[14684,14775],"content":"The steps taken to create a new <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept> for the outbound message are as follows:","source":"The steps taken to create a new **MessageVersion** for the outbound message are as follows:"},{"pos":[14782,14804],"content":"<bpt id=\"p1\">**</bpt>Request processing<ept id=\"p1\">**</ept>","source":"**Request processing**"},{"pos":[14814,14873],"content":"Get the <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept> of the outbound binding/channel.","source":"Get the **MessageVersion** of the outbound binding/channel."},{"content":"Get the body reader for the original message.","pos":[14883,14928]},{"pos":[14938,15023],"content":"Create a new message with the same action, body reader, and a new <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept>.","source":"Create a new message with the same action, body reader, and a new **MessageVersion**."},{"pos":[15033,15194],"content":"If <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageVersion.Addressing%2A&gt;</ph> != <bpt id=\"p1\">**</bpt>Addressing.None<ept id=\"p1\">**</ept>, copy the To, From, FaultTo, and RelatesTo headers to the new message.","source":"If <xref:System.ServiceModel.Channels.MessageVersion.Addressing%2A> != **Addressing.None**, copy the To, From, FaultTo, and RelatesTo headers to the new message."},{"content":"Copy all message properties to the new message.","pos":[15204,15251]},{"content":"Store the original request message to use when processing the response.","pos":[15261,15332]},{"content":"Return the new request message.","pos":[15342,15373]},{"pos":[15380,15403],"content":"<bpt id=\"p1\">**</bpt>Response processing<ept id=\"p1\">**</ept>","source":"**Response processing**"},{"pos":[15413,15472],"content":"Get the <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept> of the original request message.","source":"Get the **MessageVersion** of the original request message."},{"content":"Get the body reader for the received response message.","pos":[15482,15536]},{"pos":[15546,15670],"content":"Create a new response message with the same action, body reader, and the <bpt id=\"p1\">**</bpt>MessageVersion<ept id=\"p1\">**</ept> of the original request message.","source":"Create a new response message with the same action, body reader, and the **MessageVersion** of the original request message."},{"pos":[15680,15841],"content":"If <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageVersion.Addressing%2A&gt;</ph> != <bpt id=\"p1\">**</bpt>Addressing.None<ept id=\"p1\">**</ept>, copy the To, From, FaultTo, and RelatesTo headers to the new message.","source":"If <xref:System.ServiceModel.Channels.MessageVersion.Addressing%2A> != **Addressing.None**, copy the To, From, FaultTo, and RelatesTo headers to the new message."},{"content":"Copy the message properties to the new message.","pos":[15851,15898]},{"content":"Return the new response message.","pos":[15908,15940]},{"content":"By default, the <bpt id=\"p1\">**</bpt>SoapProcessingBehavior<ept id=\"p1\">**</ept> is automatically added to the client endpoints by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingBehavior&gt;</ph> when the service starts; however, you can control whether SOAP processing is added to all client endpoints by using the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled%2A&gt;</ph> property.","pos":[15947,16305],"source":"By default, the **SoapProcessingBehavior** is automatically added to the client endpoints by the <xref:System.ServiceModel.Routing.RoutingBehavior> when the service starts; however, you can control whether SOAP processing is added to all client endpoints by using the <xref:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled%2A> property."},{"content":"You can also add the behavior directly to a specific endpoint and enable or disable this behavior at the endpoint level if a more granular control of SOAP processing is required.","pos":[16306,16484]},{"pos":[16492,16781],"content":"[!NOTE]\n If SOAP processing is disabled for an endpoint that requires a different MessageVersion than that of the original request message, you must provide a custom mechanism for performing any SOAP modifications that are required before sending the message to the destination endpoint.","leadings":["","> "],"nodes":[{"content":"If SOAP processing is disabled for an endpoint that requires a different MessageVersion than that of the original request message, you must provide a custom mechanism for performing any SOAP modifications that are required before sending the message to the destination endpoint.","pos":[9,287]}]},{"pos":[16788,16959],"content":"In the following examples, the <bpt id=\"p1\">**</bpt>soapProcessingEnabled<ept id=\"p1\">**</ept> property is used to prevent the <bpt id=\"p2\">**</bpt>SoapProcessingBehavior<ept id=\"p2\">**</ept> from being automatically added to all client endpoints.","source":"In the following examples, the **soapProcessingEnabled** property is used to prevent the **SoapProcessingBehavior** from being automatically added to all client endpoints."},{"pos":[17418,17439],"content":"Dynamic Configuration","linkify":"Dynamic Configuration","nodes":[{"content":"Dynamic Configuration","pos":[0,21]}]},{"content":"When you add additional client endpoints, or need to modify the filters that are used to route messages, you must have a way to update the configuration dynamically at run time to prevent interrupting the service to the endpoints currently receiving messages through the Routing Service.","pos":[17443,17730]},{"content":"Modifying a configuration file or the code of the host application is not always sufficient, because either method requires recycling the application, which would lead to the potential loss of any messages currently in transit and the potential for downtime while waiting on the service to restart.","pos":[17731,18029]},{"content":"You can only modify the <bpt id=\"p1\">**</bpt>RoutingConfiguration<ept id=\"p1\">**</ept> programmatically.","pos":[18036,18102],"source":"You can only modify the **RoutingConfiguration** programmatically."},{"content":"While you can initially configure the service by using a configuration file, you can only modify the configuration at run time by constructing a new <bpt id=\"p1\">**</bpt>RoutingConfigution<ept id=\"p1\">**</ept> and passing it as a parameter to the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingExtension.ApplyConfiguration%2A&gt;</ph> method exposed by the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Routing.RoutingExtension&gt;</ph> service extension.","pos":[18103,18478],"source":" While you can initially configure the service by using a configuration file, you can only modify the configuration at run time by constructing a new **RoutingConfigution** and passing it as a parameter to the <xref:System.ServiceModel.Routing.RoutingExtension.ApplyConfiguration%2A> method exposed by the <xref:System.ServiceModel.Routing.RoutingExtension> service extension."},{"content":"Any messages currently in transit continue to be routed using the previous configuration, while messages received after the call to <bpt id=\"p1\">**</bpt>ApplyConfiguration<ept id=\"p1\">**</ept> use the new configuration.","pos":[18479,18660],"source":" Any messages currently in transit continue to be routed using the previous configuration, while messages received after the call to **ApplyConfiguration** use the new configuration."},{"content":"The following example demonstrates creating an instance of the Routing Service and then subsequently modifying the configuration.","pos":[18661,18790]},{"pos":[19820,20136],"content":"[!NOTE]\n When updating the Routing Service in this manner it is only possible to pass a new configuration. It is not possible to modify only select elements of the current configuration or append new entries to the current configuration; you must create and pass a new configuration that replaces the existing one.","leadings":["","> "],"nodes":[{"content":"When updating the Routing Service in this manner it is only possible to pass a new configuration. It is not possible to modify only select elements of the current configuration or append new entries to the current configuration; you must create and pass a new configuration that replaces the existing one.","pos":[9,314],"nodes":[{"content":"When updating the Routing Service in this manner it is only possible to pass a new configuration.","pos":[0,97]},{"content":"It is not possible to modify only select elements of the current configuration or append new entries to the current configuration; you must create and pass a new configuration that replaces the existing one.","pos":[98,305]}]}]},{"pos":[20144,20302],"content":"[!NOTE]\n Any sessions opened using the previous configuration continue using the previous configuration. The new configuration is only used by new sessions.","leadings":["","> "],"nodes":[{"content":"Any sessions opened using the previous configuration continue using the previous configuration. The new configuration is only used by new sessions.","pos":[9,156],"nodes":[{"content":"Any sessions opened using the previous configuration continue using the previous configuration.","pos":[0,95]},{"content":"The new configuration is only used by new sessions.","pos":[96,147]}]}]},{"pos":[20311,20325],"content":"Error Handling","linkify":"Error Handling","nodes":[{"content":"Error Handling","pos":[0,14]}]},{"content":"If any <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph> is encountered while attempting to send a message, error handling take place.","pos":[20329,20463],"source":"If any <xref:System.ServiceModel.CommunicationException> is encountered while attempting to send a message, error handling take place."},{"content":"These exceptions typically indicate that a problem was encountered while attempting to communicate with the defined client endpoint, such as an <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointNotFoundException&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServerTooBusyException&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.ServiceModel.CommunicationObjectFaultedException&gt;</ph>.","pos":[20464,20779],"source":" These exceptions typically indicate that a problem was encountered while attempting to communicate with the defined client endpoint, such as an <xref:System.ServiceModel.EndpointNotFoundException>, <xref:System.ServiceModel.ServerTooBusyException>, or <xref:System.ServiceModel.CommunicationObjectFaultedException>."},{"content":"The error handling-code will also catch and attempt to retry sending when a <ph id=\"ph1\">&lt;xref:System.TimeoutException&gt;</ph> occurs, which is another common exception that is not derived from <bpt id=\"p1\">**</bpt>CommunicationException<ept id=\"p1\">**</ept>.","pos":[20780,20981],"source":" The error handling-code will also catch and attempt to retry sending when a <xref:System.TimeoutException> occurs, which is another common exception that is not derived from **CommunicationException**."},{"content":"When one of the preceding exceptions occurs, the Routing Service fails over to a list of backup endpoints.","pos":[20988,21094]},{"content":"If all backup endpoints fail with a communications failure, or if an endpoint returns an exception that indicates a failure within the destination service, the Routing Service returns a fault to the client application.","pos":[21095,21313]},{"pos":[21321,21766],"content":"[!NOTE]\n The error-handling functionality captures and handles exceptions that occur when attempting to send a message and when attempting to close a channel. The error-handling code is not intended to detect or handle exceptions created by the application endpoints it is communicating with; a <xref:System.ServiceModel.FaultException> thrown by a service appears at the Routing Service as a **FaultMessage** and is flowed back to the client.","leadings":["","> "],"nodes":[{"content":"The error-handling functionality captures and handles exceptions that occur when attempting to send a message and when attempting to close a channel. The error-handling code is not intended to detect or handle exceptions created by the application endpoints it is communicating with; a <xref:System.ServiceModel.FaultException> thrown by a service appears at the Routing Service as a **FaultMessage** and is flowed back to the client.","pos":[9,443],"nodes":[{"content":"The error-handling functionality captures and handles exceptions that occur when attempting to send a message and when attempting to close a channel.","pos":[0,149]},{"content":"The error-handling code is not intended to detect or handle exceptions created by the application endpoints it is communicating with; a <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException&gt;</ph> thrown by a service appears at the Routing Service as a <bpt id=\"p1\">**</bpt>FaultMessage<ept id=\"p1\">**</ept> and is flowed back to the client.","pos":[150,434],"source":" The error-handling code is not intended to detect or handle exceptions created by the application endpoints it is communicating with; a <xref:System.ServiceModel.FaultException> thrown by a service appears at the Routing Service as a **FaultMessage** and is flowed back to the client."}]}]},{"content":"If an error occurs when the routing service tries to relay a message, you may  get a <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException&gt;</ph> on the client side, rather than a <ph id=\"ph2\">&lt;xref:System.ServiceModel.EndpointNotFoundException&gt;</ph> you would normally get in the absence of the routing service.","pos":[21777,22052],"source":"If an error occurs when the routing service tries to relay a message, you may  get a <xref:System.ServiceModel.FaultException> on the client side, rather than a <xref:System.ServiceModel.EndpointNotFoundException> you would normally get in the absence of the routing service."},{"content":"A routing service may thus mask exceptions and not provide full transparency unless you examine nested exceptions.","pos":[22053,22167]},{"pos":[22177,22195],"content":"Tracing Exceptions","linkify":"Tracing Exceptions","nodes":[{"content":"Tracing Exceptions","pos":[0,18]}]},{"content":"When sending a message to an endpoint in a list fails, the Routing Service traces the resulting exception data and attaches the exception details as a message property named <bpt id=\"p1\">**</bpt>Exceptions<ept id=\"p1\">**</ept>.","pos":[22199,22388],"source":"When sending a message to an endpoint in a list fails, the Routing Service traces the resulting exception data and attaches the exception details as a message property named **Exceptions**."},{"content":"This preserves the exception data and allows a user programmatic access through a message inspector.","pos":[22389,22489]},{"content":"The exception data is stored per message in a dictionary that maps the endpoint name to the exception details encountered when trying to send a message to it.","pos":[22491,22649]},{"pos":[22659,22675],"content":"Backup Endpoints","linkify":"Backup Endpoints","nodes":[{"content":"Backup Endpoints","pos":[0,16]}]},{"content":"Each filter entry within the filter table can optionally specify a list of backup endpoints, which are used in the event of a transmission failure when sending to the primary endpoint.","pos":[22679,22863]},{"content":"If such a failure occurs, the Routing Service attempts to transmit the message to the first entry in the backup endpoint list.","pos":[22864,22990]},{"content":"If this send attempt also encounters a transmission failure, the next endpoint in the backup list is tried.","pos":[22991,23098]},{"content":"The Routing Service continues sending the message to each endpoint in the list until the message is successfully received, all endpoints return a transmission failure, or a non-transmission failure is returned by an endpoint.","pos":[23099,23324]},{"content":"The following examples configure the Routing Service to use a backup list.","pos":[23331,23405]},{"pos":[25991,26015],"content":"Supported Error Patterns","linkify":"Supported Error Patterns","nodes":[{"content":"Supported Error Patterns","pos":[0,24]}]},{"content":"The following table describes the patterns that are compatible with the use of backup endpoint lists, along with notes describing the details of error handling for specific patterns.","pos":[26019,26201]},{"content":"Pattern","pos":[26208,26215]},{"content":"Session","pos":[26216,26223]},{"content":"Transaction","pos":[26224,26235]},{"content":"Receive Context","pos":[26236,26251]},{"content":"Backup List Supported","pos":[26252,26273]},{"content":"Notes","pos":[26274,26279]},{"content":"One-Way","pos":[26396,26403]},{"content":"Yes","pos":[26407,26410]},{"content":"Attempts to resend the message on a backup endpoint.","pos":[26411,26463]},{"content":"If this message is being multicast, only the message on the failed channel is moved to its backup destination.","pos":[26464,26574]},{"content":"One-Way","pos":[26579,26586]},{"content":"✓","pos":[26588,26589]},{"content":"No","pos":[26591,26593]},{"content":"An exception is thrown and the transaction is rolled back.","pos":[26594,26652]},{"content":"One-Way","pos":[26657,26664]},{"content":"✓","pos":[26667,26668]},{"content":"Yes","pos":[26669,26672]},{"content":"Attempts to resend the message on a backup endpoint.","pos":[26673,26725]},{"content":"After the message is successfully received, complete all receive contexts.","pos":[26726,26800]},{"content":"If the message is not successfully received by any endpoint, do not complete the receive context.","pos":[26801,26898]},{"content":"When this message is being multicast, the receive context is only completed if the message is successfully received by at least one endpoint (primary or backup).","pos":[26911,27072]},{"content":"If none of the endpoints in any of the multicast paths successfully receive the message, do not complete the receive context.","pos":[27073,27198]},{"content":"One-Way","pos":[27203,27210]},{"content":"✓","pos":[27212,27213]},{"content":"✓","pos":[27214,27215]},{"content":"Yes","pos":[27216,27219]},{"content":"Abort the previous transaction, create a new transaction, and resend all messages.","pos":[27220,27302]},{"content":"Messages that encountered an error are transmitted to a backup destination.","pos":[27303,27378]},{"content":"After a transaction has been created in which all transmissions succeed, complete the receive contexts and commit the transaction.","pos":[27391,27521]},{"content":"One-Way","pos":[27526,27533]},{"content":"✓","pos":[27534,27535]},{"content":"Yes","pos":[27538,27541]},{"content":"Attempts to resend the message on a backup endpoint.","pos":[27542,27594]},{"content":"In a multicast scenario only the messages in a session that encountered an error or in a session whose session close failed are resent to backup destinations.","pos":[27595,27753]},{"content":"One-Way","pos":[27758,27765]},{"content":"✓","pos":[27766,27767]},{"content":"✓","pos":[27768,27769]},{"content":"No","pos":[27771,27773]},{"content":"An exception is thrown and the transaction is rolled back.","pos":[27774,27832]},{"content":"One-Way","pos":[27837,27844]},{"content":"✓","pos":[27845,27846]},{"content":"✓","pos":[27848,27849]},{"content":"Yes","pos":[27850,27853]},{"content":"Attempts to resend the message on a backup endpoint.","pos":[27854,27906]},{"content":"After all message sends complete without error, the session indicates no more messages and the Routing Service successfully closes all outbound session channel(s), all receive contexts are completed, and the inbound session channel is closed.","pos":[27907,28149]},{"content":"One-Way","pos":[28154,28161]},{"content":"✓","pos":[28162,28163]},{"content":"✓","pos":[28164,28165]},{"content":"✓","pos":[28166,28167]},{"content":"Yes","pos":[28168,28171]},{"content":"Abort the current transaction and create a new one.","pos":[28172,28223]},{"content":"Resend all previous messages in the session.","pos":[28224,28268]},{"content":"After a transaction has been created in which all messages have been successfully sent and the session indicates no more messages, all the outbound session channels are closed, receive contexts are all completed with the transaction, the inbound session channel is closed, and the transaction is committed.","pos":[28269,28575]},{"content":"When the sessions are being multicast the messages that had no error are resent to the same destination as before, and messages that encountered an error are sent to backup destinations.","pos":[28588,28774]},{"content":"Two-Way","pos":[28779,28786]},{"content":"Yes","pos":[28790,28793]},{"content":"Send to a backup destination.","pos":[28794,28823]},{"content":"After a channel returns a response message, return the response to the original client.","pos":[28825,28912]},{"content":"Two-Way","pos":[28917,28924]},{"content":"✓","pos":[28925,28926]},{"content":"Yes","pos":[28929,28932]},{"content":"Send all messages on the channel to a backup destination.","pos":[28933,28990]},{"content":"After a channel returns a response message, return the response to the original client.","pos":[28992,29079]},{"content":"Two-Way","pos":[29084,29091]},{"content":"✓","pos":[29093,29094]},{"content":"No","pos":[29096,29098]},{"content":"An exception is thrown and the transaction is rolled back.","pos":[29099,29157]},{"content":"Two-Way","pos":[29162,29169]},{"content":"✓","pos":[29170,29171]},{"content":"✓","pos":[29172,29173]},{"content":"No","pos":[29175,29177]},{"content":"An exception is thrown and the transaction is rolled back.","pos":[29178,29236]},{"content":"Duplex","pos":[29241,29247]},{"content":"No","pos":[29251,29253]},{"content":"Non-session duplex communication is not currently supported.","pos":[29254,29314]},{"content":"Duplex","pos":[29319,29325]},{"content":"✓","pos":[29326,29327]},{"content":"Yes","pos":[29330,29333]},{"content":"Send to a backup destination.","pos":[29334,29363]},{"pos":[29373,29380],"content":"Hosting","linkify":"Hosting","nodes":[{"content":"Hosting","pos":[0,7]}]},{"content":"Because the Routing Service is implemented as a WCF service, it must be either self-hosted within an application or hosted by IIS or WAS.","pos":[29384,29521]},{"content":"It is recommended that the Routing Service be hosted in either IIS, WAS, or a Windows Service application to take advantage of the automatic start and life-cycle management features available in these hosting environments.","pos":[29522,29744]},{"content":"The following example demonstrates hosting the Routing Service in an application.","pos":[29751,29832]},{"content":"To host the Routing Service within IIS or WAS, you must either create a service file (.svc) or use configuration-based activation of the service.","pos":[29954,30099]},{"content":"When using a service file, you must specify the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Routing.RoutingService&gt;</ph> using the Service parameter.","pos":[30100,30226],"source":" When using a service file, you must specify the <xref:System.ServiceModel.Routing.RoutingService> using the Service parameter."},{"content":"The following example contains a sample service file that can be used to host the Routing Service with IIS or WAS.","pos":[30227,30341]},{"pos":[30578,30611],"content":"Routing Service and Impersonation","linkify":"Routing Service and Impersonation","nodes":[{"content":"Routing Service and Impersonation","pos":[0,33]}]},{"content":"The WCF Routing Service can be used with impersonation for both sending and receiving messages.","pos":[30615,30710]},{"content":"All of the usual Windows constraints of impersonation apply.","pos":[30711,30771]},{"content":"If you would have needed to set up service or account permissions to use impersonation when writing your own service, then you’ll have to do those same steps to use impersonation with the routing service.","pos":[30772,30976]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Delegation and Impersonation<ept id=\"p1\">](delegation-and-impersonation-with-wcf.md)</ept>.","pos":[30977,31076],"source":" For more information, see [Delegation and Impersonation](delegation-and-impersonation-with-wcf.md)."},{"content":"Impersonation with the routing service requires either the use of ASP.NET impersonation while in ASP.NET compatibility mode or the use of Windows credentials that have been configured to allow impersonation.","pos":[31083,31290]},{"content":"For more information about ASP.NET compatibility mode, see <bpt id=\"p1\">[</bpt>WCF Services and ASP.NET<ept id=\"p1\">](wcf-services-and-aspnet.md)</ept>.","pos":[31291,31405],"source":" For more information about ASP.NET compatibility mode, see [WCF Services and ASP.NET](wcf-services-and-aspnet.md)."},{"pos":[31413,31508],"content":"[!WARNING]\n The WCF Routing Service does not support impersonation with basic authentication.","leadings":["","> "],"nodes":[{"content":"The WCF Routing Service does not support impersonation with basic authentication.","pos":[12,93]}]},{"content":"To use ASP.NET impersonation with the routing service, enable ASP.NET compatibility mode on the service hosting environment.","pos":[31515,31639]},{"content":"The routing service has already been marked as allowing ASP.NET compatibility mode and impersonation will automatically be enabled.","pos":[31640,31771]},{"content":"Impersonation is the only supported use of ASP.NET integration with the routing service.","pos":[31772,31860]},{"content":"To use Windows credential impersonation with the routing service you need to configure both the credentials and the service.","pos":[31867,31991]},{"content":"The client credentials object (<ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.WindowsClientCredential&gt;</ph>, accessable from the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ChannelFactory&gt;</ph>) defines an <ph id=\"ph3\">&lt;xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A&gt;</ph> property that must be set to permit impersonation.","pos":[31992,32297],"source":" The client credentials object (<xref:System.ServiceModel.Security.WindowsClientCredential>, accessable from the <xref:System.ServiceModel.ChannelFactory>) defines an <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property that must be set to permit impersonation."},{"content":"Finally, on the service you need to configure the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.ServiceAuthorizationBehavior&gt;</ph> behavior to set <ph id=\"ph2\">`ImpersonateCallerForAllOperations`</ph> to <ph id=\"ph3\">`true`</ph>.","pos":[32298,32478],"source":" Finally, on the service you need to configure the <xref:System.ServiceModel.Description.ServiceAuthorizationBehavior> behavior to set `ImpersonateCallerForAllOperations` to `true`."},{"content":"The routing service uses this flag to decide whether to create the clients for forwarding messages with impersonation enabled.","pos":[32479,32605]},{"pos":[32614,32622],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[32626,32663],"content":"<bpt id=\"p1\">[</bpt>Message Filters<ept id=\"p1\">](message-filters.md)</ept>","source":"[Message Filters](message-filters.md)"},{"pos":[32666,32707],"content":"<bpt id=\"p1\">[</bpt>Routing Contracts<ept id=\"p1\">](routing-contracts.md)</ept>","source":"[Routing Contracts](routing-contracts.md)"},{"pos":[32710,32751],"content":"<bpt id=\"p1\">[</bpt>Choosing a Filter<ept id=\"p1\">](choosing-a-filter.md)</ept>","source":"[Choosing a Filter](choosing-a-filter.md)"}]}