<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="whats-new.md" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">18544a0311e24cf427111e364421db6e9fc27326</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\getting-started\whats-new.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a68faed29aa4761a9cf0e6cca7fc5edb2dd5fdec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e38a431e8bf1aecd247e168744c0740528b793c3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's new for Visual Basic | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>What's new for Visual Basic</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Current Version</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2017</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 2017<ept id="p1">](#visual-basic-2017)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Previous versions</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2015</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 14<ept id="p1">](#visual-basic-14)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2013</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Technology previews of the .NET Compiler Platform (“Roslyn”)</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2012</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Async`</ph> and <ph id="ph2">`await`</ph> keywords, iterators, caller info attributes</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Visual Basic, Visual Studio .NET 2010</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2008</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local <ph id="ph1">`var`</ph> type inference, lambda expressions, <ph id="ph2">`if`</ph> operator, partial methods, nullable value types</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2005</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`My`</ph> type and helper types (access to app, computer, files system, network)</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2003</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Bit-shift operators, loop variable declaration</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2002</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The first release of Visual Basic .NET</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Visual Basic 2017</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tuples<ept id="p1">](../programming-guide/language-features/data-types/tuples.md)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Ordinarily, to return multiple values from a method, you have to do one of the following:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Define a custom type (a <ph id="ph1">`Class`</ph> or a <ph id="ph2">`Structure`</ph>).</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This is a heavyweight solution.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Define one or more <ph id="ph1">`ByRef`</ph> parameters, in addition to returning a value from the method.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following example wraps a call to the <ph id="ph1">&lt;xref:System.Int32.TryParse%2A&gt;</ph> method and returns a tuple.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can then call the method and handle the returned tuple with code like the following.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Binary literals and digit separators<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can define a binary literal by using the prefix <ph id="ph1">`&amp;B`</ph> or <ph id="ph2">`&amp;b`</ph>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In addition, you can use the underscore character, <ph id="ph1">`_`</ph>, as a digit separator to enhance readability.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following example uses both features to assign a <ph id="ph1">`Byte`</ph> value and to display it as a decimal, hexadecimal, and binary number.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For more information, see the "Literal assignments" section of the <bpt id="p1">[</bpt>Byte<ept id="p1">](../language-reference/data-types/byte-data-type.md#literal-assignments)</ept>, <bpt id="p2">[</bpt>Integer<ept id="p2">](../language-reference/data-types/integer-data-type.md#literal-assignments)</ept>, <bpt id="p3">[</bpt>Long<ept id="p3">](../language-reference/data-types/long-data-type.md#literal-assignments)</ept>, <bpt id="p4">[</bpt>Short<ept id="p4">](../language-reference/data-types/short-data-type.md#literal-assignments)</ept>, <bpt id="p5">[</bpt>SByte<ept id="p5">](../language-reference/data-types/sbyte-data-type.md#literal-assignments)</ept>, <bpt id="p6">[</bpt>UInteger<ept id="p6">](../language-reference/data-types/uinteger-data-type.md#literal-assignments)</ept>, <bpt id="p7">[</bpt>ULong<ept id="p7">](../language-reference/data-types/ulong-data-type.md#literal-assignments)</ept>, and <bpt id="p8">[</bpt>UShort<ept id="p8">](../language-reference/data-types/ushort-data-type.md#literal-assignments)</ept> data types.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Support for C# reference return values<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Starting with C# 7, C# supports reference return values.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>That is, when the calling method receives a value returned by reference, it can change the value of the reference.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`Sentence`</ph> class written in C# includes a <ph id="ph2">`FindNext`</ph> method that finds the next word in a sentence that begins with a specified substring.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The string is returned as a reference return value, and a <ph id="ph1">`Boolean`</ph> variable passed by reference to the method indicates whether the search was successful.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the <ph id="ph1">`Sentence`</ph> class.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In its simplest form, you can modify the word found in the sentence by using code like the following.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A problem with this code, though, is that if a match is not found, the method returns the first word.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Since the example does not examine the value of the <ph id="ph1">`Boolean`</ph> argument to determine whether a match is found, it modifies the first word if there is no match.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following example corrects this by replacing the first word with itself if there is no match.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A better solution is to use a helper method to which the reference return value is passed by reference.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The helper method can then modify the argument passed to it by reference.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The following example does that.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Reference Return Values<ept id="p1">](../programming-guide/language-features/procedures/ref-return-values.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Visual Basic 14</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nameof<ept id="p1">](../../csharp/language-reference/keywords/nameof.md)</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This allows your code to remain correct when refactoring.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String Interpolation<ept id="p1">](../../csharp/language-reference/keywords/interpolated-strings.md)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can use string interpolation expressions to construct strings.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>An interpolated string expression looks like a template string that contains expressions.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>An interpolated string is easier to understand with respect to arguments than <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](../../standard/base-types/composite-format.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Null-conditional Member Access and Indexing<ept id="p1">](../../csharp/language-reference/operators/null-conditional-operators.md)</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can test for null in a very light syntactic way before performing a member access (<ph id="ph1">`?.`</ph>) or index (<ph id="ph2">`?[]`</ph>) operation.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>These operators help you write less code to handle null checks, especially for descending into data structures.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If the left operand or object reference is null, the operations returns null.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multi-line String Literals<ept id="p1">](../../visual-basic/programming-guide/language-features/strings/string-basics.md)</ept></source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>String literals can contain newline sequences.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You no longer need the old work around of using <ph id="ph1">`&lt;xml&gt;&lt;![CDATA[...text with newlines...]]&gt;&lt;/xml&gt;.Value`</ph></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Smarter Fully-qualified Name Resolution</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Given code such as <ph id="ph1">`Threading.Thread.Sleep(1000)`</ph>, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Visual Basic now considers both possible namespaces together.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Year-first Date Literals</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can have date literals in yyyy-mm-dd format, <ph id="ph1">`#2015-03-17 16:10 PM#`</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Readonly Interface Properties</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can implement readonly interface properties using a readwrite property.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>TypeOf <ph id="ph1">\&lt;</ph>expr&gt; IsNot <ph id="ph2">\&lt;</ph>type&gt;<ept id="p1">](../../visual-basic/language-reference/operators/typeof-operator.md)</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For more readability of your code, you can now use <ph id="ph1">`TypeOf`</ph> with <ph id="ph2">`IsNot`</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>#Disable Warning <ph id="ph1">\&lt;</ph>ID&gt; and #Enable Warning <ph id="ph2">\&lt;</ph>ID&gt;<ept id="p1">](../../visual-basic/language-reference/directives/directives.md)</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You can disable and enable specific warnings for regions within a source file.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>XML Doc-comment Improvements</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of <ph id="ph1">`crefs`</ph> (generics, operators, etc.), colorizing, and refactoring.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Partial Module and Interface Definitions<ept id="p1">](../../visual-basic/language-reference/modifiers/partial.md)</ept></source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In addition to classes and structs, you can declare partial modules and interfaces.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>#Region Directives inside Method Bodies<ept id="p1">](../../visual-basic/language-reference/directives/region-directive.md)</ept></source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overrides Definitions are Implicitly Overloads<ept id="p1">](../../visual-basic/language-reference/modifiers/overrides.md)</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>If you add the <ph id="ph1">`Overrides`</ph> modifier to a definition, the compiler implicitly adds <ph id="ph2">`Overloads`</ph> so that you can type less code in common cases.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>CObj Allowed in Attributes Arguments</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Declaring and Consuming Ambiguous Methods from Different Interfaces</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Previously the following code yielded errors that prevented you from declaring <ph id="ph1">`IMock`</ph> or from calling <ph id="ph2">`GetDetails`</ph> (if these had been declared in C#):</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Now the compiler will use normal overload resolution rules to choose the most appropriate <ph id="ph1">`GetDetails`</ph> to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>What's New in Visual Studio 2017<ept id="p1">](https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-in-visual-studio)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>