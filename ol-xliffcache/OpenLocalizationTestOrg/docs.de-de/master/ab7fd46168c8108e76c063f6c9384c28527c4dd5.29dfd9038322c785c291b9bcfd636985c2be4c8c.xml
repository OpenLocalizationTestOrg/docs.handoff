{"content":"---\ntitle: \"Using the XmlSerializer Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"XmlSerializer [WCF], using\"\nms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069\ncaps.latest.revision: 26\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Using the XmlSerializer Class\n[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.  \n  \n## DataContractSerializer as the Default  \n By default [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types. This serializer supports the following types:  \n  \n-   Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.  \n  \n-   Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).  \n  \n-   Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.  \n  \n-   Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.  \n  \n-   Many common collection types, which include many generic collection types.  \n  \n Many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types fall into the latter two categories and are thus serializable. Arrays of serializable types are also serializable. For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).  \n  \n The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).  \n  \n## When to Use the XmlSerializer Class  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] also supports the <xref:System.Xml.Serialization.XmlSerializer> class. The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]. It is the same serialization engine that [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services use. The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard. It also does not require any declarative attributes on the serializable types. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] the XML Serialization topic in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] documentation. The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.  \n  \n When using Svcutil.exe or the **Add Service Reference** feature in [!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)] to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you. If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.  \n  \n## Manually Switching to the XmlSerializer  \n At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>. This happens, for example, in the following cases:  \n  \n-   When migrating an application from [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.  \n  \n-   When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.  \n  \n-   When creating services that follow the legacy SOAP Encoding standard.  \n  \n In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.  \n  \n [!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]\n [!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]  \n  \n## Security Considerations  \n  \n> [!NOTE]\n>  It is important to be careful when switching serialization engines. The same type can serialize to XML differently depending on the serializer being used. If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.  \n  \n For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types. The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member. See the type in the following code.  \n  \n [!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]\n [!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]  \n  \n If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.  \n  \n Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.  \n  \n The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.  \n  \n Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class. First, it is strongly recommended that any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure. This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool). This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application. An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache. Of course, an attacker must first gain write access to one of these two locations to attempt this action.  \n  \n Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder. The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder. You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.  \n  \n## Rules for XmlSerializer support  \n You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values. However, they can be applied to typed messages (message contract body parts), as shown in the following code.  \n  \n [!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]\n [!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]  \n  \n When applied to typed message members, these attributes override properties that conflict on the typed message attributes. For example, in the following code, `ElementName` overrides `Name`.  \n  \n [!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]\n [!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]  \n  \n The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.  \n  \n> [!NOTE]\n>  In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: \"An element declared at the top level of a schema cannot have `maxOccurs` > 1. Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style.\"  \n>   \n>  If you receive such an exception, investigate whether this situation applies.  \n  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.  \n  \n## Types that Implement the IXmlSerializable Interface  \n Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`. The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.  \n  \n> [!WARNING]\n>  If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.  \n  \n There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.  \n  \n-   Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute. The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`. This is the most common usage of `IXmlSerializable` types.  \n  \n-   Element types are used when an `IXmlSerializable` type must control its own root element name. To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method. Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`. However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.  \n  \n-   Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute. Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation. This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons. Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.  \n  \n### IXmlSerializable Content Types  \n When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method. The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element. After `WriteXml` is done, the serializer closes the element.  \n  \n When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method. The method must read the entire element, including the start and end tags. Make sure your `ReadXml` code handles the case where the element is empty. Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way. The name is chosen by the serializer can vary.  \n  \n It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>. It is also permitted for the type instances to be null. Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>. All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element (\"nil\" and \"type\" in the XML Schema Instance namespace and \"Id\", \"Ref\", \"Type\" and \"Assembly\" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace).  \n  \n#### Attributes to Ignore when Implementing ReadXml  \n Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them. For example, if \"nil\" is `true`, a null value is deserialized and `ReadXml` is not called. If polymorphism is detected, the contents of the element are deserialized as if it was a different type. The polymorphically-assigned type’s implementation of `ReadXml` is called. In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.  \n  \n### Schema Considerations for IXmlSerializable Content Types  \n When exporting schema and an `IXmlSerializable` content type, the schema provider method is called. An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method. The method can add any valid schema to the schema set. The schema set contains the schema that is already known at the time when schema export occurs. When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set. If it does, the schema provider method must add the new item to the existing `XmlSchema`. Otherwise, it must create a new `XmlSchema` instance. This is important if arrays of `IXmlSerializable` types are being used. For example, if you have an `IXmlSerializable` type that gets exported as type \"A\" in namespace \"B\", it is possible that by the time the schema provider method is called the schema set already contains the schema for \"B\" to hold the \"ArrayOfA\" type.  \n  \n In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value. It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type. This qualified name also serves as the data contract name and namespace for the type. It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns. However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set. Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>. [!INCLUDE[crabout](../../../../includes/crabout-md.md)] the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).  \n  \n The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use. The type may or may not be anonymous. If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member. The `IXmlSerializable` type still has a data contract name and namespace. (This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`. This case is equivalent to returning the `XmlQualifiedName` of the type.  \n  \n Additionally, a global element declaration is exported for the type. If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its \"nillable\" property is `true`. The only exception to this is the schema namespace (\"http://www.w3.org/2001/XMLSchema\") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace. If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties. The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and \"nillable\" being `true`.  \n  \n The same global element declaration rules apply to legacy dataset types. Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.  \n  \n### IXmlSerializable Element Types  \n `IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.  \n  \n Serializing and deserializing an element type is very similar to serializing and deserializing a content type. However, there are some important differences:  \n  \n-   The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements). It should not be writing attributes outside of this single element, multiple sibling elements or mixed content. The element may be empty.  \n  \n-   The `ReadXml` implementation should not read the wrapper element. It is expected to read the one element that `WriteXml` produces.  \n  \n-   When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types. However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).  \n  \n-   When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`. In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned. Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.  \n  \n-   When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element. <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object. `ReadObject` then passes control to `ReadXml` method.  \n  \n The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types. Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.  \n  \n### Differences from the XmlSerializer  \n The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> . However, there are some differences in how these are treated in the data contract model. The important differences are summarized in the following list:  \n  \n-   The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.  \n  \n-   The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.  \n  \n-   When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace. In the data contract model, the namespace used is normally the data contract namespace as described earlier.  \n  \n Be aware of these differences when creating types that are used with both serialization technologies.  \n  \n### Importing IXmlSerializable Schema  \n When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:  \n  \n-   The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md). In this case, schema can be imported as usual and regular data contract types are generated.  \n  \n-   The generated schema may not be a valid data contract schema. For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model. In this case, you can import the schema as `IXmlSerializable` types. This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md). Note that you must work directly with the XML for your type instances. You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.  \n  \n-   You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones. In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse. This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.  \n  \n### XmlSerializer Legacy Behavior  \n In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file. The file was then compiled into an assembly.  This behavior had some undesirable consequences like slowing the startup time for the serializer. In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler. Some developers may wish to see the generated C# code. You can specify to use this legacy behavior by the following configuration:  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\" ?>  \n<configuration>  \n  <system.xml.serialization>  \n    <xmlSerializer tempFilesLocation='e:\\temp\\XmlSerializerBug' useLegacySerializerGeneration=\"true\" />  \n  </system.xml.serialization>  \n  <system.diagnostics>  \n    <switches>  \n      <add name=\"XmlSerialization.Compilation\" value=\"1\" />  \n    </switches>  \n  </system.diagnostics>  \n</configuration>  \n  \n```  \n  \n If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:  \n  \n```xml  \n<configuration>  \n<appSettings>   \n<add key=\"System:Xml:Serialization:UseLegacySerializerGeneration\" value=\"true\" />  \n               </appSettings>  \n</configuration>  \n  \n```  \n  \n As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:  \n  \n```xml  \n<configuration>  \n<system.xml.serialization>  \n<xmlSerializer useLegacySerializerGeneration=\"true\"/>  \n</system.xml.serialization>  \n</configuration>  \n  \n```  \n  \n> [!NOTE]\n>  The `<xmlSerializer useLegacySerializerGeneration=\"true\"/>` switch only works on a machine running .NET Framework 4.5 or later version. The above `appSettings` approach works on all .NET Framework versions.  \n  \n## See Also  \n <xref:System.ServiceModel.DataContractFormatAttribute>   \n <xref:System.Runtime.Serialization.DataContractSerializer>   \n <xref:System.Xml.Serialization.XmlSerializer>   \n <xref:System.ServiceModel.MessageHeaderArrayAttribute>   \n [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)   \n [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)   \n [How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)\n","nodes":[{"pos":[4,405],"embed":true,"restype":"x-metadata","content":"title: \"Using the XmlSerializer Class | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"XmlSerializer [WCF], using\"\nms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069\ncaps.latest.revision: 26\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"","nodes":[{"content":"Using the XmlSerializer Class | Microsoft Docs","nodes":[{"pos":[0,46],"content":"Using the XmlSerializer Class | Microsoft Docs","nodes":[{"content":"Using the XmlSerializer Class | Microsoft Docs","pos":[0,46]}]}],"path":["title"]}],"yml":true},{"pos":[412,441],"content":"Using the XmlSerializer Class","linkify":"Using the XmlSerializer Class","nodes":[{"content":"Using the XmlSerializer Class","pos":[0,29]}]},{"pos":[442,674],"content":"<ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.","source":"[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization."},{"pos":[683,720],"content":"DataContractSerializer as the Default","linkify":"DataContractSerializer as the Default","nodes":[{"content":"DataContractSerializer as the Default","pos":[0,37]}]},{"content":"By default <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> uses the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class to serialize data types.","pos":[724,889],"source":"By default [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types."},{"content":"This serializer supports the following types:","pos":[890,935]},{"content":"Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.DateTime&gt;</ph>, which are treated as primitives.","pos":[945,1140],"source":"Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives."},{"content":"Data contract types (types marked with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute).","pos":[1150,1262],"source":"Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute)."},{"content":"Types marked with the <ph id=\"ph1\">&lt;xref:System.SerializableAttribute&gt;</ph> attribute, which include types that implement the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface.","pos":[1272,1440],"source":"Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface."},{"content":"Types that implement the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.","pos":[1450,1534],"source":"Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface."},{"content":"Many common collection types, which include many generic collection types.","pos":[1544,1618]},{"content":"Many <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types fall into the latter two categories and are thus serializable.","pos":[1625,1762],"source":"Many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types fall into the latter two categories and are thus serializable."},{"content":"Arrays of serializable types are also serializable.","pos":[1763,1814]},{"content":"For a complete list, see <bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.","pos":[1815,1985],"source":" For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, used together with data contract types, is the recommended way to write new <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services.","pos":[1992,2197],"source":"The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.","pos":[2198,2352],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)."},{"pos":[2361,2396],"content":"When to Use the XmlSerializer Class","linkify":"When to Use the XmlSerializer Class","nodes":[{"content":"When to Use the XmlSerializer Class","pos":[0,35]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> also supports the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class.","pos":[2400,2526],"source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] also supports the <xref:System.Xml.Serialization.XmlSerializer> class."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class is not unique to <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.","pos":[2527,2656],"source":" The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]."},{"content":"It is the same serialization engine that <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> Web services use.","pos":[2657,2773],"source":" It is the same serialization engine that [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services use."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class supports a much narrower set of types than the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.","pos":[2774,3071],"source":" The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard."},{"content":"It also does not require any declarative attributes on the serializable types.","pos":[3072,3150]},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph> the XML Serialization topic in the <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> documentation.","pos":[3151,3324],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] the XML Serialization topic in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] documentation."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class does not support data contract types.","pos":[3325,3418],"source":" The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types."},{"content":"When using Svcutil.exe or the <bpt id=\"p1\">**</bpt>Add Service Reference<ept id=\"p1\">**</ept> feature in <ph id=\"ph1\">[!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)]</ph> to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.","pos":[3425,3692],"source":"When using Svcutil.exe or the **Add Service Reference** feature in [!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)] to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you."},{"content":"If the schema is not compatible with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is selected.","pos":[3693,3856],"source":" If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected."},{"pos":[3865,3904],"content":"Manually Switching to the XmlSerializer","linkify":"Manually Switching to the XmlSerializer","nodes":[{"content":"Manually Switching to the XmlSerializer","pos":[0,39]}]},{"content":"At times, you may have to manually switch to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.","pos":[3908,4003],"source":"At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>."},{"content":"This happens, for example, in the following cases:","pos":[4004,4054]},{"pos":[4064,4369],"content":"When migrating an application from <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> Web services to <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, you may want to reuse existing, <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>-compatible types instead of creating new data contract types.","source":"When migrating an application from [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types."},{"content":"When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.","pos":[4379,4693]},{"content":"When creating services that follow the legacy SOAP Encoding standard.","pos":[4703,4772]},{"pos":[4779,4993],"content":"In these and other cases, you can manually switch to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class by applying the <ph id=\"ph2\">`XmlSerializerFormatAttribute`</ph> attribute to your service, as shown in the following code.","source":"In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code."},{"pos":[5000,5237],"content":"[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]\n[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]","leadings":[""," "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#1<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[0,117],"source":"[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#1<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[118,236],"source":"[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]"}]},{"pos":[5246,5269],"content":"Security Considerations","linkify":"Security Considerations","nodes":[{"content":"Security Considerations","pos":[0,23]}]},{"pos":[5277,5575],"content":"[!NOTE]\n It is important to be careful when switching serialization engines. The same type can serialize to XML differently depending on the serializer being used. If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.","leadings":["","> "],"nodes":[{"content":"It is important to be careful when switching serialization engines. The same type can serialize to XML differently depending on the serializer being used. If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.","pos":[9,296],"nodes":[{"content":"It is important to be careful when switching serialization engines.","pos":[0,67]},{"content":"The same type can serialize to XML differently depending on the serializer being used.","pos":[68,154]},{"content":"If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.","pos":[155,287]}]}]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class only serializes members marked with the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attribute when serializing data contract types.","pos":[5582,5807],"source":"For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class serializes any public member.","pos":[5808,5893],"source":" The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member."},{"content":"See the type in the following code.","pos":[5894,5929]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#2<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)</ept><ept id=\"p1\">]</ept>","pos":[5936,6053],"source":"[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#2<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)</ept><ept id=\"p1\">]</ept>","pos":[6055,6173],"source":"[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]"},{"pos":[6180,6387],"content":"If the type is inadvertently used in a service contract where the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class is selected, the <ph id=\"ph2\">`creditCardNumber`</ph> member is serialized, which is probably not intended.","source":"If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended."},{"content":"Even though the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <ph id=\"ph2\">&lt;xref:System.ServiceModel.DataContractFormatAttribute&gt;</ph> attribute to the service contract type.","pos":[6394,6694],"source":"Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type."},{"content":"The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.","pos":[6701,6872]},{"content":"Other important security considerations apply to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class.","pos":[6879,6984],"source":"Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class."},{"content":"First, it is strongly recommended that any <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application that uses the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class is signed with a key that is safeguarded from disclosure.","pos":[6985,7219],"source":" First, it is strongly recommended that any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure."},{"content":"This recommendation applies both when a manual switch to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).","pos":[7220,7441],"source":" This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool)."},{"content":"This is because the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> serialization engine supports the loading of <bpt id=\"p1\">*</bpt>pre-generated serialization assemblies<ept id=\"p1\">*</ept> as long as they are signed with the same key as the application.","pos":[7442,7658],"source":" This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application."},{"content":"An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.","pos":[7659,7893]},{"content":"Of course, an attacker must first gain write access to one of these two locations to attempt this action.","pos":[7894,7999]},{"content":"Another threat that exists whenever you use <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is related to write access to the system temporary folder.","pos":[8006,8154],"source":"Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> serialization engine creates and uses temporary <bpt id=\"p1\">*</bpt>serialization assemblies<ept id=\"p1\">*</ept> in this folder.","pos":[8155,8295],"source":" The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder."},{"content":"You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.","pos":[8296,8440]},{"pos":[8449,8480],"content":"Rules for XmlSerializer support","linkify":"Rules for XmlSerializer support","nodes":[{"content":"Rules for XmlSerializer support","pos":[0,31]}]},{"content":"You cannot directly apply <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>-compatible attributes to contract operation parameters or return values.","pos":[8484,8628],"source":"You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values."},{"content":"However, they can be applied to typed messages (message contract body parts), as shown in the following code.","pos":[8629,8738]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#3<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)</ept><ept id=\"p1\">]</ept>","pos":[8745,8862],"source":"[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#3<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)</ept><ept id=\"p1\">]</ept>","pos":[8864,8982],"source":"[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]"},{"content":"When applied to typed message members, these attributes override properties that conflict on the typed message attributes.","pos":[8989,9111]},{"content":"For example, in the following code, <ph id=\"ph1\">`ElementName`</ph> overrides <ph id=\"ph2\">`Name`</ph>.","pos":[9112,9179],"source":" For example, in the following code, `ElementName` overrides `Name`."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#4<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)</ept><ept id=\"p1\">]</ept>","pos":[9186,9303],"source":"[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>c_XmlSerializer#4<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)</ept><ept id=\"p1\">]</ept>","pos":[9305,9423],"source":"[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]"},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> attribute is not supported when using the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.","pos":[9430,9577],"source":"The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>."},{"pos":[9585,10005],"content":"[!NOTE]\n In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: \"An element declared at the top level of a schema cannot have `maxOccurs` > 1. Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style.\"","leadings":["","> "],"nodes":[{"content":"In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: \"An element declared at the top level of a schema cannot have `maxOccurs` > 1. Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style.\"","pos":[9,418],"nodes":[{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> throws the following exception, which is released prior to <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>: \"An element declared at the top level of a schema cannot have <ph id=\"ph3\">`maxOccurs`</ph> &gt; 1.","pos":[0,258],"source":"In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: \"An element declared at the top level of a schema cannot have `maxOccurs` > 1."},{"content":"Provide a wrapper element for 'more' by using <ph id=\"ph1\">`XmlArray`</ph> or <ph id=\"ph2\">`XmlArrayItem`</ph> instead of <ph id=\"ph3\">`XmlElementAttribute`</ph>, or by using the Wrapped parameter style.\"","pos":[259,409],"source":" Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style.\""}]}]},{"content":"If you receive such an exception, investigate whether this situation applies.","pos":[10016,10093]},{"pos":[10100,10424],"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does not support the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.SoapIncludeAttribute&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.XmlIncludeAttribute&gt;</ph> attributes in message contracts and operation contracts; use the <ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute instead.","source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead."},{"pos":[10433,10484],"content":"Types that Implement the IXmlSerializable Interface","linkify":"Types that Implement the IXmlSerializable Interface","nodes":[{"content":"Types that Implement the IXmlSerializable Interface","pos":[0,51]}]},{"content":"Types that implement the <ph id=\"ph1\">`IXmlSerializable`</ph> interface are fully supported by the <ph id=\"ph2\">`DataContractSerializer`</ph>.","pos":[10488,10594],"source":"Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute should always be applied to these types to control their schema.","pos":[10595,10732],"source":" The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema."},{"pos":[10740,10926],"content":"[!WARNING]\n If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.","leadings":["","> "],"nodes":[{"content":"If you are serializing polymorphic types you must apply the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> to the type to ensure the correct type is serialized.","pos":[12,184],"source":"If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized."}]},{"pos":[10933,11126],"content":"There are three varieties of types that implement <ph id=\"ph1\">`IXmlSerializable`</ph>: types that represent arbitrary content, types that represent a single element, and legacy <ph id=\"ph2\">&lt;xref:System.Data.DataSet&gt;</ph> types.","source":"There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types."},{"content":"Content types use a schema provider method specified by the <ph id=\"ph1\">`XmlSchemaProviderAttribute`</ph> attribute.","pos":[11136,11235],"source":"Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute."},{"content":"The method does not return <ph id=\"ph1\">`null`</ph> and the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the attribute is left at its default value of <ph id=\"ph3\">`false`</ph>.","pos":[11236,11412],"source":" The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`."},{"content":"This is the most common usage of <ph id=\"ph1\">`IXmlSerializable`</ph> types.","pos":[11413,11471],"source":" This is the most common usage of `IXmlSerializable` types."},{"content":"Element types are used when an <ph id=\"ph1\">`IXmlSerializable`</ph> type must control its own root element name.","pos":[11481,11575],"source":"Element types are used when an `IXmlSerializable` type must control its own root element name."},{"content":"To mark a type as an element type, either set the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute to <ph id=\"ph3\">`true`</ph> or return <ph id=\"ph4\">`null`</ph> from the schema provider method.","pos":[11576,11838],"source":" To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method."},{"content":"Having a schema provider method is optional for element types – you may specify <ph id=\"ph1\">`null`</ph> instead of the method name in the <ph id=\"ph2\">`XmlSchemaProviderAttribute`</ph>.","pos":[11839,11989],"source":" Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`."},{"content":"However, if <ph id=\"ph1\">`IsAny`</ph> is <ph id=\"ph2\">`true`</ph> and a schema provider method is specified, the method must return <ph id=\"ph3\">`null`</ph>.","pos":[11990,12093],"source":" However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`."},{"content":"Legacy <ph id=\"ph1\">&lt;xref:System.Data.DataSet&gt;</ph> types are <ph id=\"ph2\">`IXmlSerializable`</ph> types that are not marked with the <ph id=\"ph3\">`XmlSchemaProviderAttribute`</ph> attribute.","pos":[12103,12240],"source":"Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute."},{"content":"Instead, they rely on the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A&gt;</ph> method for schema generation.","pos":[12241,12358],"source":" Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation."},{"content":"This pattern is used for the <ph id=\"ph1\">`DataSet`</ph> type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.","pos":[12359,12545],"source":" This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons."},{"content":"Do not rely on this pattern and always apply the <ph id=\"ph1\">`XmlSchemaProviderAttribute`</ph> to your <ph id=\"ph2\">`IXmlSerializable`</ph> types.","pos":[12546,12657],"source":" Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types."},{"pos":[12667,12697],"content":"IXmlSerializable Content Types","linkify":"IXmlSerializable Content Types","nodes":[{"content":"IXmlSerializable Content Types","pos":[0,30]}]},{"content":"When serializing a data member of a type that implements <ph id=\"ph1\">`IXmlSerializable`</ph> and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> method.","pos":[12701,12978],"source":"When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> implementation can write any XML, which includes adding attributes to the wrapper element.","pos":[12979,13134],"source":" The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element."},{"content":"After <ph id=\"ph1\">`WriteXml`</ph> is done, the serializer closes the element.","pos":[13135,13195],"source":" After `WriteXml` is done, the serializer closes the element."},{"content":"When deserializing a data member of a type that implements <ph id=\"ph1\">`IXmlSerializable`</ph> and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A&gt;</ph> method.","pos":[13202,13503],"source":"When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method."},{"content":"The method must read the entire element, including the start and end tags.","pos":[13504,13578]},{"content":"Make sure your <ph id=\"ph1\">`ReadXml`</ph> code handles the case where the element is empty.","pos":[13579,13653],"source":" Make sure your `ReadXml` code handles the case where the element is empty."},{"content":"Additionally, your <ph id=\"ph1\">`ReadXml`</ph> implementation should not rely on the wrapper element being named a particular way.","pos":[13654,13766],"source":" Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way."},{"content":"The name is chosen by the serializer can vary.","pos":[13767,13813]},{"content":"It is permitted to assign <ph id=\"ph1\">`IXmlSerializable`</ph> content types polymorphically, for example, to data members of type <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[13820,13954],"source":"It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>."},{"content":"It is also permitted for the type instances to be null.","pos":[13955,14010]},{"content":"Finally, it is possible to use <ph id=\"ph1\">`IXmlSerializable`</ph> types with object graph preservation enabled and with the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.","pos":[14011,14181],"source":" Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>."},{"content":"All these features require the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> serializer to attach certain attributes into the wrapper element (\"nil\" and \"type\" in the XML Schema Instance namespace and \"Id\", \"Ref\", \"Type\" and \"Assembly\" in a <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>-specific namespace).","pos":[14182,14509],"source":" All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element (\"nil\" and \"type\" in the XML Schema Instance namespace and \"Id\", \"Ref\", \"Type\" and \"Assembly\" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace)."},{"pos":[14520,14566],"content":"Attributes to Ignore when Implementing ReadXml","linkify":"Attributes to Ignore when Implementing ReadXml","nodes":[{"content":"Attributes to Ignore when Implementing ReadXml","pos":[0,46]}]},{"content":"Before passing control to your <ph id=\"ph1\">`ReadXml`</ph> code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.","pos":[14570,14715],"source":"Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them."},{"content":"For example, if \"nil\" is <ph id=\"ph1\">`true`</ph>, a null value is deserialized and <ph id=\"ph2\">`ReadXml`</ph> is not called.","pos":[14716,14806],"source":" For example, if \"nil\" is `true`, a null value is deserialized and `ReadXml` is not called."},{"content":"If polymorphism is detected, the contents of the element are deserialized as if it was a different type.","pos":[14807,14911]},{"content":"The polymorphically-assigned type’s implementation of <ph id=\"ph1\">`ReadXml`</ph> is called.","pos":[14912,14986],"source":" The polymorphically-assigned type’s implementation of `ReadXml` is called."},{"content":"In any case, a <ph id=\"ph1\">`ReadXml`</ph> implementation should ignore these special attributes because they are handled by the deserializer.","pos":[14987,15111],"source":" In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer."},{"pos":[15121,15177],"content":"Schema Considerations for IXmlSerializable Content Types","linkify":"Schema Considerations for IXmlSerializable Content Types","nodes":[{"content":"Schema Considerations for IXmlSerializable Content Types","pos":[0,56]}]},{"content":"When exporting schema and an <ph id=\"ph1\">`IXmlSerializable`</ph> content type, the schema provider method is called.","pos":[15181,15280],"source":"When exporting schema and an `IXmlSerializable` content type, the schema provider method is called."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> is passed to the schema provider method.","pos":[15281,15362],"source":" An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method."},{"content":"The method can add any valid schema to the schema set.","pos":[15363,15417]},{"content":"The schema set contains the schema that is already known at the time when schema export occurs.","pos":[15418,15513]},{"content":"When the schema provider method must add an item to the schema set, it must determine whether an <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchema&gt;</ph> with the appropriate namespace already exists in the set.","pos":[15514,15703],"source":" When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set."},{"content":"If it does, the schema provider method must add the new item to the existing <ph id=\"ph1\">`XmlSchema`</ph>.","pos":[15704,15793],"source":" If it does, the schema provider method must add the new item to the existing `XmlSchema`."},{"content":"Otherwise, it must create a new <ph id=\"ph1\">`XmlSchema`</ph> instance.","pos":[15794,15847],"source":" Otherwise, it must create a new `XmlSchema` instance."},{"content":"This is important if arrays of <ph id=\"ph1\">`IXmlSerializable`</ph> types are being used.","pos":[15848,15919],"source":" This is important if arrays of `IXmlSerializable` types are being used."},{"content":"For example, if you have an <ph id=\"ph1\">`IXmlSerializable`</ph> type that gets exported as type \"A\" in namespace \"B\", it is possible that by the time the schema provider method is called the schema set already contains the schema for \"B\" to hold the \"ArrayOfA\" type.","pos":[15920,16169],"source":" For example, if you have an `IXmlSerializable` type that gets exported as type \"A\" in namespace \"B\", it is possible that by the time the schema provider method is called the schema set already contains the schema for \"B\" to hold the \"ArrayOfA\" type."},{"content":"In addition to adding types to the <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph>, the schema provider method for content types must return a non-null value.","pos":[16176,16324],"source":"In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value."},{"content":"It can return an <ph id=\"ph1\">&lt;xref:System.Xml.XmlQualifiedName&gt;</ph> that specifies the name of the schema type to use for the given <ph id=\"ph2\">`IXmlSerializable`</ph> type.","pos":[16325,16465],"source":" It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type."},{"content":"This qualified name also serves as the data contract name and namespace for the type.","pos":[16466,16551]},{"content":"It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.","pos":[16552,16675]},{"content":"However, it is expected that by the time all related types are exported (the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A&gt;</ph> method is called for all relevant types on the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter&gt;</ph> and the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A&gt;</ph> property is accessed), the type exists in the schema set.","pos":[16676,17066],"source":" However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set."},{"content":"Accessing the <ph id=\"ph1\">`Schemas`</ph> property before all relevant <ph id=\"ph2\">`Export`</ph> calls have been made can result in an <ph id=\"ph3\">&lt;xref:System.Xml.Schema.XmlSchemaException&gt;</ph>.","pos":[17067,17211],"source":" Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>."},{"content":"<ph id=\"ph1\">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> the export process, see <bpt id=\"p1\">[</bpt>Exporting Schemas from Classes<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)</ept>.","pos":[17212,17407],"source":"[!INCLUDE[crabout](../../../../includes/crabout-md.md)] the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)."},{"content":"The schema provider method can also return the <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchemaType&gt;</ph> to use.","pos":[17414,17507],"source":"The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use."},{"content":"The type may or may not be anonymous.","pos":[17508,17545]},{"content":"If it is anonymous, the schema for the <ph id=\"ph1\">`IXmlSerializable`</ph> type is exported as an anonymous type every time the <ph id=\"ph2\">`IXmlSerializable`</ph> type is used as a data member.","pos":[17546,17706],"source":" If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member."},{"content":"The <ph id=\"ph1\">`IXmlSerializable`</ph> type still has a data contract name and namespace.","pos":[17707,17780],"source":" The `IXmlSerializable` type still has a data contract name and namespace."},{"content":"(This is determined as described in <bpt id=\"p1\">[</bpt>Data Contract Names<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept> except that the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the <ph id=\"ph2\">`XmlSchemaSet`</ph>.","pos":[17781,18107],"source":" (This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`."},{"content":"This case is equivalent to returning the <ph id=\"ph1\">`XmlQualifiedName`</ph> of the type.","pos":[18108,18180],"source":" This case is equivalent to returning the `XmlQualifiedName` of the type."},{"content":"Additionally, a global element declaration is exported for the type.","pos":[18187,18255]},{"content":"If the type does not have the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlRootAttribute&gt;</ph> attribute applied to it, the element has the same name and namespace as the data contract, and its \"nillable\" property is <ph id=\"ph2\">`true`</ph>.","pos":[18256,18464],"source":" If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its \"nillable\" property is `true`."},{"content":"The only exception to this is the schema namespace (\"http://www.w3.org/2001/XMLSchema\") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.","pos":[18465,18732]},{"content":"If the type has the <ph id=\"ph1\">`XmlRootAttribute`</ph> attribute applied to it, the global element declaration is exported using the following: <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A&gt;</ph> properties.","pos":[18733,19066],"source":" If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties."},{"content":"The defaults with <ph id=\"ph1\">`XmlRootAttribute`</ph> applied are the data contract name, a blank namespace and \"nillable\" being <ph id=\"ph2\">`true`</ph>.","pos":[19067,19186],"source":" The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and \"nillable\" being `true`."},{"content":"The same global element declaration rules apply to legacy dataset types.","pos":[19193,19265]},{"content":"Note that the <ph id=\"ph1\">`XmlRootAttribute`</ph> cannot override global element declarations added through custom code, either added to the <ph id=\"ph2\">`XmlSchemaSet`</ph> using the schema provider method or through <ph id=\"ph3\">`GetSchema`</ph> for legacy dataset types.","pos":[19266,19486],"source":" Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types."},{"pos":[19496,19526],"content":"IXmlSerializable Element Types","linkify":"IXmlSerializable Element Types","nodes":[{"content":"IXmlSerializable Element Types","pos":[0,30]}]},{"pos":[19530,19661],"content":"<ph id=\"ph1\">`IXmlSerializable`</ph> element types have either the <ph id=\"ph2\">`IsAny`</ph> property set to <ph id=\"ph3\">`true`</ph> or have their schema provider method return <ph id=\"ph4\">`null`</ph>.","source":"`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`."},{"content":"Serializing and deserializing an element type is very similar to serializing and deserializing a content type.","pos":[19668,19778]},{"content":"However, there are some important differences:","pos":[19779,19825]},{"content":"The <ph id=\"ph1\">`WriteXml`</ph> implementation is expected to write exactly one element (which could of course contain multiple child elements).","pos":[19835,19962],"source":"The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements)."},{"content":"It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.","pos":[19963,20074]},{"content":"The element may be empty.","pos":[20075,20100]},{"content":"The <ph id=\"ph1\">`ReadXml`</ph> implementation should not read the wrapper element.","pos":[20110,20175],"source":"The `ReadXml` implementation should not read the wrapper element."},{"content":"It is expected to read the one element that <ph id=\"ph1\">`WriteXml`</ph> produces.","pos":[20176,20240],"source":" It is expected to read the one element that `WriteXml` produces."},{"content":"When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling <ph id=\"ph1\">`WriteXml`</ph>, as with content types.","pos":[20250,20435],"source":"When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types."},{"content":"However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that <ph id=\"ph1\">`WriteXml`</ph> writes, unless a root name and namespace are explicitly specified when constructing the serializer in the <ph id=\"ph2\">`DataContractSerializer`</ph> or <ph id=\"ph3\">`NetDataContractSerializer`</ph> constructors.","pos":[20436,20771],"source":" However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.","pos":[20772,20952],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)."},{"content":"When serializing an element type at the top level without specifying the root name and namespace at construction time, <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A&gt;</ph> essentially do nothing and <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A&gt;</ph> calls <ph id=\"ph4\">`WriteXml`</ph>.","pos":[20962,21357],"source":"When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`."},{"content":"In this mode, the object being serialized cannot be <ph id=\"ph1\">`null`</ph> and cannot be polymorphically assigned.","pos":[21358,21456],"source":" In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned."},{"content":"Also, object graph preservation cannot enabled and the <ph id=\"ph1\">`NetDataContractSerializer`</ph> cannot be used.","pos":[21457,21555],"source":" Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used."},{"content":"When deserializing an element type at the top level without specifying the root name and namespace at construction time, <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A&gt;</ph> returns <ph id=\"ph2\">`true`</ph> if it can find the start of any element.","pos":[21565,21814],"source":"When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> with the <ph id=\"ph2\">`verifyObjectName`</ph> parameter set to <ph id=\"ph3\">`true`</ph> behaves in the same way as <ph id=\"ph4\">`IsStartObject`</ph> before actually reading the object.","pos":[21815,22015],"source":" <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object."},{"content":"<ph id=\"ph1\">`ReadObject`</ph> then passes control to <ph id=\"ph2\">`ReadXml`</ph> method.","pos":[22016,22069],"source":"`ReadObject` then passes control to `ReadXml` method."},{"content":"The schema exported for element types is the same as for the <ph id=\"ph1\">`XmlElement`</ph> type as described in an earlier section, except that the schema provider method can add any additional schema to the <ph id=\"ph2\">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> as with content types.","pos":[22076,22327],"source":"The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types."},{"content":"Using the <ph id=\"ph1\">`XmlRootAttribute`</ph> attribute with element types is not allowed, and global element declarations are never emitted for these types.","pos":[22328,22468],"source":" Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types."},{"pos":[22478,22512],"content":"Differences from the XmlSerializer","linkify":"Differences from the XmlSerializer","nodes":[{"content":"Differences from the XmlSerializer","pos":[0,34]}]},{"content":"The <ph id=\"ph1\">`IXmlSerializable`</ph> interface and the <ph id=\"ph2\">`XmlSchemaProviderAttribute`</ph> and <ph id=\"ph3\">`XmlRootAttribute`</ph> attributes are also understood by the <ph id=\"ph4\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> .","pos":[22516,22694],"source":"The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> ."},{"content":"However, there are some differences in how these are treated in the data contract model.","pos":[22695,22783]},{"content":"The important differences are summarized in the following list:","pos":[22784,22847]},{"pos":[22857,23003],"content":"The schema provider method must be public to be used in the <ph id=\"ph1\">`XmlSerializer`</ph>, but does not have to be public to be used in the data contract model.","source":"The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model."},{"pos":[23013,23133],"content":"The schema provider method is called when <ph id=\"ph1\">`IsAny`</ph> is <ph id=\"ph2\">`true`</ph> in the data contract model but not with the <ph id=\"ph3\">`XmlSerializer`</ph>.","source":"The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`."},{"content":"When the <ph id=\"ph1\">`XmlRootAttribute`</ph> attribute is not present for content or legacy dataset types, the <ph id=\"ph2\">`XmlSerializer`</ph> exports a global element declaration in the blank namespace.","pos":[23143,23313],"source":"When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace."},{"content":"In the data contract model, the namespace used is normally the data contract namespace as described earlier.","pos":[23314,23422]},{"content":"Be aware of these differences when creating types that are used with both serialization technologies.","pos":[23429,23530]},{"pos":[23540,23573],"content":"Importing IXmlSerializable Schema","linkify":"Importing IXmlSerializable Schema","nodes":[{"content":"Importing IXmlSerializable Schema","pos":[0,33]}]},{"pos":[23577,23672],"content":"When importing a schema generated from <ph id=\"ph1\">`IXmlSerializable`</ph> types, there are a few possibilities:","source":"When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:"},{"content":"The generated schema may be a valid data contract schema as described in <bpt id=\"p1\">[</bpt>Data Contract Schema Reference<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.","pos":[23682,23870],"source":"The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)."},{"content":"In this case, schema can be imported as usual and regular data contract types are generated.","pos":[23871,23963]},{"content":"The generated schema may not be a valid data contract schema.","pos":[23973,24034]},{"content":"For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.","pos":[24035,24175]},{"content":"In this case, you can import the schema as <ph id=\"ph1\">`IXmlSerializable`</ph> types.","pos":[24176,24244],"source":" In this case, you can import the schema as `IXmlSerializable` types."},{"content":"This import mode is not on by default but can easily be enabled – for example, with the <ph id=\"ph1\">`/importXmlTypes`</ph> command-line switch to the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.","pos":[24245,24511],"source":" This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)."},{"content":"This is described in detail in the <bpt id=\"p1\">[</bpt>Importing Schema to Generate Classes<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)</ept>.","pos":[24512,24674],"source":" This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)."},{"content":"Note that you must work directly with the XML for your type instances.","pos":[24675,24745]},{"content":"You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the <ph id=\"ph1\">`XmlSerializer`</ph>.","pos":[24746,24894],"source":" You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`."},{"content":"You may want to reuse your existing <ph id=\"ph1\">`IXmlSerializable`</ph> types in the proxy instead of generating new ones.","pos":[24904,25009],"source":"You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones."},{"content":"In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.","pos":[25010,25153]},{"content":"This corresponds to using the <ph id=\"ph1\">`/reference`</ph> switch on svcutil.exe, which specifies the assembly that contains the types to reuse.","pos":[25154,25282],"source":" This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse."},{"pos":[25292,25321],"content":"XmlSerializer Legacy Behavior","linkify":"XmlSerializer Legacy Behavior","nodes":[{"content":"XmlSerializer Legacy Behavior","pos":[0,29]}]},{"content":"In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.","pos":[25325,25456]},{"content":"The file was then compiled into an assembly.","pos":[25457,25501]},{"content":"This behavior had some undesirable consequences like slowing the startup time for the serializer.","pos":[25503,25600]},{"content":"In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.","pos":[25601,25715]},{"content":"Some developers may wish to see the generated C# code.","pos":[25716,25770]},{"content":"You can specify to use this legacy behavior by the following configuration:","pos":[25771,25846]},{"pos":[26270,26503],"content":"If you run into compatibility issues,  such as the <ph id=\"ph1\">`XmlSerializer`</ph> failing to serialize a derived class with a non-public new override, you can switch back to the  <ph id=\"ph2\">`XMLSerializer`</ph> legacy behavior by using the following configuration:","source":"If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:"},{"content":"As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:","pos":[26701,26844]},{"pos":[27025,27242],"content":"[!NOTE]\n The `<xmlSerializer useLegacySerializerGeneration=\"true\"/>` switch only works on a machine running .NET Framework 4.5 or later version. The above `appSettings` approach works on all .NET Framework versions.","leadings":["","> "],"nodes":[{"content":"The `<xmlSerializer useLegacySerializerGeneration=\"true\"/>` switch only works on a machine running .NET Framework 4.5 or later version. The above `appSettings` approach works on all .NET Framework versions.","pos":[9,215],"nodes":[{"content":"The <ph id=\"ph1\">`&lt;xmlSerializer useLegacySerializerGeneration=\"true\"/&gt;`</ph> switch only works on a machine running .NET Framework 4.5 or later version.","pos":[0,135],"source":"The `<xmlSerializer useLegacySerializerGeneration=\"true\"/>` switch only works on a machine running .NET Framework 4.5 or later version."},{"content":"The above <ph id=\"ph1\">`appSettings`</ph> approach works on all .NET Framework versions.","pos":[136,206],"source":" The above `appSettings` approach works on all .NET Framework versions."}]}]},{"pos":[27251,27259],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.DataContractFormatAttribute&gt;</ph>","pos":[27263,27317],"source":"<xref:System.ServiceModel.DataContractFormatAttribute> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>","pos":[27322,27380],"source":"<xref:System.Runtime.Serialization.DataContractSerializer> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>","pos":[27385,27430],"source":"<xref:System.Xml.Serialization.XmlSerializer> "},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>","pos":[27435,27489],"source":"<xref:System.ServiceModel.MessageHeaderArrayAttribute> "},{"content":"<bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept><ph id=\"ph1\"> </ph>","pos":[27494,27639],"source":"[Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md) "},{"content":"<bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept><ph id=\"ph1\"> </ph>","pos":[27643,27738],"source":"[Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)</ept>","pos":[27742,27942],"source":"[How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)"}]}