{"content":"---\ntitle: \"One-Way Services\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"Windows Communication Foundation [WCF], one-way service contracts\"\n  - \"WCF [WCF], one-way service contracts\"\n  - \"service contracts [WCF], defining one-way\"\nms.assetid: 19053a36-4492-45a3-bfe6-0365ee0205a3\n---\n# One-Way Services\nThe default behavior of a service operation is the request-reply pattern. In a request-reply pattern, the client waits for the reply message, even if the service operation is represented in code as a `void` method. With a one-way operation, only one message is transmitted. The receiver does not send a reply message, nor does the sender expect one.  \n  \n Use the one-way design pattern:  \n  \n-   When the client must call operations and is not affected by the result of the operation at the operation level.  \n  \n-   When using the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class. (For more information about this scenario, see [Queues in WCF](../../../../docs/framework/wcf/feature-details/queues-in-wcf.md).)  \n  \n When an operation is one-way, there is no response message to carry error information back to the client. You can detect error conditions by using features of the underlying binding, such as reliable sessions, or by designing a duplex service contract that uses two one-way operations—a one-way contract from the client to the service to call service operation and another one-way contract between the service and the client so that the service can send back faults to the client using a callback that the client implements.  \n  \n To create a one-way service contract, define your service contract, apply the <xref:System.ServiceModel.OperationContractAttribute> class to each operation, and set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as shown in the following sample code.  \n  \n```  \n[ServiceContract(Namespace=\"http://Microsoft.ServiceModel.Samples\")]  \npublic interface IOneWayCalculator  \n{  \n    [OperationContract(IsOneWay=true)]  \n    void Add(double n1, double n2);  \n    [OperationContract(IsOneWay = true)]  \n    void Subtract(double n1, double n2);  \n    [OperationContract(IsOneWay = true)]  \n    void Multiply(double n1, double n2);  \n    [OperationContract(IsOneWay = true)]  \n    void Divide(double n1, double n2);  \n}  \n```  \n  \n For a complete example, see the [One-Way](../../../../docs/framework/wcf/samples/one-way.md) sample.  \n  \n## Clients Blocking with One-Way Operations  \n It is important to realize that while some one-way applications return as soon as the outbound data is written to the network connection, in several scenarios the implementation of a binding or of a service can cause a WCF client to block using one-way operations. In WCF client applications, the WCF client object does not return until the outbound data has been written to the network connection. This is true for all message exchange patterns, including one-way operations; this means that any problem writing the data to the transport prevents the client from returning. Depending upon the problem, the result could be an exception or a delay in sending messages to the service.  \n  \n For example, if the transport cannot find the endpoint, a <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> exception is thrown without much delay. However, it is also possible that the service is unable to read the data off the wire for some reason, which prevents the client transport send operation from returning. In these cases, if the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> period on the client transport binding is exceeded, a <xref:System.TimeoutException?displayProperty=nameWithType> is thrown—but not until the timeout period has been exceeded. It is also possible to fire so many messages at a service that the service cannot process them past a certain point. In this case, too, the one-way client blocks until the service can process the messages or until an exception is thrown.  \n  \n Another variation is the situation in which the service <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ConcurrencyMode.Single> and the binding uses sessions. In this case, the dispatcher enforces ordering on the incoming messages (a requirement of sessions), which prevents subsequent messages from being read off the network until the service has processed the preceding message for that session. Again, the client blocks, but whether an exception occurs depends upon whether the service is able to process the waiting data prior to the timeout settings on the client.  \n  \n You can mitigate some of this problem by inserting a buffer between the client object and the client transport's send operation. For example, using asynchronous calls or using an in-memory message queue can enable the client object to return quickly. Both approaches may increase functionality, but the size of the thread pool and the message queue still enforce limits.  \n  \n It is recommended, instead, that you examine the various controls on the service as well as on the client, and then test your application scenarios to determine the best configuration on either side. For example, if the use of sessions is blocking the processing of messages on your service, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.PerCall> so that each message can be processed by a different service instance, and set the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> to <xref:System.ServiceModel.ConcurrencyMode.Multiple> in order to allow more than one thread to dispatch messages at a time. Another approach is to increase the read quotas of the service and client bindings.  \n  \n## See also\n\n- [One-Way](../../../../docs/framework/wcf/samples/one-way.md)\n","nodes":[{"pos":[4,285],"embed":true,"restype":"x-metadata","content":"title: \"One-Way Services\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"Windows Communication Foundation [WCF], one-way service contracts\"\n  - \"WCF [WCF], one-way service contracts\"\n  - \"service contracts [WCF], defining one-way\"\nms.assetid: 19053a36-4492-45a3-bfe6-0365ee0205a3","nodes":[{"content":"One-Way Services","nodes":[{"pos":[0,16],"content":"One-Way Services","nodes":[{"content":"One-Way Services","pos":[0,16]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[292,308],"content":"One-Way Services","linkify":"One-Way Services","nodes":[{"content":"One-Way Services","pos":[0,16]}]},{"content":"The default behavior of a service operation is the request-reply pattern.","pos":[309,382]},{"content":"In a request-reply pattern, the client waits for the reply message, even if the service operation is represented in code as a <ph id=\"ph1\">`void`</ph> method.","pos":[383,523],"source":" In a request-reply pattern, the client waits for the reply message, even if the service operation is represented in code as a `void` method."},{"content":"With a one-way operation, only one message is transmitted.","pos":[524,582]},{"content":"The receiver does not send a reply message, nor does the sender expect one.","pos":[583,658]},{"content":"Use the one-way design pattern:","pos":[665,696]},{"content":"When the client must call operations and is not affected by the result of the operation at the operation level.","pos":[706,817]},{"content":"When using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.NetMsmqBinding&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding&gt;</ph> class.","pos":[827,963],"source":"When using the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class."},{"content":"(For more information about this scenario, see <bpt id=\"p1\">[</bpt>Queues in WCF<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/queues-in-wcf.md)</ept>.)","pos":[964,1093],"source":" (For more information about this scenario, see [Queues in WCF](../../../../docs/framework/wcf/feature-details/queues-in-wcf.md).)"},{"content":"When an operation is one-way, there is no response message to carry error information back to the client.","pos":[1100,1205]},{"content":"You can detect error conditions by using features of the underlying binding, such as reliable sessions, or by designing a duplex service contract that uses two one-way operations—a one-way contract from the client to the service to call service operation and another one-way contract between the service and the client so that the service can send back faults to the client using a callback that the client implements.","pos":[1206,1624]},{"pos":[1631,1924],"content":"To create a one-way service contract, define your service contract, apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> class to each operation, and set the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A&gt;</ph> property to <ph id=\"ph3\">`true`</ph>, as shown in the following sample code.","source":"To create a one-way service contract, define your service contract, apply the <xref:System.ServiceModel.OperationContractAttribute> class to each operation, and set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as shown in the following sample code."},{"pos":[2397,2497],"content":"For a complete example, see the <bpt id=\"p1\">[</bpt>One-Way<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-way.md)</ept> sample.","source":"For a complete example, see the [One-Way](../../../../docs/framework/wcf/samples/one-way.md) sample."},{"pos":[2506,2546],"content":"Clients Blocking with One-Way Operations","linkify":"Clients Blocking with One-Way Operations","nodes":[{"content":"Clients Blocking with One-Way Operations","pos":[0,40]}]},{"content":"It is important to realize that while some one-way applications return as soon as the outbound data is written to the network connection, in several scenarios the implementation of a binding or of a service can cause a WCF client to block using one-way operations.","pos":[2550,2814]},{"content":"In WCF client applications, the WCF client object does not return until the outbound data has been written to the network connection.","pos":[2815,2948]},{"content":"This is true for all message exchange patterns, including one-way operations; this means that any problem writing the data to the transport prevents the client from returning.","pos":[2949,3124]},{"content":"Depending upon the problem, the result could be an exception or a delay in sending messages to the service.","pos":[3125,3232]},{"content":"For example, if the transport cannot find the endpoint, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType&gt;</ph> exception is thrown without much delay.","pos":[3239,3418],"source":"For example, if the transport cannot find the endpoint, a <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> exception is thrown without much delay."},{"content":"However, it is also possible that the service is unable to read the data off the wire for some reason, which prevents the client transport send operation from returning.","pos":[3419,3588]},{"content":"In these cases, if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType&gt;</ph> period on the client transport binding is exceeded, a <ph id=\"ph2\">&lt;xref:System.TimeoutException?displayProperty=nameWithType&gt;</ph> is thrown—but not until the timeout period has been exceeded.","pos":[3589,3875],"source":" In these cases, if the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> period on the client transport binding is exceeded, a <xref:System.TimeoutException?displayProperty=nameWithType> is thrown—but not until the timeout period has been exceeded."},{"content":"It is also possible to fire so many messages at a service that the service cannot process them past a certain point.","pos":[3876,3992]},{"content":"In this case, too, the one-way client blocks until the service can process the messages or until an exception is thrown.","pos":[3993,4113]},{"content":"Another variation is the situation in which the service <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType&gt;</ph> property is set to <ph id=\"ph2\">&lt;xref:System.ServiceModel.ConcurrencyMode.Single&gt;</ph> and the binding uses sessions.","pos":[4120,4375],"source":"Another variation is the situation in which the service <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ConcurrencyMode.Single> and the binding uses sessions."},{"content":"In this case, the dispatcher enforces ordering on the incoming messages (a requirement of sessions), which prevents subsequent messages from being read off the network until the service has processed the preceding message for that session.","pos":[4376,4615]},{"content":"Again, the client blocks, but whether an exception occurs depends upon whether the service is able to process the waiting data prior to the timeout settings on the client.","pos":[4616,4787]},{"content":"You can mitigate some of this problem by inserting a buffer between the client object and the client transport's send operation.","pos":[4794,4922]},{"content":"For example, using asynchronous calls or using an in-memory message queue can enable the client object to return quickly.","pos":[4923,5044]},{"content":"Both approaches may increase functionality, but the size of the thread pool and the message queue still enforce limits.","pos":[5045,5164]},{"content":"It is recommended, instead, that you examine the various controls on the service as well as on the client, and then test your application scenarios to determine the best configuration on either side.","pos":[5171,5370]},{"content":"For example, if the use of sessions is blocking the processing of messages on your service, you can set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType&gt;</ph> property to <ph id=\"ph2\">&lt;xref:System.ServiceModel.InstanceContextMode.PerCall&gt;</ph> so that each message can be processed by a different service instance, and set the <ph id=\"ph3\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A&gt;</ph> to <ph id=\"ph4\">&lt;xref:System.ServiceModel.ConcurrencyMode.Multiple&gt;</ph> in order to allow more than one thread to dispatch messages at a time.","pos":[5371,5929],"source":" For example, if the use of sessions is blocking the processing of messages on your service, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.PerCall> so that each message can be processed by a different service instance, and set the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> to <xref:System.ServiceModel.ConcurrencyMode.Multiple> in order to allow more than one thread to dispatch messages at a time."},{"content":"Another approach is to increase the read quotas of the service and client bindings.","pos":[5930,6013]},{"pos":[6022,6030],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6034,6094],"content":"<bpt id=\"p1\">[</bpt>One-Way<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-way.md)</ept>","source":"[One-Way](../../../../docs/framework/wcf/samples/one-way.md)"}]}