<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="lambda-expressions.md" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bbb524e50d74207227420d073afd5758d3d5aaa7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">92bd0cfa0819ae3744fbff7b31b5f65a7f683b79</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">45f6bc205d5967faeeb386c07b1fe3f2cd8c7a56</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Lambda Expressions</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Lean to use lambda expressions, which are executable code blocks that can be passed as arguments.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>.NET, .NET Core, lambda expressions, lambdas, delegates</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Lambda expressions</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>lambda expression<ept id="p1">*</ept> is a block of code (an expression or a statement block) that is treated as an object.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>It can be passed as an argument to methods, and it can also be returned by method calls.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Lambda expressions are used extensively for:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Passing the code that is to be executed to asynchronous methods, such as <ph id="ph1">@System.Threading.Tasks.Task.Run</ph>(System.Action).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Writing <bpt id="p1">[</bpt>LINQ query expressions<ept id="p1">](linq/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Creating <bpt id="p1">[</bpt>expression trees<ept id="p1">](expression-trees-building.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Lambda expressions are code that can be represented either as a delegate, or as an expression tree that compiles to a delegate.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The specific delegate type of a lambda expression depends on its parameters and return value.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Lambda expressions that don't return a value correspond to a specific <ph id="ph1">`Action`</ph> delegate, depending on its number of parameters.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Lambda expressions that return a value correspond to a specific <ph id="ph1">`Func`</ph> delegate, depending on its number of parameters.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, a lambda expression that has two parameters but returns no value corresponds to an <ph id="ph1">@System.Action</ph>%602 delegate.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>A lambda expression that has one parameter and returns a value corresponds to <ph id="ph1">@System.Func</ph>%602 delegate.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A lambda expression uses <ph id="ph1">`=&gt;`</ph>, the <bpt id="p1">[</bpt>lambda declaration operator<ept id="p1">](language-reference/operators/lambda-operator.md)</ept>, to separate the lambda's parameter list from its executable code.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator, and you put the expression or statement block on the other side.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, the single-line lambda expression <ph id="ph1">`x =&gt; x * x`</ph> specifies a parameter thatâ€™s named <ph id="ph2">`x`</ph> and returns the value of <ph id="ph3">`x`</ph> squared.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can assign this expression to a delegate type, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Or you can pass it directly as a method argument:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Expression lambdas</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A lambda expression with an expression on the right side of the =&gt; operator is called an <bpt id="p1">*</bpt>expression lambda<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Expression lambdas are used extensively in the construction of <bpt id="p1">[</bpt>expression trees<ept id="p1">](expression-trees.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>An expression lambda returns the result of the expression and takes the following basic form:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The parentheses are optional only if the lambda has one input parameter; otherwise they are required.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Specify zero input parameters with empty parentheses:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Two or more input parameters are separated by commas enclosed in parentheses:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Ordinarily, the compiler uses type inference in determining parameter types.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, sometimes it is difficult or impossible for the compiler to infer the input types.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When this occurs, you can specify the types explicitly, as in the following example:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Note in the previous example that the body of an expression lambda can consist of a method call.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server or Entity Framework (EF), you should refrain from using method calls in lambda expressions, since the methods may  have no meaning outside the context of the .NET runtime.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you do choose to use method calls in this case, be sure to test them thoroughly to ensure that the method calls can be successfuly resolved.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Statement lambdas</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Statement lambdas, like anonymous methods, cannot be used to create expression trees.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Async lambdas</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id="p1">[</bpt>async<ept id="p1">](language-reference/keywords/async.md)</ept> and <bpt id="p2">[</bpt>await<ept id="p2">](language-reference/keywords/await.md)</ept> keywords.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, the example calls a <ph id="ph1">`ShowSquares`</ph> method that executes asynchronously.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information about how to create and use async methods, see <bpt id="p1">[</bpt>Asynchronous programming with async and await<ept id="p1">](programming-guide/concepts/async/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Lambda expressions and tuples</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Starting with C# 7.0, the C# language provides built-in support for tuples.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In some cases, the C# compiler uses type inference to determine the types of tuple components.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You define a tuple by enclosing a comma-delimited list of its components in parentheses.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following example uses tuple with 5 components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with 5 components that contains the result of the multiplications.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Ordinarily, the fields of a tuple are named <ph id="ph1">`Item1`</ph>, <ph id="ph2">`Item2`</ph>, etc. You can, however, define a tuple with named components, as the following example does.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information on support for tuples in C#, see <bpt id="p1">[</bpt>C# Tuple types<ept id="p1">](tuples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Lambdas with the standard query operators</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>LINQ to Objects, among other implementations, have an input parameter whose type is one of the <ph id="ph1">@System.Func</ph>%601 family of generic delegates.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Func`</ph> delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For example, consider the <ph id="ph1">@System.Func</ph>%601 delegate, whose syntax is:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The delegate can be instantiated with code like the following</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>where <ph id="ph1">`int`</ph> is an input parameter, and <ph id="ph2">`bool`</ph> is the return value.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The return value is always specified in the last type parameter.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When the following <ph id="ph1">`Func`</ph> delegate is invoked, it returns true or false to indicate whether the input parameter is equal to 5:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You can also supply a lambda expression when the argument type is an <ph id="ph1">@System.Linq.Expressions.Expression</ph>%601, for example in the standard query operators that are defined in the <ph id="ph2">@System.Linq.Queryable</ph> type.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When you specify an <ph id="ph1">@System.Linq.Expressions.Expression</ph>%601 argument, the lambda is compiled to an expression tree.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example uses the <bpt id="p1">[</bpt>System.Linq.Enumerable.Count<ept id="p1">](xref:System.Linq.Enumerable.Count%60%601(System.Collections.Generic.IEnumerable{%60%600}))</ept> standard query operator.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The compiler can infer the type of the input parameter, or you can also specify it explicitly.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This particular lambda expression counts those integers (<ph id="ph1">`n`</ph>) that, when divided by two, have a remainder of 1.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following example produces a sequence that contains all elements in the <ph id="ph1">`numbers`</ph> array that precede the 9, because that's the first number in the sequence that doesn't meet the condition.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following example specifies multiple input parameters by enclosing them in parentheses.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The method returns all the elements in the numbers array until it encounters a number whose value is less than its ordinal position in the array.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Type inference in lambda expressions</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors, as described in the C# Language Specification.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For most of the standard query operators, the first input is the type of the elements in the source sequence.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>If you are querying an <ph id="ph1">`IEnumerable&lt;Customer&gt;`</ph>, then the input variable is inferred to be a <ph id="ph2">`Customer`</ph> object, which means you have access to its methods and properties:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The general rules for type inference for lambdas are:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The lambda must contain the same number of parameters as the delegate type.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Each input argument in the lambda must be implicitly convertible to its corresponding delegate parameter.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of "lambda expression."</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, it is sometimes convenient to speak informally of the "type" of a lambda expression.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In these cases the type refers to the delegate type or <ph id="ph1">@System.Linq.Expressions.Expression</ph> type to which the lambda expression is converted.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Variable Scope in Lambda Expressions</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Lambdas can refer to <bpt id="p1">*</bpt>outer variables<ept id="p1">*</ept> (see <bpt id="p2">[</bpt>Anonymous methods<ept id="p2">](programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>An outer variable must be definitely assigned before it can be consumed in a lambda expression.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates these rules.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The following rules apply to variable scope in lambda expressions:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Variables introduced within a lambda expression are not visible in the outer method.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A lambda expression cannot directly capture a <ph id="ph1">`ref`</ph> or <ph id="ph2">`out`</ph> parameter from an enclosing method.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>A return statement in a lambda expression does not cause the enclosing method to return.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>A lambda expression cannot contain a <ph id="ph1">`goto`</ph> statement, <ph id="ph2">`break`</ph> statement, or <ph id="ph3">`continue`</ph> statement that is inside the lambda function if the jump statementâ€™s target is outside the block.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>It is also an error to have a jump statement outside the lambda function block if the target is inside the block.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ (Language-Integrated Query)<ept id="p1">](../standard/using-linq.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anonymous methods<ept id="p1">](programming-guide/statements-expressions-operators/anonymous-methods.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Expression trees<ept id="p1">](expression-trees.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>