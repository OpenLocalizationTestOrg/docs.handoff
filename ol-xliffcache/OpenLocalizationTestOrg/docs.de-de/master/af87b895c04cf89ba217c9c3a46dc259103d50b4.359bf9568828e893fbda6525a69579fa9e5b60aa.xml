{"content":"---\ntitle: \"Numeric Data Types (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"integral types, Visual Basic\"\n  - \"Short data type, numeric data types\"\n  - \"Double data type, numeric data types\"\n  - \"Long data type, Visual Basic numeric data types\"\n  - \"numbers, whole\"\n  - \"fractions\"\n  - \"numbers\"\n  - \"whole numbers\"\n  - \"integer numbers\"\n  - \"numbers, integer\"\n  - \"fractional data types\"\n  - \"mantissas, of fractional numbers\"\n  - \"mantissas\"\n  - \"data types [Visual Basic], numeric\"\n  - \"Integer data type, numeric data types\"\n  - \"exponent, of fractional numbers\"\n  - \"integers\"\n  - \"numeric data types, Visual Basic\"\n  - \"Single data type, numeric types\"\n  - \"Decimal data type, numeric data types\"\nms.assetid: a27bd4d0-7e14-43eb-9cc4-b42eaab323c9\ncaps.latest.revision: 25\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Numeric Data Types (Visual Basic)\n[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] supplies several *numeric data types* for handling numbers in various representations. *Integral* types represent only whole numbers (positive, negative, and zero), and *nonintegral* types represent numbers with both integer and fractional parts.  \n  \n For a table showing a side-by-side comparison of the [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] data types, see [Data Types](../../../../visual-basic/language-reference/data-types/data-type-summary.md).  \n  \n## Integral Numeric Types  \n *Integral data types* are those that represent only numbers without fractional parts.  \n  \n The *signed* integral data types are [SByte Data Type](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md) (8-bit), [Short Data Type](../../../../visual-basic/language-reference/data-types/short-data-type.md) (16-bit), [Integer Data Type](../../../../visual-basic/language-reference/data-types/integer-data-type.md) (32-bit), and [Long Data Type](../../../../visual-basic/language-reference/data-types/long-data-type.md) (64-bit). If a variable always stores integers rather than fractional numbers, declare it as one of these types.  \n  \n The *unsigned* integral types are [Byte Data Type](../../../../visual-basic/language-reference/data-types/byte-data-type.md) (8-bit), [UShort Data Type](../../../../visual-basic/language-reference/data-types/ushort-data-type.md) (16-bit), [UInteger Data Type](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md) (32-bit), and [ULong Data Type](../../../../visual-basic/language-reference/data-types/ulong-data-type.md) (64-bit). If a variable contains binary data, or data of unknown nature, declare it as one of these types.  \n  \n### Performance  \n Arithmetic operations are faster with integral types than with other data types. They are fastest with the `Integer` and `UInteger` types in [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)].  \n  \n### Large Integers  \n If you need to hold an integer larger than the `Integer` data type can hold, you can use the `Long` data type instead. `Long` variables can hold numbers from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807. Operations with `Long` are slightly slower than with `Integer`.  \n  \n If you need even larger values, you can use the [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md). You can hold numbers from -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,264,337,593,543,950,335 in a `Decimal` variable if you do not use any decimal places. However, operations with `Decimal` numbers are considerably slower than with any other numeric data type.  \n  \n### Small Integers  \n If you do not need the full range of the `Integer` data type, you can use the `Short` data type, which can hold integers from -32,768 through 32,767. For the smallest integer range, the `SByte` data type holds integers from -128 through 127. If you have a very large number of variables that hold small integers, the common language runtime can sometimes store your `Short` and `SByte` variables more efficiently and save memory consumption. However, operations with `Short` and `SByte` are somewhat slower than with `Integer`.  \n  \n### Unsigned Integers  \n If you know that your variable never needs to hold a negative number, you can use the *unsigned types*`Byte`, `UShort`, `UInteger`, and `ULong`. Each of these data types can hold a positive integer twice as large as its corresponding signed type (`SByte`, `Short`, `Integer`, and `Long`). In terms of performance, each unsigned type is exactly as efficient as its corresponding signed type. In particular, `UInteger` shares with `Integer` the distinction of being the most efficient of all the elementary numeric data types.  \n  \n## Nonintegral Numeric Types  \n *Nonintegral data types* are those that represent numbers with both integer and fractional parts.  \n  \n The nonintegral numeric data types are `Decimal` (128-bit fixed point), [Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) (32-bit floating point), and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md) (64-bit floating point). They are all signed types. If a variable can contain a fraction, declare it as one of these types.  \n  \n `Decimal` is not a floating-point data type. `Decimal` numbers have a binary integer value and an integer scaling factor that specifies what portion of the value is a decimal fraction.  \n  \n You can use `Decimal` variables for money values. The advantage is the precision of the values. The `Double` data type is faster and requires less memory, but it is subject to rounding errors. The `Decimal` data type retains complete accuracy to 28 decimal places.  \n  \n Floating-point (`Single` and `Double`) numbers have larger ranges than `Decimal` numbers but can be subject to rounding errors. Floating-point types support fewer significant digits than `Decimal` but can represent values of greater magnitude.  \n  \n Nonintegral number values can be expressed as mmmEeee, in which mmm is the *mantissa* (the significant digits) and eee is the *exponent* (a power of 10). The highest positive values of the nonintegral types are 7.9228162514264337593543950335E+28 for `Decimal`, 3.4028235E+38 for `Single`, and 1.79769313486231570E+308 for `Double`.  \n  \n### Performance  \n `Double` is the most efficient of the fractional data types, because the processors on current platforms perform floating-point operations in double precision. However, operations with `Double` are not as fast as with the integral types such as `Integer`.  \n  \n### Small Magnitudes  \n For numbers with the smallest possible magnitude (closest to 0), `Double` variables can hold numbers as small as -4.94065645841246544E-324 for negative values and 4.94065645841246544E-324 for positive values.  \n  \n### Small Fractional Numbers  \n If you do not need the full range of the `Double` data type, you can use the `Single` data type, which can hold floating-point numbers from -3.4028235E+38 through 3.4028235E+38. The smallest magnitudes for `Single` variables are -1.401298E-45 for negative values and 1.401298E-45 for positive values. If you have a very large number of variables that hold small floating-point numbers, the common language runtime can sometimes store your `Single` variables more efficiently and save memory consumption.  \n  \n## See Also  \n [Elementary Data Types](../../../../visual-basic/programming-guide/language-features/data-types/elementary-data-types.md)   \n [Character Data Types](../../../../visual-basic/programming-guide/language-features/data-types/character-data-types.md)   \n [Miscellaneous Data Types](../../../../visual-basic/programming-guide/language-features/data-types/miscellaneous-data-types.md)   \n [Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)   \n [How to: Call a Windows Function that Takes Unsigned Types](../../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)","nodes":[{"pos":[4,1182],"embed":true,"restype":"x-metadata","content":"title: \"Numeric Data Types (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"integral types, Visual Basic\"\n  - \"Short data type, numeric data types\"\n  - \"Double data type, numeric data types\"\n  - \"Long data type, Visual Basic numeric data types\"\n  - \"numbers, whole\"\n  - \"fractions\"\n  - \"numbers\"\n  - \"whole numbers\"\n  - \"integer numbers\"\n  - \"numbers, integer\"\n  - \"fractional data types\"\n  - \"mantissas, of fractional numbers\"\n  - \"mantissas\"\n  - \"data types [Visual Basic], numeric\"\n  - \"Integer data type, numeric data types\"\n  - \"exponent, of fractional numbers\"\n  - \"integers\"\n  - \"numeric data types, Visual Basic\"\n  - \"Single data type, numeric types\"\n  - \"Decimal data type, numeric data types\"\nms.assetid: a27bd4d0-7e14-43eb-9cc4-b42eaab323c9\ncaps.latest.revision: 25\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","nodes":[{"content":"Numeric Data Types (Visual Basic) | Microsoft Docs","nodes":[{"pos":[0,50],"content":"Numeric Data Types (Visual Basic) | Microsoft Docs","nodes":[{"content":"Numeric Data Types (Visual Basic) | Microsoft Docs","pos":[0,50]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[1189,1222],"content":"Numeric Data Types (Visual Basic)","linkify":"Numeric Data Types (Visual Basic)","nodes":[{"content":"Numeric Data Types (Visual Basic)","pos":[0,33]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> supplies several <bpt id=\"p1\">*</bpt>numeric data types<ept id=\"p1\">*</ept> for handling numbers in various representations.","pos":[1223,1402],"source":"[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] supplies several *numeric data types* for handling numbers in various representations."},{"content":"<bpt id=\"p1\">*</bpt>Integral<ept id=\"p1\">*</ept> types represent only whole numbers (positive, negative, and zero), and <bpt id=\"p2\">*</bpt>nonintegral<ept id=\"p2\">*</ept> types represent numbers with both integer and fractional parts.","pos":[1403,1562],"source":"*Integral* types represent only whole numbers (positive, negative, and zero), and *nonintegral* types represent numbers with both integer and fractional parts."},{"pos":[1569,1821],"content":"For a table showing a side-by-side comparison of the <ph id=\"ph1\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> data types, see <bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/data-type-summary.md)</ept>.","source":"For a table showing a side-by-side comparison of the [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] data types, see [Data Types](../../../../visual-basic/language-reference/data-types/data-type-summary.md)."},{"pos":[1830,1852],"content":"Integral Numeric Types","linkify":"Integral Numeric Types","nodes":[{"content":"Integral Numeric Types","pos":[0,22]}]},{"pos":[1856,1941],"content":"<bpt id=\"p1\">*</bpt>Integral data types<ept id=\"p1\">*</ept> are those that represent only numbers without fractional parts.","source":"*Integral data types* are those that represent only numbers without fractional parts."},{"content":"The <bpt id=\"p1\">*</bpt>signed<ept id=\"p1\">*</ept> integral data types are <bpt id=\"p2\">[</bpt>SByte Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md)</ept> (8-bit), <bpt id=\"p3\">[</bpt>Short Data Type<ept id=\"p3\">](../../../../visual-basic/language-reference/data-types/short-data-type.md)</ept> (16-bit), <bpt id=\"p4\">[</bpt>Integer Data Type<ept id=\"p4\">](../../../../visual-basic/language-reference/data-types/integer-data-type.md)</ept> (32-bit), and <bpt id=\"p5\">[</bpt>Long Data Type<ept id=\"p5\">](../../../../visual-basic/language-reference/data-types/long-data-type.md)</ept> (64-bit).","pos":[1948,2401],"source":"The *signed* integral data types are [SByte Data Type](../../../../visual-basic/language-reference/data-types/sbyte-data-type.md) (8-bit), [Short Data Type](../../../../visual-basic/language-reference/data-types/short-data-type.md) (16-bit), [Integer Data Type](../../../../visual-basic/language-reference/data-types/integer-data-type.md) (32-bit), and [Long Data Type](../../../../visual-basic/language-reference/data-types/long-data-type.md) (64-bit)."},{"content":"If a variable always stores integers rather than fractional numbers, declare it as one of these types.","pos":[2402,2504]},{"content":"The <bpt id=\"p1\">*</bpt>unsigned<ept id=\"p1\">*</ept> integral types are <bpt id=\"p2\">[</bpt>Byte Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/byte-data-type.md)</ept> (8-bit), <bpt id=\"p3\">[</bpt>UShort Data Type<ept id=\"p3\">](../../../../visual-basic/language-reference/data-types/ushort-data-type.md)</ept> (16-bit), <bpt id=\"p4\">[</bpt>UInteger Data Type<ept id=\"p4\">](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md)</ept> (32-bit), and <bpt id=\"p5\">[</bpt>ULong Data Type<ept id=\"p5\">](../../../../visual-basic/language-reference/data-types/ulong-data-type.md)</ept> (64-bit).","pos":[2511,2965],"source":"The *unsigned* integral types are [Byte Data Type](../../../../visual-basic/language-reference/data-types/byte-data-type.md) (8-bit), [UShort Data Type](../../../../visual-basic/language-reference/data-types/ushort-data-type.md) (16-bit), [UInteger Data Type](../../../../visual-basic/language-reference/data-types/uinteger-data-type.md) (32-bit), and [ULong Data Type](../../../../visual-basic/language-reference/data-types/ulong-data-type.md) (64-bit)."},{"content":"If a variable contains binary data, or data of unknown nature, declare it as one of these types.","pos":[2966,3062]},{"pos":[3072,3083],"content":"Performance","linkify":"Performance","nodes":[{"content":"Performance","pos":[0,11]}]},{"content":"Arithmetic operations are faster with integral types than with other data types.","pos":[3087,3167]},{"content":"They are fastest with the <ph id=\"ph1\">`Integer`</ph> and <ph id=\"ph2\">`UInteger`</ph> types in <ph id=\"ph3\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph>.","pos":[3168,3321],"source":" They are fastest with the `Integer` and `UInteger` types in [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]."},{"pos":[3331,3345],"content":"Large Integers","linkify":"Large Integers","nodes":[{"content":"Large Integers","pos":[0,14]}]},{"content":"If you need to hold an integer larger than the <ph id=\"ph1\">`Integer`</ph> data type can hold, you can use the <ph id=\"ph2\">`Long`</ph> data type instead.","pos":[3349,3467],"source":"If you need to hold an integer larger than the `Integer` data type can hold, you can use the `Long` data type instead."},{"content":"<ph id=\"ph1\">`Long`</ph> variables can hold numbers from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807.","pos":[3468,3568],"source":"`Long` variables can hold numbers from -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807."},{"content":"Operations with <ph id=\"ph1\">`Long`</ph> are slightly slower than with <ph id=\"ph2\">`Integer`</ph>.","pos":[3569,3632],"source":" Operations with `Long` are slightly slower than with `Integer`."},{"content":"If you need even larger values, you can use the <bpt id=\"p1\">[</bpt>Decimal Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept>.","pos":[3639,3784],"source":"If you need even larger values, you can use the [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)."},{"content":"You can hold numbers from -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,264,337,593,543,950,335 in a <ph id=\"ph1\">`Decimal`</ph> variable if you do not use any decimal places.","pos":[3785,3959],"source":" You can hold numbers from -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,264,337,593,543,950,335 in a `Decimal` variable if you do not use any decimal places."},{"content":"However, operations with <ph id=\"ph1\">`Decimal`</ph> numbers are considerably slower than with any other numeric data type.","pos":[3960,4065],"source":" However, operations with `Decimal` numbers are considerably slower than with any other numeric data type."},{"pos":[4075,4089],"content":"Small Integers","linkify":"Small Integers","nodes":[{"content":"Small Integers","pos":[0,14]}]},{"content":"If you do not need the full range of the <ph id=\"ph1\">`Integer`</ph> data type, you can use the <ph id=\"ph2\">`Short`</ph> data type, which can hold integers from -32,768 through 32,767.","pos":[4093,4242],"source":"If you do not need the full range of the `Integer` data type, you can use the `Short` data type, which can hold integers from -32,768 through 32,767."},{"content":"For the smallest integer range, the <ph id=\"ph1\">`SByte`</ph> data type holds integers from -128 through 127.","pos":[4243,4334],"source":" For the smallest integer range, the `SByte` data type holds integers from -128 through 127."},{"content":"If you have a very large number of variables that hold small integers, the common language runtime can sometimes store your <ph id=\"ph1\">`Short`</ph> and <ph id=\"ph2\">`SByte`</ph> variables more efficiently and save memory consumption.","pos":[4335,4534],"source":" If you have a very large number of variables that hold small integers, the common language runtime can sometimes store your `Short` and `SByte` variables more efficiently and save memory consumption."},{"content":"However, operations with <ph id=\"ph1\">`Short`</ph> and <ph id=\"ph2\">`SByte`</ph> are somewhat slower than with <ph id=\"ph3\">`Integer`</ph>.","pos":[4535,4620],"source":" However, operations with `Short` and `SByte` are somewhat slower than with `Integer`."},{"pos":[4630,4647],"content":"Unsigned Integers","linkify":"Unsigned Integers","nodes":[{"content":"Unsigned Integers","pos":[0,17]}]},{"content":"If you know that your variable never needs to hold a negative number, you can use the <bpt id=\"p1\">*</bpt>unsigned types<ept id=\"p1\">*</ept><ph id=\"ph1\">`Byte`</ph>, <ph id=\"ph2\">`UShort`</ph>, <ph id=\"ph3\">`UInteger`</ph>, and <ph id=\"ph4\">`ULong`</ph>.","pos":[4651,4795],"source":"If you know that your variable never needs to hold a negative number, you can use the *unsigned types*`Byte`, `UShort`, `UInteger`, and `ULong`."},{"content":"Each of these data types can hold a positive integer twice as large as its corresponding signed type (<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Short`</ph>, <ph id=\"ph3\">`Integer`</ph>, and <ph id=\"ph4\">`Long`</ph>).","pos":[4796,4939],"source":" Each of these data types can hold a positive integer twice as large as its corresponding signed type (`SByte`, `Short`, `Integer`, and `Long`)."},{"content":"In terms of performance, each unsigned type is exactly as efficient as its corresponding signed type.","pos":[4940,5041]},{"content":"In particular, <ph id=\"ph1\">`UInteger`</ph> shares with <ph id=\"ph2\">`Integer`</ph> the distinction of being the most efficient of all the elementary numeric data types.","pos":[5042,5175],"source":" In particular, `UInteger` shares with `Integer` the distinction of being the most efficient of all the elementary numeric data types."},{"pos":[5184,5209],"content":"Nonintegral Numeric Types","linkify":"Nonintegral Numeric Types","nodes":[{"content":"Nonintegral Numeric Types","pos":[0,25]}]},{"pos":[5213,5310],"content":"<bpt id=\"p1\">*</bpt>Nonintegral data types<ept id=\"p1\">*</ept> are those that represent numbers with both integer and fractional parts.","source":"*Nonintegral data types* are those that represent numbers with both integer and fractional parts."},{"content":"The nonintegral numeric data types are <ph id=\"ph1\">`Decimal`</ph> (128-bit fixed point), <bpt id=\"p1\">[</bpt>Single Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/single-data-type.md)</ept> (32-bit floating point), and <bpt id=\"p2\">[</bpt>Double Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/double-data-type.md)</ept> (64-bit floating point).","pos":[5317,5632],"source":"The nonintegral numeric data types are `Decimal` (128-bit fixed point), [Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) (32-bit floating point), and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md) (64-bit floating point)."},{"content":"They are all signed types.","pos":[5633,5659]},{"content":"If a variable can contain a fraction, declare it as one of these types.","pos":[5660,5731]},{"content":"<ph id=\"ph1\">`Decimal`</ph> is not a floating-point data type.","pos":[5738,5782],"source":"`Decimal` is not a floating-point data type."},{"content":"<ph id=\"ph1\">`Decimal`</ph> numbers have a binary integer value and an integer scaling factor that specifies what portion of the value is a decimal fraction.","pos":[5783,5922],"source":"`Decimal` numbers have a binary integer value and an integer scaling factor that specifies what portion of the value is a decimal fraction."},{"content":"You can use <ph id=\"ph1\">`Decimal`</ph> variables for money values.","pos":[5929,5978],"source":"You can use `Decimal` variables for money values."},{"content":"The advantage is the precision of the values.","pos":[5979,6024]},{"content":"The <ph id=\"ph1\">`Double`</ph> data type is faster and requires less memory, but it is subject to rounding errors.","pos":[6025,6121],"source":" The `Double` data type is faster and requires less memory, but it is subject to rounding errors."},{"content":"The <ph id=\"ph1\">`Decimal`</ph> data type retains complete accuracy to 28 decimal places.","pos":[6122,6193],"source":" The `Decimal` data type retains complete accuracy to 28 decimal places."},{"content":"Floating-point (<ph id=\"ph1\">`Single`</ph> and <ph id=\"ph2\">`Double`</ph>) numbers have larger ranges than <ph id=\"ph3\">`Decimal`</ph> numbers but can be subject to rounding errors.","pos":[6200,6327],"source":"Floating-point (`Single` and `Double`) numbers have larger ranges than `Decimal` numbers but can be subject to rounding errors."},{"content":"Floating-point types support fewer significant digits than <ph id=\"ph1\">`Decimal`</ph> but can represent values of greater magnitude.","pos":[6328,6443],"source":" Floating-point types support fewer significant digits than `Decimal` but can represent values of greater magnitude."},{"content":"Nonintegral number values can be expressed as mmmEeee, in which mmm is the <bpt id=\"p1\">*</bpt>mantissa<ept id=\"p1\">*</ept> (the significant digits) and eee is the <bpt id=\"p2\">*</bpt>exponent<ept id=\"p2\">*</ept> (a power of 10).","pos":[6450,6603],"source":"Nonintegral number values can be expressed as mmmEeee, in which mmm is the *mantissa* (the significant digits) and eee is the *exponent* (a power of 10)."},{"content":"The highest positive values of the nonintegral types are 7.9228162514264337593543950335E+28 for <ph id=\"ph1\">`Decimal`</ph>, 3.4028235E+38 for <ph id=\"ph2\">`Single`</ph>, and 1.79769313486231570E+308 for <ph id=\"ph3\">`Double`</ph>.","pos":[6604,6781],"source":" The highest positive values of the nonintegral types are 7.9228162514264337593543950335E+28 for `Decimal`, 3.4028235E+38 for `Single`, and 1.79769313486231570E+308 for `Double`."},{"pos":[6791,6802],"content":"Performance","linkify":"Performance","nodes":[{"content":"Performance","pos":[0,11]}]},{"content":"<ph id=\"ph1\">`Double`</ph> is the most efficient of the fractional data types, because the processors on current platforms perform floating-point operations in double precision.","pos":[6806,6965],"source":"`Double` is the most efficient of the fractional data types, because the processors on current platforms perform floating-point operations in double precision."},{"content":"However, operations with <ph id=\"ph1\">`Double`</ph> are not as fast as with the integral types such as <ph id=\"ph2\">`Integer`</ph>.","pos":[6966,7061],"source":" However, operations with `Double` are not as fast as with the integral types such as `Integer`."},{"pos":[7071,7087],"content":"Small Magnitudes","linkify":"Small Magnitudes","nodes":[{"content":"Small Magnitudes","pos":[0,16]}]},{"pos":[7091,7299],"content":"For numbers with the smallest possible magnitude (closest to 0), <ph id=\"ph1\">`Double`</ph> variables can hold numbers as small as -4.94065645841246544E-324 for negative values and 4.94065645841246544E-324 for positive values.","source":"For numbers with the smallest possible magnitude (closest to 0), `Double` variables can hold numbers as small as -4.94065645841246544E-324 for negative values and 4.94065645841246544E-324 for positive values."},{"pos":[7309,7333],"content":"Small Fractional Numbers","linkify":"Small Fractional Numbers","nodes":[{"content":"Small Fractional Numbers","pos":[0,24]}]},{"content":"If you do not need the full range of the <ph id=\"ph1\">`Double`</ph> data type, you can use the <ph id=\"ph2\">`Single`</ph> data type, which can hold floating-point numbers from -3.4028235E+38 through 3.4028235E+38.","pos":[7337,7514],"source":"If you do not need the full range of the `Double` data type, you can use the `Single` data type, which can hold floating-point numbers from -3.4028235E+38 through 3.4028235E+38."},{"content":"The smallest magnitudes for <ph id=\"ph1\">`Single`</ph> variables are -1.401298E-45 for negative values and 1.401298E-45 for positive values.","pos":[7515,7637],"source":" The smallest magnitudes for `Single` variables are -1.401298E-45 for negative values and 1.401298E-45 for positive values."},{"content":"If you have a very large number of variables that hold small floating-point numbers, the common language runtime can sometimes store your <ph id=\"ph1\">`Single`</ph> variables more efficiently and save memory consumption.","pos":[7638,7840],"source":" If you have a very large number of variables that hold small floating-point numbers, the common language runtime can sometimes store your `Single` variables more efficiently and save memory consumption."},{"pos":[7849,7857],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Elementary Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/elementary-data-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[7861,7983],"source":"[Elementary Data Types](../../../../visual-basic/programming-guide/language-features/data-types/elementary-data-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Character Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/character-data-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[7987,8107],"source":"[Character Data Types](../../../../visual-basic/programming-guide/language-features/data-types/character-data-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Miscellaneous Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/miscellaneous-data-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[8111,8239],"source":"[Miscellaneous Data Types](../../../../visual-basic/programming-guide/language-features/data-types/miscellaneous-data-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[8243,8375],"source":"[Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Call a Windows Function that Takes Unsigned Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)</ept>","pos":[8379,8554],"source":"[How to: Call a Windows Function that Takes Unsigned Types](../../../../visual-basic/programming-guide/com-interop/how-to-call-a-windows-function-that-takes-unsigned-types.md)"}]}