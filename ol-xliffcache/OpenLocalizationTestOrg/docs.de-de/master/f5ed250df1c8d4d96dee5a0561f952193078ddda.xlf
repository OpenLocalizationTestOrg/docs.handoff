<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="best-practices-strings.md" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5ed250df1c8d4d96dee5a0561f952193078ddda</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\best-practices-strings.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a25454e0ecc21fb07e29d6aa5e466106bb50fcde</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fbdeae536395807f2763afdf2a547b65a2ce8b68</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Best Practices for Using Strings in .NET</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn how to use strings effectively in .NET applications.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Best Practices for Using Strings in .NET</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> .NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>But sorting or comparing strings is not always a culture-sensitive operation.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, strings that are used internally by an application typically should be handled identically across all cultures.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This topic examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Recommendations for String Usage<ept id="p1">](#recommendations_for_string_usage)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Specifying String Comparisons Explicitly<ept id="p1">](#specifying_string_comparisons_explicitly)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Details of String Comparison<ept id="p1">](#the_details_of_string_comparison)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a StringComparison Member for Your Method Call<ept id="p1">](#choosing_a_stringcomparison_member_for_your_method_call)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Common String Comparison Methods in .NET<ept id="p1">](#common_string_comparison_methods_in_the_net_framework)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Methods that Perform String Comparison Indirectly<ept id="p1">](#methods_that_perform_string_comparison_indirectly)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Displaying and Persisting Formatted Data<ept id="p1">](#Formatted)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Recommendations for String Usage</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When you develop with .NET, follow these simple recommendations when you use strings:</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Use overloads that explicitly specify the string comparison rules for string operations.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Typically, this involves calling a method overload that has a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> for comparisons as your safe default for culture-agnostic string matching.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Use comparisons with <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> for better performance.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Use string operations that are based on <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> when you display output to the user.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Use the non-linguistic <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values instead of string operations based on <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> when the comparison is linguistically irrelevant (symbolic, for example).</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType&gt;</ph> method instead of the <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType&gt;</ph> method when you normalize strings for comparison.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Use an overload of the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method to test whether two strings are equal.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.CompareTo%2A?displayProperty=nameWithType&gt;</ph> methods to sort strings, not to check for equality.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Use formatting with the invariant culture to persist non-string data in string form.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Avoid the following practices when you use strings:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Do not use string operations based on <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> in most cases.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>One of the few exceptions is when you are persisting linguistically meaningful but culturally agnostic data.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Do not use an overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.String.CompareTo%2A&gt;</ph> method and test for a return value of zero to determine whether two strings are equal.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Specifying String Comparisons Explicitly</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Most of the string manipulation methods in .NET are overloaded.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Most of the methods that do not rely on defaults include a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following table describes the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration members.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>StringComparison member</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Performs a case-sensitive comparison using the current culture.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive comparison using the current culture.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Performs a case-sensitive comparison using the invariant culture.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive comparison using the invariant culture.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Performs an ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Performs a case-insensitive ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method, which returns the index of a substring in a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that matches either a character or a string, has nine overloads:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph>, which include a parameter of type <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> that allows the form of the comparison to be specified.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We recommend that you select an overload that does not use default values, for the following reasons:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Some overloads with default parameters (those that search for a <ph id="ph1">&lt;xref:System.Char&gt;</ph> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It is difficult to remember which method uses which default value, and easy to confuse the overloads.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The intent of the code that relies on default values for method calls is not clear.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between <ph id="ph1">`protocol`</ph> and "http" might cause the test for equality to return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This, in turn, makes the code more readable and easier to debug and maintain.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following example addresses the questions raised about the previous example.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>It makes it clear that ordinal comparison is used and that differences in case are ignored.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The Details of String Comparison</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Additionally, comparison implicitly defines equality.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The comparison operation returns zero for strings it deems equal.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A good interpretation is that neither string is less than the other.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can download the <bpt id="p1">[</bpt>Sorting Weight Tables<ept id="p1">](https://www.microsoft.com/en-us/download/details.aspx?id=10921)</ept>, a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the <bpt id="p2">[</bpt>Default Unicode Collation Element Table<ept id="p2">](https://www.unicode.org/Public/UCA/latest/allkeys.txt)</ept>, the latest version of the sort weight table for Linux and macOS.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The specific version of the sort weight table on Linux and macOS depends on the version of the <bpt id="p1">[</bpt>International Components for Unicode<ept id="p1">](http://site.icu-project.org/)</ept> libraries installed on the system.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For information on ICU versions and the Unicode versions that they implement, see <bpt id="p1">[</bpt>Downloading ICU<ept id="p1">](http://site.icu-project.org/download)</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the invariant culture (a locale-agnostic culture based on the English language) may produce different results.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>In addition, string comparisons using different versions of .NET or using .NET on different operating systems or operating system versions may return different results.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Strings and the Unicode Standard<ept id="p1">](xref:System.String#Unicode)</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>String Comparisons that Use the Current Culture</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>One criterion involves using the conventions of the current culture when comparing strings.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Comparisons that are based on the current culture use the thread's current culture or locale.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If the culture is not set by the user, it defaults to the setting in the <bpt id="p1">**</bpt>Regional Options<ept id="p1">**</ept> window in Control Panel.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>However, comparison and casing behavior in .NET changes when the culture changes.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This behavior is intentional, but it remains non-obvious to many developers.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>This behavior may manifest itself in sort orders as well.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Comparisons that use current culture semantics are the default for the following methods:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> overloads that do not include a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.CompareTo%2A?displayProperty=nameWithType&gt;</ph> overloads.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The default <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType&gt;</ph> method, and the <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType&gt;</ph> method with a <ph id="ph3">`null`</ph><ph id="ph4">&lt;xref:System.Globalization.CultureInfo&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The default <ph id="ph1">&lt;xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType&gt;</ph> method, and the <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType&gt;</ph> method with a <ph id="ph3">`null`</ph><ph id="ph4">&lt;xref:System.Globalization.CultureInfo&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph> overloads that accept a <ph id="ph2">&lt;xref:System.String&gt;</ph> as a search parameter and that do not have a <ph id="ph3">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> overloads that accept a <ph id="ph2">&lt;xref:System.String&gt;</ph> as a search parameter and that do not have a <ph id="ph3">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter to make the intent of the method call clear.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The canonical example is the Turkish-I problem.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This casing rule quickly becomes the default for someone programming in such a culture.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This behavior occurs in the Azerbaijani ("az") culture as well.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A method call such as <ph id="ph1">`IsFileURI("file:")`</ph> returns <ph id="ph2">`true`</ph> if the current culture is U.S. English, but <ph id="ph3">`false`</ph> if the current culture is Turkish.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Ordinal String Operations</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Specifying the <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Methods that are invoked with these <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This is essentially a call to the C runtime <ph id="ph1">`strcmp`</ph> function.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Strings in .NET can contain embedded null characters.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>These characters are ignored when you use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Although string comparison methods disregard embedded null characters, string search methods such as <ph id="ph1">&lt;xref:System.String.Contains%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph5">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> do not.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>However, the strings are not considered equal when you use ordinal comparison, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparisons are the next most conservative approach.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>These comparisons ignore most casing; for example, "windows" matches "Windows".</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When dealing with ASCII characters, this policy is equivalent to <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, except that it ignores the usual ASCII casing.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Casing outside the ASCII range uses the invariant culture's tables.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Therefore, the following comparison:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>is equivalent to (but faster than) this comparison:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>These comparisons are still very fast.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The string behavior of the file system, registry keys and values, and environment variables is best represented by <ph id="ph1">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> use the binary values directly, and are best suited for matching.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>When you are not sure about your comparison settings, use one of these two values.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The results may look odd in most contexts if displayed to users.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Ordinal semantics are the default for <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> overloads that do not include a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> argument (including the equality operator).</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In any case, we recommend that you call an overload that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>String Operations that Use the Invariant Culture</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Comparisons with the invariant culture use the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph> property returned by the static <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons with the invariant culture use the static <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph> property returned by the static <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property for comparison information as well.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Any case differences among these translated characters are ignored.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Comparisons that use <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> work identically on ASCII strings.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>However, <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> makes linguistic decisions that might not be appropriate for strings that have to be interpreted as a set of bytes.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CultureInfo.InvariantCulture.CompareInfo`</ph> object makes the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method interpret certain sets of characters as equivalent.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For example, the following equivalence is valid under the invariant culture:</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>InvariantCulture: a + ̊ = å</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The LATIN SMALL LETTER A character "a"  (\u0061), when it is next to the COMBINING RING ABOVE character "+ " ̊" (\u030a), is interpreted as the LATIN SMALL LETTER A WITH RING ABOVE character "å" (\u00e5).</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>As the following example shows, this behavior differs from ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>On balance, the invariant culture has very few properties that make it useful for comparison.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>One of the few reasons to use <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> for comparison is to persist ordered data for a cross-culturally identical display.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Choosing a StringComparison Member for Your Method Call</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The following table outlines the mapping from semantic string context to a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration member.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Data</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Behavior</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Corresponding System.StringComparison</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>value</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Case-sensitive internal identifiers.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Case-sensitive identifiers in standards such as XML and HTTP.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Case-sensitive security-related settings.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where bytes match exactly.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Case-insensitive internal identifiers.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Case-insensitive identifiers in standards such as XML and HTTP.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>File paths.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Registry keys and values.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Environment variables.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Resource identifiers (for example, handle names).</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Case-insensitive security-related settings.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>A non-linguistic identifier, where case is irrelevant; especially data stored in most Windows system services.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Some persisted, linguistically relevant data.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Display of linguistic data that requires a fixed sort order.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Culturally agnostic data that still is linguistically relevant.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Data displayed to the user.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Most user input.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Data that requires local linguistic customs.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Common String Comparison Methods in .NET</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The following sections describe the methods that are most commonly used for string comparison.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>String.Compare</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Typically, it is the latter, and a <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> comparison should be used instead.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CompareInfo?displayProperty=nameWithType&gt;</ph> class, which is returned by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType&gt;</ph> property, also includes a <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.Compare%2A&gt;</ph> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <ph id="ph4">&lt;xref:System.Globalization.CompareOptions&gt;</ph> flag enumeration.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>String.CompareTo</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This method does not currently offer an overload that specifies a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>It is usually possible to convert this method to the recommended <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> form.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Types that implement the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaces implement this method.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Because it does not offer the option of a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter, implementing types often let the user specify a <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> in their constructor.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`FileName`</ph> class whose class constructor includes a <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is then used in the <ph id="ph2">`FileName.CompareTo`</ph> method.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>String.Equals</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class lets you test for equality by calling either the static or instance <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph> method overloads, or by using the static equality operator.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The overloads and operator use ordinal comparison by default.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>However, we still recommend that you call an overload that explicitly specifies the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>String.ToUpper and String.ToLower</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If so, consider using a case-insensitive comparison.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType&gt;</ph> methods are also available.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> is the standard way to normalize case.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Comparisons made using <ph id="ph1">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> are behaviorally the composition of two calls: calling <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> on both string arguments, and doing a comparison using <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to the method.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Char.ToUpper and Char.ToLower</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>These methods work similarly to the <ph id="ph1">&lt;xref:System.String.ToUpper%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLower%2A?displayProperty=nameWithType&gt;</ph> methods described in the previous section.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>String.StartsWith and String.EndsWith</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>By default, both of these methods perform a culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>String.IndexOf and String.LastIndexOf</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>There is a lack of consistency in how the default overloads of these methods perform comparisons.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>All <ph id="ph1">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> methods that include a <ph id="ph3">&lt;xref:System.Char&gt;</ph> parameter perform an ordinal comparison, but the default <ph id="ph4">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.String.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> methods that include a <ph id="ph6">&lt;xref:System.String&gt;</ph> parameter perform a culture-sensitive comparison.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>If you call the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType&gt;</ph> method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <ph id="ph3">&lt;xref:System.StringComparison&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The overloads that include a <ph id="ph1">&lt;xref:System.Char&gt;</ph> argument do not allow you to specify a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Methods that Perform String Comparison Indirectly</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Some non-string methods that have string comparison as a central operation use the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class includes six static properties that return <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> instances whose <ph id="ph3">&lt;xref:System.StringComparer.Compare%2A?displayProperty=nameWithType&gt;</ph> methods perform the following types of string comparisons:</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Culture-sensitive string comparisons using the current culture.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Case-insensitive comparisons using the current culture.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Culture-insensitive comparisons using the word comparison rules of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Case-insensitive and culture-insensitive comparisons using the word comparison rules of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Case-insensitive ordinal comparison.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object is returned by the <ph id="ph2">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Array.Sort and Array.BinarySearch</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Default interpretation: <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A?displayProperty=nameWithType&gt;</ph> method assumes that the elements in the array to be searched are already sorted.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>To sort any string element in the array, the <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method to order individual elements.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the <ph id="ph1">`Thread.CurrentThread.CurrentCulture`</ph> property.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>If the culture can change between the calls to <ph id="ph1">`StoreNames`</ph> and <ph id="ph2">`DoesNameExist`</ph>, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The change code is reflected in the lines labeled <ph id="ph1">`Line A`</ph> and <ph id="ph2">`Line B`</ph> in the two examples.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, which operates linguistically for better user output but is unaffected by changes in culture.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Collections Example: Hashtable Constructor</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object by passing it the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> object that is returned by the <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Because a class <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> that is derived from <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> implements the <ph id="ph3">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> interface, its <ph id="ph4">&lt;xref:System.Collections.IEqualityComparer.GetHashCode%2A&gt;</ph> method is used to compute the hash code of strings in the hash table.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Displaying and Persisting Formatted Data</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>When you display non-string data such as numbers and dates and times to users, format them by using the user's cultural settings.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>By default, the <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method and the <ph id="ph2">`ToString`</ph> methods of the numeric types and the date and time types use the current thread culture for formatting operations.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>To explicitly specify that the formatting method should use the current culture, you can call an overload of a formatting method that has a <ph id="ph1">`provider`</ph> parameter, such as <ph id="ph2">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, and pass it the <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>You can persist non-string data either as binary data or as formatted data.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>If you choose to save it as formatted data, you should call a formatting method overload that includes a <ph id="ph1">`provider`</ph> parameter and pass it the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The invariant culture provides a consistent format for formatted data that is independent of culture and machine.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations:</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>The properties of a culture on a specific computer can differ from standard values.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>At any time, a user can customize culture-sensitive display settings.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The portability of formatted data across computers is likely to be even more limited.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into Windows operating system updates.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>When formatting conventions change, data that was formatted by using the previous conventions may become unreadable.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The example saves an array of date and time values to a file.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>These are formatted by using the conventions of the English (United States) culture.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The attempt to read two of the data items throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception, and the array of dates now contains two incorrect elements that are equal to <ph id="ph2">&lt;xref:System.DateTime.MinValue&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>However, if you replace the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property with <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> in the calls to <ph id="ph3">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>,   the persisted date and time data is successfully restored, as the following output shows.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Manipulating Strings<ept id="p1">](../../../docs/standard/base-types/manipulating-strings.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>