{"content":"---\ntitle: What's New in C# 7 | C# Guide\ndescription: Get an overview of the new features coming in the upcoming version 7 of the C# language.    \nkeywords: C#, .NET, .NET Core, Latest Features, What's New\nauthor: BillWagner\nms.author: wiwagn\nms.date: 12/21/2016\nms.topic: article\nms.prod: visual-studio-dev-15\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: fd41596d-d0c2-4816-b94d-c4d00a5d0243\n---\n\n# What's new in C# 7\n\nC# 7 adds a number of new features to the C# language:\n* [`out` variables](#out-variables):\n    - You can declare `out` values inline as arguments to the method where they are used.\n* [Tuples](#tuples)\n    - You can create lightweight, unnamed types that contain multiple public fields. Compilers and IDE tools understand the semantics of these types.\n* [Pattern Matching](#pattern-matching)\n    - You can create branching logic based on arbitrary types and values of the members of those types.\n* [`ref` locals and returns](#ref-locals-and-returns)\n    - Method arguments and local variables can be references to other storage.\n* [Local Functions](#local-functions)\n    - You can nest functions inside other functions to limit their scope and visibility.\n* [More expression-bodied members](#more-expression-bodied-members)\n    - The list of members that can be authored using expressions has grown.\n* [`throw` Expressions](#throw-expressions)\n    - You can throw exceptions in code constructs that previously were not allowed because `throw` was a statement. \n* [Generalized async return types](#generalized-async-return-types)\n    - Methods declared with the `async` modifier can return other types in addition to `Task` and `Task<T>`.\n* [Numeric literal syntax improvements](#numeric-literal-syntax-improvements)\n    - New tokens improve readability for numeric constants.\n\nThe remainder of this topic discusses each of the features. For each feature,\nyou'll learn the reasoning behind it. You'll learn the syntax. You'll see\nsome sample scenarios where using the new feature will make you more \nproductive as a developer. \n\n## `out` variables\n\nThe existing syntax that supports `out` parameters has been improved\nin this version.  \n\nPreviously, you would need to separate the declaration of the out variable\nand its initialization into two different statements:\n\n[!code-csharp[OutVariableOldStyle](../../../samples/snippets/csharp/new-in-7/program.cs#03_OutVariableOldStyle \"classic out variable declaration\")]\n\nYou can now declare `out` variables in the argument list of a method call,\nrather than writing a separate declaration statement:\n\n[!code-csharp[OutVariableDeclarations](../../../samples/snippets/csharp/new-in-7/program.cs#01_OutVariableDeclarations \"Out variable declarations\")]\n\nYou may want to specify the type of the `out` variable for clarity,\nas shown above. However, the language does support using an implicitly\ntyped local variable:\n\n[!code-csharp[OutVarVariableDeclarations](../../../samples/snippets/csharp/new-in-7/program.cs#02_OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n* The code is easier to read. \n    - You declare the out variable where you use it, not on another line above.\n* No need to assign an initial value.\n    - By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.\n\nThe most common use for this feature will be the `Try` pattern. In this\npattern, a method returns a `bool` indicating success or failure and an\n`out` variable that provides the result if the method succeeds.\n\nWhen using the `out` variable declaration, the declared variable \"leaks\" into the outer scope of the if statement. This allows you to use the variable afterwards:\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nreturn result;\n```\n\n## Tuples\n\nC# provides a rich syntax for classes and structs that is used to explain\nyour design intent. But sometimes that rich syntax requires extra\nwork with minimal benefit. You may often write methods that need a simple\nstructure containing more than one data element. To support these scenarios\n*tuples* were added to C#. Tuples are lightweight data structures\nthat contain multiple fields to represent the data members.\nThe fields are not validated, and you cannot define your own methods\n\n> [!NOTE]\n> Tuples were available before C# 7 as an API, but had many limitations.\n> Most importantly, the members of these tuples were named \n> `Item1`, `Item2` and so on. The language support enables semantic names\n> for the fields of a Tuple.\n\nYou can create a tuple by assigning each member to a value:\n\n[!code-csharp[UnnamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#04_UnnamedTuple \"Unnamed tuple\")]\n\nThat assignment creates a tuple whose members are `Item1` and `Item2`,\nfollowing the existing @System.Tuple syntax.\nYou can modify that assignment to create a tuple that provides semantic\nnames to each of the members of the tuple:\n\n[!code-csharp[NamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#05_NamedTuple \"Named tuple\")]\n\n> [!NOTE]\n> The new tuples features require the `System.ValueTuple` type. For Visual Studio 2017,\n> you must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery.\n\nThe `namedLetters` tuple contains fields referred to as `Alpha` and\n`Beta`. In a tuple assignment, you can also specify the names of the fields\non the right-hand side of the assignment:\n\n[!code-csharp[ImplicitNamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#06_ImplicitNamedTuple \"Implicitly named tuple\")]\n\nThe language allows you to specify names for the fields on both the\nleft and right-hand side of the assignment:\n\n[!code-csharp[NamedTupleConflict](../../../samples/snippets/csharp/new-in-7/program.cs#07_NamedTupleConflict \"Named tuple conflict\")]\n\nThe line above generates a warning, `CS8123`, telling you that the names on the right\nside of the assignment, `Alpha` and `Beta` are ignored because they conflict\nwith the names on the left side, `First` and `Second`.\n\nThe examples above show the basic syntax to declare tuples. Tuples are\nmost useful as return types for `private` and `internal` methods. Tuples\nprovide a simple syntax for those methods to return multiple discrete values:\nYou save the work of authoring a `class` or a `struct` that\ndefines the type returned. There is no need for creating a new type.\n\nCreating a tuple is more efficient and more productive.\nIt is a simpler, lightweight syntax to define a data structure that carries\nmore than one value. The example method below returns the minimum and maximum\nvalues found in a sequence of integers:\n\n[!code-csharp[TupleReturningMethod](../../../samples/snippets/csharp/new-in-7/program.cs#08_TupleReturningMethod \"Tuple returning method\")]\n\nUsing tuples in this way offers several advantages:\n\n* You save the work of authoring a `class` or a `struct` that defines the type returned. \n* You do not need to create new type.\n* The language enhancements removes the need to call the <xref:System.Tuple.Create``1(``0)> methods.\n\nThe declaration for the method provides the names for the fields of the\ntuple that is returned. When you call the method, the return value is a \ntuple whose fields are `Max` and `Min`:\n\n[!code-csharp[CallingTupleMethod](../../../samples/snippets/csharp/new-in-7/program.cs#09_CallingTupleMethod \"Calling a tuple returning method\")]\n\nThere may be times when you want to unpackage the members of a tuple that\nwere returned from a method.  You can do that by declaring separate variables\nfor each of the values in the tuple. This is called *deconstructing* the tuple:\n\n[!code-csharp[CallingWithDeconstructor](../../../samples/snippets/csharp/new-in-7/program.cs#10_CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<!-- Add wildcards here, if they are in C# 7\n-->\n\nYou can also provide a similar deconstruction for any type in .NET. This is\ndone by writing a `Deconstruct` method as a member of the class. That\n`Deconstruct` method provides a set of `out` arguments for each of the\nproperties you want to extract. Consider\nthis `Point` class that provides a deconstructor method that extracts\nthe `X` and `Y` coordinates:\n\n[!code-csharp[PointWithDeconstruction](../../../samples/snippets/csharp/new-in-7/point.cs#11_PointWithDeconstruction \"Point with deconstruction method\")]\n \nYou can extract the individual fields by assigning a tuple to a `Point`:\n\n[!code-csharp[DeconstructPoint](../../../samples/snippets/csharp/new-in-7/program.cs#12_DeconstructPoint \"Deconstruct a point\")]\n\nYou are not bound by the names defined in the `Deconstruct` method. You\ncan rename the extract variables as part of the assignment:  \n\n[!code-csharp[DeconstructNames](../../../samples/snippets/csharp/new-in-7/program.cs#13_DeconstructNames \"Deconstruct with new names\")]\n\nYou can learn more in depth about tuples in the\n[tuples topic](../tuples.md).\n\n## Pattern matching\n\n*Pattern matching* is a feature that allows you to implement method dispatch on\nproperties other than the type of an object. You're probably already familiar\nwith method dispatch based on the type of an object. In Object Oriented programming,\nvirtual and override methods provide language syntax to implement method dispatching\nbased on an object's type. Base and Derived classes provide different implementations. \nPattern matching expressions extend this concept so that you can easily\nimplement similar dispatch patterns for types and data elements that are\nnot related through an inheritance hierarchy. \n\nPattern matching supports `is` expressions and `switch` expressions. Each\nenables inspecting an object and its properties to determine if that object\nsatisfies the sought pattern. You use the `when` keyword to specify additional\nrules to the pattern.\n\n### `is` expression\n\nThe `is` pattern expression extends the familiar `is` operator to query an object beyond its type.\n\nLet's start with a simple scenario. We'll add capabilities to this scenario\nthat demonstrate how pattern matching expressions make algorithms that work\nwith unrelated types easy. We'll start with a method that computes the sum\nof a number of die rolls:\n\n[!code-csharp[SumDieRolls](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#14_SumDieRolls \"Sum die rolls\")]\n\nYou might quickly find that you need to find the sum of die rolls where\nsome of the rolls are made with more than one die. Part of the input\nsequence may be multiple results instead of a single number:\n\n[!code-csharp[SumDieRollsWithGroups](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#15_SumDieRollsWithGroups \"Sum die rolls with groups\")]\n\nThe `is` pattern expression works quite well in this scenario. As part of\nchecking the type, you write a variable initialization. This creates\na new variable of the validated runtime type.\n\nAs you keep extending these scenarios, you may find that you build more\n`if` and `else if` statements. Once that becomes unwieldy, you'll likely\nwant to switch to `switch` pattern expressions.\n\n### `switch` statement updates\n\nThe *match expression* has a familiar syntax, based on the `switch`\nstatement already part of the C# language. Let's translate the existing code\nto use a match expression before adding new cases: \n\n[!code-csharp[SumUsingSwitch](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#16_SumUsingSwitch \"Sum using switch\")]\n\nThe match expressions have a slightly different syntax than the `is` expressions, where\nyou declare the type and variable at the beginning of the `case` expression.\n\nThe match expressions also support constants. This can save time by\nfactoring out simple cases:\n\n[!code-csharp[SwitchWithConstants](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#17_SwitchWithConstants \"Switch with constants\")]\n\nThe code above adds cases for `0` as a special case of `int`, and `null`\nas a special case when there is no input. This demonstrates one important\nnew feature in switch pattern expressions: the order of the `case`\nexpressions now matters. The `0` case must appear before the general `int`\ncase. Otherwise, the first pattern to match would be the `int` case,\neven when the value is `0`. If you accidentally order match expressions such\nthat a later case has already been handled, the compiler will flag that\nand generate an error.\n\nThis same behavior enables the special case for an empty input sequence.\nYou can see that the case for an `IEnumerable` item that has elements\nmust appear before the general `IEnumerable` case.\n\nThis version has also added a `default` case. The `default` case is always\nevaluated last, regardless of the order it appears in the source. For that\nreason, convention is to put the `default` case last.\n\nFinally, let's add one last `case` for a new style of die. Some games\nuse percentile dice to represent larger ranges of numbers. \n\n> [!NOTE]\n> Two 10-sided percentile dice can represent every number from 0\n> through 99. One die has sides labelled `00`, `10`, `20`, ... `90`. The other\n> die has sides labeled `0`, `1`, `2`, ... `9`. Add the two die values\n> together and you can get every number from 0 through 99.\n\nTo add this kind of die to your collection, first define a type to represent\nthe percentile die:\n\n[!code-csharp[18_PercentileDie](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#18_PercentileDie \"Percentile Die type\")]\n\nThen, add a `case` match expression for the new type:\n\n[!code-csharp[SwitchWithNewTypes](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#19_SwitchWithNewTypes \"Include Percentile Die type\")]\n\nThe new syntax for pattern matching expressions makes it easier to create\ndispatch algorithms based on an object's type, or other properties, using\na clear and concise syntax. Pattern matching expressions enable these\nconstructs on data types that are unrelated by inheritance.\n\nYou can learn more about pattern matching in the topic\ndedicated to [pattern matching in C#](../pattern-matching.md).\n\n## Ref locals and returns\n\nThis feature enables algorithms that use and return references\nto variables defined elsewhere. One example is working with\nlarge matrices, and finding a single location with certain\ncharacteristics. One method would return the two indices for\na single location in the matrix:\n\n[!code-csharp[FindReturningIndices](../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#20_FindReturningIndices \"Find returning indices\")]\n\nThere are many issues with this code. First of all, it's a public\nmethod that's returning a tuple. The language supports this, but\nuser defined types (either classes or structs) are preferred\nfor public APIs.\n\nSecond, this method is returning the indices to the item in the matrix.\nThat leads callers to write code that uses those indices to dereference\nthe matrix and modify a single element:\n\n[!code-csharp[UpdateItemFromIndices](../../../samples/snippets/csharp/new-in-7/program.cs#21_UpdateItemFromIndices \"Update Item From Indices\")]\n\nYou'd rather write a method that returns a *reference*\nto the element of the matrix that you want to change. You could only accomplish\nthis by using unsafe code and returning a pointer to an `int` in previous versions.\n\nLet's walk through a series of changes to demonstrate the ref local feature\nand show how to create a method that returns a reference to internal storage.\nAlong the way, you'll learn the rules of the ref return and ref local feature that\nprotects you from accidentally misusing it.\n\nStart by modifying the `Find` method declaration so that it returns a `ref int`\ninstead of a tuple. Then, modify the return statement so it returns the value\nstored in the matrix instead of the two indices:\n\n```csharp\n// Note that this won't compile. \n// Method declaration indicates ref return,\n// but return statement specifies a value return.\npublic static ref int Find2(int[,] matrix, Func<int, bool> predicate)\n{\n    for (int i = 0; i < matrix.GetLength(0); i++)\n        for (int j = 0; j < matrix.GetLength(1); j++)\n            if (predicate(matrix[i, j]))\n                return matrix[i, j];\n    throw new InvalidOperationException(\"Not found\");\n}\n```\n\nWhen you declare that a method returns a `ref` variable, you must also\nadd the `ref` keyword to each return statement. That indicates return\nby reference, and helps developers reading the code later remember that\nthe method returns by reference:\n\n[!code-csharp[FindReturningRef](../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#22_FindReturningRef \"Find returning by reference\")]\n\nNow that the method returns a reference to the integer value in the\nmatrix, you need to modify where it's called.  The `var` declaration\nmeans that `valItem` is now an `int` rather than a tuple:\n\n[!code-csharp[AssignRefReturnToValue](../../../samples/snippets/csharp/new-in-7/program.cs#23_AssignRefReturnToValue \"Assign ref return to value\")]\n\nThe second `WriteLine` statement in the example above prints out the value `42`,\nnot `24`. The variable `valItem` is an `int`, not a `ref int`. The `var`\nkeyword enables the compiler to specify the type, but will not implicitly\nadd the `ref` modifier. Instead, the value referred to by the `ref return`\nis *copied* to the variable on the left-hand side of the assignment. The\nvariable is not a `ref` local.\n\nIn order to get the result you want, you need to add the `ref` modifier\nto the local variable declaration to make the variable a reference when\nthe return value is a reference:\n\n[!code-csharp[AssignRefReturn](../../../samples/snippets/csharp/new-in-7/program.cs#24_AssignRefReturn \"Assign ref return\")]\n\nNow, the second `WriteLine` statement in the example above will print \nout the value `24`, indicating that the storage in the matrix has been\nmodified. The local variable has been declared with the `ref` modifier,\nand it will take a `ref` return. You must initialize a `ref` variable when\nit is declared, you cannot split the declaration and the initialization.\n\nThe C# language has three other rules that protect you from misusing\nthe `ref` locals and returns:\n\n* You cannot assign a standard method return value to a `ref` local variable.\n    - That disallows statements like `ref int i = sequence.Count();`\n* You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.\n    - That means you cannot return a reference to a local variable or a variable with a similar scope.\n* `ref` locals and returns can't be used with async methods.\n    - The compiler can't know if the referenced variable has been set to its final value when the async method returns.\n\nThe addition of ref locals and ref returns enable algorithms that are more\nefficient by avoiding copying values, or performing dereferencing operations\nmultiple times. \n\n## Local functions\n\nMany designs for classes include methods that are called from only\none location. These additional private methods keep each method small\nand focused. However, they can make it harder to understand a class\nwhen reading it the first time. These methods must be understood\noutside of the context of the single calling location.\n\nFor those designs, *local functions* enable you to declare methods\ninside the context of another method. This makes it easier for readers\nof the class to see that the local method is only called from the context\nin which is it declared.\n\nThere are two very common use cases for local functions: public iterator\nmethods and public async methods. Both types of methods generate\ncode that reports errors later than programmers might expect. In\nthe case of iterator methods, any exceptions are observed only\nwhen calling code that enumerates the returned sequence. In the case\nof async methods, any exceptions are only observed when the returned\n`Task` is awaited.\n\nLet's start with an iterator method:\n\n[!code-csharp[IteratorMethod](../../../samples/snippets/csharp/new-in-7/Iterator.cs#25_IteratorMethod \"Iterator method\")]\n\nExamine the code below that calls the iterator method incorrectly:\n\n[!code-csharp[CallIteratorMethod](../../../samples/snippets/csharp/new-in-7/program.cs#26_CallIteratorMethod \"Call iterator method\")]\n\nThe exception is thrown when `resultSet` is iterated, not when `resultSet` is created.\nIn this contained example, most developers could quickly diagnose the\nproblem. However, in larger codebases, the code that creates an iterator\noften isn't as close to the code that enumerates the result. You can\nrefactor the code so that the public method validates all arguments,\nand a private method generates the enumeration:\n\n[!code-csharp[IteratorMethodRefactored](../../../samples/snippets/csharp/new-in-7/Iterator.cs#27_IteratorMethodRefactored \"Iterator method refactored\")]\n\nThis refactored version will throw exceptions immediately because the public\nmethod is not an iterator method; only the private method uses the\n`yield return` syntax. However, there are potential problems with this\nrefactoring. The private method should only be called from the public\ninterface method, because otherwise all argument validation is skipped.\nReaders of the class must discover this fact by reading the entire class\nand searching for any other references to the `alphabetSubsetImplementation` \nmethod.\n\nYou can make that design intent more clear by declaring the \n`alphabetSubsetImplementation` as a local function inside the public\nAPI method:\n\n[!code-csharp[22_IteratorMethodLocal](../../../samples/snippets/csharp/new-in-7/Iterator.cs#28_IteratorMethodLocal \"Iterator method with local function\")]\n\nThe version above makes it clear that the local method is referenced\nonly in the context of the outer method. The rules for local functions\nalso ensure that a developer can't accidentally call the local function\nfrom another location in the class and bypass the argument validation.\n\nThe same technique can be employed with `async` methods to ensure that\nexceptions arising from argument validation are thrown before the asynchronous\nwork begins:\n\n[!code-csharp[TaskExample](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample \"Task returning method with local function\")]\n\n> [!NOTE]\n> Some of the designs that are supported by local functions\n> could also be accomplished using *lambda expressions*. Those\n> interested can [read more about the differences](../local-functions-vs-lambdas.md)\n\n## More expression-bodied members\n\nC# 6 introduced [expression-bodied members](csharp-6.md#expression-bodied-function-members)\nfor member functions, and read-only properties. C# 7 expands the allowed\nmembers that can be implemented as expressions. In C# 7, you can implement\n*constructors*, *finalizers*, and `get` and `set` accessors on *properties*\nand *indexers*. The following code shows examples of each:\n\n[!code-csharp[ExpressionBodiedMembers](../../../samples/snippets/csharp/new-in-7/expressionmembers.cs#36_ExpressionBodiedEverything \"new expression-bodied members\")]\n\n> [!NOTE]\n> This example does not need a finalizer, but it is shown\n> to demonstrate the syntax. You should not implement a\n> finalizer in your class unless it is necessary to  release\n> unmanaged resources. You should also consider using the\n> @System.Runtime.InteropServices.SafeHandle class instead\n> of managing unmanaged resources directly.\n\nThese new locations for expression-bodied members represent\nan important milestone for the C# language: These features\nwere implemented by community members working on the open-source\n[Roslyn](https://github.com/dotnet/Roslyn) project.\n\n## Throw expressions\n\nIn C#, `throw` has always been a statement. Because `throw` is a statement,\nnot an expression, there were C# constructs where you could not use it. These\nincluded conditional expressions, null coalescing expressions, and some lambda\nexpressions. The addition of expression-bodied members adds more locations\nwhere `throw` expressions would be useful. So that you can write any of these\nconstructs, C# 7 introduces *throw expressions*.\n\nThe syntax is the same as you've always used for `throw` statements. The only difference\nis that now you can place them in new locations, such as in a conditional expression:\n\n[!code-csharp[Throw_ExpressionExample](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#37_Throw_ExpressionExample \"conditional throw expressions\")]\n\nThis features enables using throw expressions in initialization expressions:\n\n[!code-csharp[ThrowInInitialization](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#38_ThrowInInitialization \"conditional throw expressions\")]\n\nPreviously, those initializations would need to be in a constructor, with the\nthrow statements in the body of the constructor:\n\n\n[!code-csharp[ThrowInConstructor](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#39_ThrowInConstructor \"throw statements\")]\n\n> [!NOTE]\n> Both of the preceding constructs will cause exceptions to be thrown during\n> the construction of an object. Those are often difficult to recover from.\n> For that reason, designs that throw exceptions during construction are\n> discouraged.\n\n## Generalized async return types \n\nReturning a `Task` object from async methods can introduce\nperformance bottlenecks in certain paths. `Task` is a reference\ntype, so using it means allocating an object. In cases where a\nmethod declared with the `async` modifier returns a cached result, or\ncompletes synchronously, the extra allocations can become a significant\ntime cost in performance critical sections of code. It can become\nvery costly if those allocations occur in tight loops.\n\nThe new language feature means that async methods may return other\ntypes in addition to `Task`, `Task<T>` and `void`. The returned type\nmust still satisfy the async pattern, meaning a `GetAwaiter` method\nmust be accessible. As one concrete example, the `ValueTask` type\nhas been added to the .NET framework to make use of this new language\nfeature: \n\n[!code-csharp[UsingValueTask](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#30_UsingValueTask \"Using ValueTask\")]\n\n> [!NOTE]\n> You need to add the pre-release NuGet package `System.Threading.Tasks.Extensions`\n> in order to use `ValueTask` in Visual Studio 15 Preview 5.\n\nA simple optimization would be to use `ValueTask` in places where\n`Task` would be used before. However, if you want to perform extra\noptimizations by hand, you can cache results from async work and\nreuse the result in subsequent calls. The `ValueTask` struct has a constructor\nwith a `Task` parameter so that you can construct a `ValueTask` from the\nreturn value of any existing async method:\n\n[!code-csharp[AsyncOptimizedValueTask](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#31_AsyncOptimizedValueTask \"Return async result or cached value\")]\n \nAs with all performance recommendations, you should benchmark\nboth versions before making large scale changes to your code.\n\n## Numeric literal syntax improvements\n\nMisreading numeric constants can make it harder to understand\ncode when reading it for the first time. This often\noccurs when those numbers are used as bit masks or other symbolic\nrather than numeric values. C# 7 includes two new features to\nmake it easier to write numbers in the most readable fashion\nfor the intended use: *binary literals*, and *digit separators*.\n\nFor those times when you are creating bit masks, or whenever a\nbinary representation of a number makes the most readable code,\nwrite that number in binary:\n\n[!code-csharp[BinaryConstants](../../../samples/snippets/csharp/new-in-7/Program.cs#32_BinaryConstants \"Binary constants\")]\n\nThe `0b` at the beginning of the constant indicates that the\nnumber is written as a binary number.\n\nBinary numbers can get very long, so it's often easier to see\nthe bit patterns by introducing the `_` as a digit separator:\n\n[!code-csharp[ThousandSeparators](../../../samples/snippets/csharp/new-in-7/Program.cs#33_ThousandSeparators \"Thousands separators\")]\n\nThe digit separator can appear anywhere in the constant. For base 10\nnumbers, it would be common to use it as a thousands separator:\n\n[!code-csharp[LargeIntegers](../../../samples/snippets/csharp/new-in-7/Program.cs#34_LargeIntegers \"Large integer\")]\n\nThe digit separator can be used with `decimal`, `float` and `double`\ntypes as well:\n\n[!code-csharp[OtherConstants](../../../samples/snippets/csharp/new-in-7/Program.cs#35_OtherConstants \"non-integral constants\")]\n\nTaken together, you can declare numeric constants with much more\nreadability.\n","nodes":[{"pos":[11,40],"content":"What's New in C# 7 | C# Guide","needQuote":true,"needEscape":true,"nodes":[{"content":"What's New in C# 7 | C# Guide","pos":[0,29]}]},{"pos":[54,142],"content":"Get an overview of the new features coming in the upcoming version 7 of the C# language.","needQuote":true,"needEscape":true,"nodes":[{"content":"Get an overview of the new features coming in the upcoming version 7 of the C# language.","pos":[0,88]}]},{"pos":[157,205],"content":"C#, .NET, .NET Core, Latest Features, What's New","needQuote":true,"needEscape":true,"nodes":[{"content":"C#, .NET, .NET Core, Latest Features, What's New","pos":[0,48]}]},{"pos":[416,434],"content":"What's new in C# 7","linkify":"What's new in C# 7","nodes":[{"content":"What's new in C# 7","pos":[0,18]}]},{"content":"C# 7 adds a number of new features to the C# language:","pos":[436,490]},{"pos":[493,527],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`out`</ph> variables<ept id=\"p1\">](#out-variables)</ept>:","source":"[`out` variables](#out-variables):"},{"pos":[534,617],"content":"You can declare <ph id=\"ph1\">`out`</ph> values inline as arguments to the method where they are used.","source":"You can declare `out` values inline as arguments to the method where they are used."},{"pos":[620,637],"content":"<bpt id=\"p1\">[</bpt>Tuples<ept id=\"p1\">](#tuples)</ept>","source":"[Tuples](#tuples)"},{"content":"You can create lightweight, unnamed types that contain multiple public fields.","pos":[644,722]},{"content":"Compilers and IDE tools understand the semantics of these types.","pos":[723,787]},{"pos":[790,827],"content":"<bpt id=\"p1\">[</bpt>Pattern Matching<ept id=\"p1\">](#pattern-matching)</ept>","source":"[Pattern Matching](#pattern-matching)"},{"content":"You can create branching logic based on arbitrary types and values of the members of those types.","pos":[834,931]},{"pos":[934,985],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`ref`</ph> locals and returns<ept id=\"p1\">](#ref-locals-and-returns)</ept>","source":"[`ref` locals and returns](#ref-locals-and-returns)"},{"content":"Method arguments and local variables can be references to other storage.","pos":[992,1064]},{"pos":[1067,1102],"content":"<bpt id=\"p1\">[</bpt>Local Functions<ept id=\"p1\">](#local-functions)</ept>","source":"[Local Functions](#local-functions)"},{"content":"You can nest functions inside other functions to limit their scope and visibility.","pos":[1109,1191]},{"pos":[1194,1259],"content":"<bpt id=\"p1\">[</bpt>More expression-bodied members<ept id=\"p1\">](#more-expression-bodied-members)</ept>","source":"[More expression-bodied members](#more-expression-bodied-members)"},{"content":"The list of members that can be authored using expressions has grown.","pos":[1266,1335]},{"pos":[1338,1379],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`throw`</ph> Expressions<ept id=\"p1\">](#throw-expressions)</ept>","source":"[`throw` Expressions](#throw-expressions)"},{"pos":[1386,1495],"content":"You can throw exceptions in code constructs that previously were not allowed because <ph id=\"ph1\">`throw`</ph> was a statement.","source":"You can throw exceptions in code constructs that previously were not allowed because `throw` was a statement."},{"pos":[1499,1564],"content":"<bpt id=\"p1\">[</bpt>Generalized async return types<ept id=\"p1\">](#generalized-async-return-types)</ept>","source":"[Generalized async return types](#generalized-async-return-types)"},{"pos":[1571,1673],"content":"Methods declared with the <ph id=\"ph1\">`async`</ph> modifier can return other types in addition to <ph id=\"ph2\">`Task`</ph> and <ph id=\"ph3\">`Task&lt;T&gt;`</ph>.","source":"Methods declared with the `async` modifier can return other types in addition to `Task` and `Task<T>`."},{"pos":[1676,1751],"content":"<bpt id=\"p1\">[</bpt>Numeric literal syntax improvements<ept id=\"p1\">](#numeric-literal-syntax-improvements)</ept>","source":"[Numeric literal syntax improvements](#numeric-literal-syntax-improvements)"},{"content":"New tokens improve readability for numeric constants.","pos":[1758,1811]},{"content":"The remainder of this topic discusses each of the features.","pos":[1813,1872]},{"content":"For each feature, you'll learn the reasoning behind it.","pos":[1873,1928],"source":" For each feature,\nyou'll learn the reasoning behind it."},{"content":"You'll learn the syntax.","pos":[1929,1953]},{"content":"You'll see some sample scenarios where using the new feature will make you more productive as a developer.","pos":[1954,2061],"source":" You'll see\nsome sample scenarios where using the new feature will make you more \nproductive as a developer."},{"pos":[2067,2082],"content":"<ph id=\"ph1\">`out`</ph> variables","linkify":"`out` variables","source":"`out` variables"},{"pos":[2084,2169],"content":"The existing syntax that supports <ph id=\"ph1\">`out`</ph> parameters has been improved in this version.","source":"The existing syntax that supports `out` parameters has been improved\nin this version."},{"pos":[2173,2301],"content":"Previously, you would need to separate the declaration of the out variable and its initialization into two different statements:","source":"Previously, you would need to separate the declaration of the out variable\nand its initialization into two different statements:"},{"pos":[2303,2450],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>OutVariableOldStyle<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#03_OutVariableOldStyle \"</bpt>classic out variable declaration<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[OutVariableOldStyle](../../../samples/snippets/csharp/new-in-7/program.cs#03_OutVariableOldStyle \"classic out variable declaration\")]"},{"pos":[2452,2580],"content":"You can now declare <ph id=\"ph1\">`out`</ph> variables in the argument list of a method call, rather than writing a separate declaration statement:","source":"You can now declare `out` variables in the argument list of a method call,\nrather than writing a separate declaration statement:"},{"pos":[2582,2730],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>OutVariableDeclarations<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#01_OutVariableDeclarations \"</bpt>Out variable declarations<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[OutVariableDeclarations](../../../samples/snippets/csharp/new-in-7/program.cs#01_OutVariableDeclarations \"Out variable declarations\")]"},{"content":"You may want to specify the type of the <ph id=\"ph1\">`out`</ph> variable for clarity, as shown above.","pos":[2732,2815],"source":"You may want to specify the type of the `out` variable for clarity,\nas shown above."},{"content":"However, the language does support using an implicitly typed local variable:","pos":[2816,2892],"source":" However, the language does support using an implicitly\ntyped local variable:"},{"pos":[2894,3052],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>OutVarVariableDeclarations<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#02_OutVarVariableDeclarations \"</bpt>Implicitly typed Out variable<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[OutVarVariableDeclarations](../../../samples/snippets/csharp/new-in-7/program.cs#02_OutVarVariableDeclarations \"Implicitly typed Out variable\")]"},{"content":"The code is easier to read.","pos":[3056,3083]},{"content":"You declare the out variable where you use it, not on another line above.","pos":[3091,3164]},{"content":"No need to assign an initial value.","pos":[3167,3202]},{"pos":[3209,3328],"content":"By declaring the <ph id=\"ph1\">`out`</ph> variable where it is used in a method call, you can't accidentally use it before it is assigned.","source":"By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned."},{"content":"The most common use for this feature will be the <ph id=\"ph1\">`Try`</ph> pattern.","pos":[3330,3393],"source":"The most common use for this feature will be the `Try` pattern."},{"content":"In this pattern, a method returns a <ph id=\"ph1\">`bool`</ph> indicating success or failure and an <ph id=\"ph2\">`out`</ph> variable that provides the result if the method succeeds.","pos":[3394,3537],"source":" In this\npattern, a method returns a `bool` indicating success or failure and an\n`out` variable that provides the result if the method succeeds."},{"content":"When using the <ph id=\"ph1\">`out`</ph> variable declaration, the declared variable \"leaks\" into the outer scope of the if statement.","pos":[3539,3653],"source":"When using the `out` variable declaration, the declared variable \"leaks\" into the outer scope of the if statement."},{"content":"This allows you to use the variable afterwards:","pos":[3654,3701]},{"pos":[3804,3810],"content":"Tuples","linkify":"Tuples","nodes":[{"content":"Tuples","pos":[0,6]}]},{"content":"C# provides a rich syntax for classes and structs that is used to explain your design intent.","pos":[3812,3905],"source":"C# provides a rich syntax for classes and structs that is used to explain\nyour design intent."},{"content":"But sometimes that rich syntax requires extra work with minimal benefit.","pos":[3906,3978],"source":" But sometimes that rich syntax requires extra\nwork with minimal benefit."},{"content":"You may often write methods that need a simple structure containing more than one data element.","pos":[3979,4074],"source":" You may often write methods that need a simple\nstructure containing more than one data element."},{"content":"To support these scenarios <bpt id=\"p1\">*</bpt>tuples<ept id=\"p1\">*</ept> were added to C#.","pos":[4075,4128],"source":" To support these scenarios\n*tuples* were added to C#."},{"content":"Tuples are lightweight data structures that contain multiple fields to represent the data members.","pos":[4129,4227],"source":" Tuples are lightweight data structures\nthat contain multiple fields to represent the data members."},{"content":"The fields are not validated, and you cannot define your own methods","pos":[4228,4296],"source":"\nThe fields are not validated, and you cannot define your own methods"},{"pos":[4300,4543],"content":"[!NOTE]\nTuples were available before C# 7 as an API, but had many limitations.\nMost importantly, the members of these tuples were named \n`Item1`, `Item2` and so on. The language support enables semantic names\nfor the fields of a Tuple.","leadings":["","> ","> ","> ","> "],"nodes":[{"content":"Tuples were available before C# 7 as an API, but had many limitations.\nMost importantly, the members of these tuples were named \n`Item1`, `Item2` and so on. The language support enables semantic names\nfor the fields of a Tuple.","pos":[8,235],"nodes":[{"content":"Tuples were available before C# 7 as an API, but had many limitations.","pos":[0,70]},{"content":"Most importantly, the members of these tuples were named <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph> and so on.","pos":[71,156],"source":"\nMost importantly, the members of these tuples were named \n`Item1`, `Item2` and so on."},{"content":"The language support enables semantic names for the fields of a Tuple.","pos":[157,227],"source":" The language support enables semantic names\nfor the fields of a Tuple."}]}]},{"content":"You can create a tuple by assigning each member to a value:","pos":[4545,4604]},{"pos":[4606,4720],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UnnamedTuple<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#04_UnnamedTuple \"</bpt>Unnamed tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UnnamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#04_UnnamedTuple \"Unnamed tuple\")]"},{"content":"That assignment creates a tuple whose members are <ph id=\"ph1\">`Item1`</ph> and <ph id=\"ph2\">`Item2`</ph>, following the existing <ph id=\"ph3\">@System.Tuple</ph> syntax.","pos":[4722,4837],"source":"That assignment creates a tuple whose members are `Item1` and `Item2`,\nfollowing the existing @System.Tuple syntax."},{"content":"You can modify that assignment to create a tuple that provides semantic names to each of the members of the tuple:","pos":[4838,4952],"source":"\nYou can modify that assignment to create a tuple that provides semantic\nnames to each of the members of the tuple:"},{"pos":[4954,5062],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>NamedTuple<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#05_NamedTuple \"</bpt>Named tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[NamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#05_NamedTuple \"Named tuple\")]"},{"pos":[5066,5298],"content":"[!NOTE]\nThe new tuples features require the `System.ValueTuple` type. For Visual Studio 2017,\nyou must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery.","leadings":["","> ","> "],"nodes":[{"content":"The new tuples features require the `System.ValueTuple` type. For Visual Studio 2017,\nyou must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery.","pos":[8,228],"nodes":[{"content":"The new tuples features require the <ph id=\"ph1\">`System.ValueTuple`</ph> type.","pos":[0,61],"source":"The new tuples features require the `System.ValueTuple` type."},{"content":"For Visual Studio 2017, you must add the NuGet package <bpt id=\"p1\">[</bpt>System.ValueTuple<ept id=\"p1\">](https://www.nuget.org/packages/System.ValueTuple/)</ept>, available on the NuGet Gallery.","pos":[62,220],"source":" For Visual Studio 2017,\nyou must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery."}]}]},{"content":"The <ph id=\"ph1\">`namedLetters`</ph> tuple contains fields referred to as <ph id=\"ph2\">`Alpha`</ph> and <ph id=\"ph3\">`Beta`</ph>.","pos":[5300,5375],"source":"The `namedLetters` tuple contains fields referred to as `Alpha` and\n`Beta`."},{"content":"In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:","pos":[5376,5485],"source":" In a tuple assignment, you can also specify the names of the fields\non the right-hand side of the assignment:"},{"pos":[5487,5622],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ImplicitNamedTuple<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#06_ImplicitNamedTuple \"</bpt>Implicitly named tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ImplicitNamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#06_ImplicitNamedTuple \"Implicitly named tuple\")]"},{"pos":[5624,5735],"content":"The language allows you to specify names for the fields on both the left and right-hand side of the assignment:","source":"The language allows you to specify names for the fields on both the\nleft and right-hand side of the assignment:"},{"pos":[5737,5870],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>NamedTupleConflict<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#07_NamedTupleConflict \"</bpt>Named tuple conflict<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[NamedTupleConflict](../../../samples/snippets/csharp/new-in-7/program.cs#07_NamedTupleConflict \"Named tuple conflict\")]"},{"pos":[5872,6089],"content":"The line above generates a warning, <ph id=\"ph1\">`CS8123`</ph>, telling you that the names on the right side of the assignment, <ph id=\"ph2\">`Alpha`</ph> and <ph id=\"ph3\">`Beta`</ph> are ignored because they conflict with the names on the left side, <ph id=\"ph4\">`First`</ph> and <ph id=\"ph5\">`Second`</ph>.","source":"The line above generates a warning, `CS8123`, telling you that the names on the right\nside of the assignment, `Alpha` and `Beta` are ignored because they conflict\nwith the names on the left side, `First` and `Second`."},{"content":"The examples above show the basic syntax to declare tuples.","pos":[6091,6150]},{"content":"Tuples are most useful as return types for <ph id=\"ph1\">`private`</ph> and <ph id=\"ph2\">`internal`</ph> methods.","pos":[6151,6227],"source":" Tuples are\nmost useful as return types for `private` and `internal` methods."},{"content":"Tuples provide a simple syntax for those methods to return multiple discrete values: You save the work of authoring a <ph id=\"ph1\">`class`</ph> or a <ph id=\"ph2\">`struct`</ph> that defines the type returned.","pos":[6228,6399],"source":" Tuples\nprovide a simple syntax for those methods to return multiple discrete values:\nYou save the work of authoring a `class` or a `struct` that\ndefines the type returned."},{"content":"There is no need for creating a new type.","pos":[6400,6441]},{"content":"Creating a tuple is more efficient and more productive.","pos":[6443,6498]},{"content":"It is a simpler, lightweight syntax to define a data structure that carries more than one value.","pos":[6499,6595],"source":"\nIt is a simpler, lightweight syntax to define a data structure that carries\nmore than one value."},{"content":"The example method below returns the minimum and maximum values found in a sequence of integers:","pos":[6596,6692],"source":" The example method below returns the minimum and maximum\nvalues found in a sequence of integers:"},{"pos":[6694,6833],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TupleReturningMethod<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#08_TupleReturningMethod \"</bpt>Tuple returning method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TupleReturningMethod](../../../samples/snippets/csharp/new-in-7/program.cs#08_TupleReturningMethod \"Tuple returning method\")]"},{"content":"Using tuples in this way offers several advantages:","pos":[6835,6886]},{"pos":[6890,6976],"content":"You save the work of authoring a <ph id=\"ph1\">`class`</ph> or a <ph id=\"ph2\">`struct`</ph> that defines the type returned.","source":"You save the work of authoring a `class` or a `struct` that defines the type returned."},{"content":"You do not need to create new type.","pos":[6980,7015]},{"pos":[7018,7116],"content":"The language enhancements removes the need to call the &lt;xref:System.Tuple.Create<ph id=\"ph1\">``1(``</ph>0)&gt; methods.","source":"The language enhancements removes the need to call the <xref:System.Tuple.Create``1(``0)> methods."},{"content":"The declaration for the method provides the names for the fields of the tuple that is returned.","pos":[7118,7213],"source":"The declaration for the method provides the names for the fields of the\ntuple that is returned."},{"content":"When you call the method, the return value is a tuple whose fields are <ph id=\"ph1\">`Max`</ph> and <ph id=\"ph2\">`Min`</ph>:","pos":[7214,7302],"source":" When you call the method, the return value is a \ntuple whose fields are `Max` and `Min`:"},{"pos":[7304,7449],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CallingTupleMethod<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#09_CallingTupleMethod \"</bpt>Calling a tuple returning method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[CallingTupleMethod](../../../samples/snippets/csharp/new-in-7/program.cs#09_CallingTupleMethod \"Calling a tuple returning method\")]"},{"content":"There may be times when you want to unpackage the members of a tuple that were returned from a method.","pos":[7451,7553],"source":"There may be times when you want to unpackage the members of a tuple that\nwere returned from a method."},{"content":"You can do that by declaring separate variables for each of the values in the tuple.","pos":[7555,7639],"source":"  You can do that by declaring separate variables\nfor each of the values in the tuple."},{"content":"This is called <bpt id=\"p1\">*</bpt>deconstructing<ept id=\"p1\">*</ept> the tuple:","pos":[7640,7682],"source":" This is called *deconstructing* the tuple:"},{"pos":[7684,7831],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CallingWithDeconstructor<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#10_CallingWithDeconstructor \"</bpt>Deconstructing a tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[CallingWithDeconstructor](../../../samples/snippets/csharp/new-in-7/program.cs#10_CallingWithDeconstructor \"Deconstructing a tuple\")]"},{"content":"You can also provide a similar deconstruction for any type in .NET.","pos":[7883,7950]},{"content":"This is done by writing a <ph id=\"ph1\">`Deconstruct`</ph> method as a member of the class.","pos":[7951,8023],"source":" This is\ndone by writing a `Deconstruct` method as a member of the class."},{"content":"That <ph id=\"ph1\">`Deconstruct`</ph> method provides a set of <ph id=\"ph2\">`out`</ph> arguments for each of the properties you want to extract.","pos":[8024,8131],"source":" That\n`Deconstruct` method provides a set of `out` arguments for each of the\nproperties you want to extract."},{"content":"Consider this <ph id=\"ph1\">`Point`</ph> class that provides a deconstructor method that extracts the <ph id=\"ph2\">`X`</ph> and <ph id=\"ph3\">`Y`</ph> coordinates:","pos":[8132,8239],"source":" Consider\nthis `Point` class that provides a deconstructor method that extracts\nthe `X` and `Y` coordinates:"},{"pos":[8241,8394],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PointWithDeconstruction<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/point.cs#11_PointWithDeconstruction \"</bpt>Point with deconstruction method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[PointWithDeconstruction](../../../samples/snippets/csharp/new-in-7/point.cs#11_PointWithDeconstruction \"Point with deconstruction method\")]"},{"pos":[8397,8469],"content":"You can extract the individual fields by assigning a tuple to a <ph id=\"ph1\">`Point`</ph>:","source":"You can extract the individual fields by assigning a tuple to a `Point`:"},{"pos":[8471,8599],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DeconstructPoint<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#12_DeconstructPoint \"</bpt>Deconstruct a point<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[DeconstructPoint](../../../samples/snippets/csharp/new-in-7/program.cs#12_DeconstructPoint \"Deconstruct a point\")]"},{"content":"You are not bound by the names defined in the <ph id=\"ph1\">`Deconstruct`</ph> method.","pos":[8601,8668],"source":"You are not bound by the names defined in the `Deconstruct` method."},{"content":"You can rename the extract variables as part of the assignment:","pos":[8669,8732],"source":" You\ncan rename the extract variables as part of the assignment:"},{"pos":[8736,8871],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DeconstructNames<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#13_DeconstructNames \"</bpt>Deconstruct with new names<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[DeconstructNames](../../../samples/snippets/csharp/new-in-7/program.cs#13_DeconstructNames \"Deconstruct with new names\")]"},{"pos":[8873,8950],"content":"You can learn more in depth about tuples in the <bpt id=\"p1\">[</bpt>tuples topic<ept id=\"p1\">](../tuples.md)</ept>.","source":"You can learn more in depth about tuples in the\n[tuples topic](../tuples.md)."},{"pos":[8955,8971],"content":"Pattern matching","linkify":"Pattern matching","nodes":[{"content":"Pattern matching","pos":[0,16]}]},{"content":"<bpt id=\"p1\">*</bpt>Pattern matching<ept id=\"p1\">*</ept> is a feature that allows you to implement method dispatch on properties other than the type of an object.","pos":[8973,9097],"source":"*Pattern matching* is a feature that allows you to implement method dispatch on\nproperties other than the type of an object."},{"content":"You're probably already familiar with method dispatch based on the type of an object.","pos":[9098,9183],"source":" You're probably already familiar\nwith method dispatch based on the type of an object."},{"content":"In Object Oriented programming, virtual and override methods provide language syntax to implement method dispatching based on an object's type.","pos":[9184,9327],"source":" In Object Oriented programming,\nvirtual and override methods provide language syntax to implement method dispatching\nbased on an object's type."},{"content":"Base and Derived classes provide different implementations.","pos":[9328,9387]},{"content":"Pattern matching expressions extend this concept so that you can easily implement similar dispatch patterns for types and data elements that are not related through an inheritance hierarchy.","pos":[9388,9579],"source":" \nPattern matching expressions extend this concept so that you can easily\nimplement similar dispatch patterns for types and data elements that are\nnot related through an inheritance hierarchy."},{"content":"Pattern matching supports <ph id=\"ph1\">`is`</ph> expressions and <ph id=\"ph2\">`switch`</ph> expressions.","pos":[9582,9650],"source":"Pattern matching supports `is` expressions and `switch` expressions."},{"content":"Each enables inspecting an object and its properties to determine if that object satisfies the sought pattern.","pos":[9651,9761],"source":" Each\nenables inspecting an object and its properties to determine if that object\nsatisfies the sought pattern."},{"content":"You use the <ph id=\"ph1\">`when`</ph> keyword to specify additional rules to the pattern.","pos":[9762,9832],"source":" You use the `when` keyword to specify additional\nrules to the pattern."},{"pos":[9838,9853],"content":"<ph id=\"ph1\">`is`</ph> expression","linkify":"`is` expression","source":"`is` expression"},{"pos":[9855,9953],"content":"The <ph id=\"ph1\">`is`</ph> pattern expression extends the familiar <ph id=\"ph2\">`is`</ph> operator to query an object beyond its type.","source":"The `is` pattern expression extends the familiar `is` operator to query an object beyond its type."},{"content":"Let's start with a simple scenario.","pos":[9955,9990]},{"content":"We'll add capabilities to this scenario that demonstrate how pattern matching expressions make algorithms that work with unrelated types easy.","pos":[9991,10133],"source":" We'll add capabilities to this scenario\nthat demonstrate how pattern matching expressions make algorithms that work\nwith unrelated types easy."},{"content":"We'll start with a method that computes the sum of a number of die rolls:","pos":[10134,10207],"source":" We'll start with a method that computes the sum\nof a number of die rolls:"},{"pos":[10209,10326],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SumDieRolls<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#14_SumDieRolls \"</bpt>Sum die rolls<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SumDieRolls](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#14_SumDieRolls \"Sum die rolls\")]"},{"content":"You might quickly find that you need to find the sum of die rolls where some of the rolls are made with more than one die.","pos":[10328,10450],"source":"You might quickly find that you need to find the sum of die rolls where\nsome of the rolls are made with more than one die."},{"content":"Part of the input sequence may be multiple results instead of a single number:","pos":[10451,10529],"source":" Part of the input\nsequence may be multiple results instead of a single number:"},{"pos":[10531,10680],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SumDieRollsWithGroups<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#15_SumDieRollsWithGroups \"</bpt>Sum die rolls with groups<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SumDieRollsWithGroups](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#15_SumDieRollsWithGroups \"Sum die rolls with groups\")]"},{"content":"The <ph id=\"ph1\">`is`</ph> pattern expression works quite well in this scenario.","pos":[10682,10744],"source":"The `is` pattern expression works quite well in this scenario."},{"content":"As part of checking the type, you write a variable initialization.","pos":[10745,10811],"source":" As part of\nchecking the type, you write a variable initialization."},{"content":"This creates a new variable of the validated runtime type.","pos":[10812,10870],"source":" This creates\na new variable of the validated runtime type."},{"content":"As you keep extending these scenarios, you may find that you build more <ph id=\"ph1\">`if`</ph> and <ph id=\"ph2\">`else if`</ph> statements.","pos":[10872,10974],"source":"As you keep extending these scenarios, you may find that you build more\n`if` and `else if` statements."},{"content":"Once that becomes unwieldy, you'll likely want to switch to <ph id=\"ph1\">`switch`</ph> pattern expressions.","pos":[10975,11064],"source":" Once that becomes unwieldy, you'll likely\nwant to switch to `switch` pattern expressions."},{"pos":[11070,11096],"content":"<ph id=\"ph1\">`switch`</ph> statement updates","linkify":"`switch` statement updates","source":"`switch` statement updates"},{"content":"The <bpt id=\"p1\">*</bpt>match expression<ept id=\"p1\">*</ept> has a familiar syntax, based on the <ph id=\"ph1\">`switch`</ph> statement already part of the C# language.","pos":[11098,11208],"source":"The *match expression* has a familiar syntax, based on the `switch`\nstatement already part of the C# language."},{"content":"Let's translate the existing code to use a match expression before adding new cases:","pos":[11209,11293],"source":" Let's translate the existing code\nto use a match expression before adding new cases:"},{"pos":[11296,11422],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SumUsingSwitch<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#16_SumUsingSwitch \"</bpt>Sum using switch<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SumUsingSwitch](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#16_SumUsingSwitch \"Sum using switch\")]"},{"pos":[11424,11588],"content":"The match expressions have a slightly different syntax than the <ph id=\"ph1\">`is`</ph> expressions, where you declare the type and variable at the beginning of the <ph id=\"ph2\">`case`</ph> expression.","source":"The match expressions have a slightly different syntax than the `is` expressions, where\nyou declare the type and variable at the beginning of the `case` expression."},{"content":"The match expressions also support constants.","pos":[11590,11635]},{"content":"This can save time by factoring out simple cases:","pos":[11636,11685],"source":" This can save time by\nfactoring out simple cases:"},{"pos":[11687,11828],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SwitchWithConstants<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#17_SwitchWithConstants \"</bpt>Switch with constants<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SwitchWithConstants](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#17_SwitchWithConstants \"Switch with constants\")]"},{"content":"The code above adds cases for <ph id=\"ph1\">`0`</ph> as a special case of <ph id=\"ph2\">`int`</ph>, and <ph id=\"ph3\">`null`</ph> as a special case when there is no input.","pos":[11830,11944],"source":"The code above adds cases for `0` as a special case of `int`, and `null`\nas a special case when there is no input."},{"content":"This demonstrates one important new feature in switch pattern expressions: the order of the <ph id=\"ph1\">`case`</ph> expressions now matters.","pos":[11945,12068],"source":" This demonstrates one important\nnew feature in switch pattern expressions: the order of the `case`\nexpressions now matters."},{"content":"The <ph id=\"ph1\">`0`</ph> case must appear before the general <ph id=\"ph2\">`int`</ph> case.","pos":[12069,12124],"source":" The `0` case must appear before the general `int`\ncase."},{"content":"Otherwise, the first pattern to match would be the <ph id=\"ph1\">`int`</ph> case, even when the value is <ph id=\"ph2\">`0`</ph>.","pos":[12125,12215],"source":" Otherwise, the first pattern to match would be the `int` case,\neven when the value is `0`."},{"content":"If you accidentally order match expressions such that a later case has already been handled, the compiler will flag that and generate an error.","pos":[12216,12359],"source":" If you accidentally order match expressions such\nthat a later case has already been handled, the compiler will flag that\nand generate an error."},{"content":"This same behavior enables the special case for an empty input sequence.","pos":[12361,12433]},{"content":"You can see that the case for an <ph id=\"ph1\">`IEnumerable`</ph> item that has elements must appear before the general <ph id=\"ph2\">`IEnumerable`</ph> case.","pos":[12434,12554],"source":"\nYou can see that the case for an `IEnumerable` item that has elements\nmust appear before the general `IEnumerable` case."},{"content":"This version has also added a <ph id=\"ph1\">`default`</ph> case.","pos":[12556,12601],"source":"This version has also added a `default` case."},{"content":"The <ph id=\"ph1\">`default`</ph> case is always evaluated last, regardless of the order it appears in the source.","pos":[12602,12696],"source":" The `default` case is always\nevaluated last, regardless of the order it appears in the source."},{"content":"For that reason, convention is to put the <ph id=\"ph1\">`default`</ph> case last.","pos":[12697,12759],"source":" For that\nreason, convention is to put the `default` case last."},{"content":"Finally, let's add one last <ph id=\"ph1\">`case`</ph> for a new style of die.","pos":[12761,12819],"source":"Finally, let's add one last `case` for a new style of die."},{"content":"Some games use percentile dice to represent larger ranges of numbers.","pos":[12820,12889],"source":" Some games\nuse percentile dice to represent larger ranges of numbers."},{"pos":[12894,13175],"content":"[!NOTE]\nTwo 10-sided percentile dice can represent every number from 0\nthrough 99. One die has sides labelled `00`, `10`, `20`, ... `90`. The other\ndie has sides labeled `0`, `1`, `2`, ... `9`. Add the two die values\ntogether and you can get every number from 0 through 99.","leadings":["","> ","> ","> ","> "],"nodes":[{"content":"Two 10-sided percentile dice can represent every number from 0\nthrough 99. One die has sides labelled `00`, `10`, `20`, ... `90`. The other\ndie has sides labeled `0`, `1`, `2`, ... `9`. Add the two die values\ntogether and you can get every number from 0 through 99.","pos":[8,273],"nodes":[{"content":"Two 10-sided percentile dice can represent every number from 0 through 99.","pos":[0,74],"source":"Two 10-sided percentile dice can represent every number from 0\nthrough 99."},{"content":"One die has sides labelled <ph id=\"ph1\">`00`</ph>, <ph id=\"ph2\">`10`</ph>, <ph id=\"ph3\">`20`</ph>, ... <ph id=\"ph4\">`90`</ph>.","pos":[75,129],"source":" One die has sides labelled `00`, `10`, `20`, ... `90`."},{"content":"The other die has sides labeled <ph id=\"ph1\">`0`</ph>, <ph id=\"ph2\">`1`</ph>, <ph id=\"ph3\">`2`</ph>, ... <ph id=\"ph4\">`9`</ph>.","pos":[130,185],"source":" The other\ndie has sides labeled `0`, `1`, `2`, ... `9`."},{"content":"Add the two die values together and you can get every number from 0 through 99.","pos":[186,265],"source":" Add the two die values\ntogether and you can get every number from 0 through 99."}]}]},{"pos":[13177,13273],"content":"To add this kind of die to your collection, first define a type to represent the percentile die:","source":"To add this kind of die to your collection, first define a type to represent\nthe percentile die:"},{"pos":[13275,13405],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>18_PercentileDie<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#18_PercentileDie \"</bpt>Percentile Die type<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[18_PercentileDie](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#18_PercentileDie \"Percentile Die type\")]"},{"pos":[13407,13460],"content":"Then, add a <ph id=\"ph1\">`case`</ph> match expression for the new type:","source":"Then, add a `case` match expression for the new type:"},{"pos":[13462,13607],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SwitchWithNewTypes<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/patternmatch.cs#19_SwitchWithNewTypes \"</bpt>Include Percentile Die type<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SwitchWithNewTypes](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#19_SwitchWithNewTypes \"Include Percentile Die type\")]"},{"content":"The new syntax for pattern matching expressions makes it easier to create dispatch algorithms based on an object's type, or other properties, using a clear and concise syntax.","pos":[13609,13784],"source":"The new syntax for pattern matching expressions makes it easier to create\ndispatch algorithms based on an object's type, or other properties, using\na clear and concise syntax."},{"content":"Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.","pos":[13785,13886],"source":" Pattern matching expressions enable these\nconstructs on data types that are unrelated by inheritance."},{"pos":[13888,14005],"content":"You can learn more about pattern matching in the topic dedicated to <bpt id=\"p1\">[</bpt>pattern matching in C#<ept id=\"p1\">](../pattern-matching.md)</ept>.","source":"You can learn more about pattern matching in the topic\ndedicated to [pattern matching in C#](../pattern-matching.md)."},{"pos":[14010,14032],"content":"Ref locals and returns","linkify":"Ref locals and returns","nodes":[{"content":"Ref locals and returns","pos":[0,22]}]},{"content":"This feature enables algorithms that use and return references to variables defined elsewhere.","pos":[14034,14128],"source":"This feature enables algorithms that use and return references\nto variables defined elsewhere."},{"content":"One example is working with large matrices, and finding a single location with certain characteristics.","pos":[14129,14232],"source":" One example is working with\nlarge matrices, and finding a single location with certain\ncharacteristics."},{"content":"One method would return the two indices for a single location in the matrix:","pos":[14233,14309],"source":" One method would return the two indices for\na single location in the matrix:"},{"pos":[14311,14455],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>FindReturningIndices<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#20_FindReturningIndices \"</bpt>Find returning indices<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[FindReturningIndices](../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#20_FindReturningIndices \"Find returning indices\")]"},{"content":"There are many issues with this code.","pos":[14457,14494]},{"content":"First of all, it's a public method that's returning a tuple.","pos":[14495,14555],"source":" First of all, it's a public\nmethod that's returning a tuple."},{"content":"The language supports this, but user defined types (either classes or structs) are preferred for public APIs.","pos":[14556,14665],"source":" The language supports this, but\nuser defined types (either classes or structs) are preferred\nfor public APIs."},{"content":"Second, this method is returning the indices to the item in the matrix.","pos":[14667,14738]},{"content":"That leads callers to write code that uses those indices to dereference the matrix and modify a single element:","pos":[14739,14850],"source":"\nThat leads callers to write code that uses those indices to dereference\nthe matrix and modify a single element:"},{"pos":[14852,14995],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UpdateItemFromIndices<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#21_UpdateItemFromIndices \"</bpt>Update Item From Indices<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UpdateItemFromIndices](../../../samples/snippets/csharp/new-in-7/program.cs#21_UpdateItemFromIndices \"Update Item From Indices\")]"},{"content":"You'd rather write a method that returns a <bpt id=\"p1\">*</bpt>reference<ept id=\"p1\">*</ept> to the element of the matrix that you want to change.","pos":[14997,15105],"source":"You'd rather write a method that returns a *reference*\nto the element of the matrix that you want to change."},{"content":"You could only accomplish this by using unsafe code and returning a pointer to an <ph id=\"ph1\">`int`</ph> in previous versions.","pos":[15106,15215],"source":" You could only accomplish\nthis by using unsafe code and returning a pointer to an `int` in previous versions."},{"content":"Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.","pos":[15217,15370],"source":"Let's walk through a series of changes to demonstrate the ref local feature\nand show how to create a method that returns a reference to internal storage."},{"content":"Along the way, you'll learn the rules of the ref return and ref local feature that protects you from accidentally misusing it.","pos":[15371,15497],"source":"\nAlong the way, you'll learn the rules of the ref return and ref local feature that\nprotects you from accidentally misusing it."},{"content":"Start by modifying the <ph id=\"ph1\">`Find`</ph> method declaration so that it returns a <ph id=\"ph2\">`ref int`</ph> instead of a tuple.","pos":[15499,15598],"source":"Start by modifying the `Find` method declaration so that it returns a `ref int`\ninstead of a tuple."},{"content":"Then, modify the return statement so it returns the value stored in the matrix instead of the two indices:","pos":[15599,15705],"source":" Then, modify the return statement so it returns the value\nstored in the matrix instead of the two indices:"},{"content":"When you declare that a method returns a <ph id=\"ph1\">`ref`</ph> variable, you must also add the <ph id=\"ph2\">`ref`</ph> keyword to each return statement.","pos":[16160,16278],"source":"When you declare that a method returns a `ref` variable, you must also\nadd the `ref` keyword to each return statement."},{"content":"That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:","pos":[16279,16405],"source":" That indicates return\nby reference, and helps developers reading the code later remember that\nthe method returns by reference:"},{"pos":[16407,16548],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>FindReturningRef<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#22_FindReturningRef \"</bpt>Find returning by reference<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[FindReturningRef](../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#22_FindReturningRef \"Find returning by reference\")]"},{"content":"Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.","pos":[16550,16663],"source":"Now that the method returns a reference to the integer value in the\nmatrix, you need to modify where it's called."},{"content":"The <ph id=\"ph1\">`var`</ph> declaration means that <ph id=\"ph2\">`valItem`</ph> is now an <ph id=\"ph3\">`int`</ph> rather than a tuple:","pos":[16665,16744],"source":"  The `var` declaration\nmeans that `valItem` is now an `int` rather than a tuple:"},{"pos":[16746,16893],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>AssignRefReturnToValue<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#23_AssignRefReturnToValue \"</bpt>Assign ref return to value<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[AssignRefReturnToValue](../../../samples/snippets/csharp/new-in-7/program.cs#23_AssignRefReturnToValue \"Assign ref return to value\")]"},{"content":"The second <ph id=\"ph1\">`WriteLine`</ph> statement in the example above prints out the value <ph id=\"ph2\">`42`</ph>, not <ph id=\"ph3\">`24`</ph>.","pos":[16895,16985],"source":"The second `WriteLine` statement in the example above prints out the value `42`,\nnot `24`."},{"content":"The variable <ph id=\"ph1\">`valItem`</ph> is an <ph id=\"ph2\">`int`</ph>, not a <ph id=\"ph3\">`ref int`</ph>.","pos":[16986,17038],"source":" The variable `valItem` is an `int`, not a `ref int`."},{"content":"The <ph id=\"ph1\">`var`</ph> keyword enables the compiler to specify the type, but will not implicitly add the <ph id=\"ph2\">`ref`</ph> modifier.","pos":[17039,17146],"source":" The `var`\nkeyword enables the compiler to specify the type, but will not implicitly\nadd the `ref` modifier."},{"content":"Instead, the value referred to by the <ph id=\"ph1\">`ref return`</ph> is <bpt id=\"p1\">*</bpt>copied<ept id=\"p1\">*</ept> to the variable on the left-hand side of the assignment.","pos":[17147,17266],"source":" Instead, the value referred to by the `ref return`\nis *copied* to the variable on the left-hand side of the assignment."},{"content":"The variable is not a <ph id=\"ph1\">`ref`</ph> local.","pos":[17267,17301],"source":" The\nvariable is not a `ref` local."},{"pos":[17303,17479],"content":"In order to get the result you want, you need to add the <ph id=\"ph1\">`ref`</ph> modifier to the local variable declaration to make the variable a reference when the return value is a reference:","source":"In order to get the result you want, you need to add the `ref` modifier\nto the local variable declaration to make the variable a reference when\nthe return value is a reference:"},{"pos":[17481,17605],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>AssignRefReturn<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#24_AssignRefReturn \"</bpt>Assign ref return<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[AssignRefReturn](../../../samples/snippets/csharp/new-in-7/program.cs#24_AssignRefReturn \"Assign ref return\")]"},{"content":"Now, the second <ph id=\"ph1\">`WriteLine`</ph> statement in the example above will print out the value <ph id=\"ph2\">`24`</ph>, indicating that the storage in the matrix has been modified.","pos":[17607,17758],"source":"Now, the second `WriteLine` statement in the example above will print \nout the value `24`, indicating that the storage in the matrix has been\nmodified."},{"content":"The local variable has been declared with the <ph id=\"ph1\">`ref`</ph> modifier, and it will take a <ph id=\"ph2\">`ref`</ph> return.","pos":[17759,17853],"source":" The local variable has been declared with the `ref` modifier,\nand it will take a `ref` return."},{"content":"You must initialize a <ph id=\"ph1\">`ref`</ph> variable when it is declared, you cannot split the declaration and the initialization.","pos":[17854,17968],"source":" You must initialize a `ref` variable when\nit is declared, you cannot split the declaration and the initialization."},{"pos":[17970,18068],"content":"The C# language has three other rules that protect you from misusing the <ph id=\"ph1\">`ref`</ph> locals and returns:","source":"The C# language has three other rules that protect you from misusing\nthe `ref` locals and returns:"},{"pos":[18072,18147],"content":"You cannot assign a standard method return value to a <ph id=\"ph1\">`ref`</ph> local variable.","source":"You cannot assign a standard method return value to a `ref` local variable."},{"pos":[18154,18216],"content":"That disallows statements like <ph id=\"ph1\">`ref int i = sequence.Count();`</ph>","source":"That disallows statements like `ref int i = sequence.Count();`"},{"pos":[18219,18325],"content":"You cannot return a <ph id=\"ph1\">`ref`</ph> to a variable whose lifetime does not extend beyond the execution of the method.","source":"You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method."},{"content":"That means you cannot return a reference to a local variable or a variable with a similar scope.","pos":[18332,18428]},{"pos":[18431,18489],"content":"<ph id=\"ph1\">`ref`</ph> locals and returns can't be used with async methods.","source":"`ref` locals and returns can't be used with async methods."},{"content":"The compiler can't know if the referenced variable has been set to its final value when the async method returns.","pos":[18496,18609]},{"pos":[18611,18778],"content":"The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values, or performing dereferencing operations multiple times.","source":"The addition of ref locals and ref returns enable algorithms that are more\nefficient by avoiding copying values, or performing dereferencing operations\nmultiple times."},{"pos":[18784,18799],"content":"Local functions","linkify":"Local functions","nodes":[{"content":"Local functions","pos":[0,15]}]},{"content":"Many designs for classes include methods that are called from only one location.","pos":[18801,18881],"source":"Many designs for classes include methods that are called from only\none location."},{"content":"These additional private methods keep each method small and focused.","pos":[18882,18950],"source":" These additional private methods keep each method small\nand focused."},{"content":"However, they can make it harder to understand a class when reading it the first time.","pos":[18951,19037],"source":" However, they can make it harder to understand a class\nwhen reading it the first time."},{"content":"These methods must be understood outside of the context of the single calling location.","pos":[19038,19125],"source":" These methods must be understood\noutside of the context of the single calling location."},{"content":"For those designs, <bpt id=\"p1\">*</bpt>local functions<ept id=\"p1\">*</ept> enable you to declare methods inside the context of another method.","pos":[19127,19231],"source":"For those designs, *local functions* enable you to declare methods\ninside the context of another method."},{"content":"This makes it easier for readers of the class to see that the local method is only called from the context in which is it declared.","pos":[19232,19363],"source":" This makes it easier for readers\nof the class to see that the local method is only called from the context\nin which is it declared."},{"content":"There are two very common use cases for local functions: public iterator methods and public async methods.","pos":[19365,19471],"source":"There are two very common use cases for local functions: public iterator\nmethods and public async methods."},{"content":"Both types of methods generate code that reports errors later than programmers might expect.","pos":[19472,19564],"source":" Both types of methods generate\ncode that reports errors later than programmers might expect."},{"content":"In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.","pos":[19565,19687],"source":" In\nthe case of iterator methods, any exceptions are observed only\nwhen calling code that enumerates the returned sequence."},{"content":"In the case of async methods, any exceptions are only observed when the returned <ph id=\"ph1\">`Task`</ph> is awaited.","pos":[19688,19787],"source":" In the case\nof async methods, any exceptions are only observed when the returned\n`Task` is awaited."},{"content":"Let's start with an iterator method:","pos":[19789,19825]},{"pos":[19827,19948],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>IteratorMethod<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Iterator.cs#25_IteratorMethod \"</bpt>Iterator method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[IteratorMethod](../../../samples/snippets/csharp/new-in-7/Iterator.cs#25_IteratorMethod \"Iterator method\")]"},{"content":"Examine the code below that calls the iterator method incorrectly:","pos":[19950,20016]},{"pos":[20018,20151],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CallIteratorMethod<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/program.cs#26_CallIteratorMethod \"</bpt>Call iterator method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[CallIteratorMethod](../../../samples/snippets/csharp/new-in-7/program.cs#26_CallIteratorMethod \"Call iterator method\")]"},{"content":"The exception is thrown when <ph id=\"ph1\">`resultSet`</ph> is iterated, not when <ph id=\"ph2\">`resultSet`</ph> is created.","pos":[20153,20239],"source":"The exception is thrown when `resultSet` is iterated, not when `resultSet` is created."},{"content":"In this contained example, most developers could quickly diagnose the problem.","pos":[20240,20318],"source":"\nIn this contained example, most developers could quickly diagnose the\nproblem."},{"content":"However, in larger codebases, the code that creates an iterator often isn't as close to the code that enumerates the result.","pos":[20319,20443],"source":" However, in larger codebases, the code that creates an iterator\noften isn't as close to the code that enumerates the result."},{"content":"You can refactor the code so that the public method validates all arguments, and a private method generates the enumeration:","pos":[20444,20568],"source":" You can\nrefactor the code so that the public method validates all arguments,\nand a private method generates the enumeration:"},{"pos":[20570,20722],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>IteratorMethodRefactored<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Iterator.cs#27_IteratorMethodRefactored \"</bpt>Iterator method refactored<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[IteratorMethodRefactored](../../../samples/snippets/csharp/new-in-7/Iterator.cs#27_IteratorMethodRefactored \"Iterator method refactored\")]"},{"content":"This refactored version will throw exceptions immediately because the public method is not an iterator method; only the private method uses the <ph id=\"ph1\">`yield return`</ph> syntax.","pos":[20724,20890],"source":"This refactored version will throw exceptions immediately because the public\nmethod is not an iterator method; only the private method uses the\n`yield return` syntax."},{"content":"However, there are potential problems with this refactoring.","pos":[20891,20951],"source":" However, there are potential problems with this\nrefactoring."},{"content":"The private method should only be called from the public interface method, because otherwise all argument validation is skipped.","pos":[20952,21080],"source":" The private method should only be called from the public\ninterface method, because otherwise all argument validation is skipped."},{"content":"Readers of the class must discover this fact by reading the entire class and searching for any other references to the <ph id=\"ph1\">`alphabetSubsetImplementation`</ph> method.","pos":[21081,21239],"source":"\nReaders of the class must discover this fact by reading the entire class\nand searching for any other references to the `alphabetSubsetImplementation` \nmethod."},{"pos":[21241,21382],"content":"You can make that design intent more clear by declaring the <ph id=\"ph1\">`alphabetSubsetImplementation`</ph> as a local function inside the public API method:","source":"You can make that design intent more clear by declaring the \n`alphabetSubsetImplementation` as a local function inside the public\nAPI method:"},{"pos":[21384,21538],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>22_IteratorMethodLocal<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Iterator.cs#28_IteratorMethodLocal \"</bpt>Iterator method with local function<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[22_IteratorMethodLocal](../../../samples/snippets/csharp/new-in-7/Iterator.cs#28_IteratorMethodLocal \"Iterator method with local function\")]"},{"content":"The version above makes it clear that the local method is referenced only in the context of the outer method.","pos":[21540,21649],"source":"The version above makes it clear that the local method is referenced\nonly in the context of the outer method."},{"content":"The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.","pos":[21650,21822],"source":" The rules for local functions\nalso ensure that a developer can't accidentally call the local function\nfrom another location in the class and bypass the argument validation."},{"pos":[21824,21986],"content":"The same technique can be employed with <ph id=\"ph1\">`async`</ph> methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins:","source":"The same technique can be employed with `async` methods to ensure that\nexceptions arising from argument validation are thrown before the asynchronous\nwork begins:"},{"pos":[21988,22130],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TaskExample<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample \"</bpt>Task returning method with local function<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TaskExample](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample \"Task returning method with local function\")]"},{"pos":[22134,22349],"content":"[!NOTE]\nSome of the designs that are supported by local functions\ncould also be accomplished using *lambda expressions*. Those\ninterested can [read more about the differences](../local-functions-vs-lambdas.md)","leadings":["","> ","> ","> "],"nodes":[{"content":"Some of the designs that are supported by local functions\ncould also be accomplished using *lambda expressions*. Those\ninterested can [read more about the differences](../local-functions-vs-lambdas.md)","pos":[8,209],"nodes":[{"content":"Some of the designs that are supported by local functions could also be accomplished using <bpt id=\"p1\">*</bpt>lambda expressions<ept id=\"p1\">*</ept>.","pos":[0,112],"source":"Some of the designs that are supported by local functions\ncould also be accomplished using *lambda expressions*."},{"content":"Those interested can <bpt id=\"p1\">[</bpt>read more about the differences<ept id=\"p1\">](../local-functions-vs-lambdas.md)</ept>","pos":[113,201],"source":" Those\ninterested can [read more about the differences](../local-functions-vs-lambdas.md)"}]}]},{"pos":[22354,22384],"content":"More expression-bodied members","linkify":"More expression-bodied members","nodes":[{"content":"More expression-bodied members","pos":[0,30]}]},{"content":"C# 6 introduced <bpt id=\"p1\">[</bpt>expression-bodied members<ept id=\"p1\">](csharp-6.md#expression-bodied-function-members)</ept> for member functions, and read-only properties.","pos":[22386,22525],"source":"C# 6 introduced [expression-bodied members](csharp-6.md#expression-bodied-function-members)\nfor member functions, and read-only properties."},{"content":"C# 7 expands the allowed members that can be implemented as expressions.","pos":[22526,22598],"source":" C# 7 expands the allowed\nmembers that can be implemented as expressions."},{"content":"In C# 7, you can implement <bpt id=\"p1\">*</bpt>constructors<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>finalizers<ept id=\"p2\">*</ept>, and <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessors on <bpt id=\"p3\">*</bpt>properties<ept id=\"p3\">*</ept> and <bpt id=\"p4\">*</bpt>indexers<ept id=\"p4\">*</ept>.","pos":[22599,22717],"source":" In C# 7, you can implement\n*constructors*, *finalizers*, and `get` and `set` accessors on *properties*\nand *indexers*."},{"content":"The following code shows examples of each:","pos":[22718,22760]},{"pos":[22762,22927],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExpressionBodiedMembers<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/expressionmembers.cs#36_ExpressionBodiedEverything \"</bpt>new expression-bodied members<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ExpressionBodiedMembers](../../../samples/snippets/csharp/new-in-7/expressionmembers.cs#36_ExpressionBodiedEverything \"new expression-bodied members\")]"},{"pos":[22931,23274],"content":"[!NOTE]\nThis example does not need a finalizer, but it is shown\nto demonstrate the syntax. You should not implement a\nfinalizer in your class unless it is necessary to  release\nunmanaged resources. You should also consider using the\n@System.Runtime.InteropServices.SafeHandle class instead\nof managing unmanaged resources directly.","leadings":["","> ","> ","> ","> ","> ","> "],"nodes":[{"content":"This example does not need a finalizer, but it is shown\nto demonstrate the syntax. You should not implement a\nfinalizer in your class unless it is necessary to  release\nunmanaged resources. You should also consider using the\n@System.Runtime.InteropServices.SafeHandle class instead\nof managing unmanaged resources directly.","pos":[8,331],"nodes":[{"content":"This example does not need a finalizer, but it is shown to demonstrate the syntax.","pos":[0,82],"source":"This example does not need a finalizer, but it is shown\nto demonstrate the syntax."},{"content":"You should not implement a finalizer in your class unless it is necessary to  release unmanaged resources.","pos":[83,189],"source":" You should not implement a\nfinalizer in your class unless it is necessary to  release\nunmanaged resources."},{"content":"You should also consider using the <ph id=\"ph1\">@System.Runtime.InteropServices.SafeHandle</ph> class instead of managing unmanaged resources directly.","pos":[190,323],"source":" You should also consider using the\n@System.Runtime.InteropServices.SafeHandle class instead\nof managing unmanaged resources directly."}]}]},{"pos":[23276,23511],"content":"These new locations for expression-bodied members represent an important milestone for the C# language: These features were implemented by community members working on the open-source <bpt id=\"p1\">[</bpt>Roslyn<ept id=\"p1\">](https://github.com/dotnet/Roslyn)</ept> project.","source":"These new locations for expression-bodied members represent\nan important milestone for the C# language: These features\nwere implemented by community members working on the open-source\n[Roslyn](https://github.com/dotnet/Roslyn) project."},{"pos":[23516,23533],"content":"Throw expressions","linkify":"Throw expressions","nodes":[{"content":"Throw expressions","pos":[0,17]}]},{"content":"In C#, <ph id=\"ph1\">`throw`</ph> has always been a statement.","pos":[23535,23578],"source":"In C#, `throw` has always been a statement."},{"content":"Because <ph id=\"ph1\">`throw`</ph> is a statement, not an expression, there were C# constructs where you could not use it.","pos":[23579,23682],"source":" Because `throw` is a statement,\nnot an expression, there were C# constructs where you could not use it."},{"content":"These included conditional expressions, null coalescing expressions, and some lambda expressions.","pos":[23683,23780],"source":" These\nincluded conditional expressions, null coalescing expressions, and some lambda\nexpressions."},{"content":"The addition of expression-bodied members adds more locations where <ph id=\"ph1\">`throw`</ph> expressions would be useful.","pos":[23781,23885],"source":" The addition of expression-bodied members adds more locations\nwhere `throw` expressions would be useful."},{"content":"So that you can write any of these constructs, C# 7 introduces <bpt id=\"p1\">*</bpt>throw expressions<ept id=\"p1\">*</ept>.","pos":[23886,23969],"source":" So that you can write any of these\nconstructs, C# 7 introduces *throw expressions*."},{"content":"The syntax is the same as you've always used for <ph id=\"ph1\">`throw`</ph> statements.","pos":[23971,24039],"source":"The syntax is the same as you've always used for `throw` statements."},{"content":"The only difference is that now you can place them in new locations, such as in a conditional expression:","pos":[24040,24145],"source":" The only difference\nis that now you can place them in new locations, such as in a conditional expression:"},{"pos":[24147,24308],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Throw_ExpressionExample<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#37_Throw_ExpressionExample \"</bpt>conditional throw expressions<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Throw_ExpressionExample](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#37_Throw_ExpressionExample \"conditional throw expressions\")]"},{"content":"This features enables using throw expressions in initialization expressions:","pos":[24310,24386]},{"pos":[24388,24545],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThrowInInitialization<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#38_ThrowInInitialization \"</bpt>conditional throw expressions<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ThrowInInitialization](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#38_ThrowInInitialization \"conditional throw expressions\")]"},{"pos":[24547,24673],"content":"Previously, those initializations would need to be in a constructor, with the throw statements in the body of the constructor:","source":"Previously, those initializations would need to be in a constructor, with the\nthrow statements in the body of the constructor:"},{"pos":[24676,24814],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThrowInConstructor<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#39_ThrowInConstructor \"</bpt>throw statements<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ThrowInConstructor](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#39_ThrowInConstructor \"throw statements\")]"},{"pos":[24818,25066],"content":"[!NOTE]\nBoth of the preceding constructs will cause exceptions to be thrown during\nthe construction of an object. Those are often difficult to recover from.\nFor that reason, designs that throw exceptions during construction are\ndiscouraged.","leadings":["","> ","> ","> ","> "],"nodes":[{"content":"Both of the preceding constructs will cause exceptions to be thrown during\nthe construction of an object. Those are often difficult to recover from.\nFor that reason, designs that throw exceptions during construction are\ndiscouraged.","pos":[8,240],"nodes":[{"content":"Both of the preceding constructs will cause exceptions to be thrown during the construction of an object.","pos":[0,105],"source":"Both of the preceding constructs will cause exceptions to be thrown during\nthe construction of an object."},{"content":"Those are often difficult to recover from.","pos":[106,148]},{"content":"For that reason, designs that throw exceptions during construction are discouraged.","pos":[149,232],"source":"\nFor that reason, designs that throw exceptions during construction are\ndiscouraged."}]}]},{"pos":[25071,25101],"content":"Generalized async return types","linkify":"Generalized async return types","nodes":[{"content":"Generalized async return types","pos":[0,30]}]},{"content":"Returning a <ph id=\"ph1\">`Task`</ph> object from async methods can introduce performance bottlenecks in certain paths.","pos":[25104,25204],"source":"Returning a `Task` object from async methods can introduce\nperformance bottlenecks in certain paths."},{"content":"<ph id=\"ph1\">`Task`</ph> is a reference type, so using it means allocating an object.","pos":[25205,25272],"source":"`Task` is a reference\ntype, so using it means allocating an object."},{"content":"In cases where a method declared with the <ph id=\"ph1\">`async`</ph> modifier returns a cached result, or completes synchronously, the extra allocations can become a significant time cost in performance critical sections of code.","pos":[25273,25483],"source":" In cases where a\nmethod declared with the `async` modifier returns a cached result, or\ncompletes synchronously, the extra allocations can become a significant\ntime cost in performance critical sections of code."},{"content":"It can become very costly if those allocations occur in tight loops.","pos":[25484,25552],"source":" It can become\nvery costly if those allocations occur in tight loops."},{"content":"The new language feature means that async methods may return other types in addition to <ph id=\"ph1\">`Task`</ph>, <ph id=\"ph2\">`Task&lt;T&gt;`</ph> and <ph id=\"ph3\">`void`</ph>.","pos":[25554,25671],"source":"The new language feature means that async methods may return other\ntypes in addition to `Task`, `Task<T>` and `void`."},{"content":"The returned type must still satisfy the async pattern, meaning a <ph id=\"ph1\">`GetAwaiter`</ph> method must be accessible.","pos":[25672,25777],"source":" The returned type\nmust still satisfy the async pattern, meaning a `GetAwaiter` method\nmust be accessible."},{"content":"As one concrete example, the <ph id=\"ph1\">`ValueTask`</ph> type has been added to the .NET framework to make use of this new language feature:","pos":[25778,25902],"source":" As one concrete example, the `ValueTask` type\nhas been added to the .NET framework to make use of this new language\nfeature:"},{"pos":[25905,26027],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UsingValueTask<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#30_UsingValueTask \"</bpt>Using ValueTask<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UsingValueTask](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#30_UsingValueTask \"Using ValueTask\")]"},{"pos":[26031,26183],"content":"[!NOTE]\nYou need to add the pre-release NuGet package `System.Threading.Tasks.Extensions`\nin order to use `ValueTask` in Visual Studio 15 Preview 5.","leadings":["","> ","> "],"nodes":[{"content":"You need to add the pre-release NuGet package <ph id=\"ph1\">`System.Threading.Tasks.Extensions`</ph> in order to use <ph id=\"ph2\">`ValueTask`</ph> in Visual Studio 15 Preview 5.","pos":[8,148],"source":"You need to add the pre-release NuGet package `System.Threading.Tasks.Extensions`\nin order to use `ValueTask` in Visual Studio 15 Preview 5."}]},{"content":"A simple optimization would be to use <ph id=\"ph1\">`ValueTask`</ph> in places where <ph id=\"ph2\">`Task`</ph> would be used before.","pos":[26185,26279],"source":"A simple optimization would be to use `ValueTask` in places where\n`Task` would be used before."},{"content":"However, if you want to perform extra optimizations by hand, you can cache results from async work and reuse the result in subsequent calls.","pos":[26280,26420],"source":" However, if you want to perform extra\noptimizations by hand, you can cache results from async work and\nreuse the result in subsequent calls."},{"content":"The <ph id=\"ph1\">`ValueTask`</ph> struct has a constructor with a <ph id=\"ph2\">`Task`</ph> parameter so that you can construct a <ph id=\"ph3\">`ValueTask`</ph> from the return value of any existing async method:","pos":[26421,26577],"source":" The `ValueTask` struct has a constructor\nwith a `Task` parameter so that you can construct a `ValueTask` from the\nreturn value of any existing async method:"},{"pos":[26579,26739],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>AsyncOptimizedValueTask<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#31_AsyncOptimizedValueTask \"</bpt>Return async result or cached value<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[AsyncOptimizedValueTask](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#31_AsyncOptimizedValueTask \"Return async result or cached value\")]"},{"pos":[26742,26865],"content":"As with all performance recommendations, you should benchmark both versions before making large scale changes to your code.","source":"As with all performance recommendations, you should benchmark\nboth versions before making large scale changes to your code."},{"pos":[26870,26905],"content":"Numeric literal syntax improvements","linkify":"Numeric literal syntax improvements","nodes":[{"content":"Numeric literal syntax improvements","pos":[0,35]}]},{"content":"Misreading numeric constants can make it harder to understand code when reading it for the first time.","pos":[26907,27009],"source":"Misreading numeric constants can make it harder to understand\ncode when reading it for the first time."},{"content":"This often occurs when those numbers are used as bit masks or other symbolic rather than numeric values.","pos":[27010,27114],"source":" This often\noccurs when those numbers are used as bit masks or other symbolic\nrather than numeric values."},{"content":"C# 7 includes two new features to make it easier to write numbers in the most readable fashion for the intended use: <bpt id=\"p1\">*</bpt>binary literals<ept id=\"p1\">*</ept>, and <bpt id=\"p2\">*</bpt>digit separators<ept id=\"p2\">*</ept>.","pos":[27115,27274],"source":" C# 7 includes two new features to\nmake it easier to write numbers in the most readable fashion\nfor the intended use: *binary literals*, and *digit separators*."},{"pos":[27276,27431],"content":"For those times when you are creating bit masks, or whenever a binary representation of a number makes the most readable code, write that number in binary:","source":"For those times when you are creating bit masks, or whenever a\nbinary representation of a number makes the most readable code,\nwrite that number in binary:"},{"pos":[27433,27556],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>BinaryConstants<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Program.cs#32_BinaryConstants \"</bpt>Binary constants<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[BinaryConstants](../../../samples/snippets/csharp/new-in-7/Program.cs#32_BinaryConstants \"Binary constants\")]"},{"pos":[27558,27656],"content":"The <ph id=\"ph1\">`0b`</ph> at the beginning of the constant indicates that the number is written as a binary number.","source":"The `0b` at the beginning of the constant indicates that the\nnumber is written as a binary number."},{"pos":[27658,27781],"content":"Binary numbers can get very long, so it's often easier to see the bit patterns by introducing the <ph id=\"ph1\">`_`</ph> as a digit separator:","source":"Binary numbers can get very long, so it's often easier to see\nthe bit patterns by introducing the `_` as a digit separator:"},{"pos":[27783,27916],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThousandSeparators<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Program.cs#33_ThousandSeparators \"</bpt>Thousands separators<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ThousandSeparators](../../../samples/snippets/csharp/new-in-7/Program.cs#33_ThousandSeparators \"Thousands separators\")]"},{"content":"The digit separator can appear anywhere in the constant.","pos":[27918,27974]},{"content":"For base 10 numbers, it would be common to use it as a thousands separator:","pos":[27975,28050],"source":" For base 10\nnumbers, it would be common to use it as a thousands separator:"},{"pos":[28052,28168],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>LargeIntegers<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Program.cs#34_LargeIntegers \"</bpt>Large integer<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[LargeIntegers](../../../samples/snippets/csharp/new-in-7/Program.cs#34_LargeIntegers \"Large integer\")]"},{"pos":[28170,28253],"content":"The digit separator can be used with <ph id=\"ph1\">`decimal`</ph>, <ph id=\"ph2\">`float`</ph> and <ph id=\"ph3\">`double`</ph> types as well:","source":"The digit separator can be used with `decimal`, `float` and `double`\ntypes as well:"},{"pos":[28255,28382],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>OtherConstants<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../../samples/snippets/csharp/new-in-7/Program.cs#35_OtherConstants \"</bpt>non-integral constants<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[OtherConstants](../../../samples/snippets/csharp/new-in-7/Program.cs#35_OtherConstants \"non-integral constants\")]"},{"pos":[28384,28461],"content":"Taken together, you can declare numeric constants with much more readability.","source":"Taken together, you can declare numeric constants with much more\nreadability."}]}