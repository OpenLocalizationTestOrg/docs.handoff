{"content":"---\ntitle: \"The large object heap on Windows systems\"\nms.date: \"05/02/2018\"\nhelpviewer_keywords:\n  - large object heap (LOH)\"\n  - LOH\n  - \"garbage collection, large object heap\"\n  - \"GC [.NET ], large object heap\"\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n\n# The large object heap on Windows systems\n\nThe .NET Garbage Collector (GC) divides objects up into small and large objects. When an object is large, some of its attributes become more significant than if the object is small. For instance, compacting it -- that is, copying it in memory elsewhere on the heap -- can be expensive. Because of this, the .NET Garbage Collector places large objects on the large object heap (LOH). In this topic, we'll look at the large object heap in depth. We'll discuss what qualifies an object as a large object, how these large objects are collected, and what kind of performance implications large objects impose.\n\n> [!IMPORTANT]\n> This topic discusses the large object heap in the .NET Framework and .NET Core running on Windows systems only. It does not cover the LOH running on .NET implementations on other platforms.\n\n## How an object ends up on the large object heap and how GC handles them\n\nIf an object is greater than or equal to 85,000 bytes, it’s considered a large object. This number was determined by performance tuning. When an object allocation request is for 85,000 or more bytes, the runtime allocates it on the large object heap.\n\nTo understand what this means, it's useful to examine some fundamentals about the .NET GC.\n\nThe .NET Garbage Collector is a generational collector. It has three generations: generation 0, generation 1, and generation 2. The reason for having 3 generations is that, in a well-tuned app, most objects die in gen0. For example, in a server app, the allocations associated with each request should die after the request is finished. The in-flight allocation requests will make it into gen1 and die there. Essentially, gen1 acts as a buffer between young object areas and long-lived object areas.\n\nSmall objects are always allocated in generation 0 and, depending on their lifetime, may be promoted to generation 1 or generation2. Large objects are always allocated in generation 2.\n\nLarge objects belong to generation 2 because they are collected only during a generation 2 collection. When a generation is collected, all its younger generation(s) are also collected. For example, when a generation 1 GC happens, both generation 1 and 0 are collected. And when a generation 2 GC happens, the whole heap is collected. For this reason, a generation 2 GC is also called a *full GC*. This article refers to generation 2 GC instead of full GC, but the terms are interchangeable.\n\nGenerations provide a logical view of the GC heap. Physically, objects live in managed heap segments. A *managed heap segment* is a chunk of memory that the GC reserves from the OS by calling the [VirtualAlloc function](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) on behalf of managed code. When the CLR is loaded, the GC allocates two initial heap segments: one for small objects (the Small Object Heap, or SOH), and one for large objects (the Large Object Heap).\n\nThe allocation requests are then satisfied by putting managed objects on these managed heap segments. If the object is less than 85,000 bytes, it is put on the segment for the SOH; otherwise, it is put on an LOH segment. Segments are committed (in smaller chunks) as more and more objects are allocated onto them.\nFor the SOH, objects that survive a GC are promoted to the next generation. Objects that survive a generation 0 collection are now considered generation 1 objects, and so on. However, objects that survive the oldest generation are still considered to be in the oldest generation. In other words, survivors from generation 2 are generation 2 objects; and survivors from the LOH are LOH objects (which are collected with gen2).\n\nUser code can only allocate in generation 0 (small objects) or the LOH (large objects). Only the GC can “allocate” objects in generation 1 (by promoting survivors from generation 0) and generation 2 (by promoting survivors from generations 1 and 2).\n\nWhen a garbage collection is triggered, the GC traces through the live objects and compacts them. But because compaction is expensive, the GC *sweeps* the LOH; it makes a free list out of dead objects that can be reused later to satisfy large object allocation requests. Adjacent dead objects are made into one free object.\n\n.NET Core and .NET Framework (starting with .NET Framework 4.5.1) include the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode?displayProperty=nameWithType> property that allows users to specify that the LOH should be compacted during the next full blocking GC. And in the future, .NET may decide to compact the LOH automatically. This means that, if you allocate large objects and want to make sure that they don’t move, you should still pin them.\n\nFigure 1 illustrates a scenario where the GC forms generation 1 after the first generation 0 GC where `Obj1` and `Obj3` are dead, and it forms generation 2 after the first generation 1 GC where `Obj2` and `Obj5` are dead. Note that this and the following figures are only for illustration purposes; they contain very few objects to better show what happens on the heap. In reality, many more objects are typically involved in a GC.\n\n![Figure 1: A gen 0 GC and a gen 1 GC](media/loh/loh-figure-1.jpg)\\\nFigure 1: A generation 0 and a generation 1 GC.\n\nFigure 2 shows that after a generation 2 GC which saw that `Obj1` and `Obj2` are dead, the GC forms contiguous free space out of memory that used to be occupied by `Obj1` and `Obj2`, which then was used to satisfy an allocation request for `Obj4`. The space after the last object, `Obj3`, to end of the segment can also be used to satisfy allocation requests.\n\n![Figure 2: After a gen 2 GC](media/loh/loh-figure-2.jpg)\\\nFigure 2: After a generation 2 GC\n\nIf there isn't enough free space to accommodate the large object allocation requests, the GC first attempts to acquire more segments from the OS. If that fails, it triggers a generation 2 GC in the hope of freeing up some space.\n\nDuring a generation 1 or generation 2 GC, the garbage collector releases segments that have no live objects on them back to the OS by calling the [VirtualFree function](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree). Space after the last live object to the end of the segment is decommitted (except on the ephemeral segment where gen0/gen1 live, where the garbage collector does keep some committed because your application will be allocating in it right away). And the free spaces remain committed though they are reset, meaning that the OS doesn’t need to write data in them back to disk.\n\nSince the LOH is only collected during generation 2 GCs, the LOH segment can only be freed during such a GC. Figure 3 illustrates a scenario where the garbage collector releases one segment (segment 2) back to the OS and decommits more space on the remaining segments. If it needs to use the decommitted space at the end of the segment to satisfy large object allocation requests, it commits the memory again. (For an explanation of commit/decommit, see the documentation for [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc).\n\n![Figure 3: LOH after a gen 2 GC](media/loh/loh-figure-3.jpg)\\\nFigure 3: The LOH after a generation 2 GC\n\n## When is a large object collected?\n\nIn general, a GC occurs when one of the following 3 conditions happens:\n\n- Allocation exceeds the generation 0 or large object threshold.\n\n  The threshold is a property of a generation. A threshold for a generation is set when the garbage collector allocates objects into it. When the threshold is exceeded, a GC is triggered on that generation. When you allocate small or large objects, you consume generation 0 and the LOH’s thresholds, respectively. When the garbage collector allocates into generation 1 and 2, it consumes their thresholds. These thresholds are dynamically tuned as the program runs.\n\n  This is the typical case; most GCs happen because of allocations on the managed heap.\n\n- The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.\n\n  If the parameterless <xref:System.GC.Collect?displayProperty=nameWithType> method is called or another overload is passed <xref:System.GC.MaxGeneration?displayProperty=nameWithType> as an argument, the LOH is collected along with the rest of the managed heap.\n\n- The system is in low memory situation.\n\n  This occurs when the garbage collector receives a high memory notification from the OS. If the garbage collector thinks that doing a generation 2 GC will be productive, it triggers one.\n\n## LOH Performance Implications\n\nAllocations on the large object heap impact performance in the following ways.\n\n- Allocation cost.\n\n  The CLR makes the guarantee that the memory for every new object it gives out is cleared. This means the allocation cost of a large object is completely dominated by memory clearing (unless it triggers a GC). If it takes 2 cycles to clear one byte, it takes 170,000 cycles to clear the smallest large object. Clearing the memory of a 16MB object on a 2GHz machine takes approximately 16ms. That's a rather large cost.\n\n- Collection cost.\n\n  Because the LOH and generation 2 are collected together, if either one's threshold is exceeded, a generation 2 collection is triggered. If a generation 2 collection is triggered because of the LOH, generation 2 won't necessarily be much smaller after the GC. If there's not much data on generation 2, this has minimal impact. But if generation 2 is large, it can cause performance problems if many generation 2 GCs are triggered. If many large objects are allocated on a very temporary basis and you have a large SOH, you could be spending too much time doing GCs. In addition, the allocation cost can really add up if you keep allocating and letting go of really large objects.\n\n- Array elements with reference types.\n\n  Very large objects on the LOH are usually arrays (it's very rare to have an instance object that's really large). If the elements of an array are reference-rich, it incurs a cost that is not present if the elements are not reference-rich. If the element doesn’t contain any references, the garbage collector doesn’t need to go through the array at all. For example, if you use an array to store nodes in a binary tree, one way to implement it is to refer to a node’s right and left node by the actual nodes:\n\n  ```csharp\n  class Node\n  {\n     Data d;\n     Node left;\n     Node right;\n  };\n\n  Node[] binary_tr = new Node [num_nodes];\n  ```\n\n  If `num_nodes` is large, the garbage collector needs to go through at least two references per element. An alternative approach is to store the index of the right and the left nodes:\n\n  ```csharp\n  class Node\n  {\n     Data d;\n     uint left_index;\n     uint right_index;\n  } ;\n  ```\n\n  Instead of referring the left node’s data as `left.d`, you refer to it as `binary_tr[left_index].d`. And the garbage collector doesn’t need to look at any references for the left and right node.\n\nOut of the three factors, the first two are usually more significant than the third. Because of this, we recommend that you allocate a pool of large objects that you reuse instead of allocating temporary ones.\n\n## Collecting performance data for the LOH\n\nBefore you collect performance data for a specific area, you should already have done the following:\n\n1. Found evidence that you should be looking at this area.\n\n2. Exhausted other areas that you know of without finding anything that could explain the performance problem you saw.\n\nSee the blog [Understand the problem before you try to find a solution](https://blogs.msdn.microsoft.com/maoni/2006/09/01/understand-the-problem-before-you-try-to-find-a-solution/) for more information on the fundamentals of memory and the CPU.\n\nYou can use the following tools to collect data on LOH performance:\n\n- [.NET CLR memory performance counters](#net-clr-memory-performance-counters)\n\n- [ETW events](#etw-events)\n\n- [A debugger](#a-debugger)\n\n### .NET CLR Memory Performance counters\n\nThese performance counters are usually a good first step in investigating performance issues (although we recommend that you use [ETW events](#etw-events)). You configure Performance Monitor by adding the counters that you want, as Figure 4 shows. The ones that are relevant for the LOH are:\n\n- **Gen 2 Collections**\n\n   Displays the number of times generation 2 GCs have occurred since the process started. The counter is incremented at the end of a generation 2 collection (also called a full garbage collection). This counter displays the last observed value.\n\n- **Large Object Heap size**\n\n   Displays the current size, in bytes, including free space, of the LOH. This counter is updated at the end of a garbage collection, not at each allocation.\n\nA common way to look at performance counters is with Performance Monitor (perfmon.exe). Use “Add Counters” to add the interesting counter for processes that you care about. You can save the performance counter data to a log file, as Figure 4 shows.\n\n![Figure 4: Adding performance counters.](media/loh/perfcounter.png)\\\nFigure 4: The LOH after a generation 2 GC\n\nPerformance counters can also be queried programmatically. Many people collect them this way as part of their routine testing process. When they spot counters with values that are out of the ordinary, they use other means to get more detailed data to help with the investigation.\n\n> [!NOTE]\n> We recommend that you to use ETW events instead of performance counters, because ETW provides much richer information.\n\n### ETW events\n\nThe garbage collector provides a rich set of ETW events to help you understand what the heap is doing and why. The following blog posts show how to collect and understand GC events with ETW:\n\n- [GC ETW Events - 1](https://blogs.msdn.microsoft.com/maoni/2014/12/22/gc-etw-events-1/)\n\n- [GC ETW Events - 2](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-2/)\n\n- [GC ETW Events - 3](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-3/)\n\n- [GC ETW Events - 4](https://blogs.msdn.microsoft.com/maoni/2014/12/30/gc-etw-events-4/)\n\nTo identify excessive generation 2 GCs caused by temporary LOH allocations, look at the Trigger Reason column for GCs. For a simple test that only allocates temporary large objects, you can collect information on ETW events with the following [PerfView](https://www.microsoft.com/download/details.aspx?id=28567) command line:\n\n```console\nperfview /GCCollectOnly /AcceptEULA /nogui collect\n```\n\nThe result is something like this:\n\n![Figure 5: Examining ETW events using PerfView](media/loh/perfview.png)\nFigure 5: ETW events shown using PerfView\n\nAs you can see, all GCs are generation 2 GCs, and they are all triggered by AllocLarge, which means that allocating a large object triggered this GC. We know that these allocations are temporary because the **LOH Survival Rate %** column says 1%.\n\nYou can collect additional ETW events that tell you who allocated these large objects. The following command line:\n\n```console\nperfview /GCOnly /AcceptEULA /nogui collect\n```\n\ncollects an AllocationTick event which is fired approximately every 100k worth of allocations. In other words, an event is fired each time a large object is allocated. You can then look at one of the GC Heap Alloc views which show you the callstacks that allocated large objects:\n\n![Figure 6: A GC Heap Alloc view](media/loh/perfview2.png)\\\nFigure 6: A GC Heap Alloc view\n\nAs you can see, this is a very simple test that just allocates large objects from its `Main` method.\n\n### A debugger\n\nIf all you have is a memory dump and you need to look at what objects are actually on the LOH, you can use the [SoS debugger extension](../../../docs/framework/tools/sos-dll-sos-debugging-extension.md) provided by .NET.\n\n> [!NOTE]\n> The debugging commands mentioned in this section are applicable to the [Windows Debuggers](https://www.microsoft.com/whdc/devtools/debugging/default.mspx).\n\nThe following shows sample output from analyzing the LOH:\n\n```\n0:003> .loadby sos mscorwks\n0:003> !eeheap -gc\nNumber of GC Heaps: 1\ngeneration 0 starts at 0x013e35ec\nsdgeneration 1 starts at 0x013e1b6c\ngeneration 2 starts at 0x013e1000\nephemeral segment allocation context: none\nsegment   begin allocated     size\n0018f2d0 790d5588 790f4b38 0x0001f5b0(128432)\n013e0000 013e1000 013e35f8 0x000025f8(9720)\nLarge object heap starts at 0x023e1000\nsegment   begin allocated     size\n023e0000 023e1000 033db630 0x00ffa630(16754224)\n033e0000 033e1000 043cdf98 0x00fecf98(16699288)\n043e0000 043e1000 05368b58 0x00f87b58(16284504)\nTotal Size 0x2f90cc8(49876168)\n------------------------------\nGC Heap Size 0x2f90cc8(49876168)\n0:003> !dumpheap -stat 023e1000 033db630\ntotal 133 objects\nStatistics:\nMT   Count   TotalSize Class Name\n001521d0       66     2081792     Free\n7912273c       63     6663696 System.Byte[]\n7912254c       4     8008736 System.Object[]\nTotal 133 objects\n```\n\nThe LOH heap size is (16,754,224 + 16,699,288 + 16,284,504) = 49,738,016 bytes. Between addresses 023e1000 and 033db630, 8,008,736 bytes are occupied by an array of <xref:System.Object?displayProperty=nameWithType> objects, 6,663,696 bytes are occupied by an array of <xref:System.Byte?displayProperty=nameWithType>  objects, and 2,081,792 bytes are occupied by free space.\n\nSometimes, the debugger shows that the total size of the LOH is less than 85,000 bytes. This happens because the runtime itself uses the LOH to allocate some objects that are smaller than a large object.\n\nBecause the LOH is not compacted, sometimes the LOH is thought to be the source of fragmentation. Fragmentation means:\n\n- Fragmentation of the managed heap, which is indicated by the amount of free space between managed objects. In SoS, the `!dumpheap –type Free` command displays the amount of free space between managed objects.\n\n- Fragmentation of the virtual memory (VM) address space, which is the memory marked as `MEM_FREE`. You can get it by using various debugger commands in windbg.\n\n   The following example shows fragmentation in the VM space:\n\n   ```\n   0:000> !address\n   00000000 : 00000000 - 00010000\n   Type     00000000\n   Protect 00000001 PAGE_NOACCESS\n   State   00010000 MEM_FREE\n   Usage   RegionUsageFree\n   00010000 : 00010000 - 00002000\n   Type     00020000 MEM_PRIVATE\n   Protect 00000004 PAGE_READWRITE\n   State   00001000 MEM_COMMIT\n   Usage   RegionUsageEnvironmentBlock\n   00012000 : 00012000 - 0000e000\n   Type     00000000\n   Protect 00000001 PAGE_NOACCESS\n   State   00010000 MEM_FREE\n   Usage   RegionUsageFree\n   … [omitted]\n   -------------------- Usage SUMMARY --------------------------\n   TotSize (     KB)   Pct(Tots) Pct(Busy)   Usage\n   701000 (   7172) : 00.34%   20.69%   : RegionUsageIsVAD\n   7de15000 ( 2062420) : 98.35%   00.00%   : RegionUsageFree\n   1452000 (   20808) : 00.99%   60.02%   : RegionUsageImage\n   300000 (   3072) : 00.15%   08.86%   : RegionUsageStack\n   3000 (     12) : 00.00%   00.03%   : RegionUsageTeb\n   381000 (   3588) : 00.17%   10.35%   : RegionUsageHeap\n   0 (       0) : 00.00%   00.00%   : RegionUsagePageHeap\n   1000 (       4) : 00.00%   00.01%   : RegionUsagePeb\n   1000 (       4) : 00.00%   00.01%   : RegionUsageProcessParametrs\n   2000 (       8) : 00.00%   00.02%   : RegionUsageEnvironmentBlock\n   Tot: 7fff0000 (2097088 KB) Busy: 021db000 (34668 KB)\n\n   -------------------- Type SUMMARY --------------------------\n   TotSize (     KB)   Pct(Tots) Usage\n   7de15000 ( 2062420) : 98.35%   : <free>\n   1452000 (   20808) : 00.99%   : MEM_IMAGE\n   69f000 (   6780) : 00.32%   : MEM_MAPPED\n   6ea000 (   7080) : 00.34%   : MEM_PRIVATE\n\n   -------------------- State SUMMARY --------------------------\n   TotSize (     KB)   Pct(Tots) Usage\n   1a58000 (   26976) : 01.29%   : MEM_COMMIT\n   7de15000 ( 2062420) : 98.35%   : MEM_FREE\n   783000 (   7692) : 00.37%   : MEM_RESERVE\n\n   Largest free region: Base 01432000 - Size 707ee000 (1843128 KB)\n   ```\n\nIt’s more common to see VM fragmentation caused by temporary large objects that require the garbage collector to frequently acquire new managed heap segments from the OS and to release empty ones back to the OS.\n\nTo verify whether the LOH is causing VM fragmentation, you can set a breakpoint on [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) and [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) to see who call them. For example, to see who tried to allocate virtual memory chunks larger than 8MBB from the OS, you can set a breakpoint like this:\n\n```console\nbp kernel32!virtualalloc \"j (dwo(@esp+8)>800000) 'kb';'g'\"\n```\n\nThis command breaks into the debugger and shows the callstack only if [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) is called with an allocation size greater than 8MB (0x800000).\n\nCLR 2.0 added a feature called *VM Hoarding* that can be useful for scenarios where segments (including on the large and small object heaps) are frequently acquired and released. To specify VM Hoarding, you specify a startup flag called `STARTUP_HOARD_GC_VM` via the hosting API. Instead of releasing empty segments back to the OS, the CLR decommits the memory on these segments and puts them on a standby list. (Note that the CLR doesn't do this for segments that are too large.) The CLR later uses those segments to satisfy new segment requests. The next time that your app needs a new segment, the CLR uses one from this standby list if it can find one that’s big enough.\n\nVM hoarding is also useful for applications that want to hold onto the segments that they already acquired, such as some server apps that are the dominant apps running on the system, to avoid out of memory exceptions.\n\nWe strongly recommend that you carefully test your application when you use this feature to ensure your application has fairly stable memory usage.\n","nodes":[{"pos":[4,253],"embed":true,"restype":"x-metadata","content":"title: \"The large object heap on Windows systems\"\nms.date: \"05/02/2018\"\nhelpviewer_keywords:\n  - large object heap (LOH)\"\n  - LOH\n  - \"garbage collection, large object heap\"\n  - \"GC [.NET ], large object heap\"\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"The large object heap on Windows systems","nodes":[{"pos":[0,40],"content":"The large object heap on Windows systems","nodes":[{"content":"The large object heap on Windows systems","pos":[0,40]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[261,301],"content":"The large object heap on Windows systems","linkify":"The large object heap on Windows systems","nodes":[{"content":"The large object heap on Windows systems","pos":[0,40]}]},{"content":"The .NET Garbage Collector (GC) divides objects up into small and large objects.","pos":[303,383]},{"content":"When an object is large, some of its attributes become more significant than if the object is small.","pos":[384,484]},{"content":"For instance, compacting it -- that is, copying it in memory elsewhere on the heap -- can be expensive.","pos":[485,588]},{"content":"Because of this, the .NET Garbage Collector places large objects on the large object heap (LOH).","pos":[589,685]},{"content":"In this topic, we'll look at the large object heap in depth.","pos":[686,746]},{"content":"We'll discuss what qualifies an object as a large object, how these large objects are collected, and what kind of performance implications large objects impose.","pos":[747,907]},{"pos":[911,1115],"content":"[!IMPORTANT]\nThis topic discusses the large object heap in the .NET Framework and .NET Core running on Windows systems only. It does not cover the LOH running on .NET implementations on other platforms.","leadings":["","> "],"nodes":[{"content":"This topic discusses the large object heap in the .NET Framework and .NET Core running on Windows systems only. It does not cover the LOH running on .NET implementations on other platforms.","pos":[13,202],"nodes":[{"content":"This topic discusses the large object heap in the .NET Framework and .NET Core running on Windows systems only.","pos":[0,111]},{"content":"It does not cover the LOH running on .NET implementations on other platforms.","pos":[112,189]}]}]},{"pos":[1120,1190],"content":"How an object ends up on the large object heap and how GC handles them","linkify":"How an object ends up on the large object heap and how GC handles them","nodes":[{"content":"How an object ends up on the large object heap and how GC handles them","pos":[0,70]}]},{"content":"If an object is greater than or equal to 85,000 bytes, it’s considered a large object.","pos":[1192,1278]},{"content":"This number was determined by performance tuning.","pos":[1279,1328]},{"content":"When an object allocation request is for 85,000 or more bytes, the runtime allocates it on the large object heap.","pos":[1329,1442]},{"content":"To understand what this means, it's useful to examine some fundamentals about the .NET GC.","pos":[1444,1534]},{"content":"The .NET Garbage Collector is a generational collector.","pos":[1536,1591]},{"content":"It has three generations: generation 0, generation 1, and generation 2.","pos":[1592,1663]},{"content":"The reason for having 3 generations is that, in a well-tuned app, most objects die in gen0.","pos":[1664,1755]},{"content":"For example, in a server app, the allocations associated with each request should die after the request is finished.","pos":[1756,1872]},{"content":"The in-flight allocation requests will make it into gen1 and die there.","pos":[1873,1944]},{"content":"Essentially, gen1 acts as a buffer between young object areas and long-lived object areas.","pos":[1945,2035]},{"content":"Small objects are always allocated in generation 0 and, depending on their lifetime, may be promoted to generation 1 or generation2.","pos":[2037,2169]},{"content":"Large objects are always allocated in generation 2.","pos":[2170,2221]},{"content":"Large objects belong to generation 2 because they are collected only during a generation 2 collection.","pos":[2223,2325]},{"content":"When a generation is collected, all its younger generation(s) are also collected.","pos":[2326,2407]},{"content":"For example, when a generation 1 GC happens, both generation 1 and 0 are collected.","pos":[2408,2491]},{"content":"And when a generation 2 GC happens, the whole heap is collected.","pos":[2492,2556]},{"content":"For this reason, a generation 2 GC is also called a <bpt id=\"p1\">*</bpt>full GC<ept id=\"p1\">*</ept>.","pos":[2557,2619],"source":" For this reason, a generation 2 GC is also called a *full GC*."},{"content":"This article refers to generation 2 GC instead of full GC, but the terms are interchangeable.","pos":[2620,2713]},{"content":"Generations provide a logical view of the GC heap.","pos":[2715,2765]},{"content":"Physically, objects live in managed heap segments.","pos":[2766,2816]},{"content":"A <bpt id=\"p1\">*</bpt>managed heap segment<ept id=\"p1\">*</ept> is a chunk of memory that the GC reserves from the OS by calling the <bpt id=\"p2\">[</bpt>VirtualAlloc function<ept id=\"p2\">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept> on behalf of managed code.","pos":[2817,3019],"source":" A *managed heap segment* is a chunk of memory that the GC reserves from the OS by calling the [VirtualAlloc function](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) on behalf of managed code."},{"content":"When the CLR is loaded, the GC allocates two initial heap segments: one for small objects (the Small Object Heap, or SOH), and one for large objects (the Large Object Heap).","pos":[3020,3193]},{"content":"The allocation requests are then satisfied by putting managed objects on these managed heap segments.","pos":[3195,3296]},{"content":"If the object is less than 85,000 bytes, it is put on the segment for the SOH; otherwise, it is put on an LOH segment.","pos":[3297,3415]},{"content":"Segments are committed (in smaller chunks) as more and more objects are allocated onto them.","pos":[3416,3508]},{"content":"For the SOH, objects that survive a GC are promoted to the next generation.","pos":[3509,3584],"source":"\nFor the SOH, objects that survive a GC are promoted to the next generation."},{"content":"Objects that survive a generation 0 collection are now considered generation 1 objects, and so on.","pos":[3585,3683]},{"content":"However, objects that survive the oldest generation are still considered to be in the oldest generation.","pos":[3684,3788]},{"content":"In other words, survivors from generation 2 are generation 2 objects; and survivors from the LOH are LOH objects (which are collected with gen2).","pos":[3789,3934]},{"content":"User code can only allocate in generation 0 (small objects) or the LOH (large objects).","pos":[3936,4023]},{"content":"Only the GC can “allocate” objects in generation 1 (by promoting survivors from generation 0) and generation 2 (by promoting survivors from generations 1 and 2).","pos":[4024,4185]},{"content":"When a garbage collection is triggered, the GC traces through the live objects and compacts them.","pos":[4187,4284]},{"content":"But because compaction is expensive, the GC <bpt id=\"p1\">*</bpt>sweeps<ept id=\"p1\">*</ept> the LOH; it makes a free list out of dead objects that can be reused later to satisfy large object allocation requests.","pos":[4285,4457],"source":" But because compaction is expensive, the GC *sweeps* the LOH; it makes a free list out of dead objects that can be reused later to satisfy large object allocation requests."},{"content":"Adjacent dead objects are made into one free object.","pos":[4458,4510]},{"content":".NET Core and .NET Framework (starting with .NET Framework 4.5.1) include the <ph id=\"ph1\">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode?displayProperty=nameWithType&gt;</ph> property that allows users to specify that the LOH should be compacted during the next full blocking GC.","pos":[4512,4786],"source":".NET Core and .NET Framework (starting with .NET Framework 4.5.1) include the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode?displayProperty=nameWithType> property that allows users to specify that the LOH should be compacted during the next full blocking GC."},{"content":"And in the future, .NET may decide to compact the LOH automatically.","pos":[4787,4855]},{"content":"This means that, if you allocate large objects and want to make sure that they don’t move, you should still pin them.","pos":[4856,4973]},{"content":"Figure 1 illustrates a scenario where the GC forms generation 1 after the first generation 0 GC where <ph id=\"ph1\">`Obj1`</ph> and <ph id=\"ph2\">`Obj3`</ph> are dead, and it forms generation 2 after the first generation 1 GC where <ph id=\"ph3\">`Obj2`</ph> and <ph id=\"ph4\">`Obj5`</ph> are dead.","pos":[4975,5196],"source":"Figure 1 illustrates a scenario where the GC forms generation 1 after the first generation 0 GC where `Obj1` and `Obj3` are dead, and it forms generation 2 after the first generation 1 GC where `Obj2` and `Obj5` are dead."},{"content":"Note that this and the following figures are only for illustration purposes; they contain very few objects to better show what happens on the heap.","pos":[5197,5344]},{"content":"In reality, many more objects are typically involved in a GC.","pos":[5345,5406]},{"content":"Figure 1: A gen 0 GC and a gen 1 GC","pos":[5410,5445]},{"content":"Figure 1: A generation 0 and a generation 1 GC.","pos":[5476,5523]},{"content":"Figure 2 shows that after a generation 2 GC which saw that <ph id=\"ph1\">`Obj1`</ph> and <ph id=\"ph2\">`Obj2`</ph> are dead, the GC forms contiguous free space out of memory that used to be occupied by <ph id=\"ph3\">`Obj1`</ph> and <ph id=\"ph4\">`Obj2`</ph>, which then was used to satisfy an allocation request for <ph id=\"ph5\">`Obj4`</ph>.","pos":[5525,5772],"source":"Figure 2 shows that after a generation 2 GC which saw that `Obj1` and `Obj2` are dead, the GC forms contiguous free space out of memory that used to be occupied by `Obj1` and `Obj2`, which then was used to satisfy an allocation request for `Obj4`."},{"content":"The space after the last object, <ph id=\"ph1\">`Obj3`</ph>, to end of the segment can also be used to satisfy allocation requests.","pos":[5773,5884],"source":" The space after the last object, `Obj3`, to end of the segment can also be used to satisfy allocation requests."},{"content":"Figure 2: After a gen 2 GC","pos":[5888,5914]},{"content":"Figure 2: After a generation 2 GC","pos":[5945,5978]},{"content":"If there isn't enough free space to accommodate the large object allocation requests, the GC first attempts to acquire more segments from the OS.","pos":[5980,6125]},{"content":"If that fails, it triggers a generation 2 GC in the hope of freeing up some space.","pos":[6126,6208]},{"content":"During a generation 1 or generation 2 GC, the garbage collector releases segments that have no live objects on them back to the OS by calling the <bpt id=\"p1\">[</bpt>VirtualFree function<ept id=\"p1\">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)</ept>.","pos":[6210,6436],"source":"During a generation 1 or generation 2 GC, the garbage collector releases segments that have no live objects on them back to the OS by calling the [VirtualFree function](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)."},{"content":"Space after the last live object to the end of the segment is decommitted (except on the ephemeral segment where gen0/gen1 live, where the garbage collector does keep some committed because your application will be allocating in it right away).","pos":[6437,6681]},{"content":"And the free spaces remain committed though they are reset, meaning that the OS doesn’t need to write data in them back to disk.","pos":[6682,6810]},{"content":"Since the LOH is only collected during generation 2 GCs, the LOH segment can only be freed during such a GC.","pos":[6812,6920]},{"content":"Figure 3 illustrates a scenario where the garbage collector releases one segment (segment 2) back to the OS and decommits more space on the remaining segments.","pos":[6921,7080]},{"content":"If it needs to use the decommitted space at the end of the segment to satisfy large object allocation requests, it commits the memory again.","pos":[7081,7221]},{"content":"(For an explanation of commit/decommit, see the documentation for <bpt id=\"p1\">[</bpt>VirtualAlloc<ept id=\"p1\">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept>.","pos":[7222,7361],"source":" (For an explanation of commit/decommit, see the documentation for [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)."},{"content":"Figure 3: LOH after a gen 2 GC","pos":[7365,7395]},{"content":"Figure 3: The LOH after a generation 2 GC","pos":[7426,7467]},{"pos":[7472,7505],"content":"When is a large object collected?","linkify":"When is a large object collected?","nodes":[{"content":"When is a large object collected?","pos":[0,33]}]},{"content":"In general, a GC occurs when one of the following 3 conditions happens:","pos":[7507,7578]},{"content":"Allocation exceeds the generation 0 or large object threshold.","pos":[7582,7644]},{"content":"The threshold is a property of a generation.","pos":[7648,7692]},{"content":"A threshold for a generation is set when the garbage collector allocates objects into it.","pos":[7693,7782]},{"content":"When the threshold is exceeded, a GC is triggered on that generation.","pos":[7783,7852]},{"content":"When you allocate small or large objects, you consume generation 0 and the LOH’s thresholds, respectively.","pos":[7853,7959]},{"content":"When the garbage collector allocates into generation 1 and 2, it consumes their thresholds.","pos":[7960,8051]},{"content":"These thresholds are dynamically tuned as the program runs.","pos":[8052,8111]},{"content":"This is the typical case; most GCs happen because of allocations on the managed heap.","pos":[8115,8200]},{"pos":[8204,8282],"content":"The <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A?displayProperty=nameWithType&gt;</ph> method is called.","source":"The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called."},{"pos":[8286,8545],"content":"If the parameterless <ph id=\"ph1\">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> method is called or another overload is passed <ph id=\"ph2\">&lt;xref:System.GC.MaxGeneration?displayProperty=nameWithType&gt;</ph> as an argument, the LOH is collected along with the rest of the managed heap.","source":"If the parameterless <xref:System.GC.Collect?displayProperty=nameWithType> method is called or another overload is passed <xref:System.GC.MaxGeneration?displayProperty=nameWithType> as an argument, the LOH is collected along with the rest of the managed heap."},{"content":"The system is in low memory situation.","pos":[8549,8587]},{"content":"This occurs when the garbage collector receives a high memory notification from the OS.","pos":[8591,8678]},{"content":"If the garbage collector thinks that doing a generation 2 GC will be productive, it triggers one.","pos":[8679,8776]},{"pos":[8781,8809],"content":"LOH Performance Implications","linkify":"LOH Performance Implications","nodes":[{"content":"LOH Performance Implications","pos":[0,28]}]},{"content":"Allocations on the large object heap impact performance in the following ways.","pos":[8811,8889]},{"content":"Allocation cost.","pos":[8893,8909]},{"content":"The CLR makes the guarantee that the memory for every new object it gives out is cleared.","pos":[8913,9002]},{"content":"This means the allocation cost of a large object is completely dominated by memory clearing (unless it triggers a GC).","pos":[9003,9121]},{"content":"If it takes 2 cycles to clear one byte, it takes 170,000 cycles to clear the smallest large object.","pos":[9122,9221]},{"content":"Clearing the memory of a 16MB object on a 2GHz machine takes approximately 16ms.","pos":[9222,9302]},{"content":"That's a rather large cost.","pos":[9303,9330]},{"content":"Collection cost.","pos":[9334,9350]},{"content":"Because the LOH and generation 2 are collected together, if either one's threshold is exceeded, a generation 2 collection is triggered.","pos":[9354,9489]},{"content":"If a generation 2 collection is triggered because of the LOH, generation 2 won't necessarily be much smaller after the GC.","pos":[9490,9612]},{"content":"If there's not much data on generation 2, this has minimal impact.","pos":[9613,9679]},{"content":"But if generation 2 is large, it can cause performance problems if many generation 2 GCs are triggered.","pos":[9680,9783]},{"content":"If many large objects are allocated on a very temporary basis and you have a large SOH, you could be spending too much time doing GCs.","pos":[9784,9918]},{"content":"In addition, the allocation cost can really add up if you keep allocating and letting go of really large objects.","pos":[9919,10032]},{"content":"Array elements with reference types.","pos":[10036,10072]},{"content":"Very large objects on the LOH are usually arrays (it's very rare to have an instance object that's really large).","pos":[10076,10189]},{"content":"If the elements of an array are reference-rich, it incurs a cost that is not present if the elements are not reference-rich.","pos":[10190,10314]},{"content":"If the element doesn’t contain any references, the garbage collector doesn’t need to go through the array at all.","pos":[10315,10428]},{"content":"For example, if you use an array to store nodes in a binary tree, one way to implement it is to refer to a node’s right and left node by the actual nodes:","pos":[10429,10583]},{"content":"If <ph id=\"ph1\">`num_nodes`</ph> is large, the garbage collector needs to go through at least two references per element.","pos":[10718,10821],"source":"If `num_nodes` is large, the garbage collector needs to go through at least two references per element."},{"content":"An alternative approach is to store the index of the right and the left nodes:","pos":[10822,10900]},{"content":"Instead of referring the left node’s data as <ph id=\"ph1\">`left.d`</ph>, you refer to it as <ph id=\"ph2\">`binary_tr[left_index].d`</ph>.","pos":[11004,11104],"source":"Instead of referring the left node’s data as `left.d`, you refer to it as `binary_tr[left_index].d`."},{"content":"And the garbage collector doesn’t need to look at any references for the left and right node.","pos":[11105,11198]},{"content":"Out of the three factors, the first two are usually more significant than the third.","pos":[11200,11284]},{"content":"Because of this, we recommend that you allocate a pool of large objects that you reuse instead of allocating temporary ones.","pos":[11285,11409]},{"pos":[11414,11453],"content":"Collecting performance data for the LOH","linkify":"Collecting performance data for the LOH","nodes":[{"content":"Collecting performance data for the LOH","pos":[0,39]}]},{"content":"Before you collect performance data for a specific area, you should already have done the following:","pos":[11455,11555]},{"content":"Found evidence that you should be looking at this area.","pos":[11560,11615]},{"content":"Exhausted other areas that you know of without finding anything that could explain the performance problem you saw.","pos":[11620,11735]},{"pos":[11737,11981],"content":"See the blog <bpt id=\"p1\">[</bpt>Understand the problem before you try to find a solution<ept id=\"p1\">](https://blogs.msdn.microsoft.com/maoni/2006/09/01/understand-the-problem-before-you-try-to-find-a-solution/)</ept> for more information on the fundamentals of memory and the CPU.","source":"See the blog [Understand the problem before you try to find a solution](https://blogs.msdn.microsoft.com/maoni/2006/09/01/understand-the-problem-before-you-try-to-find-a-solution/) for more information on the fundamentals of memory and the CPU."},{"content":"You can use the following tools to collect data on LOH performance:","pos":[11983,12050]},{"pos":[12054,12130],"content":"<bpt id=\"p1\">[</bpt>.NET CLR memory performance counters<ept id=\"p1\">](#net-clr-memory-performance-counters)</ept>","source":"[.NET CLR memory performance counters](#net-clr-memory-performance-counters)"},{"pos":[12134,12159],"content":"<bpt id=\"p1\">[</bpt>ETW events<ept id=\"p1\">](#etw-events)</ept>","source":"[ETW events](#etw-events)"},{"pos":[12163,12188],"content":"<bpt id=\"p1\">[</bpt>A debugger<ept id=\"p1\">](#a-debugger)</ept>","source":"[A debugger](#a-debugger)"},{"pos":[12194,12230],"content":".NET CLR Memory Performance counters","linkify":".NET CLR Memory Performance counters","nodes":[{"content":".NET CLR Memory Performance counters","pos":[0,36]}]},{"content":"These performance counters are usually a good first step in investigating performance issues (although we recommend that you use <bpt id=\"p1\">[</bpt>ETW events<ept id=\"p1\">](#etw-events)</ept>).","pos":[12232,12388],"source":"These performance counters are usually a good first step in investigating performance issues (although we recommend that you use [ETW events](#etw-events))."},{"content":"You configure Performance Monitor by adding the counters that you want, as Figure 4 shows.","pos":[12389,12479]},{"content":"The ones that are relevant for the LOH are:","pos":[12480,12523]},{"pos":[12527,12548],"content":"<bpt id=\"p1\">**</bpt>Gen 2 Collections<ept id=\"p1\">**</ept>","source":"**Gen 2 Collections**"},{"content":"Displays the number of times generation 2 GCs have occurred since the process started.","pos":[12553,12639]},{"content":"The counter is incremented at the end of a generation 2 collection (also called a full garbage collection).","pos":[12640,12747]},{"content":"This counter displays the last observed value.","pos":[12748,12794]},{"pos":[12798,12824],"content":"<bpt id=\"p1\">**</bpt>Large Object Heap size<ept id=\"p1\">**</ept>","source":"**Large Object Heap size**"},{"content":"Displays the current size, in bytes, including free space, of the LOH.","pos":[12829,12899]},{"content":"This counter is updated at the end of a garbage collection, not at each allocation.","pos":[12900,12983]},{"content":"A common way to look at performance counters is with Performance Monitor (perfmon.exe).","pos":[12985,13072]},{"content":"Use “Add Counters” to add the interesting counter for processes that you care about.","pos":[13073,13157]},{"content":"You can save the performance counter data to a log file, as Figure 4 shows.","pos":[13158,13233]},{"content":"Figure 4: Adding performance counters.","pos":[13237,13275]},{"content":"Figure 4: The LOH after a generation 2 GC","pos":[13305,13346]},{"content":"Performance counters can also be queried programmatically.","pos":[13348,13406]},{"content":"Many people collect them this way as part of their routine testing process.","pos":[13407,13482]},{"content":"When they spot counters with values that are out of the ordinary, they use other means to get more detailed data to help with the investigation.","pos":[13483,13627]},{"pos":[13631,13759],"content":"[!NOTE]\nWe recommend that you to use ETW events instead of performance counters, because ETW provides much richer information.","leadings":["","> "],"nodes":[{"content":"We recommend that you to use ETW events instead of performance counters, because ETW provides much richer information.","pos":[8,126]}]},{"pos":[13765,13775],"content":"ETW events","linkify":"ETW events","nodes":[{"content":"ETW events","pos":[0,10]}]},{"content":"The garbage collector provides a rich set of ETW events to help you understand what the heap is doing and why.","pos":[13777,13887]},{"content":"The following blog posts show how to collect and understand GC events with ETW:","pos":[13888,13967]},{"pos":[13971,14058],"content":"<bpt id=\"p1\">[</bpt>GC ETW Events - 1<ept id=\"p1\">](https://blogs.msdn.microsoft.com/maoni/2014/12/22/gc-etw-events-1/)</ept>","source":"[GC ETW Events - 1](https://blogs.msdn.microsoft.com/maoni/2014/12/22/gc-etw-events-1/)"},{"pos":[14062,14149],"content":"<bpt id=\"p1\">[</bpt>GC ETW Events - 2<ept id=\"p1\">](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-2/)</ept>","source":"[GC ETW Events - 2](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-2/)"},{"pos":[14153,14240],"content":"<bpt id=\"p1\">[</bpt>GC ETW Events - 3<ept id=\"p1\">](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-3/)</ept>","source":"[GC ETW Events - 3](https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-3/)"},{"pos":[14244,14331],"content":"<bpt id=\"p1\">[</bpt>GC ETW Events - 4<ept id=\"p1\">](https://blogs.msdn.microsoft.com/maoni/2014/12/30/gc-etw-events-4/)</ept>","source":"[GC ETW Events - 4](https://blogs.msdn.microsoft.com/maoni/2014/12/30/gc-etw-events-4/)"},{"content":"To identify excessive generation 2 GCs caused by temporary LOH allocations, look at the Trigger Reason column for GCs.","pos":[14333,14451]},{"content":"For a simple test that only allocates temporary large objects, you can collect information on ETW events with the following <bpt id=\"p1\">[</bpt>PerfView<ept id=\"p1\">](https://www.microsoft.com/download/details.aspx?id=28567)</ept> command line:","pos":[14452,14658],"source":" For a simple test that only allocates temporary large objects, you can collect information on ETW events with the following [PerfView](https://www.microsoft.com/download/details.aspx?id=28567) command line:"},{"content":"The result is something like this:","pos":[14727,14761]},{"pos":[14763,14877],"content":"<ph id=\"ph1\">![</ph>Figure 5: Examining ETW events using PerfView<ph id=\"ph2\">](media/loh/perfview.png)</ph> Figure 5: ETW events shown using PerfView","source":"![Figure 5: Examining ETW events using PerfView](media/loh/perfview.png)\nFigure 5: ETW events shown using PerfView"},{"content":"As you can see, all GCs are generation 2 GCs, and they are all triggered by AllocLarge, which means that allocating a large object triggered this GC.","pos":[14879,15028]},{"content":"We know that these allocations are temporary because the <bpt id=\"p1\">**</bpt>LOH Survival Rate %<ept id=\"p1\">**</ept> column says 1%.","pos":[15029,15125],"source":" We know that these allocations are temporary because the **LOH Survival Rate %** column says 1%."},{"content":"You can collect additional ETW events that tell you who allocated these large objects.","pos":[15127,15213]},{"content":"The following command line:","pos":[15214,15241]},{"content":"collects an AllocationTick event which is fired approximately every 100k worth of allocations.","pos":[15303,15397]},{"content":"In other words, an event is fired each time a large object is allocated.","pos":[15398,15470]},{"content":"You can then look at one of the GC Heap Alloc views which show you the callstacks that allocated large objects:","pos":[15471,15582]},{"content":"Figure 6: A GC Heap Alloc view","pos":[15586,15616]},{"content":"Figure 6: A GC Heap Alloc view","pos":[15644,15674]},{"pos":[15676,15776],"content":"As you can see, this is a very simple test that just allocates large objects from its <ph id=\"ph1\">`Main`</ph> method.","source":"As you can see, this is a very simple test that just allocates large objects from its `Main` method."},{"pos":[15782,15792],"content":"A debugger","linkify":"A debugger","nodes":[{"content":"A debugger","pos":[0,10]}]},{"pos":[15794,16013],"content":"If all you have is a memory dump and you need to look at what objects are actually on the LOH, you can use the <bpt id=\"p1\">[</bpt>SoS debugger extension<ept id=\"p1\">](../../../docs/framework/tools/sos-dll-sos-debugging-extension.md)</ept> provided by .NET.","source":"If all you have is a memory dump and you need to look at what objects are actually on the LOH, you can use the [SoS debugger extension](../../../docs/framework/tools/sos-dll-sos-debugging-extension.md) provided by .NET."},{"pos":[16017,16182],"content":"[!NOTE]\nThe debugging commands mentioned in this section are applicable to the [Windows Debuggers](https://www.microsoft.com/whdc/devtools/debugging/default.mspx).","leadings":["","> "],"nodes":[{"content":"The debugging commands mentioned in this section are applicable to the <bpt id=\"p1\">[</bpt>Windows Debuggers<ept id=\"p1\">](https://www.microsoft.com/whdc/devtools/debugging/default.mspx)</ept>.","pos":[8,163],"source":"The debugging commands mentioned in this section are applicable to the [Windows Debuggers](https://www.microsoft.com/whdc/devtools/debugging/default.mspx)."}]},{"content":"The following shows sample output from analyzing the LOH:","pos":[16184,16241]},{"content":"The LOH heap size is (16,754,224 + 16,699,288 + 16,284,504) = 49,738,016 bytes.","pos":[17157,17236]},{"content":"Between addresses 023e1000 and 033db630, 8,008,736 bytes are occupied by an array of <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> objects, 6,663,696 bytes are occupied by an array of <ph id=\"ph2\">&lt;xref:System.Byte?displayProperty=nameWithType&gt;</ph>  objects, and 2,081,792 bytes are occupied by free space.","pos":[17237,17530],"source":" Between addresses 023e1000 and 033db630, 8,008,736 bytes are occupied by an array of <xref:System.Object?displayProperty=nameWithType> objects, 6,663,696 bytes are occupied by an array of <xref:System.Byte?displayProperty=nameWithType>  objects, and 2,081,792 bytes are occupied by free space."},{"content":"Sometimes, the debugger shows that the total size of the LOH is less than 85,000 bytes.","pos":[17532,17619]},{"content":"This happens because the runtime itself uses the LOH to allocate some objects that are smaller than a large object.","pos":[17620,17735]},{"content":"Because the LOH is not compacted, sometimes the LOH is thought to be the source of fragmentation.","pos":[17737,17834]},{"content":"Fragmentation means:","pos":[17835,17855]},{"content":"Fragmentation of the managed heap, which is indicated by the amount of free space between managed objects.","pos":[17859,17965]},{"content":"In SoS, the <ph id=\"ph1\">`!dumpheap –type Free`</ph> command displays the amount of free space between managed objects.","pos":[17966,18067],"source":" In SoS, the `!dumpheap –type Free` command displays the amount of free space between managed objects."},{"content":"Fragmentation of the virtual memory (VM) address space, which is the memory marked as <ph id=\"ph1\">`MEM_FREE`</ph>.","pos":[18071,18168],"source":"Fragmentation of the virtual memory (VM) address space, which is the memory marked as `MEM_FREE`."},{"content":"You can get it by using various debugger commands in windbg.","pos":[18169,18229]},{"content":"The following example shows fragmentation in the VM space:","pos":[18234,18292]},{"content":"It’s more common to see VM fragmentation caused by temporary large objects that require the garbage collector to frequently acquire new managed heap segments from the OS and to release empty ones back to the OS.","pos":[20172,20383]},{"content":"To verify whether the LOH is causing VM fragmentation, you can set a breakpoint on <bpt id=\"p1\">[</bpt>VirtualAlloc<ept id=\"p1\">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept> and <bpt id=\"p2\">[</bpt>VirtualFree<ept id=\"p2\">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)</ept> to see who call them.","pos":[20385,20637],"source":"To verify whether the LOH is causing VM fragmentation, you can set a breakpoint on [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) and [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) to see who call them."},{"content":"For example, to see who tried to allocate virtual memory chunks larger than 8MBB from the OS, you can set a breakpoint like this:","pos":[20638,20767]},{"pos":[20844,21049],"content":"This command breaks into the debugger and shows the callstack only if <bpt id=\"p1\">[</bpt>VirtualAlloc<ept id=\"p1\">](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)</ept> is called with an allocation size greater than 8MB (0x800000).","source":"This command breaks into the debugger and shows the callstack only if [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) is called with an allocation size greater than 8MB (0x800000)."},{"content":"CLR 2.0 added a feature called <bpt id=\"p1\">*</bpt>VM Hoarding<ept id=\"p1\">*</ept> that can be useful for scenarios where segments (including on the large and small object heaps) are frequently acquired and released.","pos":[21051,21229],"source":"CLR 2.0 added a feature called *VM Hoarding* that can be useful for scenarios where segments (including on the large and small object heaps) are frequently acquired and released."},{"content":"To specify VM Hoarding, you specify a startup flag called <ph id=\"ph1\">`STARTUP_HOARD_GC_VM`</ph> via the hosting API.","pos":[21230,21330],"source":" To specify VM Hoarding, you specify a startup flag called `STARTUP_HOARD_GC_VM` via the hosting API."},{"content":"Instead of releasing empty segments back to the OS, the CLR decommits the memory on these segments and puts them on a standby list.","pos":[21331,21462]},{"content":"(Note that the CLR doesn't do this for segments that are too large.) The CLR later uses those segments to satisfy new segment requests.","pos":[21463,21598]},{"content":"The next time that your app needs a new segment, the CLR uses one from this standby list if it can find one that’s big enough.","pos":[21599,21725]},{"content":"VM hoarding is also useful for applications that want to hold onto the segments that they already acquired, such as some server apps that are the dominant apps running on the system, to avoid out of memory exceptions.","pos":[21727,21944]},{"content":"We strongly recommend that you carefully test your application when you use this feature to ensure your application has fairly stable memory usage.","pos":[21946,22093]}]}