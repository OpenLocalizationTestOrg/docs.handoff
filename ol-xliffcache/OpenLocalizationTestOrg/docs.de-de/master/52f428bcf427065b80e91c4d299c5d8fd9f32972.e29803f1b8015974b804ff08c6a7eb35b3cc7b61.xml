{"content":"---\ntitle: \"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)\"\nms.date: 07/20/2015\nms.assetid: a01bd1d4-133c-4ca2-aa4e-e93e81d6076c\n---\n# How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)\nThis example shows how to retrieve the total number of bytes used by all the files in a specified folder and all its subfolders.  \n  \n## Example  \n The <xref:System.Linq.Enumerable.Sum%2A> method adds the values of all the items selected in the `select` clause. You can easily modify this query to retrieve the biggest or smallest file in the specified directory tree by calling the <xref:System.Linq.Enumerable.Min%2A> or <xref:System.Linq.Enumerable.Max%2A> method instead of <xref:System.Linq.Enumerable.Sum%2A>.  \n  \n```csharp  \nclass QuerySize  \n{  \n    public static void Main()  \n    {  \n        string startFolder = @\"c:\\program files\\Microsoft Visual Studio 9.0\\VC#\";  \n  \n        // Take a snapshot of the file system.  \n        // This method assumes that the application has discovery permissions  \n        // for all folders under the specified path.  \n        IEnumerable<string> fileList = System.IO.Directory.GetFiles(startFolder, \"*.*\", System.IO.SearchOption.AllDirectories);  \n  \n        var fileQuery = from file in fileList  \n                        select GetFileLength(file);  \n  \n        // Cache the results to avoid multiple trips to the file system.  \n        long[] fileLengths = fileQuery.ToArray();  \n  \n        // Return the size of the largest file  \n        long largestFile = fileLengths.Max();  \n  \n        // Return the total number of bytes in all the files under the specified folder.  \n        long totalBytes = fileLengths.Sum();  \n  \n        Console.WriteLine(\"There are {0} bytes in {1} files under {2}\",  \n            totalBytes, fileList.Count(), startFolder);  \n        Console.WriteLine(\"The largest files is {0} bytes.\", largestFile);  \n  \n        // Keep the console window open in debug mode.  \n        Console.WriteLine(\"Press any key to exit.\");  \n        Console.ReadKey();  \n    }  \n  \n    // This method is used to swallow the possible exception  \n    // that can be raised when accessing the System.IO.FileInfo.Length property.  \n    static long GetFileLength(string filename)  \n    {  \n        long retval;  \n        try  \n        {  \n            System.IO.FileInfo fi = new System.IO.FileInfo(filename);  \n            retval = fi.Length;  \n        }  \n        catch (System.IO.FileNotFoundException)  \n        {  \n            // If a file is no longer present,  \n            // just add zero bytes to the total.  \n            retval = 0;  \n        }  \n        return retval;  \n    }  \n}  \n```  \n  \n If you only have to count the number of bytes in a specified directory tree, you can do this more efficiently without creating a LINQ query, which incurs the overhead of creating the list collection as a data source. The usefulness of the LINQ approach increases as the query becomes more complex, or when you have to run multiple queries against the same data source.  \n  \n The query calls out to a separate method to obtain the file length. It does this in order to consume the possible exception that will be raised if the file was deleted on another thread after the <xref:System.IO.FileInfo> object was created in the call to `GetFiles`. Even though the <xref:System.IO.FileInfo> object has already been created, the exception can occur because a <xref:System.IO.FileInfo> object will try to refresh its <xref:System.IO.FileInfo.Length%2A> property with the most current length the first time the property is accessed. By putting this operation in a try-catch block outside the query, the code follows the rule of avoiding operations in queries that can cause side-effects. In general, great care must be taken when you consume exceptions to make sure that an application is not left in an unknown state.  \n  \n## Compiling the Code  \n Create a project that targets the .NET Framework  version 3.5 or higher, with a reference to   System.Core.dll and `using` directives for the System.Linq and System.IO namespaces.  \n  \n## See also\n\n- [LINQ to Objects (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-objects.md)\n- [LINQ and File Directories (C#)](../../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)\n","nodes":[{"pos":[4,157],"embed":true,"restype":"x-metadata","content":"title: \"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)\"\nms.date: 07/20/2015\nms.assetid: a01bd1d4-133c-4ca2-aa4e-e93e81d6076c","nodes":[{"content":"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)","nodes":[{"pos":[0,75],"content":"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)","nodes":[{"content":"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)","pos":[0,75]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[164,239],"content":"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)","linkify":"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)","nodes":[{"content":"How to: Query for the Total Number of Bytes in a Set of Folders (LINQ) (C#)","pos":[0,75]}]},{"content":"This example shows how to retrieve the total number of bytes used by all the files in a specified folder and all its subfolders.","pos":[240,368]},{"pos":[377,384],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Sum%2A&gt;</ph> method adds the values of all the items selected in the <ph id=\"ph2\">`select`</ph> clause.","pos":[388,501],"source":"The <xref:System.Linq.Enumerable.Sum%2A> method adds the values of all the items selected in the `select` clause."},{"content":"You can easily modify this query to retrieve the biggest or smallest file in the specified directory tree by calling the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Min%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Max%2A&gt;</ph> method instead of <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.Sum%2A&gt;</ph>.","pos":[502,755],"source":" You can easily modify this query to retrieve the biggest or smallest file in the specified directory tree by calling the <xref:System.Linq.Enumerable.Min%2A> or <xref:System.Linq.Enumerable.Max%2A> method instead of <xref:System.Linq.Enumerable.Sum%2A>."},{"content":"If you only have to count the number of bytes in a specified directory tree, you can do this more efficiently without creating a LINQ query, which incurs the overhead of creating the list collection as a data source.","pos":[2696,2912]},{"content":"The usefulness of the LINQ approach increases as the query becomes more complex, or when you have to run multiple queries against the same data source.","pos":[2913,3064]},{"content":"The query calls out to a separate method to obtain the file length.","pos":[3071,3138]},{"content":"It does this in order to consume the possible exception that will be raised if the file was deleted on another thread after the <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> object was created in the call to <ph id=\"ph2\">`GetFiles`</ph>.","pos":[3139,3338],"source":" It does this in order to consume the possible exception that will be raised if the file was deleted on another thread after the <xref:System.IO.FileInfo> object was created in the call to `GetFiles`."},{"content":"Even though the <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> object has already been created, the exception can occur because a <ph id=\"ph2\">&lt;xref:System.IO.FileInfo&gt;</ph> object will try to refresh its <ph id=\"ph3\">&lt;xref:System.IO.FileInfo.Length%2A&gt;</ph> property with the most current length the first time the property is accessed.","pos":[3339,3619],"source":" Even though the <xref:System.IO.FileInfo> object has already been created, the exception can occur because a <xref:System.IO.FileInfo> object will try to refresh its <xref:System.IO.FileInfo.Length%2A> property with the most current length the first time the property is accessed."},{"content":"By putting this operation in a try-catch block outside the query, the code follows the rule of avoiding operations in queries that can cause side-effects.","pos":[3620,3774]},{"content":"In general, great care must be taken when you consume exceptions to make sure that an application is not left in an unknown state.","pos":[3775,3905]},{"pos":[3914,3932],"content":"Compiling the Code","linkify":"Compiling the Code","nodes":[{"content":"Compiling the Code","pos":[0,18]}]},{"pos":[3936,4115],"content":"Create a project that targets the .NET Framework  version 3.5 or higher, with a reference to   System.Core.dll and <ph id=\"ph1\">`using`</ph> directives for the System.Linq and System.IO namespaces.","source":"Create a project that targets the .NET Framework  version 3.5 or higher, with a reference to   System.Core.dll and `using` directives for the System.Linq and System.IO namespaces."},{"pos":[4124,4132],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4136,4229],"content":"<bpt id=\"p1\">[</bpt>LINQ to Objects (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/linq-to-objects.md)</ept>","source":"[LINQ to Objects (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-objects.md)"},{"pos":[4232,4345],"content":"<bpt id=\"p1\">[</bpt>LINQ and File Directories (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)</ept>","source":"[LINQ and File Directories (C#)](../../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)"}]}