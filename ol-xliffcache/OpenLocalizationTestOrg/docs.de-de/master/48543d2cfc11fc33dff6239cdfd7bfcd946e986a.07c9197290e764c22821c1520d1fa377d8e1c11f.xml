{"content":"---\ntitle: \"Property Value Inheritance\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"inheritance [WPF], property values\"\n  - \"value inheritance [WPF]\"\n  - \"properties [WPF], value inheritance\"\nms.assetid: d7c338f9-f2bf-48ed-832c-7be58ac390e4\n---\n# Property Value Inheritance\nProperty value inheritance is a feature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system. Property value inheritance enables child elements in a tree of elements to obtain the value of a particular property from parent elements, inheriting that value as it was set anywhere in the nearest parent element. The parent element might also have obtained its value through property value inheritance, so the system potentially recurses all the way to the page root. Property value inheritance is not the default property system behavior; a property must be established with a particular metadata setting in order to cause that property to initiate property value inheritance on child elements.  \n\n<a name=\"Property_Value_Inheritance_is_Containment_Inheritance\"></a>   \n## Property Value Inheritance Is Containment Inheritance  \n \"Inheritance\" as a term here is not quite the same concept as inheritance in the context of types and general object-oriented programming, where derived classes inherit member definitions from their base classes. That meaning of inheritance is also active in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: properties defined in various base classes are exposed as attributes for derived [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] classes when used as elements, and exposed as members for code. Property value inheritance is particularly about how property values can inherit from one element to another on the basis of the parent-child relationships within a tree of elements. That tree of elements is most directly visible when nesting elements inside other elements as you define applications in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup. Trees of objects can also be created programmatically by adding objects to designated collections of other objects, and property value inheritance works the same way in the finished tree at run time.  \n  \n<a name=\"Practical_Applications_of_Property_Value_Inheritance\"></a>   \n## Practical Applications of Property Value Inheritance  \n The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] include several properties that have property inheritance enabled. Typically, the scenario for these is that they involve a property where it is appropriate that the property be set only once per page, but where that property is also a member of one of the base element classes and thus would also exist on most of the child elements. For example, the <xref:System.Windows.FrameworkElement.FlowDirection%2A> property controls which direction flowed content should be presented and arranged on the page. Typically, you want the text flow concept to be handled consistently throughout all child elements. If flow direction were for some reason reset in some level of the element tree by user or environment action, it should typically be reset throughout. When the <xref:System.Windows.FrameworkElement.FlowDirection%2A> property is made to inherit, the value need only be set or reset once at the level in the element tree that encompasses the presentation needs of each page in the application. Even the initial default value will inherit in this way. The property value inheritance model still enables individual elements to reset the value for the rare cases where having a mix of flow directions is intentional.  \n  \n<a name=\"Making_a_Custom_Property_Inheritable\"></a>   \n## Making a Custom Property Inheritable  \n By changing a custom property's metadata, you can also make your own custom properties inheritable. Note, however, that designating a property as inheritable does have some performance considerations. In cases where that property does not have an established local value, or a value obtained through styles, templates, or data binding, an inheritable property provides its assigned property values to all child elements in the logical tree.  \n  \n To make a property participate in value inheritance, create a custom attached property, as described in [Register an Attached Property](how-to-register-an-attached-property.md). Register the property with metadata (<xref:System.Windows.FrameworkPropertyMetadata>) and specify the \"Inherits\" option in the options settings within that metadata. Also make sure that the property has an established default value, because that value will now inherit. Although you registered the property as attached, you might also want to create a property \"wrapper\" for get/set access on the owner type, just as you would for an \"nonattached\" dependency property. After doing so, the inheritable property can either be set by using the direct property wrapper on the owner type or derived types, or it can be set by using the attached property syntax on any <xref:System.Windows.DependencyObject>.  \n  \n Attached properties are conceptually similar to global properties; you can check for the value on any <xref:System.Windows.DependencyObject> and get a valid result. The typical scenario for attached properties is to set property values on child elements, and that scenario is more effective if the property in question is an attached property that is always implicitly present as an attached property on each element (<xref:System.Windows.DependencyObject>) in the tree.  \n  \n> [!NOTE]\n>  Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the run-time tree is undefined. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.  \n  \n<a name=\"InheritanceContext\"></a>   \n## Inheriting Property Values Across Tree Boundaries  \n Property inheritance works by traversing a tree of elements. This tree is often parallel to the logical tree. However, whenever you include a WPF core-level object in the markup that defines an element tree, such as a <xref:System.Windows.Media.Brush>, you have created a discontinuous logical tree. A true logical tree does not conceptually extend through the <xref:System.Windows.Media.Brush>, because the logical tree is a WPF framework-level concept. You can see this reflected in the results when using the methods of <xref:System.Windows.LogicalTreeHelper>. However, property value inheritance can bridge this gap in the logical tree and can still pass inherited values through, so long as the inheritable property was registered as an attached property and no deliberate inheritance-blocking boundary (such as a <xref:System.Windows.Controls.Frame>) is encountered.  \n  \n## See also\n\n- [Dependency Property Metadata](dependency-property-metadata.md)\n- [Attached Properties Overview](attached-properties-overview.md)\n- [Dependency Property Value Precedence](dependency-property-value-precedence.md)\n","nodes":[{"pos":[4,245],"embed":true,"restype":"x-metadata","content":"title: \"Property Value Inheritance\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"inheritance [WPF], property values\"\n  - \"value inheritance [WPF]\"\n  - \"properties [WPF], value inheritance\"\nms.assetid: d7c338f9-f2bf-48ed-832c-7be58ac390e4","nodes":[{"content":"Property Value Inheritance","nodes":[{"pos":[0,26],"content":"Property Value Inheritance","nodes":[{"content":"Property Value Inheritance","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[252,278],"content":"Property Value Inheritance","linkify":"Property Value Inheritance","nodes":[{"content":"Property Value Inheritance","pos":[0,26]}]},{"content":"Property value inheritance is a feature of the <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> property system.","pos":[279,422],"source":"Property value inheritance is a feature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system."},{"content":"Property value inheritance enables child elements in a tree of elements to obtain the value of a particular property from parent elements, inheriting that value as it was set anywhere in the nearest parent element.","pos":[423,637]},{"content":"The parent element might also have obtained its value through property value inheritance, so the system potentially recurses all the way to the page root.","pos":[638,792]},{"content":"Property value inheritance is not the default property system behavior; a property must be established with a particular metadata setting in order to cause that property to initiate property value inheritance on child elements.","pos":[793,1020]},{"pos":[1099,1152],"content":"Property Value Inheritance Is Containment Inheritance","linkify":"Property Value Inheritance Is Containment Inheritance","nodes":[{"content":"Property Value Inheritance Is Containment Inheritance","pos":[0,53]}]},{"content":"\"Inheritance\" as a term here is not quite the same concept as inheritance in the context of types and general object-oriented programming, where derived classes inherit member definitions from their base classes.","pos":[1156,1368]},{"content":"That meaning of inheritance is also active in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>: properties defined in various base classes are exposed as attributes for derived <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> classes when used as elements, and exposed as members for code.","pos":[1369,1714],"source":" That meaning of inheritance is also active in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: properties defined in various base classes are exposed as attributes for derived [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] classes when used as elements, and exposed as members for code."},{"content":"Property value inheritance is particularly about how property values can inherit from one element to another on the basis of the parent-child relationships within a tree of elements.","pos":[1715,1897]},{"content":"That tree of elements is most directly visible when nesting elements inside other elements as you define applications in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> markup.","pos":[1898,2098],"source":" That tree of elements is most directly visible when nesting elements inside other elements as you define applications in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup."},{"content":"Trees of objects can also be created programmatically by adding objects to designated collections of other objects, and property value inheritance works the same way in the finished tree at run time.","pos":[2099,2298]},{"pos":[2378,2430],"content":"Practical Applications of Property Value Inheritance","linkify":"Practical Applications of Property Value Inheritance","nodes":[{"content":"Practical Applications of Property Value Inheritance","pos":[0,52]}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> <ph id=\"ph2\">[!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)]</ph> include several properties that have property inheritance enabled.","pos":[2434,2672],"source":"The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] include several properties that have property inheritance enabled."},{"content":"Typically, the scenario for these is that they involve a property where it is appropriate that the property be set only once per page, but where that property is also a member of one of the base element classes and thus would also exist on most of the child elements.","pos":[2673,2940]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> property controls which direction flowed content should be presented and arranged on the page.","pos":[2941,3108],"source":" For example, the <xref:System.Windows.FrameworkElement.FlowDirection%2A> property controls which direction flowed content should be presented and arranged on the page."},{"content":"Typically, you want the text flow concept to be handled consistently throughout all child elements.","pos":[3109,3208]},{"content":"If flow direction were for some reason reset in some level of the element tree by user or environment action, it should typically be reset throughout.","pos":[3209,3359]},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> property is made to inherit, the value need only be set or reset once at the level in the element tree that encompasses the presentation needs of each page in the application.","pos":[3360,3600],"source":" When the <xref:System.Windows.FrameworkElement.FlowDirection%2A> property is made to inherit, the value need only be set or reset once at the level in the element tree that encompasses the presentation needs of each page in the application."},{"content":"Even the initial default value will inherit in this way.","pos":[3601,3657]},{"content":"The property value inheritance model still enables individual elements to reset the value for the rare cases where having a mix of flow directions is intentional.","pos":[3658,3820]},{"pos":[3884,3920],"content":"Making a Custom Property Inheritable","linkify":"Making a Custom Property Inheritable","nodes":[{"content":"Making a Custom Property Inheritable","pos":[0,36]}]},{"content":"By changing a custom property's metadata, you can also make your own custom properties inheritable.","pos":[3924,4023]},{"content":"Note, however, that designating a property as inheritable does have some performance considerations.","pos":[4024,4124]},{"content":"In cases where that property does not have an established local value, or a value obtained through styles, templates, or data binding, an inheritable property provides its assigned property values to all child elements in the logical tree.","pos":[4125,4364]},{"content":"To make a property participate in value inheritance, create a custom attached property, as described in <bpt id=\"p1\">[</bpt>Register an Attached Property<ept id=\"p1\">](how-to-register-an-attached-property.md)</ept>.","pos":[4371,4548],"source":"To make a property participate in value inheritance, create a custom attached property, as described in [Register an Attached Property](how-to-register-an-attached-property.md)."},{"content":"Register the property with metadata (<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>) and specify the \"Inherits\" option in the options settings within that metadata.","pos":[4549,4714],"source":" Register the property with metadata (<xref:System.Windows.FrameworkPropertyMetadata>) and specify the \"Inherits\" option in the options settings within that metadata."},{"content":"Also make sure that the property has an established default value, because that value will now inherit.","pos":[4715,4818]},{"content":"Although you registered the property as attached, you might also want to create a property \"wrapper\" for get/set access on the owner type, just as you would for an \"nonattached\" dependency property.","pos":[4819,5017]},{"content":"After doing so, the inheritable property can either be set by using the direct property wrapper on the owner type or derived types, or it can be set by using the attached property syntax on any <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph>.","pos":[5018,5251],"source":" After doing so, the inheritable property can either be set by using the direct property wrapper on the owner type or derived types, or it can be set by using the attached property syntax on any <xref:System.Windows.DependencyObject>."},{"content":"Attached properties are conceptually similar to global properties; you can check for the value on any <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> and get a valid result.","pos":[5258,5422],"source":"Attached properties are conceptually similar to global properties; you can check for the value on any <xref:System.Windows.DependencyObject> and get a valid result."},{"content":"The typical scenario for attached properties is to set property values on child elements, and that scenario is more effective if the property in question is an attached property that is always implicitly present as an attached property on each element (<ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph>) in the tree.","pos":[5423,5728],"source":" The typical scenario for attached properties is to set property values on child elements, and that scenario is more effective if the property in question is an attached property that is always implicitly present as an attached property on each element (<xref:System.Windows.DependencyObject>) in the tree."},{"pos":[5736,6154],"content":"[!NOTE]\n Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the run-time tree is undefined. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.","leadings":["","> "],"nodes":[{"content":"Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the run-time tree is undefined. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata.","pos":[9,416],"nodes":[{"content":"Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the run-time tree is undefined.","pos":[0,217]},{"content":"Always use <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.","pos":[218,407],"source":" Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata."}]}]},{"pos":[6200,6249],"content":"Inheriting Property Values Across Tree Boundaries","linkify":"Inheriting Property Values Across Tree Boundaries","nodes":[{"content":"Inheriting Property Values Across Tree Boundaries","pos":[0,49]}]},{"content":"Property inheritance works by traversing a tree of elements.","pos":[6253,6313]},{"content":"This tree is often parallel to the logical tree.","pos":[6314,6362]},{"content":"However, whenever you include a WPF core-level object in the markup that defines an element tree, such as a <ph id=\"ph1\">&lt;xref:System.Windows.Media.Brush&gt;</ph>, you have created a discontinuous logical tree.","pos":[6363,6552],"source":" However, whenever you include a WPF core-level object in the markup that defines an element tree, such as a <xref:System.Windows.Media.Brush>, you have created a discontinuous logical tree."},{"content":"A true logical tree does not conceptually extend through the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Brush&gt;</ph>, because the logical tree is a WPF framework-level concept.","pos":[6553,6707],"source":" A true logical tree does not conceptually extend through the <xref:System.Windows.Media.Brush>, because the logical tree is a WPF framework-level concept."},{"content":"You can see this reflected in the results when using the methods of <ph id=\"ph1\">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>.","pos":[6708,6816],"source":" You can see this reflected in the results when using the methods of <xref:System.Windows.LogicalTreeHelper>."},{"content":"However, property value inheritance can bridge this gap in the logical tree and can still pass inherited values through, so long as the inheritable property was registered as an attached property and no deliberate inheritance-blocking boundary (such as a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Frame&gt;</ph>) is encountered.","pos":[6817,7125],"source":" However, property value inheritance can bridge this gap in the logical tree and can still pass inherited values through, so long as the inheritable property was registered as an attached property and no deliberate inheritance-blocking boundary (such as a <xref:System.Windows.Controls.Frame>) is encountered."},{"pos":[7134,7142],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7146,7209],"content":"<bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](dependency-property-metadata.md)</ept>","source":"[Dependency Property Metadata](dependency-property-metadata.md)"},{"pos":[7212,7275],"content":"<bpt id=\"p1\">[</bpt>Attached Properties Overview<ept id=\"p1\">](attached-properties-overview.md)</ept>","source":"[Attached Properties Overview](attached-properties-overview.md)"},{"pos":[7278,7357],"content":"<bpt id=\"p1\">[</bpt>Dependency Property Value Precedence<ept id=\"p1\">](dependency-property-value-precedence.md)</ept>","source":"[Dependency Property Value Precedence](dependency-property-value-precedence.md)"}]}