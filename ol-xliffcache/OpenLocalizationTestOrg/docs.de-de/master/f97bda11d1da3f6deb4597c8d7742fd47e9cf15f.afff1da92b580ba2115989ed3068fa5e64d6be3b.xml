{"content":"---\ntitle: What's new in C# 7.3\ndescription: An overview of new features in C# 7.3\nms.date: 05/16/2018\n---\n# What's new in C# 7.3\n\nThere are two main themes to the C# 7.3 release. One theme provides features that enable safe code to be as performant as unsafe code. The second theme provides incremental improvements to existing features. In addition, new compiler options were added in this release.\n\nThe following new features support the theme of better performance for safe code:\n\n- You can access fixed fields without pinning.\n- You can reassign `ref` local variables.\n- You can use initializers on `stackalloc` arrays.\n- You can use `fixed` statements with any type that supports a pattern.\n- You can use additional generic constraints.\n\nThe following enhancements were made to existing features:\n\n- You can test `==` and `!=` with tuple types.\n- You can use expression variables in more locations.\n- You may attach attributes to the backing field of auto-implemented properties.\n- Method resolution when arguments differ by `in` has been improved.\n- Overload resolution now has fewer ambiguous cases.\n\nThe new compiler options are:\n\n- `-publicsign` to enable Open Source Software (OSS) signing of assemblies.\n- `-pathmap` to provide a mapping for source directories.\n\nThe remainder of this article provides details and links to learn more about each of the improvements.\n\n## Enabling more efficient safe code\n\nYou should be able to write C# code safely that performs as well as unsafe code. Safe code avoids classes of errors, such as buffer overruns, stray pointers, and other memory access errors. These new features expand the capabilities of verifiable safe code. Strive to write more of your code using safe constructs. These features make that easier.\n\n### Indexing `fixed` fields does not require pinning\n\nConsider this struct:\n\n```csharp\nunsafe struct S\n{\n    public fixed int myFixedField[10];\n}\n```\n\nIn earlier versions of C#, you needed to pin a variable to access one of the integers that are part of `myFixedField`. Now, the following code compiles without pinning the variable `p` inside a separate `fixed` statement:\n\n```csharp\nclass C\n{\n    static S s = new S();\n\n    unsafe public void M()\n    {\n        int p = s.myFixedField[5];\n    }\n}\n```\n\nThe variable `p` accesses one element in `myFixedField`. You don't need to declare a separate `int*` variable. Note that you still need an `unsafe` context. In earlier versions of C#, you need to declare a second fixed pointer:\n\n```csharp\nclass C\n{\n    static S s = new S();\n\n    unsafe public void M()\n    {\n        fixed (int* ptr = s.myFixedField)\n        {\n            int p = ptr[5];\n        }\n    }\n}\n```\n\nFor more information, see the article on the [`fixed` statement](../language-reference/keywords/fixed-statement.md).\n\n### `ref` local variables may be reassigned\n\nNow, `ref` locals may be reassigned to refer to different instances after being initialized. The following code now compiles:\n\n```csharp\nref VeryLargeStruct refLocal = ref veryLargeStruct; // initialization\nrefLocal = ref anotherVeryLargeStruct; // reassigned, refLocal refers to different storage.\n```\n\nFor more information, see the article on [`ref` returns and `ref` locals](../programming-guide/classes-and-structs/ref-returns.md), and the article on [`foreach`](../language-reference/keywords/foreach-in.md).\n\n### `stackalloc` arrays support initializers\n\nYou've been able to specify the values for elements in an array when you initialize it:\n\n```csharp\nvar arr = new int[3] {1, 2, 3};\nvar arr2 = new int[] {1, 2, 3};\n```\n\nNow, that same syntax can be applied to arrays that are declared with `stackalloc`:\n\n```csharp\nint* pArr = stackalloc int[3] {1, 2, 3};\nint* pArr2 = stackalloc int[] {1, 2, 3};\nSpan<int> arr = stackalloc [] {1, 2, 3};\n```\n\nFor more information, see the [`stackalloc` statement](../language-reference/keywords/stackalloc.md) article in the language reference.\n\n### More types support the `fixed` statement\n\nThe `fixed` statement supported a limited set of types. Starting with C# 7.3, any type that contains a `GetPinnableReference()` method that returns a `ref T` or `ref readonly T` may be `fixed`. Adding this feature means that `fixed` can be used with <xref:System.Span%601?displayProperty=nameWithType> and related types.\n\nFor more information, see the [`fixed` statement](../language-reference/keywords/fixed-statement.md) article in the language reference.\n\n### Enhanced generic constraints\n\nYou can now specify the type <xref:System.Enum?displayProperty=nameWithType> or <xref:System.Delegate?displayProperty=nameWithType> as base class constraints for a type parameter.\n\nYou can also use the new `unmanaged` constraint, to specify that a type parameter must be an **unmanaged type**. An **unmanaged type** is a type that isn't a reference type and doesn't contain any reference type at any level of nesting.\n\nFor more information, see the articles on [`where` generic constraints](../language-reference/keywords/where-generic-type-constraint.md) and [constraints on type parameters](../programming-guide/generics/constraints-on-type-parameters.md).\n\nAdding these constraints to existing types is an [incompatible change](version-update-considerations.md#incompatible-changes). Closed generic types may no longer meet these new constraints.\n\n## Make existing features better\n\nThe second theme provides improvements to features in the language. These features improve productivity when writing C#.\n\n### Tuples support `==` and `!=`\n\nThe C# tuple types now support `==` and `!=`. For more information, see the section covering [equality](../tuples.md#equality-and-tuples) in the article on [tuples](../tuples.md).\n\n### Attach attributes to the backing fields for auto-implemented properties\n\nThis syntax is now supported:\n\n```csharp\n[field: SomeThingAboutFieldAttribute]\npublic int SomeProperty { get; set; }\n```\n\nThe attribute `SomeThingAboutFieldAttribute` is applied to the compiler generated backing field for `SomeProperty`. For more information, see [attributes](../programming-guide/concepts/attributes/index.md) in the C# programming guide.\n\n### `in` method overload resolution tiebreaker\n\nWhen the `in` argument modifier was added, these two methods would cause an ambiguity:\n\n```csharp\nstatic void M(S arg);\nstatic void M(in S arg);\n```\n\nNow, the by value (first in the preceding example) overload is better than the by readonly reference version. To call the version with the readonly reference argument, you must include the `in` modifier when calling the method.\n\n> [!NOTE]\n> This was implemented as a bug fix. This no longer is ambiguous even with the language version set to \"7.2\".\n\nFor more information, see the article on the [`in` parameter modifier](../language-reference/keywords/in-parameter-modifier.md).\n\n### Extend expression variables in initializers\n\nThe syntax added in C# 7.0 to allow `out` variable declarations has been extended to include field initializers, property initializers, constructor initializers, and query clauses. It enables code such as the following example:\n\n```csharp\npublic class B\n{\n   public B(int i, out int j)\n   {\n      j = i;\n   }\n}\n\npublic class D : B\n{\n   public D(int i) : base(i, out var j)\n   {\n      Console.WriteLine($\"The value of 'j' is {j}\");\n   }\n}\n```\n\n### Improved overload candidates\n\nIn every release, the overload resolution rules get updated to address situations where ambiguous method invocations have an \"obvious\" choice. This release adds three new rules to help the compiler pick the obvious choice:\n\n1. When a method group contains both instance and static members, the compiler discards the instance members if the method was invoked without an instance receiver or context. The compiler discards the static members if the method was invoked with an instance receiver. When there is no receiver, the compiler includes only static members in a static context, otherwise both static and instance members. When the receiver is ambiguously an instance or type, the compiler includes both. A static context, where an implicit `this` instance receiver cannot be used, includes the body of members where no `this` is defined, such as static members, as well as places where `this` cannot be used, such as field initializers and constructor-initializers.\n1. When a method group contains some generic methods whose type arguments do not satisfy their constraints, these members are removed from the candidate set.\n1. For a method group conversion, candidate methods whose return type doesn't match up with the delegate's return type are removed from the set.\n\nYou'll only notice this change because you'll find fewer compiler errors for ambiguous method overloads when you are sure which method is better.\n\n## New compiler options\n\nNew compiler options support new build and DevOps scenarios for C# programs.\n\n### Public or Open Source signing\n\nThe `-publicsign` compiler option instructs the compiler to sign the assembly using a public key. The assembly is marked as signed, but the signature is taken from the public key. This option enables you to build signed assemblies from open-source projects using a public key.\n\nFor more information, see the [-publicsign compiler option](../language-reference/compiler-options/publicsign-compiler-option.md) article.\n\n### pathmap\n\nThe `-pathmap` compiler option instructs the compiler to replace source paths from the build environment with mapped source paths. The `-pathmap` option controls the source path written by the compiler to PDB files or for the <xref:System.Runtime.CompilerServices.CallerFilePathAttribute>.\n\nFor more information, see the [-pathmap compiler option](../language-reference/compiler-options/pathmap-compiler-option.md) article.\n","nodes":[{"pos":[4,102],"embed":true,"restype":"x-metadata","content":"title: What's new in C# 7.3\ndescription: An overview of new features in C# 7.3\nms.date: 05/16/2018","nodes":[{"content":"What's new in C# 7.3","nodes":[{"pos":[0,20],"content":"What's new in C# 7.3","nodes":[{"content":"What's new in C# 7.3","pos":[0,20]}]}],"path":["title"],"nosxs":false},{"content":"An overview of new features in C# 7.3","nodes":[{"pos":[0,37],"content":"An overview of new features in C# 7.3","nodes":[{"content":"An overview of new features in C# 7.3","pos":[0,37]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[109,129],"content":"What's new in C# 7.3","linkify":"What's new in C# 7.3","nodes":[{"content":"What's new in C# 7.3","pos":[0,20]}]},{"content":"There are two main themes to the C# 7.3 release.","pos":[131,179]},{"content":"One theme provides features that enable safe code to be as performant as unsafe code.","pos":[180,265]},{"content":"The second theme provides incremental improvements to existing features.","pos":[266,338]},{"content":"In addition, new compiler options were added in this release.","pos":[339,400]},{"content":"The following new features support the theme of better performance for safe code:","pos":[402,483]},{"content":"You can access fixed fields without pinning.","pos":[487,531]},{"pos":[534,573],"content":"You can reassign <ph id=\"ph1\">`ref`</ph> local variables.","source":"You can reassign `ref` local variables."},{"pos":[576,624],"content":"You can use initializers on <ph id=\"ph1\">`stackalloc`</ph> arrays.","source":"You can use initializers on `stackalloc` arrays."},{"pos":[627,696],"content":"You can use <ph id=\"ph1\">`fixed`</ph> statements with any type that supports a pattern.","source":"You can use `fixed` statements with any type that supports a pattern."},{"content":"You can use additional generic constraints.","pos":[699,742]},{"content":"The following enhancements were made to existing features:","pos":[744,802]},{"pos":[806,850],"content":"You can test <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph> with tuple types.","source":"You can test `==` and `!=` with tuple types."},{"content":"You can use expression variables in more locations.","pos":[853,904]},{"content":"You may attach attributes to the backing field of auto-implemented properties.","pos":[907,985]},{"pos":[988,1054],"content":"Method resolution when arguments differ by <ph id=\"ph1\">`in`</ph> has been improved.","source":"Method resolution when arguments differ by `in` has been improved."},{"content":"Overload resolution now has fewer ambiguous cases.","pos":[1057,1107]},{"content":"The new compiler options are:","pos":[1109,1138]},{"pos":[1142,1215],"content":"<ph id=\"ph1\">`-publicsign`</ph> to enable Open Source Software (OSS) signing of assemblies.","source":"`-publicsign` to enable Open Source Software (OSS) signing of assemblies."},{"pos":[1218,1273],"content":"<ph id=\"ph1\">`-pathmap`</ph> to provide a mapping for source directories.","source":"`-pathmap` to provide a mapping for source directories."},{"content":"The remainder of this article provides details and links to learn more about each of the improvements.","pos":[1275,1377]},{"pos":[1382,1415],"content":"Enabling more efficient safe code","linkify":"Enabling more efficient safe code","nodes":[{"content":"Enabling more efficient safe code","pos":[0,33]}]},{"content":"You should be able to write C# code safely that performs as well as unsafe code.","pos":[1417,1497]},{"content":"Safe code avoids classes of errors, such as buffer overruns, stray pointers, and other memory access errors.","pos":[1498,1606]},{"content":"These new features expand the capabilities of verifiable safe code.","pos":[1607,1674]},{"content":"Strive to write more of your code using safe constructs.","pos":[1675,1731]},{"content":"These features make that easier.","pos":[1732,1764]},{"pos":[1770,1818],"content":"Indexing <ph id=\"ph1\">`fixed`</ph> fields does not require pinning","linkify":"Indexing `fixed` fields does not require pinning","source":"Indexing `fixed` fields does not require pinning"},{"content":"Consider this struct:","pos":[1820,1841]},{"content":"In earlier versions of C#, you needed to pin a variable to access one of the integers that are part of <ph id=\"ph1\">`myFixedField`</ph>.","pos":[1917,2035],"source":"In earlier versions of C#, you needed to pin a variable to access one of the integers that are part of `myFixedField`."},{"content":"Now, the following code compiles without pinning the variable <ph id=\"ph1\">`p`</ph> inside a separate <ph id=\"ph2\">`fixed`</ph> statement:","pos":[2036,2138],"source":" Now, the following code compiles without pinning the variable `p` inside a separate `fixed` statement:"},{"content":"The variable <ph id=\"ph1\">`p`</ph> accesses one element in <ph id=\"ph2\">`myFixedField`</ph>.","pos":[2268,2324],"source":"The variable `p` accesses one element in `myFixedField`."},{"content":"You don't need to declare a separate <ph id=\"ph1\">`int*`</ph> variable.","pos":[2325,2378],"source":" You don't need to declare a separate `int*` variable."},{"content":"Note that you still need an <ph id=\"ph1\">`unsafe`</ph> context.","pos":[2379,2424],"source":" Note that you still need an `unsafe` context."},{"content":"In earlier versions of C#, you need to declare a second fixed pointer:","pos":[2425,2495]},{"pos":[2680,2796],"content":"For more information, see the article on the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`fixed`</ph> statement<ept id=\"p1\">](../language-reference/keywords/fixed-statement.md)</ept>.","source":"For more information, see the article on the [`fixed` statement](../language-reference/keywords/fixed-statement.md)."},{"pos":[2802,2841],"content":"<ph id=\"ph1\">`ref`</ph> local variables may be reassigned","linkify":"`ref` local variables may be reassigned","source":"`ref` local variables may be reassigned"},{"content":"Now, <ph id=\"ph1\">`ref`</ph> locals may be reassigned to refer to different instances after being initialized.","pos":[2843,2935],"source":"Now, `ref` locals may be reassigned to refer to different instances after being initialized."},{"content":"The following code now compiles:","pos":[2936,2968]},{"pos":[3147,3356],"content":"For more information, see the article on <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`ref`</ph> returns and <ph id=\"ph2\">`ref`</ph> locals<ept id=\"p1\">](../programming-guide/classes-and-structs/ref-returns.md)</ept>, and the article on <bpt id=\"p2\">[</bpt><ph id=\"ph3\">`foreach`</ph><ept id=\"p2\">](../language-reference/keywords/foreach-in.md)</ept>.","source":"For more information, see the article on [`ref` returns and `ref` locals](../programming-guide/classes-and-structs/ref-returns.md), and the article on [`foreach`](../language-reference/keywords/foreach-in.md)."},{"pos":[3362,3402],"content":"<ph id=\"ph1\">`stackalloc`</ph> arrays support initializers","linkify":"`stackalloc` arrays support initializers","source":"`stackalloc` arrays support initializers"},{"content":"You've been able to specify the values for elements in an array when you initialize it:","pos":[3404,3491]},{"pos":[3572,3655],"content":"Now, that same syntax can be applied to arrays that are declared with <ph id=\"ph1\">`stackalloc`</ph>:","source":"Now, that same syntax can be applied to arrays that are declared with `stackalloc`:"},{"pos":[3795,3930],"content":"For more information, see the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`stackalloc`</ph> statement<ept id=\"p1\">](../language-reference/keywords/stackalloc.md)</ept> article in the language reference.","source":"For more information, see the [`stackalloc` statement](../language-reference/keywords/stackalloc.md) article in the language reference."},{"pos":[3936,3976],"content":"More types support the <ph id=\"ph1\">`fixed`</ph> statement","linkify":"More types support the `fixed` statement","source":"More types support the `fixed` statement"},{"content":"The <ph id=\"ph1\">`fixed`</ph> statement supported a limited set of types.","pos":[3978,4033],"source":"The `fixed` statement supported a limited set of types."},{"content":"Starting with C# 7.3, any type that contains a <ph id=\"ph1\">`GetPinnableReference()`</ph> method that returns a <ph id=\"ph2\">`ref T`</ph> or <ph id=\"ph3\">`ref readonly T`</ph> may be <ph id=\"ph4\">`fixed`</ph>.","pos":[4034,4171],"source":" Starting with C# 7.3, any type that contains a `GetPinnableReference()` method that returns a `ref T` or `ref readonly T` may be `fixed`."},{"content":"Adding this feature means that <ph id=\"ph1\">`fixed`</ph> can be used with <ph id=\"ph2\">&lt;xref:System.Span%601?displayProperty=nameWithType&gt;</ph> and related types.","pos":[4172,4298],"source":" Adding this feature means that `fixed` can be used with <xref:System.Span%601?displayProperty=nameWithType> and related types."},{"pos":[4300,4435],"content":"For more information, see the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`fixed`</ph> statement<ept id=\"p1\">](../language-reference/keywords/fixed-statement.md)</ept> article in the language reference.","source":"For more information, see the [`fixed` statement](../language-reference/keywords/fixed-statement.md) article in the language reference."},{"pos":[4441,4469],"content":"Enhanced generic constraints","linkify":"Enhanced generic constraints","nodes":[{"content":"Enhanced generic constraints","pos":[0,28]}]},{"pos":[4471,4650],"content":"You can now specify the type <ph id=\"ph1\">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Delegate?displayProperty=nameWithType&gt;</ph> as base class constraints for a type parameter.","source":"You can now specify the type <xref:System.Enum?displayProperty=nameWithType> or <xref:System.Delegate?displayProperty=nameWithType> as base class constraints for a type parameter."},{"content":"You can also use the new <ph id=\"ph1\">`unmanaged`</ph> constraint, to specify that a type parameter must be an <bpt id=\"p1\">**</bpt>unmanaged type<ept id=\"p1\">**</ept>.","pos":[4652,4764],"source":"You can also use the new `unmanaged` constraint, to specify that a type parameter must be an **unmanaged type**."},{"content":"An <bpt id=\"p1\">**</bpt>unmanaged type<ept id=\"p1\">**</ept> is a type that isn't a reference type and doesn't contain any reference type at any level of nesting.","pos":[4765,4888],"source":" An **unmanaged type** is a type that isn't a reference type and doesn't contain any reference type at any level of nesting."},{"pos":[4890,5129],"content":"For more information, see the articles on <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`where`</ph> generic constraints<ept id=\"p1\">](../language-reference/keywords/where-generic-type-constraint.md)</ept> and <bpt id=\"p2\">[</bpt>constraints on type parameters<ept id=\"p2\">](../programming-guide/generics/constraints-on-type-parameters.md)</ept>.","source":"For more information, see the articles on [`where` generic constraints](../language-reference/keywords/where-generic-type-constraint.md) and [constraints on type parameters](../programming-guide/generics/constraints-on-type-parameters.md)."},{"content":"Adding these constraints to existing types is an <bpt id=\"p1\">[</bpt>incompatible change<ept id=\"p1\">](version-update-considerations.md#incompatible-changes)</ept>.","pos":[5131,5257],"source":"Adding these constraints to existing types is an [incompatible change](version-update-considerations.md#incompatible-changes)."},{"content":"Closed generic types may no longer meet these new constraints.","pos":[5258,5320]},{"pos":[5325,5354],"content":"Make existing features better","linkify":"Make existing features better","nodes":[{"content":"Make existing features better","pos":[0,29]}]},{"content":"The second theme provides improvements to features in the language.","pos":[5356,5423]},{"content":"These features improve productivity when writing C#.","pos":[5424,5476]},{"pos":[5482,5510],"content":"Tuples support <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph>","linkify":"Tuples support `==` and `!=`","source":"Tuples support `==` and `!=`"},{"content":"The C# tuple types now support <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph>.","pos":[5512,5557],"source":"The C# tuple types now support `==` and `!=`."},{"content":"For more information, see the section covering <bpt id=\"p1\">[</bpt>equality<ept id=\"p1\">](../tuples.md#equality-and-tuples)</ept> in the article on <bpt id=\"p2\">[</bpt>tuples<ept id=\"p2\">](../tuples.md)</ept>.","pos":[5558,5691],"source":" For more information, see the section covering [equality](../tuples.md#equality-and-tuples) in the article on [tuples](../tuples.md)."},{"pos":[5697,5768],"content":"Attach attributes to the backing fields for auto-implemented properties","linkify":"Attach attributes to the backing fields for auto-implemented properties","nodes":[{"content":"Attach attributes to the backing fields for auto-implemented properties","pos":[0,71]}]},{"content":"This syntax is now supported:","pos":[5770,5799]},{"content":"The attribute <ph id=\"ph1\">`SomeThingAboutFieldAttribute`</ph> is applied to the compiler generated backing field for <ph id=\"ph2\">`SomeProperty`</ph>.","pos":[5892,6007],"source":"The attribute `SomeThingAboutFieldAttribute` is applied to the compiler generated backing field for `SomeProperty`."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>attributes<ept id=\"p1\">](../programming-guide/concepts/attributes/index.md)</ept> in the C# programming guide.","pos":[6008,6126],"source":" For more information, see [attributes](../programming-guide/concepts/attributes/index.md) in the C# programming guide."},{"pos":[6132,6174],"content":"<ph id=\"ph1\">`in`</ph> method overload resolution tiebreaker","linkify":"`in` method overload resolution tiebreaker","source":"`in` method overload resolution tiebreaker"},{"pos":[6176,6262],"content":"When the <ph id=\"ph1\">`in`</ph> argument modifier was added, these two methods would cause an ambiguity:","source":"When the `in` argument modifier was added, these two methods would cause an ambiguity:"},{"content":"Now, the by value (first in the preceding example) overload is better than the by readonly reference version.","pos":[6326,6435]},{"content":"To call the version with the readonly reference argument, you must include the <ph id=\"ph1\">`in`</ph> modifier when calling the method.","pos":[6436,6553],"source":" To call the version with the readonly reference argument, you must include the `in` modifier when calling the method."},{"pos":[6557,6674],"content":"[!NOTE]\nThis was implemented as a bug fix. This no longer is ambiguous even with the language version set to \"7.2\".","leadings":["","> "],"nodes":[{"content":"This was implemented as a bug fix. This no longer is ambiguous even with the language version set to \"7.2\".","pos":[8,115],"nodes":[{"content":"This was implemented as a bug fix.","pos":[0,34]},{"content":"This no longer is ambiguous even with the language version set to \"7.2\".","pos":[35,107]}]}]},{"pos":[6676,6804],"content":"For more information, see the article on the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`in`</ph> parameter modifier<ept id=\"p1\">](../language-reference/keywords/in-parameter-modifier.md)</ept>.","source":"For more information, see the article on the [`in` parameter modifier](../language-reference/keywords/in-parameter-modifier.md)."},{"pos":[6810,6853],"content":"Extend expression variables in initializers","linkify":"Extend expression variables in initializers","nodes":[{"content":"Extend expression variables in initializers","pos":[0,43]}]},{"content":"The syntax added in C# 7.0 to allow <ph id=\"ph1\">`out`</ph> variable declarations has been extended to include field initializers, property initializers, constructor initializers, and query clauses.","pos":[6855,7035],"source":"The syntax added in C# 7.0 to allow `out` variable declarations has been extended to include field initializers, property initializers, constructor initializers, and query clauses."},{"content":"It enables code such as the following example:","pos":[7036,7082]},{"pos":[7302,7330],"content":"Improved overload candidates","linkify":"Improved overload candidates","nodes":[{"content":"Improved overload candidates","pos":[0,28]}]},{"content":"In every release, the overload resolution rules get updated to address situations where ambiguous method invocations have an \"obvious\" choice.","pos":[7332,7474]},{"content":"This release adds three new rules to help the compiler pick the obvious choice:","pos":[7475,7554]},{"content":"When a method group contains both instance and static members, the compiler discards the instance members if the method was invoked without an instance receiver or context.","pos":[7559,7731]},{"content":"The compiler discards the static members if the method was invoked with an instance receiver.","pos":[7732,7825]},{"content":"When there is no receiver, the compiler includes only static members in a static context, otherwise both static and instance members.","pos":[7826,7959]},{"content":"When the receiver is ambiguously an instance or type, the compiler includes both.","pos":[7960,8041]},{"content":"A static context, where an implicit <ph id=\"ph1\">`this`</ph> instance receiver cannot be used, includes the body of members where no <ph id=\"ph2\">`this`</ph> is defined, such as static members, as well as places where <ph id=\"ph3\">`this`</ph> cannot be used, such as field initializers and constructor-initializers.","pos":[8042,8303],"source":" A static context, where an implicit `this` instance receiver cannot be used, includes the body of members where no `this` is defined, such as static members, as well as places where `this` cannot be used, such as field initializers and constructor-initializers."},{"content":"When a method group contains some generic methods whose type arguments do not satisfy their constraints, these members are removed from the candidate set.","pos":[8307,8461]},{"content":"For a method group conversion, candidate methods whose return type doesn't match up with the delegate's return type are removed from the set.","pos":[8465,8606]},{"content":"You'll only notice this change because you'll find fewer compiler errors for ambiguous method overloads when you are sure which method is better.","pos":[8608,8753]},{"pos":[8758,8778],"content":"New compiler options","linkify":"New compiler options","nodes":[{"content":"New compiler options","pos":[0,20]}]},{"content":"New compiler options support new build and DevOps scenarios for C# programs.","pos":[8780,8856]},{"pos":[8862,8891],"content":"Public or Open Source signing","linkify":"Public or Open Source signing","nodes":[{"content":"Public or Open Source signing","pos":[0,29]}]},{"content":"The <ph id=\"ph1\">`-publicsign`</ph> compiler option instructs the compiler to sign the assembly using a public key.","pos":[8893,8990],"source":"The `-publicsign` compiler option instructs the compiler to sign the assembly using a public key."},{"content":"The assembly is marked as signed, but the signature is taken from the public key.","pos":[8991,9072]},{"content":"This option enables you to build signed assemblies from open-source projects using a public key.","pos":[9073,9169]},{"pos":[9171,9309],"content":"For more information, see the <bpt id=\"p1\">[</bpt>-publicsign compiler option<ept id=\"p1\">](../language-reference/compiler-options/publicsign-compiler-option.md)</ept> article.","source":"For more information, see the [-publicsign compiler option](../language-reference/compiler-options/publicsign-compiler-option.md) article."},{"pos":[9315,9322],"content":"pathmap","linkify":"pathmap","nodes":[{"content":"pathmap","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`-pathmap`</ph> compiler option instructs the compiler to replace source paths from the build environment with mapped source paths.","pos":[9324,9454],"source":"The `-pathmap` compiler option instructs the compiler to replace source paths from the build environment with mapped source paths."},{"content":"The <ph id=\"ph1\">`-pathmap`</ph> option controls the source path written by the compiler to PDB files or for the <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.CallerFilePathAttribute&gt;</ph>.","pos":[9455,9613],"source":" The `-pathmap` option controls the source path written by the compiler to PDB files or for the <xref:System.Runtime.CompilerServices.CallerFilePathAttribute>."},{"pos":[9615,9747],"content":"For more information, see the <bpt id=\"p1\">[</bpt>-pathmap compiler option<ept id=\"p1\">](../language-reference/compiler-options/pathmap-compiler-option.md)</ept> article.","source":"For more information, see the [-pathmap compiler option](../language-reference/compiler-options/pathmap-compiler-option.md) article."}]}