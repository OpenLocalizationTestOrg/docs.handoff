{"content":"---\ntitle: \"Dynamically Loading and Using Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"late binding, about late binding\"\n  - \"early binding\"\n  - \"dynamically loading and using types\"\n  - \"implicit late binding\"\n  - \"reflection, dynamically using types\"\nms.assetid: db985bec-5942-40ec-b13a-771ae98623dc\ncaps.latest.revision: 15\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Dynamically Loading and Using Types\nReflection provides infrastructure used by language compilers such as [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] and JScript to implement implicit late binding. Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type. When this process occurs at run time rather than at compile time, it is called late binding. [!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)] allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type. The arguments passed to the helper method cause the appropriate method to be invoked at run time. These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).  \n  \n In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time. A **HelloWorld** class has a **PrintHello** method that prints out \"Hello World\" concatenated with some text that is passed to the **PrintHello** method. The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=fullName>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).  \n  \n```  \nImports System  \nModule Hello  \n    Sub Main()  \n        ' Sets up the variable.  \n        Dim helloObj As Object  \n        ' Creates the object.  \n        helloObj = new HelloWorld()  \n        ' Invokes the print method as if it was early bound  \n        ' even though it is really late bound.  \n        helloObj.PrintHello(\"Visual Basic Late Bound\")  \n    End Sub  \nEnd Module  \n```  \n  \n## Custom Binding  \n In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.  \n  \n The [common language runtime](../../../docs/standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ. In the early-bound case, code generators can completely control this binding. However, in late binding through reflection, binding must be controlled by customized binding. The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.  \n  \n Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type. This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.  \n  \n The following example demonstrates a simple custom binder that provides no argument type conversion. Code for `Simple_Type.dll` precedes the main example. Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.  \n  \n [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]\n [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]\n [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  \n  \n### InvokeMember and CreateInstance  \n Use <xref:System.Type.InvokeMember%2A?displayProperty=fullName> to invoke a member of a type. The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=fullName>, are specialized forms of **InvokeMember** that create new instances of the specified type. The **Binder** class is used for overload resolution and argument coercion in these methods.  \n  \n The following example shows the three possible combinations of argument coercion (type conversion) and member selection. In Case 1, no argument coercion or member selection is needed. In Case 2, only member selection is needed. In Case 3, only argument coercion is needed.  \n  \n [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]\n [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]\n [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  \n  \n Overload resolution is needed when more than one member with the same name is available. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=fullName> methods are used to resolve binding to a single member. **Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.  \n  \n **BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible. The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.  \n  \n When ByRef arguments are present, the caller might want to get them back. Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array. In order to do this, the caller must be guaranteed that the order of the arguments is unchanged. When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees. For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=fullName>.  \n  \n The set of available members are those members defined in the type or any base type. If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set. If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules. When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.  \n  \n If there is only one member of the given name, no callback is necessary, and binding is done on that method. Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.  \n  \n If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it. In Case 2 of the code example, there are two methods named **PrintValue**. The appropriate method is selected by the call to **BindToMethod**.  \n  \n <xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method. **ChangeType** is called for every argument even if the types match exactly.  \n  \n In Case 3 of the code example, an actual argument of type **String** with a value of \"5.5\" is passed to a method with a formal argument of type **Double**. For the invocation to succeed, the string value \"5.5\" must be converted to a double value. **ChangeType** performs this conversion.  \n  \n **ChangeType** performs only lossless or [widening coercions](../../../docs/standard/base-types/type-conversion.md), as shown in the following table.  \n  \n|Source type|Target type|  \n|-----------------|-----------------|  \n|Any type|Its base type|  \n|Any type|Interface it implements|  \n|Char|UInt16, UInt32, Int32, UInt64, Int64, Single, Double|  \n|Byte|Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  \n|SByte|Int16, Int32, Int64, Single, Double|  \n|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  \n|Int16|Int32, Int64, Single, Double|  \n|UInt32|UInt64, Int64, Single, Double|  \n|Int32|Int64, Single, Double|  \n|UInt64|Single, Double|  \n|Int64|Single, Double|  \n|Single|Double|  \n|Nonreference type|Reference type|  \n  \n The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member. <xref:System.Type.GetConstructor%2A?displayProperty=fullName>, <xref:System.Type.GetMethod%2A?displayProperty=fullName>, and <xref:System.Type.GetProperty%2A?displayProperty=fullName> search for a particular member of the current type by providing signature information for that member. <xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=fullName> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=fullName> are called back on to select the given signature information of the appropriate methods.  \n  \n## See Also  \n <xref:System.Type.InvokeMember%2A?displayProperty=fullName>   \n <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>   \n [Viewing Type Information](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)   \n [Type Conversion in the .NET Framework](../../../docs/standard/base-types/type-conversion.md)","nodes":[{"pos":[4,554],"embed":true,"restype":"x-metadata","content":"title: \"Dynamically Loading and Using Types | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"late binding, about late binding\"\n  - \"early binding\"\n  - \"dynamically loading and using types\"\n  - \"implicit late binding\"\n  - \"reflection, dynamically using types\"\nms.assetid: db985bec-5942-40ec-b13a-771ae98623dc\ncaps.latest.revision: 15\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","nodes":[{"content":"Dynamically Loading and Using Types | Microsoft Docs","nodes":[{"pos":[0,52],"content":"Dynamically Loading and Using Types | Microsoft Docs","nodes":[{"content":"Dynamically Loading and Using Types | Microsoft Docs","pos":[0,52]}]}],"path":["title"]}],"yml":true},{"pos":[561,596],"content":"Dynamically Loading and Using Types","linkify":"Dynamically Loading and Using Types","nodes":[{"content":"Dynamically Loading and Using Types","pos":[0,35]}]},{"content":"Reflection provides infrastructure used by language compilers such as <ph id=\"ph1\">[!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)]</ph> and JScript to implement implicit late binding.","pos":[597,771],"source":"Reflection provides infrastructure used by language compilers such as [!INCLUDE[vbprvbext](../../../includes/vbprvbext-md.md)] and JScript to implement implicit late binding."},{"content":"Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.","pos":[772,899]},{"content":"When this process occurs at run time rather than at compile time, it is called late binding.","pos":[900,992]},{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)]</ph> allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.","pos":[993,1201],"source":"[!INCLUDE[vbprvblong](../../../includes/vbprvblong-md.md)] allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type."},{"content":"The arguments passed to the helper method cause the appropriate method to be invoked at run time.","pos":[1202,1299]},{"content":"These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).","pos":[1300,1488]},{"content":"In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.","pos":[1495,1644]},{"content":"A <bpt id=\"p1\">**</bpt>HelloWorld<ept id=\"p1\">**</ept> class has a <bpt id=\"p2\">**</bpt>PrintHello<ept id=\"p2\">**</ept> method that prints out \"Hello World\" concatenated with some text that is passed to the <bpt id=\"p3\">**</bpt>PrintHello<ept id=\"p3\">**</ept> method.","pos":[1645,1798],"source":" A **HelloWorld** class has a **PrintHello** method that prints out \"Hello World\" concatenated with some text that is passed to the **PrintHello** method."},{"content":"The <bpt id=\"p1\">**</bpt>PrintHello<ept id=\"p1\">**</ept> method called in this example is actually a <ph id=\"ph1\">&lt;xref:System.Type.InvokeMember%2A?displayProperty=fullName&gt;</ph>; the Visual Basic code allows the <bpt id=\"p2\">**</bpt>PrintHello<ept id=\"p2\">**</ept> method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).","pos":[1799,2114],"source":" The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=fullName>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding)."},{"pos":[2519,2533],"content":"Custom Binding","linkify":"Custom Binding","nodes":[{"content":"Custom Binding","pos":[0,14]}]},{"content":"In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.","pos":[2537,2674]},{"content":"The <bpt id=\"p1\">[</bpt>common language runtime<ept id=\"p1\">](../../../docs/standard/clr.md)</ept> supports multiple programming languages, and the binding rules of these languages differ.","pos":[2681,2831],"source":"The [common language runtime](../../../docs/standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ."},{"content":"In the early-bound case, code generators can completely control this binding.","pos":[2832,2909]},{"content":"However, in late binding through reflection, binding must be controlled by customized binding.","pos":[2910,3004]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Binder&gt;</ph> class provides custom control of member selection and invocation.","pos":[3005,3106],"source":" The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation."},{"content":"Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.","pos":[3113,3322]},{"content":"This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.","pos":[3323,3457]},{"content":"The following example demonstrates a simple custom binder that provides no argument type conversion.","pos":[3464,3564]},{"content":"Code for <ph id=\"ph1\">`Simple_Type.dll`</ph> precedes the main example.","pos":[3565,3618],"source":" Code for `Simple_Type.dll` precedes the main example."},{"content":"Be sure to build <ph id=\"ph1\">`Simple_Type.dll`</ph> and then include a reference to it in the project at build time.","pos":[3619,3718],"source":" Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time."},{"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Types.Dynamic#1<ept id=\"p2\">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)</ept><ept id=\"p1\">]</ept>","pos":[3725,3854],"source":"[!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Types.Dynamic#1<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[3856,3989],"source":"[!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Conceptual.Types.Dynamic#1<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[3991,4125],"source":"[!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]"},{"pos":[4135,4166],"content":"InvokeMember and CreateInstance","linkify":"InvokeMember and CreateInstance","nodes":[{"content":"InvokeMember and CreateInstance","pos":[0,31]}]},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Type.InvokeMember%2A?displayProperty=fullName&gt;</ph> to invoke a member of a type.","pos":[4170,4263],"source":"Use <xref:System.Type.InvokeMember%2A?displayProperty=fullName> to invoke a member of a type."},{"content":"The <bpt id=\"p1\">**</bpt>CreateInstance<ept id=\"p1\">**</ept> methods of various classes, such as <ph id=\"ph1\">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=fullName&gt;</ph>, are specialized forms of <bpt id=\"p2\">**</bpt>InvokeMember<ept id=\"p2\">**</ept> that create new instances of the specified type.","pos":[4264,4562],"source":" The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=fullName>, are specialized forms of **InvokeMember** that create new instances of the specified type."},{"content":"The <bpt id=\"p1\">**</bpt>Binder<ept id=\"p1\">**</ept> class is used for overload resolution and argument coercion in these methods.","pos":[4563,4655],"source":" The **Binder** class is used for overload resolution and argument coercion in these methods."},{"content":"The following example shows the three possible combinations of argument coercion (type conversion) and member selection.","pos":[4662,4782]},{"content":"In Case 1, no argument coercion or member selection is needed.","pos":[4783,4845]},{"content":"In Case 2, only member selection is needed.","pos":[4846,4889]},{"content":"In Case 3, only argument coercion is needed.","pos":[4890,4934]},{"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Types.Dynamic#2<ept id=\"p2\">](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)</ept><ept id=\"p1\">]</ept>","pos":[4941,5070],"source":"[!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Types.Dynamic#2<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)</ept><ept id=\"p1\">]</ept>","pos":[5072,5205],"source":"[!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Conceptual.Types.Dynamic#2<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)</ept><ept id=\"p1\">]</ept>","pos":[5207,5341],"source":"[!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]"},{"content":"Overload resolution is needed when more than one member with the same name is available.","pos":[5348,5436]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Binder.BindToField%2A?displayProperty=fullName&gt;</ph> methods are used to resolve binding to a single member.","pos":[5437,5645],"source":" The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=fullName> methods are used to resolve binding to a single member."},{"content":"<bpt id=\"p1\">**</bpt>Binder.BindToMethod<ept id=\"p1\">**</ept> also provides property resolution through the <bpt id=\"p2\">**</bpt>get<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>set<ept id=\"p3\">**</ept> property accessors.","pos":[5646,5755],"source":"**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors."},{"content":"<bpt id=\"p1\">**</bpt>BindToMethod<ept id=\"p1\">**</ept> returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodBase&gt;</ph> to invoke, or a null reference (<bpt id=\"p2\">**</bpt>Nothing<ept id=\"p2\">**</ept> in Visual Basic) if no such invocation is possible.","pos":[5762,5922],"source":"**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible."},{"content":"The <bpt id=\"p1\">**</bpt>MethodBase<ept id=\"p1\">**</ept> return value need not be one of those contained in the <bpt id=\"p2\">*</bpt>match<ept id=\"p2\">*</ept> parameter, although that is the usual case.","pos":[5923,6048],"source":" The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case."},{"content":"When ByRef arguments are present, the caller might want to get them back.","pos":[6055,6128]},{"content":"Therefore, <bpt id=\"p1\">**</bpt>Binder<ept id=\"p1\">**</ept> allows a client to map the array of arguments back to its original form if <bpt id=\"p2\">**</bpt>BindToMethod<ept id=\"p2\">**</ept> has manipulated the argument array.","pos":[6129,6278],"source":" Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array."},{"content":"In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.","pos":[6279,6375]},{"content":"When arguments are passed by name, <bpt id=\"p1\">**</bpt>Binder<ept id=\"p1\">**</ept> reorders the argument array, and that is what the caller sees.","pos":[6376,6484],"source":" When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees."},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=fullName&gt;</ph>.","pos":[6485,6592],"source":" For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=fullName>."},{"content":"The set of available members are those members defined in the type or any base type.","pos":[6599,6683]},{"content":"If <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> is specified, members of any accessibility will be returned in the set.","pos":[6684,6796],"source":" If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set."},{"content":"If <bpt id=\"p1\">**</bpt>BindingFlags.NonPublic<ept id=\"p1\">**</ept> is not specified, the binder must enforce accessibility rules.","pos":[6797,6889],"source":" If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules."},{"content":"When specifying the <bpt id=\"p1\">**</bpt>Public<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>NonPublic<ept id=\"p2\">**</ept> binding flag, you must also specify the <bpt id=\"p3\">**</bpt>Instance<ept id=\"p3\">**</ept> or <bpt id=\"p4\">**</bpt>Static<ept id=\"p4\">**</ept> binding flag, or no members will be returned.","pos":[6890,7050],"source":" When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned."},{"content":"If there is only one member of the given name, no callback is necessary, and binding is done on that method.","pos":[7057,7165]},{"content":"Case 1 of the code example illustrates this point: Only one <bpt id=\"p1\">**</bpt>PrintBob<ept id=\"p1\">**</ept> method is available, and therefore no callback is needed.","pos":[7166,7296],"source":" Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed."},{"content":"If there is more than one member in the available set, all these methods are passed to <bpt id=\"p1\">**</bpt>BindToMethod<ept id=\"p1\">**</ept>, which selects the appropriate method and returns it.","pos":[7303,7460],"source":"If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it."},{"content":"In Case 2 of the code example, there are two methods named <bpt id=\"p1\">**</bpt>PrintValue<ept id=\"p1\">**</ept>.","pos":[7461,7535],"source":" In Case 2 of the code example, there are two methods named **PrintValue**."},{"content":"The appropriate method is selected by the call to <bpt id=\"p1\">**</bpt>BindToMethod<ept id=\"p1\">**</ept>.","pos":[7536,7603],"source":" The appropriate method is selected by the call to **BindToMethod**."},{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.","pos":[7610,7797],"source":"<xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method."},{"content":"<bpt id=\"p1\">**</bpt>ChangeType<ept id=\"p1\">**</ept> is called for every argument even if the types match exactly.","pos":[7798,7874],"source":"**ChangeType** is called for every argument even if the types match exactly."},{"content":"In Case 3 of the code example, an actual argument of type <bpt id=\"p1\">**</bpt>String<ept id=\"p1\">**</ept> with a value of \"5.5\" is passed to a method with a formal argument of type <bpt id=\"p2\">**</bpt>Double<ept id=\"p2\">**</ept>.","pos":[7881,8036],"source":"In Case 3 of the code example, an actual argument of type **String** with a value of \"5.5\" is passed to a method with a formal argument of type **Double**."},{"content":"For the invocation to succeed, the string value \"5.5\" must be converted to a double value.","pos":[8037,8127]},{"content":"<bpt id=\"p1\">**</bpt>ChangeType<ept id=\"p1\">**</ept> performs this conversion.","pos":[8128,8168],"source":"**ChangeType** performs this conversion."},{"pos":[8175,8324],"content":"<bpt id=\"p1\">**</bpt>ChangeType<ept id=\"p1\">**</ept> performs only lossless or <bpt id=\"p2\">[</bpt>widening coercions<ept id=\"p2\">](../../../docs/standard/base-types/type-conversion.md)</ept>, as shown in the following table.","source":"**ChangeType** performs only lossless or [widening coercions](../../../docs/standard/base-types/type-conversion.md), as shown in the following table."},{"content":"Source type","pos":[8331,8342]},{"content":"Target type","pos":[8343,8354]},{"content":"Any type","pos":[8399,8407]},{"content":"Its base type","pos":[8408,8421]},{"content":"Any type","pos":[8426,8434]},{"content":"Interface it implements","pos":[8435,8458]},{"content":"Char","pos":[8463,8467]},{"content":"UInt16, UInt32, Int32, UInt64, Int64, Single, Double","pos":[8468,8520]},{"content":"Byte","pos":[8525,8529]},{"content":"Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double","pos":[8530,8595]},{"content":"SByte","pos":[8600,8605]},{"content":"Int16, Int32, Int64, Single, Double","pos":[8606,8641]},{"content":"UInt16","pos":[8646,8652]},{"content":"UInt32, Int32, UInt64, Int64, Single, Double","pos":[8653,8697]},{"content":"Int16","pos":[8702,8707]},{"content":"Int32, Int64, Single, Double","pos":[8708,8736]},{"content":"UInt32","pos":[8741,8747]},{"content":"UInt64, Int64, Single, Double","pos":[8748,8777]},{"content":"Int32","pos":[8782,8787]},{"content":"Int64, Single, Double","pos":[8788,8809]},{"content":"UInt64","pos":[8814,8820]},{"content":"Single, Double","pos":[8821,8835]},{"content":"Int64","pos":[8840,8845]},{"content":"Single, Double","pos":[8846,8860]},{"content":"Single","pos":[8865,8871]},{"content":"Double","pos":[8872,8878]},{"content":"Nonreference type","pos":[8883,8900]},{"content":"Reference type","pos":[8901,8915]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> class has <bpt id=\"p1\">**</bpt>Get<ept id=\"p1\">**</ept> methods that use parameters of type <bpt id=\"p2\">**</bpt>Binder<ept id=\"p2\">**</ept> to resolve references to a particular member.","pos":[8923,9056],"source":"The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetConstructor%2A?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Type.GetMethod%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Type.GetProperty%2A?displayProperty=fullName&gt;</ph> search for a particular member of the current type by providing signature information for that member.","pos":[9057,9343],"source":" <xref:System.Type.GetConstructor%2A?displayProperty=fullName>, <xref:System.Type.GetMethod%2A?displayProperty=fullName>, and <xref:System.Type.GetProperty%2A?displayProperty=fullName> search for a particular member of the current type by providing signature information for that member."},{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=fullName&gt;</ph> are called back on to select the given signature information of the appropriate methods.","pos":[9344,9584],"source":" <xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=fullName> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=fullName> are called back on to select the given signature information of the appropriate methods."},{"pos":[9593,9601],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.InvokeMember%2A?displayProperty=fullName&gt;</ph>","pos":[9605,9664],"source":"<xref:System.Type.InvokeMember%2A?displayProperty=fullName> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName&gt;</ph>","pos":[9669,9735],"source":"<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> "},{"content":"<bpt id=\"p1\">[</bpt>Viewing Type Information<ept id=\"p1\">](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)</ept><ph id=\"ph1\"> </ph>","pos":[9740,9843],"source":"[Viewing Type Information](../../../docs/framework/reflection-and-codedom/viewing-type-information.md) "},{"content":"<bpt id=\"p1\">[</bpt>Type Conversion in the .NET Framework<ept id=\"p1\">](../../../docs/standard/base-types/type-conversion.md)</ept>","pos":[9847,9940],"source":"[Type Conversion in the .NET Framework](../../../docs/standard/base-types/type-conversion.md)"}]}