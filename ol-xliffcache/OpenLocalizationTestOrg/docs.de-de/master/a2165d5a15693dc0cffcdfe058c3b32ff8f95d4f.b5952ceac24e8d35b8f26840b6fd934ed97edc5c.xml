{"content":"---\ntitle: \"Choosing a Filter | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 67ab5af9-b9d9-4300-b3b1-41abb5a1fd10\ncaps.latest.revision: 8\nauthor: \"wadepickett\"\nms.author: \"wpickett\"\nmanager: \"wpickett\"\n---\n# Choosing a Filter\nWhen configuring the Routing Service, it is important to select correct message filters and configure them to allow you to make exact matches against the messages you receive. If the filters you select are overly broad in their matches or are incorrectly configured, messages are routed incorrectly. If the filters are too restrictive, you may not have any valid routes available for some of your messages.  \n  \n## Filter Types  \n When selecting the filters that are used by the Routing Service, it is important that you understand how each filter works as well as what information is available as part of the incoming messages. For instance, if all messages are received over the same endpoint, the Address and EndpointName filters are not useful because all messages match these filters.  \n  \n### Action  \n The Action filter inspects the <xref:System.ServiceModel.Channels.MessageHeaders.Action%2A> property. If the contents of the Action header in the message match the filter data value specified in the filter configuration, then this filter returns `true`. The following example defines a `FilterElement` that uses the Action filter to match messages with an action header that contains a value of \"http://namespace/contract/operation/\".  \n  \n```xml  \n<filter name=\"action1\" filterType=\"Action\" filterData=\"http://namespace/contract/operation/\" />  \n```  \n  \n```csharp  \nActionMessageFilter action1 = new ActionMessageFilter(new string[] { \"http://namespace/contract/operation\" });  \n  \n```  \n  \n This filter should be used when routing messages that contain a unique Action header.  \n  \n### EndpointAddress  \n The EndpointAddress filter inspects the EndpointAddress that the message was received on. If the address that the message arrives at exactly matches the filter address specified in the filter configuration, then this filter returns `true`. The following example defines a `FilterElement` that uses the Address filter to match any messages addressed to \"http://\\<hostname>/vdir/s.svc/b\".  \n  \n```xml  \n<filter name=\"address1\" filterType=\"EndpointAddress\" filterData=\"http://host/vdir/s.svc/b\" />  \n  \n```  \n  \n```csharp  \nEndpointAddressMessageFilter address1 = new EndpointAddressMessageFilter(new EndpointAddress(\"http://host/vdir/s.svc/b\"), false);  \n  \n```  \n  \n> [!NOTE]\n>  It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name. Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.  \n>   \n>  This behavior can be modified to allow the comparison to evaluate the host name when configuring the Routing Service programmatically.  \n  \n This filter should be used when the incoming messages are addressed to a unique address.  \n  \n### EndpointAddressPrefix  \n The EndpointAddressPrefix filter is similar to the EndpointAddress filter. The EndpointAddressPrefix filter inspects the EndpointAddress that the message was received on. However the EndpointAddressPrefix filter acts as a wildcard by matching addresses that begin with the value specified in the filter configuration. The following example defines a `FilterElement` that uses the EndpointAddressPrefix filter to match any messages addressed to \"http://\\<hostname>/vdir*\".  \n  \n```xml  \n<filter name=\"prefix1\" filterType=\"EndpointAddressPrefix\" filterData=\"http://host/vdir\" />  \n  \n```  \n  \n```csharp  \nPrefixEndpointAddressMessageFilter prefix1 = new PrefixEndpointAddressMessageFilter(new EndpointAddress(\"http://host/vdir/s.svc/b\"), false);  \n  \n```  \n  \n> [!NOTE]\n>  It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name. Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.  \n  \n This filter should be used when routing incoming messages that share a common address prefix.  \n  \n### AND  \n The AND filter does not directly filter on a value within a message, but allows you to combine two other filters to create an `AND` condition where both filters must match the message before the AND filter evaluates to `true`. This allows you to create complex filters that only match if all the sub-filters match. The following example defines an address filter and an action filter, and then defines an AND filter that evaluates a message against both the address and action filters. If both the address and the action filters match, then the AND filter returns `true`.  \n  \n```xml  \n<filter name=\"address1\" filterType=\"AddressPrefix\" filterData=\"http://host/vdir\"/>  \n<filter name=\"action1\" filterType=\"Action\" filterData=\"http://namespace/contract/operation/\"/>  \n<filter name=\"and1\" filterType=\"And\" filter1=\"address1\" filter2=\"action1\" />  \n  \n```  \n  \n```csharp  \nEndpointAddressMessageFilter address1 = new EndpointAddressMessageFilter(new EndpointAddress(\"http://host/vdir/s.svc/b\"), false);  \nActionMessageFilter action1 = new ActionMessageFilter(new string[] { \"http://namespace/contract/operation\" });  \nStrictAndMessageFilter and1=new StrictAndMessageFilter(address1, action1);  \n  \n```  \n  \n This filter should be used when you must combine the logic from multiple filters to determine when a match should be made. For example, if you have multiple destinations that must receive only certain combinations of actions and messages to particular addresses, you can use an AND filter to combine the necessary Action and Address filters.  \n  \n### Custom  \n When selecting the Custom filter type, you must provide a customType value that contains the type of the assembly that contains the **MessageFilter** implementation to be used for this filter. Additionally, filterData must contain any values that the custom filter may require in its evaluation of messages. The following example defines a `FilterElement` that uses the `CustomAssembly.MyCustomMsgFilter` MessageFilter implementation.  \n  \n```xml  \n<filter name=\"custom1\" filterType=\"Custom\" customType=\"CustomAssembly.MyCustomMsgFilter, CustomAssembly\" filterData=\"Custom Data\" />  \n  \n```  \n  \n```csharp  \nMyCustomMsgFilter custom1=new MyCustomMsgFilter(\"Custom Data\");  \n```  \n  \n If you need to perform custom matching logic against a message that is not covered by the filters provided with [!INCLUDE[netfx_current_short](../../../../includes/netfx-current-short-md.md)], you must create a custom filter that is an implementation of the **MessageFilter** class. For example, you might create a custom filter that compares a field in the incoming message against a list of known values given to the filter as configuration, or that hashes a particular message element and then examines that value to determine whether the filter should return `true` or `false`.  \n  \n### EndpointName  \n The EndpointName filter inspects the name of the endpoint that received the message. The following example defines a `FilterElement` that uses the EndpointName filter to route messages received on the \"SvcEndpoint\".  \n  \n```xml  \n<filter name=\"name1\" filterType=\"Endpoint\" filterData=\"SvcEndpoint\" />  \n  \n```  \n  \n```csharp  \nEndpointNameMessageFilter name1 = new EndpointNameMessageFilter(\"SvcEndpoint\");  \n  \n```  \n  \n This filter is useful when the Routing Service exposes more than one named service endpoint. For example, you might expose two endpoints that the Routing Service uses to receive messages; one is used by priority customers who require real-time processing of their messages, while the other endpoint receives messages that are not time sensitive.  \n  \n While you can often use full address matching to determine which endpoint a message was received on, using the defined endpoint name instead is a convenient shortcut that is often less error prone, especially when configuring a Routing Service using a configuration file (where endpoint names are a required attribute).  \n  \n### MatchAll  \n The MatchAll filter matches any received message. It is useful if you must always route all received messages to a specific endpoint, such as a logging service that stores a copy of all received messages. The following example defines a `FilterElement` that uses the MatchAll filter.  \n  \n```xml  \n<filter name=\"matchAll1\" filterType=\"MatchAll\" />  \n  \n```  \n  \n```csharp  \nMatchAllMessageFilter matchAll1 = new MatchAllMessageFilter();  \n  \n```  \n  \n### XPath  \n The XPath filter allows you to specify an XPath query that is used to inspect a specific element within the message. XPath filtering is a powerful filtering option that allows you to directly inspect any XML addressable entry within the message; however it requires that you have specific knowledge of the structure of the messages that you are receiving. The following example defines a `FilterElement` that uses the XPath filter to inspect the message for an element named \"element\" within the namespace referenced by the \"ns\" namespace prefix.  \n  \n```xml  \n<filter name=\"xpath1\" filterType=\"XPath\" filterData=\"//ns:element\" />  \n  \n```  \n  \n```csharp  \nXPathMessageFilter xpath1=new XPathMessageFilter(\"//ns:element\");  \n  \n```  \n  \n This filter is useful if you know that the messages you are receiving contain a specific value. For example, if you are hosting two versions of the same service and you know that messages addressed to the newer version of the service contain a unique value in a custom header, you can create a filter that uses XPath to navigate to this header and compares the value present in the header to another given in the filter configuration to determine if the filter matches.  \n  \n Because XPath queries often contain unique namespaces, which are often lengthy or complex string values, the XPath filter allows you to use the namespace table to define unique prefixes for your namespaces. [!INCLUDE[crabout](../../../../includes/crabout-md.md)] the namespace table, see [Message Filters](../../../../docs/framework/wcf/feature-details/message-filters.md).  \n  \n [!INCLUDE[crabout](../../../../includes/crabout-md.md)]designing XPath queries, see [XPath Syntax](http://go.microsoft.com/fwlink/?LinkId=164592) (http://go.microsoft.com/fwlink/?LinkId=164592).  \n  \n## See Also  \n [Message Filters](../../../../docs/framework/wcf/feature-details/message-filters.md)   \n [How To: Use Filters](../../../../docs/framework/wcf/feature-details/how-to-use-filters.md)","nodes":[{"pos":[12,46],"content":"Choosing a Filter | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Choosing a Filter | Microsoft Docs","pos":[0,34]}]},{"pos":[353,370],"content":"Choosing a Filter","linkify":"Choosing a Filter","nodes":[{"content":"Choosing a Filter","pos":[0,17]}]},{"content":"When configuring the Routing Service, it is important to select correct message filters and configure them to allow you to make exact matches against the messages you receive.","pos":[371,546]},{"content":"If the filters you select are overly broad in their matches or are incorrectly configured, messages are routed incorrectly.","pos":[547,670]},{"content":"If the filters are too restrictive, you may not have any valid routes available for some of your messages.","pos":[671,777]},{"pos":[786,798],"content":"Filter Types","linkify":"Filter Types","nodes":[{"content":"Filter Types","pos":[0,12]}]},{"content":"When selecting the filters that are used by the Routing Service, it is important that you understand how each filter works as well as what information is available as part of the incoming messages.","pos":[802,999]},{"content":"For instance, if all messages are received over the same endpoint, the Address and EndpointName filters are not useful because all messages match these filters.","pos":[1000,1160]},{"pos":[1170,1176],"content":"Action","linkify":"Action","nodes":[{"content":"Action","pos":[0,6]}]},{"content":"The Action filter inspects the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeaders.Action%2A&gt;</ph> property.","pos":[1180,1281],"source":"The Action filter inspects the <xref:System.ServiceModel.Channels.MessageHeaders.Action%2A> property."},{"content":"If the contents of the Action header in the message match the filter data value specified in the filter configuration, then this filter returns <ph id=\"ph1\">`true`</ph>.","pos":[1282,1433],"source":" If the contents of the Action header in the message match the filter data value specified in the filter configuration, then this filter returns `true`."},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the Action filter to match messages with an action header that contains a value of \"http://namespace/contract/operation/\".","pos":[1434,1614],"source":" The following example defines a `FilterElement` that uses the Action filter to match messages with an action header that contains a value of \"http://namespace/contract/operation/\"."},{"content":"This filter should be used when routing messages that contain a unique Action header.","pos":[1874,1959]},{"pos":[1969,1984],"content":"EndpointAddress","linkify":"EndpointAddress","nodes":[{"content":"EndpointAddress","pos":[0,15]}]},{"content":"The EndpointAddress filter inspects the EndpointAddress that the message was received on.","pos":[1988,2077]},{"content":"If the address that the message arrives at exactly matches the filter address specified in the filter configuration, then this filter returns <ph id=\"ph1\">`true`</ph>.","pos":[2078,2227],"source":" If the address that the message arrives at exactly matches the filter address specified in the filter configuration, then this filter returns `true`."},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the Address filter to match any messages addressed to \"http://<ph id=\"ph2\">\\&lt;</ph>hostname&gt;/vdir/s.svc/b\".","pos":[2228,2374],"source":" The following example defines a `FilterElement` that uses the Address filter to match any messages addressed to \"http://\\<hostname>/vdir/s.svc/b\"."},{"pos":[2655,3018],"content":"[!NOTE]\n It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name. Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.","leadings":["","> "],"nodes":[{"content":" It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name. Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.","pos":[8,361],"nodes":[{"content":"It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name.","pos":[1,183]},{"content":"Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.","pos":[184,353]}]}]},{"content":"This behavior can be modified to allow the comparison to evaluate the host name when configuring the Routing Service programmatically.","pos":[3029,3163]},{"content":"This filter should be used when the incoming messages are addressed to a unique address.","pos":[3170,3258]},{"pos":[3268,3289],"content":"EndpointAddressPrefix","linkify":"EndpointAddressPrefix","nodes":[{"content":"EndpointAddressPrefix","pos":[0,21]}]},{"content":"The EndpointAddressPrefix filter is similar to the EndpointAddress filter.","pos":[3293,3367]},{"content":"The EndpointAddressPrefix filter inspects the EndpointAddress that the message was received on.","pos":[3368,3463]},{"content":"However the EndpointAddressPrefix filter acts as a wildcard by matching addresses that begin with the value specified in the filter configuration.","pos":[3464,3610]},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the EndpointAddressPrefix filter to match any messages addressed to \"http://<ph id=\"ph2\">\\&lt;</ph>hostname&gt;/vdir*\".","pos":[3611,3764],"source":" The following example defines a `FilterElement` that uses the EndpointAddressPrefix filter to match any messages addressed to \"http://\\<hostname>/vdir*\"."},{"pos":[4053,4416],"content":"[!NOTE]\n It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name. Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.","leadings":["","> "],"nodes":[{"content":" It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name. Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.","pos":[8,361],"nodes":[{"content":"It is important to note that the host name portion of an address can differ based on whether the client uses the fully qualified domain name, NetBIOS name, IP address, or other name.","pos":[1,183]},{"content":"Because differing values can refer to the same host, the default behavior for this comparison is to not use the host name portion of the address when performing matches.","pos":[184,353]}]}]},{"content":"This filter should be used when routing incoming messages that share a common address prefix.","pos":[4423,4516]},{"pos":[4526,4529],"content":"AND","linkify":"AND","nodes":[{"content":"AND","pos":[0,3]}]},{"content":"The AND filter does not directly filter on a value within a message, but allows you to combine two other filters to create an <ph id=\"ph1\">`AND`</ph> condition where both filters must match the message before the AND filter evaluates to <ph id=\"ph2\">`true`</ph>.","pos":[4533,4759],"source":"The AND filter does not directly filter on a value within a message, but allows you to combine two other filters to create an `AND` condition where both filters must match the message before the AND filter evaluates to `true`."},{"content":"This allows you to create complex filters that only match if all the sub-filters match.","pos":[4760,4847]},{"content":"The following example defines an address filter and an action filter, and then defines an AND filter that evaluates a message against both the address and action filters.","pos":[4848,5018]},{"content":"If both the address and the action filters match, then the AND filter returns <ph id=\"ph1\">`true`</ph>.","pos":[5019,5104],"source":" If both the address and the action filters match, then the AND filter returns `true`."},{"content":"This filter should be used when you must combine the logic from multiple filters to determine when a match should be made.","pos":[5739,5861]},{"content":"For example, if you have multiple destinations that must receive only certain combinations of actions and messages to particular addresses, you can use an AND filter to combine the necessary Action and Address filters.","pos":[5862,6080]},{"pos":[6090,6096],"content":"Custom","linkify":"Custom","nodes":[{"content":"Custom","pos":[0,6]}]},{"content":"When selecting the Custom filter type, you must provide a customType value that contains the type of the assembly that contains the <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> implementation to be used for this filter.","pos":[6100,6292],"source":"When selecting the Custom filter type, you must provide a customType value that contains the type of the assembly that contains the **MessageFilter** implementation to be used for this filter."},{"content":"Additionally, filterData must contain any values that the custom filter may require in its evaluation of messages.","pos":[6293,6407]},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the <ph id=\"ph2\">`CustomAssembly.MyCustomMsgFilter`</ph> MessageFilter implementation.","pos":[6408,6534],"source":" The following example defines a `FilterElement` that uses the `CustomAssembly.MyCustomMsgFilter` MessageFilter implementation."},{"content":"If you need to perform custom matching logic against a message that is not covered by the filters provided with <ph id=\"ph1\">[!INCLUDE[netfx_current_short](../../../../includes/netfx-current-short-md.md)]</ph>, you must create a custom filter that is an implementation of the <bpt id=\"p1\">**</bpt>MessageFilter<ept id=\"p1\">**</ept> class.","pos":[6784,7066],"source":"If you need to perform custom matching logic against a message that is not covered by the filters provided with [!INCLUDE[netfx_current_short](../../../../includes/netfx-current-short-md.md)], you must create a custom filter that is an implementation of the **MessageFilter** class."},{"content":"For example, you might create a custom filter that compares a field in the incoming message against a list of known values given to the filter as configuration, or that hashes a particular message element and then examines that value to determine whether the filter should return <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","pos":[7067,7365],"source":" For example, you might create a custom filter that compares a field in the incoming message against a list of known values given to the filter as configuration, or that hashes a particular message element and then examines that value to determine whether the filter should return `true` or `false`."},{"pos":[7375,7387],"content":"EndpointName","linkify":"EndpointName","nodes":[{"content":"EndpointName","pos":[0,12]}]},{"content":"The EndpointName filter inspects the name of the endpoint that received the message.","pos":[7391,7475]},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the EndpointName filter to route messages received on the \"SvcEndpoint\".","pos":[7476,7606],"source":" The following example defines a `FilterElement` that uses the EndpointName filter to route messages received on the \"SvcEndpoint\"."},{"content":"This filter is useful when the Routing Service exposes more than one named service endpoint.","pos":[7813,7905]},{"content":"For example, you might expose two endpoints that the Routing Service uses to receive messages; one is used by priority customers who require real-time processing of their messages, while the other endpoint receives messages that are not time sensitive.","pos":[7906,8158]},{"content":"While you can often use full address matching to determine which endpoint a message was received on, using the defined endpoint name instead is a convenient shortcut that is often less error prone, especially when configuring a Routing Service using a configuration file (where endpoint names are a required attribute).","pos":[8165,8484]},{"pos":[8494,8502],"content":"MatchAll","linkify":"MatchAll","nodes":[{"content":"MatchAll","pos":[0,8]}]},{"content":"The MatchAll filter matches any received message.","pos":[8506,8555]},{"content":"It is useful if you must always route all received messages to a specific endpoint, such as a logging service that stores a copy of all received messages.","pos":[8556,8710]},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the MatchAll filter.","pos":[8711,8789],"source":" The following example defines a `FilterElement` that uses the MatchAll filter."},{"pos":[8961,8966],"content":"XPath","linkify":"XPath","nodes":[{"content":"XPath","pos":[0,5]}]},{"content":"The XPath filter allows you to specify an XPath query that is used to inspect a specific element within the message.","pos":[8970,9086]},{"content":"XPath filtering is a powerful filtering option that allows you to directly inspect any XML addressable entry within the message; however it requires that you have specific knowledge of the structure of the messages that you are receiving.","pos":[9087,9325]},{"content":"The following example defines a <ph id=\"ph1\">`FilterElement`</ph> that uses the XPath filter to inspect the message for an element named \"element\" within the namespace referenced by the \"ns\" namespace prefix.","pos":[9326,9516],"source":" The following example defines a `FilterElement` that uses the XPath filter to inspect the message for an element named \"element\" within the namespace referenced by the \"ns\" namespace prefix."},{"content":"This filter is useful if you know that the messages you are receiving contain a specific value.","pos":[9708,9803]},{"content":"For example, if you are hosting two versions of the same service and you know that messages addressed to the newer version of the service contain a unique value in a custom header, you can create a filter that uses XPath to navigate to this header and compares the value present in the header to another given in the filter configuration to determine if the filter matches.","pos":[9804,10177]},{"content":"Because XPath queries often contain unique namespaces, which are often lengthy or complex string values, the XPath filter allows you to use the namespace table to define unique prefixes for your namespaces.","pos":[10184,10390]},{"content":"<ph id=\"ph1\">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> the namespace table, see <bpt id=\"p1\">[</bpt>Message Filters<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/message-filters.md)</ept>.","pos":[10391,10557],"source":"[!INCLUDE[crabout](../../../../includes/crabout-md.md)] the namespace table, see [Message Filters](../../../../docs/framework/wcf/feature-details/message-filters.md)."},{"pos":[10564,10758],"content":"<ph id=\"ph1\">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph>designing XPath queries, see <bpt id=\"p1\">[</bpt>XPath Syntax<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=164592)</ept> (http://go.microsoft.com/fwlink/?LinkId=164592).","source":"[!INCLUDE[crabout](../../../../includes/crabout-md.md)]designing XPath queries, see [XPath Syntax](http://go.microsoft.com/fwlink/?LinkId=164592) (http://go.microsoft.com/fwlink/?LinkId=164592)."},{"pos":[10767,10775],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Message Filters<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/message-filters.md)</ept><ph id=\"ph1\"> </ph>","pos":[10779,10864],"source":"[Message Filters](../../../../docs/framework/wcf/feature-details/message-filters.md) "},{"content":"<bpt id=\"p1\"> [</bpt>How To: Use Filters<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-use-filters.md)</ept>","pos":[10867,10959],"source":" [How To: Use Filters](../../../../docs/framework/wcf/feature-details/how-to-use-filters.md)"}]}