{"content":"---\ntitle: \"Object Lifetime: How Objects Are Created and Destroyed (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\nf1_keywords: \n  - \"vb.Constructor\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"destructors, object lifetime\"\n  - \"Sub Finalize destructor\"\n  - \"objects [Visual Basic], destroying\"\n  - \"lifetime, objects\"\n  - \"Sub New constructor, object lifetime\"\n  - \"Finalize method, object lifetime\"\n  - \"objects [Visual Basic], creating\"\n  - \"Class_Terminate\"\n  - \"Dispose method, object lifetime\"\n  - \"Class_Initialize\"\n  - \"object creation, object lifetime\"\n  - \"parameterized constructors\"\n  - \"objects [Visual Basic], lifetime\"\n  - \"objects [Visual Basic], garbage collection\"\n  - \"constructors [Visual Basic], object lifetime\"\n  - \"Sub Dispose destructor\"\n  - \"garbage collection, Visual Basic\"\nms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8\ncaps.latest.revision: 22\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)\nAn instance of a class, an object, is created by using the `New` keyword. Initialization tasks often must be performed on new objects before they are used. Common initialization tasks include opening files, connecting to databases, and reading values of registry keys. Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).  \n  \n After an object leaves scope, it is released by the common language runtime (CLR). Visual Basic controls the release of system resources using procedures called *destructors*. Together, constructors and destructors support the creation of robust and predictable class libraries.  \n  \n## Using Constructors and Destructors  \n Constructors and destructors control the creation and destruction of objects. The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 6.0 and earlier versions.  \n  \n### Sub New  \n The `Sub New` constructor can run only once when a class is created. It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class. Furthermore, the code in the `Sub New` method always runs before any other code in a class. [!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] and later versions implicitly create a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.  \n  \n To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition. To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:  \n  \n [!code-vb[VbVbalrOOP#42](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_1.vb)]  \n  \n Constructors are frequently overloaded, as in the following code:  \n  \n [!code-vb[VbVbalrOOP#116](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_2.vb)]  \n  \n When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters. A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`. Otherwise, `MyBase.New` is optional, and the [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] runtime calls it implicitly.  \n  \n After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure. `Sub New` can accept arguments when called as a parameterized constructor. These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.  \n  \n### Sub Finalize  \n Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure. The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information. There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.  \n  \n> [!NOTE]\n>  The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment. This is because different unmanaged objects must be disposed of in different ways. That information is not directly associated with the unmanaged object; it must be found in the documentation for the object. A class that uses unmanaged objects must dispose of them in its `Finalize` method.  \n  \n The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes. The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.  \n  \n Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor. [!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] and later versions allow for a second kind of destructor, <xref:System.IDisposable.Dispose%2A>, which can be explicitly called at any time to immediately release resources.  \n  \n> [!NOTE]\n>  A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.  \n  \n### How New and Finalize Methods Work in a Class Hierarchy  \n Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object. `New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes. A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.  \n  \n When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes. This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy. The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached. At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.  \n  \n ![Constructors and Inheritance](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif \"vaConstructorsInheritance\")  \n  \n When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory. The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.  \n  \n ![Constructors Inheritance2](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif \"vaConstructorsInheritance_2\")  \n  \n## IDisposable Interface  \n Class instances often control resources not managed by the CLR, such as Windows handles and database connections. These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector. However, the garbage collector destroys objects only when the CLR requires more free memory. This means that the resources may not be released until long after the object goes out of scope.  \n  \n To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface. <xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object. You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections. Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically. Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.  \n  \n### Implementing IDisposable  \n A class that implements the <xref:System.IDisposable> interface should include these sections of code:  \n  \n-   A field for keeping track of whether the object has been disposed:  \n  \n    ```  \n    Protected disposed As Boolean = False  \n    ```  \n  \n-   An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources. This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:  \n  \n    ```  \n    Protected Overridable Sub Dispose(ByVal disposing As Boolean)  \n        If Not Me.disposed Then  \n            If disposing Then  \n                ' Insert code to free managed resources.  \n            End If  \n            ' Insert code to free unmanaged resources.  \n        End If  \n        Me.disposed = True  \n    End Sub  \n    ```  \n  \n-   An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:  \n  \n    ```  \n    Public Sub Dispose() Implements IDisposable.Dispose  \n        Dispose(True)  \n        GC.SuppressFinalize(Me)  \n    End Sub  \n    ```  \n  \n-   An override of the `Finalize` method that contains only the following code:  \n  \n    ```  \n    Protected Overrides Sub Finalize()  \n        Dispose(False)  \n        MyBase.Finalize()  \n    End Sub  \n    ```  \n  \n### Deriving from a Class that Implements IDisposable  \n A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed. In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources. This override must call the base class's `Dispose(disposing)` method.  \n  \n```  \nProtected Overrides Sub Dispose(ByVal disposing As Boolean)  \n    If Not Me.disposed Then  \n        If disposing Then  \n            ' Insert code to free managed resources.  \n        End If  \n        ' Insert code to free unmanaged resources.  \n    End If  \n    MyBase.Dispose(disposing)  \nEnd Sub  \n```  \n  \n A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods. When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.  \n  \n## Garbage Collection and the Finalize Destructor  \n The [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] uses the *reference-tracing garbage collection* system to periodically release unused resources. Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources. Although both systems perform the same function automatically, there are a few important differences.  \n  \n The CLR periodically destroys objects when the system determines that such objects are no longer needed. Objects are released more quickly when system resources are in short supply, and less frequently otherwise. The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed. In such a situation, objects are said to have *non-deterministic lifetime*. In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.  \n  \n Another difference between the garbage-collection systems involves the use of `Nothing`. To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held. If the variable held the last reference to the object, the object's resources were released immediately. In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately. To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available. The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.  \n  \n## See Also  \n <xref:System.IDisposable.Dispose%2A>   \n [Initialization and Termination of Components](http://msdn.microsoft.com/library/58444076-a9d2-4c91-b3f6-0e180dc0695d)   \n [New Operator](../../../../visual-basic/language-reference/operators/new-operator.md)   \n [Cleaning Up Unmanaged Resources](../../../../standard/garbage-collection/unmanaged.md)   \n [Nothing](../../../../visual-basic/language-reference/nothing.md)","nodes":[{"pos":[12,98],"content":"Object Lifetime: How Objects Are Created and Destroyed (Visual Basic) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Object Lifetime: How Objects Are Created and Destroyed (Visual Basic) | Microsoft Docs","pos":[0,86]}]},{"pos":[1241,1310],"content":"Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)","linkify":"Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)","nodes":[{"content":"Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)","pos":[0,69]}]},{"content":"An instance of a class, an object, is created by using the <ph id=\"ph1\">`New`</ph> keyword.","pos":[1311,1384],"source":"An instance of a class, an object, is created by using the `New` keyword."},{"content":"Initialization tasks often must be performed on new objects before they are used.","pos":[1385,1466]},{"content":"Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.","pos":[1467,1579]},{"content":"Visual Basic controls the initialization of new objects using procedures called <bpt id=\"p1\">*</bpt>constructors<ept id=\"p1\">*</ept> (special methods that allow control over initialization).","pos":[1580,1732],"source":" Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization)."},{"content":"After an object leaves scope, it is released by the common language runtime (CLR).","pos":[1739,1821]},{"content":"Visual Basic controls the release of system resources using procedures called <bpt id=\"p1\">*</bpt>destructors<ept id=\"p1\">*</ept>.","pos":[1822,1914],"source":" Visual Basic controls the release of system resources using procedures called *destructors*."},{"content":"Together, constructors and destructors support the creation of robust and predictable class libraries.","pos":[1915,2017]},{"pos":[2026,2060],"content":"Using Constructors and Destructors","linkify":"Using Constructors and Destructors","nodes":[{"content":"Using Constructors and Destructors","pos":[0,34]}]},{"content":"Constructors and destructors control the creation and destruction of objects.","pos":[2064,2141]},{"content":"The <ph id=\"ph1\">`Sub New`</ph> and <ph id=\"ph2\">`Sub Finalize`</ph> procedures in Visual Basic initialize and destroy objects; they replace the <ph id=\"ph3\">`Class_Initialize`</ph> and <ph id=\"ph4\">`Class_Terminate`</ph> methods used in <ph id=\"ph5\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> 6.0 and earlier versions.","pos":[2142,2426],"source":" The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 6.0 and earlier versions."},{"pos":[2436,2443],"content":"Sub New","linkify":"Sub New","nodes":[{"content":"Sub New","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`Sub New`</ph> constructor can run only once when a class is created.","pos":[2447,2515],"source":"The `Sub New` constructor can run only once when a class is created."},{"content":"It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.","pos":[2516,2667]},{"content":"Furthermore, the code in the <ph id=\"ph1\">`Sub New`</ph> method always runs before any other code in a class.","pos":[2668,2759],"source":" Furthermore, the code in the `Sub New` method always runs before any other code in a class."},{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]</ph> and later versions implicitly create a <ph id=\"ph2\">`Sub New`</ph> constructor at run time if you do not explicitly define a <ph id=\"ph3\">`Sub New`</ph> procedure for a class.","pos":[2760,3015],"source":"[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] and later versions implicitly create a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class."},{"content":"To create a constructor for a class, create a procedure named <ph id=\"ph1\">`Sub New`</ph> anywhere in the class definition.","pos":[3022,3127],"source":"To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition."},{"content":"To create a parameterized constructor, specify the names and data types of arguments to <ph id=\"ph1\">`Sub New`</ph> just as you would specify arguments for any other procedure, as in the following code:","pos":[3128,3312],"source":" To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:"},{"pos":[3319,3458],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrOOP#42<ept id=\"p2\">](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_1.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrOOP#42](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_1.vb)]"},{"content":"Constructors are frequently overloaded, as in the following code:","pos":[3465,3530]},{"pos":[3537,3677],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrOOP#116<ept id=\"p2\">](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_2.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrOOP#116](../../../../visual-basic/misc/codesnippet/VisualBasic/object-lifetime-how-objects-are-created-and-destroyed_2.vb)]"},{"content":"When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.","pos":[3684,3898]},{"content":"A call to the base class that contains the above constructor, for example, would be <ph id=\"ph1\">`MyBase.New(s)`</ph>.","pos":[3899,3999],"source":" A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`."},{"content":"Otherwise, <ph id=\"ph1\">`MyBase.New`</ph> is optional, and the <ph id=\"ph2\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> runtime calls it implicitly.","pos":[4000,4166],"source":" Otherwise, `MyBase.New` is optional, and the [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] runtime calls it implicitly."},{"content":"After you write the code to call the parent object's constructor, you can add any additional initialization code to the <ph id=\"ph1\">`Sub New`</ph> procedure.","pos":[4173,4313],"source":"After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure."},{"content":"<ph id=\"ph1\">`Sub New`</ph> can accept arguments when called as a parameterized constructor.","pos":[4314,4388],"source":"`Sub New` can accept arguments when called as a parameterized constructor."},{"content":"These parameters are passed from the procedure calling the constructor, for example, <ph id=\"ph1\">`Dim AnObject As New ThisClass(X)`</ph>.","pos":[4389,4509],"source":" These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`."},{"pos":[4519,4531],"content":"Sub Finalize","linkify":"Sub Finalize","nodes":[{"content":"Sub Finalize","pos":[0,12]}]},{"content":"Before releasing objects, the CLR automatically calls the <ph id=\"ph1\">`Finalize`</ph> method for objects that define a <ph id=\"ph2\">`Sub Finalize`</ph> procedure.","pos":[4535,4662],"source":"Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure."},{"content":"The <ph id=\"ph1\">`Finalize`</ph> method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.","pos":[4663,4820],"source":" The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information."},{"content":"There is a slight performance penalty for executing <ph id=\"ph1\">`Sub Finalize`</ph>, so you should define a <ph id=\"ph2\">`Sub Finalize`</ph> method only when you need to release objects explicitly.","pos":[4821,4983],"source":" There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly."},{"pos":[4991,5461],"content":"[!NOTE]\n The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment. This is because different unmanaged objects must be disposed of in different ways. That information is not directly associated with the unmanaged object; it must be found in the documentation for the object. A class that uses unmanaged objects must dispose of them in its `Finalize` method.","leadings":["","> "],"nodes":[{"content":" The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment. This is because different unmanaged objects must be disposed of in different ways. That information is not directly associated with the unmanaged object; it must be found in the documentation for the object. A class that uses unmanaged objects must dispose of them in its `Finalize` method.","pos":[8,468],"nodes":[{"content":"The garbage collector in the CLR does not (and cannot) dispose of <bpt id=\"p1\">*</bpt>unmanaged objects<ept id=\"p1\">*</ept>, objects that the operating system executes directly, outside the CLR environment.","pos":[1,169],"source":" The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment."},{"content":"This is because different unmanaged objects must be disposed of in different ways.","pos":[170,252]},{"content":"That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.","pos":[253,377]},{"content":"A class that uses unmanaged objects must dispose of them in its <ph id=\"ph1\">`Finalize`</ph> method.","pos":[378,460],"source":" A class that uses unmanaged objects must dispose of them in its `Finalize` method."}]}]},{"content":"The <ph id=\"ph1\">`Finalize`</ph> destructor is a protected method that can be called only from the class it belongs to, or from derived classes.","pos":[5468,5594],"source":"The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes."},{"content":"The system calls <ph id=\"ph1\">`Finalize`</ph> automatically when an object is destroyed, so you should not explicitly call <ph id=\"ph2\">`Finalize`</ph> from outside of a derived class's <ph id=\"ph3\">`Finalize`</ph> implementation.","pos":[5595,5771],"source":" The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation."},{"content":"Unlike <ph id=\"ph1\">`Class_Terminate`</ph>, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the <ph id=\"ph2\">`Finalize`</ph> destructor.","pos":[5778,5973],"source":"Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor."},{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]</ph> and later versions allow for a second kind of destructor, <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, which can be explicitly called at any time to immediately release resources.","pos":[5974,6262],"source":"[!INCLUDE[vbprvblong](../../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] and later versions allow for a second kind of destructor, <xref:System.IDisposable.Dispose%2A>, which can be explicitly called at any time to immediately release resources."},{"pos":[6270,6427],"content":"[!NOTE]\n A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.","leadings":["","> "],"nodes":[{"content":"A <ph id=\"ph1\">`Finalize`</ph> destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.","pos":[9,155],"source":" A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate."}]},{"pos":[6437,6491],"content":"How New and Finalize Methods Work in a Class Hierarchy","linkify":"How New and Finalize Methods Work in a Class Hierarchy","nodes":[{"content":"How New and Finalize Methods Work in a Class Hierarchy","pos":[0,54]}]},{"content":"Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named <ph id=\"ph1\">`New`</ph>, if it exists in that object.","pos":[6495,6646],"source":"Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object."},{"content":"<ph id=\"ph1\">`New`</ph> is a type of procedure called a <ph id=\"ph2\">`constructor`</ph> that is used to initialize new objects before any other code in an object executes.","pos":[6647,6782],"source":"`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes."},{"content":"A <ph id=\"ph1\">`New`</ph> constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.","pos":[6783,6957],"source":" A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used."},{"content":"When an instance of a derived class is created, the <ph id=\"ph1\">`Sub New`</ph> constructor of the base class executes first, followed by constructors in derived classes.","pos":[6964,7116],"source":"When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes."},{"content":"This happens because the first line of code in a <ph id=\"ph1\">`Sub New`</ph> constructor uses the syntax <ph id=\"ph2\">`MyBase.New()`</ph>to call the constructor of the class immediately above itself in the class hierarchy.","pos":[7117,7303],"source":" This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy."},{"content":"The <ph id=\"ph1\">`Sub New`</ph> constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.","pos":[7304,7435],"source":" The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached."},{"content":"At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.","pos":[7436,7630]},{"pos":[7637,7814],"content":"<bpt id=\"p1\">![</bpt>Constructors and Inheritance<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif \"</bpt>vaConstructorsInheritance<ept id=\"p2\">\")</ept>","source":"![Constructors and Inheritance](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance.gif \"vaConstructorsInheritance\")"},{"content":"When an object is no longer needed, the CLR calls the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for that object before freeing its memory.","pos":[7821,7957],"source":"When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is called a <ph id=\"ph2\">`destructor`</ph> because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.","pos":[7958,8202],"source":" The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object."},{"pos":[8209,8387],"content":"<bpt id=\"p1\">![</bpt>Constructors Inheritance2<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif \"</bpt>vaConstructorsInheritance_2<ept id=\"p2\">\")</ept>","source":"![Constructors Inheritance2](../../../../visual-basic/programming-guide/language-features/objects-and-classes/media/vaconstructorsinheritance_2.gif \"vaConstructorsInheritance_2\")"},{"pos":[8396,8417],"content":"IDisposable Interface","linkify":"IDisposable Interface","nodes":[{"content":"IDisposable Interface","pos":[0,21]}]},{"content":"Class instances often control resources not managed by the CLR, such as Windows handles and database connections.","pos":[8421,8534]},{"content":"These resources must be disposed of in the <ph id=\"ph1\">`Finalize`</ph> method of the class, so that they will be released when the object is destroyed by the garbage collector.","pos":[8535,8694],"source":" These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector."},{"content":"However, the garbage collector destroys objects only when the CLR requires more free memory.","pos":[8695,8787]},{"content":"This means that the resources may not be released until long after the object goes out of scope.","pos":[8788,8884]},{"content":"To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[8891,9056],"source":"To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface."},{"content":"<ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> has one method, <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, which clients should call when they finish using an object.","pos":[9057,9196],"source":" <xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method to immediately release resources and perform tasks such as closing files and database connections.","pos":[9197,9355],"source":" You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections."},{"content":"Unlike the <ph id=\"ph1\">`Finalize`</ph> destructor, the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called automatically.","pos":[9356,9466],"source":" Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically."},{"content":"Clients of a class must explicitly call <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> when you want to immediately release resources.","pos":[9467,9591],"source":" Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources."},{"pos":[9601,9625],"content":"Implementing IDisposable","linkify":"Implementing IDisposable","nodes":[{"content":"Implementing IDisposable","pos":[0,24]}]},{"content":"A class that implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface should include these sections of code:","pos":[9629,9731],"source":"A class that implements the <xref:System.IDisposable> interface should include these sections of code:"},{"content":"A field for keeping track of whether the object has been disposed:","pos":[9741,9807]},{"content":"An overload of the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> that frees the class's resources.","pos":[9884,9973],"source":"An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources."},{"content":"This method should be called by the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> and <ph id=\"ph2\">`Finalize`</ph> methods of the base class:","pos":[9974,10088],"source":" This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:"},{"content":"An implementation of <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> that contains only the following code:","pos":[10452,10548],"source":"An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:"},{"pos":[10711,10786],"content":"An override of the <ph id=\"ph1\">`Finalize`</ph> method that contains only the following code:","source":"An override of the `Finalize` method that contains only the following code:"},{"pos":[10927,10976],"content":"Deriving from a Class that Implements IDisposable","linkify":"Deriving from a Class that Implements IDisposable","nodes":[{"content":"Deriving from a Class that Implements IDisposable","pos":[0,49]}]},{"content":"A class that derives from a base class that implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.","pos":[10980,11186],"source":"A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed."},{"content":"In that situation, the derived class should override the base class's <ph id=\"ph1\">`Dispose(disposing)`</ph> method to dispose of the derived class's resources.","pos":[11187,11329],"source":" In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources."},{"content":"This override must call the base class's <ph id=\"ph1\">`Dispose(disposing)`</ph> method.","pos":[11330,11399],"source":" This override must call the base class's `Dispose(disposing)` method."},{"content":"A derived class should not override the base class's <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> and <ph id=\"ph2\">`Finalize`</ph> methods.","pos":[11721,11834],"source":"A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods."},{"content":"When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the <ph id=\"ph1\">`Dispose(disposing)`</ph> method.","pos":[11835,12022],"source":" When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method."},{"pos":[12031,12077],"content":"Garbage Collection and the Finalize Destructor","linkify":"Garbage Collection and the Finalize Destructor","nodes":[{"content":"Garbage Collection and the Finalize Destructor","pos":[0,46]}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> uses the <bpt id=\"p1\">*</bpt>reference-tracing garbage collection<ept id=\"p1\">*</ept> system to periodically release unused resources.","pos":[12081,12268],"source":"The [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] uses the *reference-tracing garbage collection* system to periodically release unused resources."},{"content":"Visual Basic 6.0 and earlier versions used a different system called <bpt id=\"p1\">*</bpt>reference counting<ept id=\"p1\">*</ept> to manage resources.","pos":[12269,12379],"source":" Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources."},{"content":"Although both systems perform the same function automatically, there are a few important differences.","pos":[12380,12481]},{"content":"The CLR periodically destroys objects when the system determines that such objects are no longer needed.","pos":[12488,12592]},{"content":"Objects are released more quickly when system resources are in short supply, and less frequently otherwise.","pos":[12593,12700]},{"content":"The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.","pos":[12701,12912]},{"content":"In such a situation, objects are said to have <bpt id=\"p1\">*</bpt>non-deterministic lifetime<ept id=\"p1\">*</ept>.","pos":[12913,12988],"source":" In such a situation, objects are said to have *non-deterministic lifetime*."},{"content":"In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the <ph id=\"ph1\">`Finalize`</ph> destructor may not immediately execute when an object loses scope.","pos":[12989,13185],"source":" In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope."},{"content":"Another difference between the garbage-collection systems involves the use of <ph id=\"ph1\">`Nothing`</ph>.","pos":[13192,13280],"source":"Another difference between the garbage-collection systems involves the use of `Nothing`."},{"content":"To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned <ph id=\"ph1\">`Nothing`</ph> to object variables to release the references those variables held.","pos":[13281,13471],"source":" To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held."},{"content":"If the variable held the last reference to the object, the object's resources were released immediately.","pos":[13472,13576]},{"content":"In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.","pos":[13577,13766]},{"content":"To release resources immediately, use the object's <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method, if available.","pos":[13767,13876],"source":" To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available."},{"content":"The only time you should set a variable to <ph id=\"ph1\">`Nothing`</ph> is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.","pos":[13877,14035],"source":" The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects."},{"pos":[14044,14052],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>","pos":[14056,14092],"source":"<xref:System.IDisposable.Dispose%2A> "},{"content":"<bpt id=\"p1\"> [</bpt>Initialization and Termination of Components<ept id=\"p1\">](http://msdn.microsoft.com/library/58444076-a9d2-4c91-b3f6-0e180dc0695d)</ept><ph id=\"ph1\"> </ph>","pos":[14096,14216],"source":" [Initialization and Termination of Components](http://msdn.microsoft.com/library/58444076-a9d2-4c91-b3f6-0e180dc0695d) "},{"content":"<bpt id=\"p1\"> [</bpt>New Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/new-operator.md)</ept><ph id=\"ph1\"> </ph>","pos":[14219,14306],"source":" [New Operator](../../../../visual-basic/language-reference/operators/new-operator.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](../../../../standard/garbage-collection/unmanaged.md)</ept><ph id=\"ph1\"> </ph>","pos":[14309,14398],"source":" [Cleaning Up Unmanaged Resources](../../../../standard/garbage-collection/unmanaged.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Nothing<ept id=\"p1\">](../../../../visual-basic/language-reference/nothing.md)</ept>","pos":[14401,14467],"source":" [Nothing](../../../../visual-basic/language-reference/nothing.md)"}]}