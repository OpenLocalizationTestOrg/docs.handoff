{"content":"---\ntitle: \"Service Channel-Level Programming\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 8d8dcd85-0a05-4c44-8861-4a0b3b90cca9\n---\n# Service Channel-Level Programming\nThis topic describes how to write a Windows Communication Foundation (WCF) service application without using the <xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType> and its associated object model.  \n  \n## Receiving Messages  \n To be ready to receive and process messages, the following steps are required:  \n  \n1.  Create a binding.  \n  \n2.  Build a channel listener.  \n  \n3.  Open the channel listener.  \n  \n4.  Read the request and send a reply.  \n  \n5.  Close all channel objects.  \n  \n#### Creating a Binding  \n The first step in listening for and receiving messages is creating a binding. WCF ships with several built-in or system-provided bindings that can be used directly by instantiating one of them. In addition, you can also create your own custom binding by instantiating a CustomBinding class which is what the code in listing 1 does.  \n  \n The code example below creates an instance of <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType> and adds an <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType> to its Elements collection which is a collection of binding elements that are used to build the channel stack. In this example, because the elements collection has only the <xref:System.ServiceModel.Channels.HttpTransportBindingElement>, the resulting channel stack has only the HTTP transport channel.  \n  \n#### Building a ChannelListener  \n After creating a binding, we call <xref:System.ServiceModel.Channels.Binding.BuildChannelListener%2A?displayProperty=nameWithType> to build the channel listener where the type parameter is the channel shape to create. In this example we are using <xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType> because we want to listen for incoming messages in a request/reply message exchange pattern.  \n  \n <xref:System.ServiceModel.Channels.IReplyChannel> is used for receiving request messages and sending back reply messages. Calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType> returns an <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>, which can be used to receive the request message and to send back a reply message.  \n  \n When creating the listener, we pass the network address on which it listens, in this case `http://localhost:8080/channelapp`. In general, each transport channel supports one or possibly several address schemes, for example, the HTTP transport supports both http and https schemes.  \n  \n We also pass an empty <xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType> when creating the listener. A binding parameter is a mechanism to pass parameters that control how the listener should be built. In our example, we are not using any such parameters so we pass an empty collection.  \n  \n#### Listening for Incoming Messages  \n We then call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the listener and start accepting channels. The behavior of <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> depends on whether the transport is connection-oriented or connection-less. For connection-oriented transports, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> blocks until a new connection request comes in at which point it returns a new channel that represents that new connection. For connection-less transports, such as HTTP, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> returns immediately with the one and only channel that the transport listener creates.  \n  \n In this example, the listener returns a channel that implements <xref:System.ServiceModel.Channels.IReplyChannel>. To receive messages on this channel we first call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on it to place it in a state ready for communication. We then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> which blocks until a message arrives.  \n  \n#### Reading the Request and Sending a Reply  \n When <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> returns a <xref:System.ServiceModel.Channels.RequestContext>, we get the received message using its <xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A> property. We write out the message’s action and body content, (which we assume is a string).  \n  \n To send a reply, we create a new reply message in this case passing back the string data we received in the request. We then call <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> to send the reply message.  \n  \n#### Closing Objects  \n To avoid leaking resources, it is very important to close objects used in communications when they are no longer required. In this example we close the request message, the request context, the channel and the listener.  \n  \n The following code example shows a basic service in which a channel listener receives only one message. A real service keeps accepting channels and receiving messages until the service exits.  \n  \n [!code-csharp[ChannelProgrammingBasic#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/channelprogrammingbasic/cs/serviceprogram.cs#1)]\n [!code-vb[ChannelProgrammingBasic#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/channelprogrammingbasic/vb/serviceprogram.vb#1)]\n","nodes":[{"pos":[4,151],"embed":true,"restype":"x-metadata","content":"title: \"Service Channel-Level Programming\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: 8d8dcd85-0a05-4c44-8861-4a0b3b90cca9","nodes":[{"content":"Service Channel-Level Programming","nodes":[{"pos":[0,33],"content":"Service Channel-Level Programming","nodes":[{"content":"Service Channel-Level Programming","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[158,191],"content":"Service Channel-Level Programming","linkify":"Service Channel-Level Programming","nodes":[{"content":"Service Channel-Level Programming","pos":[0,33]}]},{"pos":[192,405],"content":"This topic describes how to write a Windows Communication Foundation (WCF) service application without using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType&gt;</ph> and its associated object model.","source":"This topic describes how to write a Windows Communication Foundation (WCF) service application without using the <xref:System.ServiceModel.ServiceHost?displayProperty=nameWithType> and its associated object model."},{"pos":[414,432],"content":"Receiving Messages","linkify":"Receiving Messages","nodes":[{"content":"Receiving Messages","pos":[0,18]}]},{"content":"To be ready to receive and process messages, the following steps are required:","pos":[436,514]},{"content":"Create a binding.","pos":[524,541]},{"content":"Build a channel listener.","pos":[551,576]},{"content":"Open the channel listener.","pos":[586,612]},{"content":"Read the request and send a reply.","pos":[622,656]},{"content":"Close all channel objects.","pos":[666,692]},{"pos":[703,721],"content":"Creating a Binding","linkify":"Creating a Binding","nodes":[{"content":"Creating a Binding","pos":[0,18]}]},{"content":"The first step in listening for and receiving messages is creating a binding.","pos":[725,802]},{"content":"WCF ships with several built-in or system-provided bindings that can be used directly by instantiating one of them.","pos":[803,918]},{"content":"In addition, you can also create your own custom binding by instantiating a CustomBinding class which is what the code in listing 1 does.","pos":[919,1056]},{"content":"The code example below creates an instance of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType&gt;</ph> and adds an <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType&gt;</ph> to its Elements collection which is a collection of binding elements that are used to build the channel stack.","pos":[1063,1403],"source":"The code example below creates an instance of <xref:System.ServiceModel.Channels.CustomBinding?displayProperty=nameWithType> and adds an <xref:System.ServiceModel.Channels.HttpTransportBindingElement?displayProperty=nameWithType> to its Elements collection which is a collection of binding elements that are used to build the channel stack."},{"content":"In this example, because the elements collection has only the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.HttpTransportBindingElement&gt;</ph>, the resulting channel stack has only the HTTP transport channel.","pos":[1404,1595],"source":" In this example, because the elements collection has only the <xref:System.ServiceModel.Channels.HttpTransportBindingElement>, the resulting channel stack has only the HTTP transport channel."},{"pos":[1606,1632],"content":"Building a ChannelListener","linkify":"Building a ChannelListener","nodes":[{"content":"Building a ChannelListener","pos":[0,26]}]},{"content":"After creating a binding, we call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Binding.BuildChannelListener%2A?displayProperty=nameWithType&gt;</ph> to build the channel listener where the type parameter is the channel shape to create.","pos":[1636,1853],"source":"After creating a binding, we call <xref:System.ServiceModel.Channels.Binding.BuildChannelListener%2A?displayProperty=nameWithType> to build the channel listener where the type parameter is the channel shape to create."},{"content":"In this example we are using <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType&gt;</ph> because we want to listen for incoming messages in a request/reply message exchange pattern.","pos":[1854,2054],"source":" In this example we are using <xref:System.ServiceModel.Channels.IReplyChannel?displayProperty=nameWithType> because we want to listen for incoming messages in a request/reply message exchange pattern."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph> is used for receiving request messages and sending back reply messages.","pos":[2061,2182],"source":"<xref:System.ServiceModel.Channels.IReplyChannel> is used for receiving request messages and sending back reply messages."},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType&gt;</ph> returns an <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType&gt;</ph>, which can be used to receive the request message and to send back a reply message.","pos":[2183,2463],"source":" Calling <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A?displayProperty=nameWithType> returns an <xref:System.ServiceModel.Channels.IRequestChannel?displayProperty=nameWithType>, which can be used to receive the request message and to send back a reply message."},{"content":"When creating the listener, we pass the network address on which it listens, in this case <ph id=\"ph1\">`http://localhost:8080/channelapp`</ph>.","pos":[2470,2595],"source":"When creating the listener, we pass the network address on which it listens, in this case `http://localhost:8080/channelapp`."},{"content":"In general, each transport channel supports one or possibly several address schemes, for example, the HTTP transport supports both http and https schemes.","pos":[2596,2750]},{"content":"We also pass an empty <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType&gt;</ph> when creating the listener.","pos":[2757,2898],"source":"We also pass an empty <xref:System.ServiceModel.Channels.BindingParameterCollection?displayProperty=nameWithType> when creating the listener."},{"content":"A binding parameter is a mechanism to pass parameters that control how the listener should be built.","pos":[2899,2999]},{"content":"In our example, we are not using any such parameters so we pass an empty collection.","pos":[3000,3084]},{"pos":[3095,3126],"content":"Listening for Incoming Messages","linkify":"Listening for Incoming Messages","nodes":[{"content":"Listening for Incoming Messages","pos":[0,31]}]},{"content":"We then call <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType&gt;</ph> on the listener and start accepting channels.","pos":[3130,3273],"source":"We then call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on the listener and start accepting channels."},{"content":"The behavior of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType&gt;</ph> depends on whether the transport is connection-oriented or connection-less.","pos":[3274,3468],"source":" The behavior of <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType> depends on whether the transport is connection-oriented or connection-less."},{"content":"For connection-oriented transports, <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A&gt;</ph> blocks until a new connection request comes in at which point it returns a new channel that represents that new connection.","pos":[3469,3702],"source":" For connection-oriented transports, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> blocks until a new connection request comes in at which point it returns a new channel that represents that new connection."},{"content":"For connection-less transports, such as HTTP, <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A&gt;</ph> returns immediately with the one and only channel that the transport listener creates.","pos":[3703,3909],"source":" For connection-less transports, such as HTTP, <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A> returns immediately with the one and only channel that the transport listener creates."},{"content":"In this example, the listener returns a channel that implements <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph>.","pos":[3916,4030],"source":"In this example, the listener returns a channel that implements <xref:System.ServiceModel.Channels.IReplyChannel>."},{"content":"To receive messages on this channel we first call <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType&gt;</ph> on it to place it in a state ready for communication.","pos":[4031,4219],"source":" To receive messages on this channel we first call <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> on it to place it in a state ready for communication."},{"content":"We then call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> which blocks until a message arrives.","pos":[4220,4338],"source":" We then call <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> which blocks until a message arrives."},{"pos":[4349,4388],"content":"Reading the Request and Sending a Reply","linkify":"Reading the Request and Sending a Reply","nodes":[{"content":"Reading the Request and Sending a Reply","pos":[0,39]}]},{"content":"When <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> returns a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.RequestContext&gt;</ph>, we get the received message using its <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A&gt;</ph> property.","pos":[4392,4643],"source":"When <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> returns a <xref:System.ServiceModel.Channels.RequestContext>, we get the received message using its <xref:System.ServiceModel.Channels.RequestContext.RequestMessage%2A> property."},{"content":"We write out the message’s action and body content, (which we assume is a string).","pos":[4644,4726]},{"content":"To send a reply, we create a new reply message in this case passing back the string data we received in the request.","pos":[4733,4849]},{"content":"We then call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.RequestContext.Reply%2A&gt;</ph> to send the reply message.","pos":[4850,4949],"source":" We then call <xref:System.ServiceModel.Channels.RequestContext.Reply%2A> to send the reply message."},{"pos":[4960,4975],"content":"Closing Objects","linkify":"Closing Objects","nodes":[{"content":"Closing Objects","pos":[0,15]}]},{"content":"To avoid leaking resources, it is very important to close objects used in communications when they are no longer required.","pos":[4979,5101]},{"content":"In this example we close the request message, the request context, the channel and the listener.","pos":[5102,5198]},{"content":"The following code example shows a basic service in which a channel listener receives only one message.","pos":[5205,5308]},{"content":"A real service keeps accepting channels and receiving messages until the service exits.","pos":[5309,5396]}]}