{"content":"---\ntitle: \"@ (C# Reference) | Microsoft Docs\"\nms.date: \"2017-02-09\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"@_CSharpKeyword\"\n  - \"@\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"@ special character [C#]\"\n  - \"@ language element [C#]\"\nms.assetid: 89bc7e53-85f5-478a-866d-1cca003c4e8c\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# @ (C# Reference)\n\nThe `@` special character serves as a verbatim identifier. It can be used in the following ways:\n\n1. To enable C# keywords to be used as identifiers. The `@` character prefixes a code element that the compiler is to interpret as an identifier rather than a C# keyword. The following example uses the `@` character to define an identifier named `for` that it uses in a `for` loop.\n\n   [!code-cs[verbatim1](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#1)]\n\n1. To indicate that a string literal is to be interpreted verbatim. The `@` character in this instance defines a *verbatim string literal*. Simple escape sequences (such as `\"\\\\\"` for a backslash), hexadecimal escape sequences (such as `\"\\x0041\"` for an uppercase A, and Unicode escape sequences, such as `\"\\u0041\"` for an uppercase A, are interpreted literally. Only a quote escape sequence (`\"\"`) is not interpreted literally; it produces a single quotation mark. The following example defines two identical file paths, one by using a regular string literal and the other by using a verbatim string literal. This is one of the more common uses of verbatim string literals.\n\n   [!code-cs[verbatim2](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#2)]\n\n   The following example illustrates the effect of defining a regular string literal and a verbatim string literal that contain identical character sequences.\n\n   [!code-cs[verbatim3](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#3)]\n\n1. To enable the compiler to distinguish between attributes in cases of a naming conflict. An attribute is a type that derives from @System.Attribute. Its type name typically includes the suffix **Attribute**, although the compiler does not enforce this convention. The attribute can then be referenced in code either by its full type name (for example, `[InfoAttribute]` or its shortened name (for example, `[Info]`). However, a naming conflict occurs if two shortened attribute type names are identical, and one type name includes the **Attribute** suffix but the other does not. For example, the following code fails to compile because the compiler cannot determine whether the `Info` or `InfoAttribute` attribute is applied to the `Main` method.\n\n   ```csharp\n   using System;\n\n   [AttributeUsage(AttributeTargets.Class)]\n   public class Info : Attribute\n   {\n      private string information;\n      \n      public Info(string info)\n      {\n          information = info;\n      }\n   }\n\n   [AttributeUsage(AttributeTargets.Method)]\n   public class InfoAttribute : Attribute\n   {\n      private string information;\n      \n      public InfoAttribute(string info)\n      {\n          information = info;\n      }\n   }\n\n   [Info(\"A simple executable.\")]\n   public class Example\n   {\n      [InfoAttribute(\"The entry point.\")]\n      public static void Main()\n      {\n      }\n   }\n   ```  \n\n   If the verbatim identifier is used to identify the `Info` attribute, the example compiles successfully.\n\n   [!code-cs[verbatim4](../../../../samples/snippets/csharp/language-reference/keywords/verbatim4.cs#1)]\n\n## See Also  \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [C# Special Characters](../../../csharp/language-reference/tokens/index.md)\n","nodes":[{"pos":[12,45],"content":"@ (C# Reference) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"@ (C# Reference) | Microsoft Docs","pos":[0,33]}]},{"pos":[569,585],"content":"@ (C# Reference)","linkify":"@ (C# Reference)","nodes":[{"content":"@ (C# Reference)","pos":[0,16]}]},{"content":"The <ph id=\"ph1\">`@`</ph> special character serves as a verbatim identifier.","pos":[587,645],"source":"The `@` special character serves as a verbatim identifier."},{"content":"It can be used in the following ways:","pos":[646,683]},{"content":"To enable C# keywords to be used as identifiers.","pos":[688,736]},{"content":"The <ph id=\"ph1\">`@`</ph> character prefixes a code element that the compiler is to interpret as an identifier rather than a C# keyword.","pos":[737,855],"source":" The `@` character prefixes a code element that the compiler is to interpret as an identifier rather than a C# keyword."},{"content":"The following example uses the <ph id=\"ph1\">`@`</ph> character to define an identifier named <ph id=\"ph2\">`for`</ph> that it uses in a <ph id=\"ph3\">`for`</ph> loop.","pos":[856,966],"source":" The following example uses the `@` character to define an identifier named `for` that it uses in a `for` loop."},{"pos":[971,1072],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>verbatim1<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[verbatim1](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#1)]"},{"content":"To indicate that a string literal is to be interpreted verbatim.","pos":[1077,1141]},{"content":"The <ph id=\"ph1\">`@`</ph> character in this instance defines a <bpt id=\"p1\">*</bpt>verbatim string literal<ept id=\"p1\">*</ept>.","pos":[1142,1213],"source":" The `@` character in this instance defines a *verbatim string literal*."},{"content":"Simple escape sequences (such as <ph id=\"ph1\">`\"\\\\\"`</ph> for a backslash), hexadecimal escape sequences (such as <ph id=\"ph2\">`\"\\x0041\"`</ph> for an uppercase A, and Unicode escape sequences, such as <ph id=\"ph3\">`\"\\u0041\"`</ph> for an uppercase A, are interpreted literally.","pos":[1214,1436],"source":" Simple escape sequences (such as `\"\\\\\"` for a backslash), hexadecimal escape sequences (such as `\"\\x0041\"` for an uppercase A, and Unicode escape sequences, such as `\"\\u0041\"` for an uppercase A, are interpreted literally."},{"content":"Only a quote escape sequence (<ph id=\"ph1\">`\"\"`</ph>) is not interpreted literally; it produces a single quotation mark.","pos":[1437,1539],"source":" Only a quote escape sequence (`\"\"`) is not interpreted literally; it produces a single quotation mark."},{"content":"The following example defines two identical file paths, one by using a regular string literal and the other by using a verbatim string literal.","pos":[1540,1683]},{"content":"This is one of the more common uses of verbatim string literals.","pos":[1684,1748]},{"pos":[1753,1854],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>verbatim2<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#2)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[verbatim2](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#2)]"},{"content":"The following example illustrates the effect of defining a regular string literal and a verbatim string literal that contain identical character sequences.","pos":[1859,2014]},{"pos":[2019,2120],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>verbatim3<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#3)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[verbatim3](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#3)]"},{"content":"To enable the compiler to distinguish between attributes in cases of a naming conflict.","pos":[2125,2212]},{"content":"An attribute is a type that derives from <ph id=\"ph1\">@System.Attribute</ph>.","pos":[2213,2272],"source":" An attribute is a type that derives from @System.Attribute."},{"content":"Its type name typically includes the suffix <bpt id=\"p1\">**</bpt>Attribute<ept id=\"p1\">**</ept>, although the compiler does not enforce this convention.","pos":[2273,2387],"source":" Its type name typically includes the suffix **Attribute**, although the compiler does not enforce this convention."},{"content":"The attribute can then be referenced in code either by its full type name (for example, <ph id=\"ph1\">`[InfoAttribute]`</ph> or its shortened name (for example, <ph id=\"ph2\">`[Info]`</ph>).","pos":[2388,2540],"source":" The attribute can then be referenced in code either by its full type name (for example, `[InfoAttribute]` or its shortened name (for example, `[Info]`)."},{"content":"However, a naming conflict occurs if two shortened attribute type names are identical, and one type name includes the <bpt id=\"p1\">**</bpt>Attribute<ept id=\"p1\">**</ept> suffix but the other does not.","pos":[2541,2703],"source":" However, a naming conflict occurs if two shortened attribute type names are identical, and one type name includes the **Attribute** suffix but the other does not."},{"content":"For example, the following code fails to compile because the compiler cannot determine whether the <ph id=\"ph1\">`Info`</ph> or <ph id=\"ph2\">`InfoAttribute`</ph> attribute is applied to the <ph id=\"ph3\">`Main`</ph> method.","pos":[2704,2871],"source":" For example, the following code fails to compile because the compiler cannot determine whether the `Info` or `InfoAttribute` attribute is applied to the `Main` method."},{"pos":[3506,3609],"content":"If the verbatim identifier is used to identify the <ph id=\"ph1\">`Info`</ph> attribute, the example compiles successfully.","source":"If the verbatim identifier is used to identify the `Info` attribute, the example compiles successfully."},{"pos":[3614,3715],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>verbatim4<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/verbatim4.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[verbatim4](../../../../samples/snippets/csharp/language-reference/keywords/verbatim4.cs#1)]"},{"pos":[3720,3728],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[3732,3792],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[3795,3863],"source":" [C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>C# Special Characters<ept id=\"p1\">](../../../csharp/language-reference/tokens/index.md)</ept>","pos":[3866,3942],"source":" [C# Special Characters](../../../csharp/language-reference/tokens/index.md)"}]}