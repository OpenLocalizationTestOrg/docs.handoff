{"content":"---\ntitle: \"Specifying Data Transfer in Service Contracts\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"service contracts [WCF], data transfer\"\nms.assetid: 7c5a26c8-89c9-4bcb-a4bc-7131e6d01f0c\n---\n# Specifying Data Transfer in Service Contracts\nThe Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure. Service operations can receive messages, process them, and send them messages. Messages are described using operation contracts. For example, consider the following contract.  \n  \n```csharp  \n[ServiceContract]  \npublic interface IAirfareQuoteService  \n{  \n    [OperationContract]  \n    float GetAirfare(string fromCity, string toCity);  \n}  \n```  \n  \n```vb  \n<ServiceContract()>  \nPublic Interface IAirfareQuoteService  \n  \n    <OperationContract()>  \n    Function GetAirfare(fromCity As String, toCity As String) As Double  \nEnd Interface  \n```  \n  \n Here, the `GetAirfare` operation accepts a message with information about `fromCity` and `toCity`, and then returns a message that contains a number.  \n  \n This topic explains the various ways in which an operation contract can describe messages.  \n  \n## Describing Messages by Using Parameters  \n The simplest way to describe a message is to use a parameter list and the return value. In the preceding example, the `fromCity` and `toCity` string parameters were used to describe the request message, and the float return value was used to describe the reply message. If the return value alone is not enough to describe a reply message, out parameters may be used. For example, the following operation has `fromCity` and `toCity` in its request message, and a number together with a currency in its reply message:  \n  \n```csharp  \n[OperationContract]  \nfloat GetAirfare(string fromCity, string toCity, out string currency);  \n```  \n  \n```vb  \n<OperationContract()>  \n    Function GetAirfare(fromCity As String, toCity As String) As Double  \n```  \n  \n Additionally, you may use reference parameters to make a parameter part of both the request and the reply message. The parameters must be of types that can be serialized (converted to XML). By default, WCF uses a component called the <xref:System.Runtime.Serialization.DataContractSerializer> class to perform this conversion. Most primitive types (such as `int`, `string`, `float`, and `DateTime`.) are supported. User-defined types must normally have a data contract. For more information, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).  \n  \n```csharp\npublic interface IAirfareQuoteService  \n{  \n    [OperationContract]  \n    float GetAirfare(Itinerary itinerary, DateTime date);  \n  \n    [DataContract]  \n    public class Itinerary  \n    {  \n        [DataMember]  \n        public string fromCity;  \n        [DataMember]  \n        public string toCity;  \n   }  \n}  \n```  \n  \n```vb  \nPublic Interface IAirfareQuoteService  \n    <OperationContract()>  \n    GetAirfare(itinerary as Itinerary, date as DateTime) as Double  \n  \n    <DataContract()>  \n    Class Itinerary  \n  \n        <DataMember()>  \n        Public fromCity As String  \n        <DataMember()>  \n        Public toCity As String  \n    End Class  \nEnd Interface  \n```  \n  \n Occasionally, the `DataContractSerializer` is not adequate to serialize your types. WCF supports an alternative serialization engine, the <xref:System.Xml.Serialization.XmlSerializer>, which you can also use to serialize parameters. The <xref:System.Xml.Serialization.XmlSerializer> allows you to use more control over the resultant XML using attributes such as the `XmlAttributeAttribute`. To switch to using the <xref:System.Xml.Serialization.XmlSerializer> for a particular operation or for the entire service, apply the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute to an operation or a service. For example:  \n  \n```csharp  \n[ServiceContract]  \npublic interface IAirfareQuoteService  \n{  \n    [OperationContract]  \n    [XmlSerializerFormat]  \n    float GetAirfare(Itinerary itinerary, DateTime date);  \n}  \npublic class Itinerary  \n{  \n    public string fromCity;  \n    public string toCity;  \n    [XmlAttribute]  \n    public bool isFirstClass;  \n}  \n```  \n  \n```vb  \n<ServiceContract()>  \nPublic Interface IAirfareQuoteService  \n    <OperationContract()>  \n    <XmlSerializerFormat>  \n    GetAirfare(itinerary as Itinerary, date as DateTime) as Double  \n  \nEnd Interface  \n  \nClass Itinerary  \n  \n    Public fromCity As String  \n    Public toCity As String  \n    <XmlSerializerFormat()>  \n    Public isFirstClass As Boolean  \nEnd Class  \n```  \n  \n For more information, see [Using the XmlSerializer Class](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md). Remember that manually switching to the <xref:System.Xml.Serialization.XmlSerializer> as shown here is not recommended unless you have specific reasons to do so as detailed in that topic.  \n  \n To isolate .NET parameter names from contract names, you can use the <xref:System.ServiceModel.MessageParameterAttribute> attribute, and use the `Name` property to set the contract name. For example, the following operation contract is equivalent to the first example in this topic.  \n  \n```csharp  \n[OperationContract]  \npublic float GetAirfare(  \n    [MessageParameter(Name=\"fromCity\")] string originCity,  \n    [MessageParameter(Name=\"toCity\")] string destinationCity);  \n```  \n  \n```vb  \n<OperationContract()>  \n  Function GetAirfare(<MessageParameter(Name := \"fromCity\")> fromCity As String, <MessageParameter(Name := \"toCity\")> toCity As String) As Double  \n```  \n  \n## Describing Empty Messages  \n An empty request message can be described by having no input or reference parameters. For example in C#:  \n  \n `[OperationContract]`  \n  \n `public int GetCurrentTemperature();`  \n  \n For example in VB:  \n  \n `<OperationContract()>`  \n  \n `Function GetCurrentTemperature() as Integer`  \n  \n An empty reply message can be described by having a `void` return type and no output or reference parameters. For example in:  \n  \n```csharp  \n[OperationContract]  \npublic void SetTemperature(int temperature);  \n```  \n  \n```vb  \n<OperationContract()>  \nSub SetTemperature(temperature As Integer)  \n```  \n  \n This is different from a one-way operation, such as:  \n  \n```csharp  \n[OperationContract(IsOneWay=true)]  \npublic void SetLightbulbStatus(bool isOn);  \n```  \n  \n```vb  \n<OperationContract(IsOneWay:=True)>  \nSub SetLightbulbStatus(isOne As Boolean)  \n```  \n  \n The `SetTemperatureStatus` operation returns an empty message. It may return a fault instead if there is a problem processing the input message. The `SetLightbulbStatus` operation returns nothing. There is no way to communicate a fault condition from this operation.  \n  \n## Describing Messages by Using Message Contracts  \n You may want to use a single type to represent the entire message. While it is possible to use a data contract for this purpose, the recommended way to do this is to use a message contractâ€”this avoids unnecessary levels of wrapping in the resultant XML. Additionally, message contracts allow you to exercise more control over resultant messages. For instance, you can decide which pieces of information should be in the message body and which should be in the message headers. The following example shows the use of message contracts.  \n  \n```csharp  \n[ServiceContract]  \npublic interface IAirfareQuoteService  \n{  \n    [OperationContract]  \n    GetAirfareResponse GetAirfare(GetAirfareRequest request);  \n}  \n  \n[MessageContract]  \npublic class GetAirfareRequest  \n{  \n    [MessageHeader] public DateTime date;  \n    [MessageBodyMember] public Itinerary itinerary;  \n}  \n  \n[MessageContract]  \npublic class GetAirfareResponse  \n{  \n    [MessageBodyMember] public float airfare;  \n    [MessageBodyMember] public string currency;  \n}  \n  \n[DataContract]  \npublic class Itinerary  \n{  \n    [DataMember] public string fromCity;  \n    [DataMember] public string toCity;  \n}  \n```  \n  \n```vb  \n<ServiceContract()>  \nPublic Interface IAirfareQuoteService  \n    <OperationContract()>  \n    Function GetAirfare(request As GetAirfareRequest) As GetAirfareResponse  \nEnd Interface  \n  \n<MessageContract()>  \nPublic Class GetAirfareRequest  \n    <MessageHeader()>   \n    Public Property date as DateTime  \n    <MessageBodyMember()>  \n    Public Property itinerary As Itinerary  \nEnd Class  \n  \n<MessageContract()>  \nPublic Class GetAirfareResponse  \n    <MessageBodyMember()>  \n    Public Property airfare As Double  \n    <MessageBodyMember()> Public Property currency As String  \nEnd Class  \n  \n<DataContract()>  \nPublic Class Itinerary  \n    <DataMember()> Public Property fromCity As String  \n    <DataMember()> Public Property toCity As String  \nEnd Class  \n```  \n  \n For more information, see [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).  \n  \n In the previous example, the <xref:System.Runtime.Serialization.DataContractSerializer> class is still used by default. The <xref:System.Xml.Serialization.XmlSerializer> class can also be used with message contracts. To do this, apply the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute to either the operation or the contract, and use types compatible with the <xref:System.Xml.Serialization.XmlSerializer> class in the message headers and body members.  \n  \n## Describing Messages by Using Streams  \n Another way to describe messages in operations is to use the <xref:System.IO.Stream> class or one of its derived classes in an operation contract or as a message contract body member (it must be the only member in this case). For incoming messages, the type must be `Stream`â€”you cannot use derived classes.  \n  \n Instead of invoking the serializer, WCF retrieves data from a stream and puts it directly into an outgoing message, or retrieves data from an incoming message and puts it directly into a stream. The following sample shows the use of streams.  \n  \n```csharp  \n[OperationContract]  \npublic Stream DownloadFile(string fileName);  \n```  \n  \n```vb  \n<OperationContract()>  \nFunction DownloadFile(fileName As String) As String  \n```  \n  \n You cannot combine `Stream` and non-stream data in a single message body. Use a message contract to put the extra data in message headers. The following example shows the incorrect usage of streams when defining the operation contract.  \n  \n```csharp  \n//Incorrect:  \n// [OperationContract]  \n// public void UploadFile (string fileName, Stream fileData);  \n```  \n  \n```vb  \n'Incorrect:  \n    '<OperationContract()>  \n    Public Sub UploadFile(fileName As String, fileData As StreamingContext)  \n```  \n  \n The following sample shows the correct usage of streams when defining an operation contract.  \n  \n```csharp  \n[OperationContract]  \npublic void UploadFile (UploadFileMessage message);  \n//code omitted  \n[MessageContract]  \npublic class UploadFileMessage  \n{  \n    [MessageHeader] public string fileName;  \n    [MessageBodyMember] public Stream fileData;  \n}  \n```  \n  \n```vb  \n<OperationContract()>  \nPublic Sub UploadFile(fileName As String, fileData As StreamingContext)  \n'Code Omitted  \n<MessageContract()>  \nPublic Class UploadFileMessage  \n   <MessageHeader()>  \n    Public Property fileName As String  \n    <MessageBodyMember()>  \n    Public Property fileData As Stream  \nEnd Class  \n```  \n  \n For more information, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  \n  \n## Using the Message Class  \n To have complete programmatic control over messages sent or received, you can use the <xref:System.ServiceModel.Channels.Message> class directly, as shown in the following example code.  \n  \n```csharp  \n[OperationContract]  \npublic void LogMessage(Message m);  \n```  \n  \n```vb  \n<OperationContract()>  \nSub LogMessage(m As Message)  \n```  \n  \n This is an advanced scenario, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  \n  \n## Describing Fault Messages  \n In addition to the messages that are described by the return value and output or reference parameters, any operation that is not one-way can return at least two possible messages: its normal response message and a fault message. Consider the following operation contract.  \n  \n```csharp  \n[OperationContract]  \nfloat GetAirfare(string fromCity, string toCity, DateTime date);  \n```  \n  \n```vb  \n<OperationContract()>  \nFunction GetAirfare(fromCity As String, toCity As String, date as DateTime)  \n```  \n  \n This operation may either return a normal message that contains a `float` number, or a fault message that contains a fault code and a description. You can accomplish this by throwing a <xref:System.ServiceModel.FaultException> in your service implementation.  \n  \n You can specify additional possible fault messages by using the <xref:System.ServiceModel.FaultContractAttribute> attribute. The additional faults must be serializable using the <xref:System.Runtime.Serialization.DataContractSerializer>, as shown in the following example code.  \n  \n```csharp  \n[OperationContract]  \n[FaultContract(typeof(ItineraryNotAvailableFault))]  \nfloat GetAirfare(string fromCity, string toCity, DateTime date);  \n  \n//code omitted  \n  \n[DataContract]  \npublic class ItineraryNotAvailableFault  \n{  \n    [DataMember]  \n    public bool IsAlternativeDateAvailable;  \n  \n    [DataMember]  \n    public DateTime alternativeSuggestedDate;  \n}  \n```  \n  \n```vb  \n<OperationContract()>  \n<FaultContract(GetType(ItineraryNotAvailableFault))>  \nFunction GetAirfare(fromCity As String, toCity As String, date as DateTime) As Double  \n  \n'Code Omitted  \n<DataContract()>  \nPublic Class  \n  <DataMember()>  \n  Public Property IsAlternativeDateAvailable As Boolean  \n  <DataMember()>  \n  Public Property alternativeSuggestedDate As DateTime  \nEnd Class  \n```  \n  \n These additional faults can be generated by throwing a <xref:System.ServiceModel.FaultException%601> of the appropriate data contract type. For more information, see [Handling Exceptions and Faults](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md).  \n  \n You cannot use the <xref:System.Xml.Serialization.XmlSerializer> class to describe faults. The <xref:System.ServiceModel.XmlSerializerFormatAttribute> has no effect on fault contracts.  \n  \n## Using Derived Types  \n You may want to use a base type in an operation or a message contract, and then use a derived type when actually invoking the operation. In this case, you must use either the <xref:System.ServiceModel.ServiceKnownTypeAttribute> attribute or some alternative mechanism to allow the use of derived types. Consider the following operation.  \n  \n```csharp  \n[OperationContract]  \npublic bool IsLibraryItemAvailable(LibraryItem item);  \n```  \n  \n```vb\n<OperationContract()>  \n    Function IsLibraryItemAvailable(item As LibraryItem) As Boolean  \n```  \n  \n Assume that two types, `Book` and `Magazine`, derive from `LibraryItem`. To use these types in the `IsLibraryItemAvailable` operation, you can change the operation as follows:  \n  \n `[OperationContract]`  \n  \n `[ServiceKnownType(typeof(Book))]`  \n  \n `[ServiceKnownType(typeof(Magazine))]`  \n  \n `public bool IsLibraryItemAvailable(LibraryItem item);`  \n  \n Alternatively, you can use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute when the default <xref:System.Runtime.Serialization.DataContractSerializer> is in use, as shown in the following example code.  \n  \n```csharp  \n[OperationContract]  \npublic bool IsLibraryItemAvailable(LibraryItem item);  \n  \n// code omitted   \n  \n[DataContract]  \n[KnownType(typeof(Book))]  \n[KnownType(typeof(Magazine))]  \npublic class LibraryItem  \n{  \n    //code omitted  \n}  \n```  \n  \n```vb  \n<OperationContract()>  \nFunction IsLibraryItemAvailable(item As LibraryItem) As Boolean  \n  \n'Code Omitted  \n<DataContract()>  \n<KnownType(GetType(Book))>  \n<KnownType(GetType(Magazine))>  \nPublic Class LibraryItem  \n  'Code Omitted  \nEnd Class  \n```  \n  \n You can use the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute when using the <xref:System.Xml.Serialization.XmlSerializer>.  \n  \n You can apply the <xref:System.ServiceModel.ServiceKnownTypeAttribute> attribute to an operation or to the entire service. It accepts either a type or the name of the method to call to get a list of known types, just like the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute. For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).  \n  \n## Specifying the Use and Style  \n When describing services using Web Services Description Language (WSDL), the two commonly used styles are Document and remote procedure call (RPC). In the Document style, the entire message body is described using the schema, and the WSDL describes the various message body parts by referring to elements within that schema. In the RPC style, the WSDL refers to a schema type for each message part rather than an element. In some cases, you have to manually select one of these styles. You can do this by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute and setting the `Style` property (when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use), or by setting `Style` on the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute (when using the <xref:System.Xml.Serialization.XmlSerializer>).  \n  \n Additionally, the <xref:System.Xml.Serialization.XmlSerializer> supports two forms of serialized XML: `Literal` and `Encoded`. `Literal` is the most commonly accepted form, and is the only form the <xref:System.Runtime.Serialization.DataContractSerializer> supports. `Encoded` is a legacy form described in section 5 of the SOAP specification, and is not recommended for new services. To switch to `Encoded` mode, set the `Use` property on the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute to `Encoded`.  \n  \n In most cases, you should not change the default settings for the `Style` and `Use` properties.  \n  \n## Controlling the Serialization Process  \n You can do a number of things to customize the way data is serialized.  \n  \n### Changing Server Serialization Settings  \n When the default <xref:System.Runtime.Serialization.DataContractSerializer> is in use, you can control some aspects of the serialization process on the service by applying the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute to the service. Specifically, you may use the `MaxItemsInObjectGraph` property to set the quota that limits the maximum number of objects the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes. You can use the `IgnoreExtensionDataObject` property to turn off the round-tripping versioning feature. For more information about quotas, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md). For more information about round-tripping, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).  \n  \n```csharp  \n[ServiceBehavior(MaxItemsInObjectGraph=100000)]  \npublic class MyDataService:IDataService  \n{  \n    public DataPoint[] GetData()  \n    {  \n       // Implementation omitted  \n    }  \n}  \n```  \n  \n```vb  \n<ServiceBehavior(MaxItemsInObjectGraph:=100000)>  \nPublic Class MyDataService Implements IDataService  \n  \n    Function GetData() As DataPoint()  \n         â€˜ Implementation omitted  \n    End Function  \nEnd Interface  \n```  \n  \n### Serialization Behaviors  \n Two behaviors are available in WCF, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and the <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> that are automatically plugged in depending on which serializer is in use for a particular operation. Because these behaviors are applied automatically, you normally do not have to be aware of them.  \n  \n However, the `DataContractSerializerOperationBehavior` has the `MaxItemsInObjectGraph`, `IgnoreExtensionDataObject`, and `DataContractSurrogate` properties that you may use to customize the serialization process. The first two properties have the same meaning as discussed in the previous section. You can use the `DataContractSurrogate` property to enable data contract surrogates, which are a powerful mechanism for customizing and extending the serialization process. For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).  \n  \n You can use the `DataContractSerializerOperationBehavior` to customize both client and server serialization. The following example shows how to increase the `MaxItemsInObjectGraph` quota on the client.  \n  \n```csharp  \nChannelFactory<IDataService> factory = new ChannelFactory<IDataService>(binding, address);  \nforeach (OperationDescription op in factory.Endpoint.Contract.Operations)  \n{  \n    DataContractSerializerOperationBehavior dataContractBehavior =  \n                op.Behaviors.Find<DataContractSerializerOperationBehavior>()  \n                as DataContractSerializerOperationBehavior;  \n    if (dataContractBehavior != null)  \n    {  \n        dataContractBehavior.MaxItemsInObjectGraph = 100000;  \n    }  \n}  \nIDataService client = factory.CreateChannel();  \n```  \n  \n```vb  \nDim factory As ChannelFactory(Of IDataService) = New ChannelFactory(Of IDataService)(binding, address)  \nFor Each op As OperationDescription In factory.Endpoint.Contract.Operations  \n        Dim dataContractBehavior As DataContractSerializerOperationBehavior = op.Behaviors.Find(Of DataContractSerializerOperationBehavior)()  \n        If dataContractBehavior IsNot Nothing Then  \n            dataContractBehavior.MaxItemsInObjectGraph = 100000  \n        End If  \n     Next  \n    Dim client As IDataService = factory.CreateChannel  \n```  \n  \n Following is the equivalent code on the service, in the self-hosted case.  \n  \n```csharp  \nServiceHost serviceHost = new ServiceHost(typeof(IDataService))  \nforeach (ServiceEndpoint ep in serviceHost.Description.Endpoints)  \n{  \nforeach (OperationDescription op in ep.Contract.Operations)  \n{  \n        DataContractSerializerOperationBehavior dataContractBehavior =  \n           op.Behaviors.Find<DataContractSerializerOperationBehavior>()  \n                as DataContractSerializerOperationBehavior;  \n        if (dataContractBehavior != null)  \n        {  \n            dataContractBehavior.MaxItemsInObjectGraph = 100000;  \n        }  \n}  \n}  \nserviceHost.Open();  \n```  \n  \n```vb  \nDim serviceHost As ServiceHost = New ServiceHost(GetType(IDataService))  \n        For Each ep As ServiceEndpoint In serviceHost.Description.Endpoints  \n            For Each op As OperationDescription In ep.Contract.Operations  \n                Dim dataContractBehavior As DataContractSerializerOperationBehavior = op.Behaviors.Find(Of DataContractSerializerOperationBehavior)()  \n  \n                If dataContractBehavior IsNot Nothing Then  \n                    dataContractBehavior.MaxItemsInObjectGraph = 100000  \n                End If  \n            Next  \n        Next  \n        serviceHost.Open()  \n```  \n  \n In the Web-hosted case, you must create a new `ServiceHost` derived class and use a service host factory to plug it in.  \n  \n### Controlling Serialization Settings in Configuration  \n The `MaxItemsInObjectGraph` and `IgnoreExtensionDataObject` can be controlled through configuration by using the `dataContractSerializer` endpoint or service behavior, as shown in the following example.  \n  \n```xml  \n<configuration>  \n    <system.serviceModel>  \n        <behaviors>  \n            <endpointBehaviors>  \n                <behavior name=\"LargeQuotaBehavior\">  \n                    <dataContractSerializer  \n                      maxItemsInObjectGraph=\"100000\" />  \n                </behavior>  \n            </endpointBehaviors>  \n        </behaviors>  \n        <client>  \n            <endpoint address=\"http://example.com/myservice\"  \n                  behaviorConfiguration=\"LargeQuotaBehavior\"  \n                binding=\"basicHttpBinding\" bindingConfiguration=\"\"   \n                            contract=\"IDataService\"  \n                name=\"\" />  \n        </client>  \n    </system.serviceModel>  \n</configuration>  \n```  \n  \n### Shared Type Serialization, Object Graph Preservation, and Custom Serializers  \n The <xref:System.Runtime.Serialization.DataContractSerializer> serializes using data contract names and not .NET type names. This is consistent with service-oriented architecture tenets and allows for a great degree of flexibilityâ€”the .NET types can change without affecting the wire contract. In rare cases, you may want to serialize actual .NET type names, thereby introducing a tight coupling between the client and the server, similar to the .NET Framework remoting technology. This is not a recommended practice, except in rare cases that usually occur when migrating to WCF from .NET Framework remoting. In this case, you must use the <xref:System.Runtime.Serialization.NetDataContractSerializer> class instead of the <xref:System.Runtime.Serialization.DataContractSerializer> class.  \n  \n The <xref:System.Runtime.Serialization.DataContractSerializer> normally serializes object graphs as object trees. That is, if the same object is referred to more than once, it is serialized more than once. For example, consider a `PurchaseOrder` instance that has two fields of type Address called `billTo` and `shipTo`. If both fields are set to the same Address instance, there are two identical Address instances after serialization and deserialization. This is done because there is no standard interoperable way to represent object graphs in XML (except for the legacy SOAP encoded standard available on the <xref:System.Xml.Serialization.XmlSerializer>, as described in the previous section on `Style` and `Use`). Serializing object graphs as trees has certain disadvantages, for example, graphs with circular references cannot be serialized. Occasionally, it is necessary to switch to true object graph serialization, even though it is not interoperable. This can be done by using the <xref:System.Runtime.Serialization.DataContractSerializer> constructed with the `preserveObjectReferences` parameter set to `true`.  \n  \n Occasionally, the built-in serializers are not enough for your scenario. In most cases, you can still use the <xref:System.Runtime.Serialization.XmlObjectSerializer> abstraction from which both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive.  \n  \n The previous three cases (.NET type preservation, object graph preservation, and completely custom `XmlObjectSerializer`-based serialization) all require a custom serializer be plugged in. To do this, perform the following steps:  \n  \n1.  Write your own behavior deriving from the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior>.  \n  \n2.  Override the two `CreateSerializer` methods to return your own serializer (either the <xref:System.Runtime.Serialization.NetDataContractSerializer>, the <xref:System.Runtime.Serialization.DataContractSerializer> with `preserveObjectReferences` set to `true`, or your own custom <xref:System.Runtime.Serialization.XmlObjectSerializer>).  \n  \n3.  Before opening the service host or creating a client channel, remove the existing <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior and plug in the custom derived class that you created in the previous steps.  \n  \n For more information about advanced serialization concepts, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).  \n  \n## See also\n\n- [Using the XmlSerializer Class](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)\n- [How to: Enable Streaming](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)\n- [How to: Create a Basic Data Contract for a Class or Structure](../../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md)\n","nodes":[{"pos":[4,230],"embed":true,"restype":"x-metadata","content":"title: \"Specifying Data Transfer in Service Contracts\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"service contracts [WCF], data transfer\"\nms.assetid: 7c5a26c8-89c9-4bcb-a4bc-7131e6d01f0c","nodes":[{"content":"Specifying Data Transfer in Service Contracts","nodes":[{"pos":[0,45],"content":"Specifying Data Transfer in Service Contracts","nodes":[{"content":"Specifying Data Transfer in Service Contracts","pos":[0,45]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[237,282],"content":"Specifying Data Transfer in Service Contracts","linkify":"Specifying Data Transfer in Service Contracts","nodes":[{"content":"Specifying Data Transfer in Service Contracts","pos":[0,45]}]},{"content":"The Windows Communication Foundation (WCF) can be thought of as a messaging infrastructure.","pos":[283,374]},{"content":"Service operations can receive messages, process them, and send them messages.","pos":[375,453]},{"content":"Messages are described using operation contracts.","pos":[454,503]},{"content":"For example, consider the following contract.","pos":[504,549]},{"pos":[927,1076],"content":"Here, the <ph id=\"ph1\">`GetAirfare`</ph> operation accepts a message with information about <ph id=\"ph2\">`fromCity`</ph> and <ph id=\"ph3\">`toCity`</ph>, and then returns a message that contains a number.","source":"Here, the `GetAirfare` operation accepts a message with information about `fromCity` and `toCity`, and then returns a message that contains a number."},{"content":"This topic explains the various ways in which an operation contract can describe messages.","pos":[1083,1173]},{"pos":[1182,1221],"content":"Describing Messages by Using Parameters","linkify":"Describing Messages by Using Parameters","nodes":[{"content":"Describing Messages by Using Parameters","pos":[0,39]}]},{"content":"The simplest way to describe a message is to use a parameter list and the return value.","pos":[1225,1312]},{"content":"In the preceding example, the <ph id=\"ph1\">`fromCity`</ph> and <ph id=\"ph2\">`toCity`</ph> string parameters were used to describe the request message, and the float return value was used to describe the reply message.","pos":[1313,1494],"source":" In the preceding example, the `fromCity` and `toCity` string parameters were used to describe the request message, and the float return value was used to describe the reply message."},{"content":"If the return value alone is not enough to describe a reply message, out parameters may be used.","pos":[1495,1591]},{"content":"For example, the following operation has <ph id=\"ph1\">`fromCity`</ph> and <ph id=\"ph2\">`toCity`</ph> in its request message, and a number together with a currency in its reply message:","pos":[1592,1740],"source":" For example, the following operation has `fromCity` and `toCity` in its request message, and a number together with a currency in its reply message:"},{"content":"Additionally, you may use reference parameters to make a parameter part of both the request and the reply message.","pos":[1978,2092]},{"content":"The parameters must be of types that can be serialized (converted to XML).","pos":[2093,2167]},{"content":"By default, WCF uses a component called the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class to perform this conversion.","pos":[2168,2304],"source":" By default, WCF uses a component called the <xref:System.Runtime.Serialization.DataContractSerializer> class to perform this conversion."},{"content":"Most primitive types (such as <ph id=\"ph1\">`int`</ph>, <ph id=\"ph2\">`string`</ph>, <ph id=\"ph3\">`float`</ph>, and <ph id=\"ph4\">`DateTime`</ph>.) are supported.","pos":[2305,2392],"source":" Most primitive types (such as `int`, `string`, `float`, and `DateTime`.) are supported."},{"content":"User-defined types must normally have a data contract.","pos":[2393,2447]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.","pos":[2448,2569],"source":" For more information, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)."},{"content":"Occasionally, the <ph id=\"ph1\">`DataContractSerializer`</ph> is not adequate to serialize your types.","pos":[3266,3349],"source":"Occasionally, the `DataContractSerializer` is not adequate to serialize your types."},{"content":"WCF supports an alternative serialization engine, the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, which you can also use to serialize parameters.","pos":[3350,3498],"source":" WCF supports an alternative serialization engine, the <xref:System.Xml.Serialization.XmlSerializer>, which you can also use to serialize parameters."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> allows you to use more control over the resultant XML using attributes such as the <ph id=\"ph2\">`XmlAttributeAttribute`</ph>.","pos":[3499,3656],"source":" The <xref:System.Xml.Serialization.XmlSerializer> allows you to use more control over the resultant XML using attributes such as the `XmlAttributeAttribute`."},{"content":"To switch to using the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> for a particular operation or for the entire service, apply the <ph id=\"ph2\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> attribute to an operation or a service.","pos":[3657,3885],"source":" To switch to using the <xref:System.Xml.Serialization.XmlSerializer> for a particular operation or for the entire service, apply the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute to an operation or a service."},{"content":"For example:","pos":[3886,3898]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using the XmlSerializer Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)</ept>.","pos":[4640,4779],"source":"For more information, see [Using the XmlSerializer Class](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)."},{"content":"Remember that manually switching to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> as shown here is not recommended unless you have specific reasons to do so as detailed in that topic.","pos":[4780,4967],"source":" Remember that manually switching to the <xref:System.Xml.Serialization.XmlSerializer> as shown here is not recommended unless you have specific reasons to do so as detailed in that topic."},{"content":"To isolate .NET parameter names from contract names, you can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageParameterAttribute&gt;</ph> attribute, and use the <ph id=\"ph2\">`Name`</ph> property to set the contract name.","pos":[4974,5160],"source":"To isolate .NET parameter names from contract names, you can use the <xref:System.ServiceModel.MessageParameterAttribute> attribute, and use the `Name` property to set the contract name."},{"content":"For example, the following operation contract is equivalent to the first example in this topic.","pos":[5161,5256]},{"pos":[5650,5675],"content":"Describing Empty Messages","linkify":"Describing Empty Messages","nodes":[{"content":"Describing Empty Messages","pos":[0,25]}]},{"content":"An empty request message can be described by having no input or reference parameters.","pos":[5679,5764]},{"content":"For example in C#:","pos":[5765,5783]},{"content":"For example in VB:","pos":[5862,5880]},{"content":"An empty reply message can be described by having a <ph id=\"ph1\">`void`</ph> return type and no output or reference parameters.","pos":[5969,6078],"source":"An empty reply message can be described by having a `void` return type and no output or reference parameters."},{"content":"For example in:","pos":[6079,6094]},{"content":"This is different from a one-way operation, such as:","pos":[6277,6329]},{"content":"The <ph id=\"ph1\">`SetTemperatureStatus`</ph> operation returns an empty message.","pos":[6537,6599],"source":"The `SetTemperatureStatus` operation returns an empty message."},{"content":"It may return a fault instead if there is a problem processing the input message.","pos":[6600,6681]},{"content":"The <ph id=\"ph1\">`SetLightbulbStatus`</ph> operation returns nothing.","pos":[6682,6733],"source":" The `SetLightbulbStatus` operation returns nothing."},{"content":"There is no way to communicate a fault condition from this operation.","pos":[6734,6803]},{"pos":[6812,6858],"content":"Describing Messages by Using Message Contracts","linkify":"Describing Messages by Using Message Contracts","nodes":[{"content":"Describing Messages by Using Message Contracts","pos":[0,46]}]},{"content":"You may want to use a single type to represent the entire message.","pos":[6862,6928]},{"content":"While it is possible to use a data contract for this purpose, the recommended way to do this is to use a message contractâ€”this avoids unnecessary levels of wrapping in the resultant XML.","pos":[6929,7115]},{"content":"Additionally, message contracts allow you to exercise more control over resultant messages.","pos":[7116,7207]},{"content":"For instance, you can decide which pieces of information should be in the message body and which should be in the message headers.","pos":[7208,7338]},{"content":"The following example shows the use of message contracts.","pos":[7339,7396]},{"pos":[8823,8950],"content":"For more information, see <bpt id=\"p1\">[</bpt>Using Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)</ept>.","source":"For more information, see [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)."},{"content":"In the previous example, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class is still used by default.","pos":[8957,9076],"source":"In the previous example, the <xref:System.Runtime.Serialization.DataContractSerializer> class is still used by default."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class can also be used with message contracts.","pos":[9077,9173],"source":" The <xref:System.Xml.Serialization.XmlSerializer> class can also be used with message contracts."},{"content":"To do this, apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> attribute to either the operation or the contract, and use types compatible with the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class in the message headers and body members.","pos":[9174,9429],"source":" To do this, apply the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute to either the operation or the contract, and use types compatible with the <xref:System.Xml.Serialization.XmlSerializer> class in the message headers and body members."},{"pos":[9438,9474],"content":"Describing Messages by Using Streams","linkify":"Describing Messages by Using Streams","nodes":[{"content":"Describing Messages by Using Streams","pos":[0,36]}]},{"content":"Another way to describe messages in operations is to use the <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph> class or one of its derived classes in an operation contract or as a message contract body member (it must be the only member in this case).","pos":[9478,9703],"source":"Another way to describe messages in operations is to use the <xref:System.IO.Stream> class or one of its derived classes in an operation contract or as a message contract body member (it must be the only member in this case)."},{"content":"For incoming messages, the type must be <ph id=\"ph1\">`Stream`</ph>â€”you cannot use derived classes.","pos":[9704,9784],"source":" For incoming messages, the type must be `Stream`â€”you cannot use derived classes."},{"content":"Instead of invoking the serializer, WCF retrieves data from a stream and puts it directly into an outgoing message, or retrieves data from an incoming message and puts it directly into a stream.","pos":[9791,9985]},{"content":"The following sample shows the use of streams.","pos":[9986,10032]},{"content":"You cannot combine <ph id=\"ph1\">`Stream`</ph> and non-stream data in a single message body.","pos":[10224,10297],"source":"You cannot combine `Stream` and non-stream data in a single message body."},{"content":"Use a message contract to put the extra data in message headers.","pos":[10298,10362]},{"content":"The following example shows the incorrect usage of streams when defining the operation contract.","pos":[10363,10459]},{"content":"The following sample shows the correct usage of streams when defining an operation contract.","pos":[10729,10821]},{"pos":[11430,11559],"content":"For more information, see <bpt id=\"p1\">[</bpt>Large Data and Streaming<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)</ept>.","source":"For more information, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)."},{"pos":[11568,11591],"content":"Using the Message Class","linkify":"Using the Message Class","nodes":[{"content":"Using the Message Class","pos":[0,23]}]},{"pos":[11595,11780],"content":"To have complete programmatic control over messages sent or received, you can use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class directly, as shown in the following example code.","source":"To have complete programmatic control over messages sent or received, you can use the <xref:System.ServiceModel.Channels.Message> class directly, as shown in the following example code."},{"pos":[11939,12102],"content":"This is an advanced scenario, which is described in detail in <bpt id=\"p1\">[</bpt>Using the Message Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)</ept>.","source":"This is an advanced scenario, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)."},{"pos":[12111,12136],"content":"Describing Fault Messages","linkify":"Describing Fault Messages","nodes":[{"content":"Describing Fault Messages","pos":[0,25]}]},{"content":"In addition to the messages that are described by the return value and output or reference parameters, any operation that is not one-way can return at least two possible messages: its normal response message and a fault message.","pos":[12140,12368]},{"content":"Consider the following operation contract.","pos":[12369,12411]},{"content":"This operation may either return a normal message that contains a <ph id=\"ph1\">`float`</ph> number, or a fault message that contains a fault code and a description.","pos":[12647,12793],"source":"This operation may either return a normal message that contains a `float` number, or a fault message that contains a fault code and a description."},{"content":"You can accomplish this by throwing a <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException&gt;</ph> in your service implementation.","pos":[12794,12905],"source":" You can accomplish this by throwing a <xref:System.ServiceModel.FaultException> in your service implementation."},{"content":"You can specify additional possible fault messages by using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultContractAttribute&gt;</ph> attribute.","pos":[12912,13036],"source":"You can specify additional possible fault messages by using the <xref:System.ServiceModel.FaultContractAttribute> attribute."},{"content":"The additional faults must be serializable using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, as shown in the following example code.","pos":[13037,13189],"source":" The additional faults must be serializable using the <xref:System.Runtime.Serialization.DataContractSerializer>, as shown in the following example code."},{"content":"These additional faults can be generated by throwing a <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException%601&gt;</ph> of the appropriate data contract type.","pos":[13987,14126],"source":"These additional faults can be generated by throwing a <xref:System.ServiceModel.FaultException%601> of the appropriate data contract type."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Handling Exceptions and Faults<ept id=\"p1\">](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md)</ept>.","pos":[14127,14262],"source":" For more information, see [Handling Exceptions and Faults](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md)."},{"content":"You cannot use the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> class to describe faults.","pos":[14269,14359],"source":"You cannot use the <xref:System.Xml.Serialization.XmlSerializer> class to describe faults."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> has no effect on fault contracts.","pos":[14360,14453],"source":" The <xref:System.ServiceModel.XmlSerializerFormatAttribute> has no effect on fault contracts."},{"pos":[14462,14481],"content":"Using Derived Types","linkify":"Using Derived Types","nodes":[{"content":"Using Derived Types","pos":[0,19]}]},{"content":"You may want to use a base type in an operation or a message contract, and then use a derived type when actually invoking the operation.","pos":[14485,14621]},{"content":"In this case, you must use either the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceKnownTypeAttribute&gt;</ph> attribute or some alternative mechanism to allow the use of derived types.","pos":[14622,14787],"source":" In this case, you must use either the <xref:System.ServiceModel.ServiceKnownTypeAttribute> attribute or some alternative mechanism to allow the use of derived types."},{"content":"Consider the following operation.","pos":[14788,14821]},{"content":"Assume that two types, <ph id=\"ph1\">`Book`</ph> and <ph id=\"ph2\">`Magazine`</ph>, derive from <ph id=\"ph3\">`LibraryItem`</ph>.","pos":[15036,15108],"source":"Assume that two types, `Book` and `Magazine`, derive from `LibraryItem`."},{"content":"To use these types in the <ph id=\"ph1\">`IsLibraryItemAvailable`</ph> operation, you can change the operation as follows:","pos":[15109,15211],"source":" To use these types in the `IsLibraryItemAvailable` operation, you can change the operation as follows:"},{"pos":[15394,15616],"content":"Alternatively, you can use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute when the default <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is in use, as shown in the following example code.","source":"Alternatively, you can use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute when the default <xref:System.Runtime.Serialization.DataContractSerializer> is in use, as shown in the following example code."},{"pos":[16144,16283],"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlIncludeAttribute&gt;</ph> attribute when using the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.","source":"You can use the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute when using the <xref:System.Xml.Serialization.XmlSerializer>."},{"content":"You can apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceKnownTypeAttribute&gt;</ph> attribute to an operation or to the entire service.","pos":[16290,16412],"source":"You can apply the <xref:System.ServiceModel.ServiceKnownTypeAttribute> attribute to an operation or to the entire service."},{"content":"It accepts either a type or the name of the method to call to get a list of known types, just like the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute.","pos":[16413,16581],"source":" It accepts either a type or the name of the method to call to get a list of known types, just like the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Data Contract Known Types<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>.","pos":[16582,16713],"source":" For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)."},{"pos":[16722,16750],"content":"Specifying the Use and Style","linkify":"Specifying the Use and Style","nodes":[{"content":"Specifying the Use and Style","pos":[0,28]}]},{"content":"When describing services using Web Services Description Language (WSDL), the two commonly used styles are Document and remote procedure call (RPC).","pos":[16754,16901]},{"content":"In the Document style, the entire message body is described using the schema, and the WSDL describes the various message body parts by referring to elements within that schema.","pos":[16902,17078]},{"content":"In the RPC style, the WSDL refers to a schema type for each message part rather than an element.","pos":[17079,17175]},{"content":"In some cases, you have to manually select one of these styles.","pos":[17176,17239]},{"content":"You can do this by applying the <ph id=\"ph1\">&lt;xref:System.ServiceModel.DataContractFormatAttribute&gt;</ph> attribute and setting the <ph id=\"ph2\">`Style`</ph> property (when the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is in use), or by setting <ph id=\"ph4\">`Style`</ph> on the <ph id=\"ph5\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> attribute (when using the <ph id=\"ph6\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>).","pos":[17240,17609],"source":" You can do this by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute and setting the `Style` property (when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use), or by setting `Style` on the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute (when using the <xref:System.Xml.Serialization.XmlSerializer>)."},{"content":"Additionally, the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> supports two forms of serialized XML: <ph id=\"ph2\">`Literal`</ph> and <ph id=\"ph3\">`Encoded`</ph>.","pos":[17616,17742],"source":"Additionally, the <xref:System.Xml.Serialization.XmlSerializer> supports two forms of serialized XML: `Literal` and `Encoded`."},{"content":"<ph id=\"ph1\">`Literal`</ph> is the most commonly accepted form, and is the only form the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> supports.","pos":[17743,17882],"source":"`Literal` is the most commonly accepted form, and is the only form the <xref:System.Runtime.Serialization.DataContractSerializer> supports."},{"content":"<ph id=\"ph1\">`Encoded`</ph> is a legacy form described in section 5 of the SOAP specification, and is not recommended for new services.","pos":[17883,18000],"source":"`Encoded` is a legacy form described in section 5 of the SOAP specification, and is not recommended for new services."},{"content":"To switch to <ph id=\"ph1\">`Encoded`</ph> mode, set the <ph id=\"ph2\">`Use`</ph> property on the <ph id=\"ph3\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> attribute to <ph id=\"ph4\">`Encoded`</ph>.","pos":[18001,18139],"source":" To switch to `Encoded` mode, set the `Use` property on the <xref:System.ServiceModel.XmlSerializerFormatAttribute> attribute to `Encoded`."},{"pos":[18146,18241],"content":"In most cases, you should not change the default settings for the <ph id=\"ph1\">`Style`</ph> and <ph id=\"ph2\">`Use`</ph> properties.","source":"In most cases, you should not change the default settings for the `Style` and `Use` properties."},{"pos":[18250,18287],"content":"Controlling the Serialization Process","linkify":"Controlling the Serialization Process","nodes":[{"content":"Controlling the Serialization Process","pos":[0,37]}]},{"content":"You can do a number of things to customize the way data is serialized.","pos":[18291,18361]},{"pos":[18371,18409],"content":"Changing Server Serialization Settings","linkify":"Changing Server Serialization Settings","nodes":[{"content":"Changing Server Serialization Settings","pos":[0,38]}]},{"content":"When the default <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is in use, you can control some aspects of the serialization process on the service by applying the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph> attribute to the service.","pos":[18413,18666],"source":"When the default <xref:System.Runtime.Serialization.DataContractSerializer> is in use, you can control some aspects of the serialization process on the service by applying the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute to the service."},{"content":"Specifically, you may use the <ph id=\"ph1\">`MaxItemsInObjectGraph`</ph> property to set the quota that limits the maximum number of objects the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> deserializes.","pos":[18667,18865],"source":" Specifically, you may use the `MaxItemsInObjectGraph` property to set the quota that limits the maximum number of objects the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes."},{"content":"You can use the <ph id=\"ph1\">`IgnoreExtensionDataObject`</ph> property to turn off the round-tripping versioning feature.","pos":[18866,18969],"source":" You can use the `IgnoreExtensionDataObject` property to turn off the round-tripping versioning feature."},{"content":"For more information about quotas, see <bpt id=\"p1\">[</bpt>Security Considerations for Data<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)</ept>.","pos":[18970,19128],"source":" For more information about quotas, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)."},{"content":"For more information about round-tripping, see <bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>.","pos":[19129,19297],"source":" For more information about round-tripping, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)."},{"pos":[19749,19772],"content":"Serialization Behaviors","linkify":"Serialization Behaviors","nodes":[{"content":"Serialization Behaviors","pos":[0,23]}]},{"content":"Two behaviors are available in WCF, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.XmlSerializerOperationBehavior&gt;</ph> that are automatically plugged in depending on which serializer is in use for a particular operation.","pos":[19776,20074],"source":"Two behaviors are available in WCF, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and the <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> that are automatically plugged in depending on which serializer is in use for a particular operation."},{"content":"Because these behaviors are applied automatically, you normally do not have to be aware of them.","pos":[20075,20171]},{"content":"However, the <ph id=\"ph1\">`DataContractSerializerOperationBehavior`</ph> has the <ph id=\"ph2\">`MaxItemsInObjectGraph`</ph>, <ph id=\"ph3\">`IgnoreExtensionDataObject`</ph>, and <ph id=\"ph4\">`DataContractSurrogate`</ph> properties that you may use to customize the serialization process.","pos":[20178,20390],"source":"However, the `DataContractSerializerOperationBehavior` has the `MaxItemsInObjectGraph`, `IgnoreExtensionDataObject`, and `DataContractSurrogate` properties that you may use to customize the serialization process."},{"content":"The first two properties have the same meaning as discussed in the previous section.","pos":[20391,20475]},{"content":"You can use the <ph id=\"ph1\">`DataContractSurrogate`</ph> property to enable data contract surrogates, which are a powerful mechanism for customizing and extending the serialization process.","pos":[20476,20648],"source":" You can use the `DataContractSurrogate` property to enable data contract surrogates, which are a powerful mechanism for customizing and extending the serialization process."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Data Contract Surrogates<ept id=\"p1\">](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)</ept>.","pos":[20649,20772],"source":" For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)."},{"content":"You can use the <ph id=\"ph1\">`DataContractSerializerOperationBehavior`</ph> to customize both client and server serialization.","pos":[20779,20887],"source":"You can use the `DataContractSerializerOperationBehavior` to customize both client and server serialization."},{"content":"The following example shows how to increase the <ph id=\"ph1\">`MaxItemsInObjectGraph`</ph> quota on the client.","pos":[20888,20980],"source":" The following example shows how to increase the `MaxItemsInObjectGraph` quota on the client."},{"content":"Following is the equivalent code on the service, in the self-hosted case.","pos":[22112,22185]},{"pos":[23414,23533],"content":"In the Web-hosted case, you must create a new <ph id=\"ph1\">`ServiceHost`</ph> derived class and use a service host factory to plug it in.","source":"In the Web-hosted case, you must create a new `ServiceHost` derived class and use a service host factory to plug it in."},{"pos":[23543,23594],"content":"Controlling Serialization Settings in Configuration","linkify":"Controlling Serialization Settings in Configuration","nodes":[{"content":"Controlling Serialization Settings in Configuration","pos":[0,51]}]},{"pos":[23598,23800],"content":"The <ph id=\"ph1\">`MaxItemsInObjectGraph`</ph> and <ph id=\"ph2\">`IgnoreExtensionDataObject`</ph> can be controlled through configuration by using the <ph id=\"ph3\">`dataContractSerializer`</ph> endpoint or service behavior, as shown in the following example.","source":"The `MaxItemsInObjectGraph` and `IgnoreExtensionDataObject` can be controlled through configuration by using the `dataContractSerializer` endpoint or service behavior, as shown in the following example."},{"pos":[24543,24619],"content":"Shared Type Serialization, Object Graph Preservation, and Custom Serializers","linkify":"Shared Type Serialization, Object Graph Preservation, and Custom Serializers","nodes":[{"content":"Shared Type Serialization, Object Graph Preservation, and Custom Serializers","pos":[0,76]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> serializes using data contract names and not .NET type names.","pos":[24623,24747],"source":"The <xref:System.Runtime.Serialization.DataContractSerializer> serializes using data contract names and not .NET type names."},{"content":"This is consistent with service-oriented architecture tenets and allows for a great degree of flexibilityâ€”the .NET types can change without affecting the wire contract.","pos":[24748,24916]},{"content":"In rare cases, you may want to serialize actual .NET type names, thereby introducing a tight coupling between the client and the server, similar to the .NET Framework remoting technology.","pos":[24917,25104]},{"content":"This is not a recommended practice, except in rare cases that usually occur when migrating to WCF from .NET Framework remoting.","pos":[25105,25232]},{"content":"In this case, you must use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> class instead of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> class.","pos":[25233,25412],"source":" In this case, you must use the <xref:System.Runtime.Serialization.NetDataContractSerializer> class instead of the <xref:System.Runtime.Serialization.DataContractSerializer> class."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> normally serializes object graphs as object trees.","pos":[25419,25532],"source":"The <xref:System.Runtime.Serialization.DataContractSerializer> normally serializes object graphs as object trees."},{"content":"That is, if the same object is referred to more than once, it is serialized more than once.","pos":[25533,25624]},{"content":"For example, consider a <ph id=\"ph1\">`PurchaseOrder`</ph> instance that has two fields of type Address called <ph id=\"ph2\">`billTo`</ph> and <ph id=\"ph3\">`shipTo`</ph>.","pos":[25625,25739],"source":" For example, consider a `PurchaseOrder` instance that has two fields of type Address called `billTo` and `shipTo`."},{"content":"If both fields are set to the same Address instance, there are two identical Address instances after serialization and deserialization.","pos":[25740,25875]},{"content":"This is done because there is no standard interoperable way to represent object graphs in XML (except for the legacy SOAP encoded standard available on the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, as described in the previous section on <ph id=\"ph2\">`Style`</ph> and <ph id=\"ph3\">`Use`</ph>).","pos":[25876,26138],"source":" This is done because there is no standard interoperable way to represent object graphs in XML (except for the legacy SOAP encoded standard available on the <xref:System.Xml.Serialization.XmlSerializer>, as described in the previous section on `Style` and `Use`)."},{"content":"Serializing object graphs as trees has certain disadvantages, for example, graphs with circular references cannot be serialized.","pos":[26139,26267]},{"content":"Occasionally, it is necessary to switch to true object graph serialization, even though it is not interoperable.","pos":[26268,26380]},{"content":"This can be done by using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> constructed with the <ph id=\"ph2\">`preserveObjectReferences`</ph> parameter set to <ph id=\"ph3\">`true`</ph>.","pos":[26381,26542],"source":" This can be done by using the <xref:System.Runtime.Serialization.DataContractSerializer> constructed with the `preserveObjectReferences` parameter set to `true`."},{"content":"Occasionally, the built-in serializers are not enough for your scenario.","pos":[26549,26621]},{"content":"In most cases, you can still use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph> abstraction from which both the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> derive.","pos":[26622,26883],"source":" In most cases, you can still use the <xref:System.Runtime.Serialization.XmlObjectSerializer> abstraction from which both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive."},{"content":"The previous three cases (.NET type preservation, object graph preservation, and completely custom <ph id=\"ph1\">`XmlObjectSerializer`</ph>-based serialization) all require a custom serializer be plugged in.","pos":[26890,27078],"source":"The previous three cases (.NET type preservation, object graph preservation, and completely custom `XmlObjectSerializer`-based serialization) all require a custom serializer be plugged in."},{"content":"To do this, perform the following steps:","pos":[27079,27119]},{"pos":[27129,27250],"content":"Write your own behavior deriving from the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph>.","source":"Write your own behavior deriving from the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior>."},{"pos":[27260,27595],"content":"Override the two <ph id=\"ph1\">`CreateSerializer`</ph> methods to return your own serializer (either the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>, the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> with <ph id=\"ph4\">`preserveObjectReferences`</ph> set to <ph id=\"ph5\">`true`</ph>, or your own custom <ph id=\"ph6\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph>).","source":"Override the two `CreateSerializer` methods to return your own serializer (either the <xref:System.Runtime.Serialization.NetDataContractSerializer>, the <xref:System.Runtime.Serialization.DataContractSerializer> with `preserveObjectReferences` set to `true`, or your own custom <xref:System.Runtime.Serialization.XmlObjectSerializer>)."},{"pos":[27605,27851],"content":"Before opening the service host or creating a client channel, remove the existing <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph> behavior and plug in the custom derived class that you created in the previous steps.","source":"Before opening the service host or creating a client channel, remove the existing <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior and plug in the custom derived class that you created in the previous steps."},{"pos":[27858,28043],"content":"For more information about advanced serialization concepts, see <bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.","source":"For more information about advanced serialization concepts, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)."},{"pos":[28052,28060],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[28064,28176],"content":"<bpt id=\"p1\">[</bpt>Using the XmlSerializer Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)</ept>","source":"[Using the XmlSerializer Class](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)"},{"pos":[28179,28280],"content":"<bpt id=\"p1\">[</bpt>How to: Enable Streaming<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)</ept>","source":"[How to: Enable Streaming](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)"},{"pos":[28283,28458],"content":"<bpt id=\"p1\">[</bpt>How to: Create a Basic Data Contract for a Class or Structure<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md)</ept>","source":"[How to: Create a Basic Data Contract for a Class or Structure](../../../../docs/framework/wcf/feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md)"}]}