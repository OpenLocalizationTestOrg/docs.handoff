{"content":"---\ntitle: LINQ (Language Integrated Query)\ndescription: LINQ (Language Integrated Query)\nkeywords: .NET, .NET Core\nauthor: cartermp\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: dotnet-standard\nms.devlang: dotnet\nms.assetid: c00939e1-59e3-4e61-8fe9-08ad6b3f1295\n---\n\n# LINQ (Language Integrated Query)\n\n## What is it?\n\nLINQ provides language-level querying capabilities and a [higher-order function](https://en.wikipedia.org/wiki/Higher-order_function) API to C# and VB as a way to write expressive, declarative code.\n\nLanguage-level query syntax:\n\n```csharp\nvar linqExperts = from p in programmers\n                  where p.IsNewToLINQ\n                  select new LINQExpert(p);\n\n```\n\nSame example using the `IEnumerable<T>` API:\n\n```csharp\nvar linqExperts = programmers.Where(p => IsNewToLINQ)\n                             .Select(p => new LINQExpert(p));\n\n```\n\n## LINQ is Expressive\n\nImagine you have a list of pets, but want to convert it into a dictionary where you can access a pet directly by its `RFID` value.\n\nTraditional imperative code:\n\n```csharp\nvar petLookup = new Dictionary<int, Pet>();\n\nforeach (var pet in pets)\n{\n    petLookup.Add(pet.RFID, pet);\n}\n\n```\n\nThe intention behind the code is not to create a new `Dictionary<int, Pet>` and add to it via a loop, it is to convert an existing list into a dictionary! LINQ preserves the intention whereas the imperative code does not.\n\nEquivalent LINQ expression:\n\n```csharp\nvar petLookup = pets.ToDictionary(pet => pet.RFID);\n\n```\n\nThe code using LINQ is valuable because it evens the playing field between intent and code when reasoning as a programmer. Another bonus is code brevity. Imagine reducing large portions of a codebase by 1/3 as done above. Pretty sweet deal, right?\n\n## LINQ Providers Simplify Data Access\n\nFor a significant chunk of software out in the wild, everything revolves around dealing with data from some source (Databases, JSON, XML, etc). Often this involves learning a new API for each data source, which can be annoying. LINQ simplifies this by abstracting common elements of data access into a query syntax which looks the same no matter which data source you pick.\n\nConsider the following: finding all XML elements with a specific attribute value.\n\n```csharp\npublic static IEnumerable<XElement> FindAllElementsWithAttribute(XElement documentRoot, string elementName,\n                                           string attributeName, string value)\n{\n    return from el in documentRoot.Elements(elementName)\n           where (string)el.Element(attributeName) == value\n           select el;\n}\n\n```\n\nWriting code to manually traverse the XML document to perform this task would be far more challenging.\n\nInteracting with XML isn’t the only thing you can do with LINQ Providers. [Linq to SQL](https://msdn.microsoft.com/library/bb386976.aspx) is a fairly bare-bones Object-Relational Mapper (ORM) for an MSSQL Server Database. The [JSON.NET](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm) library provides efficient JSON Document traversal via LINQ. Furthermore, if there isn’t a library which does what you need, you can also [write your own LINQ Provider](https://msdn.microsoft.com/library/Bb546158.aspx)!\n\n## Why Use the Query Syntax?\n\nThis is a question which often comes up. After all, this,\n\n```csharp\nvar filteredItems = myItems.Where(item => item.Foo);\n\n```\n\nis a lot more concise than this:\n\n```csharp\nvar filteredItems = from item in myItems\n                    where item.Foo\n                    select item;\n\n```\n\nIsn’t the API syntax just a more concise way to do the query syntax?\n\nNo. The query syntax allows for the use the **let** clause, which allows you to introduce and bind a variable within the scope of the expression, using it in subsequent pieces of the expression. Reproducing the same code with only the API syntax can be done, but will most likely lead to code which is hard to read.\n\nSo this begs the question, **should you just use the query syntax?**\n\nThe answer to this question is **yes** if...\n\n*   Your existing codebase already uses the query syntax\n*   You need to scope variables within your queries due to complexity\n*   You prefer the query syntax and it won’t distract from your codebase\n\nThe answer to this question is **no** if...\n\n*   Your existing codebase already uses the API syntax\n*   You have no need to scope variables within your queries\n*   You prefer the API syntax and it won’t distract from your codebase\n\n## Essential Samples\n\nFor a truly comprehensive list of LINQ samples, visit [101 LINQ Samples](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b).\n\nThe following is a quick demonstration of some of the essential pieces of LINQ. This is in no way comprehensive, as LINQ provides significantly more functionality than what is showcased here.\n\n*   The bread and butter - `Where`, `Select`, and `Aggregate`:\n\n```csharp\n// Filtering a list\nvar germanShepards = dogs.Where(dog => dog.Breed == DogBreed.GermanShepard);\n\n// Using the query syntax\nvar queryGermanShepards = from dog in dogs\n                          where dog.Breed == DogBreed.GermanShepard\n                          select dog;\n\n// Mapping a list from type A to type B\nvar cats = dogs.Select(dog => dog.TurnIntoACat());\n\n// Using the query syntax\nvar queryCats = from dog in dogs\n                select dog.TurnIntoACat();\n\n// Summing then lengths of a set of strings\nint seed = 0;\nint sumOfStrings = strings.Aggregate(seed, (s1, s2) => s1.Length + s2.Length);\n\n```\n\n*   Flattening a list of lists:\n\n```csharp\n// Transforms the list of kennels into a list of all their dogs.\nvar allDogsFromKennels = kennels.SelectMany(kennel => kennel.Dogs);\n\n```\n\n*   Union between two sets (with custom comparator):\n\n```csharp\npublic class DogHairLengthComparer : IEqualityComparer<Dog>\n{\n    public bool Equals(Dog a, Dog b)\n    {\n        if (a == null && b == null)\n        {\n            return true;\n        }\n        else if ((a == null && b != null) ||\n                 (a != null && b == null))\n        {\n            return false;\n        }\n        else\n        {\n            return a.HairLengthType == b.HairLengthType;\n        }\n    }\n\n    public int GetHashCode(Dog d)\n    {\n        // default hashcode is enough here, as these are simple objects.\n        return b.GetHashCode();\n    }\n}\n\n...\n\n// Gets all the short-haired dogs between two different kennels\nvar allShortHairedDogs = kennel1.Dogs.Union(kennel2.Dogs, new DogHairLengthComparer());\n\n```\n\n*   Intersection between two sets:\n\n```csharp\n// Gets the volunteers who spend share time with two humane societies.\nvar volunteers = humaneSociety1.Volunteers.Intersect(humaneSociety2.Volunteers,\n                                                     new VolunteerTimeComparer());\n\n```\n\n*   Ordering:\n\n```csharp\n// Get driving directions, ordering by if it's toll-free before estimated driving time.\nvar results = DirectionsProcessor.GetDirections(start, end)\n              .OrderBy(direction => direction.HasNoTolls)\n              .ThenBy(direction => direction.EstimatedTime);\n\n```\n\n*   Finally, a more advanced sample: determining if the values of the properties of two instances of the same type are equal (Borrowed and modified from [this StackOverflow post](http://stackoverflow.com/a/844855)):\n\n```csharp\npublic static bool PublicInstancePropertiesEqual<T>(this T self, T to, params string[] ignore) where T : class\n{\n    if (self != null && to != null)\n    {\n        var type = typeof(T);\n        var ignoreList = new List<string>(ignore);\n\n        // Selects the properties which have unequal values into a sequence of those properties.\n        var unequalProperties = from pi in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)\n                                where !ignoreList.Contains(pi.Name)\n                                let selfValue = type.GetProperty(pi.Name).GetValue(self, null)\n                                let toValue = type.GetProperty(pi.Name).GetValue(to, null)\n                                where selfValue != toValue && (selfValue == null || !selfValue.Equals(toValue))\n                                select new { Prop = pi.Name, selfValue, toValue };\n        return !unequalProperties.Any();\n    }\n\n    return self == to;\n}\n\n```\n\n## PLINQ\n\nPLINQ, or Parallel LINQ, is a parallel execution engine for LINQ expressions. In other words, a regular LINQ expressions can be trivially parallelized across any number of threads. This is accomplished via a call to `AsParallel()` preceding the expression.\n\nConsider the following:\n\n```csharp\npublic static string GetAllFacebookUserLikesMessage(IEnumerable<FacebookUser> facebookUsers)\n{\n    var seed = default(UInt64);\n\n    Func<UInt64, UInt64, UInt64> threadAccumulator = (t1, t2) => t1 + t2;\n    Func<UInt64, UInt64, UInt64> threadResultAccumulator = (t1, t2) => t1 + t2;\n    Func<Uint64, string> resultSelector = total => $\"Facebook has {total} likes!\";\n\n    return facebookUsers.AsParallel()\n                        .Aggregate(seed, threadAccumulator, threadResultAccumulator, resultSelector);\n}\n\n```\n\nThis code will partition `facebookUsers` across system threads as necessary, sum up the total likes on each thread in parallel, sum the results computed by each thread, and project that result into a nice string.\n\nIn diagram form:\n\n![PLINQ diagram](./media/using-linq/plinq-diagram.png)\n\nParallelizable CPU-bound jobs which can be easily expressed via LINQ (in other words, are pure functions and have no side effects) are a great candidate for PLINQ. For jobs which _do_ have a side effect, consider using the [Task Parallel Library](https://msdn.microsoft.com/library/dd460717.aspx).\n\n## Further Resources:\n\n*   [101 LINQ Samples](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)\n*   [Linqpad](https://www.linqpad.net/), a playground environment and Database querying engine for C#/F#/VB\n*   [EduLinq](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/), an e-book for learning how LINQ-to-objects is implemented\n","nodes":[{"pos":[11,43],"content":"LINQ (Language Integrated Query)","needQuote":true,"needEscape":true,"nodes":[{"content":"LINQ (Language Integrated Query)","pos":[0,32]}]},{"pos":[57,89],"content":"LINQ (Language Integrated Query)","needQuote":true,"needEscape":true,"nodes":[{"content":"LINQ (Language Integrated Query)","pos":[0,32]}]},{"pos":[100,115],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[309,341],"content":"LINQ (Language Integrated Query)","linkify":"LINQ (Language Integrated Query)","nodes":[{"content":"LINQ (Language Integrated Query)","pos":[0,32]}]},{"pos":[346,357],"content":"What is it?","linkify":"What is it?","nodes":[{"content":"What is it?","pos":[0,11]}]},{"pos":[359,557],"content":"LINQ provides language-level querying capabilities and a <bpt id=\"p1\">[</bpt>higher-order function<ept id=\"p1\">](https://en.wikipedia.org/wiki/Higher-order_function)</ept> API to C# and VB as a way to write expressive, declarative code.","source":"LINQ provides language-level querying capabilities and a [higher-order function](https://en.wikipedia.org/wiki/Higher-order_function) API to C# and VB as a way to write expressive, declarative code."},{"content":"Language-level query syntax:","pos":[559,587]},{"pos":[727,771],"content":"Same example using the <ph id=\"ph1\">`IEnumerable&lt;T&gt;`</ph> API:","source":"Same example using the `IEnumerable<T>` API:"},{"pos":[908,926],"content":"LINQ is Expressive","linkify":"LINQ is Expressive","nodes":[{"content":"LINQ is Expressive","pos":[0,18]}]},{"pos":[928,1058],"content":"Imagine you have a list of pets, but want to convert it into a dictionary where you can access a pet directly by its <ph id=\"ph1\">`RFID`</ph> value.","source":"Imagine you have a list of pets, but want to convert it into a dictionary where you can access a pet directly by its `RFID` value."},{"content":"Traditional imperative code:","pos":[1060,1088]},{"content":"The intention behind the code is not to create a new <ph id=\"ph1\">`Dictionary&lt;int, Pet&gt;`</ph> and add to it via a loop, it is to convert an existing list into a dictionary!","pos":[1215,1369],"source":"The intention behind the code is not to create a new `Dictionary<int, Pet>` and add to it via a loop, it is to convert an existing list into a dictionary!"},{"content":"LINQ preserves the intention whereas the imperative code does not.","pos":[1370,1436]},{"content":"Equivalent LINQ expression:","pos":[1438,1465]},{"content":"The code using LINQ is valuable because it evens the playing field between intent and code when reasoning as a programmer.","pos":[1535,1657]},{"content":"Another bonus is code brevity.","pos":[1658,1688]},{"content":"Imagine reducing large portions of a codebase by 1/3 as done above.","pos":[1689,1756]},{"content":"Pretty sweet deal, right?","pos":[1757,1782]},{"pos":[1787,1822],"content":"LINQ Providers Simplify Data Access","linkify":"LINQ Providers Simplify Data Access","nodes":[{"content":"LINQ Providers Simplify Data Access","pos":[0,35]}]},{"content":"For a significant chunk of software out in the wild, everything revolves around dealing with data from some source (Databases, JSON, XML, etc).","pos":[1824,1967]},{"content":"Often this involves learning a new API for each data source, which can be annoying.","pos":[1968,2051]},{"content":"LINQ simplifies this by abstracting common elements of data access into a query syntax which looks the same no matter which data source you pick.","pos":[2052,2197]},{"content":"Consider the following: finding all XML elements with a specific attribute value.","pos":[2199,2280]},{"content":"Writing code to manually traverse the XML document to perform this task would be far more challenging.","pos":[2628,2730]},{"content":"Interacting with XML isn’t the only thing you can do with LINQ Providers.","pos":[2732,2805]},{"content":"<bpt id=\"p1\">[</bpt>Linq to SQL<ept id=\"p1\">](https://msdn.microsoft.com/library/bb386976.aspx)</ept> is a fairly bare-bones Object-Relational Mapper (ORM) for an MSSQL Server Database.","pos":[2806,2953],"source":"[Linq to SQL](https://msdn.microsoft.com/library/bb386976.aspx) is a fairly bare-bones Object-Relational Mapper (ORM) for an MSSQL Server Database."},{"content":"The <bpt id=\"p1\">[</bpt>JSON.NET<ept id=\"p1\">](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm)</ept> library provides efficient JSON Document traversal via LINQ.","pos":[2954,3086],"source":" The [JSON.NET](http://www.newtonsoft.com/json/help/html/LINQtoJSON.htm) library provides efficient JSON Document traversal via LINQ."},{"content":"Furthermore, if there isn’t a library which does what you need, you can also <bpt id=\"p1\">[</bpt>write your own LINQ Provider<ept id=\"p1\">](https://msdn.microsoft.com/library/Bb546158.aspx)</ept>!","pos":[3087,3245],"source":" Furthermore, if there isn’t a library which does what you need, you can also [write your own LINQ Provider](https://msdn.microsoft.com/library/Bb546158.aspx)!"},{"pos":[3250,3275],"content":"Why Use the Query Syntax?","linkify":"Why Use the Query Syntax?","nodes":[{"content":"Why Use the Query Syntax?","pos":[0,25]}]},{"content":"This is a question which often comes up.","pos":[3277,3317]},{"content":"After all, this,","pos":[3318,3334]},{"content":"is a lot more concise than this:","pos":[3405,3437]},{"content":"Isn’t the API syntax just a more concise way to do the query syntax?","pos":[3564,3632]},{"content":"No.","pos":[3634,3637]},{"content":"The query syntax allows for the use the <bpt id=\"p1\">**</bpt>let<ept id=\"p1\">**</ept> clause, which allows you to introduce and bind a variable within the scope of the expression, using it in subsequent pieces of the expression.","pos":[3638,3828],"source":" The query syntax allows for the use the **let** clause, which allows you to introduce and bind a variable within the scope of the expression, using it in subsequent pieces of the expression."},{"content":"Reproducing the same code with only the API syntax can be done, but will most likely lead to code which is hard to read.","pos":[3829,3949]},{"pos":[3951,4019],"content":"So this begs the question, <bpt id=\"p1\">**</bpt>should you just use the query syntax?<ept id=\"p1\">**</ept>","source":"So this begs the question, **should you just use the query syntax?**"},{"pos":[4021,4065],"content":"The answer to this question is <bpt id=\"p1\">**</bpt>yes<ept id=\"p1\">**</ept> if...","source":"The answer to this question is **yes** if..."},{"content":"Your existing codebase already uses the query syntax","pos":[4071,4123]},{"content":"You need to scope variables within your queries due to complexity","pos":[4128,4193]},{"content":"You prefer the query syntax and it won’t distract from your codebase","pos":[4198,4266]},{"pos":[4268,4311],"content":"The answer to this question is <bpt id=\"p1\">**</bpt>no<ept id=\"p1\">**</ept> if...","source":"The answer to this question is **no** if..."},{"content":"Your existing codebase already uses the API syntax","pos":[4317,4367]},{"content":"You have no need to scope variables within your queries","pos":[4372,4427]},{"content":"You prefer the API syntax and it won’t distract from your codebase","pos":[4432,4498]},{"pos":[4503,4520],"content":"Essential Samples","linkify":"Essential Samples","nodes":[{"content":"Essential Samples","pos":[0,17]}]},{"pos":[4522,4654],"content":"For a truly comprehensive list of LINQ samples, visit <bpt id=\"p1\">[</bpt>101 LINQ Samples<ept id=\"p1\">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>.","source":"For a truly comprehensive list of LINQ samples, visit [101 LINQ Samples](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)."},{"content":"The following is a quick demonstration of some of the essential pieces of LINQ.","pos":[4656,4735]},{"content":"This is in no way comprehensive, as LINQ provides significantly more functionality than what is showcased here.","pos":[4736,4847]},{"pos":[4853,4911],"content":"The bread and butter - <ph id=\"ph1\">`Where`</ph>, <ph id=\"ph2\">`Select`</ph>, and <ph id=\"ph3\">`Aggregate`</ph>:","source":"The bread and butter - `Where`, `Select`, and `Aggregate`:"},{"content":"Flattening a list of lists:","pos":[5539,5566]},{"content":"Union between two sets (with custom comparator):","pos":[5721,5769]},{"content":"Intersection between two sets:","pos":[6519,6549]},{"content":"Ordering:","pos":[6805,6814]},{"pos":[7103,7314],"content":"Finally, a more advanced sample: determining if the values of the properties of two instances of the same type are equal (Borrowed and modified from <bpt id=\"p1\">[</bpt>this StackOverflow post<ept id=\"p1\">](http://stackoverflow.com/a/844855)</ept>):","source":"Finally, a more advanced sample: determining if the values of the properties of two instances of the same type are equal (Borrowed and modified from [this StackOverflow post](http://stackoverflow.com/a/844855)):"},{"pos":[8298,8303],"content":"PLINQ","linkify":"PLINQ","nodes":[{"content":"PLINQ","pos":[0,5]}]},{"content":"PLINQ, or Parallel LINQ, is a parallel execution engine for LINQ expressions.","pos":[8305,8382]},{"content":"In other words, a regular LINQ expressions can be trivially parallelized across any number of threads.","pos":[8383,8485]},{"content":"This is accomplished via a call to <ph id=\"ph1\">`AsParallel()`</ph> preceding the expression.","pos":[8486,8561],"source":" This is accomplished via a call to `AsParallel()` preceding the expression."},{"content":"Consider the following:","pos":[8563,8586]},{"pos":[9112,9324],"content":"This code will partition <ph id=\"ph1\">`facebookUsers`</ph> across system threads as necessary, sum up the total likes on each thread in parallel, sum the results computed by each thread, and project that result into a nice string.","source":"This code will partition `facebookUsers` across system threads as necessary, sum up the total likes on each thread in parallel, sum the results computed by each thread, and project that result into a nice string."},{"content":"In diagram form:","pos":[9326,9342]},{"content":"PLINQ diagram","pos":[9346,9359]},{"content":"Parallelizable CPU-bound jobs which can be easily expressed via LINQ (in other words, are pure functions and have no side effects) are a great candidate for PLINQ.","pos":[9400,9563]},{"content":"For jobs which <bpt id=\"p1\">_</bpt>do<ept id=\"p1\">_</ept> have a side effect, consider using the <bpt id=\"p2\">[</bpt>Task Parallel Library<ept id=\"p2\">](https://msdn.microsoft.com/library/dd460717.aspx)</ept>.","pos":[9564,9697],"source":" For jobs which _do_ have a side effect, consider using the [Task Parallel Library](https://msdn.microsoft.com/library/dd460717.aspx)."},{"pos":[9702,9720],"content":"Further Resources:","linkify":"Further Resources:","nodes":[{"content":"Further Resources:","pos":[0,18]}]},{"pos":[9726,9803],"content":"<bpt id=\"p1\">[</bpt>101 LINQ Samples<ept id=\"p1\">](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)</ept>","source":"[101 LINQ Samples](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)"},{"pos":[9808,9911],"content":"<bpt id=\"p1\">[</bpt>Linqpad<ept id=\"p1\">](https://www.linqpad.net/)</ept>, a playground environment and Database querying engine for C#/F#/VB","source":"[Linqpad](https://www.linqpad.net/), a playground environment and Database querying engine for C#/F#/VB"},{"pos":[9916,10093],"content":"<bpt id=\"p1\">[</bpt>EduLinq<ept id=\"p1\">](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/)</ept>, an e-book for learning how LINQ-to-objects is implemented","source":"[EduLinq](http://codeblog.jonskeet.uk/2011/02/23/reimplementing-linq-to-objects-part-45-conclusion-and-list-of-posts/), an e-book for learning how LINQ-to-objects is implemented"}]}