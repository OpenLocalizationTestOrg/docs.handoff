<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff7e67add731324e01b8f2cc323a66e3a8683ec9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\structs.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2c12d3288656963eec1e33bc5ab1663830a9765e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">396c22c21e30c4aeeb9096ab3da8c769667af5cf</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Structs | C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn about the struct type and how you create them</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, C#</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Structs</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>struct<ept id="p1">*</ept> is a value type.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When a struct is created, the variable to which the struct is assigned holds the struct's actual data.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When the struct is assigned to a new variable, it is copied.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The new variable and the original variable therefore contain two separate copies of the same data.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Changes made to one copy do not affect the other copy.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>There is no separate heap allocation or garbage collection overhead for value-type variables.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>There are two categories of value types: <bpt id="p1">[</bpt>struct<ept id="p1">](./language-reference/keywords/struct.md)</ept> and <bpt id="p2">[</bpt>enum<ept id="p2">](./language-reference/keywords/enum.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The built-in numeric types are structs, and they have properties and methods that you can access:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Static Method<ept id="p2">](../../samples/snippets/csharp/concepts/structs/static-method.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>But you declare and assign values to them as if they were simple non-aggregate types:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Assign Values<ept id="p2">](../../samples/snippets/csharp/concepts/structs/assign-value.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Value types are <bpt id="p1">*</bpt>sealed<ept id="p1">*</ept>, which means, for example, that you cannot derive a type from <ph id="ph1">@System.Int32</ph>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <ph id="ph2">@System.ValueType</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>However, a struct can implement one or more interfaces.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can cast a struct type to an interface type; this causes a <bpt id="p1">*</bpt>boxing<ept id="p1">*</ept> operation to wrap the struct inside a reference type object on the managed heap.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Boxing operations occur when you pass a value type to a method that takes an <ph id="ph1">@System.Object</ph> as an input parameter.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](./programming-guide/types/boxing-and-unboxing.md )</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You use the <bpt id="p1">[</bpt>struct<ept id="p1">](./language-reference/keywords/struct.md)</ept> keyword to create your own custom value types.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Struct Keyword<ept id="p2">](../../samples/snippets/csharp/concepts/structs/struct-keyword.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For more information about value types in the .NET Framework, see <bpt id="p1">[</bpt>Common Type System<ept id="p1">](../standard/common-type-system.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Structs share most of the same syntax as classes, although structs are more limited than classes:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Within a struct declaration, fields cannot be initialized unless they are declared as <ph id="ph1">`const`</ph> or <ph id="ph2">`static`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A struct cannot declare a default constructor (a constructor without parameters) or a finalizer.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Structs are copied on assignment.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When a struct is assigned to a new variable, all the data is copied, and any modification to the new copy does not change the data for the original copy.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This is important to remember when working with collections of value types such as Dictionary&lt;string, myStruct&gt;.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Structs are value types and classes are reference types.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Unlike classes, structs can be instantiated without using a <ph id="ph1">`new`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Structs can declare constructors that have parameters.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A struct cannot inherit from another struct or class, and it cannot be the base of a class.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>All structs inherit directly from <ph id="ph1">@System.ValueType</ph>, which inherits from <ph id="ph2">@System.Object</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>A struct can implement interfaces.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Literal values</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In C#, literal values receive a type from the compiler.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can specify how a numeric literal should be typed by appending a letter to the end of the number.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: <ph id="ph1">`4.56f`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If no letter is appended, the compiler will infer the <ph id="ph1">`double`</ph> type for the literal.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information about which types can be specified with letter suffixes, see the reference pages for individual types in <bpt id="p1">[</bpt>Value Types<ept id="p1">](./language-reference/keywords/value-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Because literals are typed, and all types derive ultimately from <ph id="ph1">@System.Object</ph>, you can write and compile code such as the following:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Literal Values<ept id="p2">](../../samples/snippets/csharp/concepts/structs/literals.cs)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The last two examples demonstrate language features introduced in C# 7.0.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first allows you to use an underscore character as a <bpt id="p1">*</bpt>digit separator<ept id="p1">*</ept> inside numeric literals.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can put them wherever you want between digits to improve readability.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>They have no effect on the value.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The second demonstrates <bpt id="p1">*</bpt>binary literals<ept id="p1">*</ept>, which allow you to specify bit patterns directly instead of using hexadecimal notation.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Ordinary value types cannot have a value of <bpt id="p1">[</bpt>null<ept id="p1">](./language-reference/keywords/null.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>However, you can create nullable value types by affixing a <bpt id="p1">**</bpt>?<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>after the type.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt>int?<ept id="p1">**</ept> is an <bpt id="p2">**</bpt>int<ept id="p2">**</ept> type that can also have the value <bpt id="p3">[</bpt>null<ept id="p3">](./language-reference/keywords/null.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the CTS, nullable types are instances of the generic struct type <ph id="ph1">@System.Nullable</ph>%601.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Nullable Types (C# Programming Guide)<ept id="p1">](./programming-guide/nullable-types/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Classes<ept id="p1">](classes.md)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Basic Types<ept id="p1">](basic-types.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>