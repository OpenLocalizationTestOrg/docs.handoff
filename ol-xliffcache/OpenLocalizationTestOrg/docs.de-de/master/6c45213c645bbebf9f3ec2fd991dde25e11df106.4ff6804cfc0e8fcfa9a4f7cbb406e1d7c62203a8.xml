{"content":"---\ntitle: \"Handling Exceptions and Faults | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: a64d01c6-f221-4f58-93e5-da4e87a5682e\ncaps.latest.revision: 12\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Handling Exceptions and Faults\nExceptions are used to communicate errors locally within the service or the client implementation. Faults, on the other hand, are used to communicate errors across service boundaries, such as from the server to the client or vice versa. In addition to faults, transport channels often use transport-specific mechanisms to communicate transport-level errors. For example, HTTP transport uses status codes such as 404 to communicate a non-existing endpoint URL (there is no endpoint to send back a fault). This document consists of three sections that provide guidance to custom channel authors. The first section provides guidance on when and how to define and throw exceptions. The second section provides guidance around generating and consuming faults. The third section explains how to provide trace information to aid the user of your custom channel in troubleshooting running applications.  \n  \n## Exceptions  \n There are two things to keep in mind when throwing an exception: First it has to be of a type that allows users to write correct code that can react appropriately to the exception. Second, it has to provide enough information for the user to understand what went wrong, the failure impact, and how to fix it. The following sections give guidance around exception types and messages for [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] channels. There is also general guidance around exceptions in .NET in the Design Guidelines for Exceptions document.  \n  \n### Exception Types  \n All exceptions thrown by channels must be either a <xref:System.TimeoutException?displayProperty=fullName>, <xref:System.ServiceModel.CommunicationException?displayProperty=fullName>, or a type derived from <xref:System.ServiceModel.CommunicationException>. (Exceptions such as <xref:System.ObjectDisposedException> may also be thrown, but only to indicate that the calling code has misused the channel. If a channel is used correctly, it must only throw the given exceptions.) [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides seven exception types that derive from <xref:System.ServiceModel.CommunicationException> and are designed to be used by channels. There are other <xref:System.ServiceModel.CommunicationException>-derived exceptions that are designed to be used by other parts of the system. These exception types are:  \n  \n|Exception Type|Meaning|Inner Exception Content|Recovery Strategy|  \n|--------------------|-------------|-----------------------------|-----------------------|  \n|<xref:System.ServiceModel.AddressAlreadyInUseException>|The endpoint address specified for listening is already in use.|If present, provides more details about the transport error that caused this exception. For example. <xref:System.IO.PipeException>, <xref:System.Net.HttpListenerException>, or <xref:System.Net.Sockets.SocketException>.|Try a different address.|  \n|<xref:System.ServiceModel.AddressAccessDeniedException>|The process is not allowed access to the endpoint address specified for listening.|If present, provides more details about the transport error that caused this exception. For example, <xref:System.IO.PipeException>, or <xref:System.Net.HttpListenerException>.|Try with different credentials.|  \n|<xref:System.ServiceModel.CommunicationObjectFaultedException>|The <xref:System.ServiceModel.ICommunicationObject> being used is in the Faulted state (for more information, see [Understanding State Changes](../../../../docs/framework/wcf/extending/understanding-state-changes.md)). Note that when an object with multiple pending calls transitions to the Faulted state, only one call throws an exception that is related to the failure and the rest of the calls throw a <xref:System.ServiceModel.CommunicationObjectFaultedException>. This exception is typically thrown because an application overlooks some exception and tries to use an already faulted object, possibly on a thread other than the one that caught the original exception.|If present provides details about the inner exception.|Create a new object. Note that depending on what caused the <xref:System.ServiceModel.ICommunicationObject> to fault in the first place, there may be other work required to recover.|  \n|<xref:System.ServiceModel.CommunicationObjectAbortedException>|The <xref:System.ServiceModel.ICommunicationObject> being used has been Aborted (for more information, see [Understanding State Changes](../../../../docs/framework/wcf/extending/understanding-state-changes.md)). Similar to <xref:System.ServiceModel.CommunicationObjectFaultedException>, his exception indicates the application has called <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the object, possibly from another thread, and the object is no longer usable for that reason.|If present provides details about the inner exception.|Create a new object. Note that depending on what caused the <xref:System.ServiceModel.ICommunicationObject> to abort in the first place, there may be other work required to recover.|  \n|<xref:System.ServiceModel.EndpointNotFoundException>|The target remote endpoint is not listening. This can result from any part of the endpoint address being incorrect, irresolvable, or the endpoint being down. Examples include DNS error, Queue Manager not available, and service not running.|The inner exception provides details, typically from the underlying transport.|Try a different address. Alternatively, the sender may wait a while and try again in case the service was down|  \n|<xref:System.ServiceModel.ProtocolException>|The communication protocols, as described by the endpoint’s policy, are mismatched between endpoints. For example, framing content type mismatch or max message size exceeded.|If present provides more information about the specific protocol error. For example, <xref:System.ServiceModel.QuotaExceededException> is the inner exception when the error cause is exceeding MaxReceivedMessageSize.|Recovery: Ensure sender and received protocol settings match. One way to do this is to re-import the service endpoint’s metadata (policy) and use the generated binding to recreate the channel.|  \n|<xref:System.ServiceModel.ServerTooBusyException>|The remote endpoint is listening but is not prepared to process messages.|If present, the inner Exception provides the SOAP fault or transport-level error details.|Recovery: Wait and retry the operation later.|  \n|<xref:System.TimeoutException>|The operation failed to complete within the timeout period.|May provide details about the timeout.|Wait and retry the operation later.|  \n  \n Define a new exception type only if that type corresponds to a specific recovery strategy different from all of the existing exception types. If you do define a new exception type, it must derive from <xref:System.ServiceModel.CommunicationException> or one of its derived classes.  \n  \n### Exception Messages  \n Exception messages are targeted at the user not the program so they should provide sufficient information to help the user understand and solve the problem. The three essential parts of a good exception message are:  \n  \n What happened. Provide a clear description of the problem using terms that relate to the user’s experience. For example, a bad exception message would be \"Invalid configuration section\". This leaves the user wondering which configuration section is incorrect and why it is incorrect. An improved message would be \"Invalid configuration section \\<customBinding>\". An even better message would be \"Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport\". This is a very specific message using terms and names that the user can easily identify in the application’s configuration file. However, there are still a few key components missing.  \n  \n The significance of the error. Unless the message states clearly what the error means, the user is likely to wonder whether it is a fatal error or if it can be ignored. In general, messages should lead with the meaning or significance of the error. To improve the previous example, the message could be \"ServiceHost failed to Open due to a configuration error: Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport\".  \n  \n How the user should correct the problem. The most important part of the message is helping the user fix the problem. The message should include some guidance or hints about what to check or fix to remedy the problem. For example, \"ServiceHost failed to Open due to a configuration error: Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport. Please ensure there is only one transport in the binding\".  \n  \n## Communicating Faults  \n SOAP 1.1 and SOAP 1.2 both define a specific structure for faults. There are some differences between the two specifications but in general, the Message and MessageFault types are used to create and consume faults.  \n  \n ![Handling exceptions and faults](../../../../docs/framework/wcf/extending/media/wcfc-soap1-1andsoap1-2faultcomparisonc.gif \"wcfc_SOAP1-1AndSOAP1-2FaultComparisonc\")  \nSOAP 1.2 Fault (left) and SOAP 1.1 Fault (right). Note that in SOAP 1.1 only the Fault element is namespace qualified.  \n  \n SOAP defines a fault message as a message that contains only a fault element (an element whose name is `<env:Fault>`) as a child of `<env:Body>`. The contents of the fault element differ slightly between SOAP 1.1 and SOAP 1.2 as shown in figure 1. However, the <xref:System.ServiceModel.Channels.MessageFault?displayProperty=fullName> class normalizes these differences into one object model:  \n  \n```  \npublic abstract class MessageFault  \n{  \n    protected MessageFault();  \n  \n    public virtual string Actor { get; }  \n    public virtual string Node { get; }  \n    public static string DefaultAction { get; }  \n    public abstract FaultCode Code { get; }  \n    public abstract bool HasDetail { get; }  \n    public abstract FaultReason Reason { get; }  \n  \n    public T GetDetail<T>();  \n    public T GetDetail<T>( XmlObjectSerializer serializer);  \n    public System.Xml.XmlDictionaryReader GetReaderAtDetailContents();  \n  \n    // other methods omitted  \n}  \n```  \n  \n The `Code` property corresponds to the `env:Code` (or `faultCode` in SOAP 1.1) and identifies the type of the fault. SOAP 1.2 defines five allowable values for `faultCode` (for example, Sender and Receiver) and defines a `Subcode` element which can contain any subcode value. (See the [SOAP 1.2 specification](http://go.microsoft.com/fwlink/?LinkId=95176) for the list of allowable fault codes and their meaning.) SOAP 1.1 has a slightly different mechanism: It defines four `faultCode` values (for example, Client and Server) that can be extended either by defining entirely new ones or by using the dot notation to create more specific `faultCodes`, for example, Client.Authentication.  \n  \n When you use MessageFault to program faults, the FaultCode.Name and FaultCode.Namespace maps to the name and namespace of the SOAP 1.2 `env:Code` or the SOAP 1.1 `faultCode`. The FaultCode.SubCode maps to `env:Subcode` for SOAP 1.2 and is null for SOAP 1.1.  \n  \n You should create new fault subcodes (or new fault codes if using SOAP 1.1) if it is interesting to programmatically distinguish a fault. This is analogous to creating a new exception type. You should avoid using the dot notation with SOAP 1.1 fault codes. (The [WS-I Basic Profile](http://go.microsoft.com/fwlink/?LinkId=95177) also discourages the use of the fault code dot notation.)  \n  \n```  \npublic class FaultCode  \n{  \n    public FaultCode(string name);  \n    public FaultCode(string name, FaultCode subCode);  \n    public FaultCode(string name, string ns);  \n    public FaultCode(string name, string ns, FaultCode subCode);  \n  \n    public bool IsPredefinedFault { get; }  \n    public bool IsReceiverFault { get; }  \n    public bool IsSenderFault { get; }  \n    public string Name { get; }  \n    public string Namespace { get; }  \n    public FaultCode SubCode { get; }  \n  \n//  methods omitted  \n  \n}  \n```  \n  \n The `Reason` property corresponds to the `env:Reason` (or `faultString` in SOAP 1.1) a human-readable description of the error condition analogous to an exception’s message. The `FaultReason` class (and SOAP `env:Reason/faultString`) has built-in support for having multiple translations in the interest of globalization.  \n  \n```  \npublic class FaultReason  \n{  \n    public FaultReason(FaultReasonText translation);  \n    public FaultReason(IEnumerable<FaultReasonText> translations);  \n    public FaultReason(string text);  \n  \n    public SynchronizedReadOnlyCollection<FaultReasonText> Translations   \n    {   \n       get;   \n    }  \n  \n }  \n```  \n  \n The fault detail contents are exposed on MessageFault using various methods including the `GetDetail`\\<T> and `GetReaderAtDetailContents`(). The fault detail is an opaque element for carrying additional detail about the fault. This is useful if there is some arbitrary structured detail that you want to carry with the fault.  \n  \n### Generating Faults  \n This section explains the process of generating a fault in response to an error condition detected in a channel or in a message property created by the channel. A typical example is sending back a fault in response to a request message that contains invalid data.  \n  \n When generating a fault, the custom channel should not send the fault directly, rather, it should throw an exception and let the layer above decide whether to convert that exception to a fault and how to send it. To aid in this conversion, the channel should provide a `FaultConverter` implementation that can convert the exception thrown by the custom channel to the appropriate fault. `FaultConverter` is defined as:  \n  \n```  \npublic class FaultConverter  \n{  \n    public static FaultConverter GetDefaultFaultConverter(  \n                                   MessageVersion version);  \n    protected abstract bool OnTryCreateFaultMessage(  \n                                   Exception exception,   \n                                   out Message message);  \n    public bool TryCreateFaultMessage(  \n                                   Exception exception,   \n                                   out Message message);  \n}  \n```  \n  \n Each channel that generates custom faults must implement `FaultConverter` and return it from a call to `GetProperty<FaultConverter>`. The custom `OnTryCreateFaultMessage` implementation must either convert the exception to a fault or delegate to the inner channel’s `FaultConverter`. If the channel is a transport it must either convert the exception or delegate to the encoder’s `FaultConverter` or the default `FaultConverter` provided in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] . The default `FaultConverter` converts errors corresponding to fault messages specified by WS-Addressing and SOAP. Here is an example `OnTryCreateFaultMessage` implementation.  \n  \n```  \npublic override bool OnTryCreateFaultMessage(Exception exception,   \n                                             out Message message)  \n{  \n    if (exception is ...)  \n    {  \n        message = ...;  \n        return true;  \n    }  \n  \n#if IMPLEMENTING_TRANSPORT_CHANNEL  \n    FaultConverter encoderConverter =   \n                    this.encoder.GetProperty<FaultConverter>();  \n    if ((encoderConverter != null) &&               \n        (encoderConverter.TryCreateFaultMessage(  \n         exception, out message)))  \n    {  \n        return true;  \n    }  \n  \n    FaultConverter defaultConverter =   \n                   FaultConverter.GetDefaultFaultConverter(  \n                   this.channel.messageVersion);  \n    return defaultConverter.TryCreateFaultMessage(  \n                   exception,   \n                   out message);  \n#else  \n    FaultConverter inner =   \n                   this.innerChannel.GetProperty<FaultConverter>();  \n    if (inner != null)  \n    {  \n        return inner.TryCreateFaultMessage(exception, out message);  \n    }  \n    else  \n    {  \n        message = null;  \n        return false;  \n    }  \n#endif  \n}  \n```  \n  \n An implication of this pattern is that exceptions thrown between layers for error conditions that require faults must contain enough information for the corresponding fault generator to create the correct fault. As a custom channel author, you may define exception types that correspond to different fault conditions if such exceptions do not already exist. Note that exceptions traversing channel layers should communicate the error condition rather than opaque fault data.  \n  \n### Fault Categories  \n There are generally three categories of faults:  \n  \n1.  Faults that are pervasive throughout the entire stack. These faults could be encountered at any layer in the channel stack, for example InvalidCardinalityAddressingException.  \n  \n2.  Faults that can be encountered anywhere above a certain layer in the stack for example some errors that pertain to a flowed transaction or to security roles.  \n  \n3.  Faults that are directed at a single layer in the stack, for example errors like WS-RM sequence number faults.  \n  \n Category 1. Faults are generally WS-Addressing and SOAP faults. The base `FaultConverter` class provided by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] converts errors corresponding to fault messages specified by WS-Addressing and SOAP so you do not have to handle conversion of these exceptions yourself.  \n  \n Category 2. Faults occur when a layer adds a property to the message that does not completely consume message information that pertains to that layer. Errors may be detected later when a higher layer asks the message property to process message information further. Such channels should implement the `GetProperty` specified previously to enable the higher layer to send back the correct fault. An example of this is the TransactionMessageProperty. This property is added to the message without fully validating all the data in the header (doing so may involve contacting the distributed transaction coordinator (DTC).  \n  \n Category 3. Faults are only generated and sent by a single layer in the processor. Therefore all the exceptions are contained within the layer. To improve consistency among channels and ease maintenance, your custom channel should use the pattern specified previously to generate fault messages even for internal faults.  \n  \n### Interpreting Received Faults  \n This section provides guidance for generating the appropriate exception when receiving a fault message. The decision tree for processing a message at every layer in the stack is as follows:  \n  \n1.  If the layer considers the message to be invalid, the layer should do its ‘invalid message’ processing. Such processing is specific to the layer but could include dropping the message, tracing, or throwing an exception that gets converted to a fault. Examples include security receiving a message that is not secured properly, or RM receiving a message with a bad sequence number.  \n  \n2.  Otherwise, if the message is a fault message that applies specifically to the layer, and the message is not meaningful outside the layer’s interaction, the layer should handle the error condition. An example of this is an RM Sequence Refused fault that is meaningless to layers above the RM channel and that implies faulting the RM channel and throwing from pending operations.  \n  \n3.  Otherwise, the message should be returned from Request() or Receive(). This includes cases where the layer recognizes the fault, but the fault just indicates that a request failed and does not imply faulting the channel and throwing from pending operations. To improve usability in such a case, the layer should implement `GetProperty<FaultConverter>` and return a `FaultConverter` derived class that can convert the fault to an exception by overriding `OnTryCreateException`.  \n  \n The following object model supports converting messages to exceptions:  \n  \n```  \npublic class FaultConverter  \n{  \n    public static FaultConverter GetDefaultFaultConverter(  \n                                  MessageVersion version);  \n    protected abstract bool OnTryCreateException(  \n                                 Message message,   \n                                 MessageFault fault,   \n                                 out Exception exception);  \n    public bool TryCreateException(  \n                                 Message message,   \n                                 MessageFault fault,   \n                                 out Exception exception);  \n}  \n```  \n  \n A channel layer can implement `GetProperty<FaultConverter>` to support converting fault messages to exceptions. To do so, override `OnTryCreateException` and inspect the fault message. If recognized, do the conversion, otherwise ask the inner channel to convert it. Transport channels should delegate to `FaultConverter.GetDefaultFaultConverter` to get the default SOAP/WS-Addressing FaultConverter.  \n  \n A typical implementation looks like this:  \n  \n```  \npublic override bool OnTryCreateException(  \n                            Message message,   \n                            MessageFault fault,   \n                            out Exception exception)  \n{  \n    if (message.Action == \"...\")  \n    {  \n        exception = ...;  \n        return true;  \n    }  \n    // OR  \n    if ((fault.Code.Name == \"...\") && (fault.Code.Namespace == \"...\"))  \n    {  \n        exception = ...;  \n        return true;  \n    }  \n  \n    if (fault.IsMustUnderstand)  \n    {  \n        if (fault.WasHeaderNotUnderstood(  \n                   message.Headers, \"...\", \"...\"))  \n        {  \n            exception = new ProtocolException(...);  \n            return true;  \n        }  \n    }  \n  \n#if IMPLEMENTING_TRANSPORT_CHANNEL  \n    FaultConverter encoderConverter =   \n              this.encoder.GetProperty<FaultConverter>();  \n    if ((encoderConverter != null) &&   \n        (encoderConverter.TryCreateException(  \n                              message, fault, out exception)))  \n    {  \n        return true;  \n    }  \n  \n    FaultConverter defaultConverter =  \n             FaultConverter.GetDefaultFaultConverter(  \n                             this.channel.messageVersion);  \n    return defaultConverter.TryCreateException(  \n                             message, fault, out exception);  \n#else  \n    FaultConverter inner =   \n                    this.innerChannel.GetProperty<FaultConverter>();  \n    if (inner != null)  \n    {  \n        return inner.TryCreateException(message, fault, out exception);  \n    }  \n    else  \n    {  \n        exception = null;  \n        return false;  \n    }  \n#endif  \n}  \n```  \n  \n For specific fault conditions that have distinct recovery scenarios, consider defining a derived class of `ProtocolException`.  \n  \n### MustUnderstand Processing  \n SOAP defines a general fault for signaling that a required header was not understood by the receiver. This fault is known as the `mustUnderstand` fault. In [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], custom channels never generate `mustUnderstand` faults. Instead, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] Dispatcher, which is located at the top of the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] communication stack, checks to see that all headers that were marked as MustUndestand=true were understood by the underlying stack. If any were not understood, a `mustUnderstand` fault is generated at that point. (The user can choose to turn off this `mustUnderstand` processing and have the application receive all message headers. In that case the application is responsible for performing `mustUnderstand` processing.) The generated fault includes a NotUnderstood header that contains the names of all headers with MustUnderstand=true that were not understood.  \n  \n If your protocol channel sends a custom header with MustUnderstand=true and receives a `mustUnderstand` fault, it must figure out whether that fault is due to the header it sent. There are two members on the `MessageFault` class that are useful for this:  \n  \n```  \npublic class MessageFault  \n{  \n    ...  \n    public bool IsMustUnderstandFault { get; }  \n    public static bool WasHeaderNotUnderstood(MessageHeaders headers,   \n        string name, string ns) { }  \n    ...  \n  \n}  \n```  \n  \n `IsMustUnderstandFault` returns `true` if the fault is a `mustUnderstand` fault. `WasHeaderNotUnderstood` returns `true` if the header with the specified name and namespace is included in the fault as a NotUnderstood header.  Otherwise, it returns `false`.  \n  \n If a channel emits a header that is marked MustUnderstand = true, then that layer should also implement the Exception Generation API pattern and should convert `mustUnderstand` faults caused by that header to a more useful exception as described previously.  \n  \n## Tracing  \n The .NET Framework provides a mechanism to trace program execution as a way to aid diagnosing production applications or intermittent problems where it is not possible to just attach a debugger and step through the code. The core components of this mechanism are in the <xref:System.Diagnostics?displayProperty=fullName> namespace and consist of:  \n  \n-   <xref:System.Diagnostics.TraceSource?displayProperty=fullName>, which is the source of trace information to be written, <xref:System.Diagnostics.TraceListener?displayProperty=fullName>, which is an abstract base class for concrete listeners that receive the information to be traced from the <xref:System.Diagnostics.TraceSource> and output it to a listener-specific destination. For example, <xref:System.Diagnostics.XmlWriterTraceListener> outputs trace information to an XML file. Finally, <xref:System.Diagnostics.TraceSwitch?displayProperty=fullName>, which lets the application user control the tracing verbosity and is typically specified in configuration.  \n  \n-   In addition to the core components, you can use the [Service Trace Viewer Tool (SvcTraceViewer.exe)](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md) to view and search [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] traces. The tool is designed specifically for trace files generated by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and written out using <xref:System.Diagnostics.XmlWriterTraceListener>. The following figure shows the various components involved in tracing.  \n  \n ![Handling exceptions and faults](../../../../docs/framework/wcf/extending/media/wcfc-tracinginchannelsc.gif \"wcfc_TracingInChannelsc\")  \n  \n### Tracing from a Custom Channel  \n Custom channels should write out trace messages to assist in diagnosing problems when it is not possible to attach a debugger to the running application. This involves two high level tasks: Instantiating a <xref:System.Diagnostics.TraceSource> and calling its methods to write traces.  \n  \n When instantiating a <xref:System.Diagnostics.TraceSource>, the string you specify becomes the name of that source. This name is used to configure (enable/disable/set tracing level) the trace source. It also appears in the trace output itself. Custom channels should use a unique source name to help readers of the trace output understand where the trace information comes from. Using the name of the assembly that is writing the information as the name of the trace source is the common practice. For example, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses System.ServiceModel as the trace source for information written from the System.ServiceModel assembly.  \n  \n Once you have a trace source, you call its <xref:System.Diagnostics.TraceSource.TraceData%2A>, <xref:System.Diagnostics.TraceSource.TraceEvent%2A>, or <xref:System.Diagnostics.TraceSource.TraceInformation%2A> methods to write trace entries to the trace listeners. For each trace entry you write, you need to classify the type of event as one of the event types defined in <xref:System.Diagnostics.TraceEventType>. This classification and the trace level setting in configuration determine whether the trace entry is output to the listener. For example, setting the trace level in configuration to `Warning` allows `Warning`, `Error` and `Critical` trace entries to be written but blocks Information and Verbose entries. Here is an example of instantiating a trace source and writing out an entry at Information level:  \n  \n```  \nusing System.Diagnostics;  \n//...  \nTraceSource udpSource=new TraceSource(\"Microsoft.Samples.Udp\");  \n//...  \nudpsource.TraceInformation(\"UdpInputChannel received a message\");  \n```  \n  \n> [!IMPORTANT]\n>  It is highly recommended that you specify a trace source name that is unique to your custom channel to help trace output readers understand where the output came from.  \n  \n#### Integrating with the Trace Viewer  \n Traces generated by your channel can be output in a format readable by the [Service Trace Viewer Tool (SvcTraceViewer.exe)](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md) by using <xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=fullName> as the trace listener. This is not something you, as the channel developer, need to do. Rather, it is the application user (or the person troubleshooting the application) that needs to configure this trace listener in the application’s configuration file. For example, the following configuration outputs trace information from both <xref:System.ServiceModel?displayProperty=fullName> and `Microsoft.Samples.Udp` to the file named `TraceEventsFile.e2e`:  \n  \n```  \n<configuration>  \n  <system.diagnostics>  \n    <sources>  \n      <!-- configure System.ServiceModel trace source -->  \n      <source name=\"System.ServiceModel\" switchValue=\"Verbose\"   \n              propagateActivity=\"true\">  \n        <listeners>  \n          <add name=\"e2e\" />  \n        </listeners>  \n      </source>  \n      <!-- configure Microsoft.Samples.Udp trace source -->  \n      <source name=\"Microsoft.Samples.Udp\" switchValue=\"Verbose\" >  \n        <listeners>  \n          <add name=\"e2e\" />  \n        </listeners>  \n      </source>  \n    </sources>  \n    <!--   \n    Define a shared trace listener that outputs to TraceFile.e2e  \n    The listener name is e2e   \n    -->  \n    <sharedListeners>  \n      <add name=\"e2e\" type=\"System.Diagnostics.XmlWriterTraceListener\"  \n        initializeData=\".\\TraceFile.e2e\"/>  \n    </sharedListeners>  \n    <trace autoflush=\"true\" />  \n  </system.diagnostics>  \n</configuration>  \n```  \n  \n#### Tracing Structured Data  \n <xref:System.Diagnostics.TraceSource?displayProperty=fullName> has a <xref:System.Diagnostics.TraceSource.TraceData%2A> method that takes one or more objects that are to be included in the trace entry. In general, the <xref:System.Object.ToString%2A?displayProperty=fullName> method is called on each object and the resulting string is written as part of the trace entry. When using <xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=fullName> to output traces, you can pass an <xref:System.Xml.XPath.IXPathNavigable?displayProperty=fullName> as the data object to <xref:System.Diagnostics.TraceSource.TraceData%2A>. The resulting trace entry includes the XML provided by the <xref:System.Xml.XPath.XPathNavigator?displayProperty=fullName>. Here is an example entry with XML application data:  \n  \n```  \n<E2ETraceEvent xmlns=\"http://schemas.microsoft.com/2004/06/E2ETraceEvent\">  \n  <System xmlns=\"...\">  \n    <EventID>12</EventID>  \n    <Type>3</Type>  \n    <SubType Name=\"Information\">0</SubType>  \n    <Level>8</Level>  \n    <TimeCreated SystemTime=\"2006-01-13T22:58:03.0654832Z\" />  \n    <Source Name=\"Microsoft.ServiceModel.Samples.Udp\" />  \n    <Correlation ActivityID=\"{00000000-0000-0000-0000-000000000000}\" />  \n    <Execution  ProcessName=\"UdpTestConsole\"   \n                ProcessID=\"3348\" ThreadID=\"4\" />  \n    <Channel />  \n    <Computer>COMPUTER-LT01</Computer>  \n  </System>  \n<!-- XML application data -->  \n  <ApplicationData>  \n  <TraceData>  \n   <DataItem>  \n   <TraceRecord   \n     Severity=\"Information\"  \n     xmlns=\"…\">  \n        <TraceIdentifier>some trace id</TraceIdentifier>  \n        <Description>EndReceive called</Description>  \n        <AppDomain>UdpTestConsole.exe</AppDomain>  \n        <Source>UdpInputChannel</Source>  \n      </TraceRecord>  \n    </DataItem>  \n  </TraceData>  \n  </ApplicationData>  \n</E2ETraceEvent>  \n```  \n  \n The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] trace viewer understands the schema of the `TraceRecord` element shown previously and extracts the data from its child elements and displays it in a tabular format. Your channel should use this schema when tracing structured application data to help Svctraceviewer.exe users read the data.","nodes":[{"pos":[12,59],"content":"Handling Exceptions and Faults | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Handling Exceptions and Faults | Microsoft Docs","pos":[0,47]}]},{"pos":[358,388],"content":"Handling Exceptions and Faults","linkify":"Handling Exceptions and Faults","nodes":[{"content":"Handling Exceptions and Faults","pos":[0,30]}]},{"content":"Exceptions are used to communicate errors locally within the service or the client implementation.","pos":[389,487]},{"content":"Faults, on the other hand, are used to communicate errors across service boundaries, such as from the server to the client or vice versa.","pos":[488,625]},{"content":"In addition to faults, transport channels often use transport-specific mechanisms to communicate transport-level errors.","pos":[626,746]},{"content":"For example, HTTP transport uses status codes such as 404 to communicate a non-existing endpoint URL (there is no endpoint to send back a fault).","pos":[747,892]},{"content":"This document consists of three sections that provide guidance to custom channel authors.","pos":[893,982]},{"content":"The first section provides guidance on when and how to define and throw exceptions.","pos":[983,1066]},{"content":"The second section provides guidance around generating and consuming faults.","pos":[1067,1143]},{"content":"The third section explains how to provide trace information to aid the user of your custom channel in troubleshooting running applications.","pos":[1144,1283]},{"pos":[1292,1302],"content":"Exceptions","linkify":"Exceptions","nodes":[{"content":"Exceptions","pos":[0,10]}]},{"content":"There are two things to keep in mind when throwing an exception: First it has to be of a type that allows users to write correct code that can react appropriately to the exception.","pos":[1306,1486]},{"content":"Second, it has to provide enough information for the user to understand what went wrong, the failure impact, and how to fix it.","pos":[1487,1614]},{"content":"The following sections give guidance around exception types and messages for <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> channels.","pos":[1615,1757],"source":" The following sections give guidance around exception types and messages for [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] channels."},{"content":"There is also general guidance around exceptions in .NET in the Design Guidelines for Exceptions document.","pos":[1758,1864]},{"pos":[1874,1889],"content":"Exception Types","linkify":"Exception Types","nodes":[{"content":"Exception Types","pos":[0,15]}]},{"content":"All exceptions thrown by channels must be either a <ph id=\"ph1\">&lt;xref:System.TimeoutException?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.CommunicationException?displayProperty=fullName&gt;</ph>, or a type derived from <ph id=\"ph3\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>.","pos":[1893,2150],"source":"All exceptions thrown by channels must be either a <xref:System.TimeoutException?displayProperty=fullName>, <xref:System.ServiceModel.CommunicationException?displayProperty=fullName>, or a type derived from <xref:System.ServiceModel.CommunicationException>."},{"content":"(Exceptions such as <ph id=\"ph1\">&lt;xref:System.ObjectDisposedException&gt;</ph> may also be thrown, but only to indicate that the calling code has misused the channel.","pos":[2151,2296],"source":" (Exceptions such as <xref:System.ObjectDisposedException> may also be thrown, but only to indicate that the calling code has misused the channel."},{"content":"If a channel is used correctly, it must only throw the given exceptions.) <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> provides seven exception types that derive from <ph id=\"ph2\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph> and are designed to be used by channels.","pos":[2297,2565],"source":" If a channel is used correctly, it must only throw the given exceptions.) [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides seven exception types that derive from <xref:System.ServiceModel.CommunicationException> and are designed to be used by channels."},{"content":"There are other <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>-derived exceptions that are designed to be used by other parts of the system.","pos":[2566,2709],"source":" There are other <xref:System.ServiceModel.CommunicationException>-derived exceptions that are designed to be used by other parts of the system."},{"content":"These exception types are:","pos":[2710,2736]},{"content":"Exception Type","pos":[2743,2757]},{"content":"Meaning","pos":[2758,2765]},{"content":"Inner Exception Content","pos":[2766,2789]},{"content":"Recovery Strategy","pos":[2790,2807]},{"content":"The endpoint address specified for listening is already in use.","pos":[2961,3024]},{"content":"If present, provides more details about the transport error that caused this exception.","pos":[3025,3112]},{"content":"For example.","pos":[3113,3125]},{"content":"<ph id=\"ph1\">&lt;xref:System.IO.PipeException&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.HttpListenerException&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[3126,3244],"source":"<xref:System.IO.PipeException>, <xref:System.Net.HttpListenerException>, or <xref:System.Net.Sockets.SocketException>."},{"content":"Try a different address.","pos":[3245,3269]},{"content":"The process is not allowed access to the endpoint address specified for listening.","pos":[3330,3412]},{"content":"If present, provides more details about the transport error that caused this exception.","pos":[3413,3500]},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.IO.PipeException&gt;</ph>, or <ph id=\"ph2\">&lt;xref:System.Net.HttpListenerException&gt;</ph>.","pos":[3501,3589],"source":" For example, <xref:System.IO.PipeException>, or <xref:System.Net.HttpListenerException>."},{"content":"Try with different credentials.","pos":[3590,3621]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> being used is in the Faulted state (for more information, see <bpt id=\"p1\">[</bpt>Understanding State Changes<ept id=\"p1\">](../../../../docs/framework/wcf/extending/understanding-state-changes.md)</ept>).","pos":[3689,3907],"source":"The <xref:System.ServiceModel.ICommunicationObject> being used is in the Faulted state (for more information, see [Understanding State Changes](../../../../docs/framework/wcf/extending/understanding-state-changes.md))."},{"content":"Note that when an object with multiple pending calls transitions to the Faulted state, only one call throws an exception that is related to the failure and the rest of the calls throw a <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationObjectFaultedException&gt;</ph>.","pos":[3908,4157],"source":" Note that when an object with multiple pending calls transitions to the Faulted state, only one call throws an exception that is related to the failure and the rest of the calls throw a <xref:System.ServiceModel.CommunicationObjectFaultedException>."},{"content":"This exception is typically thrown because an application overlooks some exception and tries to use an already faulted object, possibly on a thread other than the one that caught the original exception.","pos":[4158,4360]},{"content":"If present provides details about the inner exception.","pos":[4361,4415]},{"content":"Create a new object.","pos":[4416,4436]},{"content":"Note that depending on what caused the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> to fault in the first place, there may be other work required to recover.","pos":[4437,4597],"source":" Note that depending on what caused the <xref:System.ServiceModel.ICommunicationObject> to fault in the first place, there may be other work required to recover."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> being used has been Aborted (for more information, see <bpt id=\"p1\">[</bpt>Understanding State Changes<ept id=\"p1\">](../../../../docs/framework/wcf/extending/understanding-state-changes.md)</ept>).","pos":[4665,4876],"source":"The <xref:System.ServiceModel.ICommunicationObject> being used has been Aborted (for more information, see [Understanding State Changes](../../../../docs/framework/wcf/extending/understanding-state-changes.md))."},{"content":"Similar to <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationObjectFaultedException&gt;</ph>, his exception indicates the application has called <ph id=\"ph2\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> on the object, possibly from another thread, and the object is no longer usable for that reason.","pos":[4877,5156],"source":" Similar to <xref:System.ServiceModel.CommunicationObjectFaultedException>, his exception indicates the application has called <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the object, possibly from another thread, and the object is no longer usable for that reason."},{"content":"If present provides details about the inner exception.","pos":[5157,5211]},{"content":"Create a new object.","pos":[5212,5232]},{"content":"Note that depending on what caused the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject&gt;</ph> to abort in the first place, there may be other work required to recover.","pos":[5233,5393],"source":" Note that depending on what caused the <xref:System.ServiceModel.ICommunicationObject> to abort in the first place, there may be other work required to recover."},{"content":"The target remote endpoint is not listening.","pos":[5451,5495]},{"content":"This can result from any part of the endpoint address being incorrect, irresolvable, or the endpoint being down.","pos":[5496,5608]},{"content":"Examples include DNS error, Queue Manager not available, and service not running.","pos":[5609,5690]},{"content":"The inner exception provides details, typically from the underlying transport.","pos":[5691,5769]},{"content":"Try a different address.","pos":[5770,5794]},{"content":"Alternatively, the sender may wait a while and try again in case the service was down","pos":[5795,5880]},{"content":"The communication protocols, as described by the endpoint’s policy, are mismatched between endpoints.","pos":[5930,6031]},{"content":"For example, framing content type mismatch or max message size exceeded.","pos":[6032,6104]},{"content":"If present provides more information about the specific protocol error.","pos":[6105,6176]},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> is the inner exception when the error cause is exceeding MaxReceivedMessageSize.","pos":[6177,6320],"source":" For example, <xref:System.ServiceModel.QuotaExceededException> is the inner exception when the error cause is exceeding MaxReceivedMessageSize."},{"content":"Recovery: Ensure sender and received protocol settings match.","pos":[6321,6382]},{"content":"One way to do this is to re-import the service endpoint’s metadata (policy) and use the generated binding to recreate the channel.","pos":[6383,6513]},{"content":"The remote endpoint is listening but is not prepared to process messages.","pos":[6568,6641]},{"content":"If present, the inner Exception provides the SOAP fault or transport-level error details.","pos":[6642,6731]},{"content":"Recovery: Wait and retry the operation later.","pos":[6732,6777]},{"content":"The operation failed to complete within the timeout period.","pos":[6813,6872]},{"content":"May provide details about the timeout.","pos":[6873,6911]},{"content":"Wait and retry the operation later.","pos":[6912,6947]},{"content":"Define a new exception type only if that type corresponds to a specific recovery strategy different from all of the existing exception types.","pos":[6955,7096]},{"content":"If you do define a new exception type, it must derive from <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph> or one of its derived classes.","pos":[7097,7236],"source":" If you do define a new exception type, it must derive from <xref:System.ServiceModel.CommunicationException> or one of its derived classes."},{"pos":[7246,7264],"content":"Exception Messages","linkify":"Exception Messages","nodes":[{"content":"Exception Messages","pos":[0,18]}]},{"content":"Exception messages are targeted at the user not the program so they should provide sufficient information to help the user understand and solve the problem.","pos":[7268,7424]},{"content":"The three essential parts of a good exception message are:","pos":[7425,7483]},{"content":"What happened.","pos":[7490,7504]},{"content":"Provide a clear description of the problem using terms that relate to the user’s experience.","pos":[7505,7597]},{"content":"For example, a bad exception message would be \"Invalid configuration section\".","pos":[7598,7676]},{"content":"This leaves the user wondering which configuration section is incorrect and why it is incorrect.","pos":[7677,7773]},{"content":"An improved message would be \"Invalid configuration section <ph id=\"ph1\">\\&lt;</ph>customBinding&gt;\".","pos":[7774,7852],"source":" An improved message would be \"Invalid configuration section \\<customBinding>\"."},{"content":"An even better message would be \"Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport\".","pos":[7853,8023]},{"content":"This is a very specific message using terms and names that the user can easily identify in the application’s configuration file.","pos":[8024,8152]},{"content":"However, there are still a few key components missing.","pos":[8153,8207]},{"content":"The significance of the error.","pos":[8214,8244]},{"content":"Unless the message states clearly what the error means, the user is likely to wonder whether it is a fatal error or if it can be ignored.","pos":[8245,8382]},{"content":"In general, messages should lead with the meaning or significance of the error.","pos":[8383,8462]},{"content":"To improve the previous example, the message could be \"ServiceHost failed to Open due to a configuration error: Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport\".","pos":[8463,8712]},{"content":"How the user should correct the problem.","pos":[8719,8759]},{"content":"The most important part of the message is helping the user fix the problem.","pos":[8760,8835]},{"content":"The message should include some guidance or hints about what to check or fix to remedy the problem.","pos":[8836,8935]},{"content":"For example, \"ServiceHost failed to Open due to a configuration error: Cannot add the transport named myTransport to the binding named myBinding because the binding already has a transport named myTransport.","pos":[8936,9143]},{"content":"Please ensure there is only one transport in the binding\".","pos":[9144,9202]},{"pos":[9211,9231],"content":"Communicating Faults","linkify":"Communicating Faults","nodes":[{"content":"Communicating Faults","pos":[0,20]}]},{"content":"SOAP 1.1 and SOAP 1.2 both define a specific structure for faults.","pos":[9235,9301]},{"content":"There are some differences between the two specifications but in general, the Message and MessageFault types are used to create and consume faults.","pos":[9302,9449]},{"content":"<bpt id=\"p1\">![</bpt>Handling exceptions and faults<ept id=\"p1\">](../../../../docs/framework/wcf/extending/media/wcfc-soap1-1andsoap1-2faultcomparisonc.gif \"wcfc_SOAP1-1AndSOAP1-2FaultComparisonc\")</ept>","pos":[9456,9621],"source":"![Handling exceptions and faults](../../../../docs/framework/wcf/extending/media/wcfc-soap1-1andsoap1-2faultcomparisonc.gif \"wcfc_SOAP1-1AndSOAP1-2FaultComparisonc\")"},{"content":"SOAP 1.2 Fault (left) and SOAP 1.1 Fault (right).","pos":[9624,9673]},{"content":"Note that in SOAP 1.1 only the Fault element is namespace qualified.","pos":[9674,9742]},{"content":"SOAP defines a fault message as a message that contains only a fault element (an element whose name is <ph id=\"ph1\">`&lt;env:Fault&gt;`</ph>) as a child of <ph id=\"ph2\">`&lt;env:Body&gt;`</ph>.","pos":[9749,9894],"source":"SOAP defines a fault message as a message that contains only a fault element (an element whose name is `<env:Fault>`) as a child of `<env:Body>`."},{"content":"The contents of the fault element differ slightly between SOAP 1.1 and SOAP 1.2 as shown in figure 1.","pos":[9895,9996]},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageFault?displayProperty=fullName&gt;</ph> class normalizes these differences into one object model:","pos":[9997,10141],"source":" However, the <xref:System.ServiceModel.Channels.MessageFault?displayProperty=fullName> class normalizes these differences into one object model:"},{"content":"The <ph id=\"ph1\">`Code`</ph> property corresponds to the <ph id=\"ph2\">`env:Code`</ph> (or <ph id=\"ph3\">`faultCode`</ph> in SOAP 1.1) and identifies the type of the fault.","pos":[10723,10839],"source":"The `Code` property corresponds to the `env:Code` (or `faultCode` in SOAP 1.1) and identifies the type of the fault."},{"content":"SOAP 1.2 defines five allowable values for <ph id=\"ph1\">`faultCode`</ph> (for example, Sender and Receiver) and defines a <ph id=\"ph2\">`Subcode`</ph> element which can contain any subcode value.","pos":[10840,10998],"source":" SOAP 1.2 defines five allowable values for `faultCode` (for example, Sender and Receiver) and defines a `Subcode` element which can contain any subcode value."},{"content":"(See the <bpt id=\"p1\">[</bpt>SOAP 1.2 specification<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=95176)</ept> for the list of allowable fault codes and their meaning.) SOAP 1.1 has a slightly different mechanism: It defines four <ph id=\"ph1\">`faultCode`</ph> values (for example, Client and Server) that can be extended either by defining entirely new ones or by using the dot notation to create more specific <ph id=\"ph2\">`faultCodes`</ph>, for example, Client.Authentication.","pos":[10999,11410],"source":" (See the [SOAP 1.2 specification](http://go.microsoft.com/fwlink/?LinkId=95176) for the list of allowable fault codes and their meaning.) SOAP 1.1 has a slightly different mechanism: It defines four `faultCode` values (for example, Client and Server) that can be extended either by defining entirely new ones or by using the dot notation to create more specific `faultCodes`, for example, Client.Authentication."},{"content":"When you use MessageFault to program faults, the FaultCode.Name and FaultCode.Namespace maps to the name and namespace of the SOAP 1.2 <ph id=\"ph1\">`env:Code`</ph> or the SOAP 1.1 <ph id=\"ph2\">`faultCode`</ph>.","pos":[11417,11591],"source":"When you use MessageFault to program faults, the FaultCode.Name and FaultCode.Namespace maps to the name and namespace of the SOAP 1.2 `env:Code` or the SOAP 1.1 `faultCode`."},{"content":"The FaultCode.SubCode maps to <ph id=\"ph1\">`env:Subcode`</ph> for SOAP 1.2 and is null for SOAP 1.1.","pos":[11592,11674],"source":" The FaultCode.SubCode maps to `env:Subcode` for SOAP 1.2 and is null for SOAP 1.1."},{"content":"You should create new fault subcodes (or new fault codes if using SOAP 1.1) if it is interesting to programmatically distinguish a fault.","pos":[11681,11818]},{"content":"This is analogous to creating a new exception type.","pos":[11819,11870]},{"content":"You should avoid using the dot notation with SOAP 1.1 fault codes.","pos":[11871,11937]},{"content":"(The <bpt id=\"p1\">[</bpt>WS-I Basic Profile<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=95177)</ept> also discourages the use of the fault code dot notation.)","pos":[11938,12067],"source":" (The [WS-I Basic Profile](http://go.microsoft.com/fwlink/?LinkId=95177) also discourages the use of the fault code dot notation.)"},{"content":"The <ph id=\"ph1\">`Reason`</ph> property corresponds to the <ph id=\"ph2\">`env:Reason`</ph> (or <ph id=\"ph3\">`faultString`</ph> in SOAP 1.1) a human-readable description of the error condition analogous to an exception’s message.","pos":[12603,12776],"source":"The `Reason` property corresponds to the `env:Reason` (or `faultString` in SOAP 1.1) a human-readable description of the error condition analogous to an exception’s message."},{"content":"The <ph id=\"ph1\">`FaultReason`</ph> class (and SOAP <ph id=\"ph2\">`env:Reason/faultString`</ph>) has built-in support for having multiple translations in the interest of globalization.","pos":[12777,12924],"source":" The `FaultReason` class (and SOAP `env:Reason/faultString`) has built-in support for having multiple translations in the interest of globalization."},{"content":"The fault detail contents are exposed on MessageFault using various methods including the <ph id=\"ph1\">`GetDetail`</ph><ph id=\"ph2\">\\&lt;</ph>T&gt; and <ph id=\"ph3\">`GetReaderAtDetailContents`</ph>().","pos":[13258,13398],"source":"The fault detail contents are exposed on MessageFault using various methods including the `GetDetail`\\<T> and `GetReaderAtDetailContents`()."},{"content":"The fault detail is an opaque element for carrying additional detail about the fault.","pos":[13399,13484]},{"content":"This is useful if there is some arbitrary structured detail that you want to carry with the fault.","pos":[13485,13583]},{"pos":[13593,13610],"content":"Generating Faults","linkify":"Generating Faults","nodes":[{"content":"Generating Faults","pos":[0,17]}]},{"content":"This section explains the process of generating a fault in response to an error condition detected in a channel or in a message property created by the channel.","pos":[13614,13774]},{"content":"A typical example is sending back a fault in response to a request message that contains invalid data.","pos":[13775,13877]},{"content":"When generating a fault, the custom channel should not send the fault directly, rather, it should throw an exception and let the layer above decide whether to convert that exception to a fault and how to send it.","pos":[13884,14096]},{"content":"To aid in this conversion, the channel should provide a <ph id=\"ph1\">`FaultConverter`</ph> implementation that can convert the exception thrown by the custom channel to the appropriate fault.","pos":[14097,14270],"source":" To aid in this conversion, the channel should provide a `FaultConverter` implementation that can convert the exception thrown by the custom channel to the appropriate fault."},{"content":"<ph id=\"ph1\">`FaultConverter`</ph> is defined as:","pos":[14271,14302],"source":"`FaultConverter` is defined as:"},{"content":"Each channel that generates custom faults must implement <ph id=\"ph1\">`FaultConverter`</ph> and return it from a call to <ph id=\"ph2\">`GetProperty&lt;FaultConverter&gt;`</ph>.","pos":[14817,14950],"source":"Each channel that generates custom faults must implement `FaultConverter` and return it from a call to `GetProperty<FaultConverter>`."},{"content":"The custom <ph id=\"ph1\">`OnTryCreateFaultMessage`</ph> implementation must either convert the exception to a fault or delegate to the inner channel’s <ph id=\"ph2\">`FaultConverter`</ph>.","pos":[14951,15100],"source":" The custom `OnTryCreateFaultMessage` implementation must either convert the exception to a fault or delegate to the inner channel’s `FaultConverter`."},{"content":"If the channel is a transport it must either convert the exception or delegate to the encoder’s <ph id=\"ph1\">`FaultConverter`</ph> or the default <ph id=\"ph2\">`FaultConverter`</ph> provided in <ph id=\"ph3\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> .","pos":[15101,15315],"source":" If the channel is a transport it must either convert the exception or delegate to the encoder’s `FaultConverter` or the default `FaultConverter` provided in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] ."},{"content":"The default <ph id=\"ph1\">`FaultConverter`</ph> converts errors corresponding to fault messages specified by WS-Addressing and SOAP.","pos":[15316,15429],"source":" The default `FaultConverter` converts errors corresponding to fault messages specified by WS-Addressing and SOAP."},{"content":"Here is an example <ph id=\"ph1\">`OnTryCreateFaultMessage`</ph> implementation.","pos":[15430,15490],"source":" Here is an example `OnTryCreateFaultMessage` implementation."},{"content":"An implication of this pattern is that exceptions thrown between layers for error conditions that require faults must contain enough information for the corresponding fault generator to create the correct fault.","pos":[16659,16870]},{"content":"As a custom channel author, you may define exception types that correspond to different fault conditions if such exceptions do not already exist.","pos":[16871,17016]},{"content":"Note that exceptions traversing channel layers should communicate the error condition rather than opaque fault data.","pos":[17017,17133]},{"pos":[17143,17159],"content":"Fault Categories","linkify":"Fault Categories","nodes":[{"content":"Fault Categories","pos":[0,16]}]},{"content":"There are generally three categories of faults:","pos":[17163,17210]},{"content":"Faults that are pervasive throughout the entire stack.","pos":[17220,17274]},{"content":"These faults could be encountered at any layer in the channel stack, for example InvalidCardinalityAddressingException.","pos":[17275,17394]},{"content":"Faults that can be encountered anywhere above a certain layer in the stack for example some errors that pertain to a flowed transaction or to security roles.","pos":[17404,17561]},{"content":"Faults that are directed at a single layer in the stack, for example errors like WS-RM sequence number faults.","pos":[17571,17681]},{"content":"Category 1.","pos":[17688,17699]},{"content":"Faults are generally WS-Addressing and SOAP faults.","pos":[17700,17751]},{"content":"The base <ph id=\"ph1\">`FaultConverter`</ph> class provided by <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> converts errors corresponding to fault messages specified by WS-Addressing and SOAP so you do not have to handle conversion of these exceptions yourself.","pos":[17752,18005],"source":" The base `FaultConverter` class provided by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] converts errors corresponding to fault messages specified by WS-Addressing and SOAP so you do not have to handle conversion of these exceptions yourself."},{"content":"Category 2.","pos":[18012,18023]},{"content":"Faults occur when a layer adds a property to the message that does not completely consume message information that pertains to that layer.","pos":[18024,18162]},{"content":"Errors may be detected later when a higher layer asks the message property to process message information further.","pos":[18163,18277]},{"content":"Such channels should implement the <ph id=\"ph1\">`GetProperty`</ph> specified previously to enable the higher layer to send back the correct fault.","pos":[18278,18406],"source":" Such channels should implement the `GetProperty` specified previously to enable the higher layer to send back the correct fault."},{"content":"An example of this is the TransactionMessageProperty.","pos":[18407,18460]},{"content":"This property is added to the message without fully validating all the data in the header (doing so may involve contacting the distributed transaction coordinator (DTC).","pos":[18461,18630]},{"content":"Category 3.","pos":[18637,18648]},{"content":"Faults are only generated and sent by a single layer in the processor.","pos":[18649,18719]},{"content":"Therefore all the exceptions are contained within the layer.","pos":[18720,18780]},{"content":"To improve consistency among channels and ease maintenance, your custom channel should use the pattern specified previously to generate fault messages even for internal faults.","pos":[18781,18957]},{"pos":[18967,18995],"content":"Interpreting Received Faults","linkify":"Interpreting Received Faults","nodes":[{"content":"Interpreting Received Faults","pos":[0,28]}]},{"content":"This section provides guidance for generating the appropriate exception when receiving a fault message.","pos":[18999,19102]},{"content":"The decision tree for processing a message at every layer in the stack is as follows:","pos":[19103,19188]},{"content":"If the layer considers the message to be invalid, the layer should do its ‘invalid message’ processing.","pos":[19198,19301]},{"content":"Such processing is specific to the layer but could include dropping the message, tracing, or throwing an exception that gets converted to a fault.","pos":[19302,19448]},{"content":"Examples include security receiving a message that is not secured properly, or RM receiving a message with a bad sequence number.","pos":[19449,19578]},{"content":"Otherwise, if the message is a fault message that applies specifically to the layer, and the message is not meaningful outside the layer’s interaction, the layer should handle the error condition.","pos":[19588,19784]},{"content":"An example of this is an RM Sequence Refused fault that is meaningless to layers above the RM channel and that implies faulting the RM channel and throwing from pending operations.","pos":[19785,19965]},{"content":"Otherwise, the message should be returned from Request() or Receive().","pos":[19975,20045]},{"content":"This includes cases where the layer recognizes the fault, but the fault just indicates that a request failed and does not imply faulting the channel and throwing from pending operations.","pos":[20046,20232]},{"content":"To improve usability in such a case, the layer should implement <ph id=\"ph1\">`GetProperty&lt;FaultConverter&gt;`</ph> and return a <ph id=\"ph2\">`FaultConverter`</ph> derived class that can convert the fault to an exception by overriding <ph id=\"ph3\">`OnTryCreateException`</ph>.","pos":[20233,20451],"source":" To improve usability in such a case, the layer should implement `GetProperty<FaultConverter>` and return a `FaultConverter` derived class that can convert the fault to an exception by overriding `OnTryCreateException`."},{"content":"The following object model supports converting messages to exceptions:","pos":[20458,20528]},{"content":"A channel layer can implement <ph id=\"ph1\">`GetProperty&lt;FaultConverter&gt;`</ph> to support converting fault messages to exceptions.","pos":[21140,21251],"source":"A channel layer can implement `GetProperty<FaultConverter>` to support converting fault messages to exceptions."},{"content":"To do so, override <ph id=\"ph1\">`OnTryCreateException`</ph> and inspect the fault message.","pos":[21252,21324],"source":" To do so, override `OnTryCreateException` and inspect the fault message."},{"content":"If recognized, do the conversion, otherwise ask the inner channel to convert it.","pos":[21325,21405]},{"content":"Transport channels should delegate to <ph id=\"ph1\">`FaultConverter.GetDefaultFaultConverter`</ph> to get the default SOAP/WS-Addressing FaultConverter.","pos":[21406,21539],"source":" Transport channels should delegate to `FaultConverter.GetDefaultFaultConverter` to get the default SOAP/WS-Addressing FaultConverter."},{"content":"A typical implementation looks like this:","pos":[21546,21587]},{"pos":[23242,23368],"content":"For specific fault conditions that have distinct recovery scenarios, consider defining a derived class of <ph id=\"ph1\">`ProtocolException`</ph>.","source":"For specific fault conditions that have distinct recovery scenarios, consider defining a derived class of `ProtocolException`."},{"pos":[23378,23403],"content":"MustUnderstand Processing","linkify":"MustUnderstand Processing","nodes":[{"content":"MustUnderstand Processing","pos":[0,25]}]},{"content":"SOAP defines a general fault for signaling that a required header was not understood by the receiver.","pos":[23407,23508]},{"content":"This fault is known as the <ph id=\"ph1\">`mustUnderstand`</ph> fault.","pos":[23509,23559],"source":" This fault is known as the `mustUnderstand` fault."},{"content":"In <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, custom channels never generate <ph id=\"ph2\">`mustUnderstand`</ph> faults.","pos":[23560,23675],"source":" In [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], custom channels never generate `mustUnderstand` faults."},{"content":"Instead, the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> Dispatcher, which is located at the top of the <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> communication stack, checks to see that all headers that were marked as MustUndestand=true were understood by the underlying stack.","pos":[23676,23979],"source":" Instead, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] Dispatcher, which is located at the top of the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] communication stack, checks to see that all headers that were marked as MustUndestand=true were understood by the underlying stack."},{"content":"If any were not understood, a <ph id=\"ph1\">`mustUnderstand`</ph> fault is generated at that point.","pos":[23980,24060],"source":" If any were not understood, a `mustUnderstand` fault is generated at that point."},{"content":"(The user can choose to turn off this <ph id=\"ph1\">`mustUnderstand`</ph> processing and have the application receive all message headers.","pos":[24061,24180],"source":" (The user can choose to turn off this `mustUnderstand` processing and have the application receive all message headers."},{"content":"In that case the application is responsible for performing <ph id=\"ph1\">`mustUnderstand`</ph> processing.) The generated fault includes a NotUnderstood header that contains the names of all headers with MustUnderstand=true that were not understood.","pos":[24181,24411],"source":" In that case the application is responsible for performing `mustUnderstand` processing.) The generated fault includes a NotUnderstood header that contains the names of all headers with MustUnderstand=true that were not understood."},{"content":"If your protocol channel sends a custom header with MustUnderstand=true and receives a <ph id=\"ph1\">`mustUnderstand`</ph> fault, it must figure out whether that fault is due to the header it sent.","pos":[24418,24596],"source":"If your protocol channel sends a custom header with MustUnderstand=true and receives a `mustUnderstand` fault, it must figure out whether that fault is due to the header it sent."},{"content":"There are two members on the <ph id=\"ph1\">`MessageFault`</ph> class that are useful for this:","pos":[24597,24672],"source":" There are two members on the `MessageFault` class that are useful for this:"},{"content":"<ph id=\"ph1\">`IsMustUnderstandFault`</ph> returns <ph id=\"ph2\">`true`</ph> if the fault is a <ph id=\"ph3\">`mustUnderstand`</ph> fault.","pos":[24913,24993],"source":"`IsMustUnderstandFault` returns `true` if the fault is a `mustUnderstand` fault."},{"content":"<ph id=\"ph1\">`WasHeaderNotUnderstood`</ph> returns <ph id=\"ph2\">`true`</ph> if the header with the specified name and namespace is included in the fault as a NotUnderstood header.","pos":[24994,25137],"source":"`WasHeaderNotUnderstood` returns `true` if the header with the specified name and namespace is included in the fault as a NotUnderstood header."},{"content":"Otherwise, it returns <ph id=\"ph1\">`false`</ph>.","pos":[25139,25169],"source":"  Otherwise, it returns `false`."},{"pos":[25176,25433],"content":"If a channel emits a header that is marked MustUnderstand = true, then that layer should also implement the Exception Generation API pattern and should convert <ph id=\"ph1\">`mustUnderstand`</ph> faults caused by that header to a more useful exception as described previously.","source":"If a channel emits a header that is marked MustUnderstand = true, then that layer should also implement the Exception Generation API pattern and should convert `mustUnderstand` faults caused by that header to a more useful exception as described previously."},{"pos":[25442,25449],"content":"Tracing","linkify":"Tracing","nodes":[{"content":"Tracing","pos":[0,7]}]},{"content":"The .NET Framework provides a mechanism to trace program execution as a way to aid diagnosing production applications or intermittent problems where it is not possible to just attach a debugger and step through the code.","pos":[25453,25673]},{"content":"The core components of this mechanism are in the <ph id=\"ph1\">&lt;xref:System.Diagnostics?displayProperty=fullName&gt;</ph> namespace and consist of:","pos":[25674,25799],"source":" The core components of this mechanism are in the <xref:System.Diagnostics?displayProperty=fullName> namespace and consist of:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceSource?displayProperty=fullName&gt;</ph>, which is the source of trace information to be written, <ph id=\"ph2\">&lt;xref:System.Diagnostics.TraceListener?displayProperty=fullName&gt;</ph>, which is an abstract base class for concrete listeners that receive the information to be traced from the <ph id=\"ph3\">&lt;xref:System.Diagnostics.TraceSource&gt;</ph> and output it to a listener-specific destination.","pos":[25809,26188],"source":"<xref:System.Diagnostics.TraceSource?displayProperty=fullName>, which is the source of trace information to be written, <xref:System.Diagnostics.TraceListener?displayProperty=fullName>, which is an abstract base class for concrete listeners that receive the information to be traced from the <xref:System.Diagnostics.TraceSource> and output it to a listener-specific destination."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Diagnostics.XmlWriterTraceListener&gt;</ph> outputs trace information to an XML file.","pos":[26189,26292],"source":" For example, <xref:System.Diagnostics.XmlWriterTraceListener> outputs trace information to an XML file."},{"content":"Finally, <ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceSwitch?displayProperty=fullName&gt;</ph>, which lets the application user control the tracing verbosity and is typically specified in configuration.","pos":[26293,26472],"source":" Finally, <xref:System.Diagnostics.TraceSwitch?displayProperty=fullName>, which lets the application user control the tracing verbosity and is typically specified in configuration."},{"content":"In addition to the core components, you can use the <bpt id=\"p1\">[</bpt>Service Trace Viewer Tool (SvcTraceViewer.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md)</ept> to view and search <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> traces.","pos":[26482,26745],"source":"In addition to the core components, you can use the [Service Trace Viewer Tool (SvcTraceViewer.exe)](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md) to view and search [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] traces."},{"content":"The tool is designed specifically for trace files generated by <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> and written out using <ph id=\"ph2\">&lt;xref:System.Diagnostics.XmlWriterTraceListener&gt;</ph>.","pos":[26746,26936],"source":" The tool is designed specifically for trace files generated by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and written out using <xref:System.Diagnostics.XmlWriterTraceListener>."},{"content":"The following figure shows the various components involved in tracing.","pos":[26937,27007]},{"pos":[27014,27149],"content":"<bpt id=\"p1\">![</bpt>Handling exceptions and faults<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/extending/media/wcfc-tracinginchannelsc.gif \"</bpt>wcfc_TracingInChannelsc<ept id=\"p2\">\")</ept>","source":"![Handling exceptions and faults](../../../../docs/framework/wcf/extending/media/wcfc-tracinginchannelsc.gif \"wcfc_TracingInChannelsc\")"},{"pos":[27159,27188],"content":"Tracing from a Custom Channel","linkify":"Tracing from a Custom Channel","nodes":[{"content":"Tracing from a Custom Channel","pos":[0,29]}]},{"content":"Custom channels should write out trace messages to assist in diagnosing problems when it is not possible to attach a debugger to the running application.","pos":[27192,27345]},{"content":"This involves two high level tasks: Instantiating a <ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceSource&gt;</ph> and calling its methods to write traces.","pos":[27346,27476],"source":" This involves two high level tasks: Instantiating a <xref:System.Diagnostics.TraceSource> and calling its methods to write traces."},{"content":"When instantiating a <ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceSource&gt;</ph>, the string you specify becomes the name of that source.","pos":[27483,27598],"source":"When instantiating a <xref:System.Diagnostics.TraceSource>, the string you specify becomes the name of that source."},{"content":"This name is used to configure (enable/disable/set tracing level) the trace source.","pos":[27599,27682]},{"content":"It also appears in the trace output itself.","pos":[27683,27726]},{"content":"Custom channels should use a unique source name to help readers of the trace output understand where the trace information comes from.","pos":[27727,27861]},{"content":"Using the name of the assembly that is writing the information as the name of the trace source is the common practice.","pos":[27862,27980]},{"content":"For example, <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> uses System.ServiceModel as the trace source for information written from the System.ServiceModel assembly.","pos":[27981,28157],"source":" For example, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses System.ServiceModel as the trace source for information written from the System.ServiceModel assembly."},{"content":"Once you have a trace source, you call its <ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceSource.TraceData%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Diagnostics.TraceSource.TraceEvent%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Diagnostics.TraceSource.TraceInformation%2A&gt;</ph> methods to write trace entries to the trace listeners.","pos":[28164,28427],"source":"Once you have a trace source, you call its <xref:System.Diagnostics.TraceSource.TraceData%2A>, <xref:System.Diagnostics.TraceSource.TraceEvent%2A>, or <xref:System.Diagnostics.TraceSource.TraceInformation%2A> methods to write trace entries to the trace listeners."},{"content":"For each trace entry you write, you need to classify the type of event as one of the event types defined in <ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceEventType&gt;</ph>.","pos":[28428,28577],"source":" For each trace entry you write, you need to classify the type of event as one of the event types defined in <xref:System.Diagnostics.TraceEventType>."},{"content":"This classification and the trace level setting in configuration determine whether the trace entry is output to the listener.","pos":[28578,28703]},{"content":"For example, setting the trace level in configuration to <ph id=\"ph1\">`Warning`</ph> allows <ph id=\"ph2\">`Warning`</ph>, <ph id=\"ph3\">`Error`</ph> and <ph id=\"ph4\">`Critical`</ph> trace entries to be written but blocks Information and Verbose entries.","pos":[28704,28883],"source":" For example, setting the trace level in configuration to `Warning` allows `Warning`, `Error` and `Critical` trace entries to be written but blocks Information and Verbose entries."},{"content":"Here is an example of instantiating a trace source and writing out an entry at Information level:","pos":[28884,28981]},{"pos":[29182,29365],"content":"[!IMPORTANT]\n It is highly recommended that you specify a trace source name that is unique to your custom channel to help trace output readers understand where the output came from.","leadings":["","> "],"nodes":[{"content":"It is highly recommended that you specify a trace source name that is unique to your custom channel to help trace output readers understand where the output came from.","pos":[14,181]}]},{"pos":[29376,29409],"content":"Integrating with the Trace Viewer","linkify":"Integrating with the Trace Viewer","nodes":[{"content":"Integrating with the Trace Viewer","pos":[0,33]}]},{"content":"Traces generated by your channel can be output in a format readable by the <bpt id=\"p1\">[</bpt>Service Trace Viewer Tool (SvcTraceViewer.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md)</ept> by using <ph id=\"ph1\">&lt;xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=fullName&gt;</ph> as the trace listener.","pos":[29413,29722],"source":"Traces generated by your channel can be output in a format readable by the [Service Trace Viewer Tool (SvcTraceViewer.exe)](../../../../docs/framework/wcf/service-trace-viewer-tool-svctraceviewer-exe.md) by using <xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=fullName> as the trace listener."},{"content":"This is not something you, as the channel developer, need to do.","pos":[29723,29787]},{"content":"Rather, it is the application user (or the person troubleshooting the application) that needs to configure this trace listener in the application’s configuration file.","pos":[29788,29955]},{"content":"For example, the following configuration outputs trace information from both <ph id=\"ph1\">&lt;xref:System.ServiceModel?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">`Microsoft.Samples.Udp`</ph> to the file named <ph id=\"ph3\">`TraceEventsFile.e2e`</ph>:","pos":[29956,30153],"source":" For example, the following configuration outputs trace information from both <xref:System.ServiceModel?displayProperty=fullName> and `Microsoft.Samples.Udp` to the file named `TraceEventsFile.e2e`:"},{"pos":[31108,31131],"content":"Tracing Structured Data","linkify":"Tracing Structured Data","nodes":[{"content":"Tracing Structured Data","pos":[0,23]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Diagnostics.TraceSource?displayProperty=fullName&gt;</ph> has a <ph id=\"ph2\">&lt;xref:System.Diagnostics.TraceSource.TraceData%2A&gt;</ph> method that takes one or more objects that are to be included in the trace entry.","pos":[31135,31336],"source":"<xref:System.Diagnostics.TraceSource?displayProperty=fullName> has a <xref:System.Diagnostics.TraceSource.TraceData%2A> method that takes one or more objects that are to be included in the trace entry."},{"content":"In general, the <ph id=\"ph1\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method is called on each object and the resulting string is written as part of the trace entry.","pos":[31337,31506],"source":" In general, the <xref:System.Object.ToString%2A?displayProperty=fullName> method is called on each object and the resulting string is written as part of the trace entry."},{"content":"When using <ph id=\"ph1\">&lt;xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=fullName&gt;</ph> to output traces, you can pass an <ph id=\"ph2\">&lt;xref:System.Xml.XPath.IXPathNavigable?displayProperty=fullName&gt;</ph> as the data object to <ph id=\"ph3\">&lt;xref:System.Diagnostics.TraceSource.TraceData%2A&gt;</ph>.","pos":[31507,31764],"source":" When using <xref:System.Diagnostics.XmlWriterTraceListener?displayProperty=fullName> to output traces, you can pass an <xref:System.Xml.XPath.IXPathNavigable?displayProperty=fullName> as the data object to <xref:System.Diagnostics.TraceSource.TraceData%2A>."},{"content":"The resulting trace entry includes the XML provided by the <ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNavigator?displayProperty=fullName&gt;</ph>.","pos":[31765,31888],"source":" The resulting trace entry includes the XML provided by the <xref:System.Xml.XPath.XPathNavigator?displayProperty=fullName>."},{"content":"Here is an example entry with XML application data:","pos":[31889,31940]},{"content":"The <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> trace viewer understands the schema of the <ph id=\"ph2\">`TraceRecord`</ph> element shown previously and extracts the data from its child elements and displays it in a tabular format.","pos":[33013,33237],"source":"The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] trace viewer understands the schema of the `TraceRecord` element shown previously and extracts the data from its child elements and displays it in a tabular format."},{"content":"Your channel should use this schema when tracing structured application data to help Svctraceviewer.exe users read the data.","pos":[33238,33362]}]}