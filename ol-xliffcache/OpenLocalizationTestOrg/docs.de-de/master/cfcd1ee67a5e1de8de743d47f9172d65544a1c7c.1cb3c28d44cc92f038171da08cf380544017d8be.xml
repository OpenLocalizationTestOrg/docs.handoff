{"content":"---\ntitle: \"FROM (Entity SQL) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-ado\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\nms.assetid: ff3e3048-0d5d-4502-ae5c-9187fcbd0514\ncaps.latest.revision: 3\nauthor: \"JennieHubbard\"\nms.author: \"jhubbard\"\nmanager: \"jhubbard\"\n---\n# FROM (Entity SQL)\nSpecifies the collection used in [SELECT](../../../../../../docs/framework/data/adonet/ef/language-reference/select-entity-sql.md) statements.  \n  \n## Syntax  \n  \n```  \n  \nFROM expression [ ,...n ] as C  \n```  \n  \n## Arguments  \n `expression`  \n Any valid query expression that yields a collection to use as a source in a `SELECT` statement.  \n  \n## Remarks  \n A `FROM` clause is a comma-separated list of one or more `FROM` clause items. The `FROM` clause can be used to specify one or more sources for a `SELECT` statement. The simplest form of a `FROM` clause is a single query expression that identifies a collection and an alias used as the source in a `SELECT` statement, as illustrated in the following example:  \n  \n `FROM C as c`  \n  \n## FROM Clause Items  \n Each `FROM` clause item refers to a source collection in the [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query. [!INCLUDE[esql](../../../../../../includes/esql-md.md)] supports the following classes of `FROM` clause items: simple `FROM` clause items, `JOIN FROM` clause items, and `APPLY FROM` clause items. Each of these `FROM` clause items is described in more detail in the following sections.  \n  \n### Simple FROM Clause Item  \n The simplest `FROM` clause item is a single expression that identifies a collection and an alias. The expression can simply be an entity set, or a subquery, or any other expression that is a collection type. The following is an example:  \n  \n```  \nLOB.Customers as c  \n```  \n  \n The alias specification is optional. An alternate specification of the above from clause item could be the following:  \n  \n```  \nLOB.Customers  \n```  \n  \n If no alias is specified, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] attempts to generate an alias based on the collection expression.  \n  \n### JOIN FROM Clause Item  \n A `JOIN FROM` clause item represents a join between two `FROM` clause items. [!INCLUDE[esql](../../../../../../includes/esql-md.md)] supports cross joins, inner joins, left and right outer joins, and full outer joins. All these joins are supported similar to the way that they are supported in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]. As in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], the two `FROM` clause items involved in the `JOIN` must be independent. That is, they cannot be correlated. A `CROSS APPLY` or `OUTER APPLY` can be used for these cases.  \n  \n#### Cross Joins  \n A `CROSS JOIN` query expression produces the Cartesian product of the two collections, as illustrated in the following example:  \n  \n `FROM C AS c CROSS JOIN D as d`  \n  \n#### Inner Joins  \n An `INNER JOIN` produces a constrained Cartesian product of the two collections, as illustrated in the following example:  \n  \n `FROM C AS c [INNER] JOIN D AS d ON e`  \n  \n The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the `ON` condition is true. If no `ON` condition is specified, an `INNER JOIN` degenerates to a `CROSS JOIN`.  \n  \n#### Left Outer Joins and Right Outer Joins  \n An `OUTER JOIN` query expression produces a constrained Cartesian product of the two collections, as illustrated in the following example:  \n  \n `FROM C AS c LEFT OUTER JOIN D AS d ON e`  \n  \n The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the `ON` condition is true. If the `ON` condition is false, the expression still processes a single instance of the element on the left paired against the element on the right, with the value null.  \n  \n A `RIGHT OUTER JOIN` may be expressed in a similar manner.  \n  \n#### Full Outer Joins  \n An explicit `FULL OUTER JOIN` produces a constrained Cartesian product of the two collections as illustrated in the following example:  \n  \n `FROM C AS c FULL OUTER JOIN D AS d ON e`  \n  \n The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the `ON` condition is true. If the `ON` condition is false, the expression still processes one instance of the element on the left paired against the element on the right, with the value null. It also processes one instance of the element on the right paired against the element on the left, with the value null.  \n  \n> [!NOTE]\n>  To preserve compatibility with SQL-92, in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)] the OUTER keyword is optional. Therefore, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN` are synonyms for `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, and `FULL OUTER JOIN`.  \n  \n### APPLY Clause Item  \n [!INCLUDE[esql](../../../../../../includes/esql-md.md)] supports two kinds of `APPLY`: `CROSS APPLY` and `OUTER APPLY`.  \n  \n A `CROSS APPLY` produces a unique pairing of each element of the collection on the left with an element of the collection produced by evaluating the expression on the right. With a `CROSS APPLY`, the expression on the right is functionally dependent on the element on the left, as illustrated in the following associated collection example:  \n  \n `SELECT c, f FROM C AS c CROSS APPLY c.Assoc AS f`  \n  \n The behavior of `CROSS APPLY` is similar to the join list. If the expression on the right evaluates to an empty collection, the `CROSS APPLY` produces no pairings for that instance of the element on the left.  \n  \n An `OUTER APPLY` resembles a `CROSS APPLY`, except a pairing is still produced even when the expression on the right evaluates to an empty collection. The following is an example of an `OUTER APPLY`:  \n  \n `SELECT c, f FROM C AS c OUTER APPLY c.Assoc AS f`  \n  \n> [!NOTE]\n>  Unlike in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], there is no need for an explicit unnest step in [!INCLUDE[esql](../../../../../../includes/esql-md.md)].  \n  \n> [!NOTE]\n>  `CROSS` and `OUTER APPLY` operators were introduced in [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]. In some cases, the query pipeline might produce Transact-SQL that contains `CROSS APPLY` and/or `OUTER APPLY` operators. Because some backend providers, including versions of [!INCLUDE[ssNoVersion](../../../../../../includes/ssnoversion-md.md)] earlier than [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)], do not support these operators, such queries cannot be executed on these backend providers.  \n>   \n>  Some typical scenarios that might lead to the presence of `CROSS APPLY` and/or `OUTER APPLY` operators in the output query are the following: a correlated subquery with paging; AnyElement over a correlated subquery or over a collection produced by navigation; LINQ queries that use grouping methods that accept an element selector; a query in which a `CROSS APPLY` or an `OUTER APPLY` are explicitly specified; a query that has a `DEREF` construct over a `REF` construct.  \n  \n## Multiple Collections in the FROM Clause  \n The `FROM` clause can contain more than one collection separated by commas. In these cases, the collections are assumed to be joined together. Think of these as an n-way CROSS JOIN.  \n  \n In the following example, `C` and `D` are independent collections, but `c.Names` is dependent on `C`.  \n  \n```  \nFROM C AS c, D AS d, c.Names AS e  \n```  \n  \n The previous example is logically equivalent to the following example:  \n  \n `FROM (C AS c JOIN D AS d) CROSS APPLY c.Names AS e`  \n  \n## Left Correlation  \n Items in the `FROM` clause can refer to items specified in earlier clauses. In the following example, `C` and `D` are independent collections, but `c.Names` is dependent on `C`:  \n  \n```  \nfrom C as c, D as d, c.Names as e  \n```  \n  \n This is logically equivalent to:  \n  \n```  \nfrom (C as c join D as d) cross apply c.Names as e  \n```  \n  \n## Semantics  \n Logically, the collections in the `FROM` clause are assumed to be part of an `n`-way cross join (except in the case of a 1-way cross join). Aliases in the `FROM` clause are processed left to right, and are added to the current scope for later reference. The `FROM` clause is assumed to produce a multiset of rows. There will be one field for each item in the `FROM` clause that represents a single element from that collection item.  \n  \n The `FROM` clause logically produces a multiset of rows of type Row(c, d, e) where fields c, d, and e are assumed to be of the element type of `C`, `D`, and `c.Names`.  \n  \n [!INCLUDE[esql](../../../../../../includes/esql-md.md)] introduces an alias for each simple `FROM` clause item in scope. For example, in the following FROM clause snippet, The names introduced into scope are c, d, and e.  \n  \n```  \nfrom (C as c join D as d) cross apply c.Names as e  \n```  \n  \n In [!INCLUDE[esql](../../../../../../includes/esql-md.md)] (unlike [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]), the `FROM` clause only introduces the aliases into scope. Any references to columns (properties) of these collections must be qualified with the alias.  \n  \n## Pulling Up Keys from Nested Queries  \n Certain types of queries that require pulling up keys from a nested query are not supported. For example, the following query is valid:  \n  \n```  \nselect c.Orders from Customers as c   \n```  \n  \n However, the following query is not valid, because the nested query does not have any keys:  \n  \n```  \nselect {1} from {2, 3}  \n```  \n  \n## See Also  \n [Entity SQL Reference](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-reference.md)   \n [Query Expressions](../../../../../../docs/framework/data/adonet/ef/language-reference/query-expressions-entity-sql.md)   \n [Nullable Structured Types](../../../../../../docs/framework/data/adonet/ef/language-reference/nullable-structured-types-entity-sql.md)","nodes":[{"pos":[4,392],"embed":true,"restype":"x-metadata","content":"title: \"FROM (Entity SQL) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-ado\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\nms.assetid: ff3e3048-0d5d-4502-ae5c-9187fcbd0514\ncaps.latest.revision: 3\nauthor: \"JennieHubbard\"\nms.author: \"jhubbard\"\nmanager: \"jhubbard\"","nodes":[{"content":"FROM (Entity SQL) | Microsoft Docs","nodes":[{"pos":[0,34],"content":"FROM (Entity SQL) | Microsoft Docs","nodes":[{"content":"FROM (Entity SQL) | Microsoft Docs","pos":[0,34]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[399,416],"content":"FROM (Entity SQL)","linkify":"FROM (Entity SQL)","nodes":[{"content":"FROM (Entity SQL)","pos":[0,17]}]},{"pos":[417,559],"content":"Specifies the collection used in <bpt id=\"p1\">[</bpt>SELECT<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/ef/language-reference/select-entity-sql.md)</ept> statements.","source":"Specifies the collection used in [SELECT](../../../../../../docs/framework/data/adonet/ef/language-reference/select-entity-sql.md) statements."},{"pos":[568,574],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[634,643],"content":"Arguments","linkify":"Arguments","nodes":[{"content":"Arguments","pos":[0,9]}]},{"content":"Any valid query expression that yields a collection to use as a source in a <ph id=\"ph1\">`SELECT`</ph> statement.","pos":[663,758],"source":"Any valid query expression that yields a collection to use as a source in a `SELECT` statement."},{"pos":[767,774],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"A <ph id=\"ph1\">`FROM`</ph> clause is a comma-separated list of one or more <ph id=\"ph2\">`FROM`</ph> clause items.","pos":[778,855],"source":"A `FROM` clause is a comma-separated list of one or more `FROM` clause items."},{"content":"The <ph id=\"ph1\">`FROM`</ph> clause can be used to specify one or more sources for a <ph id=\"ph2\">`SELECT`</ph> statement.","pos":[856,942],"source":" The `FROM` clause can be used to specify one or more sources for a `SELECT` statement."},{"content":"The simplest form of a <ph id=\"ph1\">`FROM`</ph> clause is a single query expression that identifies a collection and an alias used as the source in a <ph id=\"ph2\">`SELECT`</ph> statement, as illustrated in the following example:","pos":[943,1135],"source":" The simplest form of a `FROM` clause is a single query expression that identifies a collection and an alias used as the source in a `SELECT` statement, as illustrated in the following example:"},{"pos":[1164,1181],"content":"FROM Clause Items","linkify":"FROM Clause Items","nodes":[{"content":"FROM Clause Items","pos":[0,17]}]},{"content":"Each <ph id=\"ph1\">`FROM`</ph> clause item refers to a source collection in the <ph id=\"ph2\">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> query.","pos":[1185,1308],"source":"Each `FROM` clause item refers to a source collection in the [!INCLUDE[esql](../../../../../../includes/esql-md.md)] query."},{"content":"<ph id=\"ph1\">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports the following classes of <ph id=\"ph2\">`FROM`</ph> clause items: simple <ph id=\"ph3\">`FROM`</ph> clause items, <ph id=\"ph4\">`JOIN FROM`</ph> clause items, and <ph id=\"ph5\">`APPLY FROM`</ph> clause items.","pos":[1309,1504],"source":"[!INCLUDE[esql](../../../../../../includes/esql-md.md)] supports the following classes of `FROM` clause items: simple `FROM` clause items, `JOIN FROM` clause items, and `APPLY FROM` clause items."},{"content":"Each of these <ph id=\"ph1\">`FROM`</ph> clause items is described in more detail in the following sections.","pos":[1505,1593],"source":" Each of these `FROM` clause items is described in more detail in the following sections."},{"pos":[1603,1626],"content":"Simple FROM Clause Item","linkify":"Simple FROM Clause Item","nodes":[{"content":"Simple FROM Clause Item","pos":[0,23]}]},{"content":"The simplest <ph id=\"ph1\">`FROM`</ph> clause item is a single expression that identifies a collection and an alias.","pos":[1630,1727],"source":"The simplest `FROM` clause item is a single expression that identifies a collection and an alias."},{"content":"The expression can simply be an entity set, or a subquery, or any other expression that is a collection type.","pos":[1728,1837]},{"content":"The following is an example:","pos":[1838,1866]},{"content":"The alias specification is optional.","pos":[1909,1945]},{"content":"An alternate specification of the above from clause item could be the following:","pos":[1946,2026]},{"pos":[2064,2211],"content":"If no alias is specified, <ph id=\"ph1\">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> attempts to generate an alias based on the collection expression.","source":"If no alias is specified, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] attempts to generate an alias based on the collection expression."},{"pos":[2221,2242],"content":"JOIN FROM Clause Item","linkify":"JOIN FROM Clause Item","nodes":[{"content":"JOIN FROM Clause Item","pos":[0,21]}]},{"content":"A <ph id=\"ph1\">`JOIN FROM`</ph> clause item represents a join between two <ph id=\"ph2\">`FROM`</ph> clause items.","pos":[2246,2322],"source":"A `JOIN FROM` clause item represents a join between two `FROM` clause items."},{"content":"<ph id=\"ph1\">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> supports cross joins, inner joins, left and right outer joins, and full outer joins.","pos":[2323,2463],"source":"[!INCLUDE[esql](../../../../../../includes/esql-md.md)] supports cross joins, inner joins, left and right outer joins, and full outer joins."},{"content":"All these joins are supported similar to the way that they are supported in <ph id=\"ph1\">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>.","pos":[2464,2596],"source":" All these joins are supported similar to the way that they are supported in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]."},{"content":"As in <ph id=\"ph1\">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, the two <ph id=\"ph2\">`FROM`</ph> clause items involved in the <ph id=\"ph3\">`JOIN`</ph> must be independent.","pos":[2597,2731],"source":" As in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], the two `FROM` clause items involved in the `JOIN` must be independent."},{"content":"That is, they cannot be correlated.","pos":[2732,2767]},{"content":"A <ph id=\"ph1\">`CROSS APPLY`</ph> or <ph id=\"ph2\">`OUTER APPLY`</ph> can be used for these cases.","pos":[2768,2829],"source":" A `CROSS APPLY` or `OUTER APPLY` can be used for these cases."},{"pos":[2840,2851],"content":"Cross Joins","linkify":"Cross Joins","nodes":[{"content":"Cross Joins","pos":[0,11]}]},{"pos":[2855,2982],"content":"A <ph id=\"ph1\">`CROSS JOIN`</ph> query expression produces the Cartesian product of the two collections, as illustrated in the following example:","source":"A `CROSS JOIN` query expression produces the Cartesian product of the two collections, as illustrated in the following example:"},{"pos":[3031,3042],"content":"Inner Joins","linkify":"Inner Joins","nodes":[{"content":"Inner Joins","pos":[0,11]}]},{"pos":[3046,3167],"content":"An <ph id=\"ph1\">`INNER JOIN`</ph> produces a constrained Cartesian product of the two collections, as illustrated in the following example:","source":"An `INNER JOIN` produces a constrained Cartesian product of the two collections, as illustrated in the following example:"},{"content":"The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the <ph id=\"ph1\">`ON`</ph> condition is true.","pos":[3219,3414],"source":"The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the `ON` condition is true."},{"content":"If no <ph id=\"ph1\">`ON`</ph> condition is specified, an <ph id=\"ph2\">`INNER JOIN`</ph> degenerates to a <ph id=\"ph3\">`CROSS JOIN`</ph>.","pos":[3415,3496],"source":" If no `ON` condition is specified, an `INNER JOIN` degenerates to a `CROSS JOIN`."},{"pos":[3507,3545],"content":"Left Outer Joins and Right Outer Joins","linkify":"Left Outer Joins and Right Outer Joins","nodes":[{"content":"Left Outer Joins and Right Outer Joins","pos":[0,38]}]},{"pos":[3549,3687],"content":"An <ph id=\"ph1\">`OUTER JOIN`</ph> query expression produces a constrained Cartesian product of the two collections, as illustrated in the following example:","source":"An `OUTER JOIN` query expression produces a constrained Cartesian product of the two collections, as illustrated in the following example:"},{"content":"The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the <ph id=\"ph1\">`ON`</ph> condition is true.","pos":[3742,3937],"source":"The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the `ON` condition is true."},{"content":"If the <ph id=\"ph1\">`ON`</ph> condition is false, the expression still processes a single instance of the element on the left paired against the element on the right, with the value null.","pos":[3938,4107],"source":" If the `ON` condition is false, the expression still processes a single instance of the element on the left paired against the element on the right, with the value null."},{"pos":[4114,4172],"content":"A <ph id=\"ph1\">`RIGHT OUTER JOIN`</ph> may be expressed in a similar manner.","source":"A `RIGHT OUTER JOIN` may be expressed in a similar manner."},{"pos":[4183,4199],"content":"Full Outer Joins","linkify":"Full Outer Joins","nodes":[{"content":"Full Outer Joins","pos":[0,16]}]},{"pos":[4203,4337],"content":"An explicit <ph id=\"ph1\">`FULL OUTER JOIN`</ph> produces a constrained Cartesian product of the two collections as illustrated in the following example:","source":"An explicit `FULL OUTER JOIN` produces a constrained Cartesian product of the two collections as illustrated in the following example:"},{"content":"The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the <ph id=\"ph1\">`ON`</ph> condition is true.","pos":[4392,4587],"source":"The previous query expression processes a combination of every element of the collection on the left paired against every element of the collection on the right, where the `ON` condition is true."},{"content":"If the <ph id=\"ph1\">`ON`</ph> condition is false, the expression still processes one instance of the element on the left paired against the element on the right, with the value null.","pos":[4588,4752],"source":" If the `ON` condition is false, the expression still processes one instance of the element on the left paired against the element on the right, with the value null."},{"content":"It also processes one instance of the element on the right paired against the element on the left, with the value null.","pos":[4753,4872]},{"pos":[4880,5152],"content":"[!NOTE]\n To preserve compatibility with SQL-92, in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)] the OUTER keyword is optional. Therefore, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN` are synonyms for `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, and `FULL OUTER JOIN`.","leadings":["","> "],"nodes":[{"content":"To preserve compatibility with SQL-92, in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)] the OUTER keyword is optional. Therefore, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN` are synonyms for `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, and `FULL OUTER JOIN`.","pos":[9,270],"nodes":[{"content":"To preserve compatibility with SQL-92, in <ph id=\"ph1\">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph> the OUTER keyword is optional.","pos":[0,128],"source":"To preserve compatibility with SQL-92, in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)] the OUTER keyword is optional."},{"content":"Therefore, <ph id=\"ph1\">`LEFT JOIN`</ph>, <ph id=\"ph2\">`RIGHT JOIN`</ph>, and <ph id=\"ph3\">`FULL JOIN`</ph> are synonyms for <ph id=\"ph4\">`LEFT OUTER JOIN`</ph>, <ph id=\"ph5\">`RIGHT OUTER JOIN`</ph>, and <ph id=\"ph6\">`FULL OUTER JOIN`</ph>.","pos":[129,261],"source":" Therefore, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN` are synonyms for `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, and `FULL OUTER JOIN`."}]}]},{"pos":[5162,5179],"content":"APPLY Clause Item","linkify":"APPLY Clause Item","nodes":[{"content":"APPLY Clause Item","pos":[0,17]}]},{"pos":[5239,5302],"content":"supports two kinds of <ph id=\"ph1\">`APPLY`</ph>: <ph id=\"ph2\">`CROSS APPLY`</ph> and <ph id=\"ph3\">`OUTER APPLY`</ph>.","source":" supports two kinds of `APPLY`: `CROSS APPLY` and `OUTER APPLY`."},{"content":"A <ph id=\"ph1\">`CROSS APPLY`</ph> produces a unique pairing of each element of the collection on the left with an element of the collection produced by evaluating the expression on the right.","pos":[5309,5482],"source":"A `CROSS APPLY` produces a unique pairing of each element of the collection on the left with an element of the collection produced by evaluating the expression on the right."},{"content":"With a <ph id=\"ph1\">`CROSS APPLY`</ph>, the expression on the right is functionally dependent on the element on the left, as illustrated in the following associated collection example:","pos":[5483,5649],"source":" With a `CROSS APPLY`, the expression on the right is functionally dependent on the element on the left, as illustrated in the following associated collection example:"},{"content":"The behavior of <ph id=\"ph1\">`CROSS APPLY`</ph> is similar to the join list.","pos":[5713,5771],"source":"The behavior of `CROSS APPLY` is similar to the join list."},{"content":"If the expression on the right evaluates to an empty collection, the <ph id=\"ph1\">`CROSS APPLY`</ph> produces no pairings for that instance of the element on the left.","pos":[5772,5921],"source":" If the expression on the right evaluates to an empty collection, the `CROSS APPLY` produces no pairings for that instance of the element on the left."},{"content":"An <ph id=\"ph1\">`OUTER APPLY`</ph> resembles a <ph id=\"ph2\">`CROSS APPLY`</ph>, except a pairing is still produced even when the expression on the right evaluates to an empty collection.","pos":[5928,6078],"source":"An `OUTER APPLY` resembles a `CROSS APPLY`, except a pairing is still produced even when the expression on the right evaluates to an empty collection."},{"content":"The following is an example of an <ph id=\"ph1\">`OUTER APPLY`</ph>:","pos":[6079,6127],"source":" The following is an example of an `OUTER APPLY`:"},{"pos":[6192,6374],"content":"[!NOTE]\n Unlike in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], there is no need for an explicit unnest step in [!INCLUDE[esql](../../../../../../includes/esql-md.md)].","leadings":["","> "],"nodes":[{"content":"Unlike in <ph id=\"ph1\">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>, there is no need for an explicit unnest step in <ph id=\"ph2\">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph>.","pos":[9,180],"source":"Unlike in [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)], there is no need for an explicit unnest step in [!INCLUDE[esql](../../../../../../includes/esql-md.md)]."}]},{"pos":[6382,6947],"content":"[!NOTE]\n `CROSS` and `OUTER APPLY` operators were introduced in [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]. In some cases, the query pipeline might produce Transact-SQL that contains `CROSS APPLY` and/or `OUTER APPLY` operators. Because some backend providers, including versions of [!INCLUDE[ssNoVersion](../../../../../../includes/ssnoversion-md.md)] earlier than [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)], do not support these operators, such queries cannot be executed on these backend providers.","leadings":["","> "],"nodes":[{"content":"`CROSS` and `OUTER APPLY` operators were introduced in [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]. In some cases, the query pipeline might produce Transact-SQL that contains `CROSS APPLY` and/or `OUTER APPLY` operators. Because some backend providers, including versions of [!INCLUDE[ssNoVersion](../../../../../../includes/ssnoversion-md.md)] earlier than [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)], do not support these operators, such queries cannot be executed on these backend providers.","pos":[9,563],"nodes":[{"content":"<ph id=\"ph1\">`CROSS`</ph> and <ph id=\"ph2\">`OUTER APPLY`</ph> operators were introduced in <ph id=\"ph3\">[!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]</ph>.","pos":[0,129],"source":"`CROSS` and `OUTER APPLY` operators were introduced in [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]."},{"content":"In some cases, the query pipeline might produce Transact-SQL that contains <ph id=\"ph1\">`CROSS APPLY`</ph> and/or <ph id=\"ph2\">`OUTER APPLY`</ph> operators.","pos":[130,250],"source":" In some cases, the query pipeline might produce Transact-SQL that contains `CROSS APPLY` and/or `OUTER APPLY` operators."},{"content":"Because some backend providers, including versions of <ph id=\"ph1\">[!INCLUDE[ssNoVersion](../../../../../../includes/ssnoversion-md.md)]</ph> earlier than <ph id=\"ph2\">[!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)]</ph>, do not support these operators, such queries cannot be executed on these backend providers.","pos":[251,554],"source":" Because some backend providers, including versions of [!INCLUDE[ssNoVersion](../../../../../../includes/ssnoversion-md.md)] earlier than [!INCLUDE[ssVersion2005](../../../../../../includes/ssversion2005-md.md)], do not support these operators, such queries cannot be executed on these backend providers."}]}]},{"pos":[6958,7429],"content":"Some typical scenarios that might lead to the presence of <ph id=\"ph1\">`CROSS APPLY`</ph> and/or <ph id=\"ph2\">`OUTER APPLY`</ph> operators in the output query are the following: a correlated subquery with paging; AnyElement over a correlated subquery or over a collection produced by navigation; LINQ queries that use grouping methods that accept an element selector; a query in which a <ph id=\"ph3\">`CROSS APPLY`</ph> or an <ph id=\"ph4\">`OUTER APPLY`</ph> are explicitly specified; a query that has a <ph id=\"ph5\">`DEREF`</ph> construct over a <ph id=\"ph6\">`REF`</ph> construct.","source":"Some typical scenarios that might lead to the presence of `CROSS APPLY` and/or `OUTER APPLY` operators in the output query are the following: a correlated subquery with paging; AnyElement over a correlated subquery or over a collection produced by navigation; LINQ queries that use grouping methods that accept an element selector; a query in which a `CROSS APPLY` or an `OUTER APPLY` are explicitly specified; a query that has a `DEREF` construct over a `REF` construct."},{"pos":[7438,7477],"content":"Multiple Collections in the FROM Clause","linkify":"Multiple Collections in the FROM Clause","nodes":[{"content":"Multiple Collections in the FROM Clause","pos":[0,39]}]},{"content":"The <ph id=\"ph1\">`FROM`</ph> clause can contain more than one collection separated by commas.","pos":[7481,7556],"source":"The `FROM` clause can contain more than one collection separated by commas."},{"content":"In these cases, the collections are assumed to be joined together.","pos":[7557,7623]},{"content":"Think of these as an n-way CROSS JOIN.","pos":[7624,7662]},{"pos":[7669,7770],"content":"In the following example, <ph id=\"ph1\">`C`</ph> and <ph id=\"ph2\">`D`</ph> are independent collections, but <ph id=\"ph3\">`c.Names`</ph> is dependent on <ph id=\"ph4\">`C`</ph>.","source":"In the following example, `C` and `D` are independent collections, but `c.Names` is dependent on `C`."},{"content":"The previous example is logically equivalent to the following example:","pos":[7828,7898]},{"pos":[7966,7982],"content":"Left Correlation","linkify":"Left Correlation","nodes":[{"content":"Left Correlation","pos":[0,16]}]},{"content":"Items in the <ph id=\"ph1\">`FROM`</ph> clause can refer to items specified in earlier clauses.","pos":[7986,8061],"source":"Items in the `FROM` clause can refer to items specified in earlier clauses."},{"content":"In the following example, <ph id=\"ph1\">`C`</ph> and <ph id=\"ph2\">`D`</ph> are independent collections, but <ph id=\"ph3\">`c.Names`</ph> is dependent on <ph id=\"ph4\">`C`</ph>:","pos":[8062,8163],"source":" In the following example, `C` and `D` are independent collections, but `c.Names` is dependent on `C`:"},{"content":"This is logically equivalent to:","pos":[8221,8253]},{"pos":[8330,8339],"content":"Semantics","linkify":"Semantics","nodes":[{"content":"Semantics","pos":[0,9]}]},{"content":"Logically, the collections in the <ph id=\"ph1\">`FROM`</ph> clause are assumed to be part of an <ph id=\"ph2\">`n`</ph>-way cross join (except in the case of a 1-way cross join).","pos":[8343,8482],"source":"Logically, the collections in the `FROM` clause are assumed to be part of an `n`-way cross join (except in the case of a 1-way cross join)."},{"content":"Aliases in the <ph id=\"ph1\">`FROM`</ph> clause are processed left to right, and are added to the current scope for later reference.","pos":[8483,8596],"source":" Aliases in the `FROM` clause are processed left to right, and are added to the current scope for later reference."},{"content":"The <ph id=\"ph1\">`FROM`</ph> clause is assumed to produce a multiset of rows.","pos":[8597,8656],"source":" The `FROM` clause is assumed to produce a multiset of rows."},{"content":"There will be one field for each item in the <ph id=\"ph1\">`FROM`</ph> clause that represents a single element from that collection item.","pos":[8657,8775],"source":" There will be one field for each item in the `FROM` clause that represents a single element from that collection item."},{"pos":[8782,8949],"content":"The <ph id=\"ph1\">`FROM`</ph> clause logically produces a multiset of rows of type Row(c, d, e) where fields c, d, and e are assumed to be of the element type of <ph id=\"ph2\">`C`</ph>, <ph id=\"ph3\">`D`</ph>, and <ph id=\"ph4\">`c.Names`</ph>.","source":"The `FROM` clause logically produces a multiset of rows of type Row(c, d, e) where fields c, d, and e are assumed to be of the element type of `C`, `D`, and `c.Names`."},{"content":"introduces an alias for each simple <ph id=\"ph1\">`FROM`</ph> clause item in scope.","pos":[9012,9076],"source":" introduces an alias for each simple `FROM` clause item in scope."},{"content":"For example, in the following FROM clause snippet, The names introduced into scope are c, d, and e.","pos":[9077,9176]},{"content":"In <ph id=\"ph1\">[!INCLUDE[esql](../../../../../../includes/esql-md.md)]</ph> (unlike <ph id=\"ph2\">[!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]</ph>), the <ph id=\"ph3\">`FROM`</ph> clause only introduces the aliases into scope.","pos":[9251,9433],"source":"In [!INCLUDE[esql](../../../../../../includes/esql-md.md)] (unlike [!INCLUDE[tsql](../../../../../../includes/tsql-md.md)]), the `FROM` clause only introduces the aliases into scope."},{"content":"Any references to columns (properties) of these collections must be qualified with the alias.","pos":[9434,9527]},{"pos":[9536,9571],"content":"Pulling Up Keys from Nested Queries","linkify":"Pulling Up Keys from Nested Queries","nodes":[{"content":"Pulling Up Keys from Nested Queries","pos":[0,35]}]},{"content":"Certain types of queries that require pulling up keys from a nested query are not supported.","pos":[9575,9667]},{"content":"For example, the following query is valid:","pos":[9668,9710]},{"content":"However, the following query is not valid, because the nested query does not have any keys:","pos":[9771,9862]},{"pos":[9911,9919],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Entity SQL Reference<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-reference.md)</ept><ph id=\"ph1\"> </ph>","pos":[9923,10038],"source":"[Entity SQL Reference](../../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-reference.md) "},{"content":"<bpt id=\"p1\">[</bpt>Query Expressions<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/ef/language-reference/query-expressions-entity-sql.md)</ept><ph id=\"ph1\"> </ph>","pos":[10042,10162],"source":"[Query Expressions](../../../../../../docs/framework/data/adonet/ef/language-reference/query-expressions-entity-sql.md) "},{"content":"<bpt id=\"p1\">[</bpt>Nullable Structured Types<ept id=\"p1\">](../../../../../../docs/framework/data/adonet/ef/language-reference/nullable-structured-types-entity-sql.md)</ept>","pos":[10166,10301],"source":"[Nullable Structured Types](../../../../../../docs/framework/data/adonet/ef/language-reference/nullable-structured-types-entity-sql.md)"}]}