{"content":"---\ntitle: The relationship between language features and library types | Microsoft Docs\ndescription: Language features often rely on library types for implementation. Understand that relationship.\nms.date: 07/20/2017\n---\n\n# Relationships between language features and library types\n\nThe C# language definition requires a standard library to have certain\ntypes and certain accessible members on those types. The compiler generates\ncode that uses these required types and members for many different language\nfeatures. When necessary, there are NuGet packages that contain types\nneeded for newer versions of the language when writing code for environments\nwhere those types or members have not been deployed yet.\n\nThis dependency on standard library functionality has been part of the\nC# language since its first version. In that version, examples included:\n\n* <xref:System.Exception> - used for all compiler generated exceptions.\n* <xref:System.String> - the C# `string` type is a synonym for <xref:System.String>.\n* <xref:System.Int32> - synonym of `int`.\n\nThat first\nversion was simple: the compiler and the standard library shipped together,\nand there was only one version of each.\n\nSubsequent versions of C# have occasionally added new types or members to\nthe dependencies. Examples include: <xref:System.Runtime.CompilerServices.INotifyCompletion>,\n<xref:System.Runtime.CompilerServices.CallerFilePathAttribute> and\n<xref:System.Runtime.CompilerServices.CallerMemberNameAttribute>. C# 7.0 continues this by adding a dependency on <xref:System.ValueTuple> to\nimplement the [tuples](../tuples.md) language feature.\n\nThe language design team works to minimize the surface area of the types\nand members required in a compliant standard library. That goal is balanced\nagainst a clean design where new library features are incorporated seamlessly\ninto the language. There will be new features in future versions of C# that\nrequire new types and members in a standard library. It's important to understand\nhow to manage those dependencies in your work.\n\n## Managing your dependencies\n\nC# compiler tools are now decoupled from the release cycle of the .NET libraries\non supported platforms. In fact, different .NET libraries have different release\ncycles: the .NET Framework on Windows is released as a Windows Update, .NET Core ships on\na separate schedule, and the Xamarin versions of library updates ship with the Xamarin tools\nfor each target platform.\n\nThe majority of time, you won't notice these changes. However, when you are working\nwith a newer version of the language that requires features not yet in the .NET libraries\non that platform, you'll reference the NuGet packages to provide those new types.\nAs the platforms your app supports are updated with new framework installations,\nyou can remove the extra reference.\n\nThis separation means you can use new language features even when you are targeting\nmachines that may not have the corresponding framework.\n","nodes":[{"pos":[4,217],"embed":true,"restype":"x-metadata","content":"title: The relationship between language features and library types | Microsoft Docs\ndescription: Language features often rely on library types for implementation. Understand that relationship.\nms.date: 07/20/2017","nodes":[{"content":"The relationship between language features and library types | Microsoft Docs","nodes":[{"pos":[0,77],"content":"The relationship between language features and library types | Microsoft Docs","nodes":[{"content":"The relationship between language features and library types | Microsoft Docs","pos":[0,77]}]}],"path":["title"],"nosxs":false},{"content":"Language features often rely on library types for implementation. Understand that relationship.","nodes":[{"pos":[0,95],"content":"Language features often rely on library types for implementation. Understand that relationship.","nodes":[{"content":"Language features often rely on library types for implementation. Understand that relationship.","pos":[0,95],"nodes":[{"content":"Language features often rely on library types for implementation.","pos":[0,65]},{"content":"Understand that relationship.","pos":[66,95]}]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[225,282],"content":"Relationships between language features and library types","linkify":"Relationships between language features and library types","nodes":[{"content":"Relationships between language features and library types","pos":[0,57]}]},{"content":"The C# language definition requires a standard library to have certain types and certain accessible members on those types.","pos":[284,407],"source":"The C# language definition requires a standard library to have certain\ntypes and certain accessible members on those types."},{"content":"The compiler generates code that uses these required types and members for many different language features.","pos":[408,516],"source":" The compiler generates\ncode that uses these required types and members for many different language\nfeatures."},{"content":"When necessary, there are NuGet packages that contain types needed for newer versions of the language when writing code for environments where those types or members have not been deployed yet.","pos":[517,710],"source":" When necessary, there are NuGet packages that contain types\nneeded for newer versions of the language when writing code for environments\nwhere those types or members have not been deployed yet."},{"content":"This dependency on standard library functionality has been part of the C# language since its first version.","pos":[712,819],"source":"This dependency on standard library functionality has been part of the\nC# language since its first version."},{"content":"In that version, examples included:","pos":[820,855]},{"pos":[859,928],"content":"<ph id=\"ph1\">&lt;xref:System.Exception&gt;</ph> - used for all compiler generated exceptions.","source":"<xref:System.Exception> - used for all compiler generated exceptions."},{"pos":[931,1013],"content":"<ph id=\"ph1\">&lt;xref:System.String&gt;</ph> - the C# <ph id=\"ph2\">`string`</ph> type is a synonym for <ph id=\"ph3\">&lt;xref:System.String&gt;</ph>.","source":"<xref:System.String> - the C# `string` type is a synonym for <xref:System.String>."},{"pos":[1016,1055],"content":"<ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> - synonym of <ph id=\"ph2\">`int`</ph>.","source":"<xref:System.Int32> - synonym of `int`."},{"pos":[1057,1183],"content":"That first version was simple: the compiler and the standard library shipped together, and there was only one version of each.","source":"That first\nversion was simple: the compiler and the standard library shipped together,\nand there was only one version of each."},{"content":"Subsequent versions of C# have occasionally added new types or members to the dependencies.","pos":[1185,1276],"source":"Subsequent versions of C# have occasionally added new types or members to\nthe dependencies."},{"content":"Examples include: <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.INotifyCompletion&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.CallerFilePathAttribute&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Runtime.CompilerServices.CallerMemberNameAttribute&gt;</ph>.","pos":[1277,1485],"source":" Examples include: <xref:System.Runtime.CompilerServices.INotifyCompletion>,\n<xref:System.Runtime.CompilerServices.CallerFilePathAttribute> and\n<xref:System.Runtime.CompilerServices.CallerMemberNameAttribute>."},{"content":"C# 7.0 continues this by adding a dependency on <ph id=\"ph1\">&lt;xref:System.ValueTuple&gt;</ph> to implement the <bpt id=\"p1\">[</bpt>tuples<ept id=\"p1\">](../tuples.md)</ept> language feature.","pos":[1486,1616],"source":" C# 7.0 continues this by adding a dependency on <xref:System.ValueTuple> to\nimplement the [tuples](../tuples.md) language feature."},{"content":"The language design team works to minimize the surface area of the types and members required in a compliant standard library.","pos":[1618,1744],"source":"The language design team works to minimize the surface area of the types\nand members required in a compliant standard library."},{"content":"That goal is balanced against a clean design where new library features are incorporated seamlessly into the language.","pos":[1745,1863],"source":" That goal is balanced\nagainst a clean design where new library features are incorporated seamlessly\ninto the language."},{"content":"There will be new features in future versions of C# that require new types and members in a standard library.","pos":[1864,1973],"source":" There will be new features in future versions of C# that\nrequire new types and members in a standard library."},{"content":"It's important to understand how to manage those dependencies in your work.","pos":[1974,2049],"source":" It's important to understand\nhow to manage those dependencies in your work."},{"pos":[2054,2080],"content":"Managing your dependencies","linkify":"Managing your dependencies","nodes":[{"content":"Managing your dependencies","pos":[0,26]}]},{"content":"C# compiler tools are now decoupled from the release cycle of the .NET libraries on supported platforms.","pos":[2082,2186],"source":"C# compiler tools are now decoupled from the release cycle of the .NET libraries\non supported platforms."},{"content":"In fact, different .NET libraries have different release cycles: the .NET Framework on Windows is released as a Windows Update, .NET Core ships on a separate schedule, and the Xamarin versions of library updates ship with the Xamarin tools for each target platform.","pos":[2187,2452],"source":" In fact, different .NET libraries have different release\ncycles: the .NET Framework on Windows is released as a Windows Update, .NET Core ships on\na separate schedule, and the Xamarin versions of library updates ship with the Xamarin tools\nfor each target platform."},{"content":"The majority of time, you won't notice these changes.","pos":[2454,2507]},{"content":"However, when you are working with a newer version of the language that requires features not yet in the .NET libraries on that platform, you'll reference the NuGet packages to provide those new types.","pos":[2508,2709],"source":" However, when you are working\nwith a newer version of the language that requires features not yet in the .NET libraries\non that platform, you'll reference the NuGet packages to provide those new types."},{"content":"As the platforms your app supports are updated with new framework installations, you can remove the extra reference.","pos":[2710,2826],"source":"\nAs the platforms your app supports are updated with new framework installations,\nyou can remove the extra reference."},{"pos":[2828,2967],"content":"This separation means you can use new language features even when you are targeting machines that may not have the corresponding framework.","source":"This separation means you can use new language features even when you are targeting\nmachines that may not have the corresponding framework."}]}