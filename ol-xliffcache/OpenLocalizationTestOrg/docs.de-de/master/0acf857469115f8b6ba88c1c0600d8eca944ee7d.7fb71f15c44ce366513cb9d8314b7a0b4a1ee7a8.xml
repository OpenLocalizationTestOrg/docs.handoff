{"content":"---\ntitle: \"Walkthrough: SQL Generation | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-ado\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 16c38aaa-9927-4f3c-ab0f-81636cce57a3\ncaps.latest.revision: 3\nauthor: \"JennieHubbard\"\nms.author: \"jhubbard\"\nmanager: \"jhubbard\"\n---\n# Walkthrough: SQL Generation\nThis topic illustrates how SQL generation occurs in the [Sample Provider](http://go.microsoft.com/fwlink/?LinkId=180616). The following Entity SQL query uses the model that is included with the sample provider:  \n  \n```  \nSELECT  j1.ProductId, j1.ProductName, j1.CategoryName, j2.ShipCountry, j2.ProductId  \nFROM (  SELECT P.ProductName, P.ProductId, P.Category.CategoryName  \n        FROM NorthwindEntities.Products AS P) as j1  \nINNER JOIN (SELECT OD.ProductId, OD.Order.ShipCountry as ShipCountry  \n            FROM NorthwindEntities.OrderDetails AS OD) as j2  \n            ON j1.ProductId == j2.ProductId   \n```  \n  \n The query produces the following output command tree that is passed to the provider:  \n  \n```  \nDbQueryCommandTree  \n|_Parameters  \n|_Query : Collection{Record['C1'=Edm.Int32, 'ProductID'=Edm.Int32, 'ProductName'=Edm.String, 'CategoryName'=Edm.String, 'ShipCountry'=Edm.String, 'ProductID1'=Edm.Int32]}  \n  |_Project  \n    |_Input : 'Join4'  \n    | |_InnerJoin  \n    |   |_Left : 'Join1'  \n    |   | |_LeftOuterJoin  \n    |   |   |_Left : 'Extent1'  \n    |   |   | |_Scan : dbo.Products  \n    |   |   |_Right : 'Extent2'  \n    |   |   | |_Scan : dbo.Categories  \n    |   |   |_JoinCondition  \n    |   |     |_  \n    |   |       |_Var(Extent1).CategoryID  \n    |   |       |_=  \n    |   |       |_Var(Extent2).CategoryID  \n    |   |_Right : 'Join3'  \n    |   | |_LeftOuterJoin  \n    |   |   |_Left : 'Extent3'  \n    |   |   | |_Scan : dbo.OrderDetails  \n    |   |   |_Right : 'Join2'  \n    |   |   | |_LeftOuterJoin  \n    |   |   |   |_Left : 'Extent4'  \n    |   |   |   | |_Scan : dbo.Orders  \n    |   |   |   |_Right : 'Extent5'  \n    |   |   |   | |_Scan : dbo.InternationalOrders  \n    |   |   |   |_JoinCondition  \n    |   |   |     |_  \n    |   |   |       |_Var(Extent4).OrderID  \n    |   |   |       |_=  \n    |   |   |       |_Var(Extent5).OrderID  \n    |   |   |_JoinCondition  \n    |   |     |_  \n    |   |       |_Var(Extent3).OrderID  \n    |   |       |_=  \n    |   |       |_Var(Join2).Extent4.OrderID  \n    |   |_JoinCondition  \n    |     |_  \n    |       |_Var(Join1).Extent1.ProductID  \n    |       |_=  \n    |       |_Var(Join3).Extent3.ProductID  \n    |_Projection  \n      |_NewInstance : Record['C1'=Edm.Int32, 'ProductID'=Edm.Int32, 'ProductName'=Edm.String, 'CategoryName'=Edm.String, 'ShipCountry'=Edm.String, 'ProductID1'=Edm.Int32]  \n        |_Column : 'C1'  \n        | |_1  \n        |_Column : 'ProductID'  \n        | |_Var(Join4).Join1.Extent1.ProductID  \n        |_Column : 'ProductName'  \n        | |_Var(Join4).Join1.Extent1.ProductName  \n        |_Column : 'CategoryName'  \n        | |_Var(Join4).Join1.Extent2.CategoryName  \n        |_Column : 'ShipCountry'  \n        | |_Var(Join4).Join3.Join2.Extent4.ShipCountry  \n        |_Column : 'ProductID1'  \n          |_Var(Join4).Join3.Extent3.ProductID  \n```  \n  \n This topic describes how to translate this output command tree into the following SQL statements.  \n  \n```  \nSELECT   \n1 AS [C1],   \n[Extent1].[ProductID] AS [ProductID],   \n[Extent1].[ProductName] AS [ProductName],   \n[Extent2].[CategoryName] AS [CategoryName],   \n[Join3].[ShipCountry] AS [ShipCountry],   \n[Join3].[ProductID] AS [ProductID1]  \nFROM   [dbo].[Products] AS [Extent1]  \nLEFT OUTER JOIN [dbo].[Categories] AS [Extent2] ON [Extent1].[CategoryID] = [Extent2].[CategoryID]  \nINNER JOIN    \n(SELECT [Extent3].[OrderID] AS [OrderID1], [Extent3].[ProductID] AS [ProductID], [Extent3].[UnitPrice] AS [UnitPrice], [Extent3].[Quantity] AS [Quantity], [Extent3].[Discount] AS [Discount], [Join2].[OrderID2], [Join2].[CustomerID], [Join2].[EmployeeID], [Join2].[OrderDate], [Join2].[RequiredDate], [Join2].[ShippedDate], [Join2].[Freight], [Join2].[ShipName], [Join2].[ShipAddress], [Join2].[ShipCity], [Join2].[ShipRegion], [Join2].[ShipPostalCode], [Join2].[ShipCountry], [Join2].[OrderID3], [Join2].[CustomsDescription], [Join2].[ExciseTax]  \nFROM  [dbo].[OrderDetails] AS [Extent3]  \nLEFT OUTER JOIN    \n      (SELECT [Extent4].[OrderID] AS [OrderID2], [Extent4].[CustomerID] AS [CustomerID], [Extent4].[EmployeeID] AS [EmployeeID], [Extent4].[OrderDate] AS [OrderDate], [Extent4].[RequiredDate] AS [RequiredDate], [Extent4].[ShippedDate] AS [ShippedDate], [Extent4].[Freight] AS [Freight], [Extent4].[ShipName] AS [ShipName], [Extent4].[ShipAddress] AS [ShipAddress], [Extent4].[ShipCity] AS [ShipCity], [Extent4].[ShipRegion] AS [ShipRegion], [Extent4].[ShipPostalCode] AS [ShipPostalCode], [Extent4].[ShipCountry] AS [ShipCountry], [Extent5].[OrderID] AS [OrderID3], [Extent5].[CustomsDescription] AS [CustomsDescription], [Extent5].[ExciseTax] AS [ExciseTax]  \nFROM  [dbo].[Orders] AS [Extent4]  \nLEFT OUTER JOIN [dbo].[InternationalOrders] AS [Extent5] ON [Extent4].[OrderID] = [Extent5].[OrderID]   \n      ) AS [Join2] ON [Extent3].[OrderID] = [Join2].[OrderID2]   \n   ) AS [Join3] ON [Extent1].[ProductID] = [Join3].[ProductID]  \n```  \n  \n## First Phase of SQL Generation: Visiting the Expression Tree  \n The following figure illustrates the initial empty state of the visitor.  Throughout this topic, only the properties relevant to the walkthrough explanation are shown.  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/430180f5-4fb9-4bc3-8589-d566512d9703.gif \"430180f5-4fb9-4bc3-8589-d566512d9703\")  \n  \n When the Project  node is visited, VisitInputExpression is called over its input (Join4), which triggers the visit of Join4 by the method VisitJoinExpression. Because this is a topmost join, IsParentAJoin returns false and a new SqlSelectStatement (SelectStatement0) is created and pushed on the SELECT statement stack. Also, a new scope (scope0) is entered in the symbol table. Before the first (left) input of the join is visited, 'true' is pushed on the IsParentAJoin stack. Right before Join1, which is the left input of Join4, is visited, the state of the visitor is as shown in the next figure.  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/406d4f5f-6166-44ea-8e74-c5001d5d5d79.gif \"406d4f5f-6166-44ea-8e74-c5001d5d5d79\")  \n  \n When the join visit method is invoked over Join4, IsParentAJoin is true, thus it reuses the current select statement SelectStatement0. A new scope is entered (scope1). Before visiting its left child, Extent1, another true is pushed on the IsParentAJoin stack.  \n  \n When Extent1 is visited, because IsParentAJoin returns true, it returns a SqlBuilder containing \"[dbo].[Products]\". The control returns to the method visiting Join4. An entry is popped from IsParentAJoin, and ProcessJoinInputResult is called, which appends the result of visiting Extent1 to the From clause of SelectStatement0. A new from symbol, symbol_Extent1, for the input binding name \"Extent1\" is created, added to the FromExtents of SelectStatement0, and also \"As\" and  symbol_Extent1 are appended to the from clause. A new entry is added to AllExtentNames for \"Extent1\" with the value of 0. A new entry is added to the current scope in the symbol table to associate \"Extent1\" with its symbol symbol_Extent1. Symbol_Extent1 is also added to the AllJoinExtents of the SqlSelectStatement.  \n  \n Before the right input of Join1 is visited, \"LEFT OUTER JOIN\" is added to the From clause of SelectStatement0. Because the right input is a Scan expression, true is again pushed to the IsParentAJoin stack. The state before visiting the right input as shown in the next figure.  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/ca62c31b-7ff6-4836-b209-e16166304fdc.gif \"ca62c31b-7ff6-4836-b209-e16166304fdc\")  \n  \n The right input is processed in the same way as the left input. The state after visiting the right input is shown in the next figure.  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/cd2afa99-7256-4c63-aaa9-c2d13f18a3d8.gif \"cd2afa99-7256-4c63-aaa9-c2d13f18a3d8\")  \n  \n Next \"false\" is pushed on the IsParentAJoin stack and the join condition Var(Extent1).CategoryID == Var(Extent2).CategoryID is processed. Var(Extenent1) is resolved to <symbol_Extent1> after a look up in the symbol table. Because the instance is resolved to a simple Symbol, as a result of processing Var(Extent1).CategoryID, a SqlBuilder with \\<symbol1>.\"CategoryID\" is returned. Similarly the other side of the comparison is processed, and the result of visiting the join condition is appended to the FROM clause of SelectStatement1 and the value \"false\" is popped from the IsParentAJoin stack.  \n  \n With this, Join1 has completely been processed, and a scope is popped from the symbol table.  \n  \n Control returns to processing Join4, the parent of Join1. Because the child reused the Select statement, the Join1 extents are replaced with a single Join symbol <joinSymbol_Join1>. Also a new entry is added to the symbol table to associate Join1 with <joinSymbol_Join1>.  \n  \n The next node to be processed is Join3, the second child of Join4. As it is a right child, \"false\" is pushed to the IsParentAJoin stack. The state of the visitor at this point is illustrated in the next figure.  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/1ec61ed3-fcdd-4649-9089-24385be7e423.gif \"1ec61ed3-fcdd-4649-9089-24385be7e423\")  \n  \n For Join3, IsParentAJoin returns false and needs to start a new SqlSelectStatement (SelectStatement1) and push it on the stack. Processing continues as it did with the previous the previous joins, a new scope is pushed on the stack and the children are processed. The left child is an Extent (Extent3) and the right child is a join (Join2) which also needs to start a new SqlSelectStatement: SelectStatement2. The children on Join2 are Extents as well and are aggregated into SelectStatement2.  \n  \n The state of the visitor right after Join2 is visited, but before its post-processing (ProcessJoinInputResult) is done is shown in the next figure:  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/7510346f-8b09-4c99-b411-40af239c3c4d.gif \"7510346f-8b09-4c99-b411-40af239c3c4d\")  \n  \n In the previous figure, SelectStatement2 is shown as free floating because it was popped out of the stack, but not yet post processed by the parent. It needs to be added to the FROM part of the parent, but it is not a complete SQL statement without a SELECT clause. So, at this point, the default columns (all the columns produced by its inputs) are added to the select list by the method AddDefaultColumns. AddDefaultColumns iterates over the symbols in FromExtents and for each symbol adds all the columns brought in scope. For a simple symbol, it looks at the symbol type to retrieve all its properties to be added. It also populates the AllColumnNames dictionary with the column names. The completed SelectStatement2 is appended to the FROM clause of SelectStatement1.  \n  \n Next, a new join symbol is created to represent Join2, it is marked as a nested join and added to the AllJoinExtents of SelectStatement1 and added to the symbol table.  Now the join condition of Join3, Var(Extent3).OrderID =  Var(Join2).Extent4.OrderID, needs to be processed. Processing of the left hand side is similar to the join condition of Join1. However, the processing of the right and side \"Var(Join2).Extent4.OrderID\" is different because join flattening is required.  \n  \n The next figure shows the state of the visitor right before the DbPropertyExpression \"Var(Join2).Extent4.OrderID\" is processed.  \n  \n Consider how \"Var(Join2).Extent4.OrderID\" is visited. First, the instance property \"Var(Join2).Extent4\" is visited, which is another DbPropertyExpression and first visits its instance \"Var(Join2)\". In the top most scope in the symbol table, \"Join2\" resolves to <joinSymbol_join2>. In the visit method for DbPropertyExpression processing \"Var(Join2).Extent4\" notice that a join symbol was returned when visiting the instance and flattening is required.  \n  \n Since it is a nested join, we look up the property \"Extent4\" in the NameToExtent dictionary of the join symbol, resolve it to <symbol_Extent4> and return a new SymbolPair(<joinSymbol_join2>, <symbol_Extent4>). Since a symbol pair is returned from the processing of the instance of \"Var(Join2).Extent4.OrderID\",  the property \"OrderID\" is resolved from the ColumnPart of that symbol pair (<symbol_Extent4>), which has a list of the columns of the extent it represents. So, \"Var(Join2).Extent4.OrderID\" is resolved to { <joinSymbol_Join2>, \".\", <symbol_OrderID>}.  \n  \n The join condition of Join4 is similarly processed. The control returns to the VisitInputExpression method that processed the top most project. Looking at the FromExtents of the returned SelectStatement0, the input is identified as a join, and removes the original extents and replaces them with a new extent with just the Join symbol. The symbol table is also updated and next the projection part of the Project is processed. The resolving of the properties and the flattening of the join extents is as described earlier.  \n  \n ![Diagram](../../../../../docs/framework/data/adonet/ef/media/9456d6a9-ea2e-40ae-accc-a10e18e28b81.gif \"9456d6a9-ea2e-40ae-accc-a10e18e28b81\")  \n  \n Finally, the following SqlSelectStatement is produced:  \n  \n```  \nSELECT:   \n  \"1\", \" AS \", \"[C1]\",  \n  <symbol_Extent1>, \".\", \"[ProductID]\", \" AS \", \"[ProductID]\",   \n  <symbol_Extent1>, \".\", \"[ProductName]\", \" AS \", \"[ProductName]\",  \n  <symbol_Extent2>, \".\", \"[CategoryName]\", \" AS \", \"[CategoryName]\",  \n  <joinSymbol_Join3>, \".\", <symbol_ShipCountry>, \" AS \", \"[ShipCountry]\",   \n  <joinSymbol_Join3>, \".\", <symbol_ProductID>, \" AS \", \"[ProductID1]\"  \nFROM: \"[dbo].[Products]\", \" AS \", <symbol_Extent1>,   \n        \"LEFT OUTER JOIN \"\"[dbo].[Categories]\", \" AS \", <symbol_Extent2>, \" ON \", <symbol_Extent1>, \".\", \"[CategoryID]\", \" = \", <symbol_Extent2>, \".\", \"[CategoryID]\",   \n        \"INNER JOIN \",   \n        \" (\", SELECT:   \n           <symbol_Extent3>, \".\", \"[OrderID]\", \" AS \", <symbol_OrderID>, \",   \n              <symbol_Extent3>, \".\", \"[ProductID]\", \" AS \", <symbol_ProductID>, ...,  \n         <joinSymbol_Join2>, \".\", <symbol_OrderID_2>, \", \",   \n           <joinSymbol_Join2>, \".\", <symbol_CustomerID>, ....,    \n        <joinSymbol_Join2>, \".\", <symbol_OrderID_3>,   \n<joinSymbol_Join2>, \".\", <symbol_CustomsDescription>,   \n<joinSymbol_Join2>, \".\", <symbol_ExciseTax>  \nFROM: \"[dbo].[OrderDetails]\", \" AS \", <symbol_Extent3>,   \n\"LEFT OUTER JOIN \",   \n\" (\", SELECT:   \n<symbol_Extent4>, \".\", \"[OrderID]\", \" AS \", <symbol_OrderID_2>,   \n<symbol_Extent4>, \".\", \"[CustomerID]\", \" AS \", <symbol_CustomerID>, ...  \n<symbol_Extent5>, \".\", \"[OrderID]\", \" AS \", <symbol_OrderID_3>,  \n<symbol_Extent5>, \".\", \"[CustomsDescription]\", \" AS \", <symbol_CustomsDescription>,  \n<symbol_Extent5>, \".\", \"[ExciseTax]\", \" AS \", <symbol_ExciseTax>  \nFROM: \"[dbo].[Orders]\", \" AS \", <symbol_Extent4>,  \n\"LEFT OUTER JOIN \", , \"[dbo].[InternationalOrders]\", \" AS \", <symbol_Extent5>,   \n\" ON \", <symbol_Extent4>, \".\", \"[OrderID]\", \" = \", , <symbol_Extent5>, \".\", \"[OrderID]\"  \n\" )\", \" AS \", <joinSymbol_Join2>, \" ON \", , , <symbol_Extent3>, \".\", \"[OrderID]\", \" = \", , <joinSymbol_Join2>, \".\", <symbol_OrderID_2>  \n\" )\", \" AS \", <joinSymbol_Join3>, \" ON \", , , <symbol_Extent1>, \".\", \"[ProductID]\", \" = \", , <joinSymbol_Join3>, \".\", <symbol_ProductID>  \n```  \n  \n### Second Phase of SQL Generation: Generating the String Command  \n The second phase produces actual names for the symbols, and we only focus on the symbols representing columns named \"OrderID\", as in this case a conflict needs to be resolved. These are highlighted in the SqlSelectStatement. Note that the suffixes used in the figure are only to emphasize that these are different instances, not to represent any new names, as at this stage their final names (possibly different form the original names) have not been assigned yet.  \n  \n The first symbol found that needs to be renamed is <symbol_OrderID>. Its new name is assigned as \"OrderID1\", 1 is marked as the last used suffix for \"OrderID\" and the symbol is marked as not needing renaming. Next, the first usage of <symbol_OrderID_2> is found. It is renamed to use the next available suffix (\"OrderID2\") and again marked as not needing renaming, so that next time it is used it does not get renamed. This is done for <symbol_OrderID_3> too.  \n  \n At the end of the second phase, the final SQL statement is generated.  \n  \n## See Also  \n [SQL Generation in the Sample Provider](../../../../../docs/framework/data/adonet/ef/sql-generation-in-the-sample-provider.md)","nodes":[{"pos":[12,56],"content":"Walkthrough: SQL Generation | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Walkthrough: SQL Generation | Microsoft Docs","pos":[0,44]}]},{"pos":[365,392],"content":"Walkthrough: SQL Generation","linkify":"Walkthrough: SQL Generation","nodes":[{"content":"Walkthrough: SQL Generation","pos":[0,27]}]},{"content":"This topic illustrates how SQL generation occurs in the <bpt id=\"p1\">[</bpt>Sample Provider<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=180616)</ept>.","pos":[393,514],"source":"This topic illustrates how SQL generation occurs in the [Sample Provider](http://go.microsoft.com/fwlink/?LinkId=180616)."},{"content":"The following Entity SQL query uses the model that is included with the sample provider:","pos":[515,603]},{"content":"The query produces the following output command tree that is passed to the provider:","pos":[1015,1099]},{"content":"This topic describes how to translate this output command tree into the following SQL statements.","pos":[3256,3353]},{"pos":[5313,5372],"content":"First Phase of SQL Generation: Visiting the Expression Tree","linkify":"First Phase of SQL Generation: Visiting the Expression Tree","nodes":[{"content":"First Phase of SQL Generation: Visiting the Expression Tree","pos":[0,59]}]},{"content":"The following figure illustrates the initial empty state of the visitor.","pos":[5376,5448]},{"content":"Throughout this topic, only the properties relevant to the walkthrough explanation are shown.","pos":[5450,5543]},{"pos":[5550,5692],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/430180f5-4fb9-4bc3-8589-d566512d9703.gif \"</bpt>430180f5-4fb9-4bc3-8589-d566512d9703<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/430180f5-4fb9-4bc3-8589-d566512d9703.gif \"430180f5-4fb9-4bc3-8589-d566512d9703\")"},{"content":"When the Project  node is visited, VisitInputExpression is called over its input (Join4), which triggers the visit of Join4 by the method VisitJoinExpression.","pos":[5699,5857]},{"content":"Because this is a topmost join, IsParentAJoin returns false and a new SqlSelectStatement (SelectStatement0) is created and pushed on the SELECT statement stack.","pos":[5858,6018]},{"content":"Also, a new scope (scope0) is entered in the symbol table.","pos":[6019,6077]},{"content":"Before the first (left) input of the join is visited, 'true' is pushed on the IsParentAJoin stack.","pos":[6078,6176]},{"content":"Right before Join1, which is the left input of Join4, is visited, the state of the visitor is as shown in the next figure.","pos":[6177,6299]},{"pos":[6306,6448],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/406d4f5f-6166-44ea-8e74-c5001d5d5d79.gif \"</bpt>406d4f5f-6166-44ea-8e74-c5001d5d5d79<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/406d4f5f-6166-44ea-8e74-c5001d5d5d79.gif \"406d4f5f-6166-44ea-8e74-c5001d5d5d79\")"},{"content":"When the join visit method is invoked over Join4, IsParentAJoin is true, thus it reuses the current select statement SelectStatement0.","pos":[6455,6589]},{"content":"A new scope is entered (scope1).","pos":[6590,6622]},{"content":"Before visiting its left child, Extent1, another true is pushed on the IsParentAJoin stack.","pos":[6623,6714]},{"content":"When Extent1 is visited, because IsParentAJoin returns true, it returns a SqlBuilder containing \"[dbo].[Products]\".","pos":[6721,6836]},{"content":"The control returns to the method visiting Join4.","pos":[6837,6886]},{"content":"An entry is popped from IsParentAJoin, and ProcessJoinInputResult is called, which appends the result of visiting Extent1 to the From clause of SelectStatement0.","pos":[6887,7048]},{"content":"A new from symbol, symbol_Extent1, for the input binding name \"Extent1\" is created, added to the FromExtents of SelectStatement0, and also \"As\" and  symbol_Extent1 are appended to the from clause.","pos":[7049,7245]},{"content":"A new entry is added to AllExtentNames for \"Extent1\" with the value of 0.","pos":[7246,7319]},{"content":"A new entry is added to the current scope in the symbol table to associate \"Extent1\" with its symbol symbol_Extent1.","pos":[7320,7436]},{"content":"Symbol_Extent1 is also added to the AllJoinExtents of the SqlSelectStatement.","pos":[7437,7514]},{"content":"Before the right input of Join1 is visited, \"LEFT OUTER JOIN\" is added to the From clause of SelectStatement0.","pos":[7521,7631]},{"content":"Because the right input is a Scan expression, true is again pushed to the IsParentAJoin stack.","pos":[7632,7726]},{"content":"The state before visiting the right input as shown in the next figure.","pos":[7727,7797]},{"pos":[7804,7946],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/ca62c31b-7ff6-4836-b209-e16166304fdc.gif \"</bpt>ca62c31b-7ff6-4836-b209-e16166304fdc<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/ca62c31b-7ff6-4836-b209-e16166304fdc.gif \"ca62c31b-7ff6-4836-b209-e16166304fdc\")"},{"content":"The right input is processed in the same way as the left input.","pos":[7953,8016]},{"content":"The state after visiting the right input is shown in the next figure.","pos":[8017,8086]},{"pos":[8093,8235],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/cd2afa99-7256-4c63-aaa9-c2d13f18a3d8.gif \"</bpt>cd2afa99-7256-4c63-aaa9-c2d13f18a3d8<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/cd2afa99-7256-4c63-aaa9-c2d13f18a3d8.gif \"cd2afa99-7256-4c63-aaa9-c2d13f18a3d8\")"},{"content":"Next \"false\" is pushed on the IsParentAJoin stack and the join condition Var(Extent1).CategoryID == Var(Extent2).CategoryID is processed.","pos":[8242,8379]},{"content":"Var(Extenent1) is resolved to &lt;symbol_Extent1&gt; after a look up in the symbol table.","pos":[8380,8463],"source":" Var(Extenent1) is resolved to <symbol_Extent1> after a look up in the symbol table."},{"content":"Because the instance is resolved to a simple Symbol, as a result of processing Var(Extent1).CategoryID, a SqlBuilder with <ph id=\"ph1\">\\&lt;</ph>symbol1&gt;.\"CategoryID\" is returned.","pos":[8464,8622],"source":" Because the instance is resolved to a simple Symbol, as a result of processing Var(Extent1).CategoryID, a SqlBuilder with \\<symbol1>.\"CategoryID\" is returned."},{"content":"Similarly the other side of the comparison is processed, and the result of visiting the join condition is appended to the FROM clause of SelectStatement1 and the value \"false\" is popped from the IsParentAJoin stack.","pos":[8623,8838]},{"content":"With this, Join1 has completely been processed, and a scope is popped from the symbol table.","pos":[8845,8937]},{"content":"Control returns to processing Join4, the parent of Join1.","pos":[8944,9001]},{"content":"Because the child reused the Select statement, the Join1 extents are replaced with a single Join symbol &lt;joinSymbol_Join1&gt;.","pos":[9002,9125],"source":" Because the child reused the Select statement, the Join1 extents are replaced with a single Join symbol <joinSymbol_Join1>."},{"content":"Also a new entry is added to the symbol table to associate Join1 with &lt;joinSymbol_Join1&gt;.","pos":[9126,9215],"source":" Also a new entry is added to the symbol table to associate Join1 with <joinSymbol_Join1>."},{"content":"The next node to be processed is Join3, the second child of Join4.","pos":[9222,9288]},{"content":"As it is a right child, \"false\" is pushed to the IsParentAJoin stack.","pos":[9289,9358]},{"content":"The state of the visitor at this point is illustrated in the next figure.","pos":[9359,9432]},{"pos":[9439,9581],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/1ec61ed3-fcdd-4649-9089-24385be7e423.gif \"</bpt>1ec61ed3-fcdd-4649-9089-24385be7e423<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/1ec61ed3-fcdd-4649-9089-24385be7e423.gif \"1ec61ed3-fcdd-4649-9089-24385be7e423\")"},{"content":"For Join3, IsParentAJoin returns false and needs to start a new SqlSelectStatement (SelectStatement1) and push it on the stack.","pos":[9588,9715]},{"content":"Processing continues as it did with the previous the previous joins, a new scope is pushed on the stack and the children are processed.","pos":[9716,9851]},{"content":"The left child is an Extent (Extent3) and the right child is a join (Join2) which also needs to start a new SqlSelectStatement: SelectStatement2.","pos":[9852,9997]},{"content":"The children on Join2 are Extents as well and are aggregated into SelectStatement2.","pos":[9998,10081]},{"content":"The state of the visitor right after Join2 is visited, but before its post-processing (ProcessJoinInputResult) is done is shown in the next figure:","pos":[10088,10235]},{"pos":[10242,10384],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/7510346f-8b09-4c99-b411-40af239c3c4d.gif \"</bpt>7510346f-8b09-4c99-b411-40af239c3c4d<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/7510346f-8b09-4c99-b411-40af239c3c4d.gif \"7510346f-8b09-4c99-b411-40af239c3c4d\")"},{"content":"In the previous figure, SelectStatement2 is shown as free floating because it was popped out of the stack, but not yet post processed by the parent.","pos":[10391,10539]},{"content":"It needs to be added to the FROM part of the parent, but it is not a complete SQL statement without a SELECT clause.","pos":[10540,10656]},{"content":"So, at this point, the default columns (all the columns produced by its inputs) are added to the select list by the method AddDefaultColumns.","pos":[10657,10798]},{"content":"AddDefaultColumns iterates over the symbols in FromExtents and for each symbol adds all the columns brought in scope.","pos":[10799,10916]},{"content":"For a simple symbol, it looks at the symbol type to retrieve all its properties to be added.","pos":[10917,11009]},{"content":"It also populates the AllColumnNames dictionary with the column names.","pos":[11010,11080]},{"content":"The completed SelectStatement2 is appended to the FROM clause of SelectStatement1.","pos":[11081,11163]},{"content":"Next, a new join symbol is created to represent Join2, it is marked as a nested join and added to the AllJoinExtents of SelectStatement1 and added to the symbol table.","pos":[11170,11337]},{"content":"Now the join condition of Join3, Var(Extent3).OrderID =  Var(Join2).Extent4.OrderID, needs to be processed.","pos":[11339,11446]},{"content":"Processing of the left hand side is similar to the join condition of Join1.","pos":[11447,11522]},{"content":"However, the processing of the right and side \"Var(Join2).Extent4.OrderID\" is different because join flattening is required.","pos":[11523,11647]},{"content":"The next figure shows the state of the visitor right before the DbPropertyExpression \"Var(Join2).Extent4.OrderID\" is processed.","pos":[11654,11781]},{"content":"Consider how \"Var(Join2).Extent4.OrderID\" is visited.","pos":[11788,11841]},{"content":"First, the instance property \"Var(Join2).Extent4\" is visited, which is another DbPropertyExpression and first visits its instance \"Var(Join2)\".","pos":[11842,11985]},{"content":"In the top most scope in the symbol table, \"Join2\" resolves to &lt;joinSymbol_join2&gt;.","pos":[11986,12068],"source":" In the top most scope in the symbol table, \"Join2\" resolves to <joinSymbol_join2>."},{"content":"In the visit method for DbPropertyExpression processing \"Var(Join2).Extent4\" notice that a join symbol was returned when visiting the instance and flattening is required.","pos":[12069,12239]},{"content":"Since it is a nested join, we look up the property \"Extent4\" in the NameToExtent dictionary of the join symbol, resolve it to &lt;symbol_Extent4&gt; and return a new SymbolPair(&lt;joinSymbol_join2&gt;, &lt;symbol_Extent4&gt;).","pos":[12246,12455],"source":"Since it is a nested join, we look up the property \"Extent4\" in the NameToExtent dictionary of the join symbol, resolve it to <symbol_Extent4> and return a new SymbolPair(<joinSymbol_join2>, <symbol_Extent4>)."},{"content":"Since a symbol pair is returned from the processing of the instance of \"Var(Join2).Extent4.OrderID\",  the property \"OrderID\" is resolved from the ColumnPart of that symbol pair (&lt;symbol_Extent4&gt;), which has a list of the columns of the extent it represents.","pos":[12456,12713],"source":" Since a symbol pair is returned from the processing of the instance of \"Var(Join2).Extent4.OrderID\",  the property \"OrderID\" is resolved from the ColumnPart of that symbol pair (<symbol_Extent4>), which has a list of the columns of the extent it represents."},{"content":"So, \"Var(Join2).Extent4.OrderID\" is resolved to { &lt;joinSymbol_Join2&gt;, \".\", &lt;symbol_OrderID&gt;}.","pos":[12714,12807],"source":" So, \"Var(Join2).Extent4.OrderID\" is resolved to { <joinSymbol_Join2>, \".\", <symbol_OrderID>}."},{"content":"The join condition of Join4 is similarly processed.","pos":[12814,12865]},{"content":"The control returns to the VisitInputExpression method that processed the top most project.","pos":[12866,12957]},{"content":"Looking at the FromExtents of the returned SelectStatement0, the input is identified as a join, and removes the original extents and replaces them with a new extent with just the Join symbol.","pos":[12958,13149]},{"content":"The symbol table is also updated and next the projection part of the Project is processed.","pos":[13150,13240]},{"content":"The resolving of the properties and the flattening of the join extents is as described earlier.","pos":[13241,13336]},{"pos":[13343,13485],"content":"<bpt id=\"p1\">![</bpt>Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/9456d6a9-ea2e-40ae-accc-a10e18e28b81.gif \"</bpt>9456d6a9-ea2e-40ae-accc-a10e18e28b81<ept id=\"p2\">\")</ept>","source":"![Diagram](../../../../../docs/framework/data/adonet/ef/media/9456d6a9-ea2e-40ae-accc-a10e18e28b81.gif \"9456d6a9-ea2e-40ae-accc-a10e18e28b81\")"},{"content":"Finally, the following SqlSelectStatement is produced:","pos":[13492,13546]},{"pos":[15652,15713],"content":"Second Phase of SQL Generation: Generating the String Command","linkify":"Second Phase of SQL Generation: Generating the String Command","nodes":[{"content":"Second Phase of SQL Generation: Generating the String Command","pos":[0,61]}]},{"content":"The second phase produces actual names for the symbols, and we only focus on the symbols representing columns named \"OrderID\", as in this case a conflict needs to be resolved.","pos":[15717,15892]},{"content":"These are highlighted in the SqlSelectStatement.","pos":[15893,15941]},{"content":"Note that the suffixes used in the figure are only to emphasize that these are different instances, not to represent any new names, as at this stage their final names (possibly different form the original names) have not been assigned yet.","pos":[15942,16181]},{"content":"The first symbol found that needs to be renamed is &lt;symbol_OrderID&gt;.","pos":[16188,16256],"source":"The first symbol found that needs to be renamed is <symbol_OrderID>."},{"content":"Its new name is assigned as \"OrderID1\", 1 is marked as the last used suffix for \"OrderID\" and the symbol is marked as not needing renaming.","pos":[16257,16396]},{"content":"Next, the first usage of &lt;symbol_OrderID_2&gt; is found.","pos":[16397,16450],"source":" Next, the first usage of <symbol_OrderID_2> is found."},{"content":"It is renamed to use the next available suffix (\"OrderID2\") and again marked as not needing renaming, so that next time it is used it does not get renamed.","pos":[16451,16606]},{"content":"This is done for &lt;symbol_OrderID_3&gt; too.","pos":[16607,16647],"source":" This is done for <symbol_OrderID_3> too."},{"content":"At the end of the second phase, the final SQL statement is generated.","pos":[16654,16723]},{"pos":[16732,16740],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[16744,16870],"content":"<bpt id=\"p1\">[</bpt>SQL Generation in the Sample Provider<ept id=\"p1\">](../../../../../docs/framework/data/adonet/ef/sql-generation-in-the-sample-provider.md)</ept>","source":"[SQL Generation in the Sample Provider](../../../../../docs/framework/data/adonet/ef/sql-generation-in-the-sample-provider.md)"}]}