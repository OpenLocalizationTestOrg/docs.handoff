{"content":"---\ntitle: \"WPF XAML Namescopes\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"namescopes [WPF]\"\n  - \"styles [WPF], namescopes in\"\n  - \"templates [WPF], namescopes in\"\n  - \"APIs [WPF], name-related\"\n  - \"name-related APIs\"\n  - \"XAML [WPF], namescopes\"\n  - \"classes [WPF], FrameworkContentElement\"\nms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4\n---\n# WPF XAML Namescopes\nXAML namescopes are a concept that identifies objects that are defined in XAML. The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree. Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application. XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.  \n\n<a name=\"Namescopes_in_Loaded_XAML_Applications\"></a>   \n## Namescopes in Loaded XAML Applications  \n In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object. For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced. These general principles are true for XAML namescopes. In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded. Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.  \n  \n In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope. If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.  \n  \n> [!NOTE]\n>  WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.  \n  \n If you try to use the same name twice in any XAML namescope, an exception is raised. For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile. For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded. XAML designers might also anticipate XAML namescope issues at design time.  \n  \n### Adding Objects to Runtime Object Trees  \n The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined. If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope. To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root. If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.  \n  \n The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page. <xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations. For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).  \n  \n If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.  \n  \n### XAML Namescopes in Code  \n You can create and then use XAML namescopes in code. The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself. The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.  \n  \n For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.  \n  \n Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default. You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently. To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method. Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.  \n  \n If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect. If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.  \n  \n For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).  \n  \n<a name=\"Namescopes_in_Styles_and_Templates\"></a>   \n## XAML Namescopes in Styles and Templates  \n Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way. However, styles and templates might also include elements with XAML names defined at the template level. That same template might be used multiple times in a page. For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.  \n  \n Consider the following example:  \n  \n [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  \n  \n Here, the same template is applied to two different buttons. If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope. Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.  \n  \n Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned. These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.  \n  \n Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page. You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied. Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.  \n  \n If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code. The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.  \n  \n If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there. An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.  \n  \n<a name=\"Namescopes_and_Name_related_APIs\"></a>   \n## XAML Namescopes and Name-related APIs  \n <xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods. If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope. Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root). <xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope. The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.  \n  \n <xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object. You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage. Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.  \n  \n### XAML Namescope Implementations  \n The following classes implement <xref:System.Windows.Markup.INameScope> directly:  \n  \n-   <xref:System.Windows.NameScope>  \n  \n-   <xref:System.Windows.Style>  \n  \n-   <xref:System.Windows.ResourceDictionary>  \n  \n-   <xref:System.Windows.FrameworkTemplate>  \n  \n <xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation. The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.  \n  \n <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions. The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes. But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.  \n  \n The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:  \n  \n-   <xref:System.Windows.FrameworkElement>  \n  \n-   <xref:System.Windows.FrameworkContentElement>  \n  \n## See also\n\n- [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)\n- [x:Name Directive](../../xaml-services/x-name-directive.md)\n","nodes":[{"pos":[4,348],"embed":true,"restype":"x-metadata","content":"title: \"WPF XAML Namescopes\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"namescopes [WPF]\"\n  - \"styles [WPF], namescopes in\"\n  - \"templates [WPF], namescopes in\"\n  - \"APIs [WPF], name-related\"\n  - \"name-related APIs\"\n  - \"XAML [WPF], namescopes\"\n  - \"classes [WPF], FrameworkContentElement\"\nms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4","nodes":[{"content":"WPF XAML Namescopes","nodes":[{"pos":[0,19],"content":"WPF XAML Namescopes","nodes":[{"content":"WPF XAML Namescopes","pos":[0,19]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[355,374],"content":"WPF XAML Namescopes","linkify":"WPF XAML Namescopes","nodes":[{"content":"WPF XAML Namescopes","pos":[0,19]}]},{"content":"XAML namescopes are a concept that identifies objects that are defined in XAML.","pos":[375,454]},{"content":"The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.","pos":[455,615]},{"content":"Typically, XAML namescopes in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> managed code are created when loading the individual XAML page roots for a XAML application.","pos":[616,820],"source":" Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application."},{"content":"XAML namescopes as the programming object are defined by the <ph id=\"ph1\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> interface and are also implemented by the practical class <ph id=\"ph2\">&lt;xref:System.Windows.NameScope&gt;</ph>.","pos":[821,1012],"source":" XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>."},{"pos":[1076,1114],"content":"Namescopes in Loaded XAML Applications","linkify":"Namescopes in Loaded XAML Applications","nodes":[{"content":"Namescopes in Loaded XAML Applications","pos":[0,38]}]},{"content":"In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.","pos":[1118,1289]},{"content":"For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.","pos":[1290,1528]},{"content":"These general principles are true for XAML namescopes.","pos":[1529,1583]},{"content":"In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.","pos":[1584,1680]},{"content":"Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.","pos":[1681,1787]},{"content":"In WPF XAML, elements that are common root elements (such as <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Page&gt;</ph>, and <ph id=\"ph2\">&lt;xref:System.Windows.Window&gt;</ph>) always control a XAML namescope.","pos":[1794,1958],"source":"In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope."},{"content":"If an element such as <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> is the root element of the page in markup, a <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> processor adds a <ph id=\"ph4\">&lt;xref:System.Windows.Controls.Page&gt;</ph> root implicitly so that the <ph id=\"ph5\">&lt;xref:System.Windows.Controls.Page&gt;</ph> can provide a working XAML namescope.","pos":[1959,2340],"source":" If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope."},{"pos":[2348,2578],"content":"[!NOTE]\n WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.","leadings":["","> "],"nodes":[{"content":"WPF build actions create a XAML namescope for a XAML production even if no <ph id=\"ph1\">`Name`</ph> or <ph id=\"ph2\">`x:Name`</ph> attributes are defined on any elements in the <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> markup.","pos":[9,228],"source":"WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup."}]},{"content":"If you try to use the same name twice in any XAML namescope, an exception is raised.","pos":[2585,2669]},{"content":"For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.","pos":[2670,2884]},{"content":"For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.","pos":[2885,3027]},{"content":"XAML designers might also anticipate XAML namescope issues at design time.","pos":[3028,3102]},{"pos":[3112,3150],"content":"Adding Objects to Runtime Object Trees","linkify":"Adding Objects to Runtime Object Trees","nodes":[{"content":"Adding Objects to Runtime Object Trees","pos":[0,38]}]},{"content":"The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.","pos":[3154,3264]},{"content":"If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a <ph id=\"ph1\">`Name`</ph> or <ph id=\"ph2\">`x:Name`</ph> value on the new object does not automatically update the information in a XAML namescope.","pos":[3265,3485],"source":" If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope."},{"content":"To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <ph id=\"ph1\">&lt;xref:System.Windows.Markup.INameScope.RegisterName%2A&gt;</ph> on the object that defines the XAML namescope, which is typically the XAML page root.","pos":[3486,3751],"source":" To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root."},{"content":"If the name is not registered, the added object cannot be referenced by name through methods such as <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, and you cannot use that name for animation targeting.","pos":[3752,3958],"source":" If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting."},{"content":"The most common scenario for application developers is that you will use <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> to register names into the XAML namescope on the current root of the page.","pos":[3965,4167],"source":"The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> is part of an important scenario for storyboards that target objects for animations.","pos":[4168,4307],"source":"<xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Storyboards Overview<ept id=\"p1\">](../graphics-multimedia/storyboards-overview.md)</ept>.","pos":[4308,4405],"source":" For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md)."},{"pos":[4412,4752],"content":"If you call <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> on the XAML namescope defining object.","source":"If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object."},{"pos":[4762,4785],"content":"XAML Namescopes in Code","linkify":"XAML Namescopes in Code","nodes":[{"content":"XAML Namescopes in Code","pos":[0,23]}]},{"content":"You can create and then use XAML namescopes in code.","pos":[4789,4841]},{"content":"The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> uses these APIs and concepts when it processes XAML itself.","pos":[4842,5117],"source":" The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself."},{"content":"The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.","pos":[5118,5284]},{"pos":[5291,5643],"content":"For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <ph id=\"ph1\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>, or be a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class, in order to support creation of a XAML namescope on its instances.","source":"For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances."},{"content":"Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.","pos":[5650,5801]},{"content":"You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.","pos":[5802,5917]},{"content":"To create a XAML namescope, you call the static <ph id=\"ph1\">&lt;xref:System.Windows.NameScope.SetNameScope%2A&gt;</ph> method.","pos":[5918,6021],"source":" To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method."},{"content":"Specify the object that will own it as the <ph id=\"ph1\">`dependencyObject`</ph> parameter, and a new <ph id=\"ph2\">&lt;xref:System.Windows.NameScope.%23ctor%2A&gt;</ph> constructor call as the <ph id=\"ph3\">`value`</ph> parameter.","pos":[6022,6190],"source":" Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter."},{"content":"If the object provided as <ph id=\"ph1\">`dependencyObject`</ph> for <ph id=\"ph2\">&lt;xref:System.Windows.NameScope.SetNameScope%2A&gt;</ph> is not a <ph id=\"ph3\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> implementation, <ph id=\"ph4\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id=\"ph5\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, calling <ph id=\"ph6\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> on any child elements will have no effect.","pos":[6197,6553],"source":"If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect."},{"content":"If you fail to create the new XAML namescope explicitly, then calls to <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> will raise an exception.","pos":[6554,6704],"source":" If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception."},{"pos":[6711,6844],"content":"For an example of using XAML namescope APIs in code, see <bpt id=\"p1\">[</bpt>Define a Name Scope<ept id=\"p1\">](../graphics-multimedia/how-to-define-a-name-scope.md)</ept>.","source":"For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md)."},{"pos":[6906,6945],"content":"XAML Namescopes in Styles and Templates","linkify":"XAML Namescopes in Styles and Templates","nodes":[{"content":"XAML Namescopes in Styles and Templates","pos":[0,39]}]},{"content":"Styles and templates in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provide the ability to reuse and reapply content in a straightforward way.","pos":[6949,7129],"source":"Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way."},{"content":"However, styles and templates might also include elements with XAML names defined at the template level.","pos":[7130,7234]},{"content":"That same template might be used multiple times in a page.","pos":[7235,7293]},{"content":"For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.","pos":[7294,7461]},{"content":"Consider the following example:","pos":[7468,7499]},{"content":"Here, the same template is applied to two different buttons.","pos":[7655,7715]},{"content":"If templates did not have discrete XAML namescopes, the <ph id=\"ph1\">`TheBorder`</ph> name used in the template would cause a name collision in the XAML namescope.","pos":[7716,7861],"source":" If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope."},{"content":"Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.","pos":[7862,8019]},{"content":"Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.","pos":[8026,8142]},{"content":"These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.","pos":[8143,8298]},{"content":"Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.","pos":[8305,8456]},{"content":"You first need to determine the applied template, by getting the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Template%2A&gt;</ph> property value of the control where the template is applied.","pos":[8457,8633],"source":" You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied."},{"content":"Then, you call the template version of <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A&gt;</ph>, passing the control where the template was applied as the second parameter.","pos":[8634,8801],"source":" Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter."},{"content":"If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph> method from your control implementation code.","pos":[8808,9116],"source":"If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph> method is protected, so only the control author has access to it.","pos":[9117,9245],"source":" The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it."},{"content":"If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph>, and then call <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph> there.","pos":[9252,9511],"source":"If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there."},{"content":"An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.","pos":[9512,9685]},{"pos":[9745,9782],"content":"XAML Namescopes and Name-related APIs","linkify":"XAML Namescopes and Name-related APIs","nodes":[{"content":"XAML Namescopes and Name-related APIs","pos":[0,37]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> has <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Windows.FrameworkElement.UnregisterName%2A&gt;</ph> methods.","pos":[9786,10005],"source":"<xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods."},{"content":"If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.","pos":[10006,10134]},{"content":"Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).","pos":[10135,10380]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> has analogous behaviors, with the exception that no <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> will ever own a XAML namescope.","pos":[10381,10556],"source":"<xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope."},{"content":"The methods exist on <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> so that the calls can be forwarded eventually to a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element.","pos":[10557,10729],"source":" The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.NameScope.SetNameScope%2A&gt;</ph> is used to map a new XAML namescope to an existing object.","pos":[10736,10842],"source":"<xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object."},{"content":"You can call <ph id=\"ph1\">&lt;xref:System.Windows.NameScope.SetNameScope%2A&gt;</ph> more than once in order to reset or clear the XAML namescope, but that is not a common usage.","pos":[10843,10997],"source":" You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage."},{"content":"Also, <ph id=\"ph1\">&lt;xref:System.Windows.NameScope.GetNameScope%2A&gt;</ph> is not typically used from code.","pos":[10998,11084],"source":" Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code."},{"pos":[11094,11124],"content":"XAML Namescope Implementations","linkify":"XAML Namescope Implementations","nodes":[{"content":"XAML Namescope Implementations","pos":[0,30]}]},{"pos":[11128,11209],"content":"The following classes implement <ph id=\"ph1\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> directly:","source":"The following classes implement <xref:System.Windows.Markup.INameScope> directly:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.","pos":[11393,11538],"source":"<xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation."},{"content":"The only reason that <ph id=\"ph1\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> implements <ph id=\"ph2\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <ph id=\"ph3\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> handles keys, and also to assure that XAML namescopes are not applied to a <ph id=\"ph4\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> by parent elements.","pos":[11539,11945],"source":" The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph> implement <ph id=\"ph3\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> through explicit interface definitions.","pos":[11952,12113],"source":"<xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions."},{"content":"The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <ph id=\"ph1\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> interface, which is how XAML namescopes are communicated by <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> internal processes.","pos":[12114,12432],"source":" The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes."},{"content":"But the explicit interface definitions are not part of the conventional API surface of <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph>, because you seldom need to call the <ph id=\"ph3\">&lt;xref:System.Windows.Markup.INameScope&gt;</ph> methods on <ph id=\"ph4\">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Windows.Style&gt;</ph> directly, and instead would use other API such as <ph id=\"ph6\">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph>.","pos":[12433,12861],"source":" But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>."},{"pos":[12868,13166],"content":"The following classes define their own XAML namescope, by using the <ph id=\"ph1\">&lt;xref:System.Windows.NameScope?displayProperty=nameWithType&gt;</ph> helper class and connecting to its XAML namescope implementation through the <ph id=\"ph2\">&lt;xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType&gt;</ph> attached property:","source":"The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:"},{"pos":[13278,13286],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13290,13397],"content":"<bpt id=\"p1\">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id=\"p1\">](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>","source":"[XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)"},{"pos":[13400,13459],"content":"<bpt id=\"p1\">[</bpt>x:Name Directive<ept id=\"p1\">](../../xaml-services/x-name-directive.md)</ept>","source":"[x:Name Directive](../../xaml-services/x-name-directive.md)"}]}