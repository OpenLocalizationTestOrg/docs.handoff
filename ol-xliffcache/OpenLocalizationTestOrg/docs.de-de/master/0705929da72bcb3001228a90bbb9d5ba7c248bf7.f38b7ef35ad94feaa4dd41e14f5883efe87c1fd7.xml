{"content":"---\ntitle: \"Extension Methods (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\nf1_keywords: \n  - \"vb.ExtensionMethods\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"extending data types\"\n  - \"extension methods [Visual Basic]\"\nms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6\ncaps.latest.revision: 41\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Extension Methods (Visual Basic)\nExtension methods enable developers to add custom functionality to data types that are already defined without creating a new derived type. Extension methods make it possible to write a method that can be called as if it were an instance method of the existing type.  \n  \n## Remarks  \n An extension method can be only a `Sub` procedure or a `Function` procedure. You cannot define an extension property, field, or event. All extension methods must be marked with the extension attribute `<Extension()>` from the <xref:System.Runtime.CompilerServices?displayProperty=fullName> namespace.  \n  \n The first parameter in an extension method definition specifies which data type the method extends. When the method is run, the first parameter is bound to the instance of the data type that invokes the method.  \n  \n## Example  \n  \n### Description  \n The following example defines a `Print` extension to the <xref:System.String> data type. The method uses `Console.WriteLine` to display a string. The parameter of the `Print` method, `aString`, establishes that the method extends the <xref:System.String> class.  \n  \n [!code-vb[VbVbalrExtensionMethods#1](./codesnippet/VisualBasic/extension-methods_1.vb)]  \n  \n Notice that the extension method definition is marked with the extension attribute `<Extension()>`. Marking the module in which the method is defined is optional, but each extension method must be marked. <xref:System.Runtime.CompilerServices> must be imported in order to access the extension attribute.  \n  \n Extension methods can be declared only within modules. Typically, the module in which an extension method is defined is not the same module as the one in which it is called. Instead, the module that contains the extension method is imported, if it needs to be, to bring it into scope. After the module that contains `Print` is in scope, the method can be called as if it were an ordinary instance method that takes no arguments, such as `ToUpper`:  \n  \n [!code-vb[VbVbalrExtensionMethods#2](./codesnippet/VisualBasic/extension-methods_2.vb)]  \n  \n The next example, `PrintAndPunctuate`, is also an extension to <xref:System.String>, this time defined with two parameters. The first parameter, `aString`, establishes that the extension method extends <xref:System.String>. The second parameter, `punc`, is intended to be a string of punctuation marks that is passed in as an argument when the method is called. The method displays the string followed by the punctuation marks.  \n  \n [!code-vb[VbVbalrExtensionMethods#3](./codesnippet/VisualBasic/extension-methods_3.vb)]  \n  \n The method is called by sending in a string argument for `punc`: `example.PrintAndPunctuate(\".\")`  \n  \n The following example shows `Print` and `PrintAndPunctuate` defined and called. <xref:System.Runtime.CompilerServices> is imported in the definition module in order to enable access to the extension attribute.  \n  \n### Code  \n  \n```vb  \nImports System.Runtime.CompilerServices  \n  \nModule StringExtensions  \n  \n    <Extension()>   \n    Public Sub Print(ByVal aString As String)  \n        Console.WriteLine(aString)  \n    End Sub  \n  \n    <Extension()>   \n    Public Sub PrintAndPunctuate(ByVal aString As String,   \n                                 ByVal punc As String)  \n        Console.WriteLine(aString & punc)  \n    End Sub  \n  \nEnd Module  \n```  \n  \n Next, the extension methods are brought into scope and called.  \n  \n```vb  \nImports ConsoleApplication2.StringExtensions  \nModule Module1  \n  \n    Sub Main()  \n  \n        Dim example As String = \"Example string\"  \n        example.Print()  \n  \n        example = \"Hello\"  \n        example.PrintAndPunctuate(\".\")  \n        example.PrintAndPunctuate(\"!!!!\")  \n  \n    End Sub  \nEnd Module  \n```  \n  \n### Comments  \n All that is required to be able to run these or similar extension methods is that they be in scope. If the module that contains an extension method is in scope, it is visible in IntelliSense and can be called as if it were an ordinary instance method.  \n  \n Notice that when the methods are invoked, no argument is sent in for the first parameter. Parameter `aString` in the previous method definitions is bound to `example`, the instance of `String` that calls them. The compiler will use `example` as the argument sent to the first parameter.  \n  \n If an extension method is called for an object that is set to `Nothing`, the extension method executes. This does not apply to ordinary instance methods. You can explicitly check for `Nothing` in the extension method.  \n  \n## Types That Can Be Extended  \n You can define an extension method on most types that can be represented in a Visual Basic parameter list, including the following:  \n  \n-   Classes (reference types)  \n  \n-   Structures (value types)  \n  \n-   Interfaces  \n  \n-   Delegates  \n  \n-   ByRef and ByVal arguments  \n  \n-   Generic method parameters  \n  \n-   Arrays  \n  \n Because the first parameter specifies the data type that the extension method extends, it is required and cannot be optional. For that reason, `Optional` parameters and `ParamArray` parameters cannot be the first parameter in the parameter list.  \n  \n Extension methods are not considered in late binding. In the following example, the statement `anObject.PrintMe()` raises a <xref:System.MissingMemberException> exception, the same exception you would see if the second `PrintMe` extension method definition were deleted.  \n  \n [!code-vb[VbVbalrExtensionMethods#9](./codesnippet/VisualBasic/extension-methods_4.vb)]  \n  \n## Best Practices  \n Extension methods provide a convenient and powerful way to extend an existing type. However, to use them successfully, there are some points to consider. These considerations apply mainly to authors of class libraries, but they might affect any application that uses extension methods.  \n  \n Most generally, extension methods that you add to types that you do not own are more vulnerable than extension methods added to types that you control. A number of things can occur in classes you do not own that can interfere with your extension methods.  \n  \n-   If any accessible instance member exists that has a signature that is compatible with the arguments in the calling statement, with no narrowing conversions required from argument to parameter, the instance method will be used in preference to any extension method. Therefore, if an appropriate instance method is added to a class at some point, an existing extension member that you rely on may become inaccessible.  \n  \n-   The author of an extension method cannot prevent other programmers from writing conflicting extension methods that may have precedence over the original extension.  \n  \n-   You can improve robustness by putting extension methods in their own namespace. Consumers of your library can then include a namespace or exclude it, or select among namespaces, separately from the rest of the library.  \n  \n-   It may be safer to extend interfaces than it is to extend classes, especially if you do not own the interface or class. A change in an interface affects every class that implements it. Therefore, the author may be less likely to add or change methods in an interface. However, if a class implements two interfaces that have extension methods with the same signature, neither extension method is visible.  \n  \n-   Extend the most specific type you can. In a hierarchy of types, if you select a type from which many other types are derived, there are layers of possibilities for the introduction of instance methods or other extension methods that might interfere with yours.  \n  \n## Extension Methods, Instance Methods, and Properties  \n When an in-scope instance method has a signature that is compatible with the arguments of a calling statement, the instance method is chosen in preference to any extension method. The instance method has precedence even if the extension method is a better match. In the following example, `ExampleClass` contains an instance method named `ExampleMethod` that has one parameter of type `Integer`. Extension method `ExampleMethod` extends `ExampleClass`, and has one parameter of type `Long`.  \n  \n [!code-vb[VbVbalrExtensionMethods#4](./codesnippet/VisualBasic/extension-methods_5.vb)]  \n  \n The first call to `ExampleMethod` in the following code calls the extension method, because `arg1` is `Long` and is compatible only with the `Long` parameter in the extension method. The second call to `ExampleMethod` has an `Integer` argument, `arg2`, and it calls the instance method.  \n  \n [!code-vb[VbVbalrExtensionMethods#5](./codesnippet/VisualBasic/extension-methods_6.vb)]  \n  \n Now reverse the data types of the parameters in the two methods:  \n  \n [!code-vb[VbVbalrExtensionMethods#6](./codesnippet/VisualBasic/extension-methods_7.vb)]  \n  \n This time the code in `Main` calls the instance method both times. This is because both `arg1` and `arg2` have a widening conversion to `Long`, and the instance method takes precedence over the extension method in both cases.  \n  \n [!code-vb[VbVbalrExtensionMethods#7](./codesnippet/VisualBasic/extension-methods_8.vb)]  \n  \n Therefore, an extension method cannot replace an existing instance method. However, when an extension method has the same name as an instance method but the signatures do not conflict, both methods can be accessed. For example, if class `ExampleClass` contains a method named `ExampleMethod` that takes no arguments, extension methods with the same name but different signatures are permitted, as shown in the following code.  \n  \n [!code-vb[VbVbalrExtensionMethods#8](./codesnippet/VisualBasic/extension-methods_9.vb)]  \n  \n The output from this code is as follows:  \n  \n `Extension method`  \n  \n `Instance method`  \n  \n The situation is simpler with properties: if an extension method has the same name as a property of the class it extends, the extension method is not visible and cannot be accessed.  \n  \n## Extension Method Precedence  \n When two extension methods that have identical signatures are in scope and accessible, the one with higher precedence will be invoked. An extension method's precedence is based on the mechanism used to bring the method into scope. The following list shows the precedence hierarchy, from highest to lowest.  \n  \n1.  Extension methods defined inside the current module.  \n  \n2.  Extension methods defined inside data types in the current namespace or any one of its parents, with child namespaces having higher precedence than parent namespaces.  \n  \n3.  Extension methods defined inside any type imports in the current file.  \n  \n4.  Extension methods defined inside any namespace imports in the current file.  \n  \n5.  Extension methods defined inside any project-level type imports.  \n  \n6.  Extension methods defined inside any project-level namespace imports.  \n  \n If precedence does not resolve the ambiguity, you can use the fully qualified name to specify the method that you are calling. If the `Print` method in the earlier example is defined in a module named `StringExtensions`, the fully qualified name is `StringExtensions.Print(example)` instead of `example.Print()`.  \n  \n## See Also  \n <xref:System.Runtime.CompilerServices>   \n <xref:System.Runtime.CompilerServices.ExtensionAttribute>   \n [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)   \n [Module Statement](../../../../visual-basic/language-reference/statements/module-statement.md)   \n [Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md)   \n [Optional Parameters](./optional-parameters.md)   \n [Parameter Arrays](./parameter-arrays.md)   \n [Attributes overview](../../../../visual-basic/programming-guide/concepts/attributes/index.md)   \n [Scope in Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)","nodes":[{"pos":[4,681],"nodes":[{"content":"Extension Methods (Visual Basic) | Microsoft Docs","nodes":[{"pos":[0,49],"content":"Extension Methods (Visual Basic) | Microsoft Docs","nodes":[{"content":"Extension Methods (Visual Basic) | Microsoft Docs","pos":[0,49]}]}],"pos":[6,58],"yaml":true}],"content":"title: \"Extension Methods (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\nf1_keywords: \n  - \"vb.ExtensionMethods\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"extending data types\"\n  - \"extension methods [Visual Basic]\"\nms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6\ncaps.latest.revision: 41\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","yamlblock":true},{"pos":[688,720],"content":"Extension Methods (Visual Basic)","linkify":"Extension Methods (Visual Basic)","nodes":[{"content":"Extension Methods (Visual Basic)","pos":[0,32]}]},{"content":"Extension methods enable developers to add custom functionality to data types that are already defined without creating a new derived type.","pos":[721,860]},{"content":"Extension methods make it possible to write a method that can be called as if it were an instance method of the existing type.","pos":[861,987]},{"pos":[996,1003],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"An extension method can be only a <ph id=\"ph1\">`Sub`</ph> procedure or a <ph id=\"ph2\">`Function`</ph> procedure.","pos":[1007,1083],"source":"An extension method can be only a `Sub` procedure or a `Function` procedure."},{"content":"You cannot define an extension property, field, or event.","pos":[1084,1141]},{"content":"All extension methods must be marked with the extension attribute <ph id=\"ph1\">`&lt;Extension()&gt;`</ph> from the <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices?displayProperty=fullName&gt;</ph> namespace.","pos":[1142,1307],"source":" All extension methods must be marked with the extension attribute `<Extension()>` from the <xref:System.Runtime.CompilerServices?displayProperty=fullName> namespace."},{"content":"The first parameter in an extension method definition specifies which data type the method extends.","pos":[1314,1413]},{"content":"When the method is run, the first parameter is bound to the instance of the data type that invokes the method.","pos":[1414,1524]},{"pos":[1533,1540],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[1550,1561],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"content":"The following example defines a <ph id=\"ph1\">`Print`</ph> extension to the <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> data type.","pos":[1565,1653],"source":"The following example defines a `Print` extension to the <xref:System.String> data type."},{"content":"The method uses <ph id=\"ph1\">`Console.WriteLine`</ph> to display a string.","pos":[1654,1710],"source":" The method uses `Console.WriteLine` to display a string."},{"content":"The parameter of the <ph id=\"ph1\">`Print`</ph> method, <ph id=\"ph2\">`aString`</ph>, establishes that the method extends the <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> class.","pos":[1711,1826],"source":" The parameter of the `Print` method, `aString`, establishes that the method extends the <xref:System.String> class."},{"pos":[1833,1920],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#1<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_1.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#1](./codesnippet/VisualBasic/extension-methods_1.vb)]"},{"content":"Notice that the extension method definition is marked with the extension attribute <ph id=\"ph1\">`&lt;Extension()&gt;`</ph>.","pos":[1927,2026],"source":"Notice that the extension method definition is marked with the extension attribute `<Extension()>`."},{"content":"Marking the module in which the method is defined is optional, but each extension method must be marked.","pos":[2027,2131]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices&gt;</ph> must be imported in order to access the extension attribute.","pos":[2132,2231],"source":" <xref:System.Runtime.CompilerServices> must be imported in order to access the extension attribute."},{"content":"Extension methods can be declared only within modules.","pos":[2238,2292]},{"content":"Typically, the module in which an extension method is defined is not the same module as the one in which it is called.","pos":[2293,2411]},{"content":"Instead, the module that contains the extension method is imported, if it needs to be, to bring it into scope.","pos":[2412,2522]},{"content":"After the module that contains <ph id=\"ph1\">`Print`</ph> is in scope, the method can be called as if it were an ordinary instance method that takes no arguments, such as <ph id=\"ph2\">`ToUpper`</ph>:","pos":[2523,2685],"source":" After the module that contains `Print` is in scope, the method can be called as if it were an ordinary instance method that takes no arguments, such as `ToUpper`:"},{"pos":[2692,2779],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#2<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_2.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#2](./codesnippet/VisualBasic/extension-methods_2.vb)]"},{"content":"The next example, <ph id=\"ph1\">`PrintAndPunctuate`</ph>, is also an extension to <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, this time defined with two parameters.","pos":[2786,2909],"source":"The next example, `PrintAndPunctuate`, is also an extension to <xref:System.String>, this time defined with two parameters."},{"content":"The first parameter, <ph id=\"ph1\">`aString`</ph>, establishes that the extension method extends <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>.","pos":[2910,3009],"source":" The first parameter, `aString`, establishes that the extension method extends <xref:System.String>."},{"content":"The second parameter, <ph id=\"ph1\">`punc`</ph>, is intended to be a string of punctuation marks that is passed in as an argument when the method is called.","pos":[3010,3147],"source":" The second parameter, `punc`, is intended to be a string of punctuation marks that is passed in as an argument when the method is called."},{"content":"The method displays the string followed by the punctuation marks.","pos":[3148,3213]},{"pos":[3220,3307],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#3<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_3.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#3](./codesnippet/VisualBasic/extension-methods_3.vb)]"},{"pos":[3314,3411],"content":"The method is called by sending in a string argument for <ph id=\"ph1\">`punc`</ph>: <ph id=\"ph2\">`example.PrintAndPunctuate(\".\")`</ph>","source":"The method is called by sending in a string argument for `punc`: `example.PrintAndPunctuate(\".\")`"},{"content":"The following example shows <ph id=\"ph1\">`Print`</ph> and <ph id=\"ph2\">`PrintAndPunctuate`</ph> defined and called.","pos":[3418,3497],"source":"The following example shows `Print` and `PrintAndPunctuate` defined and called."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices&gt;</ph> is imported in the definition module in order to enable access to the extension attribute.","pos":[3498,3627],"source":" <xref:System.Runtime.CompilerServices> is imported in the definition module in order to enable access to the extension attribute."},{"pos":[3637,3641],"content":"Code","linkify":"Code","nodes":[{"content":"Code","pos":[0,4]}]},{"content":"Next, the extension methods are brought into scope and called.","pos":[4075,4137]},{"pos":[4474,4482],"content":"Comments","linkify":"Comments","nodes":[{"content":"Comments","pos":[0,8]}]},{"content":"All that is required to be able to run these or similar extension methods is that they be in scope.","pos":[4486,4585]},{"content":"If the module that contains an extension method is in scope, it is visible in IntelliSense and can be called as if it were an ordinary instance method.","pos":[4586,4737]},{"content":"Notice that when the methods are invoked, no argument is sent in for the first parameter.","pos":[4744,4833]},{"content":"Parameter <ph id=\"ph1\">`aString`</ph> in the previous method definitions is bound to <ph id=\"ph2\">`example`</ph>, the instance of <ph id=\"ph3\">`String`</ph> that calls them.","pos":[4834,4953],"source":" Parameter `aString` in the previous method definitions is bound to `example`, the instance of `String` that calls them."},{"content":"The compiler will use <ph id=\"ph1\">`example`</ph> as the argument sent to the first parameter.","pos":[4954,5030],"source":" The compiler will use `example` as the argument sent to the first parameter."},{"content":"If an extension method is called for an object that is set to <ph id=\"ph1\">`Nothing`</ph>, the extension method executes.","pos":[5037,5140],"source":"If an extension method is called for an object that is set to `Nothing`, the extension method executes."},{"content":"This does not apply to ordinary instance methods.","pos":[5141,5190]},{"content":"You can explicitly check for <ph id=\"ph1\">`Nothing`</ph> in the extension method.","pos":[5191,5254],"source":" You can explicitly check for `Nothing` in the extension method."},{"pos":[5263,5289],"content":"Types That Can Be Extended","linkify":"Types That Can Be Extended","nodes":[{"content":"Types That Can Be Extended","pos":[0,26]}]},{"content":"You can define an extension method on most types that can be represented in a Visual Basic parameter list, including the following:","pos":[5293,5424]},{"content":"Classes (reference types)","pos":[5434,5459]},{"content":"Structures (value types)","pos":[5469,5493]},{"content":"Interfaces","pos":[5503,5513]},{"content":"Delegates","pos":[5523,5532]},{"content":"ByRef and ByVal arguments","pos":[5542,5567]},{"content":"Generic method parameters","pos":[5577,5602]},{"content":"Arrays","pos":[5612,5618]},{"content":"Because the first parameter specifies the data type that the extension method extends, it is required and cannot be optional.","pos":[5625,5750]},{"content":"For that reason, <ph id=\"ph1\">`Optional`</ph> parameters and <ph id=\"ph2\">`ParamArray`</ph> parameters cannot be the first parameter in the parameter list.","pos":[5751,5870],"source":" For that reason, `Optional` parameters and `ParamArray` parameters cannot be the first parameter in the parameter list."},{"content":"Extension methods are not considered in late binding.","pos":[5877,5930]},{"content":"In the following example, the statement <ph id=\"ph1\">`anObject.PrintMe()`</ph> raises a <ph id=\"ph2\">&lt;xref:System.MissingMemberException&gt;</ph> exception, the same exception you would see if the second <ph id=\"ph3\">`PrintMe`</ph> extension method definition were deleted.","pos":[5931,6147],"source":" In the following example, the statement `anObject.PrintMe()` raises a <xref:System.MissingMemberException> exception, the same exception you would see if the second `PrintMe` extension method definition were deleted."},{"pos":[6154,6241],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#9<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_4.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#9](./codesnippet/VisualBasic/extension-methods_4.vb)]"},{"pos":[6250,6264],"content":"Best Practices","linkify":"Best Practices","nodes":[{"content":"Best Practices","pos":[0,14]}]},{"content":"Extension methods provide a convenient and powerful way to extend an existing type.","pos":[6268,6351]},{"content":"However, to use them successfully, there are some points to consider.","pos":[6352,6421]},{"content":"These considerations apply mainly to authors of class libraries, but they might affect any application that uses extension methods.","pos":[6422,6553]},{"content":"Most generally, extension methods that you add to types that you do not own are more vulnerable than extension methods added to types that you control.","pos":[6560,6711]},{"content":"A number of things can occur in classes you do not own that can interfere with your extension methods.","pos":[6712,6814]},{"content":"If any accessible instance member exists that has a signature that is compatible with the arguments in the calling statement, with no narrowing conversions required from argument to parameter, the instance method will be used in preference to any extension method.","pos":[6824,7088]},{"content":"Therefore, if an appropriate instance method is added to a class at some point, an existing extension member that you rely on may become inaccessible.","pos":[7089,7239]},{"content":"The author of an extension method cannot prevent other programmers from writing conflicting extension methods that may have precedence over the original extension.","pos":[7249,7412]},{"content":"You can improve robustness by putting extension methods in their own namespace.","pos":[7422,7501]},{"content":"Consumers of your library can then include a namespace or exclude it, or select among namespaces, separately from the rest of the library.","pos":[7502,7640]},{"content":"It may be safer to extend interfaces than it is to extend classes, especially if you do not own the interface or class.","pos":[7650,7769]},{"content":"A change in an interface affects every class that implements it.","pos":[7770,7834]},{"content":"Therefore, the author may be less likely to add or change methods in an interface.","pos":[7835,7917]},{"content":"However, if a class implements two interfaces that have extension methods with the same signature, neither extension method is visible.","pos":[7918,8053]},{"content":"Extend the most specific type you can.","pos":[8063,8101]},{"content":"In a hierarchy of types, if you select a type from which many other types are derived, there are layers of possibilities for the introduction of instance methods or other extension methods that might interfere with yours.","pos":[8102,8323]},{"pos":[8332,8383],"content":"Extension Methods, Instance Methods, and Properties","linkify":"Extension Methods, Instance Methods, and Properties","nodes":[{"content":"Extension Methods, Instance Methods, and Properties","pos":[0,51]}]},{"content":"When an in-scope instance method has a signature that is compatible with the arguments of a calling statement, the instance method is chosen in preference to any extension method.","pos":[8387,8566]},{"content":"The instance method has precedence even if the extension method is a better match.","pos":[8567,8649]},{"content":"In the following example, <ph id=\"ph1\">`ExampleClass`</ph> contains an instance method named <ph id=\"ph2\">`ExampleMethod`</ph> that has one parameter of type <ph id=\"ph3\">`Integer`</ph>.","pos":[8650,8782],"source":" In the following example, `ExampleClass` contains an instance method named `ExampleMethod` that has one parameter of type `Integer`."},{"content":"Extension method <ph id=\"ph1\">`ExampleMethod`</ph> extends <ph id=\"ph2\">`ExampleClass`</ph>, and has one parameter of type <ph id=\"ph3\">`Long`</ph>.","pos":[8783,8877],"source":" Extension method `ExampleMethod` extends `ExampleClass`, and has one parameter of type `Long`."},{"pos":[8884,8971],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#4<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_5.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#4](./codesnippet/VisualBasic/extension-methods_5.vb)]"},{"content":"The first call to <ph id=\"ph1\">`ExampleMethod`</ph> in the following code calls the extension method, because <ph id=\"ph2\">`arg1`</ph> is <ph id=\"ph3\">`Long`</ph> and is compatible only with the <ph id=\"ph4\">`Long`</ph> parameter in the extension method.","pos":[8978,9160],"source":"The first call to `ExampleMethod` in the following code calls the extension method, because `arg1` is `Long` and is compatible only with the `Long` parameter in the extension method."},{"content":"The second call to <ph id=\"ph1\">`ExampleMethod`</ph> has an <ph id=\"ph2\">`Integer`</ph> argument, <ph id=\"ph3\">`arg2`</ph>, and it calls the instance method.","pos":[9161,9264],"source":" The second call to `ExampleMethod` has an `Integer` argument, `arg2`, and it calls the instance method."},{"pos":[9271,9358],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#5<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_6.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#5](./codesnippet/VisualBasic/extension-methods_6.vb)]"},{"content":"Now reverse the data types of the parameters in the two methods:","pos":[9365,9429]},{"pos":[9436,9523],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#6<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_7.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#6](./codesnippet/VisualBasic/extension-methods_7.vb)]"},{"content":"This time the code in <ph id=\"ph1\">`Main`</ph> calls the instance method both times.","pos":[9530,9596],"source":"This time the code in `Main` calls the instance method both times."},{"content":"This is because both <ph id=\"ph1\">`arg1`</ph> and <ph id=\"ph2\">`arg2`</ph> have a widening conversion to <ph id=\"ph3\">`Long`</ph>, and the instance method takes precedence over the extension method in both cases.","pos":[9597,9755],"source":" This is because both `arg1` and `arg2` have a widening conversion to `Long`, and the instance method takes precedence over the extension method in both cases."},{"pos":[9762,9849],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#7<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_8.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#7](./codesnippet/VisualBasic/extension-methods_8.vb)]"},{"content":"Therefore, an extension method cannot replace an existing instance method.","pos":[9856,9930]},{"content":"However, when an extension method has the same name as an instance method but the signatures do not conflict, both methods can be accessed.","pos":[9931,10070]},{"content":"For example, if class <ph id=\"ph1\">`ExampleClass`</ph> contains a method named <ph id=\"ph2\">`ExampleMethod`</ph> that takes no arguments, extension methods with the same name but different signatures are permitted, as shown in the following code.","pos":[10071,10281],"source":" For example, if class `ExampleClass` contains a method named `ExampleMethod` that takes no arguments, extension methods with the same name but different signatures are permitted, as shown in the following code."},{"pos":[10288,10375],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrExtensionMethods#8<ept id=\"p2\">](./codesnippet/VisualBasic/extension-methods_9.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrExtensionMethods#8](./codesnippet/VisualBasic/extension-methods_9.vb)]"},{"content":"The output from this code is as follows:","pos":[10382,10422]},{"content":"The situation is simpler with properties: if an extension method has the same name as a property of the class it extends, the extension method is not visible and cannot be accessed.","pos":[10478,10659]},{"pos":[10668,10695],"content":"Extension Method Precedence","linkify":"Extension Method Precedence","nodes":[{"content":"Extension Method Precedence","pos":[0,27]}]},{"content":"When two extension methods that have identical signatures are in scope and accessible, the one with higher precedence will be invoked.","pos":[10699,10833]},{"content":"An extension method's precedence is based on the mechanism used to bring the method into scope.","pos":[10834,10929]},{"content":"The following list shows the precedence hierarchy, from highest to lowest.","pos":[10930,11004]},{"content":"Extension methods defined inside the current module.","pos":[11014,11066]},{"content":"Extension methods defined inside data types in the current namespace or any one of its parents, with child namespaces having higher precedence than parent namespaces.","pos":[11076,11242]},{"content":"Extension methods defined inside any type imports in the current file.","pos":[11252,11322]},{"content":"Extension methods defined inside any namespace imports in the current file.","pos":[11332,11407]},{"content":"Extension methods defined inside any project-level type imports.","pos":[11417,11481]},{"content":"Extension methods defined inside any project-level namespace imports.","pos":[11491,11560]},{"content":"If precedence does not resolve the ambiguity, you can use the fully qualified name to specify the method that you are calling.","pos":[11567,11693]},{"content":"If the <ph id=\"ph1\">`Print`</ph> method in the earlier example is defined in a module named <ph id=\"ph2\">`StringExtensions`</ph>, the fully qualified name is <ph id=\"ph3\">`StringExtensions.Print(example)`</ph> instead of <ph id=\"ph4\">`example.Print()`</ph>.","pos":[11694,11879],"source":" If the `Print` method in the earlier example is defined in a module named `StringExtensions`, the fully qualified name is `StringExtensions.Print(example)` instead of `example.Print()`."},{"pos":[11888,11896],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices&gt;</ph>","pos":[11900,11938],"source":"<xref:System.Runtime.CompilerServices> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.ExtensionAttribute&gt;</ph>","pos":[11943,12000],"source":"<xref:System.Runtime.CompilerServices.ExtensionAttribute> "},{"content":"<bpt id=\"p1\">[</bpt>Extension Methods<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept><ph id=\"ph1\"> </ph>","pos":[12005,12104],"source":"[Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md) "},{"content":"<bpt id=\"p1\">[</bpt>Module Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/module-statement.md)</ept><ph id=\"ph1\"> </ph>","pos":[12108,12203],"source":"[Module Statement](../../../../visual-basic/language-reference/statements/module-statement.md) "},{"content":"<bpt id=\"p1\">[</bpt>Procedure Parameters and Arguments<ept id=\"p1\">](./procedure-parameters-and-arguments.md)</ept><ph id=\"ph1\"> </ph>","pos":[12207,12285],"source":"[Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md) "},{"content":"<bpt id=\"p1\">[</bpt>Optional Parameters<ept id=\"p1\">](./optional-parameters.md)</ept><ph id=\"ph1\"> </ph>","pos":[12289,12337],"source":"[Optional Parameters](./optional-parameters.md) "},{"content":"<bpt id=\"p1\">[</bpt>Parameter Arrays<ept id=\"p1\">](./parameter-arrays.md)</ept><ph id=\"ph1\"> </ph>","pos":[12341,12383],"source":"[Parameter Arrays](./parameter-arrays.md) "},{"content":"<bpt id=\"p1\">[</bpt>Attributes overview<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/attributes/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[12387,12482],"source":"[Attributes overview](../../../../visual-basic/programming-guide/concepts/attributes/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Scope in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)</ept>","pos":[12486,12598],"source":"[Scope in Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)"}]}