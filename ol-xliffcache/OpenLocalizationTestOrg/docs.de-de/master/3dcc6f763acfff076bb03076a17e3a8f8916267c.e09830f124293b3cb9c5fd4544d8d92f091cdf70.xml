{"content":"---\ntitle: \"Implementing Business Logic (LINQ to SQL)\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: c4577590-7b12-42e1-84a6-95aa2562727e\n---\n# Implementing Business Logic (LINQ to SQL)\nThe term \"business logic\" in this topic refers to any custom rules or validation tests that you apply to data before it is inserted, updated or deleted from the database. Business logic is also sometimes referred to as \"business rules\" or \"domain logic.\" In n-tier applications it is typically designed as a logical layer so that it can be modified independently of the presentation layer or data access layer. The business logic can be invoked by the data access layer before or after any update, insertion, or deletion of data in the database.  \n  \n The business logic can be as simple as a schema validation to make sure that the type of the field is compatible with the type of the table column. Or it can consist of a set of objects that interact in arbitrarily complex ways. The rules may be implemented as stored procedures on the database or as in-memory objects. However the business logic is implemented, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] enables you use partial classes and partial methods to separate the business logic from the data access code.  \n  \n## How LINQ to SQL Invokes Your Business Logic  \n When you generate an entity class at design time, either manually or by using the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] or SQLMetal, it is defined as a partial class. This means that, in a separate code file, you can define another part of the entity class that contains your custom business logic. At compile time, the two parts are merged into a single class. But if you have to regenerate your entity classes by using the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] or SQLMetal, you can do so and your part of the class will not be modified.  \n  \n The partial classes that define entities and the <xref:System.Data.Linq.DataContext> contain partial methods. These are the extensibility points that you can use to apply your business logic before and after any update, insert, or delete for an entity or entity property. Partial methods can be thought of as compile-time events. The code-generator defines a method signature and calls the methods in the get and set property accessors, the `DataContext` constructor, and in some cases behind the scenes when <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called. However, if you do not implement a particular partial method, then all the references to it and the definition are removed at compile time.  \n  \n In the implementing definition that you write in your separate code file, you can perform whatever custom logic is required. You can use your partial class itself as your domain layer, or you can call from your implementing definition of the partial method into a separate object or objects. Either way, your business logic is cleanly separated from both your data access code and your presentation layer code.  \n  \n## A Closer Look at the Extensibility Points  \n The following example shows part of the code generated by the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] for the `DataContext` class that has two tables: `Customers` and `Orders`. Note that Insert, Update, and Delete methods are defined for each table in the class.  \n  \n```vb  \nPartial Public Class Northwnd  \n    Inherits System.Data.Linq.DataContext  \n  \n    Private Shared mappingSource As _  \n        System.Data.Linq.Mapping.MappingSource = New _  \n        AttributeMappingSource  \n  \n    #Region \"Extensibility Method Definitions\"  \n    Partial Private Sub OnCreated()  \n    End Sub  \n    Partial Private Sub InsertCustomer(instance As Customer)  \n    End Sub  \n    Partial Private Sub UpdateCustomer(instance As Customer)  \n    End Sub  \n    Partial Private Sub DeleteCustomer(instance As Customer)  \n    End Sub  \n    Partial Private Sub InsertOrder(instance As [Order])  \n    End Sub  \n    Partial Private Sub UpdateOrder(instance As [Order])  \n    End Sub  \n    Partial Private Sub DeleteOrder(instance As [Order])  \n    End Sub  \n    #End Region  \n```  \n  \n```csharp  \npublic partial class MyNorthWindDataContext : System.Data.Linq.DataContext  \n    {  \n        private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();  \n  \n        #region Extensibility Method Definitions  \n        partial void OnCreated();  \n        partial void InsertCustomer(Customer instance);  \n        partial void UpdateCustomer(Customer instance);  \n        partial void DeleteCustomer(Customer instance);  \n        partial void InsertOrder(Order instance);  \n        partial void UpdateOrder(Order instance);  \n        partial void DeleteOrder(Order instance);  \n        #endregion  \n```  \n  \n If you implement the Insert, Update and Delete methods in your partial class, the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime will call them instead of its own default methods when <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called. This enables you to override the default behavior for create / read / update / delete operations. For more information, see [Walkthrough: Customizing the insert, update, and delete behavior of entity classes](/visualstudio/data-tools/walkthrough-customizing-the-insert-update-and-delete-behavior-of-entity-classes).  \n  \n The `OnCreated` method is called in the class constructor.  \n  \n```vb  \nPublic Sub New(ByVal connection As String)  \n    MyBase.New(connection, mappingSource)  \n    OnCreated()  \nEnd Sub  \n```  \n  \n```csharp  \npublic MyNorthWindDataContext(string connection) :  \n            base(connection, mappingSource)  \n        {  \n            OnCreated();  \n        }  \n```  \n  \n The entity classes have three methods that are called by the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime when the entity is created, loaded, and validated (when `SubmitChanges` is called). The entity classes also have two partial methods for each property, one that is called before the property is set, and one that is called after. The following code example shows some of the methods generated for the `Customer` class:  \n  \n```vb  \n#Region \"Extensibility Method Definitions\"  \n    Partial Private Sub OnLoaded()  \n    End Sub  \n    Partial Private Sub OnValidate(action As _  \n        System.Data.Linq.ChangeAction)  \n    End Sub  \n    Partial Private Sub OnCreated()  \n    End Sub  \n    Partial Private Sub OnCustomerIDChanging(value As String)  \n    End Sub  \n    Partial Private Sub OnCustomerIDChanged()  \n    End Sub  \n    Partial Private Sub OnCompanyNameChanging(value As String)  \n    End Sub  \n    Partial Private Sub OnCompanyNameChanged()  \n    End Sub  \n' ...Additional Changing/Changed methods for each property.  \n```  \n  \n```csharp  \n#region Extensibility Method Definitions  \n    partial void OnLoaded();  \n    partial void OnValidate();  \n    partial void OnCreated();  \n    partial void OnCustomerIDChanging(string value);  \n    partial void OnCustomerIDChanged();  \n    partial void OnCompanyNameChanging(string value);  \n    partial void OnCompanyNameChanged();  \n// ...additional Changing/Changed methods for each property  \n```  \n  \n The methods are called in the property set accessor as shown in the following example for the `CustomerID` property:  \n  \n```vb  \nPublic Property CustomerID() As String  \n    Set  \n        If (String.Equals(Me._CustomerID, value) = False) Then  \n            Me.OnCustomerIDChanging(value)  \n            Me.SendPropertyChanging()  \n            Me._CustomerID = value  \n            Me.SendPropertyChanged(\"CustomerID\")  \n            Me.OnCustomerIDChanged()  \n        End If  \n    End Set  \nEnd Property  \n```  \n  \n```csharp  \npublic string CustomerID  \n{  \n    set  \n    {  \n        if ((this._CustomerID != value))  \n        {  \n            this.OnCustomerIDChanging(value);  \n            this.SendPropertyChanging();  \n            this._CustomerID = value;  \n            this.SendPropertyChanged(\"CustomerID\");  \n            this.OnCustomerIDChanged();  \n        }  \n     }  \n}  \n```  \n  \n In your part of the class, you write an implementing definition of the method. In Visual Studio, after you type `partial` you will see IntelliSense for the method definitions in the other part of the class.  \n  \n```vb  \nPartial Public Class Customer  \n    Private Sub OnCustomerIDChanging(value As String)  \n        ' Perform custom validation logic here.  \n    End Sub  \nEnd Class  \n```  \n  \n```csharp  \npartial class Customer   \n    {  \n        partial void OnCustomerIDChanging(string value)  \n        {  \n            //Perform custom validation logic here.  \n        }  \n    }  \n```  \n  \n For more information about how to add business logic to your application by using partial methods, see the following topics:  \n  \n [How to: Add validation to entity classes](/visualstudio/data-tools/how-to-add-validation-to-entity-classes)  \n  \n [Walkthrough: Customizing the insert, update, and delete behavior of entity classes](/visualstudio/data-tools/walkthrough-customizing-the-insert-update-and-delete-behavior-of-entity-classes)  \n  \n [Walkthrough: Adding Validation to Entity Classes](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/bb629301(v=vs.120))  \n  \n## See also\n\n- [Partial Classes and Methods](../../../../../csharp/programming-guide/classes-and-structs/partial-classes-and-methods.md)\n- [Partial Methods](~/docs/visual-basic/programming-guide/language-features/procedures/partial-methods.md)\n- [LINQ to SQL Tools in Visual Studio](/visualstudio/data-tools/linq-to-sql-tools-in-visual-studio2)\n- [SqlMetal.exe (Code Generation Tool)](../../../../../../docs/framework/tools/sqlmetal-exe-code-generation-tool.md)\n","nodes":[{"pos":[4,159],"embed":true,"restype":"x-metadata","content":"title: \"Implementing Business Logic (LINQ to SQL)\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: c4577590-7b12-42e1-84a6-95aa2562727e","nodes":[{"content":"Implementing Business Logic (LINQ to SQL)","nodes":[{"pos":[0,41],"content":"Implementing Business Logic (LINQ to SQL)","nodes":[{"content":"Implementing Business Logic (LINQ to SQL)","pos":[0,41]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[166,207],"content":"Implementing Business Logic (LINQ to SQL)","linkify":"Implementing Business Logic (LINQ to SQL)","nodes":[{"content":"Implementing Business Logic (LINQ to SQL)","pos":[0,41]}]},{"content":"The term \"business logic\" in this topic refers to any custom rules or validation tests that you apply to data before it is inserted, updated or deleted from the database.","pos":[208,378]},{"content":"Business logic is also sometimes referred to as \"business rules\" or \"domain logic.\"","pos":[379,462]},{"content":"In n-tier applications it is typically designed as a logical layer so that it can be modified independently of the presentation layer or data access layer.","pos":[463,618]},{"content":"The business logic can be invoked by the data access layer before or after any update, insertion, or deletion of data in the database.","pos":[619,753]},{"content":"The business logic can be as simple as a schema validation to make sure that the type of the field is compatible with the type of the table column.","pos":[760,907]},{"content":"Or it can consist of a set of objects that interact in arbitrarily complex ways.","pos":[908,988]},{"content":"The rules may be implemented as stored procedures on the database or as in-memory objects.","pos":[989,1079]},{"content":"However the business logic is implemented, <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> enables you use partial classes and partial methods to separate the business logic from the data access code.","pos":[1080,1300],"source":" However the business logic is implemented, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] enables you use partial classes and partial methods to separate the business logic from the data access code."},{"pos":[1309,1352],"content":"How LINQ to SQL Invokes Your Business Logic","linkify":"How LINQ to SQL Invokes Your Business Logic","nodes":[{"content":"How LINQ to SQL Invokes Your Business Logic","pos":[0,43]}]},{"content":"When you generate an entity class at design time, either manually or by using the <ph id=\"ph1\">[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]</ph> or SQLMetal, it is defined as a partial class.","pos":[1356,1568],"source":"When you generate an entity class at design time, either manually or by using the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] or SQLMetal, it is defined as a partial class."},{"content":"This means that, in a separate code file, you can define another part of the entity class that contains your custom business logic.","pos":[1569,1700]},{"content":"At compile time, the two parts are merged into a single class.","pos":[1701,1763]},{"content":"But if you have to regenerate your entity classes by using the <ph id=\"ph1\">[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]</ph> or SQLMetal, you can do so and your part of the class will not be modified.","pos":[1764,1986],"source":" But if you have to regenerate your entity classes by using the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] or SQLMetal, you can do so and your part of the class will not be modified."},{"content":"The partial classes that define entities and the <ph id=\"ph1\">&lt;xref:System.Data.Linq.DataContext&gt;</ph> contain partial methods.","pos":[1993,2102],"source":"The partial classes that define entities and the <xref:System.Data.Linq.DataContext> contain partial methods."},{"content":"These are the extensibility points that you can use to apply your business logic before and after any update, insert, or delete for an entity or entity property.","pos":[2103,2264]},{"content":"Partial methods can be thought of as compile-time events.","pos":[2265,2322]},{"content":"The code-generator defines a method signature and calls the methods in the get and set property accessors, the <ph id=\"ph1\">`DataContext`</ph> constructor, and in some cases behind the scenes when <ph id=\"ph2\">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> is called.","pos":[2323,2565],"source":" The code-generator defines a method signature and calls the methods in the get and set property accessors, the `DataContext` constructor, and in some cases behind the scenes when <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called."},{"content":"However, if you do not implement a particular partial method, then all the references to it and the definition are removed at compile time.","pos":[2566,2705]},{"content":"In the implementing definition that you write in your separate code file, you can perform whatever custom logic is required.","pos":[2712,2836]},{"content":"You can use your partial class itself as your domain layer, or you can call from your implementing definition of the partial method into a separate object or objects.","pos":[2837,3003]},{"content":"Either way, your business logic is cleanly separated from both your data access code and your presentation layer code.","pos":[3004,3122]},{"pos":[3131,3172],"content":"A Closer Look at the Extensibility Points","linkify":"A Closer Look at the Extensibility Points","nodes":[{"content":"A Closer Look at the Extensibility Points","pos":[0,41]}]},{"content":"The following example shows part of the code generated by the <ph id=\"ph1\">[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]</ph> for the <ph id=\"ph2\">`DataContext`</ph> class that has two tables: <ph id=\"ph3\">`Customers`</ph> and <ph id=\"ph4\">`Orders`</ph>.","pos":[3176,3396],"source":"The following example shows part of the code generated by the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] for the `DataContext` class that has two tables: `Customers` and `Orders`."},{"content":"Note that Insert, Update, and Delete methods are defined for each table in the class.","pos":[3397,3482]},{"content":"If you implement the Insert, Update and Delete methods in your partial class, the <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> runtime will call them instead of its own default methods when <ph id=\"ph2\">&lt;xref:System.Data.Linq.DataContext.SubmitChanges%2A&gt;</ph> is called.","pos":[4944,5220],"source":"If you implement the Insert, Update and Delete methods in your partial class, the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime will call them instead of its own default methods when <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called."},{"content":"This enables you to override the default behavior for create / read / update / delete operations.","pos":[5221,5318]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Walkthrough: Customizing the insert, update, and delete behavior of entity classes<ept id=\"p1\">](/visualstudio/data-tools/walkthrough-customizing-the-insert-update-and-delete-behavior-of-entity-classes)</ept>.","pos":[5319,5536],"source":" For more information, see [Walkthrough: Customizing the insert, update, and delete behavior of entity classes](/visualstudio/data-tools/walkthrough-customizing-the-insert-update-and-delete-behavior-of-entity-classes)."},{"pos":[5543,5601],"content":"The <ph id=\"ph1\">`OnCreated`</ph> method is called in the class constructor.","source":"The `OnCreated` method is called in the class constructor."},{"content":"The entity classes have three methods that are called by the <ph id=\"ph1\">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]</ph> runtime when the entity is created, loaded, and validated (when <ph id=\"ph2\">`SubmitChanges`</ph> is called).","pos":[5913,6133],"source":"The entity classes have three methods that are called by the [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime when the entity is created, loaded, and validated (when `SubmitChanges` is called)."},{"content":"The entity classes also have two partial methods for each property, one that is called before the property is set, and one that is called after.","pos":[6134,6278]},{"content":"The following code example shows some of the methods generated for the <ph id=\"ph1\">`Customer`</ph> class:","pos":[6279,6367],"source":" The following code example shows some of the methods generated for the `Customer` class:"},{"pos":[7405,7521],"content":"The methods are called in the property set accessor as shown in the following example for the <ph id=\"ph1\">`CustomerID`</ph> property:","source":"The methods are called in the property set accessor as shown in the following example for the `CustomerID` property:"},{"content":"In your part of the class, you write an implementing definition of the method.","pos":[8296,8374]},{"content":"In Visual Studio, after you type <ph id=\"ph1\">`partial`</ph> you will see IntelliSense for the method definitions in the other part of the class.","pos":[8375,8502],"source":" In Visual Studio, after you type `partial` you will see IntelliSense for the method definitions in the other part of the class."},{"content":"For more information about how to add business logic to your application by using partial methods, see the following topics:","pos":[8889,9013]},{"pos":[9020,9128],"content":"<bpt id=\"p1\">[</bpt>How to: Add validation to entity classes<ept id=\"p1\">](/visualstudio/data-tools/how-to-add-validation-to-entity-classes)</ept>","source":"[How to: Add validation to entity classes](/visualstudio/data-tools/how-to-add-validation-to-entity-classes)"},{"pos":[9135,9325],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Customizing the insert, update, and delete behavior of entity classes<ept id=\"p1\">](/visualstudio/data-tools/walkthrough-customizing-the-insert-update-and-delete-behavior-of-entity-classes)</ept>","source":"[Walkthrough: Customizing the insert, update, and delete behavior of entity classes](/visualstudio/data-tools/walkthrough-customizing-the-insert-update-and-delete-behavior-of-entity-classes)"},{"pos":[9332,9479],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Adding Validation to Entity Classes<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/bb629301(v=vs.120))</ept>","source":"[Walkthrough: Adding Validation to Entity Classes](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/bb629301(v=vs.120))"},{"pos":[9488,9496],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9500,9621],"content":"<bpt id=\"p1\">[</bpt>Partial Classes and Methods<ept id=\"p1\">](../../../../../csharp/programming-guide/classes-and-structs/partial-classes-and-methods.md)</ept>","source":"[Partial Classes and Methods](../../../../../csharp/programming-guide/classes-and-structs/partial-classes-and-methods.md)"},{"pos":[9624,9728],"content":"<bpt id=\"p1\">[</bpt>Partial Methods<ept id=\"p1\">](~/docs/visual-basic/programming-guide/language-features/procedures/partial-methods.md)</ept>","source":"[Partial Methods](~/docs/visual-basic/programming-guide/language-features/procedures/partial-methods.md)"},{"pos":[9731,9829],"content":"<bpt id=\"p1\">[</bpt>LINQ to SQL Tools in Visual Studio<ept id=\"p1\">](/visualstudio/data-tools/linq-to-sql-tools-in-visual-studio2)</ept>","source":"[LINQ to SQL Tools in Visual Studio](/visualstudio/data-tools/linq-to-sql-tools-in-visual-studio2)"},{"pos":[9832,9946],"content":"<bpt id=\"p1\">[</bpt>SqlMetal.exe (Code Generation Tool)<ept id=\"p1\">](../../../../../../docs/framework/tools/sqlmetal-exe-code-generation-tool.md)</ept>","source":"[SqlMetal.exe (Code Generation Tool)](../../../../../../docs/framework/tools/sqlmetal-exe-code-generation-tool.md)"}]}