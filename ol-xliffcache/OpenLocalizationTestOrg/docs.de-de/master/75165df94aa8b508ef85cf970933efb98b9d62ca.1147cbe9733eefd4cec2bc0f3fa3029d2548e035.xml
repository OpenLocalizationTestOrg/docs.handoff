{"content":"---\ntitle: \"Preview Events\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"Preview events [WPF]\"\n  - \"suppressing events [WPF]\"\n  - \"events [WPF], Preview\"\n  - \"events [WPF], suppressing\"\nms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e\n---\n# Preview Events\nPreview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data. Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.  \n  \n## Preview Events and Input  \n When you handle Preview events in general, be cautious about marking the events handled in the event data. Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated. Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.  \n  \n For input events specifically, Preview events also share event data instances with the equivalent bubbling event. If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked. Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked. Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.  \n  \n For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).  \n  \n### Working Around Event Suppression by Controls  \n One scenario where Preview events are commonly used is for composited control handling of input events. Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior. For instance, a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself. The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked.  If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`. But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event. For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead. This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>. These input events use tunnel/bubble pairs, raise both events, and share the event data.  \n  \n Each of these techniques has either side effects or limitations. The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route. The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.  \n  \n## See also\n\n- [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md)\n- [Routed Events Overview](routed-events-overview.md)\n","nodes":[{"pos":[4,238],"embed":true,"restype":"x-metadata","content":"title: \"Preview Events\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"Preview events [WPF]\"\n  - \"suppressing events [WPF]\"\n  - \"events [WPF], Preview\"\n  - \"events [WPF], suppressing\"\nms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e","nodes":[{"content":"Preview Events","nodes":[{"pos":[0,14],"content":"Preview Events","nodes":[{"content":"Preview Events","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[245,259],"content":"Preview Events","linkify":"Preview Events","nodes":[{"content":"Preview Events","pos":[0,14]}]},{"content":"Preview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data.","pos":[260,479]},{"content":"Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.","pos":[480,747]},{"pos":[756,780],"content":"Preview Events and Input","linkify":"Preview Events and Input","nodes":[{"content":"Preview Events and Input","pos":[0,24]}]},{"content":"When you handle Preview events in general, be cautious about marking the events handled in the event data.","pos":[784,890]},{"content":"Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated.","pos":[891,1130]},{"content":"Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.","pos":[1131,1269]},{"content":"For input events specifically, Preview events also share event data instances with the equivalent bubbling event.","pos":[1276,1389]},{"content":"If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked.","pos":[1390,1523]},{"content":"Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked.","pos":[1524,1661]},{"content":"Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.","pos":[1662,1834]},{"pos":[1841,2035],"content":"For more information about class handling and how it relates to Preview events see <bpt id=\"p1\">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id=\"p1\">](marking-routed-events-as-handled-and-class-handling.md)</ept>.","source":"For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md)."},{"pos":[2045,2089],"content":"Working Around Event Suppression by Controls","linkify":"Working Around Event Suppression by Controls","nodes":[{"content":"Working Around Event Suppression by Controls","pos":[0,44]}]},{"content":"One scenario where Preview events are commonly used is for composited control handling of input events.","pos":[2093,2196]},{"content":"Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior.","pos":[2197,2421]},{"content":"For instance, a <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph> suppresses <ph id=\"ph3\">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Windows.UIElement.MouseRightButtonDown&gt;</ph> bubbling events raised by the <ph id=\"ph5\">&lt;xref:System.Windows.Controls.Button&gt;</ph> or its composite elements in favor of capturing the mouse and raising a <ph id=\"ph6\">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event that is always raised by the <ph id=\"ph7\">&lt;xref:System.Windows.Controls.Button&gt;</ph> itself.","pos":[2422,2955],"source":" For instance, a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself."},{"content":"The event and its data still continue along the route, but because the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> marks the event data as <ph id=\"ph2\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph>, only handlers for the event that specifically indicated they should act in the <ph id=\"ph3\">`handledEventsToo`</ph> case  are invoked.","pos":[2956,3255],"source":" The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked."},{"content":"If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with <ph id=\"ph1\">`handledEventsToo`</ph> specified as <ph id=\"ph2\">`true`</ph>.","pos":[3257,3468],"source":"  If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`."},{"content":"But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event.","pos":[3469,3592]},{"content":"For instance, if a control suppresses <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph>, try attaching a handler for <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> instead.","pos":[3593,3779],"source":" For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead."},{"content":"This technique only works for base element input events such as <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.MouseLeftButtonDown&gt;</ph>.","pos":[3780,3896],"source":" This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>."},{"content":"These input events use tunnel/bubble pairs, raise both events, and share the event data.","pos":[3897,3985]},{"content":"Each of these techniques has either side effects or limitations.","pos":[3992,4056]},{"content":"The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route.","pos":[4057,4353]},{"content":"The limitation of the <ph id=\"ph1\">`handledEventsToo`</ph> technique is that you cannot specify a <ph id=\"ph2\">`handledEventsToo`</ph> handler in <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.","pos":[4354,4684],"source":" The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached."},{"pos":[4693,4701],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4705,4815],"content":"<bpt id=\"p1\">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id=\"p1\">](marking-routed-events-as-handled-and-class-handling.md)</ept>","source":"[Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md)"},{"pos":[4818,4869],"content":"<bpt id=\"p1\">[</bpt>Routed Events Overview<ept id=\"p1\">](routed-events-overview.md)</ept>","source":"[Routed Events Overview](routed-events-overview.md)"}]}