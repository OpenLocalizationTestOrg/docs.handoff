{"content":"---\ntitle: \"How to: use SpinLock for low-level synchronization\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"SpinLock, how to use\"\nms.assetid: a9ed3e4e-4f29-4207-b730-ed0a51ecbc19\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# How to: use SpinLock for low-level synchronization\n\nThe following example demonstrates how to use a <xref:System.Threading.SpinLock>. In this example, the critical section performs a minimal amount of work, which makes it a good candidate for a <xref:System.Threading.SpinLock>. Increasing the work a small amount increases the performance of the <xref:System.Threading.SpinLock> compared to a standard lock. However, there is a point at which a SpinLock becomes more expensive than a standard lock. You can use the concurrency profiling functionality in the profiling tools to see which type of lock provides better performance in your program. For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer).  \n  \n [!code-csharp[CDS_SpinLock#02](../../../samples/snippets/csharp/VS_Snippets_Misc/cds_spinlock/cs/spinlockdemo.cs#02)]\n [!code-vb[CDS_SpinLock#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_spinlock/vb/spinlock_vb.vb#02)]  \n  \n <xref:System.Threading.SpinLock> might be useful when a lock on a shared resource is not going to be held for very long. In such cases, on multi-core computers it can be efficient for the blocked thread to spin for a few cycles until the lock is released. By spinning, the thread does not become blocked, which is a CPU-intensive process. <xref:System.Threading.SpinLock> will stop spinning under certain conditions to prevent starvation of logical processors or priority inversion on systems with Hyper-Threading.  \n  \n This example uses the <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> class, which requires user synchronization for multi-threaded access. In applications that target the .NET Framework version 4, another option is to use the <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>, which does not require any user locks.  \n  \n Note the use of `false` (`False` in Visual Basic) in the call to <xref:System.Threading.SpinLock.Exit%2A?displayProperty=nameWithType>. This provides the best performance. Specify `true` (`True` in Visual Basic) on IA64 architectures to use the memory fence, which flushes the write buffers to ensure that the lock is now available for other threads to exit.  \n  \n## See also\n\n- [Threading objects and features](threading-objects-and-features.md)\n- [lock statement (C#)](../../csharp/language-reference/keywords/lock-statement.md)\n- [SyncLock statement (Visual Basic)](../../visual-basic/language-reference/statements/synclock-statement.md)\n","nodes":[{"pos":[4,288],"embed":true,"restype":"x-metadata","content":"title: \"How to: use SpinLock for low-level synchronization\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"SpinLock, how to use\"\nms.assetid: a9ed3e4e-4f29-4207-b730-ed0a51ecbc19\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"How to: use SpinLock for low-level synchronization","nodes":[{"pos":[0,50],"content":"How to: use SpinLock for low-level synchronization","nodes":[{"content":"How to: use SpinLock for low-level synchronization","pos":[0,50]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[295,345],"content":"How to: use SpinLock for low-level synchronization","linkify":"How to: use SpinLock for low-level synchronization","nodes":[{"content":"How to: use SpinLock for low-level synchronization","pos":[0,50]}]},{"content":"The following example demonstrates how to use a <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph>.","pos":[347,428],"source":"The following example demonstrates how to use a <xref:System.Threading.SpinLock>."},{"content":"In this example, the critical section performs a minimal amount of work, which makes it a good candidate for a <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph>.","pos":[429,573],"source":" In this example, the critical section performs a minimal amount of work, which makes it a good candidate for a <xref:System.Threading.SpinLock>."},{"content":"Increasing the work a small amount increases the performance of the <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> compared to a standard lock.","pos":[574,703],"source":" Increasing the work a small amount increases the performance of the <xref:System.Threading.SpinLock> compared to a standard lock."},{"content":"However, there is a point at which a SpinLock becomes more expensive than a standard lock.","pos":[704,794]},{"content":"You can use the concurrency profiling functionality in the profiling tools to see which type of lock provides better performance in your program.","pos":[795,940]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Concurrency Visualizer<ept id=\"p1\">](/visualstudio/profiling/concurrency-visualizer)</ept>.","pos":[941,1040],"source":" For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> might be useful when a lock on a shared resource is not going to be held for very long.","pos":[1290,1410],"source":"<xref:System.Threading.SpinLock> might be useful when a lock on a shared resource is not going to be held for very long."},{"content":"In such cases, on multi-core computers it can be efficient for the blocked thread to spin for a few cycles until the lock is released.","pos":[1411,1545]},{"content":"By spinning, the thread does not become blocked, which is a CPU-intensive process.","pos":[1546,1628]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> will stop spinning under certain conditions to prevent starvation of logical processors or priority inversion on systems with Hyper-Threading.","pos":[1629,1804],"source":"<xref:System.Threading.SpinLock> will stop spinning under certain conditions to prevent starvation of logical processors or priority inversion on systems with Hyper-Threading."},{"content":"This example uses the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType&gt;</ph> class, which requires user synchronization for multi-threaded access.","pos":[1811,1975],"source":"This example uses the <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> class, which requires user synchronization for multi-threaded access."},{"content":"In applications that target the .NET Framework version 4, another option is to use the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType&gt;</ph>, which does not require any user locks.","pos":[1976,2188],"source":" In applications that target the .NET Framework version 4, another option is to use the <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>, which does not require any user locks."},{"content":"Note the use of <ph id=\"ph1\">`false`</ph> (<ph id=\"ph2\">`False`</ph> in Visual Basic) in the call to <ph id=\"ph3\">&lt;xref:System.Threading.SpinLock.Exit%2A?displayProperty=nameWithType&gt;</ph>.","pos":[2195,2330],"source":"Note the use of `false` (`False` in Visual Basic) in the call to <xref:System.Threading.SpinLock.Exit%2A?displayProperty=nameWithType>."},{"content":"This provides the best performance.","pos":[2331,2366]},{"content":"Specify <ph id=\"ph1\">`true`</ph> (<ph id=\"ph2\">`True`</ph> in Visual Basic) on IA64 architectures to use the memory fence, which flushes the write buffers to ensure that the lock is now available for other threads to exit.","pos":[2367,2553],"source":" Specify `true` (`True` in Visual Basic) on IA64 architectures to use the memory fence, which flushes the write buffers to ensure that the lock is now available for other threads to exit."},{"pos":[2562,2570],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2574,2641],"content":"<bpt id=\"p1\">[</bpt>Threading objects and features<ept id=\"p1\">](threading-objects-and-features.md)</ept>","source":"[Threading objects and features](threading-objects-and-features.md)"},{"pos":[2644,2725],"content":"<bpt id=\"p1\">[</bpt>lock statement (C#)<ept id=\"p1\">](../../csharp/language-reference/keywords/lock-statement.md)</ept>","source":"[lock statement (C#)](../../csharp/language-reference/keywords/lock-statement.md)"},{"pos":[2728,2835],"content":"<bpt id=\"p1\">[</bpt>SyncLock statement (Visual Basic)<ept id=\"p1\">](../../visual-basic/language-reference/statements/synclock-statement.md)</ept>","source":"[SyncLock statement (Visual Basic)](../../visual-basic/language-reference/statements/synclock-statement.md)"}]}