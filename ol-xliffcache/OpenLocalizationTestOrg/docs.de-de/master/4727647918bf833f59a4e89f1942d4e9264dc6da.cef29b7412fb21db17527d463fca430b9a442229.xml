{"content":"---\ntitle: \"Extended Protection for Authentication Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 3d2ceffe-a7bf-4bd9-a5a2-9406423bd7f8\ncaps.latest.revision: 4\nauthor: \"BrucePerlerMS\"\nms.author: \"bruceper\"\nmanager: \"mbaldwin\"\n---\n# Extended Protection for Authentication Overview\nExtended Protection for Authentication helps protect against man-in-the-middle (MITM) attacks, in which an attacker intercepts a client’s credentials and forwards them to a server.  \n  \n Consider a scenario with three participants: a client, server, and attacker. The server has the URL `https://server`, whereas the attacker has the URL `https://attacker`. The attacker tricks the client into accessing the attacker as if it were the server. The attacker then sends a request to the server. If the attacker is trying to access a secure resource, the server replies to the attacker with a WWW-Authenticate header. The attacker does not have the authentication information, so it sends the WWW-Authenticate header on to the client. The client sends the Authorization header to the attacker, and the attacker sends the header on to the server and gets access to the secure resources using the client’s credentials.  \n  \n Currently, when a client application authenticates itself to the server using Kerberos, Digest, or NTLM using HTTPS, a Transport Level Security (TLS) channel is first established and authentication takes place using this channel. However, there is no binding between the session key generated by Secure Sockets Layer (SSL) and the session key that is generated during authentication. So, in the previous scenario, if the communication takes places over a TLS (such as an HTTPS channel), there are two SSL channels created: one between the client and the attacker, and another between the attacker and the server. The client’s credentials are sent from the client to the server first over the SSL channel between the client and the attacker and then over the channel between the attacker and the server. Once the client’s credentials reach the server, the server verifies the credentials without detecting that the channel over which those credentials were sent originated with the attacker and not the client.  \n  \n The solution is to use a TLS-secured outer channel and a client-authenticated inner channel, and to pass a Channel Binding Token (CBT) to the server. The CBT is a property of the TLS-secured outer channel, and is used to bind the outer channel to a conversation over the client-authenticated inner channel.  \n  \n In the previous scenario, the CBT of the client-attacker TLS channel is merged with the authorization information that is sent to the server. A CBT-aware server compares the CBT contained in the client authentication information, which corresponds to the client-attacker channel, to the CBT attached to the attacker-server channel. A CBT is specific to a channel’s destination, so the client-attacker CBT does not match the attacker-server CBT. This lets the server detect the MITM attack and refuse the authentication request.  \n  \n The client side does not require any configuration setting. Once the client has been updated to pass the CBT to the server, it always does so. If the server has also been updated, it can be configured to use the CBT or ignore it. If it has not been updated, it ignores it.  \n  \n The server can have the following levels of protection:  \n  \n-   None. No channel binding validation is performed. This is the behavior of all servers that have not been updated.  \n  \n-   Partial. All clients that have been updated must provide channel binding information to the server. Clients that have not been updated do not have to do so. This is an intermediate option that allows for application compatibility.  \n  \n-   Full. All clients must provide channel binding information. The server rejects authentication requests from clients that do not do so.  \n  \n For more information, see the Win7 CBT/Extended Protection sample.  \n  \n## See Also  \n [Security Model for Windows Server App Fabric](http://go.microsoft.com/fwlink/?LinkID=201279&clcid=0x409)","nodes":[{"pos":[12,76],"content":"Extended Protection for Authentication Overview | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Extended Protection for Authentication Overview | Microsoft Docs","pos":[0,64]}]},{"pos":[385,432],"content":"Extended Protection for Authentication Overview","linkify":"Extended Protection for Authentication Overview","nodes":[{"content":"Extended Protection for Authentication Overview","pos":[0,47]}]},{"content":"Extended Protection for Authentication helps protect against man-in-the-middle (MITM) attacks, in which an attacker intercepts a client’s credentials and forwards them to a server.","pos":[433,613]},{"content":"Consider a scenario with three participants: a client, server, and attacker.","pos":[620,696]},{"content":"The server has the URL <ph id=\"ph1\">`https://server`</ph>, whereas the attacker has the URL <ph id=\"ph2\">`https://attacker`</ph>.","pos":[697,790],"source":" The server has the URL `https://server`, whereas the attacker has the URL `https://attacker`."},{"content":"The attacker tricks the client into accessing the attacker as if it were the server.","pos":[791,875]},{"content":"The attacker then sends a request to the server.","pos":[876,924]},{"content":"If the attacker is trying to access a secure resource, the server replies to the attacker with a WWW-Authenticate header.","pos":[925,1046]},{"content":"The attacker does not have the authentication information, so it sends the WWW-Authenticate header on to the client.","pos":[1047,1163]},{"content":"The client sends the Authorization header to the attacker, and the attacker sends the header on to the server and gets access to the secure resources using the client’s credentials.","pos":[1164,1345]},{"content":"Currently, when a client application authenticates itself to the server using Kerberos, Digest, or NTLM using HTTPS, a Transport Level Security (TLS) channel is first established and authentication takes place using this channel.","pos":[1352,1581]},{"content":"However, there is no binding between the session key generated by Secure Sockets Layer (SSL) and the session key that is generated during authentication.","pos":[1582,1735]},{"content":"So, in the previous scenario, if the communication takes places over a TLS (such as an HTTPS channel), there are two SSL channels created: one between the client and the attacker, and another between the attacker and the server.","pos":[1736,1964]},{"content":"The client’s credentials are sent from the client to the server first over the SSL channel between the client and the attacker and then over the channel between the attacker and the server.","pos":[1965,2154]},{"content":"Once the client’s credentials reach the server, the server verifies the credentials without detecting that the channel over which those credentials were sent originated with the attacker and not the client.","pos":[2155,2361]},{"content":"The solution is to use a TLS-secured outer channel and a client-authenticated inner channel, and to pass a Channel Binding Token (CBT) to the server.","pos":[2368,2517]},{"content":"The CBT is a property of the TLS-secured outer channel, and is used to bind the outer channel to a conversation over the client-authenticated inner channel.","pos":[2518,2674]},{"content":"In the previous scenario, the CBT of the client-attacker TLS channel is merged with the authorization information that is sent to the server.","pos":[2681,2822]},{"content":"A CBT-aware server compares the CBT contained in the client authentication information, which corresponds to the client-attacker channel, to the CBT attached to the attacker-server channel.","pos":[2823,3012]},{"content":"A CBT is specific to a channel’s destination, so the client-attacker CBT does not match the attacker-server CBT.","pos":[3013,3125]},{"content":"This lets the server detect the MITM attack and refuse the authentication request.","pos":[3126,3208]},{"content":"The client side does not require any configuration setting.","pos":[3215,3274]},{"content":"Once the client has been updated to pass the CBT to the server, it always does so.","pos":[3275,3357]},{"content":"If the server has also been updated, it can be configured to use the CBT or ignore it.","pos":[3358,3444]},{"content":"If it has not been updated, it ignores it.","pos":[3445,3487]},{"content":"The server can have the following levels of protection:","pos":[3494,3549]},{"content":"None.","pos":[3559,3564]},{"content":"No channel binding validation is performed.","pos":[3565,3608]},{"content":"This is the behavior of all servers that have not been updated.","pos":[3609,3672]},{"content":"Partial.","pos":[3682,3690]},{"content":"All clients that have been updated must provide channel binding information to the server.","pos":[3691,3781]},{"content":"Clients that have not been updated do not have to do so.","pos":[3782,3838]},{"content":"This is an intermediate option that allows for application compatibility.","pos":[3839,3912]},{"content":"Full.","pos":[3922,3927]},{"content":"All clients must provide channel binding information.","pos":[3928,3981]},{"content":"The server rejects authentication requests from clients that do not do so.","pos":[3982,4056]},{"content":"For more information, see the Win7 CBT/Extended Protection sample.","pos":[4063,4129]},{"pos":[4138,4146],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[4150,4255],"content":"<bpt id=\"p1\">[</bpt>Security Model for Windows Server App Fabric<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=201279&amp;clcid=0x409)</ept>","source":"[Security Model for Windows Server App Fabric](http://go.microsoft.com/fwlink/?LinkID=201279&clcid=0x409)"}]}