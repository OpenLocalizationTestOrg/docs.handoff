{"content":"---\ntitle: \"ICorProfilerCallback2::SurvivingReferences Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorProfilerCallback2.SurvivingReferences\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences\"\nhelpviewer_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences method [.NET Framework profiling]\"\n  - \"SurvivingReferences method [.NET Framework profiling]\"\nms.assetid: f165200e-3a91-47f7-88fc-13ff10c8babc\ntopic_type: \n  - \"apiref\"\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# ICorProfilerCallback2::SurvivingReferences Method\nReports the layout of objects in the heap as a result of a non-compacting garbage collection.  \n  \n## Syntax  \n  \n```  \nHRESULT SurvivingReferences(  \n    [in] ULONG  cSurvivingObjectIDRanges,  \n    [in, size_is(cSurvivingObjectIDRanges)] ObjectID  \n                objectIDRangeStart[] ,  \n    [in, size_is(cSurvivingObjectIDRanges)] ULONG  \n                cObjectIDRangeLength[] );  \n```  \n  \n## Parameters  \n `cSurvivingObjectIDRanges`  \n [in] The number of blocks of contiguous objects that survived as the result of the non-compacting garbage collection. That is, the value of `cSurvivingObjectIDRanges` is the size of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays, which store an `ObjectID` and a length, respectively, for each block of objects.  \n  \n The next two arguments of `SurvivingReferences` are parallel arrays. In other words, `objectIDRangeStart` and `cObjectIDRangeLength` concern the same block of contiguous objects.  \n  \n `objectIDRangeStart`  \n [in] An array of `ObjectID` values, each of which is the starting address of a block of contiguous, live objects in memory.  \n  \n `cObjectIDRangeLength`  \n [in] An array of integers, each of which is the size of a surviving block of contiguous objects in memory.  \n  \n A size is specified for each block that is referenced in the `objectIDRangeStart` array.  \n  \n## Remarks  \n  \n> [!IMPORTANT]\n>  This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms. For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead.  \n  \n The elements of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays should be interpreted as follows to determine whether an object survived the garbage collection. Assume that an `ObjectID` value (`ObjectID`) lies within the following range:  \n  \n `ObjectIDRangeStart[i]` <= `ObjectID` < `ObjectIDRangeStart[i]` + `cObjectIDRangeLength[i]`  \n  \n For any value of `i` that is in the following range, the object has survived the garbage collection:  \n  \n 0 <= `i` < `cSurvivingObjectIDRanges`  \n  \n A non-compacting garbage collection reclaims the memory occupied by \"dead\" objects, but does not compact that freed space. As a result, memory is returned to the heap, but no \"live\" objects are moved.  \n  \n The common language runtime (CLR) calls `SurvivingReferences` for non-compacting garbage collections. For compacting garbage collections, [ICorProfilerCallback::MovedReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-movedreferences-method.md) is called instead. A single garbage collection can be compacting for one generation and non-compacting for another. For a garbage collection on any particular generation, the profiler will receive either a `SurvivingReferences` callback or a `MovedReferences` callback, but not both.  \n  \n Multiple `SurvivingReferences` callbacks might be received during a particular garbage collection, due to limited internal buffering, multiple threads reporting in the case of server garbage collection, and other reasons. In the case of multiple callbacks during a garbage collection, the information is cumulative — all references that are reported in any `SurvivingReferences` callback survive the garbage collection.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorProf.idl, CorProf.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]  \n  \n## See also\n\n- [ICorProfilerCallback Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)\n- [ICorProfilerCallback2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)\n- [SurvivingReferences2 Method](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)\n","nodes":[{"pos":[4,538],"embed":true,"restype":"x-metadata","content":"title: \"ICorProfilerCallback2::SurvivingReferences Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorProfilerCallback2.SurvivingReferences\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences\"\nhelpviewer_keywords: \n  - \"ICorProfilerCallback2::SurvivingReferences method [.NET Framework profiling]\"\n  - \"SurvivingReferences method [.NET Framework profiling]\"\nms.assetid: f165200e-3a91-47f7-88fc-13ff10c8babc\ntopic_type: \n  - \"apiref\"\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"ICorProfilerCallback2::SurvivingReferences Method","nodes":[{"pos":[0,49],"content":"ICorProfilerCallback2::SurvivingReferences Method","nodes":[{"content":"ICorProfilerCallback2::SurvivingReferences Method","pos":[0,49]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[545,594],"content":"ICorProfilerCallback2::SurvivingReferences Method","linkify":"ICorProfilerCallback2::SurvivingReferences Method","nodes":[{"content":"ICorProfilerCallback2::SurvivingReferences Method","pos":[0,49]}]},{"content":"Reports the layout of objects in the heap as a result of a non-compacting garbage collection.","pos":[595,688]},{"pos":[697,703],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[994,1004],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] The number of blocks of contiguous objects that survived as the result of the non-compacting garbage collection.","pos":[1038,1155]},{"content":"That is, the value of <ph id=\"ph1\">`cSurvivingObjectIDRanges`</ph> is the size of the <ph id=\"ph2\">`objectIDRangeStart`</ph> and <ph id=\"ph3\">`cObjectIDRangeLength`</ph> arrays, which store an <ph id=\"ph4\">`ObjectID`</ph> and a length, respectively, for each block of objects.","pos":[1156,1360],"source":" That is, the value of `cSurvivingObjectIDRanges` is the size of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays, which store an `ObjectID` and a length, respectively, for each block of objects."},{"content":"The next two arguments of <ph id=\"ph1\">`SurvivingReferences`</ph> are parallel arrays.","pos":[1367,1435],"source":"The next two arguments of `SurvivingReferences` are parallel arrays."},{"content":"In other words, <ph id=\"ph1\">`objectIDRangeStart`</ph> and <ph id=\"ph2\">`cObjectIDRangeLength`</ph> concern the same block of contiguous objects.","pos":[1436,1545],"source":" In other words, `objectIDRangeStart` and `cObjectIDRangeLength` concern the same block of contiguous objects."},{"content":"[in] An array of <ph id=\"ph1\">`ObjectID`</ph> values, each of which is the starting address of a block of contiguous, live objects in memory.","pos":[1576,1699],"source":"[in] An array of `ObjectID` values, each of which is the starting address of a block of contiguous, live objects in memory."},{"content":"[in] An array of integers, each of which is the size of a surviving block of contiguous objects in memory.","pos":[1732,1838]},{"pos":[1845,1933],"content":"A size is specified for each block that is referenced in the <ph id=\"ph1\">`objectIDRangeStart`</ph> array.","source":"A size is specified for each block that is referenced in the `objectIDRangeStart` array."},{"pos":[1942,1949],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1957,2287],"content":"[!IMPORTANT]\n This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms. For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead.","leadings":["","> "],"nodes":[{"content":"This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms. For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead.","pos":[14,328],"nodes":[{"content":"This method reports sizes as <ph id=\"ph1\">`MAX_ULONG`</ph> for objects that are greater than 4 GB on 64-bit platforms.","pos":[0,100],"source":"This method reports sizes as `MAX_ULONG` for objects that are greater than 4 GB on 64-bit platforms."},{"content":"For objects that are larger than 4 GB, use the <bpt id=\"p1\">[</bpt>ICorProfilerCallback4::SurvivingReferences2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)</ept> method instead.","pos":[101,314],"source":" For objects that are larger than 4 GB, use the [ICorProfilerCallback4::SurvivingReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md) method instead."}]}]},{"content":"The elements of the <ph id=\"ph1\">`objectIDRangeStart`</ph> and <ph id=\"ph2\">`cObjectIDRangeLength`</ph> arrays should be interpreted as follows to determine whether an object survived the garbage collection.","pos":[2294,2465],"source":"The elements of the `objectIDRangeStart` and `cObjectIDRangeLength` arrays should be interpreted as follows to determine whether an object survived the garbage collection."},{"content":"Assume that an <ph id=\"ph1\">`ObjectID`</ph> value (<ph id=\"ph2\">`ObjectID`</ph>) lies within the following range:","pos":[2466,2543],"source":" Assume that an `ObjectID` value (`ObjectID`) lies within the following range:"},{"pos":[2648,2748],"content":"For any value of <ph id=\"ph1\">`i`</ph> that is in the following range, the object has survived the garbage collection:","source":"For any value of `i` that is in the following range, the object has survived the garbage collection:"},{"pos":[2755,2792],"content":"0 &lt;= <ph id=\"ph1\">`i`</ph><ph id=\"ph2\"> &lt; </ph><ph id=\"ph3\">`cSurvivingObjectIDRanges`</ph>","source":"0 <= `i` < `cSurvivingObjectIDRanges`"},{"content":"A non-compacting garbage collection reclaims the memory occupied by \"dead\" objects, but does not compact that freed space.","pos":[2799,2921]},{"content":"As a result, memory is returned to the heap, but no \"live\" objects are moved.","pos":[2922,2999]},{"content":"The common language runtime (CLR) calls <ph id=\"ph1\">`SurvivingReferences`</ph> for non-compacting garbage collections.","pos":[3006,3107],"source":"The common language runtime (CLR) calls `SurvivingReferences` for non-compacting garbage collections."},{"content":"For compacting garbage collections, <bpt id=\"p1\">[</bpt>ICorProfilerCallback::MovedReferences<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-movedreferences-method.md)</ept> is called instead.","pos":[3108,3301],"source":" For compacting garbage collections, [ICorProfilerCallback::MovedReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-movedreferences-method.md) is called instead."},{"content":"A single garbage collection can be compacting for one generation and non-compacting for another.","pos":[3302,3398]},{"content":"For a garbage collection on any particular generation, the profiler will receive either a <ph id=\"ph1\">`SurvivingReferences`</ph> callback or a <ph id=\"ph2\">`MovedReferences`</ph> callback, but not both.","pos":[3399,3566],"source":" For a garbage collection on any particular generation, the profiler will receive either a `SurvivingReferences` callback or a `MovedReferences` callback, but not both."},{"content":"Multiple <ph id=\"ph1\">`SurvivingReferences`</ph> callbacks might be received during a particular garbage collection, due to limited internal buffering, multiple threads reporting in the case of server garbage collection, and other reasons.","pos":[3573,3794],"source":"Multiple `SurvivingReferences` callbacks might be received during a particular garbage collection, due to limited internal buffering, multiple threads reporting in the case of server garbage collection, and other reasons."},{"content":"In the case of multiple callbacks during a garbage collection, the information is cumulative — all references that are reported in any <ph id=\"ph1\">`SurvivingReferences`</ph> callback survive the garbage collection.","pos":[3795,3992],"source":" In the case of multiple callbacks during a garbage collection, the information is cumulative — all references that are reported in any `SurvivingReferences` callback survive the garbage collection."},{"pos":[4001,4013],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[4017,4121],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[4128,4162],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorProf.idl, CorProf.h","source":"**Header:** CorProf.idl, CorProf.h"},{"pos":[4169,4194],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[4201,4309],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept> <ph id=\"ph1\">[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</ph>","source":"**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]"},{"pos":[4318,4326],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4330,4448],"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept>","source":"[ICorProfilerCallback Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)"},{"pos":[4451,4571],"content":"<bpt id=\"p1\">[</bpt>ICorProfilerCallback2 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept>","source":"[ICorProfilerCallback2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)"},{"pos":[4574,4708],"content":"<bpt id=\"p1\">[</bpt>SurvivingReferences2 Method<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)</ept>","source":"[SurvivingReferences2 Method](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-survivingreferences2-method.md)"}]}