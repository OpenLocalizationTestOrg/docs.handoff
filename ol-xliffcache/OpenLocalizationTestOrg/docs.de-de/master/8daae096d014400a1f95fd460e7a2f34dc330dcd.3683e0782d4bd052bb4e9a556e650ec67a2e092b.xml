{"content":"---\ntitle: .NET Assembly File Format\ndescription: .NET Assembly File Format\nkeywords: .NET, .NET Core\nauthor: richlander\nms.author: mairaw\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: dotnet-standard\nms.devlang: dotnet\nms.assetid: 6520323e-ff28-4c8a-ba80-e64a413199e6\n---\n\n# .NET Assembly File Format\n\nThe .NET platform defines a binary file format - \"assembly\" - that is used to fully-describe and contain .NET programs. Assemblies are used for the programs themselves as well as any dependent libraries. A .NET program can be executed as one of more assemblies, with no other required artifacts, beyond the appropriate .NET runtime. Native dependencies, including operating system APIs, are a separate concern and are not contained within the .NET assembly format, although are sometimes described with this format (for example, WinRT).\n\n> Each CLI component carries the metadata for declarations, implementations, and references specific to that component. Therefore, the component-specific metadata is referred to as component metadata, and the resulting component is said to be self-describing – from ECMA 335 I.9.1, Components and assemblies.\n\nThe format is fully specified and standardized as ECMA 335. All .NET compilers and runtimes use this format. The presence of a documented and infrequently updated binary format has been a major benefit (arguably a requirement) for interoperatibility. The format was last updated in a substantive way in 2005 (.NET 2.0) to accommodate generics and processor architecture.\n\nThe format is CPU- and OS-agnostic. It has been used as part of .NET runtimes that target many chips and CPUs. While the format itself has Windows heritage, it is implementable on any operating system. It’s arguably most significant choice for OS interoperability is that most values are stored in little-endian format. It doesn’t have a specific affinity to machine pointer size (for example, 32-bit, 64-bit).\n\nThe .NET assembly format is also very descriptive about the structure of a given program or library. It describes the internal components of an assembly, specifically: assembly references and types defined and their internal structure. Tools or APIs can read and process this information for display or to make programmatic decisions.\n\n## Format\n\nThe .NET binary format is based on the Windows [PE file](http://en.wikipedia.org/wiki/Portable_Executable) format. In fact, .NET class libraries are conformant Windows PEs, and appear on first glance to be Windows dynamic link libraries (DLLs) or application executables (EXEs). This is a very useful characteristic on Windows, where they can masquerade as native executable binaries and get some of the same treatment (for example, OS load, PE tools).\n\n![Assembly headers](./media/assembly-format/assembly-headers.png)\n\nAssembly Headers from ECMA 335 II.25.1, Structure of the runtime file format.\n\n## Processing the Assemblies\n\nIt is possible to write tools or APIs to process assemblies. Assembly information enables making programmatic decisions at runtime, re-writing assemblies, providing API IntelliSense in an editor and generating documentation. [System.Reflection](https://msdn.microsoft.com/library/system.reflection.aspx) and [Mono.Cecil](http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/) are good examples of tools that are frequently used for this purpose.\n","nodes":[{"pos":[11,36],"content":".NET Assembly File Format","needQuote":true,"needEscape":true,"nodes":[{"content":".NET Assembly File Format","pos":[0,25]}]},{"pos":[50,75],"content":".NET Assembly File Format","needQuote":true,"needEscape":true,"nodes":[{"content":".NET Assembly File Format","pos":[0,25]}]},{"pos":[86,101],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[297,322],"content":".NET Assembly File Format","linkify":".NET Assembly File Format","nodes":[{"content":".NET Assembly File Format","pos":[0,25]}]},{"content":"The .NET platform defines a binary file format - \"assembly\" - that is used to fully-describe and contain .NET programs.","pos":[324,443]},{"content":"Assemblies are used for the programs themselves as well as any dependent libraries.","pos":[444,527]},{"content":"A .NET program can be executed as one of more assemblies, with no other required artifacts, beyond the appropriate .NET runtime.","pos":[528,656]},{"content":"Native dependencies, including operating system APIs, are a separate concern and are not contained within the .NET assembly format, although are sometimes described with this format (for example, WinRT).","pos":[657,860]},{"content":"Each CLI component carries the metadata for declarations, implementations, and references specific to that component.","pos":[864,981]},{"content":"Therefore, the component-specific metadata is referred to as component metadata, and the resulting component is said to be self-describing – from ECMA 335 I.9.1, Components and assemblies.","pos":[982,1170]},{"content":"The format is fully specified and standardized as ECMA 335.","pos":[1172,1231]},{"content":"All .NET compilers and runtimes use this format.","pos":[1232,1280]},{"content":"The presence of a documented and infrequently updated binary format has been a major benefit (arguably a requirement) for interoperatibility.","pos":[1281,1422]},{"content":"The format was last updated in a substantive way in 2005 (.NET 2.0) to accommodate generics and processor architecture.","pos":[1423,1542]},{"content":"The format is CPU- and OS-agnostic.","pos":[1544,1579]},{"content":"It has been used as part of .NET runtimes that target many chips and CPUs.","pos":[1580,1654]},{"content":"While the format itself has Windows heritage, it is implementable on any operating system.","pos":[1655,1745]},{"content":"It’s arguably most significant choice for OS interoperability is that most values are stored in little-endian format.","pos":[1746,1863]},{"content":"It doesn’t have a specific affinity to machine pointer size (for example, 32-bit, 64-bit).","pos":[1864,1954]},{"content":"The .NET assembly format is also very descriptive about the structure of a given program or library.","pos":[1956,2056]},{"content":"It describes the internal components of an assembly, specifically: assembly references and types defined and their internal structure.","pos":[2057,2191]},{"content":"Tools or APIs can read and process this information for display or to make programmatic decisions.","pos":[2192,2290]},{"pos":[2295,2301],"content":"Format","linkify":"Format","nodes":[{"content":"Format","pos":[0,6]}]},{"content":"The .NET binary format is based on the Windows <bpt id=\"p1\">[</bpt>PE file<ept id=\"p1\">](http://en.wikipedia.org/wiki/Portable_Executable)</ept> format.","pos":[2303,2417],"source":"The .NET binary format is based on the Windows [PE file](http://en.wikipedia.org/wiki/Portable_Executable) format."},{"content":"In fact, .NET class libraries are conformant Windows PEs, and appear on first glance to be Windows dynamic link libraries (DLLs) or application executables (EXEs).","pos":[2418,2581]},{"content":"This is a very useful characteristic on Windows, where they can masquerade as native executable binaries and get some of the same treatment (for example, OS load, PE tools).","pos":[2582,2755]},{"content":"Assembly headers","pos":[2759,2775]},{"content":"Assembly Headers from ECMA 335 II.25.1, Structure of the runtime file format.","pos":[2824,2901]},{"pos":[2906,2931],"content":"Processing the Assemblies","linkify":"Processing the Assemblies","nodes":[{"content":"Processing the Assemblies","pos":[0,25]}]},{"content":"It is possible to write tools or APIs to process assemblies.","pos":[2933,2993]},{"content":"Assembly information enables making programmatic decisions at runtime, re-writing assemblies, providing API IntelliSense in an editor and generating documentation.","pos":[2994,3157]},{"content":"<bpt id=\"p1\">[</bpt>System.Reflection<ept id=\"p1\">](https://msdn.microsoft.com/library/system.reflection.aspx)</ept> and <bpt id=\"p2\">[</bpt>Mono.Cecil<ept id=\"p2\">](http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/)</ept> are good examples of tools that are frequently used for this purpose.","pos":[3158,3395],"source":"[System.Reflection](https://msdn.microsoft.com/library/system.reflection.aspx) and [Mono.Cecil](http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/) are good examples of tools that are frequently used for this purpose."}]}