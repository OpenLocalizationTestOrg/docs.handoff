{"content":"---\ntitle: C# Expressions - A tour of the C# language\ndescription: expressions, operands, and operators are building blocks of the C# language\nms.date: 11/06/2016\nms.assetid: 20d5eb10-7381-47b9-ad90-f1cc895aa27e\n---\n\n# Expressions\n\n*Expressions* are constructed from *operands* and *operators*. The operators of an expression indicate which operations to apply to the operands. Examples of operators include `+`, `-`, `*`, `/`, and `new`. Examples of operands include literals, fields, local variables, and expressions.\n\nWhen an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated. For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.\n\nWhen an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:\n\n* Except for the assignment operators, all binary operators are *left-associative*, meaning that operations are performed from left to right. For example, `x + y + z` is evaluated as `(x + y) + z`.\n* The assignment operators and the conditional operator (`?:`) are *right-associative*, meaning that operations are performed from right to left. For example, `x = y = z` is evaluated as `x = (y = z)`.\n\nPrecedence and associativity can be controlled using parentheses. For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.\n\nMost operators can be *overloaded*. Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.\n\nThe following summarizes C#’s operators, listing the operator categories in order of precedence from highest to lowest. Operators in the same category have equal precedence. Under each category is a list of expressions in that category along with the description of that expression type.\n\n* Primary\n    - `x.m`: Member access\n    - `x(...)`: Method and delegate invocation\n    - `x[...]`: Array and indexer access\n    - `x++`: Post-increment\n    - `x--`: Post-decrement\n    - `new T(...)`: Object and delegate creation\n    - `new T(...){...}`: Object creation with initializer\n    - `new {...}`:  Anonymous object initializer\n    - `new T[...]`: Array creation\n    - `typeof(T)`: Obtain <xref:System.Type> object for `T`\n    - `checked(x)`: Evaluate expression in checked context\n    - `unchecked(x)`: Evaluate expression in unchecked context\n    - `default(T)`: Obtain default value of type `T`\n    - `delegate {...}`: Anonymous function (anonymous method)\n* Unary\n    - `+x`: Identity\n    - `-x`: Negation\n    - `!x`: Logical negation\n    - `~x`: Bitwise negation\n    - `++x`: Pre-increment\n    - `--x`: Pre-decrement\n    - `(T)x`: Explicitly convert `x` to type `T`\n    - `await x`: Asynchronously wait for `x` to complete\n* Multiplicative\n    - `x * y`: Multiplication\n    - `x / y`: Division\n    - `x % y`: Remainder\n* Additive\n    - `x + y`: Addition, string concatenation, delegate combination\n    - `x – y`: Subtraction, delegate removal\n* Shift\n    - `x << y`: Shift left\n    - `x >> y`: Shift right\n* Relational and type testing\n    - `x < y`: Less than\n    - `x > y`: Greater than\n    - `x <= y`: Less than or equal\n    - `x >= y`: Greater than or equal\n    - `x is T`: Return `true` if `x` is a `T`, `false` otherwise\n    - `x as T`: Return `x` typed as `T`, or `null` if `x` is not a `T`\n* Equality\n    - `x == y`: Equal\n    - `x != y`: Not equal\n* Logical AND\n    - `x & y`: Integer bitwise AND, boolean logical AND\n* Logical XOR\n    - `x ^ y`: Integer bitwise XOR, boolean logical XOR\n* Logical OR\n    - `x | y`: Integer bitwise OR, boolean logical OR\n* Conditional AND\n    - `x && y`: Evaluates `y` only if `x` is not `false`\n* Conditional OR\n    - `x || y`: Evaluates `y` only if `x` is not `true`\n* Null coalescing\n    - `x ?? y`: Evaluates to `y` if `x` is null, to `x` otherwise\n* Conditional\n    - `x ? y : z`: Evaluates `y` if `x` is `true`, `z` if `x` is `false`\n* Assignment or anonymous function\n    - `x = y`: Assignment\n    - `x op= y`: Compound assignment; supported operators are\n        - `*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`  `^=`  `|=`\n    - `(T x) => y`: Anonymous function (lambda expression)\n\n> [!div class=\"step-by-step\"]\n> [Previous](types-and-variables.md)\n> [Next](statements.md)\n","nodes":[{"pos":[4,211],"embed":true,"restype":"x-metadata","content":"title: C# Expressions - A tour of the C# language\ndescription: expressions, operands, and operators are building blocks of the C# language\nms.date: 11/06/2016\nms.assetid: 20d5eb10-7381-47b9-ad90-f1cc895aa27e","nodes":[{"content":"C# Expressions - A tour of the C# language","nodes":[{"pos":[0,42],"content":"C# Expressions - A tour of the C# language","nodes":[{"content":"C# Expressions - A tour of the C# language","pos":[0,42]}]}],"path":["title"],"nosxs":false},{"content":"expressions, operands, and operators are building blocks of the C# language","nodes":[{"pos":[0,75],"content":"expressions, operands, and operators are building blocks of the C# language","nodes":[{"content":"expressions, operands, and operators are building blocks of the C# language","pos":[0,75]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[219,230],"content":"Expressions","linkify":"Expressions","nodes":[{"content":"Expressions","pos":[0,11]}]},{"content":"<bpt id=\"p1\">*</bpt>Expressions<ept id=\"p1\">*</ept> are constructed from <bpt id=\"p2\">*</bpt>operands<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>operators<ept id=\"p3\">*</ept>.","pos":[232,294],"source":"*Expressions* are constructed from *operands* and *operators*."},{"content":"The operators of an expression indicate which operations to apply to the operands.","pos":[295,377]},{"content":"Examples of operators include <ph id=\"ph1\">`+`</ph>, <ph id=\"ph2\">`-`</ph>, <ph id=\"ph3\">`*`</ph>, <ph id=\"ph4\">`/`</ph>, and <ph id=\"ph5\">`new`</ph>.","pos":[378,438],"source":" Examples of operators include `+`, `-`, `*`, `/`, and `new`."},{"content":"Examples of operands include literals, fields, local variables, and expressions.","pos":[439,519]},{"content":"When an expression contains multiple operators, the <bpt id=\"p1\">*</bpt>precedence<ept id=\"p1\">*</ept> of the operators controls the order in which the individual operators are evaluated.","pos":[521,670],"source":"When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated."},{"content":"For example, the expression <ph id=\"ph1\">`x + y * z`</ph> is evaluated as <ph id=\"ph2\">`x + (y * z)`</ph> because the <ph id=\"ph3\">`*`</ph> operator has higher precedence than the <ph id=\"ph4\">`+`</ph> operator.","pos":[671,810],"source":" For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator."},{"pos":[812,977],"content":"When an operand occurs between two operators with the same precedence, the <bpt id=\"p1\">*</bpt>associativity<ept id=\"p1\">*</ept> of the operators controls the order in which the operations are performed:","source":"When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:"},{"content":"Except for the assignment operators, all binary operators are <bpt id=\"p1\">*</bpt>left-associative<ept id=\"p1\">*</ept>, meaning that operations are performed from left to right.","pos":[981,1120],"source":"Except for the assignment operators, all binary operators are *left-associative*, meaning that operations are performed from left to right."},{"content":"For example, <ph id=\"ph1\">`x + y + z`</ph> is evaluated as <ph id=\"ph2\">`(x + y) + z`</ph>.","pos":[1121,1176],"source":" For example, `x + y + z` is evaluated as `(x + y) + z`."},{"content":"The assignment operators and the conditional operator (<ph id=\"ph1\">`?:`</ph>) are <bpt id=\"p1\">*</bpt>right-associative<ept id=\"p1\">*</ept>, meaning that operations are performed from right to left.","pos":[1179,1322],"source":"The assignment operators and the conditional operator (`?:`) are *right-associative*, meaning that operations are performed from right to left."},{"content":"For example, <ph id=\"ph1\">`x = y = z`</ph> is evaluated as <ph id=\"ph2\">`x = (y = z)`</ph>.","pos":[1323,1378],"source":" For example, `x = y = z` is evaluated as `x = (y = z)`."},{"content":"Precedence and associativity can be controlled using parentheses.","pos":[1380,1445]},{"content":"For example, <ph id=\"ph1\">`x + y * z`</ph> first multiplies <ph id=\"ph2\">`y`</ph> by <ph id=\"ph3\">`z`</ph> and then adds the result to <ph id=\"ph4\">`x`</ph>, but <ph id=\"ph5\">`(x + y) * z`</ph> first adds <ph id=\"ph6\">`x`</ph> and <ph id=\"ph7\">`y`</ph> and then multiplies the result by <ph id=\"ph8\">`z`</ph>.","pos":[1446,1611],"source":" For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`."},{"content":"Most operators can be <bpt id=\"p1\">*</bpt>overloaded<ept id=\"p1\">*</ept>.","pos":[1613,1648],"source":"Most operators can be *overloaded*."},{"content":"Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.","pos":[1649,1824]},{"content":"The following summarizes C#’s operators, listing the operator categories in order of precedence from highest to lowest.","pos":[1826,1945]},{"content":"Operators in the same category have equal precedence.","pos":[1946,1999]},{"content":"Under each category is a list of expressions in that category along with the description of that expression type.","pos":[2000,2113]},{"content":"Primary","pos":[2117,2124]},{"pos":[2131,2151],"content":"<ph id=\"ph1\">`x.m`</ph>: Member access","source":"`x.m`: Member access"},{"pos":[2158,2198],"content":"<ph id=\"ph1\">`x(...)`</ph>: Method and delegate invocation","source":"`x(...)`: Method and delegate invocation"},{"pos":[2205,2239],"content":"<ph id=\"ph1\">`x[...]`</ph>: Array and indexer access","source":"`x[...]`: Array and indexer access"},{"pos":[2246,2267],"content":"<ph id=\"ph1\">`x++`</ph>: Post-increment","source":"`x++`: Post-increment"},{"pos":[2274,2295],"content":"<ph id=\"ph1\">`x--`</ph>: Post-decrement","source":"`x--`: Post-decrement"},{"pos":[2302,2344],"content":"<ph id=\"ph1\">`new T(...)`</ph>: Object and delegate creation","source":"`new T(...)`: Object and delegate creation"},{"pos":[2351,2402],"content":"<ph id=\"ph1\">`new T(...){...}`</ph>: Object creation with initializer","source":"`new T(...){...}`: Object creation with initializer"},{"pos":[2409,2451],"content":"<ph id=\"ph1\">`new {...}`</ph>:  Anonymous object initializer","source":"`new {...}`:  Anonymous object initializer"},{"pos":[2458,2486],"content":"<ph id=\"ph1\">`new T[...]`</ph>: Array creation","source":"`new T[...]`: Array creation"},{"pos":[2493,2546],"content":"<ph id=\"ph1\">`typeof(T)`</ph>: Obtain <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object for <ph id=\"ph3\">`T`</ph>","source":"`typeof(T)`: Obtain <xref:System.Type> object for `T`"},{"pos":[2553,2605],"content":"<ph id=\"ph1\">`checked(x)`</ph>: Evaluate expression in checked context","source":"`checked(x)`: Evaluate expression in checked context"},{"pos":[2612,2668],"content":"<ph id=\"ph1\">`unchecked(x)`</ph>: Evaluate expression in unchecked context","source":"`unchecked(x)`: Evaluate expression in unchecked context"},{"pos":[2675,2721],"content":"<ph id=\"ph1\">`default(T)`</ph>: Obtain default value of type <ph id=\"ph2\">`T`</ph>","source":"`default(T)`: Obtain default value of type `T`"},{"pos":[2728,2783],"content":"<ph id=\"ph1\">`delegate {...}`</ph>: Anonymous function (anonymous method)","source":"`delegate {...}`: Anonymous function (anonymous method)"},{"content":"Unary","pos":[2786,2791]},{"pos":[2798,2812],"content":"<ph id=\"ph1\">`+x`</ph>: Identity","source":"`+x`: Identity"},{"pos":[2819,2833],"content":"<ph id=\"ph1\">`-x`</ph>: Negation","source":"`-x`: Negation"},{"pos":[2840,2862],"content":"<ph id=\"ph1\">`!x`</ph>: Logical negation","source":"`!x`: Logical negation"},{"pos":[2869,2891],"content":"<ph id=\"ph1\">`~x`</ph>: Bitwise negation","source":"`~x`: Bitwise negation"},{"pos":[2898,2918],"content":"<ph id=\"ph1\">`++x`</ph>: Pre-increment","source":"`++x`: Pre-increment"},{"pos":[2925,2945],"content":"<ph id=\"ph1\">`--x`</ph>: Pre-decrement","source":"`--x`: Pre-decrement"},{"pos":[2952,2994],"content":"<ph id=\"ph1\">`(T)x`</ph>: Explicitly convert <ph id=\"ph2\">`x`</ph> to type <ph id=\"ph3\">`T`</ph>","source":"`(T)x`: Explicitly convert `x` to type `T`"},{"pos":[3001,3051],"content":"<ph id=\"ph1\">`await x`</ph>: Asynchronously wait for <ph id=\"ph2\">`x`</ph> to complete","source":"`await x`: Asynchronously wait for `x` to complete"},{"content":"Multiplicative","pos":[3054,3068]},{"pos":[3075,3098],"content":"<ph id=\"ph1\">`x * y`</ph>: Multiplication","source":"`x * y`: Multiplication"},{"pos":[3105,3122],"content":"<ph id=\"ph1\">`x / y`</ph>: Division","source":"`x / y`: Division"},{"pos":[3129,3147],"content":"<ph id=\"ph1\">`x % y`</ph>: Remainder","source":"`x % y`: Remainder"},{"content":"Additive","pos":[3150,3158]},{"pos":[3165,3226],"content":"<ph id=\"ph1\">`x + y`</ph>: Addition, string concatenation, delegate combination","source":"`x + y`: Addition, string concatenation, delegate combination"},{"pos":[3233,3271],"content":"<ph id=\"ph1\">`x – y`</ph>: Subtraction, delegate removal","source":"`x – y`: Subtraction, delegate removal"},{"content":"Shift","pos":[3274,3279]},{"pos":[3286,3306],"content":"<ph id=\"ph1\">`x &lt;&lt; y`</ph>: Shift left","source":"`x << y`: Shift left"},{"pos":[3313,3334],"content":"<ph id=\"ph1\">`x &gt;&gt; y`</ph>: Shift right","source":"`x >> y`: Shift right"},{"content":"Relational and type testing","pos":[3337,3364]},{"pos":[3371,3389],"content":"<ph id=\"ph1\">`x &lt; y`</ph>: Less than","source":"`x < y`: Less than"},{"pos":[3396,3417],"content":"<ph id=\"ph1\">`x &gt; y`</ph>: Greater than","source":"`x > y`: Greater than"},{"pos":[3424,3452],"content":"<ph id=\"ph1\">`x &lt;= y`</ph>: Less than or equal","source":"`x <= y`: Less than or equal"},{"pos":[3459,3490],"content":"<ph id=\"ph1\">`x &gt;= y`</ph>: Greater than or equal","source":"`x >= y`: Greater than or equal"},{"pos":[3497,3555],"content":"<ph id=\"ph1\">`x is T`</ph>: Return <ph id=\"ph2\">`true`</ph> if <ph id=\"ph3\">`x`</ph> is a <ph id=\"ph4\">`T`</ph>, <ph id=\"ph5\">`false`</ph> otherwise","source":"`x is T`: Return `true` if `x` is a `T`, `false` otherwise"},{"pos":[3562,3626],"content":"<ph id=\"ph1\">`x as T`</ph>: Return <ph id=\"ph2\">`x`</ph> typed as <ph id=\"ph3\">`T`</ph>, or <ph id=\"ph4\">`null`</ph> if <ph id=\"ph5\">`x`</ph> is not a <ph id=\"ph6\">`T`</ph>","source":"`x as T`: Return `x` typed as `T`, or `null` if `x` is not a `T`"},{"content":"Equality","pos":[3629,3637]},{"pos":[3644,3659],"content":"<ph id=\"ph1\">`x == y`</ph>: Equal","source":"`x == y`: Equal"},{"pos":[3666,3685],"content":"<ph id=\"ph1\">`x != y`</ph>: Not equal","source":"`x != y`: Not equal"},{"content":"Logical AND","pos":[3688,3699]},{"pos":[3706,3755],"content":"<ph id=\"ph1\">`x &amp; y`</ph>: Integer bitwise AND, boolean logical AND","source":"`x & y`: Integer bitwise AND, boolean logical AND"},{"content":"Logical XOR","pos":[3758,3769]},{"pos":[3776,3825],"content":"<ph id=\"ph1\">`x ^ y`</ph>: Integer bitwise XOR, boolean logical XOR","source":"`x ^ y`: Integer bitwise XOR, boolean logical XOR"},{"content":"Logical OR","pos":[3828,3838]},{"pos":[3845,3892],"content":"<ph id=\"ph1\">`x | y`</ph>: Integer bitwise OR, boolean logical OR","source":"`x | y`: Integer bitwise OR, boolean logical OR"},{"content":"Conditional AND","pos":[3895,3910]},{"pos":[3917,3967],"content":"<ph id=\"ph1\">`x &amp;&amp; y`</ph>: Evaluates <ph id=\"ph2\">`y`</ph> only if <ph id=\"ph3\">`x`</ph> is not <ph id=\"ph4\">`false`</ph>","source":"`x && y`: Evaluates `y` only if `x` is not `false`"},{"content":"Conditional OR","pos":[3970,3984]},{"pos":[3991,4040],"content":"<ph id=\"ph1\">`x || y`</ph>: Evaluates <ph id=\"ph2\">`y`</ph> only if <ph id=\"ph3\">`x`</ph> is not <ph id=\"ph4\">`true`</ph>","source":"`x || y`: Evaluates `y` only if `x` is not `true`"},{"content":"Null coalescing","pos":[4043,4058]},{"pos":[4065,4124],"content":"<ph id=\"ph1\">`x ?? y`</ph>: Evaluates to <ph id=\"ph2\">`y`</ph> if <ph id=\"ph3\">`x`</ph> is null, to <ph id=\"ph4\">`x`</ph> otherwise","source":"`x ?? y`: Evaluates to `y` if `x` is null, to `x` otherwise"},{"content":"Conditional","pos":[4127,4138]},{"pos":[4145,4211],"content":"<ph id=\"ph1\">`x ? y : z`</ph>: Evaluates <ph id=\"ph2\">`y`</ph> if <ph id=\"ph3\">`x`</ph> is <ph id=\"ph4\">`true`</ph>, <ph id=\"ph5\">`z`</ph> if <ph id=\"ph6\">`x`</ph> is <ph id=\"ph7\">`false`</ph>","source":"`x ? y : z`: Evaluates `y` if `x` is `true`, `z` if `x` is `false`"},{"content":"Assignment or anonymous function","pos":[4214,4246]},{"pos":[4253,4272],"content":"<ph id=\"ph1\">`x = y`</ph>: Assignment","source":"`x = y`: Assignment"},{"pos":[4279,4334],"content":"<ph id=\"ph1\">`x op= y`</ph>: Compound assignment; supported operators are","source":"`x op= y`: Compound assignment; supported operators are"},{"pos":[4345,4412],"content":"<ph id=\"ph1\">`*=`</ph>   <ph id=\"ph2\">`/=`</ph>   <ph id=\"ph3\">`%=`</ph>   <ph id=\"ph4\">`+=`</ph>   <ph id=\"ph5\">`-=`</ph>   <ph id=\"ph6\">`&lt;&lt;=`</ph>   <ph id=\"ph7\">`&gt;&gt;=`</ph>   <ph id=\"ph8\">`&amp;=`</ph>  <ph id=\"ph9\">`^=`</ph>  <ph id=\"ph10\">`|=`</ph>","source":"`*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`  `^=`  `|=`"},{"pos":[4419,4471],"content":"<ph id=\"ph1\">`(T x) =&gt; y`</ph>: Anonymous function (lambda expression)","source":"`(T x) => y`: Anonymous function (lambda expression)"},{"pos":[4475,4563],"content":"[!div class=\"step-by-step\"]\n[Previous](types-and-variables.md)\n[Next](statements.md)","leadings":["","> ","> "],"nodes":[{"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](types-and-variables.md)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\">[</bpt>Next<ept id=\"p2\">](statements.md)</ept>","pos":[28,84],"source":"[Previous](types-and-variables.md)\n[Next](statements.md)"}]}]}