{"content":"---\ntitle: \"Hosting Win32 Content in WPF\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords:\n  - \"interoperability [WPF], tutorials\"\n  - \"Win32 code [WPF], WPF interoperation\"\n  - \"interoperability [WPF], Win32\"\nms.assetid: 3cc8644a-34f3-4082-9ddc-77623e4df2d8\n---\n\n# Hosting Win32 Content in WPF\n\n## Prerequisites\n\nSee [WPF and Win32 Interoperation](wpf-and-win32-interoperation.md).\n\n## A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)\n\nTo reuse [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] content inside [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, use <xref:System.Windows.Interop.HwndHost>, which is a control that makes HWNDs look like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content. Like <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost> is straightforward to use: derive from <xref:System.Windows.Interop.HwndHost> and implement `BuildWindowCore` and `DestroyWindowCore` methods, then instantiate your <xref:System.Windows.Interop.HwndHost> derived class and place it inside your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.\n\nIf your [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] logic is already packaged as a control, then your `BuildWindowCore` implementation is little more than a call to `CreateWindow`. For example, to create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] LISTBOX control in [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]:\n\n```cpp\nvirtual HandleRef BuildWindowCore(HandleRef hwndParent) override {\n    HWND handle = CreateWindowEx(0, L\"LISTBOX\",\n    L\"this is a Win32 listbox\",\n    WS_CHILD | WS_VISIBLE | LBS_NOTIFY\n    | WS_VSCROLL | WS_BORDER,\n    0, 0, // x, y\n    30, 70, // height, width\n    (HWND) hwndParent.Handle.ToPointer(), // parent hwnd\n    0, // hmenu\n    0, // hinstance\n    0); // lparam\n\n    return HandleRef(this, IntPtr(handle));\n}\n\nvirtual void DestroyWindowCore(HandleRef hwnd) override {\n    // HwndHost will dispose the hwnd for us\n}\n```\n\nBut suppose the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code is not quite so self-contained? If so, you can create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] dialog box and embed its contents into a larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application. The sample shows this in [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)], although it is also possible to do this in a different language or at the command line.\n\nStart with a simple dialog, which is compiled into a [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] project.\n\nNext, introduce the dialog into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application:\n\n- Compile the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] as managed (`/clr`)\n\n- Turn the dialog into a control\n\n- Define the derived class of <xref:System.Windows.Interop.HwndHost> with `BuildWindowCore` and `DestroyWindowCore` methods\n\n- Override `TranslateAccelerator` method to handle dialog keys\n\n- Override `TabInto` method to support tabbing\n\n- Override `OnMnemonic` method to support mnemonics\n\n- Instantiate the <xref:System.Windows.Interop.HwndHost> subclass and put it under the right [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element\n\n### Turn the Dialog into a Control\n\nYou can turn a dialog box into a child HWND using the WS_CHILD and DS_CONTROL styles. Go into the resource file (.rc) where the dialog is defined, and find the beginning of the definition of the dialog:\n\n```\nIDD_DIALOG1 DIALOGEX 0, 0, 303, 121\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\n```\n\nChange the second line to:\n\n```\nSTYLE DS_SETFONT | WS_CHILD | WS_BORDER | DS_CONTROL\n```\n\nThis action does not fully package it into a self-contained control; you still need to call `IsDialogMessage()` so [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] can process certain messages, but the control change does provide a straightforward way of putting those controls inside another HWND.\n\n## Subclass HwndHost\n\nImport the following namespaces:\n\n```cpp\nnamespace ManagedCpp\n{\n    using namespace System;\n    using namespace System::Windows;\n    using namespace System::Windows::Interop;\n    using namespace System::Windows::Input;\n    using namespace System::Windows::Media;\n    using namespace System::Runtime::InteropServices;\n```\n\nThen create a derived class of <xref:System.Windows.Interop.HwndHost> and override the `BuildWindowCore` and `DestroyWindowCore` methods:\n\n```cpp\npublic ref class MyHwndHost : public HwndHost, IKeyboardInputSink {\n    private:\n        HWND dialog;\n\n    protected:\n        virtual HandleRef BuildWindowCore(HandleRef hwndParent) override {\n            InitializeGlobals();\n            dialog = CreateDialog(hInstance,\n                MAKEINTRESOURCE(IDD_DIALOG1),\n                (HWND) hwndParent.Handle.ToPointer(),\n                (DLGPROC) About);\n            return HandleRef(this, IntPtr(dialog));\n        }\n\n        virtual void DestroyWindowCore(HandleRef hwnd) override {\n            // hwnd will be disposed for us\n        }\n```\n\nHere you use the `CreateDialog` to create the dialog box that is really a control. Since this is one of the first methods called inside the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)], you should also do some standard [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] initialization by calling a function you will define later, called `InitializeGlobals()`:\n\n```cpp\nbool initialized = false;\n    void InitializeGlobals() {\n        if (initialized) return;\n        initialized = true;\n\n        // TODO: Place code here.\n        MSG msg;\n        HACCEL hAccelTable;\n\n        // Initialize global strings\n        LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);\n        LoadString(hInstance, IDC_TYPICALWIN32DIALOG, szWindowClass, MAX_LOADSTRING);\n        MyRegisterClass(hInstance);\n```\n\n### Override TranslateAccelerator Method to Handle Dialog Keys\n\nIf you ran this sample now, you would get a dialog control that displays, but it would ignore all of the keyboard processing that makes a dialog box a functional dialog box. You should now override the `TranslateAccelerator` implementation (which comes from `IKeyboardInputSink`, an interface that <xref:System.Windows.Interop.HwndHost> implements). This method gets called when the application receives WM_KEYDOWN and WM_SYSKEYDOWN.\n\n```cpp\n#undef TranslateAccelerator\n        virtual bool TranslateAccelerator(System::Windows::Interop::MSG% msg,\n            ModifierKeys modifiers) override\n        {\n            ::MSG m = ConvertMessage(msg);\n\n            // Win32's IsDialogMessage() will handle most of our tabbing, but doesn't know\n            // what to do when it reaches the last tab stop\n            if (m.message == WM_KEYDOWN && m.wParam == VK_TAB) {\n                HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1);\n                HWND lastTabStop = GetDlgItem(dialog, IDCANCEL);\n                TraversalRequest^ request = nullptr;\n\n                if (GetKeyState(VK_SHIFT) && GetFocus() == firstTabStop) {\n                    // this code should work, but there’s a bug with interop shift-tab in current builds\n                    request = gcnew TraversalRequest(FocusNavigationDirection::Last);\n                }\n                else if (!GetKeyState(VK_SHIFT) && GetFocus() == lastTabStop) {\n                    request = gcnew TraversalRequest(FocusNavigationDirection::Next);\n                }\n\n                if (request != nullptr)\n                    return ((IKeyboardInputSink^) this)->KeyboardInputSite->OnNoMoreTabStops(request);\n\n            }\n\n            // Only call IsDialogMessage for keys it will do something with.\n            if (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN) {\n                switch (m.wParam) {\n                    case VK_TAB:\n                    case VK_LEFT:\n                    case VK_UP:\n                    case VK_RIGHT:\n                    case VK_DOWN:\n                    case VK_EXECUTE:\n                    case VK_RETURN:\n                    case VK_ESCAPE:\n                    case VK_CANCEL:\n                        IsDialogMessage(dialog, &m);\n                        // IsDialogMessage should be called ProcessDialogMessage --\n                        // it processes messages without ever really telling you\n                        // if it handled a specific message or not\n                        return true;\n                }\n            }\n\n            return false; // not a key we handled\n        }\n```\n\nThis is a lot of code in one piece, so it could use some more detailed explanations. First, the code using [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] macros; you need to be aware that there is already a macro named `TranslateAccelerator`, which is defined in winuser.h:\n\n```cpp\n#define TranslateAccelerator  TranslateAcceleratorW\n```\n\nSo make sure to define a `TranslateAccelerator` method and not a `TranslateAcceleratorW` method.\n\nSimilarly, there is both the unmanaged winuser.h MSG and the managed `Microsoft::Win32::MSG` struct. You can disambiguate between the two using the [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] `::` operator.\n\n```cpp\nvirtual bool TranslateAccelerator(System::Windows::Interop::MSG% msg,\n    ModifierKeys modifiers) override\n{\n    ::MSG m = ConvertMessage(msg);\n}\n\nBoth MSGs have the same data, but sometimes it is easier to work with the unmanaged definition, so in this sample you can define the obvious conversion routine:\n\n```cpp\n::MSG ConvertMessage(System::Windows::Interop::MSG% msg) {\n    ::MSG m;\n    m.hwnd = (HWND) msg.hwnd.ToPointer();\n    m.lParam = (LPARAM) msg.lParam.ToPointer();\n    m.message = msg.message;\n    m.wParam = (WPARAM) msg.wParam.ToPointer();\n\n    m.time = msg.time;\n\n    POINT pt;\n    pt.x = msg.pt_x;\n    pt.y = msg.pt_y;\n    m.pt = pt;\n\n    return m;\n}\n```\n\nBack to `TranslateAccelerator`. The basic principle is to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `IsDialogMessage` to do as much work as possible, but `IsDialogMessage` does not have access to anything outside the dialog. As a user tab around the dialog, when tabbing runs past the last control in our dialog, you need to set focus to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] portion by calling `IKeyboardInputSite::OnNoMoreStops`.\n\n```cpp\n// Win32's IsDialogMessage() will handle most of the tabbing, but doesn't know\n// what to do when it reaches the last tab stop\nif (m.message == WM_KEYDOWN && m.wParam == VK_TAB) {\n    HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1);\n    HWND lastTabStop = GetDlgItem(dialog, IDCANCEL);\n    TraversalRequest^ request = nullptr;\n\n    if (GetKeyState(VK_SHIFT) && GetFocus() == firstTabStop) {\n        request = gcnew TraversalRequest(FocusNavigationDirection::Last);\n    }\n    else if (!GetKeyState(VK_SHIFT) && GetFocus() ==  lastTabStop) { {\n        request = gcnew TraversalRequest(FocusNavigationDirection::Next);\n    }\n\n    if (request != nullptr)\n        return ((IKeyboardInputSink^) this)->KeyboardInputSite->OnNoMoreTabStops(request);\n}\n```\n\nFinally, call `IsDialogMessage`. But one of the responsibilities of a `TranslateAccelerator` method is telling [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] whether you handled the keystroke or not. If you did not handle it, the input event can tunnel and bubble through the rest of the application. Here, you will expose a quirk of keyboard messange handling and the nature of the input architecture in [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]. Unfortunately, `IsDialogMessage` does not return in any way whether it handles a particular keystroke. Even worse, it will call `DispatchMessage()` on keystrokes it should not handle!  So you will have to reverse-engineer `IsDialogMessage`, and only call it for the keys you know it will handle:\n\n```cpp\n// Only call IsDialogMessage for keys it will do something with.\nif (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN) {\n    switch (m.wParam) {\n        case VK_TAB:\n        case VK_LEFT:\n        case VK_UP:\n        case VK_RIGHT:\n        case VK_DOWN:\n        case VK_EXECUTE:\n        case VK_RETURN:\n        case VK_ESCAPE:\n        case VK_CANCEL:\n            IsDialogMessage(dialog, &m);\n            // IsDialogMessage should be called ProcessDialogMessage --\n            // it processes messages without ever really telling you\n            // if it handled a specific message or not\n            return true;\n    }\n```\n\n### Override TabInto Method to Support Tabbing\n\nNow that you have implemented `TranslateAccelerator`, a user can tab around inside the dialog box and tab out of it into the greater [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application. But a user cannot tab back into the dialog box. To solve that, you override `TabInto`:\n\n```cpp\npublic:\n    virtual bool TabInto(TraversalRequest^ request) override {\n        if (request->FocusNavigationDirection == FocusNavigationDirection::Last) {\n            HWND lastTabStop = GetDlgItem(dialog, IDCANCEL);\n            SetFocus(lastTabStop);\n        }\n        else {\n            HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1);\n            SetFocus(firstTabStop);\n        }\n        return true;\n    }\n```\n\nThe `TraversalRequest` parameter tells you whether the tab action is a tab or shift tab.\n\n### Override OnMnemonic Method to Support Mnemonics\n\nKeyboard handling is almost complete, but there is one thing missing – mnemonics do not work. If a user presses alt-F, focus doe not jump to the \"First name:\" edit box. So, you override the `OnMnemonic` method:\n\n```cpp\nvirtual bool OnMnemonic(System::Windows::Interop::MSG% msg, ModifierKeys modifiers) override {\n    ::MSG m = ConvertMessage(msg);\n\n    // If it's one of our mnemonics, set focus to the appropriate hwnd\n    if (msg.message == WM_SYSCHAR && GetKeyState(VK_MENU /*alt*/)) {\n        int dialogitem = 9999;\n        switch (m.wParam) {\n            case 's': dialogitem = IDOK; break;\n            case 'c': dialogitem = IDCANCEL; break;\n            case 'f': dialogitem = IDC_EDIT1; break;\n            case 'l': dialogitem = IDC_EDIT2; break;\n            case 'p': dialogitem = IDC_EDIT3; break;\n            case 'a': dialogitem = IDC_EDIT4; break;\n            case 'i': dialogitem = IDC_EDIT5; break;\n            case 't': dialogitem = IDC_EDIT6; break;\n            case 'z': dialogitem = IDC_EDIT7; break;\n        }\n        if (dialogitem != 9999) {\n            HWND hwnd = GetDlgItem(dialog, dialogitem);\n            SetFocus(hwnd);\n            return true;\n        }\n    }\n    return false; // key unhandled\n};\n```\n\nWhy not call `IsDialogMessage` here?  You have the same issue as before--you need to be able to inform [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] code whether your code handled the keystroke or not, and `IsDialogMessage` cannot do that. There is also a second issue, because `IsDialogMessage` refuses to process the mnemonic if the focused HWND is not inside the dialog box.\n\n### Instantiate the HwndHost Derived Class\n\nFinally, now that all the key and tab support is in place, you can put your <xref:System.Windows.Interop.HwndHost> into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application. If the main application is written in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the easiest way to put it in the right place is to leave an empty <xref:System.Windows.Controls.Border> element where you want to put the <xref:System.Windows.Interop.HwndHost>. Here you create a <xref:System.Windows.Controls.Border> named `insertHwndHostHere`:\n\n```xaml\n<Window x:Class=\"WPFApplication1.Window1\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    Title=\"Windows Presentation Framework Application\"\n    Loaded=\"Window1_Loaded\"\n    >\n    <StackPanel>\n        <Button Content=\"WPF button\"/>\n        <Border Name=\"insertHwndHostHere\" Height=\"200\" Width=\"500\"/>\n        <Button Content=\"WPF button\"/>\n    </StackPanel>\n</Window>\n```\n\nThen all that remains is to find a good place in code sequence to instantiate the <xref:System.Windows.Interop.HwndHost> and connect it to the <xref:System.Windows.Controls.Border>. In this example, you will put it inside the constructor for the <xref:System.Windows.Window> derived class:\n\n```csharp\npublic partial class Window1 : Window {\n    public Window1() {\n    }\n\n    void Window1_Loaded(object sender, RoutedEventArgs e) {\n        HwndHost host = new ManagedCpp.MyHwndHost();\n        insertHwndHostHere.Child = host;\n    }\n}\n```\n\nWhich gives you:\n\n![WPF application screenshot](./media/interoparch09.PNG \"InteropArch09\")\n\n## See also\n\n- [WPF and Win32 Interoperation](wpf-and-win32-interoperation.md)\n","nodes":[{"pos":[4,252],"embed":true,"restype":"x-metadata","content":"title: \"Hosting Win32 Content in WPF\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords:\n  - \"interoperability [WPF], tutorials\"\n  - \"Win32 code [WPF], WPF interoperation\"\n  - \"interoperability [WPF], Win32\"\nms.assetid: 3cc8644a-34f3-4082-9ddc-77623e4df2d8","nodes":[{"content":"Hosting Win32 Content in WPF","nodes":[{"pos":[0,28],"content":"Hosting Win32 Content in WPF","nodes":[{"content":"Hosting Win32 Content in WPF","pos":[0,28]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[260,288],"content":"Hosting Win32 Content in WPF","linkify":"Hosting Win32 Content in WPF","nodes":[{"content":"Hosting Win32 Content in WPF","pos":[0,28]}]},{"pos":[293,306],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"pos":[308,376],"content":"See <bpt id=\"p1\">[</bpt>WPF and Win32 Interoperation<ept id=\"p1\">](wpf-and-win32-interoperation.md)</ept>.","source":"See [WPF and Win32 Interoperation](wpf-and-win32-interoperation.md)."},{"pos":[381,452],"content":"A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)","linkify":"A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)","nodes":[{"content":"A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)","pos":[0,71]}]},{"content":"To reuse <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> content inside <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications, use <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>, which is a control that makes HWNDs look like <ph id=\"ph4\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> content.","pos":[454,828],"source":"To reuse [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] content inside [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, use <xref:System.Windows.Interop.HwndHost>, which is a control that makes HWNDs look like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content."},{"content":"Like <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> is straightforward to use: derive from <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and implement <ph id=\"ph4\">`BuildWindowCore`</ph> and <ph id=\"ph5\">`DestroyWindowCore`</ph> methods, then instantiate your <ph id=\"ph6\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> derived class and place it inside your <ph id=\"ph7\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[829,1252],"source":" Like <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost> is straightforward to use: derive from <xref:System.Windows.Interop.HwndHost> and implement `BuildWindowCore` and `DestroyWindowCore` methods, then instantiate your <xref:System.Windows.Interop.HwndHost> derived class and place it inside your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"If your <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> logic is already packaged as a control, then your <ph id=\"ph2\">`BuildWindowCore`</ph> implementation is little more than a call to <ph id=\"ph3\">`CreateWindow`</ph>.","pos":[1254,1464],"source":"If your [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] logic is already packaged as a control, then your `BuildWindowCore` implementation is little more than a call to `CreateWindow`."},{"content":"For example, to create a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> LISTBOX control in <ph id=\"ph2\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph>:","pos":[1465,1651],"source":" For example, to create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] LISTBOX control in [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]:"},{"content":"But suppose the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> code is not quite so self-contained?","pos":[2192,2318],"source":"But suppose the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code is not quite so self-contained?"},{"content":"If so, you can create a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> dialog box and embed its contents into a larger <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[2319,2559],"source":" If so, you can create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] dialog box and embed its contents into a larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"The sample shows this in <ph id=\"ph1\">[!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph>, although it is also possible to do this in a different language or at the command line.","pos":[2560,2825],"source":" The sample shows this in [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)], although it is also possible to do this in a different language or at the command line."},{"pos":[2827,3026],"content":"Start with a simple dialog, which is compiled into a <ph id=\"ph1\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> <ph id=\"ph2\">[!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]</ph> project.","source":"Start with a simple dialog, which is compiled into a [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] project."},{"pos":[3028,3165],"content":"Next, introduce the dialog into the larger <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application:","source":"Next, introduce the dialog into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application:"},{"pos":[3169,3270],"content":"Compile the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]</ph> as managed (<ph id=\"ph2\">`/clr`</ph>)","source":"Compile the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] as managed (`/clr`)"},{"content":"Turn the dialog into a control","pos":[3274,3304]},{"pos":[3308,3429],"content":"Define the derived class of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> with <ph id=\"ph2\">`BuildWindowCore`</ph> and <ph id=\"ph3\">`DestroyWindowCore`</ph> methods","source":"Define the derived class of <xref:System.Windows.Interop.HwndHost> with `BuildWindowCore` and `DestroyWindowCore` methods"},{"pos":[3433,3493],"content":"Override <ph id=\"ph1\">`TranslateAccelerator`</ph> method to handle dialog keys","source":"Override `TranslateAccelerator` method to handle dialog keys"},{"pos":[3497,3541],"content":"Override <ph id=\"ph1\">`TabInto`</ph> method to support tabbing","source":"Override `TabInto` method to support tabbing"},{"pos":[3545,3594],"content":"Override <ph id=\"ph1\">`OnMnemonic`</ph> method to support mnemonics","source":"Override `OnMnemonic` method to support mnemonics"},{"pos":[3598,3778],"content":"Instantiate the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> subclass and put it under the right <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> element","source":"Instantiate the <xref:System.Windows.Interop.HwndHost> subclass and put it under the right [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element"},{"pos":[3784,3814],"content":"Turn the Dialog into a Control","linkify":"Turn the Dialog into a Control","nodes":[{"content":"Turn the Dialog into a Control","pos":[0,30]}]},{"content":"You can turn a dialog box into a child HWND using the WS_CHILD and DS_CONTROL styles.","pos":[3816,3901]},{"content":"Go into the resource file (.rc) where the dialog is defined, and find the beginning of the definition of the dialog:","pos":[3902,4018]},{"content":"Change the second line to:","pos":[4149,4175]},{"pos":[4239,4562],"content":"This action does not fully package it into a self-contained control; you still need to call <ph id=\"ph1\">`IsDialogMessage()`</ph> so <ph id=\"ph2\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> can process certain messages, but the control change does provide a straightforward way of putting those controls inside another HWND.","source":"This action does not fully package it into a self-contained control; you still need to call `IsDialogMessage()` so [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] can process certain messages, but the control change does provide a straightforward way of putting those controls inside another HWND."},{"pos":[4567,4584],"content":"Subclass HwndHost","linkify":"Subclass HwndHost","nodes":[{"content":"Subclass HwndHost","pos":[0,17]}]},{"content":"Import the following namespaces:","pos":[4586,4618]},{"pos":[4908,5045],"content":"Then create a derived class of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and override the <ph id=\"ph2\">`BuildWindowCore`</ph> and <ph id=\"ph3\">`DestroyWindowCore`</ph> methods:","source":"Then create a derived class of <xref:System.Windows.Interop.HwndHost> and override the `BuildWindowCore` and `DestroyWindowCore` methods:"},{"content":"Here you use the <ph id=\"ph1\">`CreateDialog`</ph> to create the dialog box that is really a control.","pos":[5647,5729],"source":"Here you use the `CreateDialog` to create the dialog box that is really a control."},{"content":"Since this is one of the first methods called inside the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]</ph>, you should also do some standard <ph id=\"ph2\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> initialization by calling a function you will define later, called <ph id=\"ph3\">`InitializeGlobals()`</ph>:","pos":[5730,6054],"source":" Since this is one of the first methods called inside the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)], you should also do some standard [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] initialization by calling a function you will define later, called `InitializeGlobals()`:"},{"pos":[6501,6559],"content":"Override TranslateAccelerator Method to Handle Dialog Keys","linkify":"Override TranslateAccelerator Method to Handle Dialog Keys","nodes":[{"content":"Override TranslateAccelerator Method to Handle Dialog Keys","pos":[0,58]}]},{"content":"If you ran this sample now, you would get a dialog control that displays, but it would ignore all of the keyboard processing that makes a dialog box a functional dialog box.","pos":[6561,6734]},{"content":"You should now override the <ph id=\"ph1\">`TranslateAccelerator`</ph> implementation (which comes from <ph id=\"ph2\">`IKeyboardInputSink`</ph>, an interface that <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> implements).","pos":[6735,6910],"source":" You should now override the `TranslateAccelerator` implementation (which comes from `IKeyboardInputSink`, an interface that <xref:System.Windows.Interop.HwndHost> implements)."},{"content":"This method gets called when the application receives WM_KEYDOWN and WM_SYSKEYDOWN.","pos":[6911,6994]},{"content":"This is a lot of code in one piece, so it could use some more detailed explanations.","pos":[9161,9245]},{"content":"First, the code using <ph id=\"ph1\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> macros; you need to be aware that there is already a macro named <ph id=\"ph3\">`TranslateAccelerator`</ph>, which is defined in winuser.h:","pos":[9246,9527],"source":" First, the code using [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] macros; you need to be aware that there is already a macro named `TranslateAccelerator`, which is defined in winuser.h:"},{"pos":[9593,9689],"content":"So make sure to define a <ph id=\"ph1\">`TranslateAccelerator`</ph> method and not a <ph id=\"ph2\">`TranslateAcceleratorW`</ph> method.","source":"So make sure to define a `TranslateAccelerator` method and not a `TranslateAcceleratorW` method."},{"content":"Similarly, there is both the unmanaged winuser.h MSG and the managed <ph id=\"ph1\">`Microsoft::Win32::MSG`</ph> struct.","pos":[9691,9791],"source":"Similarly, there is both the unmanaged winuser.h MSG and the managed `Microsoft::Win32::MSG` struct."},{"content":"You can disambiguate between the two using the <ph id=\"ph1\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> <ph id=\"ph2\">`::`</ph> operator.","pos":[9792,9921],"source":" You can disambiguate between the two using the [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] `::` operator."},{"content":"Back to <ph id=\"ph1\">`TranslateAccelerator`</ph>.","pos":[10603,10634],"source":"Back to `TranslateAccelerator`."},{"content":"The basic principle is to call the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> function <ph id=\"ph2\">`IsDialogMessage`</ph> to do as much work as possible, but <ph id=\"ph3\">`IsDialogMessage`</ph> does not have access to anything outside the dialog.","pos":[10635,10877],"source":" The basic principle is to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `IsDialogMessage` to do as much work as possible, but `IsDialogMessage` does not have access to anything outside the dialog."},{"content":"As a user tab around the dialog, when tabbing runs past the last control in our dialog, you need to set focus to the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> portion by calling <ph id=\"ph2\">`IKeyboardInputSite::OnNoMoreStops`</ph>.","pos":[10878,11132],"source":" As a user tab around the dialog, when tabbing runs past the last control in our dialog, you need to set focus to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] portion by calling `IKeyboardInputSite::OnNoMoreStops`."},{"content":"Finally, call <ph id=\"ph1\">`IsDialogMessage`</ph>.","pos":[11892,11924],"source":"Finally, call `IsDialogMessage`."},{"content":"But one of the responsibilities of a <ph id=\"ph1\">`TranslateAccelerator`</ph> method is telling <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> whether you handled the keystroke or not.","pos":[11925,12126],"source":" But one of the responsibilities of a `TranslateAccelerator` method is telling [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] whether you handled the keystroke or not."},{"content":"If you did not handle it, the input event can tunnel and bubble through the rest of the application.","pos":[12127,12227]},{"content":"Here, you will expose a quirk of keyboard messange handling and the nature of the input architecture in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph>.","pos":[12228,12406],"source":" Here, you will expose a quirk of keyboard messange handling and the nature of the input architecture in [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]."},{"content":"Unfortunately, <ph id=\"ph1\">`IsDialogMessage`</ph> does not return in any way whether it handles a particular keystroke.","pos":[12407,12509],"source":" Unfortunately, `IsDialogMessage` does not return in any way whether it handles a particular keystroke."},{"content":"Even worse, it will call <ph id=\"ph1\">`DispatchMessage()`</ph> on keystrokes it should not handle!","pos":[12510,12590],"source":" Even worse, it will call `DispatchMessage()` on keystrokes it should not handle!"},{"content":"So you will have to reverse-engineer <ph id=\"ph1\">`IsDialogMessage`</ph>, and only call it for the keys you know it will handle:","pos":[12592,12702],"source":"  So you will have to reverse-engineer `IsDialogMessage`, and only call it for the keys you know it will handle:"},{"pos":[13347,13389],"content":"Override TabInto Method to Support Tabbing","linkify":"Override TabInto Method to Support Tabbing","nodes":[{"content":"Override TabInto Method to Support Tabbing","pos":[0,42]}]},{"content":"Now that you have implemented <ph id=\"ph1\">`TranslateAccelerator`</ph>, a user can tab around inside the dialog box and tab out of it into the greater <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[13391,13618],"source":"Now that you have implemented `TranslateAccelerator`, a user can tab around inside the dialog box and tab out of it into the greater [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"But a user cannot tab back into the dialog box.","pos":[13619,13666]},{"content":"To solve that, you override <ph id=\"ph1\">`TabInto`</ph>:","pos":[13667,13705],"source":" To solve that, you override `TabInto`:"},{"pos":[14130,14218],"content":"The <ph id=\"ph1\">`TraversalRequest`</ph> parameter tells you whether the tab action is a tab or shift tab.","source":"The `TraversalRequest` parameter tells you whether the tab action is a tab or shift tab."},{"pos":[14224,14271],"content":"Override OnMnemonic Method to Support Mnemonics","linkify":"Override OnMnemonic Method to Support Mnemonics","nodes":[{"content":"Override OnMnemonic Method to Support Mnemonics","pos":[0,47]}]},{"content":"Keyboard handling is almost complete, but there is one thing missing – mnemonics do not work.","pos":[14273,14366]},{"content":"If a user presses alt-F, focus doe not jump to the \"First name:\" edit box.","pos":[14367,14441]},{"content":"So, you override the <ph id=\"ph1\">`OnMnemonic`</ph> method:","pos":[14442,14483],"source":" So, you override the `OnMnemonic` method:"},{"content":"Why not call <ph id=\"ph1\">`IsDialogMessage`</ph> here?","pos":[15505,15541],"source":"Why not call `IsDialogMessage` here?"},{"content":"You have the same issue as before--you need to be able to inform <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> code whether your code handled the keystroke or not, and <ph id=\"ph2\">`IsDialogMessage`</ph> cannot do that.","pos":[15543,15780],"source":"  You have the same issue as before--you need to be able to inform [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] code whether your code handled the keystroke or not, and `IsDialogMessage` cannot do that."},{"content":"There is also a second issue, because <ph id=\"ph1\">`IsDialogMessage`</ph> refuses to process the mnemonic if the focused HWND is not inside the dialog box.","pos":[15781,15918],"source":" There is also a second issue, because `IsDialogMessage` refuses to process the mnemonic if the focused HWND is not inside the dialog box."},{"pos":[15924,15962],"content":"Instantiate the HwndHost Derived Class","linkify":"Instantiate the HwndHost Derived Class","nodes":[{"content":"Instantiate the HwndHost Derived Class","pos":[0,38]}]},{"content":"Finally, now that all the key and tab support is in place, you can put your <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> into the larger <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[15964,16189],"source":"Finally, now that all the key and tab support is in place, you can put your <xref:System.Windows.Interop.HwndHost> into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"If the main application is written in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, the easiest way to put it in the right place is to leave an empty <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border&gt;</ph> element where you want to put the <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>.","pos":[16190,16478],"source":" If the main application is written in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the easiest way to put it in the right place is to leave an empty <xref:System.Windows.Controls.Border> element where you want to put the <xref:System.Windows.Interop.HwndHost>."},{"content":"Here you create a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Border&gt;</ph> named <ph id=\"ph2\">`insertHwndHostHere`</ph>:","pos":[16479,16562],"source":" Here you create a <xref:System.Windows.Controls.Border> named `insertHwndHostHere`:"},{"content":"Then all that remains is to find a good place in code sequence to instantiate the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and connect it to the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border&gt;</ph>.","pos":[17029,17210],"source":"Then all that remains is to find a good place in code sequence to instantiate the <xref:System.Windows.Interop.HwndHost> and connect it to the <xref:System.Windows.Controls.Border>."},{"content":"In this example, you will put it inside the constructor for the <ph id=\"ph1\">&lt;xref:System.Windows.Window&gt;</ph> derived class:","pos":[17211,17318],"source":" In this example, you will put it inside the constructor for the <xref:System.Windows.Window> derived class:"},{"content":"Which gives you:","pos":[17567,17583]},{"pos":[17585,17657],"content":"<bpt id=\"p1\">![</bpt>WPF application screenshot<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/interoparch09.PNG \"</bpt>InteropArch09<ept id=\"p2\">\")</ept>","source":"![WPF application screenshot](./media/interoparch09.PNG \"InteropArch09\")"},{"pos":[17662,17670],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[17674,17737],"content":"<bpt id=\"p1\">[</bpt>WPF and Win32 Interoperation<ept id=\"p1\">](wpf-and-win32-interoperation.md)</ept>","source":"[WPF and Win32 Interoperation](wpf-and-win32-interoperation.md)"}]}