{"content":"---\ntitle: \"Thread Local Storage: Thread-Relative Static Fields and Data Slots\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"threading [.NET Framework], local storage\"\n  - \"threading [.NET Framework], thread-relative static fields\"\n  - \"local thread storage\"\n  - \"TLS\"\nms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Thread Local Storage: Thread-Relative Static Fields and Data Slots\nYou can use managed thread local storage (TLS) to store data that is unique to a thread and application domain. The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.  \n  \n-   Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time. Thread-relative static fields provide the best performance. They also give you the benefits of compile-time type checking.  \n  \n-   Use data slots when your actual requirements might be discovered only at run time. Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.  \n  \n In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage. Thread-relative static fields and data slots provide the managed version of this behavior.  \n  \n In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed. For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).  \n  \n## Uniqueness of Data in Managed TLS  \n Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.  \n  \n-   Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.  \n  \n-   When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.  \n  \n For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain. Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.  \n  \n Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.  \n  \n## Thread-Relative Static Fields  \n If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field. Use the field as you would use any other static field. The data in the field is unique to each thread that uses it.  \n  \n Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.  \n  \n Be aware that any class constructor code will run on the first thread in the first context that accesses the field. In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types. Therefore, you should not rely on class constructors to initialize thread-relative static fields. Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.  \n  \n## Data Slots  \n The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain. There are two types of data slots: named slots and unnamed slots. Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.  \n  \n-   To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method. To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.  \n  \n-   To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.  \n  \n For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot. These are static methods that always act on the data for the thread that is currently executing them.  \n  \n Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot. However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data. (This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)  \n  \n## See also\n\n- <xref:System.ContextStaticAttribute>\n- <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>\n- <xref:System.ThreadStaticAttribute>\n- <xref:System.Runtime.Remoting.Messaging.CallContext>\n- [Threading](../../../docs/standard/threading/index.md)\n","nodes":[{"pos":[4,392],"embed":true,"restype":"x-metadata","content":"title: \"Thread Local Storage: Thread-Relative Static Fields and Data Slots\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"threading [.NET Framework], local storage\"\n  - \"threading [.NET Framework], thread-relative static fields\"\n  - \"local thread storage\"\n  - \"TLS\"\nms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Thread Local Storage: Thread-Relative Static Fields and Data Slots","nodes":[{"pos":[0,66],"content":"Thread Local Storage: Thread-Relative Static Fields and Data Slots","nodes":[{"content":"Thread Local Storage: Thread-Relative Static Fields and Data Slots","pos":[0,66]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[399,465],"content":"Thread Local Storage: Thread-Relative Static Fields and Data Slots","linkify":"Thread Local Storage: Thread-Relative Static Fields and Data Slots","nodes":[{"content":"Thread Local Storage: Thread-Relative Static Fields and Data Slots","pos":[0,66]}]},{"content":"You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.","pos":[466,577]},{"content":"The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.","pos":[578,680]},{"content":"Use thread-relative static fields (thread-relative <ph id=\"ph1\">`Shared`</ph> fields in Visual Basic) if you can anticipate your exact needs at compile time.","pos":[690,829],"source":"Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time."},{"content":"Thread-relative static fields provide the best performance.","pos":[830,889]},{"content":"They also give you the benefits of compile-time type checking.","pos":[890,952]},{"content":"Use data slots when your actual requirements might be discovered only at run time.","pos":[962,1044]},{"content":"Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, so you must cast it to the correct type before you use it.","pos":[1045,1234],"source":" Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it."},{"content":"In unmanaged C++, you use <ph id=\"ph1\">`TlsAlloc`</ph> to allocate slots dynamically and <ph id=\"ph2\">`__declspec(thread)`</ph> to declare that a variable should be allocated in thread-relative storage.","pos":[1241,1407],"source":"In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage."},{"content":"Thread-relative static fields and data slots provide the managed version of this behavior.","pos":[1408,1498]},{"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, you can use the <ph id=\"ph2\">&lt;xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType&gt;</ph> class to create thread-local objects that are initialized lazily when the object is first consumed.","pos":[1505,1760],"source":"In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Lazy Initialization<ept id=\"p1\">](../../../docs/framework/performance/lazy-initialization.md)</ept>.","pos":[1761,1869],"source":" For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md)."},{"pos":[1878,1911],"content":"Uniqueness of Data in Managed TLS","linkify":"Uniqueness of Data in Managed TLS","nodes":[{"content":"Uniqueness of Data in Managed TLS","pos":[0,33]}]},{"content":"Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.","pos":[1915,2058]},{"content":"Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.","pos":[2068,2199]},{"content":"When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.","pos":[2209,2348]},{"content":"For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.","pos":[2355,2616]},{"content":"Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.","pos":[2617,2750]},{"content":"Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.","pos":[2757,2956]},{"pos":[2965,2994],"content":"Thread-Relative Static Fields","linkify":"Thread-Relative Static Fields","nodes":[{"content":"Thread-Relative Static Fields","pos":[0,29]}]},{"content":"If you know that a piece of data is always unique to a thread and application-domain combination, apply the <ph id=\"ph1\">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to the static field.","pos":[2998,3172],"source":"If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field."},{"content":"Use the field as you would use any other static field.","pos":[3173,3227]},{"content":"The data in the field is unique to each thread that uses it.","pos":[3228,3288]},{"content":"Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.","pos":[3295,3419]},{"content":"Be aware that any class constructor code will run on the first thread in the first context that accesses the field.","pos":[3426,3541]},{"content":"In all other threads or contexts in the same application domain, the fields will be initialized to <ph id=\"ph1\">`null`</ph> (<ph id=\"ph2\">`Nothing`</ph> in Visual Basic) if they are reference types, or to their default values if they are value types.","pos":[3542,3756],"source":" In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types."},{"content":"Therefore, you should not rely on class constructors to initialize thread-relative static fields.","pos":[3757,3854]},{"content":"Instead, avoid initializing thread-relative static fields and assume that they are initialized to <ph id=\"ph1\">`null`</ph> (<ph id=\"ph2\">`Nothing`</ph>) or to their default values.","pos":[3855,3999],"source":" Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values."},{"pos":[4008,4018],"content":"Data Slots","linkify":"Data Slots","nodes":[{"content":"Data Slots","pos":[0,10]}]},{"content":"The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.","pos":[4022,4135]},{"content":"There are two types of data slots: named slots and unnamed slots.","pos":[4136,4201]},{"content":"Both are implemented by using the <ph id=\"ph1\">&lt;xref:System.LocalDataStoreSlot&gt;</ph> structure.","pos":[4202,4279],"source":" Both are implemented by using the <xref:System.LocalDataStoreSlot> structure."},{"content":"To create a named data slot, use the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[4289,4501],"source":"To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method."},{"content":"To get a reference to an existing named slot, pass its name to the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method.","pos":[4502,4627],"source":" To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method."},{"pos":[4637,4764],"content":"To create an unnamed data slot, use the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType&gt;</ph> method.","source":"To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method."},{"content":"For both named and unnamed slots, use the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType&gt;</ph> methods to set and retrieve the information in the slot.","pos":[4771,5015],"source":"For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot."},{"content":"These are static methods that always act on the data for the thread that is currently executing them.","pos":[5016,5117]},{"content":"Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method, instead of maintaining a reference to an unnamed slot.","pos":[5124,5346],"source":"Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot."},{"content":"However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.","pos":[5347,5556]},{"content":"(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)","pos":[5557,5700]},{"pos":[5709,5717],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5935,5989],"content":"<bpt id=\"p1\">[</bpt>Threading<ept id=\"p1\">](../../../docs/standard/threading/index.md)</ept>","source":"[Threading](../../../docs/standard/threading/index.md)"}]}