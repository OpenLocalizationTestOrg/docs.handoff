<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="introduction-to-linq-queries.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1f15867c76a3498ac49df0bff6a7953f668b1a6f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\concepts\linq\introduction-to-linq-queries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9052485e5bcdf4e0ecd4e071feec928382ff8034</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dcd316d3301bf3ff3385c8340e53af4fbdb7a46b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Introduction to LINQ Queries (C#)</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Introduction to LINQ Queries (C#)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>query<ept id="p1">*</ept> is an expression that retrieves data from a data source.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Queries are usually expressed in a specialized query language.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Different languages have been developed over time for the various types of data sources, for example SQL for relational databases and XQuery for XML.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Therefore, developers have had to learn a new query language for each type of data source or data format that they must support.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> simplifies this situation by offering a consistent model for working with data across various kinds of data sources and formats.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In a <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query, you are always working with objects.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You use the same basic coding patterns to query and transform data in XML documents, SQL databases, <ph id="ph1">[!INCLUDE[vstecado](~/includes/vstecado-md.md)]</ph> Datasets, .NET collections, and any other format for which a <ph id="ph2">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> provider is available.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Three Parts of a Query Operation</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>All <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query operations consist of three distinct actions:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Obtain the data source.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Create the query.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Execute the query.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The following example shows how the three parts of a query operation are expressed in source code.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The example uses an integer array as a data source for convenience; however, the same concepts apply to other data sources also.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This example is referred to throughout the rest of this topic.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following illustration shows the complete query operation.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> the execution of the query is distinct from the query itself; in other words you have not retrieved any data just by creating a query variable.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Diagram of the complete LINQ query operation.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The Data Source</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In the previous example, because the data source is an array, it implicitly supports the generic <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This fact means it can be queried with <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A query is executed in a <ph id="ph1">`foreach`</ph> statement, and <ph id="ph2">`foreach`</ph> requires <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Types that support <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> or a derived interface such as the generic <ph id="ph2">&lt;xref:System.Linq.IQueryable%601&gt;</ph> are called <bpt id="p1">*</bpt>queryable types<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A queryable type requires no modification or special treatment to serve as a <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> data source.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If the source data is not already in memory as a queryable type, the <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> provider must represent it as such.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> loads an XML document into a queryable <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph> type:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph>, you first create an object-relational mapping at design time either manually or by using the <bpt id="p1">[</bpt>LINQ to SQL Tools in Visual Studio<ept id="p1">](/visualstudio/data-tools/linq-to-sql-tools-in-visual-studio2)</ept> in Visual Studio.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You write your queries against the objects, and at run-time <ph id="ph1">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> handles the communication with the database.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`Customers`</ph> represents a specific table in the database, and the type of the query result, <ph id="ph2">&lt;xref:System.Linq.IQueryable%601&gt;</ph>, derives from <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For more information about how to create specific types of data sources, see the documentation for the various <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> providers.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, the basic rule is very simple: a <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> data source is any object that supports the generic <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface, or an interface that inherits from it.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Types such as <ph id="ph1">&lt;xref:System.Collections.ArrayList&gt;</ph> that support the non-generic <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface can also be used as a <ph id="ph3">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> data source.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Query an ArrayList with LINQ (C#)<ept id="p1">](../../../../csharp/programming-guide/concepts/linq/how-to-query-an-arraylist-with-linq.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="query"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> The Query</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The query specifies what information to retrieve from the data source or sources.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Optionally, a query also specifies how that information should be sorted, grouped, and shaped before it is returned.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A query is stored in a query variable and initialized with a query expression.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>To make it easier to write queries, C# has introduced new query syntax.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The query in the previous example returns all the even numbers from the integer array.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The query expression contains three clauses: <ph id="ph1">`from`</ph>, <ph id="ph2">`where`</ph> and <ph id="ph3">`select`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>(If you are familiar with SQL, you will have noticed that the ordering of the clauses is reversed from the order in SQL.) The <ph id="ph1">`from`</ph> clause specifies the data source, the <ph id="ph2">`where`</ph> clause applies the filter, and the <ph id="ph3">`select`</ph> clause specifies the type of the returned elements.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>These and the other query clauses are discussed in detail in the <bpt id="p1">[</bpt>LINQ Query Expressions<ept id="p1">](../../../../csharp/programming-guide/linq-query-expressions/index.md)</ept> section.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For now, the important point is that in <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>, the query variable itself takes no action and returns no data.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>It just stores the information that is required to produce the results when the query is executed at some later point.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information about how queries are constructed behind the scenes, see <bpt id="p1">[</bpt>Standard Query Operators Overview (C#)<ept id="p1">](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Queries can also be expressed by using method syntax.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Query Syntax and Method Syntax in LINQ<ept id="p1">](../../../../csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Query Execution</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Deferred Execution</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>As stated previously, the query variable itself only stores the query commands.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The actual execution of the query is deferred until you iterate over the query variable in a <ph id="ph1">`foreach`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This concept is referred to as <bpt id="p1">*</bpt>deferred execution<ept id="p1">*</ept> and is demonstrated in the following example:</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`foreach`</ph> statement is also where the query results are retrieved.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For example, in the previous query, the iteration variable <ph id="ph1">`num`</ph> holds each value (one at a time) in the returned sequence.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Because the query variable itself never holds the query results, you can execute it as often as you like.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For example, you may have a database that is being updated continually by a separate application.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In your application, you could create one query that retrieves the latest data, and you could execute it repeatedly at some interval to retrieve different results every time.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Forcing Immediate Execution</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Queries that perform aggregation functions over a range of source elements must first iterate over those elements.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Examples of such queries are <ph id="ph1">`Count`</ph>, <ph id="ph2">`Max`</ph>, <ph id="ph3">`Average`</ph>, and <ph id="ph4">`First`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>These execute without an explicit <ph id="ph1">`foreach`</ph> statement because the query itself must use <ph id="ph2">`foreach`</ph> in order to return a result.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Note also that these types of queries return a single value, not an <ph id="ph1">`IEnumerable`</ph> collection.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following query returns a count of the even numbers in the source array:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>To force immediate execution of any query and cache its results, you can call the <ph id="ph1">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToArray%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can also force execution by putting the <ph id="ph1">`foreach`</ph> loop immediately after the query expression.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, by calling <ph id="ph1">`ToList`</ph> or <ph id="ph2">`ToArray`</ph> you also cache all the data in a single collection object.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started with LINQ in C#<ept id="p1">](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Walkthrough: Writing Queries in C#<ept id="p1">](../../../../csharp/programming-guide/concepts/linq/walkthrough-writing-queries-linq.md)</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ Query Expressions<ept id="p1">](../../../../csharp/programming-guide/linq-query-expressions/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>foreach, in<ept id="p1">](../../../../csharp/language-reference/keywords/foreach-in.md)</ept></source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Query Keywords (LINQ)<ept id="p1">](../../../../csharp/language-reference/keywords/query-keywords.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>