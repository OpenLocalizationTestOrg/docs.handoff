<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">43ba8cdf265efd930199f7c6a8a77e49f491e737</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\statements-expressions-operators\lambda-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">efa64cfc2820390b22ae60241e8636cdb2473cf5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b4302ba1fc1c7c5c8de88a9db5919229069c5f6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (C# Programming Guide) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Lambda Expressions (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A lambda expression is an <bpt id="p1">[</bpt>anonymous function<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept> that you can use to create <bpt id="p2">[</bpt>delegates<ept id="p2">](../../../csharp/programming-guide/delegates/using-delegates.md)</ept> or <bpt id="p3">[</bpt>expression tree<ept id="p3">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept> types.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>By using lambda expressions, you can write local functions that can be passed as arguments or returned as the value of function calls.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Lambda expressions are particularly helpful for writing LINQ query expressions.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator <bpt id="p1">[</bpt><ph id="ph1">=&gt;</ph><ept id="p1">](../../../csharp/language-reference/operators/lambda-operator.md)</ept>, and you put the expression or statement block on the other side.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, the lambda expression <ph id="ph1">`x =&gt; x * x`</ph> specifies a parameter thatâ€™s named <ph id="ph2">`x`</ph> and returns the value of <ph id="ph3">`x`</ph> squared.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can assign this expression to a delegate type, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>To create an expression tree type:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`=&gt;`</ph> operator has the same precedence as assignment (<ph id="ph2">`=`</ph>) and is <bpt id="p1">[</bpt>right associative<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/operators.md)</ept> (see "Associativity" section of the Operators article).</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Lambdas are used in method-based <ph id="ph1">[!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)]</ph> queries as arguments to standard query operator methods such as <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When you use method-based syntax to call the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method in the <ph id="ph2">&lt;xref:System.Linq.Enumerable&gt;</ph> class (as you do in <ph id="ph3">[!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)]</ph> to Objects and <ph id="ph4">[!INCLUDE[sqltecxlinq](../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>) the parameter is a delegate type <ph id="ph5">&lt;xref:System.Func%602?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A lambda expression is the most convenient way to create that delegate.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you call the same method in, for example, the <ph id="ph1">&lt;xref:System.Linq.Queryable?displayProperty=fullName&gt;</ph> class (as you do in <ph id="ph2">[!INCLUDE[vbtecdlinq](../../../csharp/includes/vbtecdlinq_md.md)]</ph>) then the parameter type is an <ph id="ph3">&lt;xref:System.Linq.Expressions.Expression?displayProperty=fullName&gt;</ph>&lt;Func<ph id="ph4">\&gt;</ph> where Func is any of the Func delegates with up to sixteen input parameters.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Again, a lambda expression is just a very concise way to construct that expression tree.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The lambdas allow the <ph id="ph1">`Where`</ph> calls to look similar although in fact the type of object created from the lambda is different.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In the previous example, notice that the delegate signature has one implicitly-typed input parameter of type <ph id="ph1">`int`</ph>, and returns an <ph id="ph2">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The lambda expression can be converted to a delegate of that type because it also has one input parameter (<ph id="ph1">`x`</ph>) and a return value that the compiler can implicitly convert to type <ph id="ph2">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>(Type inference is discussed in more detail in the following sections.) When the delegate is invoked by using an input parameter of 5, it returns a result of 25.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Lambdas are not allowed on the left side of the <bpt id="p1">[</bpt>is<ept id="p1">](../../../csharp/language-reference/keywords/is.md)</ept> or <bpt id="p2">[</bpt>as<ept id="p2">](../../../csharp/language-reference/keywords/as.md)</ept> operator.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>All restrictions that apply to anonymous methods also apply to lambda expressions.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Anonymous Methods<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Expression Lambdas</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A lambda expression with an expression on the right side of the =&gt; operator is called an <bpt id="p1">*</bpt>expression lambda<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Expression lambdas are used extensively in the construction of <bpt id="p1">[</bpt>Expression Trees<ept id="p1">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>An expression lambda returns the result of the expression and takes the following basic form:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The parentheses are optional only if the lambda has one input parameter; otherwise they are required.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Two or more input parameters are separated by commas enclosed in parentheses:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Sometimes it is difficult or impossible for the compiler to infer the input types.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When this occurs, you can specify the types explicitly as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Specify zero input parameters with empty parentheses:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Note in the previous example that the body of an expression lambda can consist of a method call.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server, you should not use method calls in lambda expressions.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The methods will have no meaning outside the context of the .NET common language runtime.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Statement Lambdas</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>(input-parameters) =&gt; { statement; }</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>StatementLamba#1<ept id="p2">](../../../../samples\snippets\csharp\programming-guide\lambda-expressions/statements.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>StatementLamba#2<ept id="p2">](../../../../samples\snippets\csharp\programming-guide\lambda-expressions/statements.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Statement lambdas, like anonymous methods, cannot be used to create expression trees.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Async Lambdas</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <bpt id="p1">[</bpt>async<ept id="p1">](../../../csharp/language-reference/keywords/async.md)</ept> and <bpt id="p2">[</bpt>await<ept id="p2">](../../../csharp/language-reference/keywords/await.md)</ept> keywords.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <ph id="ph1">`ExampleMethodAsync`</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can add the same event handler by using an async lambda.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>To add this handler, add an <ph id="ph1">`async`</ph> modifier before the lambda parameter list, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information about how to create and use async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with async and await<ept id="p1">](../../../csharp/programming-guide/concepts/async/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Lambdas with the Standard Query Operators</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Many Standard query operators have an input parameter whose type is one of the <ph id="ph1">&lt;xref:System.Func%602&gt;</ph> family of generic delegates.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These delegates use type parameters to define the number and types of input parameters, and the return type of the delegate.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Func`</ph> delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For example, consider the following delegate type:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The delegate can be instantiated as <ph id="ph1">`Func&lt;int,bool&gt; myFunc`</ph> where <ph id="ph2">`int`</ph> is an input parameter and <ph id="ph3">`bool`</ph> is the return value.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The return value is always specified in the last type parameter.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Func&lt;int, string, bool&gt;`</ph> defines a delegate with two input parameters, <ph id="ph2">`int`</ph> and <ph id="ph3">`string`</ph>, and a return type of <ph id="ph4">`bool`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following <ph id="ph1">`Func`</ph> delegate, when it is invoked, will return true or false to indicate whether the input parameter is equal to 5:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can also supply a lambda expression when the argument type is an <ph id="ph1">`Expression&lt;Func&gt;`</ph>, for example in the standard query operators that are defined in System.Linq.Queryable.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When you specify an <ph id="ph1">`Expression&lt;Func&gt;`</ph> argument, the lambda will be compiled to an expression tree.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A standard query operator, the <ph id="ph1">&lt;xref:System.Linq.Enumerable.Count%2A&gt;</ph> method, is shown here:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The compiler can infer the type of the input parameter, or you can also specify it explicitly.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This particular lambda expression counts those integers (<ph id="ph1">`n`</ph>) which when divided by two have a remainder of 1.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The following line of code produces a sequence that contains all elements in the <ph id="ph1">`numbers`</ph> array that are to the left side of the 9 because that's the first number in the sequence that doesn't meet the condition:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example shows how to specify multiple input parameters by enclosing them in parentheses.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The method returns all the elements in the numbers array until a number is encountered whose value is less than its position.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Do not confuse the lambda operator (<ph id="ph1">`=&gt;`</ph>) with the greater than or equal operator (<ph id="ph2">`&gt;=`</ph>).</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Type Inference in Lambdas</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameterâ€™s delegate type, and other factors as described in the C# Language Specification.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For most of the standard query operators, the first input is the type of the elements in the source sequence.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>So if you are querying an <ph id="ph1">`IEnumerable&lt;Customer&gt;`</ph>, then the input variable is inferred to be a <ph id="ph2">`Customer`</ph> object, which means you have access to its methods and properties:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The general rules for lambdas are as follows:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The lambda must contain the same number of parameters as the delegate type.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of "lambda expression."</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>However, it is sometimes convenient to speak informally of the "type" of a lambda expression.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>In these cases the type refers to the delegate type or <ph id="ph1">&lt;xref:System.Linq.Expressions.Expression&gt;</ph> type to which the lambda expression is converted.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Variable Scope in Lambda Expressions</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Lambdas can refer to <bpt id="p1">*</bpt>outer variables<ept id="p1">*</ept> (see <bpt id="p2">[</bpt>Anonymous Methods<ept id="p2">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>An outer variable must be definitely assigned before it can be consumed in a lambda expression.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following example demonstrates these rules:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following rules apply to variable scope in lambda expressions:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Variables introduced within a lambda expression are not visible in the outer method.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A lambda expression cannot directly capture a <ph id="ph1">`ref`</ph> or <ph id="ph2">`out`</ph> parameter from an enclosing method.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A return statement in a lambda expression does not cause the enclosing method to return.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A lambda expression cannot contain a <ph id="ph1">`goto`</ph> statement, <ph id="ph2">`break`</ph> statement, or <ph id="ph3">`continue`</ph> statement that is inside the lambda function if the jump statementâ€™s target is outside the block.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It is also an error to have a jump statement outside the lambda function block if the target is inside the block.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>C# Language Specification</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Featured Book Chapter</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Delegates, Events, and Lambda Expressions<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=195395)</ept> in <bpt id="p2">[</bpt>C# 3.0 Cookbook, Third Edition: More than 250 solutions for C# 3.0 programmers<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=195369)</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ (Language-Integrated Query)<ept id="p1">](http://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anonymous Methods<ept id="p1">](../../../csharp/programming-guide/statements-expressions-operators/anonymous-methods.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>is<ept id="p1">](../../../csharp/language-reference/keywords/is.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Expression Trees<ept id="p1">](http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Visual Studio 2008 C# Samples (see LINQ Sample Queries files and XQuery program)<ept id="p1">](http://code.msdn.microsoft.com/Visual-Studio-2008-C-d295cdba)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Recursive lambda expressions<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=112395)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>