{"content":"---\ntitle: \"Chaining Tasks by Using Continuation Tasks\"\nms.date: \"02/11/2019\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"tasks, continuations\"\nms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Chaining Tasks by Using Continuation Tasks\nIn asynchronous programming, it is common for one asynchronous operation, on completion, to invoke a second operation and pass data to it. Traditionally, continuations have been done by using callback methods. In the Task Parallel Library, the same functionality is provided by *continuation tasks*. A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent finishes.  \n  \n Continuations are relatively easy to use, but are nevertheless powerful and flexible. For example, you can:  \n  \n-   Pass data from the antecedent to the continuation.  \n  \n-   Specify the precise conditions under which the continuation will be invoked or not invoked.  \n  \n-   Cancel a continuation either before it starts or cooperatively as it is running.  \n  \n-   Provide hints about how the continuation should be scheduled.  \n  \n-   Invoke multiple continuations from the same antecedent.  \n  \n-   Invoke one continuation when all or any one of multiple antecedents complete.  \n  \n-   Chain continuations one after another to any arbitrary length.  \n  \n-   Use a continuation to handle exceptions thrown by the antecedent.  \n  \n## About continuations  \n A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state. It is activated automatically when its antecedent task or tasks complete. Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.  \n  \n A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started. Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.  \n  \n## Creating a continuation for a single antecedent  \n You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method. The following example shows the basic pattern (for clarity, exception handling is omitted). It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week. When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result. \n\n> [!NOTE]\n> The C# samples in this article make use of the `async` modifier on the `Main` method. That feature is available in C# 7.1 and later. Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code. You'll need to set the language version to C# 7.1 or newer. You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).\n  \n [!code-csharp[TPL_Continuations#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/simple1.cs#1)]\n [!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]  \n  \n## Creating a continuation for multiple antecedents  \n You can also create a continuation that will run when any or all of a group of tasks has completed. To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method. To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.  \n  \n Note that calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.  However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and  <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.  \n  \n The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks. Each antecedent task squares an index value that ranges from one to 10. If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent. The example adds them to compute the sum of squares for all numbers between one and 10.  \n  \n [!code-csharp[TPL_Continuations#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/whenall1.cs#5)]\n [!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]  \n  \n## Continuation options  \n When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts. For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state. If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started.  \n  \n A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter. Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however. You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>. If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.  \n  \n For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.  \n  \n## Passing Data to a Continuation  \n The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument. If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.  \n  \n The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed. However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception. You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.  \n  \n [!code-csharp[TPL_Continuations#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result1.cs#2)]\n [!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]  \n  \n If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception. One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>. You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent. For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md). The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.  \n  \n [!code-csharp[TPL_Continuations#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result2.cs#7)]\n [!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]  \n  \n## Canceling a Continuation  \n The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:  \n  \n-   It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request. As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgement of cooperative cancellation.  \n  \n-   The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`. In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.  \n  \n-   The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met. For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.  \n  \n If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example. It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation. The continuation in turn displays the list. Both the antecedent and the continuation pause regularly for random intervals. In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval. This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method. Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses. If the antecedent is canceled, the continuation will not start. If the antecedent is not canceled, the token can still be used to cancel the continuation.  \n  \n [!code-csharp[TPL_Continuations#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation1.cs#3)]\n [!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]  \n  \n You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation. The following is a simple example.  \n  \n [!code-csharp[TPL_Continuations#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation2.cs#8)]\n [!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]  \n  \n After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.  \n  \n Continuations that are disposed will not start.  \n  \n## Continuations and Child Tasks  \n A continuation does not run until the antecedent and all of its attached child tasks have completed. The continuation does not wait for detached child tasks to finish. The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation. In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time. The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  \n  \n [!code-csharp[TPL_Continuations#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/attached1.cs#9)]\n [!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]  \n  \n If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks. As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.  \n  \n [!code-csharp[TPL_Continuations#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/detached1.cs#10)]\n [!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]  \n  \n The final status of the antecedent task depends on the final status of any attached child tasks. The status of detached child tasks does not affect the parent. For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  \n  \n## Associating State with Continuations  \n You can associate arbitrary state with a task continuation. The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation. You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property. This state object is `null` if you do not provide a value.  \n  \n Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL. In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property. By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.  \n  \n Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger. For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task. For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).  \n  \n The following example shows how to use continuation state. It creates a chain of continuation tasks. Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method. Each <xref:System.DateTime> object represents the time at which the continuation task is created. Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes. After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.  \n  \n [!code-csharp[TPL_ContinuationState#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]\n [!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  \n  \n## Handling Exceptions Thrown from Continuations  \n An antecedent-continuation relationship is not a parent-child relationship. Exceptions thrown by continuations are not propagated to the antecedent. Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:  \n  \n-   You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation. You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.  \n  \n     [!code-csharp[TPL_Continuations#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception1.cs#6)]\n     [!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]  \n  \n-   You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation. In the following example, a task attempts to read from a non-existent file. The continuation then displays information about the exception in the antecedent task.  \n  \n     [!code-csharp[TPL_Continuations#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#4)]\n     [!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]  \n  \n     Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`. If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.  \n  \n     [!code-csharp[TPL_Continuations#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#11)]\n     [!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]  \n  \n     For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  \n  \n-   If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child. For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  \n  \n## See also\n\n- [Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)\n","nodes":[{"pos":[4,280],"embed":true,"restype":"x-metadata","content":"title: \"Chaining Tasks by Using Continuation Tasks\"\nms.date: \"02/11/2019\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"tasks, continuations\"\nms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Chaining Tasks by Using Continuation Tasks","nodes":[{"pos":[0,42],"content":"Chaining Tasks by Using Continuation Tasks","nodes":[{"content":"Chaining Tasks by Using Continuation Tasks","pos":[0,42]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[287,329],"content":"Chaining Tasks by Using Continuation Tasks","linkify":"Chaining Tasks by Using Continuation Tasks","nodes":[{"content":"Chaining Tasks by Using Continuation Tasks","pos":[0,42]}]},{"content":"In asynchronous programming, it is common for one asynchronous operation, on completion, to invoke a second operation and pass data to it.","pos":[330,468]},{"content":"Traditionally, continuations have been done by using callback methods.","pos":[469,539]},{"content":"In the Task Parallel Library, the same functionality is provided by <bpt id=\"p1\">*</bpt>continuation tasks<ept id=\"p1\">*</ept>.","pos":[540,629],"source":" In the Task Parallel Library, the same functionality is provided by *continuation tasks*."},{"content":"A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the <bpt id=\"p1\">*</bpt>antecedent<ept id=\"p1\">*</ept>, when the antecedent finishes.","pos":[630,808],"source":" A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent finishes."},{"content":"Continuations are relatively easy to use, but are nevertheless powerful and flexible.","pos":[815,900]},{"content":"For example, you can:","pos":[901,922]},{"content":"Pass data from the antecedent to the continuation.","pos":[932,982]},{"content":"Specify the precise conditions under which the continuation will be invoked or not invoked.","pos":[992,1083]},{"content":"Cancel a continuation either before it starts or cooperatively as it is running.","pos":[1093,1173]},{"content":"Provide hints about how the continuation should be scheduled.","pos":[1183,1244]},{"content":"Invoke multiple continuations from the same antecedent.","pos":[1254,1309]},{"content":"Invoke one continuation when all or any one of multiple antecedents complete.","pos":[1319,1396]},{"content":"Chain continuations one after another to any arbitrary length.","pos":[1406,1468]},{"content":"Use a continuation to handle exceptions thrown by the antecedent.","pos":[1478,1543]},{"pos":[1552,1571],"content":"About continuations","linkify":"About continuations","nodes":[{"content":"About continuations","pos":[0,19]}]},{"content":"A continuation is a task that is created in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.WaitingForActivation&gt;</ph> state.","pos":[1575,1691],"source":"A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state."},{"content":"It is activated automatically when its antecedent task or tasks complete.","pos":[1692,1765]},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> on a continuation in user code throws an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException?displayProperty=nameWithType&gt;</ph> exception.","pos":[1766,1967],"source":" Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception."},{"content":"A continuation is itself a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and does not block the thread on which it is started.","pos":[1974,2089],"source":"A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method to block until the continuation task finishes.","pos":[2090,2224],"source":" Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes."},{"pos":[2233,2280],"content":"Creating a continuation for a single antecedent","linkify":"Creating a continuation for a single antecedent","nodes":[{"content":"Creating a continuation for a single antecedent","pos":[0,47]}]},{"content":"You create a continuation that executes when its antecedent has completed by calling the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[2284,2460],"source":"You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method."},{"content":"The following example shows the basic pattern (for clarity, exception handling is omitted).","pos":[2461,2552]},{"content":"It executes an antecedent task, <ph id=\"ph1\">`taskA`</ph>, that returns a <ph id=\"ph2\">&lt;xref:System.DayOfWeek&gt;</ph> object that indicates the name of the current day of the week.","pos":[2553,2695],"source":" It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week."},{"content":"When the antecedent completes, the continuation task, <ph id=\"ph1\">`continuation`</ph>, is passed the antecedent and displays a string that includes its result.","pos":[2696,2838],"source":" When the antecedent completes, the continuation task, `continuation`, is passed the antecedent and displays a string that includes its result."},{"pos":[2843,3308],"content":"[!NOTE]\nThe C# samples in this article make use of the `async` modifier on the `Main` method. That feature is available in C# 7.1 and later. Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code. You'll need to set the language version to C# 7.1 or newer. You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).","leadings":["","> "],"nodes":[{"content":"The C# samples in this article make use of the `async` modifier on the `Main` method. That feature is available in C# 7.1 and later. Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code. You'll need to set the language version to C# 7.1 or newer. You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md).","pos":[8,463],"nodes":[{"content":"The C# samples in this article make use of the <ph id=\"ph1\">`async`</ph> modifier on the <ph id=\"ph2\">`Main`</ph> method.","pos":[0,85],"source":"The C# samples in this article make use of the `async` modifier on the `Main` method."},{"content":"That feature is available in C# 7.1 and later.","pos":[86,132]},{"content":"Previous versions generate <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`CS5001`</ph><ept id=\"p1\">](../../csharp/misc/cs5001.md)</ept> when compiling this sample code.","pos":[133,232],"source":" Previous versions generate [`CS5001`](../../csharp/misc/cs5001.md) when compiling this sample code."},{"content":"You'll need to set the language version to C# 7.1 or newer.","pos":[233,292]},{"content":"You can learn how to configure the language version in the article on <bpt id=\"p1\">[</bpt>configure language version<ept id=\"p1\">](../../csharp/language-reference/configure-language-version.md)</ept>.","pos":[293,455],"source":" You can learn how to configure the language version in the article on [configure language version](../../csharp/language-reference/configure-language-version.md)."}]}]},{"pos":[3565,3613],"content":"Creating a continuation for multiple antecedents","linkify":"Creating a continuation for multiple antecedents","nodes":[{"content":"Creating a continuation for multiple antecedents","pos":[0,48]}]},{"content":"You can also create a continuation that will run when any or all of a group of tasks has completed.","pos":[3617,3716]},{"content":"To execute a continuation when all antecedent tasks have completed, you call the static (<ph id=\"ph1\">`Shared`</ph> in Visual Basic) <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType&gt;</ph> method or the instance <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[3717,4027],"source":" To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method."},{"content":"To execute a continuation when any of the antecedent tasks has completed, you call the static (<ph id=\"ph1\">`Shared`</ph> in Visual Basic) <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> method or the instance <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[4028,4344],"source":" To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method."},{"content":"Note that calls to the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> overloads do not block the calling thread.","pos":[4351,4570],"source":"Note that calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread."},{"content":"However, you typically call all but the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType&gt;</ph> and  <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType&gt;</ph> methods to retrieve the returned  <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property, which does block the calling thread.","pos":[4572,5035],"source":"  However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and  <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread."},{"content":"The following example calls the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType&gt;</ph> method to create a continuation task that reflects the results of its 10 antecedent tasks.","pos":[5042,5313],"source":"The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its 10 antecedent tasks."},{"content":"Each antecedent task squares an index value that ranges from one to 10.","pos":[5314,5385]},{"content":"If the antecedents complete successfully (their <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property is <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType&gt;</ph>), the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property of the continuation is an array of the <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> values returned by each antecedent.","pos":[5386,5851],"source":" If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent."},{"content":"The example adds them to compute the sum of squares for all numbers between one and 10.","pos":[5852,5939]},{"pos":[6200,6220],"content":"Continuation options","linkify":"Continuation options","nodes":[{"content":"Continuation options","pos":[0,20]}]},{"content":"When you create a single-task continuation, you can use a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> overload that takes a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType&gt;</ph> enumeration value to specify the conditions under which the continuation starts.","pos":[6224,6518],"source":"When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts."},{"content":"For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.","pos":[6519,6670]},{"content":"If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType&gt;</ph> state and subsequently cannot be started.","pos":[6671,6922],"source":" If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and subsequently cannot be started."},{"content":"A number of multi-task continuation methods, such as overloads of the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType&gt;</ph> method, also include a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType&gt;</ph> parameter.","pos":[6929,7205],"source":"A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter."},{"content":"Only a subset of all <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType&gt;</ph> enumeration members are valid, however.","pos":[7206,7349],"source":" Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however."},{"content":"You can specify <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType&gt;</ph> values that have counterparts in the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> enumeration, such as <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType&gt;</ph>.","pos":[7350,7885],"source":" You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>."},{"content":"If you specify any of the <ph id=\"ph1\">`NotOn`</ph> or <ph id=\"ph2\">`OnlyOn`</ph> options with a multi-task continuation, an <ph id=\"ph3\">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception will be thrown at run time.","pos":[7886,8054],"source":" If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time."},{"pos":[8061,8180],"content":"For more information on task continuation options, see the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> topic.","source":"For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic."},{"pos":[8189,8219],"content":"Passing Data to a Continuation","linkify":"Passing Data to a Continuation","nodes":[{"content":"Passing Data to a Continuation","pos":[0,30]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType&gt;</ph> method passes a reference to the antecedent to the user delegate of the continuation as an argument.","pos":[8223,8407],"source":"The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument."},{"content":"If the antecedent is a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType&gt;</ph> object, and the task ran until it was completed, then the continuation can access the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property of the task.","pos":[8408,8684],"source":" If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property blocks until the task has completed.","pos":[8691,8818],"source":"The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed."},{"content":"However, if the task was canceled or faulted, attempting to access the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property throws an <ph id=\"ph2\">&lt;xref:System.AggregateException&gt;</ph> exception.","pos":[8819,9001],"source":" However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception."},{"content":"You can avoid this problem by using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion&gt;</ph> option, as shown in the following example.","pos":[9002,9160],"source":" You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example."},{"content":"If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.","pos":[9417,9551]},{"content":"One approach is to test the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property of the antecedent, and only attempt to access the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property if the status is not <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.","pos":[9552,9894],"source":" One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>."},{"content":"You can also examine the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property of the antecedent.","pos":[9895,9995],"source":" You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.","pos":[9996,10132],"source":" For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)."},{"content":"The following example modifies the previous example to access antecedent's <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property only if its status is <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType&gt;</ph>.","pos":[10133,10403],"source":" The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>."},{"pos":[10662,10686],"content":"Canceling a Continuation","linkify":"Canceling a Continuation","nodes":[{"content":"Canceling a Continuation","pos":[0,24]}]},{"pos":[10690,10912],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property of a continuation is set to <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType&gt;</ph> in the following situations:","source":"The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:"},{"content":"It throws an <ph id=\"ph1\">&lt;xref:System.OperationCanceledException&gt;</ph> exception in response to a cancellation request.","pos":[10922,11024],"source":"It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request."},{"content":"As with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgement of cooperative cancellation.","pos":[11025,11185]},{"content":"The continuation is passed a <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken?displayProperty=nameWithType&gt;</ph> whose <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property is <ph id=\"ph3\">`true`</ph>.","pos":[11195,11389],"source":"The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`."},{"content":"In this case, the continuation does not start, and it transitions to the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType&gt;</ph> state.","pos":[11390,11548],"source":" In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state."},{"content":"The continuation never runs because the condition set by its <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> argument was not met.","pos":[11558,11694],"source":"The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met."},{"content":"For example, if an antecedent goes into a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType&gt;</ph> state, its continuation that was passed the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType&gt;</ph> option will not run but will transition to the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.","pos":[11695,12058],"source":" For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state."},{"content":"If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.","pos":[12065,12237]},{"content":"It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.","pos":[12238,12363]},{"content":"The continuation in turn displays the list.","pos":[12364,12407]},{"content":"Both the antecedent and the continuation pause regularly for random intervals.","pos":[12408,12486]},{"content":"In addition, a <ph id=\"ph1\">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> object is used to execute the <ph id=\"ph2\">`Elapsed`</ph> method after a five-second timeout interval.","pos":[12487,12645],"source":" In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval."},{"content":"This example calls the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method, which causes the currently executing task to call the <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[12646,12928],"source":" This example calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method."},{"content":"Whether the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.","pos":[12929,13155],"source":" Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses."},{"content":"If the antecedent is canceled, the continuation will not start.","pos":[13156,13219]},{"content":"If the antecedent is not canceled, the token can still be used to cancel the continuation.","pos":[13220,13310]},{"pos":[13317,13572],"content":"[!code-csharp[TPL_Continuations#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation1.cs#3)]\n[!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]","leadings":[""," "],"nodes":[]},{"content":"You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType&gt;</ph> option when you create the continuation.","pos":[13579,13871],"source":"You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation."},{"content":"The following is a simple example.","pos":[13872,13906]},{"pos":[13913,14168],"content":"[!code-csharp[TPL_Continuations#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation2.cs#8)]\n[!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]","leadings":[""," "],"nodes":[]},{"pos":[14175,14423],"content":"After a continuation goes into the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state, it may affect continuations that follow, depending on the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> that were specified for those continuations.","source":"After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations."},{"content":"Continuations that are disposed will not start.","pos":[14430,14477]},{"pos":[14486,14515],"content":"Continuations and Child Tasks","linkify":"Continuations and Child Tasks","nodes":[{"content":"Continuations and Child Tasks","pos":[0,29]}]},{"content":"A continuation does not run until the antecedent and all of its attached child tasks have completed.","pos":[14519,14619]},{"content":"The continuation does not wait for detached child tasks to finish.","pos":[14620,14686]},{"content":"The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.","pos":[14687,14818]},{"content":"In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.","pos":[14819,14985]},{"content":"The example launches the antecedent by calling the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method, since by default the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> method creates a parent task whose default task creation option is <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.","pos":[14986,15382],"source":" The example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>."},{"content":"If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.","pos":[15643,15808]},{"content":"As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.","pos":[15809,15952]},{"content":"The final status of the antecedent task depends on the final status of any attached child tasks.","pos":[16217,16313]},{"content":"The status of detached child tasks does not affect the parent.","pos":[16314,16376]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Attached and Detached Child Tasks<ept id=\"p1\">](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.","pos":[16377,16521],"source":" For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)."},{"pos":[16530,16566],"content":"Associating State with Continuations","linkify":"Associating State with Continuations","nodes":[{"content":"Associating State with Continuations","pos":[0,36]}]},{"content":"You can associate arbitrary state with a task continuation.","pos":[16570,16629]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> method provides overloaded versions that each take an <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> value that represents the state of the continuation.","pos":[16630,16812],"source":" The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation."},{"content":"You can later access this state object by using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType&gt;</ph> property.","pos":[16813,16952],"source":" You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property."},{"content":"This state object is <ph id=\"ph1\">`null`</ph> if you do not provide a value.","pos":[16953,17011],"source":" This state object is `null` if you do not provide a value."},{"content":"Continuation state is useful when you convert existing code that uses the <bpt id=\"p1\">[</bpt>Asynchronous Programming Model (APM)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)</ept> to use the TPL.","pos":[17018,17242],"source":"Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL."},{"content":"In the APM, you typically provide object state in the <bpt id=\"p1\">**</bpt>Begin<ept id=\"p1\">**</ept><bpt id=\"p2\">_</bpt>Method<ept id=\"p2\">_</ept> method and later access that state by using the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType&gt;</ph> property.","pos":[17243,17442],"source":" In the APM, you typically provide object state in the **Begin**_Method_ method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property."},{"content":"By using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> method, you can preserve this state when you convert code that uses the APM to use the TPL.","pos":[17443,17598],"source":" By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL."},{"content":"Continuation state can also be useful when you work with <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects in the Visual Studio debugger.","pos":[17605,17735],"source":"Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger."},{"content":"For example, in the <bpt id=\"p1\">**</bpt>Parallel Tasks<ept id=\"p1\">**</ept> window, the <bpt id=\"p2\">**</bpt>Task<ept id=\"p2\">**</ept> column displays the string representation of the state object for each task.","pos":[17736,17872],"source":" For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task."},{"content":"For more information about the <bpt id=\"p1\">**</bpt>Parallel Tasks<ept id=\"p1\">**</ept> window, see <bpt id=\"p2\">[</bpt>Using the Tasks Window<ept id=\"p2\">](/visualstudio/debugger/using-the-tasks-window)</ept>.","pos":[17873,18007],"source":" For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window)."},{"content":"The following example shows how to use continuation state.","pos":[18014,18072]},{"content":"It creates a chain of continuation tasks.","pos":[18073,18114]},{"content":"Each task provides the current time, a <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> object, for the <ph id=\"ph2\">`state`</ph> parameter of the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> method.","pos":[18115,18276],"source":" Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> object represents the time at which the continuation task is created.","pos":[18277,18374],"source":" Each <xref:System.DateTime> object represents the time at which the continuation task is created."},{"content":"Each task produces as its result a second <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> object that represents the time at which the task finishes.","pos":[18375,18499],"source":" Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes."},{"content":"After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.","pos":[18500,18618]},{"pos":[18913,18958],"content":"Handling Exceptions Thrown from Continuations","linkify":"Handling Exceptions Thrown from Continuations","nodes":[{"content":"Handling Exceptions Thrown from Continuations","pos":[0,45]}]},{"content":"An antecedent-continuation relationship is not a parent-child relationship.","pos":[18962,19037]},{"content":"Exceptions thrown by continuations are not propagated to the antecedent.","pos":[19038,19110]},{"content":"Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:","pos":[19111,19219]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> method, or its generic counterpart, to wait on the continuation.","pos":[19229,19449],"source":"You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation."},{"content":"You can wait for an antecedent and its continuations in the same <ph id=\"ph1\">`try`</ph> statement, as shown in the following example.","pos":[19450,19566],"source":" You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example."},{"pos":[19577,19830],"content":"[!code-csharp[TPL_Continuations#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception1.cs#6)]\n [!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]","leadings":["","    "],"nodes":[]},{"content":"You can use a second continuation to observe the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property of the first continuation.","pos":[19840,19972],"source":"You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation."},{"content":"In the following example, a task attempts to read from a non-existent file.","pos":[19973,20048]},{"content":"The continuation then displays information about the exception in the antecedent task.","pos":[20049,20135]},{"pos":[20146,20399],"content":"[!code-csharp[TPL_Continuations#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#4)]\n [!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]","leadings":["","    "],"nodes":[]},{"content":"Because it was run with the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType&gt;</ph> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property is not <ph id=\"ph3\">`null`</ph>.","pos":[20410,20737],"source":"Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`."},{"content":"If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property is not <ph id=\"ph2\">`null`</ph> before attempting to handle the exception, as the following code fragment shows.","pos":[20738,21023],"source":" If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows."},{"pos":[21034,21291],"content":"[!code-csharp[TPL_Continuations#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#11)]\n [!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]","leadings":["","    "],"nodes":[]},{"pos":[21302,21438],"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.","source":"For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)."},{"content":"If the continuation is an attached child task that was created by using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType&gt;</ph> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.","pos":[21448,21751],"source":"If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Attached and Detached Child Tasks<ept id=\"p1\">](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.","pos":[21752,21896],"source":" For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)."},{"pos":[21905,21913],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[21917,22020],"content":"<bpt id=\"p1\">[</bpt>Task Parallel Library (TPL)<ept id=\"p1\">](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)</ept>","source":"[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)"}]}