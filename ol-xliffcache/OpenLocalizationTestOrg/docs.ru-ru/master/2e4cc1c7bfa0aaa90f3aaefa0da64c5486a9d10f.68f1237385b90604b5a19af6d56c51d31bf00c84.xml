{"content":"---\ntitle: Strongly Typed Delegates\ndescription: Learn how to use generic delegate types to declare custom types when creating a feature requiring delegates.\nms.date: 06/20/2016\nms.assetid: 564a683d-352b-4e57-8bac-b466529daf6b\n---\n\n# Strongly Typed Delegates\n\n[Previous](delegate-class.md)\n\nIn the previous article, you saw that you create specific delegate\ntypes using the `delegate` keyword. \n\nThe abstract Delegate class provide the infrastructure for loose coupling\nand invocation. Concrete Delegate types become much more useful by embracing\nand enforcing type safety for the methods that are added to the invocation\nlist for a delegate object. When you use the `delegate` keyword and define\na concrete delegate type, the compiler generates those methods.\n\nIn practice, this would lead to creating new delegate types\nwhenever you need a different method signature. This work could get tedious\nafter a time. Every new feature requires new delegate types.\n\nThankfully, this isn't necessary. The .NET Core framework contains several\ntypes that you can reuse whenever you need delegate types. These are\n[generic](programming-guide/generics/index.md) definitions so you can declare customizations\nwhen you need new method declarations. \n\nThe first of these types is the <xref:System.Action> type, and several variations:\n\n```csharp\npublic delegate void Action();\npublic delegate void Action<in T>(T arg);\npublic delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);\n// Other variations removed for brevity.\n```\n\nThe `in` modifier on the generic type argument is covered in the article\non covariance.\n\nThere are variations of the `Action` delegate that contain up to\n16 arguments such as <xref:System.Action%6016>.\nIt's important that these definitions use different generic arguments for each of the\ndelegate arguments: That gives you maximum flexibility. The method arguments need not be, but may be, the same type.\n\nUse one of the `Action` types for any delegate type that has a void return type.\n\nThe framework also includes several generic delegate types that you can use for\ndelegate types that return values:\n\n```csharp\npublic delegate TResult Func<out TResult>();\npublic delegate TResult Func<in T1, out TResult>(T1 arg);\npublic delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);\n// Other variations removed for brevity\n```\n\nThe `out` modifier on the result generic type argument is covered in the\narticle on covariance.\n\nThere are variations of the `Func` delegate with up to\n16 input arguments such as <xref:System.Func%6017>.\nThe type of the result is always the last type parameter in all the `Func`\ndeclarations, by convention.\n\nUse one of the `Func` types for any delegate type that returns a value.\n\nThere's also a specialized\n<xref:System.Predicate%601> \ntype for a delegate that returns a test on a single value:\n\n```csharp\npublic delegate bool Predicate<in T>(T obj);\n```\n\nYou may notice that for any `Predicate` type, a structurally equivalent `Func`\ntype exists For example:\n\n```csharp\nFunc<string, bool> TestForString;\nPredicate<string> AnotherTestForString;\n```\n\nYou might think these two types are equivalent. They are not.\nThese two variables cannot be used interchangeably. A variable of one type cannot\nbe assigned the other type. The C# type system uses the names of the defined types,\nnot the structure.\n\nAll these delegate type definitions in the .NET Core Library should mean that\nyou do not need to define a new delegate type for any new feature you create\nthat requires delegates. These generic definitions should provide all the\ndelegate types you need under most situations. You can simply instantiate\none of these types with the required type parameters. In the case of algorithms\nthat can be made generic, these delegates can be used as generic types. \n\nThis should save time, and minimize the number of new types that you need\nto create in order to work with delegates.\n\nIn the next article, you'll see several common patterns for working\nwith delegates in practice.\n\n[Next](delegates-patterns.md)\n","nodes":[{"pos":[4,226],"embed":true,"restype":"x-metadata","content":"title: Strongly Typed Delegates\ndescription: Learn how to use generic delegate types to declare custom types when creating a feature requiring delegates.\nms.date: 06/20/2016\nms.assetid: 564a683d-352b-4e57-8bac-b466529daf6b","nodes":[{"content":"Strongly Typed Delegates","nodes":[{"pos":[0,24],"content":"Strongly Typed Delegates","nodes":[{"content":"Strongly Typed Delegates","pos":[0,24]}]}],"path":["title"],"nosxs":false},{"content":"Learn how to use generic delegate types to declare custom types when creating a feature requiring delegates.","nodes":[{"pos":[0,108],"content":"Learn how to use generic delegate types to declare custom types when creating a feature requiring delegates.","nodes":[{"content":"Learn how to use generic delegate types to declare custom types when creating a feature requiring delegates.","pos":[0,108]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[234,258],"content":"Strongly Typed Delegates","linkify":"Strongly Typed Delegates","nodes":[{"content":"Strongly Typed Delegates","pos":[0,24]}]},{"pos":[260,289],"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](delegate-class.md)</ept>","source":"[Previous](delegate-class.md)"},{"pos":[291,393],"content":"In the previous article, you saw that you create specific delegate types using the <ph id=\"ph1\">`delegate`</ph> keyword.","source":"In the previous article, you saw that you create specific delegate\ntypes using the `delegate` keyword."},{"content":"The abstract Delegate class provide the infrastructure for loose coupling and invocation.","pos":[396,485],"source":"The abstract Delegate class provide the infrastructure for loose coupling\nand invocation."},{"content":"Concrete Delegate types become much more useful by embracing and enforcing type safety for the methods that are added to the invocation list for a delegate object.","pos":[486,649],"source":" Concrete Delegate types become much more useful by embracing\nand enforcing type safety for the methods that are added to the invocation\nlist for a delegate object."},{"content":"When you use the <ph id=\"ph1\">`delegate`</ph> keyword and define a concrete delegate type, the compiler generates those methods.","pos":[650,760],"source":" When you use the `delegate` keyword and define\na concrete delegate type, the compiler generates those methods."},{"content":"In practice, this would lead to creating new delegate types whenever you need a different method signature.","pos":[762,869],"source":"In practice, this would lead to creating new delegate types\nwhenever you need a different method signature."},{"content":"This work could get tedious after a time.","pos":[870,911],"source":" This work could get tedious\nafter a time."},{"content":"Every new feature requires new delegate types.","pos":[912,958]},{"content":"Thankfully, this isn't necessary.","pos":[960,993]},{"content":"The .NET Core framework contains several types that you can reuse whenever you need delegate types.","pos":[994,1093],"source":" The .NET Core framework contains several\ntypes that you can reuse whenever you need delegate types."},{"content":"These are <bpt id=\"p1\">[</bpt>generic<ept id=\"p1\">](programming-guide/generics/index.md)</ept> definitions so you can declare customizations when you need new method declarations.","pos":[1094,1235],"source":" These are\n[generic](programming-guide/generics/index.md) definitions so you can declare customizations\nwhen you need new method declarations."},{"pos":[1238,1320],"content":"The first of these types is the <ph id=\"ph1\">&lt;xref:System.Action&gt;</ph> type, and several variations:","source":"The first of these types is the <xref:System.Action> type, and several variations:"},{"pos":[1512,1599],"content":"The <ph id=\"ph1\">`in`</ph> modifier on the generic type argument is covered in the article on covariance.","source":"The `in` modifier on the generic type argument is covered in the article\non covariance."},{"content":"There are variations of the <ph id=\"ph1\">`Action`</ph> delegate that contain up to 16 arguments such as <ph id=\"ph2\">&lt;xref:System.Action%6016&gt;</ph>.","pos":[1601,1713],"source":"There are variations of the `Action` delegate that contain up to\n16 arguments such as <xref:System.Action%6016>."},{"content":"It's important that these definitions use different generic arguments for each of the delegate arguments: That gives you maximum flexibility.","pos":[1714,1855],"source":"\nIt's important that these definitions use different generic arguments for each of the\ndelegate arguments: That gives you maximum flexibility."},{"content":"The method arguments need not be, but may be, the same type.","pos":[1856,1916]},{"pos":[1918,1998],"content":"Use one of the <ph id=\"ph1\">`Action`</ph> types for any delegate type that has a void return type.","source":"Use one of the `Action` types for any delegate type that has a void return type."},{"pos":[2000,2114],"content":"The framework also includes several generic delegate types that you can use for delegate types that return values:","source":"The framework also includes several generic delegate types that you can use for\ndelegate types that return values:"},{"pos":[2349,2444],"content":"The <ph id=\"ph1\">`out`</ph> modifier on the result generic type argument is covered in the article on covariance.","source":"The `out` modifier on the result generic type argument is covered in the\narticle on covariance."},{"content":"There are variations of the <ph id=\"ph1\">`Func`</ph> delegate with up to 16 input arguments such as <ph id=\"ph2\">&lt;xref:System.Func%6017&gt;</ph>.","pos":[2446,2552],"source":"There are variations of the `Func` delegate with up to\n16 input arguments such as <xref:System.Func%6017>."},{"content":"The type of the result is always the last type parameter in all the <ph id=\"ph1\">`Func`</ph> declarations, by convention.","pos":[2553,2656],"source":"\nThe type of the result is always the last type parameter in all the `Func`\ndeclarations, by convention."},{"pos":[2658,2729],"content":"Use one of the <ph id=\"ph1\">`Func`</ph> types for any delegate type that returns a value.","source":"Use one of the `Func` types for any delegate type that returns a value."},{"content":"There's also a specialized <ph id=\"ph1\">&lt;xref:System.Predicate%601&gt;</ph>","pos":[2731,2785],"source":"There's also a specialized\n<xref:System.Predicate%601>"},{"content":"type for a delegate that returns a test on a single value:","pos":[2787,2845],"source":"\ntype for a delegate that returns a test on a single value:"},{"pos":[2907,3010],"content":"You may notice that for any <ph id=\"ph1\">`Predicate`</ph> type, a structurally equivalent <ph id=\"ph2\">`Func`</ph> type exists For example:","source":"You may notice that for any `Predicate` type, a structurally equivalent `Func`\ntype exists For example:"},{"content":"You might think these two types are equivalent.","pos":[3101,3148]},{"content":"They are not.","pos":[3149,3162]},{"content":"These two variables cannot be used interchangeably.","pos":[3163,3214],"source":"\nThese two variables cannot be used interchangeably."},{"content":"A variable of one type cannot be assigned the other type.","pos":[3215,3272],"source":" A variable of one type cannot\nbe assigned the other type."},{"content":"The C# type system uses the names of the defined types, not the structure.","pos":[3273,3347],"source":" The C# type system uses the names of the defined types,\nnot the structure."},{"content":"All these delegate type definitions in the .NET Core Library should mean that you do not need to define a new delegate type for any new feature you create that requires delegates.","pos":[3349,3528],"source":"All these delegate type definitions in the .NET Core Library should mean that\nyou do not need to define a new delegate type for any new feature you create\nthat requires delegates."},{"content":"These generic definitions should provide all the delegate types you need under most situations.","pos":[3529,3624],"source":" These generic definitions should provide all the\ndelegate types you need under most situations."},{"content":"You can simply instantiate one of these types with the required type parameters.","pos":[3625,3705],"source":" You can simply instantiate\none of these types with the required type parameters."},{"content":"In the case of algorithms that can be made generic, these delegates can be used as generic types.","pos":[3706,3803],"source":" In the case of algorithms\nthat can be made generic, these delegates can be used as generic types."},{"pos":[3806,3922],"content":"This should save time, and minimize the number of new types that you need to create in order to work with delegates.","source":"This should save time, and minimize the number of new types that you need\nto create in order to work with delegates."},{"pos":[3924,4019],"content":"In the next article, you'll see several common patterns for working with delegates in practice.","source":"In the next article, you'll see several common patterns for working\nwith delegates in practice."},{"pos":[4021,4050],"content":"<bpt id=\"p1\">[</bpt>Next<ept id=\"p1\">](delegates-patterns.md)</ept>","source":"[Next](delegates-patterns.md)"}]}