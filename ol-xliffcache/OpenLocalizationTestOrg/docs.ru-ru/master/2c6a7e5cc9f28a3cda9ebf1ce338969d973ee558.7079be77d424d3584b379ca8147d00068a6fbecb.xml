{"content":"---\ntitle: \"Copying and Pinning | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"pinning, interop marshaling\"\n  - \"copying, interop marshaling\"\n  - \"interop marshaling, copying\"\n  - \"interop marshaling, pinning\"\nms.assetid: 0059f576-e460-4e70-b257-668870e420b8\ncaps.latest.revision: 8\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Copying and Pinning\nWhen marshaling data, the interop marshaler can copy or pin the data being marshaled. Copying the data places a copy of data from one memory location in another memory location. The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.  \n  \n ![Value types passed by value and by reference](../../../docs/framework/interop/media/interopmarshalcopy.gif \"interopmarshalcopy\")  \nValue types passed by value and by reference  \n  \n Method arguments passed by value are marshaled to unmanaged code as values on the stack. The copying process is direct. Arguments passed by reference are passed as pointers on the stack. Reference types are also passed by value and by reference. As the following illustration shows, reference types passed by value are either copied or pinned.  \n  \n ![COM interop](../../../docs/framework/interop/media/interopmarshalpin.gif \"interopmarshalpin\")  \nReference types passed by value and by reference  \n  \n Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector. The marshaler pins data to reduce the overhead of copying and enhance performance. The type of the data determines whether it is copied or pinned during the marshaling process.  Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.  \n  \n## Formatted Blittable Classes  \n Formatted [blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory. When these types require marshaling, a pointer to the object in the heap is passed to the callee directly. The callee can change the contents of the memory location being referenced by the pointer.  \n  \n> [!NOTE]\n>  The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types. Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.  \n  \n## Formatted Non-Blittable Classes  \n Formatted [non-blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory. The data can require transformation under the following conditions:  \n  \n-   If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.  \n  \n-   If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.  \n  \n-   If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.  \n  \n-   If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.  \n  \n-   If both **InAttribute** and **OutAttribute** are set, both copies are required. If either attribute is omitted, the marshaler can optimize by eliminating either copy.  \n  \n## Reference Types  \n Reference types can be passed by value or by reference. When they are passed by value, a pointer to the type is passed on the stack. When passed by reference, a pointer to a pointer to the type is passed on the stack.  \n  \n Reference types have the following conditional behavior:  \n  \n-   If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:  \n  \n    -   When an argument is passed to the unmanaged side.  \n  \n    -   On return from the call.  \n  \n     To avoid unnecessarily copying and conversion, these types are marshaled as In parameters. You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.  \n  \n-   If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller. Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior. Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.  \n  \n-   If a reference type is passed by reference, it will be marshaled as In/Out by default.  \n  \n## System.String and System.Text.StringBuilder  \n When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee. Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.  \n  \n As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.  \n  \n> [!CAUTION]\n>  When a string is passed by value, the callee must never alter the reference passed by the marshaler. Doing so can corrupt the managed heap.  \n  \n When a <xref:System.String?displayProperty=fullName> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call. It then copies the contents of the buffer into a new string on return from the call. This technique ensures that the immutable managed string remains unaltered.  \n  \n When a <xref:System.Text.StringBuilder?displayProperty=fullName> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller. The caller and callee must agree on the size of the buffer. The caller is responsible for creating a **StringBuilder** of adequate length. The callee must take the necessary precautions to ensure that the buffer is not overrun. **StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default. It is always passed as In/Out.  \n  \n## See Also  \n [Default Marshaling Behavior](../../../docs/framework/interop/default-marshaling-behavior.md)   \n [Memory Management with the Interop Marshaler](http://msdn.microsoft.com/en-us/417206ce-ee3e-4619-9529-0c0b686c7bee)   \n [Directional Attributes](http://msdn.microsoft.com/en-us/241ac5b5-928e-4969-8f58-1dbc048f9ea2)   \n [Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)","nodes":[{"pos":[4,559],"nodes":[{"content":"Copying and Pinning | Microsoft Docs","nodes":[{"pos":[0,36],"content":"Copying and Pinning | Microsoft Docs","nodes":[{"content":"Copying and Pinning | Microsoft Docs","pos":[0,36]}]}],"pos":[6,45],"yaml":true}],"content":"title: \"Copying and Pinning | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"pinning, interop marshaling\"\n  - \"copying, interop marshaling\"\n  - \"interop marshaling, copying\"\n  - \"interop marshaling, pinning\"\nms.assetid: 0059f576-e460-4e70-b257-668870e420b8\ncaps.latest.revision: 8\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[566,585],"content":"Copying and Pinning","linkify":"Copying and Pinning","nodes":[{"content":"Copying and Pinning","pos":[0,19]}]},{"content":"When marshaling data, the interop marshaler can copy or pin the data being marshaled.","pos":[586,671]},{"content":"Copying the data places a copy of data from one memory location in another memory location.","pos":[672,763]},{"content":"The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.","pos":[764,914]},{"content":"<bpt id=\"p1\">![</bpt>Value types passed by value and by reference<ept id=\"p1\">](../../../docs/framework/interop/media/interopmarshalcopy.gif \"interopmarshalcopy\")</ept>","pos":[921,1051],"source":"![Value types passed by value and by reference](../../../docs/framework/interop/media/interopmarshalcopy.gif \"interopmarshalcopy\")"},{"content":"Value types passed by value and by reference","pos":[1054,1098]},{"content":"Method arguments passed by value are marshaled to unmanaged code as values on the stack.","pos":[1105,1193]},{"content":"The copying process is direct.","pos":[1194,1224]},{"content":"Arguments passed by reference are passed as pointers on the stack.","pos":[1225,1291]},{"content":"Reference types are also passed by value and by reference.","pos":[1292,1350]},{"content":"As the following illustration shows, reference types passed by value are either copied or pinned.","pos":[1351,1448]},{"content":"<bpt id=\"p1\">![</bpt>COM interop<ept id=\"p1\">](../../../docs/framework/interop/media/interopmarshalpin.gif \"interopmarshalpin\")</ept>","pos":[1455,1550],"source":"![COM interop](../../../docs/framework/interop/media/interopmarshalpin.gif \"interopmarshalpin\")"},{"content":"Reference types passed by value and by reference","pos":[1553,1601]},{"content":"Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.","pos":[1608,1763]},{"content":"The marshaler pins data to reduce the overhead of copying and enhance performance.","pos":[1764,1846]},{"content":"The type of the data determines whether it is copied or pinned during the marshaling process.","pos":[1847,1940]},{"content":"Pinning is automatically performed during marshaling for objects such as <ph id=\"ph1\">&lt;xref:System.String&gt;</ph>, however you can also manually pin memory using the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> class.","pos":[1942,2141],"source":"  Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class."},{"pos":[2150,2177],"content":"Formatted Blittable Classes","linkify":"Formatted Blittable Classes","nodes":[{"content":"Formatted Blittable Classes","pos":[0,27]}]},{"content":"Formatted <bpt id=\"p1\">[</bpt>blittable<ept id=\"p1\">](../../../docs/framework/interop/blittable-and-non-blittable-types.md)</ept> classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.","pos":[2181,2379],"source":"Formatted [blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory."},{"content":"When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.","pos":[2380,2486]},{"content":"The callee can change the contents of the memory location being referenced by the pointer.","pos":[2487,2577]},{"pos":[2585,2966],"content":"[!NOTE]\n The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types. Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.","leadings":["","> "],"nodes":[{"content":"The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types. Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.","pos":[9,379],"nodes":[{"content":"The callee can change the memory contents if the parameter is marked Out or In/Out.","pos":[0,83]},{"content":"In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.","pos":[84,238]},{"content":"Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.","pos":[239,370]}]}]},{"pos":[2975,3006],"content":"Formatted Non-Blittable Classes","linkify":"Formatted Non-Blittable Classes","nodes":[{"content":"Formatted Non-Blittable Classes","pos":[0,31]}]},{"content":"Formatted <bpt id=\"p1\">[</bpt>non-blittable<ept id=\"p1\">](../../../docs/framework/interop/blittable-and-non-blittable-types.md)</ept> classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.","pos":[3010,3217],"source":"Formatted [non-blittable](../../../docs/framework/interop/blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory."},{"content":"The data can require transformation under the following conditions:","pos":[3218,3285]},{"content":"If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.","pos":[3295,3405]},{"content":"If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.","pos":[3415,3542]},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.InAttribute&gt;</ph> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.","pos":[3552,3710],"source":"If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.OutAttribute&gt;</ph> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.","pos":[3720,3879],"source":"If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary."},{"content":"If both <bpt id=\"p1\">**</bpt>InAttribute<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>OutAttribute<ept id=\"p2\">**</ept> are set, both copies are required.","pos":[3889,3968],"source":"If both **InAttribute** and **OutAttribute** are set, both copies are required."},{"content":"If either attribute is omitted, the marshaler can optimize by eliminating either copy.","pos":[3969,4055]},{"pos":[4064,4079],"content":"Reference Types","linkify":"Reference Types","nodes":[{"content":"Reference Types","pos":[0,15]}]},{"content":"Reference types can be passed by value or by reference.","pos":[4083,4138]},{"content":"When they are passed by value, a pointer to the type is passed on the stack.","pos":[4139,4215]},{"content":"When passed by reference, a pointer to a pointer to the type is passed on the stack.","pos":[4216,4300]},{"content":"Reference types have the following conditional behavior:","pos":[4307,4363]},{"content":"If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:","pos":[4373,4485]},{"content":"When an argument is passed to the unmanaged side.","pos":[4499,4548]},{"content":"On return from the call.","pos":[4562,4586]},{"content":"To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.","pos":[4597,4687]},{"content":"You must explicitly apply the <bpt id=\"p1\">**</bpt>InAttribute<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>OutAttribute<ept id=\"p2\">**</ept> attributes to an argument for the caller to see changes made by the callee.","pos":[4688,4830],"source":" You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee."},{"content":"If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.","pos":[4840,5043]},{"content":"Apply <bpt id=\"p1\">**</bpt>InAttribute<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>OutAttribute<ept id=\"p2\">**</ept> explicitly if you want this behavior.","pos":[5044,5124],"source":" Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior."},{"content":"Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.","pos":[5125,5350]},{"content":"If a reference type is passed by reference, it will be marshaled as In/Out by default.","pos":[5360,5446]},{"pos":[5455,5498],"content":"System.String and System.Text.StringBuilder","linkify":"System.String and System.Text.StringBuilder","nodes":[{"content":"System.String and System.Text.StringBuilder","pos":[0,43]}]},{"content":"When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.","pos":[5502,5735]},{"content":"Unless the reference is a <bpt id=\"p1\">**</bpt>BSTR<ept id=\"p1\">**</ept> allocated with <bpt id=\"p2\">**</bpt>SysAllocString<ept id=\"p2\">**</ept>, the reference is always allocated with <bpt id=\"p3\">**</bpt>CoTaskMemAlloc<ept id=\"p3\">**</ept>.","pos":[5736,5864],"source":" Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**."},{"content":"As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.","pos":[5871,6111]},{"pos":[6119,6272],"content":"[!CAUTION]\n When a string is passed by value, the callee must never alter the reference passed by the marshaler. Doing so can corrupt the managed heap.","leadings":["","> "],"nodes":[{"content":"When a string is passed by value, the callee must never alter the reference passed by the marshaler. Doing so can corrupt the managed heap.","pos":[12,151],"nodes":[{"content":"When a string is passed by value, the callee must never alter the reference passed by the marshaler.","pos":[0,100]},{"content":"Doing so can corrupt the managed heap.","pos":[101,139]}]}]},{"content":"When a <ph id=\"ph1\">&lt;xref:System.String?displayProperty=fullName&gt;</ph> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.","pos":[6279,6446],"source":"When a <xref:System.String?displayProperty=fullName> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call."},{"content":"It then copies the contents of the buffer into a new string on return from the call.","pos":[6447,6531]},{"content":"This technique ensures that the immutable managed string remains unaltered.","pos":[6532,6607]},{"content":"When a <ph id=\"ph1\">&lt;xref:System.Text.StringBuilder?displayProperty=fullName&gt;</ph> is passed by value, the marshaler passes a reference to the internal buffer of the <bpt id=\"p1\">**</bpt>StringBuilder<ept id=\"p1\">**</ept> directly to the caller.","pos":[6614,6803],"source":"When a <xref:System.Text.StringBuilder?displayProperty=fullName> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller."},{"content":"The caller and callee must agree on the size of the buffer.","pos":[6804,6863]},{"content":"The caller is responsible for creating a <bpt id=\"p1\">**</bpt>StringBuilder<ept id=\"p1\">**</ept> of adequate length.","pos":[6864,6942],"source":" The caller is responsible for creating a **StringBuilder** of adequate length."},{"content":"The callee must take the necessary precautions to ensure that the buffer is not overrun.","pos":[6943,7031]},{"content":"<bpt id=\"p1\">**</bpt>StringBuilder<ept id=\"p1\">**</ept> is an exception to the rule that reference types passed by value are passed as In parameters by default.","pos":[7032,7154],"source":"**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default."},{"content":"It is always passed as In/Out.","pos":[7155,7185]},{"pos":[7194,7202],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Default Marshaling Behavior<ept id=\"p1\">](../../../docs/framework/interop/default-marshaling-behavior.md)</ept><ph id=\"ph1\"> </ph>","pos":[7206,7300],"source":"[Default Marshaling Behavior](../../../docs/framework/interop/default-marshaling-behavior.md) "},{"content":"<bpt id=\"p1\">[</bpt>Memory Management with the Interop Marshaler<ept id=\"p1\">](http://msdn.microsoft.com/en-us/417206ce-ee3e-4619-9529-0c0b686c7bee)</ept><ph id=\"ph1\"> </ph>","pos":[7304,7421],"source":"[Memory Management with the Interop Marshaler](http://msdn.microsoft.com/en-us/417206ce-ee3e-4619-9529-0c0b686c7bee) "},{"content":"<bpt id=\"p1\">[</bpt>Directional Attributes<ept id=\"p1\">](http://msdn.microsoft.com/en-us/241ac5b5-928e-4969-8f58-1dbc048f9ea2)</ept><ph id=\"ph1\"> </ph>","pos":[7425,7520],"source":"[Directional Attributes](http://msdn.microsoft.com/en-us/241ac5b5-928e-4969-8f58-1dbc048f9ea2) "},{"content":"<bpt id=\"p1\">[</bpt>Interop Marshaling<ept id=\"p1\">](../../../docs/framework/interop/interop-marshaling.md)</ept>","pos":[7524,7599],"source":"[Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)"}]}