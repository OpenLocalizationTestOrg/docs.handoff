<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="character-encoding.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">16154ff6b2fcf6c537126b6ced03c45f6746b57a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\character-encoding.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f15c6c0f5c92f6a4f025ce9615fa1b5f9b0af425</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5517ddc395d679c756206499a4d831b6aa22ed25</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Character Encoding in .NET</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn about character encoding and decoding in .NET.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Character Encoding in .NET</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Characters are abstract entities that can be represented in many different ways.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A character encoding is a system that pairs each character in a supported character set with some value that represents that character.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For example, Morse code is a character encoding that pairs each character in the Roman alphabet with a pattern of dots and dashes that are suitable for transmission over telegraph lines.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A character encoding for computers pairs each character in a supported character set with a numeric value that represents that character.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A character encoding has two distinct components:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>An encoder, which translates a sequence of characters into a sequence of numeric values (bytes).</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>A decoder, which translates a sequence of bytes into a sequence of characters.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Character encoding describes the rules by which an encoder and a decoder operate.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> class describes the rules for encoding to, and decoding from, 8-bit Unicode Transformation Format (UTF-8), which uses one to four bytes to represent a single Unicode character.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Encoding and decoding can also include validation.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class checks all surrogates  to make sure they constitute valid surrogate pairs.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>(A surrogate pair consists of a character with a code point that ranges from U+D800 to U+DBFF followed by a character with a code point that ranges from U+DC00 to U+DFFF.)  A fallback strategy determines how an encoder handles invalid characters or how a decoder handles invalid bytes.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>.NET encoding classes provide a way to store and convert character data.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>They should not be used to store binary data in string form.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Depending on the encoding used, converting binary data to string format with the encoding classes can introduce unexpected behavior and produce inaccurate or corrupted data.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To convert binary data to a string form, use the <ph id="ph1">&lt;xref:System.Convert.ToBase64String%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>.NET uses the UTF-16 encoding (represented by the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> class) to represent characters and strings.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Applications that target the common language runtime use encoders to map Unicode character representations supported by the common language runtime to other encoding schemes.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>They use decoders to map characters from non-Unicode encodings to Unicode.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This topic consists of the following sections:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Encodings in .NET<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Encodings)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Selecting an Encoding Class<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Selecting)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using an Encoding Object<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Using)</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Choosing a Fallback Strategy<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#FallbackStrategy)</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementing a Custom Fallback Strategy<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Custom)</ept></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Encodings in .NET</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>All character encoding classes in .NET inherit from the <ph id="ph1">&lt;xref:System.Text.Encoding?displayProperty=nameWithType&gt;</ph> class, which is an abstract class that defines the functionality common to all character encodings.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To access the individual encoding objects implemented in .NET, do the following:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Use the static properties of the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class, which return objects that represent the standard character encodings available in .NET (ASCII, UTF-7, UTF-8, UTF-16, and UTF-32).</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement Fallback<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Replacement)</ept> section.)</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Call the encoding's class constructor.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Objects for the ASCII, UTF-7, UTF-8, UTF-16, and UTF-32 encodings can be instantiated in this way.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>By default, each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode, but you can specify that an exception should be thrown instead.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Replacement Fallback<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Replacement)</ept> and <bpt id="p2">[</bpt>Exception Fallback<ept id="p2">](../../../docs/standard/base-types/character-encoding.md#Exception)</ept> sections.)</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Call the <ph id="ph1">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%29?displayProperty=nameWithType&gt;</ph> constructor and pass it an integer that represents the encoding.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Standard encoding objects use replacement fallback, and code page and double-byte character set (DBCS) encoding objects use best-fit fallback to handle strings that they cannot encode and bytes that they cannot decode.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>(For more information, see the <bpt id="p1">[</bpt>Best-Fit Fallback<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#BestFit)</ept> section.)</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> method, which returns any standard, code page, or DBCS encoding available in .NET.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Overloads let you specify a fallback object for both the encoder and the decoder.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The Unicode Standard assigns a code point (a number) and a name to each character in every supported script.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example, the character "A" is represented by the code point U+0041 and the name "LATIN CAPITAL LETTER A".</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The Unicode Transformation Format (UTF) encodings define ways to encode that code point into a sequence of one or more bytes.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A Unicode encoding scheme simplifies world-ready application development because it allows characters from any character set to be represented in a single encoding.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Application developers no longer have to keep track of the encoding scheme that was used to produce characters for a specific language or writing system, and data can be shared among systems internationally without being corrupted.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>.NET supports three encodings defined by the Unicode standard: UTF-8, UTF-16, and UTF-32.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](https://www.unicode.org/)</ept>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can retrieve information about all the encodings available in .NET by calling the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET supports the character encoding systems listed in the following table.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Encoding</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Class</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Advantages/disadvantages</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>ASCII</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Encodes a limited range of characters by using the lower seven bits of a byte.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Because this encoding only supports character values from U+0000 through U+007F, in most cases it is inadequate for internationalized applications.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Represents characters as sequences of 7-bit ASCII characters.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Non-ASCII Unicode characters are represented by an escape sequence of ASCII characters.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>UTF-7 supports protocols such as email and newsgroup protocols.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>However, UTF-7 is not particularly secure or robust.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In some cases, changing one bit can radically alter the interpretation of an entire UTF-7 string.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In other cases, different UTF-7 strings can encode the same text.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For sequences that include non-ASCII characters, UTF-7 requires more space than UTF-8, and encoding/decoding is slower.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Consequently, you should use UTF-8 instead of UTF-7 if possible.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one to four bytes.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>UTF-8 supports 8-bit data sizes and works well with many existing operating systems.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For the ASCII range of characters, UTF-8 is identical to ASCII encoding and allows a broader set of characters.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>However, for Chinese-Japanese-Korean (CJK) scripts, UTF-8 can require three bytes for each character, and can potentially cause larger data sizes than UTF-16.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Note that sometimes the amount of ASCII data, such as HTML tags, justifies the increased size for the CJK range.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a sequence of one or two 16-bit integers.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Most common Unicode characters require only one UTF-16 code point, although Unicode supplementary characters (U+10000 and greater) require two UTF-16 surrogate code points.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>UTF-16 encoding is used by the common language runtime to represent <ph id="ph1">&lt;xref:System.Char&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> values, and it is used by the Windows operating system to represent <ph id="ph3">`WCHAR`</ph> values.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Represents each Unicode code point as a 32-bit integer.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Both little-endian and big-endian byte orders are supported.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>UTF-32 encoding is used when applications want to avoid the surrogate code point behavior of UTF-16 encoding on operating systems for which encoded space is too important.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Single glyphs rendered on a display can still be encoded with more than one UTF-32 character.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>ANSI/ISO encodings</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Provides support for a variety of code pages.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>On Windows operating systems, code pages are used to support a specific language or group of languages.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For a table that lists the code pages supported by .NET, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You can retrieve an encoding object for a particular code page by calling the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A code page contains 256 code points and is zero-based.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In most code pages, code points 0 through 127 represent the ASCII character set, and code points 128 through 255 differ significantly between code pages.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, code page 1252 provides the characters for Latin writing systems, including English, German, and French.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The last 128 code points in code page 1252 contain the accent characters.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Code page 1253 provides character codes that are required in the Greek writing system.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The last 128 code points in code page 1253 contain the Greek characters.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>As a result, an application that relies on ANSI code pages cannot store Greek and German in the same text stream unless it includes an identifier that indicates the referenced code page.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Double-byte character set (DBCS) encodings</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Supports languages, such as Chinese, Japanese, and Korean, that contain more than 256 characters.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In a DBCS, a pair of code points (a double byte) represents each character.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph2">`false`</ph> for DBCS encodings.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>You can retrieve an encoding object for a particular DBCS by calling the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In a DBCS, a pair of code points (a double byte) represents each character.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>When an application handles DBCS data, the first byte of a DBCS character (the lead byte) is processed in combination with the trail byte that immediately follows it.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Because a single pair of double-byte code points can represent different characters depending on the code page, this scheme still does not allow for the combination of two languages, such as Japanese and Chinese, in the same data stream.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>These encodings enable you to work with Unicode characters as well as with encodings that are most commonly used in legacy applications.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In addition, you can create a custom encoding by defining a class that derives from <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> and overriding its members.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Platform Notes: <ph id="ph1">[!INCLUDE[net_core](../../../includes/net-core-md.md)]</ph></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>By default, <ph id="ph1">[!INCLUDE[net_core](../../../includes/net-core-md.md)]</ph> does not make available any code page encodings other than code page 28591 and the Unicode encodings, such as UTF-8 and UTF-16.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>However, you can add the code page encodings found in standard Windows apps that target .NET to your app.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For complete information, see the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> topic.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Selecting an Encoding Class</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If you have the opportunity to choose the encoding to be used by your application, you should use a Unicode encoding, preferably either <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>(.NET also supports a third Unicode encoding, <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph>.)</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>If you are planning to use an ASCII encoding (<ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>), choose <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instead.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The two encodings are identical for the ASCII character set, but <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> has the following advantages:</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>It can represent every Unicode character, whereas <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> supports only the Unicode character values between U+0000 and U+007F.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>It provides error detection and better security.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It has been tuned to be as fast as possible and should be faster than any other encoding.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Even for content that is entirely ASCII, operations performed with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> are faster than operations performed with <ph id="ph2">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You should consider using <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> only for legacy applications.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>However, even for legacy applications, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> might be a better choice for the following reasons (assuming default settings):</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, each non-ASCII character encodes as a question mark (?).</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If the application then decodes this data, the information is lost.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If your application has content that is not strictly ASCII and encodes it with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, the result seems unintelligible if interpreted as ASCII.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>However, if the application then uses a UTF-8 decoder to decode this data, the data performs a round trip successfully.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In a web application, characters sent to the client in response to a web request should reflect the encoding used on the client.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>In most cases, you should set the <ph id="ph1">&lt;xref:System.Web.HttpResponse.ContentEncoding%2A?displayProperty=nameWithType&gt;</ph> property to the value returned by the <ph id="ph2">&lt;xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=nameWithType&gt;</ph> property to display text in the encoding that the user expects.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Using an Encoding Object</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>An encoder converts a string of characters (most commonly, Unicode characters) to its numeric (byte) equivalent.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For example, you might use an ASCII encoder to convert Unicode characters to ASCII so that they can be displayed at the console.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>To perform the conversion, you call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>If you want to determine how many bytes are needed to store the encoded characters before performing the encoding, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The following example uses a single byte array to encode strings in two separate operations.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the byte array for the next set of ASCII-encoded bytes.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>It calls the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.GetByteCount%28System.String%29?displayProperty=nameWithType&gt;</ph> method to ensure that the byte array is large enough to accommodate the encoded string.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to encode the characters in the string.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A decoder converts a byte array that reflects a particular character encoding into a set of characters, either in a character array or in a string.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a character array, you call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>To decode a byte array into a string, you call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If you want to determine how many characters are needed to store the decoded bytes before performing the decoding, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The following example encodes three strings and then decodes them into a single array of characters.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>It maintains an index that indicates the starting position in the character array for the next set of decoded characters.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>It calls the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.GetCharCount%2A&gt;</ph> method to ensure that the character array is large enough to accommodate all the decoded characters.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to decode the byte array.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The encoding and decoding methods of a class derived from <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> are designed to work on a complete set of data; that is, all the data to be encoded or decoded is supplied in a single method call.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>However, in some cases, data is available in a stream, and the data to be encoded or decoded may be available only from separate read operations.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This requires the encoding or decoding operation to remember any saved state from its previous invocation.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Methods of classes derived from <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> are able to handle encoding and decoding operations that span multiple method calls.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object for a particular encoding is available from that encoding's <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object for a particular encoding is available from that encoding's <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For decoding operations, note that classes derived from <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> include a <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, but they do not have a method that corresponds to <ph id="ph3">&lt;xref:System.Text.Encoding.GetString%2A?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between using the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> methods for decoding a Unicode byte array.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The example encodes a string that contains some Unicode characters to a file, and then uses the two decoding methods to decode them ten bytes at a time.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Because a surrogate pair occurs in the tenth and eleventh bytes, it is decoded in separate method calls.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>As the output shows, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method is not able to correctly decode the bytes and instead replaces them with U+FFFD (REPLACEMENT CHARACTER).</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>On the other hand, the <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method is able to successfully decode the byte array to get the original string.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Choosing a Fallback Strategy</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>When a method tries to encode or decode a character but no mapping exists, it must implement a fallback strategy that determines how the failed mapping should be handled.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>There are three types of fallback strategies:</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Best-fit fallback</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Replacement fallback</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Exception fallback</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The most common problems in encoding operations occur when a Unicode character cannot be mapped to a particular code page encoding.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The most common problems in decoding operations occur when invalid byte sequences cannot be translated into valid Unicode characters.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For these reasons, you should know which fallback strategy a particular encoding object uses.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should specify the fallback strategy used by an encoding object when you instantiate the object.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Best-Fit Fallback</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target encoding, the encoder can try to map it to a similar character.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>(Best-fit fallback is mostly an encoding rather than a decoding issue.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>There are very few code pages that contain characters that cannot be successfully mapped to Unicode.) Best-fit fallback is the default for code page and double-byte character set encodings that are retrieved by the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29?displayProperty=nameWithType&gt;</ph> overloads.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>In theory, the Unicode encoding classes provided in .NET (<ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, and <ph id="ph3">&lt;xref:System.Text.UTF32Encoding&gt;</ph>) support every character in every character set, so they can be used to eliminate best-fit fallback issues.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Best-fit strategies vary for different code pages.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For example, for some code pages, full-width Latin characters map to the more common half-width Latin characters.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>For other code pages, this mapping is not made.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Even under an aggressive best-fit strategy, there is no imaginable fit for some characters in some encodings.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>For example, a Chinese ideograph has no reasonable mapping to code page 1252.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>In this case, a replacement string is used.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>By default, this string is just a single QUESTION MARK (U+003F).</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Best-fit strategies are not documented in detail.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>However, several code pages are documented at the <bpt id="p1">[</bpt>Unicode Consortium's<ept id="p1">](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/)</ept> website.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Please review the <bpt id="p1">**</bpt>readme.txt<ept id="p1">**</ept> file in that folder for a description of how to interpret the mapping files.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The following example uses code page 1252 (the Windows code page for Western European languages) to illustrate best-fit mapping and its drawbacks.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method is used to retrieve an encoding object for code page 1252.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>By default, it uses a best-fit mapping for Unicode characters that it does not support.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The example instantiates a string that contains three non-ASCII characters - CIRCLED LATIN CAPITAL LETTER S (U+24C8), SUPERSCRIPT FIVE (U+2075), and INFINITY (U+221E) - separated by spaces.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, when the string is encoded, the three original non-space characters are replaced by QUESTION MARK (U+003F), DIGIT FIVE (U+0035), and DIGIT EIGHT (U+0038).</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>DIGIT EIGHT is a particularly poor replacement for the unsupported INFINITY character, and QUESTION MARK indicates that no mapping was available for the original character.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Best-fit mapping is the default behavior for an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object that encodes Unicode data into code page data, and there are legacy applications that rely on this behavior.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>However, most new applications should avoid best-fit behavior for security reasons.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>For example, applications should not put a domain name through a best-fit encoding.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>You can also implement a custom best-fit fallback mapping for an encoding.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a Custom Fallback Strategy<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Custom)</ept> section.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>If best-fit fallback is the default for an encoding object, you can choose another fallback strategy when you retrieve an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object by calling the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The following section includes an example that replaces each character that cannot be mapped to code page 1252 with an asterisk (*).</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Replacement Fallback</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>When a character does not have an exact match in the target scheme, but there is no appropriate character that it can be mapped to, the application can specify a replacement character or string.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This is the default behavior for the Unicode decoder, which replaces any two-byte sequence that it cannot decode with REPLACEMENT_CHARACTER (U+FFFD).</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>It is also the default behavior of the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> class, which replaces each character that it cannot encode or decode with a question mark.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The following example illustrates character replacement for the Unicode string from the previous example.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>As the output shows, each character that cannot be decoded into an ASCII byte value is replaced by 0x3F, which is the ASCII code for a question mark.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>.NET includes the <ph id="ph1">&lt;xref:System.Text.EncoderReplacementFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderReplacementFallback&gt;</ph> classes, which substitute a replacement string if a character does not map exactly in an encoding or decoding operation.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>By default, this replacement string is a question mark, but you can call a class constructor overload to choose a different string.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Typically, the replacement string is a single character, although this is not a requirement.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The following example changes the behavior of the code page 1252 encoder by instantiating an <ph id="ph1">&lt;xref:System.Text.EncoderReplacementFallback&gt;</ph> object that uses an asterisk (*) as a replacement string.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>You can also implement a replacement class for an encoding.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a Custom Fallback Strategy<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Custom)</ept> section.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>In addition to QUESTION MARK (U+003F), the Unicode REPLACEMENT CHARACTER (U+FFFD) is commonly used as a replacement string, particularly when decoding byte sequences that cannot be successfully translated into Unicode characters.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>However, you are free to choose any replacement string, and it can contain multiple characters.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Exception Fallback</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Instead of providing a best-fit fallback or a replacement string, an encoder can throw an <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> if it is unable to encode a set of characters, and a decoder can throw a <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> if it is unable to decode a byte array.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>To throw an exception in encoding and decoding operations, you supply an <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> object and a <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> object, respectively, to the <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The following example illustrates exception fallback with the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>You can also implement a custom exception handler for an encoding operation.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>Implementing a Custom Fallback Strategy<ept id="p1">](../../../docs/standard/base-types/character-encoding.md#Custom)</ept> section.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> objects provide the following information about the condition that caused the exception:</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> object includes an <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException.IsUnknownSurrogate%2A&gt;</ph> method, which indicates whether the character or characters that cannot be encoded represent an unknown surrogate pair (in which case, the method returns <ph id="ph3">`true`</ph>) or an unknown single character (in which case, the method returns <ph id="ph4">`false`</ph>).</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The characters in the surrogate pair are available from the <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException.CharUnknownHigh%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException.CharUnknownLow%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The unknown single character is available from the <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException.CharUnknown%2A?displayProperty=nameWithType&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException.Index%2A?displayProperty=nameWithType&gt;</ph> property indicates the position in the string at which the first character that could not be encoded was found.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> object includes a <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException.BytesUnknown%2A&gt;</ph> property that returns an array of bytes that cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.DecoderFallbackException.Index%2A?displayProperty=nameWithType&gt;</ph> property indicates the starting position of the unknown bytes.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Although the <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> objects provide adequate diagnostic information about the exception, they do not provide access to the encoding or decoding buffer.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Therefore, they do not allow invalid data to be replaced or corrected within the encoding or decoding method.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Implementing a Custom Fallback Strategy</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>In addition to the best-fit mapping that is implemented internally by code pages, .NET includes the following classes for implementing a fallback strategy:</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">&lt;xref:System.Text.EncoderReplacementFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.EncoderReplacementFallbackBuffer&gt;</ph> to replace characters in encoding operations.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">&lt;xref:System.Text.DecoderReplacementFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderReplacementFallbackBuffer&gt;</ph> to replace characters in decoding operations.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.EncoderExceptionFallbackBuffer&gt;</ph> to throw an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> when a character cannot be encoded.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Use <ph id="ph1">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallbackBuffer&gt;</ph> to throw a <ph id="ph3">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> when a character cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>In addition, you can implement a custom solution that uses best-fit fallback, replacement fallback, or exception fallback, by following these steps:</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Derive a class from <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> for encoding operations, and from <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> for decoding operations.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Derive a class from <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph> for encoding operations, and from <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer&gt;</ph> for decoding operations.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>For exception fallback, if the predefined <ph id="ph1">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> classes do not meet your needs, derive a class from an exception object such as <ph id="ph3">&lt;xref:System.Exception&gt;</ph> or <ph id="ph4">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallback or DecoderFallback</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must create a class that inherits from <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> for encoding operations, and from <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> for decoding operations.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Instances of these classes are passed to the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method and serve as the intermediary between the encoding class and the fallback implementation.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback.MaxCharCount%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallback.MaxCharCount%2A?displayProperty=nameWithType&gt;</ph> property, which returns the maximum possible number of characters that the best-fit, replacement, or exception fallback can return to replace a single character.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>For a custom exception fallback, its value is zero.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType&gt;</ph> method, which returns your custom <ph id="ph3">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph> or <ph id="ph4">&lt;xref:System.Text.DecoderFallbackBuffer&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The method is called by the encoder when it encounters the first character that it is unable to successfully encode, or by the decoder when it encounters the first byte that it is unable to successfully decode.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Deriving from EncoderFallbackBuffer or DecoderFallbackBuffer</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>To implement a custom fallback solution, you must also create a class that inherits from <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph> for encoding operations, and from <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer&gt;</ph> for decoding operations.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Instances of these classes are returned by the <ph id="ph1">&lt;xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A&gt;</ph> method  of the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType&gt;</ph> method is called by the encoder when it encounters the first character that it is not able to encode, and the <ph id="ph2">&lt;xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType&gt;</ph> method is called by the decoder when it encounters one or more bytes that it is not able to decode.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer&gt;</ph> classes provide the fallback implementation.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Each instance represents a buffer that contains the fallback characters that will replace the character that cannot be encoded or the byte sequence that cannot be decoded.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType&gt;</ph> is called by the encoder to provide the fallback buffer with information about the character that it cannot encode.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Because the character to be encoded may be a surrogate pair, this method is overloaded.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>One overload is passed the character to be encoded and its index in the string.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The second overload is passed the high and low surrogate along with its index in the string.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType&gt;</ph> method is called by the decoder to provide the fallback buffer with information about the bytes that it cannot decode.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>This method is passed an array of bytes that it cannot decode, along with the index of the first byte.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The fallback method should return <ph id="ph1">`true`</ph> if the fallback buffer can supply a best-fit or replacement character or characters; otherwise, it should return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>For an exception fallback, the fallback method should throw an exception.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType&gt;</ph> method, which is called repeatedly by the encoder or decoder to get the next character from the fallback buffer.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>When all fallback characters have been returned, the method should return U+0000.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType&gt;</ph> property, which returns the number of characters remaining in the fallback buffer.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType&gt;</ph> method, which moves the current position in the fallback buffer to the previous character.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer.Reset%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer.Reset%2A?displayProperty=nameWithType&gt;</ph> method, which reinitializes the fallback buffer.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>If the fallback implementation is a best-fit fallback or a replacement fallback, the classes derived from <ph id="ph1">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallbackBuffer&gt;</ph> also maintain two private instance fields: the exact number of characters in the buffer; and the index of the next character in the buffer to return.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>An EncoderFallback Example</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>An earlier example used replacement fallback to replace Unicode characters that did not correspond to ASCII characters with an asterisk (*).</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>The following example uses a custom best-fit fallback implementation instead to provide a better mapping of non-ASCII characters.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The following code defines a class named <ph id="ph1">`CustomMapper`</ph> that is derived from <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph> to handle the best-fit mapping of non-ASCII characters.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`CreateFallbackBuffer`</ph> method returns a <ph id="ph2">`CustomMapperFallbackBuffer`</ph> object, which provides the <ph id="ph3">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CustomMapper`</ph> class uses a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> object to store the mappings of unsupported Unicode characters (the key value) and their corresponding 8-bit characters (which are stored in two consecutive bytes in a 64-bit integer).</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>To make this mapping available to the fallback buffer, the <ph id="ph1">`CustomMapper`</ph> instance is passed as a parameter to the <ph id="ph2">`CustomMapperFallbackBuffer`</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Because the longest mapping is the string "INF" for the Unicode character U+221E, the <ph id="ph1">`MaxCharCount`</ph> property returns 3.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The following code defines the <ph id="ph1">`CustomMapperFallbackBuffer`</ph> class, which is derived from <ph id="ph2">&lt;xref:System.Text.EncoderFallbackBuffer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The dictionary that contains best-fit mappings and that is defined in the <ph id="ph1">`CustomMapper`</ph> instance is available from its class constructor.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Its <ph id="ph1">`Fallback`</ph> method returns <ph id="ph2">`true`</ph> if any of the Unicode characters that the ASCII encoder cannot encode are defined in the mapping dictionary; otherwise, it returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>For each fallback, the private <ph id="ph1">`count`</ph> variable indicates the number of characters that remain to be returned, and the private <ph id="ph2">`index`</ph> variable indicates the position in the string buffer, <ph id="ph3">`charsToReturn`</ph>, of the next character to return.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The following code then instantiates the <ph id="ph1">`CustomMapper`</ph> object and passes an instance of it to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The output indicates that the best-fit fallback implementation successfully handles the three non-ASCII characters in the original string.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Globalization and Localization<ept id="p1">](../../../docs/standard/globalization-localization/index.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>