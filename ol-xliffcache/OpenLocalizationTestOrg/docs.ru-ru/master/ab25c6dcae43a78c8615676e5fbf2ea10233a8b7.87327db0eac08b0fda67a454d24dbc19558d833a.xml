{"content":"---\ntitle: \"TypeConverters and XAML | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"classes, TypeConverter\"\n  - \"TypeConverter class\"\n  - \"XAML, TypeConverter class\"\nms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b\ncaps.latest.revision: 13\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# TypeConverters and XAML\nThis topic introduces the purpose of type conversion from string as a general XAML language feature. In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage. If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.  \n  \n\n  \n## Type Conversion Concepts  \n  \n### XAML and String Values  \n When you set an attribute value in a XAML file, the initial type of that value is a string in pure text. Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.  \n  \n A XAML processor needs two pieces of information in order to process an attribute value. The first piece of information is the value type of the property that is being set. Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type. If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted. If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration. If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string. This is done by indicating a type converter class. The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.  \n  \n### Using Existing Type Conversion Behavior in XAML  \n Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it. For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>. A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>. When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide. For example: `<LinearGradientBrush StartPoint=\"0,0\" EndPoint=\"1,1\">`.  \n  \n Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter. In this case that is the class <xref:System.Windows.PointConverter>.  \n  \n The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>. Without a type converter here, you would need the following much more verbose markup for the same example shown previously:  \n  \n `<LinearGradientBrush>`  \n  \n `<LinearGradientBrush.StartPoint>`  \n  \n `<Point X=\"0\" Y=\"0\"/>`  \n  \n `</LinearGradientBrush.StartPoint>`  \n  \n `<LinearGradientBrush.EndPoint>`  \n  \n `<Point X=\"1\" Y=\"1\"/>`  \n  \n `</LinearGradientBrush.EndPoint>`  \n  \n `<LinearGradientBrush>`  \n  \n Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice. Your XAML tooling workflow might also influence how values are set. Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.  \n  \n Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>. This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.  \n  \n### Type Converters and Markup Extensions  \n Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to. Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations. In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.  \n  \n One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists. At best, a stateless type converter could only generate a new instance, which might not be desirable. For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).  \n  \n### Native Type Converters  \n In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives. An example of such a type is <xref:System.DateTime>. The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET. <xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported. Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed. (In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.  \n  \n<a name=\"Implementing_a_Type_Converter\"></a>   \n## Implementing a Type Converter  \n  \n### TypeConverter  \n In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned. For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>. The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers. For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.  \n  \n <xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:  \n  \n-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  \n  \n-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  \n  \n-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  \n  \n-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  \n  \n Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>. This method converts the input string to the required object type. Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.  \n  \n The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>. If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation. In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .  \n  \n <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation. You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support. For XAML purposes, this generally means the <xref:System.String> type.  \n  \n### Culture Information and Type Converters for XAML  \n Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters. There is an important consideration with regard to culture and XAML type conversion. Using localizable strings as attribute values is entirely supported by XAML. But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture. For more information on the design reasons for this restriction, you should consult the XAML language specification ([\\[MS-XAML\\]](http://go.microsoft.com/fwlink/?LinkId=114525)).  \n  \n As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers. This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists). Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.  \n  \n### Implementing ConvertFrom  \n To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter. If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property. Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.  \n  \n Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters. However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.  \n  \n> [!NOTE]\n>  Do not use the curly brace characters, particularly {, as a possible element of your string format. These characters are reserved as the entry and exit for a markup extension sequence.  \n  \n### Implementing ConvertTo  \n <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support. Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement. However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.  \n  \n To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter. When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>. The returned string must represent a serialized value of `value`. Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.  \n  \n If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case. But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.  \n  \n If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling. Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.  \n  \n### Implementing CanConvertTo  \n Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.  \n  \n### Implementing CanConvertFrom  \n Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.  \n  \n<a name=\"Applying_the_TypeConverterAttribute\"></a>   \n## Applying the TypeConverterAttribute  \n In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition. The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter. With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.  \n  \n You can also provide a type converter on a per-property basis. Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it). The type of the property must match the type that is processed by your custom type converter. With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances. The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.  \n  \n## See Also  \n <xref:System.ComponentModel.TypeConverter>   \n [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)   \n [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)   \n [XAML Syntax In Detail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)","nodes":[{"pos":[12,52],"content":"TypeConverters and XAML | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"TypeConverters and XAML | Microsoft Docs","pos":[0,40]}]},{"pos":[469,492],"content":"TypeConverters and XAML","linkify":"TypeConverters and XAML","nodes":[{"content":"TypeConverters and XAML","pos":[0,23]}]},{"content":"This topic introduces the purpose of type conversion from string as a general XAML language feature.","pos":[493,593]},{"content":"In the .NET Framework, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.","pos":[594,816],"source":" In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage."},{"content":"If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to your class, write a custom <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> class, or both.","pos":[817,1097],"source":" If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both."},{"pos":[1110,1134],"content":"Type Conversion Concepts","linkify":"Type Conversion Concepts","nodes":[{"content":"Type Conversion Concepts","pos":[0,24]}]},{"pos":[1144,1166],"content":"XAML and String Values","linkify":"XAML and String Values","nodes":[{"content":"XAML and String Values","pos":[0,22]}]},{"content":"When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.","pos":[1170,1274]},{"content":"Even other primitives such as <ph id=\"ph1\">&lt;xref:System.Double&gt;</ph> are initially text strings to a XAML processor.","pos":[1275,1373],"source":" Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor."},{"content":"A XAML processor needs two pieces of information in order to process an attribute value.","pos":[1380,1468]},{"content":"The first piece of information is the value type of the property that is being set.","pos":[1469,1552]},{"content":"Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.","pos":[1553,1691]},{"content":"If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.","pos":[1692,1832]},{"content":"If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.","pos":[1833,1950]},{"content":"If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.","pos":[1951,2140]},{"content":"This is done by indicating a type converter class.","pos":[2141,2191]},{"content":"The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.","pos":[2192,2356]},{"pos":[2366,2413],"content":"Using Existing Type Conversion Behavior in XAML","linkify":"Using Existing Type Conversion Behavior in XAML","nodes":[{"content":"Using Existing Type Conversion Behavior in XAML","pos":[0,47]}]},{"content":"Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.","pos":[2417,2579]},{"content":"For instance, WPF defines literally hundreds of properties that take a value of type <ph id=\"ph1\">&lt;xref:System.Windows.Point&gt;</ph>.","pos":[2580,2693],"source":" For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Point&gt;</ph> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <ph id=\"ph2\">&lt;xref:System.Windows.Point.X%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Point.Y%2A&gt;</ph>.","pos":[2694,2921],"source":" A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>."},{"content":"When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <ph id=\"ph1\">&lt;xref:System.Windows.Point.X%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Point.Y%2A&gt;</ph> values you provide.","pos":[2922,3121],"source":" When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide."},{"content":"For example: <ph id=\"ph1\">`&lt;LinearGradientBrush StartPoint=\"0,0\" EndPoint=\"1,1\"&gt;`</ph>.","pos":[3122,3191],"source":" For example: `<LinearGradientBrush StartPoint=\"0,0\" EndPoint=\"1,1\">`."},{"content":"Even this simple type of <ph id=\"ph1\">&lt;xref:System.Windows.Point&gt;</ph> and its simple usage in XAML involve a type converter.","pos":[3198,3305],"source":"Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter."},{"content":"In this case that is the class <ph id=\"ph1\">&lt;xref:System.Windows.PointConverter&gt;</ph>.","pos":[3306,3374],"source":" In this case that is the class <xref:System.Windows.PointConverter>."},{"content":"The type converter for <ph id=\"ph1\">&lt;xref:System.Windows.Point&gt;</ph> defined at the class level streamlines the markup usages of all properties that take <ph id=\"ph2\">&lt;xref:System.Windows.Point&gt;</ph>.","pos":[3381,3545],"source":"The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>."},{"content":"Without a type converter here, you would need the following much more verbose markup for the same example shown previously:","pos":[3546,3669]},{"content":"Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.","pos":[3956,4069]},{"content":"Your XAML tooling workflow might also influence how values are set.","pos":[4070,4137]},{"content":"Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.","pos":[4138,4291]},{"content":"Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph>.","pos":[4298,4500],"source":"Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>."},{"content":"This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.","pos":[4501,4655]},{"pos":[4665,4702],"content":"Type Converters and Markup Extensions","linkify":"Type Converters and Markup Extensions","nodes":[{"content":"Type Converters and Markup Extensions","pos":[0,37]}]},{"content":"Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.","pos":[4706,4845]},{"content":"Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.","pos":[4846,5054]},{"content":"In other words, even if a markup extension returns a text string as its <ph id=\"ph1\">`ProvideValue`</ph> output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.","pos":[5055,5388],"source":" In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved."},{"content":"One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.","pos":[5395,5539]},{"content":"At best, a stateless type converter could only generate a new instance, which might not be desirable.","pos":[5540,5641]},{"content":"For more information on markup extensions, see <bpt id=\"p1\">[</bpt>Markup Extensions and WPF XAML<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)</ept>.","pos":[5642,5797],"source":" For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)."},{"pos":[5807,5829],"content":"Native Type Converters","linkify":"Native Type Converters","nodes":[{"content":"Native Type Converters","pos":[0,22]}]},{"content":"In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.","pos":[5833,6037]},{"content":"An example of such a type is <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph>.","pos":[6038,6090],"source":" An example of such a type is <xref:System.DateTime>."},{"content":"The reason for this is based on how the .NET Framework architecture works: the type <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> is defined in mscorlib, the most basic library in .NET.","pos":[6091,6253],"source":" The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET."},{"content":"<ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.","pos":[6254,6543],"source":"<xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported."},{"content":"Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.","pos":[6544,6693]},{"content":"(In the case of <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> this involves a call to <ph id=\"ph2\">&lt;xref:System.DateTime.Parse%2A&gt;</ph>.","pos":[6694,6789],"source":" (In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>."},{"pos":[6846,6875],"content":"Implementing a Type Converter","linkify":"Implementing a Type Converter","nodes":[{"content":"Implementing a Type Converter","pos":[0,29]}]},{"pos":[6885,6898],"content":"TypeConverter","linkify":"TypeConverter","nodes":[{"content":"TypeConverter","pos":[0,13]}]},{"content":"In the <ph id=\"ph1\">&lt;xref:System.Windows.Point&gt;</ph> example given previously, the class <ph id=\"ph2\">&lt;xref:System.Windows.PointConverter&gt;</ph> was mentioned.","pos":[6902,7024],"source":"In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned."},{"content":"For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>.","pos":[7025,7198],"source":" For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.","pos":[7199,7427],"source":" The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers."},{"content":"For XAML, the role of <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.","pos":[7428,7751],"source":" For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute."},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> defines four members that are relevant for converting to and from strings for XAML processing purposes:","pos":[7758,7904],"source":"<xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:"},{"content":"Of these, the most important method is <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph>.","pos":[8181,8278],"source":"Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>."},{"content":"This method converts the input string to the required object type.","pos":[8279,8345]},{"content":"Strictly speaking, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> input that matters.","pos":[8346,8737],"source":" Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters."},{"content":"The next most important method is <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph>.","pos":[8744,8834],"source":"The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>."},{"content":"If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> is responsible for producing a markup representation.","pos":[8835,9052],"source":" If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation."},{"content":"In this case, the code path that matters for XAML is when you pass a <ph id=\"ph1\">`destinationType`</ph> of <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> .","pos":[9053,9165],"source":" In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> ."},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A&gt;</ph> are support methods that are used when a service queries the capabilities of the <ph id=\"ph3\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation.","pos":[9172,9435],"source":"<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation."},{"content":"You must implement these methods to return <ph id=\"ph1\">`true`</ph> for type-specific cases that the equivalent conversion methods of your converter support.","pos":[9436,9575],"source":" You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support."},{"content":"For XAML purposes, this generally means the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type.","pos":[9576,9646],"source":" For XAML purposes, this generally means the <xref:System.String> type."},{"pos":[9656,9704],"content":"Culture Information and Type Converters for XAML","linkify":"Culture Information and Type Converters for XAML","nodes":[{"content":"Culture Information and Type Converters for XAML","pos":[0,48]}]},{"content":"Each <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.","pos":[9708,9925],"source":"Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters."},{"content":"There is an important consideration with regard to culture and XAML type conversion.","pos":[9926,10010]},{"content":"Using localizable strings as attribute values is entirely supported by XAML.","pos":[10011,10087]},{"content":"But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using <ph id=\"ph1\">`en-US`</ph> culture.","pos":[10088,10326],"source":" But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture."},{"content":"For more information on the design reasons for this restriction, you should consult the XAML language specification (<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\[</ph>MS-XAML<ph id=\"ph2\">\\]</ph><ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=114525)</ept>).","pos":[10327,10506],"source":" For more information on the design reasons for this restriction, you should consult the XAML language specification ([\\[MS-XAML\\]](http://go.microsoft.com/fwlink/?LinkId=114525))."},{"content":"As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.","pos":[10513,10629]},{"content":"This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).","pos":[10630,10840]},{"content":"Even passing a culture in the surrounding XAML (setting <ph id=\"ph1\">`Language`</ph> or <ph id=\"ph2\">`xml:lang`</ph> to the <ph id=\"ph3\">`sl-SI`</ph> culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.","pos":[10841,11038],"source":" Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue."},{"pos":[11048,11072],"content":"Implementing ConvertFrom","linkify":"Implementing ConvertFrom","nodes":[{"content":"Implementing ConvertFrom","pos":[0,24]}]},{"content":"To be usable as a <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation that supports XAML, the <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> method for that converter must accept a string as the <ph id=\"ph3\">`value`</ph> parameter.","pos":[11076,11306],"source":"To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter."},{"content":"If the string was in valid format, and can be converted by the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation, then the returned object must support a cast to the type expected by the property.","pos":[11307,11511],"source":" If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property."},{"content":"Otherwise, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> implementation must return <ph id=\"ph2\">`null`</ph>.","pos":[11512,11619],"source":" Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.","pos":[11626,11863],"source":"Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters."},{"content":"However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on <ph id=\"ph1\">`xml:lang`</ph>.","pos":[11864,12017],"source":" However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`."},{"pos":[12025,12220],"content":"[!NOTE]\n Do not use the curly brace characters, particularly {, as a possible element of your string format. These characters are reserved as the entry and exit for a markup extension sequence.","leadings":["","> "],"nodes":[{"content":" Do not use the curly brace characters, particularly {, as a possible element of your string format. These characters are reserved as the entry and exit for a markup extension sequence.","pos":[8,193],"nodes":[{"content":"Do not use the curly brace characters, particularly {, as a possible element of your string format.","pos":[1,100]},{"content":"These characters are reserved as the entry and exit for a markup extension sequence.","pos":[101,185]}]}]},{"pos":[12230,12252],"content":"Implementing ConvertTo","linkify":"Implementing ConvertTo","nodes":[{"content":"Implementing ConvertTo","pos":[0,22]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> is potentially used for serialization support.","pos":[12256,12358],"source":"<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support."},{"content":"Serialization support through <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> for your custom type and its type converter is not an absolute requirement.","pos":[12359,12520],"source":" Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement."},{"content":"However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph>.","pos":[12521,12717],"source":" However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>."},{"content":"To be usable as a <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation that supports XAML, the <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> method for that converter must accept an instance of the type (or a value) being supported as the <ph id=\"ph3\">`value`</ph> parameter.","pos":[12724,12996],"source":"To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter."},{"content":"When the <ph id=\"ph1\">`destinationType`</ph> parameter is the type <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, then the returned object must be able to be cast as <ph id=\"ph3\">&lt;xref:System.String&gt;</ph>.","pos":[12997,13141],"source":" When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>."},{"content":"The returned string must represent a serialized value of <ph id=\"ph1\">`value`</ph>.","pos":[13142,13207],"source":" The returned string must represent a serialized value of `value`."},{"content":"Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> implementation of the same converter, without significant loss of information.","pos":[13208,13470],"source":" Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information."},{"content":"If the value cannot be serialized, or the converter does not support serialization, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> implementation must return <ph id=\"ph2\">`null`</ph>, and is permitted to throw an exception in this case.","pos":[13477,13708],"source":"If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case."},{"content":"But if you do throw exceptions, you should report the inability to use that conversion as part of your <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> implementation so that the best practice of checking with <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> first to avoid exceptions is supported.","pos":[13709,14027],"source":" But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported."},{"content":"If <ph id=\"ph1\">`destinationType`</ph> parameter is not of type <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can choose your own converter handling.","pos":[14034,14145],"source":"If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling."},{"content":"Typically, you would revert to base implementation handling, which in the basemost <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> raises a specific exception.","pos":[14146,14313],"source":" Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception."},{"pos":[14323,14348],"content":"Implementing CanConvertTo","linkify":"Implementing CanConvertTo","nodes":[{"content":"Implementing CanConvertTo","pos":[0,25]}]},{"pos":[14352,14551],"content":"Your <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> implementation should return <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`destinationType`</ph> of type <ph id=\"ph4\">&lt;xref:System.String&gt;</ph>, and otherwise defer to the base implementation.","source":"Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation."},{"pos":[14561,14588],"content":"Implementing CanConvertFrom","linkify":"Implementing CanConvertFrom","nodes":[{"content":"Implementing CanConvertFrom","pos":[0,27]}]},{"pos":[14592,14788],"content":"Your <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A&gt;</ph> implementation should return <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`sourceType`</ph> of type <ph id=\"ph4\">&lt;xref:System.String&gt;</ph>, and otherwise defer to the base implementation.","source":"Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation."},{"pos":[14851,14886],"content":"Applying the TypeConverterAttribute","linkify":"Applying the TypeConverterAttribute","nodes":[{"content":"Applying the TypeConverterAttribute","pos":[0,35]}]},{"content":"In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)]</ph> <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to your class definition.","pos":[14890,15196],"source":"In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A&gt;</ph> that you specify through the attribute must be the type name of your custom type converter.","pos":[15197,15365],"source":" The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter."},{"content":"With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.","pos":[15366,15534]},{"content":"You can also provide a type converter on a per-property basis.","pos":[15541,15603]},{"content":"Instead of applying a <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)]</ph> <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to the class definition, apply it to a property definition (the main definition, not the <ph id=\"ph3\">`get`</ph><ph id=\"ph4\">/</ph><ph id=\"ph5\">`set`</ph> implementations within it).","pos":[15604,15896],"source":" Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it)."},{"content":"The type of the property must match the type that is processed by your custom type converter.","pos":[15897,15990]},{"content":"With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.","pos":[15991,16131]},{"content":"The per-property type converter technique is particularly useful if you choose to use a property type from <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)]</ph> or from some other library where you cannot control the class definition and cannot apply a <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> there.","pos":[16132,16471],"source":" The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there."},{"pos":[16480,16488],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\"> [</bpt>XAML Overview (WPF)<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept><ph id=\"ph1\"> </ph>","pos":[16538,16623],"source":" [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Markup Extensions and WPF XAML<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)</ept><ph id=\"ph1\"> </ph>","pos":[16626,16735],"source":" [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md) "},{"content":"<bpt id=\"p1\"> [</bpt>XAML Syntax In Detail<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>","pos":[16738,16828],"source":" [XAML Syntax In Detail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)"}]}