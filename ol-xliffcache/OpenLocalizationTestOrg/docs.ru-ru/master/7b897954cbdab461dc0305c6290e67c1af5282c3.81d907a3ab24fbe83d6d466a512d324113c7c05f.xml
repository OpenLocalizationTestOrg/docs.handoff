{"content":"---\ntitle: \"How to: Add Class Handling for a Routed Event\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"routed events [WPF], class handlers\"\n  - \"task_core_add_class_handling_routed_properties [WPF]\"\n  - \"class handlers [WPF], routed events\"\nms.assetid: 15b7b06c-9112-4ee5-b30a-65d10c5c5df6\n---\n# How to: Add Class Handling for a Routed Event\nRouted events can be handled either by class handlers or instance handlers on any given node in the route. Class handlers are invoked first, and can be used by class implementations to suppress events from instance handling or introduce other event specific behaviors on events that are owned by base classes. This example illustrates two closely related techniques for implementing class handlers.  \n  \n## Example  \n This example uses a custom class based on the <xref:System.Windows.Controls.Canvas> panel. The basic premise of the application is that the custom class introduces behaviors on its child elements, including intercepting any left mouse button clicks and marking them handled, before the child element class or any instance handlers on it will be invoked.  \n  \n The <xref:System.Windows.UIElement> class exposes a virtual method that enables class handling on the <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> event, by simply overriding the event. This is the simplest way to implement class handling if such a virtual method is available somewhere in your class' hierarchy. The following code shows the <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> implementation in the \"MyEditContainer\" that is derived from <xref:System.Windows.Controls.Canvas>. The implementation marks the event as handled in the arguments, and then adds some code to give the source element a basic visible change.  \n  \n [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]\n [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  \n  \n If no virtual is available on base classes or for that particular method, class handling can be added directly using a utility method of the <xref:System.Windows.EventManager> class, <xref:System.Windows.EventManager.RegisterClassHandler%2A>. This method should only be called within the static initialization of classes that are adding class handling. This example adds another handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> , and in this case the registered class is the custom class. In contrast, when using the virtuals, the registered class is really the <xref:System.Windows.UIElement> base class. In cases where base classes and subclass each register class handling, the subclass handlers are invoked first. The behavior in an application would be that first this handler would show its message box and then the visual change in the virtual method's handler would be shown.  \n  \n [!code-csharp[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#staticandregisterclasshandler)]\n [!code-vb[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#staticandregisterclasshandler)]  \n  \n## See also\n\n- <xref:System.Windows.EventManager>\n- [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md)\n- [Handle a Routed Event](how-to-handle-a-routed-event.md)\n- [Routed Events Overview](routed-events-overview.md)\n","nodes":[{"pos":[4,328],"embed":true,"restype":"x-metadata","content":"title: \"How to: Add Class Handling for a Routed Event\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"routed events [WPF], class handlers\"\n  - \"task_core_add_class_handling_routed_properties [WPF]\"\n  - \"class handlers [WPF], routed events\"\nms.assetid: 15b7b06c-9112-4ee5-b30a-65d10c5c5df6","nodes":[{"content":"How to: Add Class Handling for a Routed Event","nodes":[{"pos":[0,45],"content":"How to: Add Class Handling for a Routed Event","nodes":[{"content":"How to: Add Class Handling for a Routed Event","pos":[0,45]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[335,380],"content":"How to: Add Class Handling for a Routed Event","linkify":"How to: Add Class Handling for a Routed Event","nodes":[{"content":"How to: Add Class Handling for a Routed Event","pos":[0,45]}]},{"content":"Routed events can be handled either by class handlers or instance handlers on any given node in the route.","pos":[381,487]},{"content":"Class handlers are invoked first, and can be used by class implementations to suppress events from instance handling or introduce other event specific behaviors on events that are owned by base classes.","pos":[488,690]},{"content":"This example illustrates two closely related techniques for implementing class handlers.","pos":[691,779]},{"pos":[788,795],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example uses a custom class based on the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> panel.","pos":[799,889],"source":"This example uses a custom class based on the <xref:System.Windows.Controls.Canvas> panel."},{"content":"The basic premise of the application is that the custom class introduces behaviors on its child elements, including intercepting any left mouse button clicks and marking them handled, before the child element class or any instance handlers on it will be invoked.","pos":[890,1152]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> class exposes a virtual method that enables class handling on the <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> event, by simply overriding the event.","pos":[1159,1358],"source":"The <xref:System.Windows.UIElement> class exposes a virtual method that enables class handling on the <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> event, by simply overriding the event."},{"content":"This is the simplest way to implement class handling if such a virtual method is available somewhere in your class' hierarchy.","pos":[1359,1485]},{"content":"The following code shows the <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A&gt;</ph> implementation in the \"MyEditContainer\" that is derived from <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Canvas&gt;</ph>.","pos":[1486,1678],"source":" The following code shows the <xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A> implementation in the \"MyEditContainer\" that is derived from <xref:System.Windows.Controls.Canvas>."},{"content":"The implementation marks the event as handled in the arguments, and then adds some code to give the source element a basic visible change.","pos":[1679,1817]},{"content":"If no virtual is available on base classes or for that particular method, class handling can be added directly using a utility method of the <ph id=\"ph1\">&lt;xref:System.Windows.EventManager&gt;</ph> class, <ph id=\"ph2\">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.","pos":[2155,2397],"source":"If no virtual is available on base classes or for that particular method, class handling can be added directly using a utility method of the <xref:System.Windows.EventManager> class, <xref:System.Windows.EventManager.RegisterClassHandler%2A>."},{"content":"This method should only be called within the static initialization of classes that are adding class handling.","pos":[2398,2507]},{"content":"This example adds another handler for <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.PreviewMouseLeftButtonDown&gt;</ph> , and in this case the registered class is the custom class.","pos":[2508,2665],"source":" This example adds another handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> , and in this case the registered class is the custom class."},{"content":"In contrast, when using the virtuals, the registered class is really the <ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> base class.","pos":[2666,2782],"source":" In contrast, when using the virtuals, the registered class is really the <xref:System.Windows.UIElement> base class."},{"content":"In cases where base classes and subclass each register class handling, the subclass handlers are invoked first.","pos":[2783,2894]},{"content":"The behavior in an application would be that first this handler would show its message box and then the visual change in the virtual method's handler would be shown.","pos":[2895,3060]},{"pos":[3444,3452],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3493,3603],"content":"<bpt id=\"p1\">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id=\"p1\">](marking-routed-events-as-handled-and-class-handling.md)</ept>","source":"[Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md)"},{"pos":[3606,3662],"content":"<bpt id=\"p1\">[</bpt>Handle a Routed Event<ept id=\"p1\">](how-to-handle-a-routed-event.md)</ept>","source":"[Handle a Routed Event](how-to-handle-a-routed-event.md)"},{"pos":[3665,3716],"content":"<bpt id=\"p1\">[</bpt>Routed Events Overview<ept id=\"p1\">](routed-events-overview.md)</ept>","source":"[Routed Events Overview](routed-events-overview.md)"}]}