{"content":"---\ntitle: \"Accessing Services Using a Client\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d\n---\n# Accessing Services Using a Client\nClient applications must create, configure, and use WCF client or channel objects to communicate with services. The [WCF Client Overview](../../../../docs/framework/wcf/wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.  \n  \n This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.  \n  \n## Overview  \n This topic describes behavior and issues relating to:  \n  \n-   Channel and session lifetimes.  \n  \n-   Handling exceptions.  \n  \n-   Understanding blocking issues.  \n  \n-   Initializing channels interactively.  \n  \n### Channel and Session Lifetimes  \n Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.  \n  \n A *datagram* channel is a channel in which all messages are uncorrelated. With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused. Because of this, datagram channels typically do not fault.  \n  \n *Sessionful* channels, however, are channels with a connection to the other endpoint. Messages in a session on one side are always correlated with the same session on the other side. In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful. If they cannot agree, the sessionful channel may fault.  \n  \n Open clients explicitly or implicitly by calling the first operation.  \n  \n> [!NOTE]\n>  Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation. For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure. But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures. If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.  \n  \n Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not. For more information, see [Using Sessions](../../../../docs/framework/wcf/using-sessions.md).  \n  \n### The Proper Use of Sessions  \n Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful. It is recommended that a calling application open the channel, use it, and close the channel inside one try block. If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful. Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.  \n  \n The following section provides an example of this client approach.  \n  \n### Handling Exceptions  \n Handling exceptions in client applications is straightforward. If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown. Typically, if an exception is thrown the conversation is aborted.  \n  \n> [!NOTE]\n>  Use of the `using` statement (`Using` in Visual Basic) is not recommended. This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about. For more information, see [Use Close and Abort to release WCF client resources](../../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md).  \n  \n The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.  \n  \n [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]\n [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  \n  \n> [!NOTE]\n>  Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.  \n  \n Datagram channels never fault even if exceptions occur when they are closed. In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>. However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.  \n  \n For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md). [Expected Exceptions](../../../../docs/framework/wcf/samples/expected-exceptions.md) describes expected exceptions and shows how to handle them. For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md).  \n  \n### Client Blocking and Performance  \n When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown. This behavior is similar to local behavior. When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown. And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent. One-way operations are only about the message exchange, no more and no less. For more information, see [One-Way Services](../../../../docs/framework/wcf/feature-details/one-way-services.md).  \n  \n Large data chunks can slow client processing no matter what the message exchange pattern. To understand how to handle these issues, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  \n  \n If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements. The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). For an example, see [How to: Call Service Operations Asynchronously](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md).  \n  \n For more information about increasing client performance, see [Middle-Tier Client Applications](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md).  \n  \n### Enabling the User to Select Credentials Dynamically  \n The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.  \n  \n Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways. The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).  \n  \n If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension. If it calls anything other than the first operation, an exception is thrown.  \n  \n If using the explicit approach, the application must perform the following steps in order:  \n  \n1.  Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).  \n  \n2.  When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.  \n  \n3.  Call operations.  \n  \n It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.  \n  \n Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.  \n  \n## See also\n\n- [Duplex Services](../../../../docs/framework/wcf/feature-details/duplex-services.md)\n- [How to: Access Services with One-Way and Request-Reply Contracts](../../../../docs/framework/wcf/feature-details/how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)\n- [How to: Access Services with a Duplex Contract](../../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)\n- [How to: Access a WSE 3.0 Service](../../../../docs/framework/wcf/feature-details/how-to-access-a-wse-3-0-service-with-a-wcf-client.md)\n- [How to: Use the ChannelFactory](../../../../docs/framework/wcf/feature-details/how-to-use-the-channelfactory.md)\n- [How to: Call Service Operations Asynchronously](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)\n- [Middle-Tier Client Applications](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)\n","nodes":[{"pos":[4,151],"embed":true,"restype":"x-metadata","content":"title: \"Accessing Services Using a Client\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d","nodes":[{"content":"Accessing Services Using a Client","nodes":[{"pos":[0,33],"content":"Accessing Services Using a Client","nodes":[{"content":"Accessing Services Using a Client","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[158,191],"content":"Accessing Services Using a Client","linkify":"Accessing Services Using a Client","nodes":[{"content":"Accessing Services Using a Client","pos":[0,33]}]},{"content":"Client applications must create, configure, and use WCF client or channel objects to communicate with services.","pos":[192,303]},{"content":"The <bpt id=\"p1\">[</bpt>WCF Client Overview<ept id=\"p1\">](../../../../docs/framework/wcf/wcf-client-overview.md)</ept> topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.","pos":[304,506],"source":" The [WCF Client Overview](../../../../docs/framework/wcf/wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them."},{"content":"This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.","pos":[513,683]},{"pos":[692,700],"content":"Overview","linkify":"Overview","nodes":[{"content":"Overview","pos":[0,8]}]},{"content":"This topic describes behavior and issues relating to:","pos":[704,757]},{"content":"Channel and session lifetimes.","pos":[767,797]},{"content":"Handling exceptions.","pos":[807,827]},{"content":"Understanding blocking issues.","pos":[837,867]},{"content":"Initializing channels interactively.","pos":[877,913]},{"pos":[923,952],"content":"Channel and Session Lifetimes","linkify":"Channel and Session Lifetimes","nodes":[{"content":"Channel and Session Lifetimes","pos":[0,29]}]},{"content":"Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.","pos":[956,1069]},{"content":"A <bpt id=\"p1\">*</bpt>datagram<ept id=\"p1\">*</ept> channel is a channel in which all messages are uncorrelated.","pos":[1076,1149],"source":"A *datagram* channel is a channel in which all messages are uncorrelated."},{"content":"With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.","pos":[1150,1293]},{"content":"Because of this, datagram channels typically do not fault.","pos":[1294,1352]},{"content":"<bpt id=\"p1\">*</bpt>Sessionful<ept id=\"p1\">*</ept> channels, however, are channels with a connection to the other endpoint.","pos":[1359,1444],"source":"*Sessionful* channels, however, are channels with a connection to the other endpoint."},{"content":"Messages in a session on one side are always correlated with the same session on the other side.","pos":[1445,1541]},{"content":"In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.","pos":[1542,1695]},{"content":"If they cannot agree, the sessionful channel may fault.","pos":[1696,1751]},{"content":"Open clients explicitly or implicitly by calling the first operation.","pos":[1758,1827]},{"pos":[1835,2817],"content":"[!NOTE]\n Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation. For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure. But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures. If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.","leadings":["","> "],"nodes":[{"content":"Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation. For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure. But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures. If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.","pos":[9,980],"nodes":[{"content":"Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.","pos":[0,151]},{"content":"For example, because the <ph id=\"ph1\">&lt;xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType&gt;</ph> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType&gt;</ph> event on the service or the client you are likely to be notified quickly in the event of a network failure.","pos":[152,541],"source":" For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure."},{"content":"But reliable sessions (established by bindings in which the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType&gt;</ph> is enabled) are designed to insulate services from small network failures.","pos":[542,771],"source":" But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures."},{"content":"If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.","pos":[772,971]}]}]},{"content":"Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <ph id=\"ph1\">&lt;xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType&gt;</ph> does not.","pos":[2824,3025],"source":"Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using Sessions<ept id=\"p1\">](../../../../docs/framework/wcf/using-sessions.md)</ept>.","pos":[3026,3119],"source":" For more information, see [Using Sessions](../../../../docs/framework/wcf/using-sessions.md)."},{"pos":[3129,3155],"content":"The Proper Use of Sessions","linkify":"The Proper Use of Sessions","nodes":[{"content":"The Proper Use of Sessions","pos":[0,26]}]},{"content":"Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.","pos":[3159,3277]},{"content":"It is recommended that a calling application open the channel, use it, and close the channel inside one try block.","pos":[3278,3392]},{"content":"If a session channel is open, and the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType&gt;</ph> method is called once, and that call returns successfully, then the session was successful.","pos":[3393,3608],"source":" If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful."},{"content":"Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType&gt;</ph> on the channel before calling <ph id=\"ph2\">&lt;xref:System.ServiceModel.ICommunicationObject.Close%2A&gt;</ph>.","pos":[3609,3905],"source":" Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>."},{"content":"The following section provides an example of this client approach.","pos":[3912,3978]},{"pos":[3988,4007],"content":"Handling Exceptions","linkify":"Handling Exceptions","nodes":[{"content":"Handling Exceptions","pos":[0,19]}]},{"content":"Handling exceptions in client applications is straightforward.","pos":[4011,4073]},{"content":"If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.","pos":[4074,4202]},{"content":"Typically, if an exception is thrown the conversation is aborted.","pos":[4203,4268]},{"pos":[4276,4659],"content":"[!NOTE]\n Use of the `using` statement (`Using` in Visual Basic) is not recommended. This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about. For more information, see [Use Close and Abort to release WCF client resources](../../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md).","leadings":["","> "],"nodes":[{"content":"Use of the `using` statement (`Using` in Visual Basic) is not recommended. This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about. For more information, see [Use Close and Abort to release WCF client resources](../../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md).","pos":[9,381],"nodes":[{"content":"Use of the <ph id=\"ph1\">`using`</ph> statement (<ph id=\"ph2\">`Using`</ph> in Visual Basic) is not recommended.","pos":[0,74],"source":"Use of the `using` statement (`Using` in Visual Basic) is not recommended."},{"content":"This is because the end of the <ph id=\"ph1\">`using`</ph> statement can cause exceptions that can mask other exceptions you may need to know about.","pos":[75,203],"source":" This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Use Close and Abort to release WCF client resources<ept id=\"p1\">](../../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md)</ept>.","pos":[204,372],"source":" For more information, see [Use Close and Abort to release WCF client resources](../../../../docs/framework/wcf/samples/use-close-abort-release-wcf-client-resources.md)."}]}]},{"pos":[4666,4784],"content":"The following code example shows the recommended client pattern using a try/catch block and not the <ph id=\"ph1\">`using`</ph> statement.","source":"The following code example shows the recommended client pattern using a try/catch block and not the `using` statement."},{"pos":[5064,5288],"content":"[!NOTE]\n Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.","leadings":["","> "],"nodes":[{"content":"Checking the value of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType&gt;</ph> property is a race condition and is not recommended to determine whether to reuse or close a channel.","pos":[9,222],"source":"Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel."}]},{"content":"Datagram channels never fault even if exceptions occur when they are closed.","pos":[5295,5371]},{"content":"In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType&gt;</ph>.","pos":[5372,5566],"source":" In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>."},{"content":"However if the duplex client using a secure conversation fails to authenticate, the client receives a <ph id=\"ph1\">&lt;xref:System.TimeoutException?displayProperty=nameWithType&gt;</ph> instead.","pos":[5567,5737],"source":" However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead."},{"content":"For more complete information about working with error information at the application level, see <bpt id=\"p1\">[</bpt>Specifying and Handling Faults in Contracts and Services<ept id=\"p1\">](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)</ept>.","pos":[5744,5992],"source":"For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)."},{"content":"<bpt id=\"p1\">[</bpt>Expected Exceptions<ept id=\"p1\">](../../../../docs/framework/wcf/samples/expected-exceptions.md)</ept> describes expected exceptions and shows how to handle them.","pos":[5993,6137],"source":"[Expected Exceptions](../../../../docs/framework/wcf/samples/expected-exceptions.md) describes expected exceptions and shows how to handle them."},{"content":"For more information about how to handle errors when developing channels, see <bpt id=\"p1\">[</bpt>Handling Exceptions and Faults<ept id=\"p1\">](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md)</ept>.","pos":[6138,6325],"source":" For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md)."},{"pos":[6335,6366],"content":"Client Blocking and Performance","linkify":"Client Blocking and Performance","nodes":[{"content":"Client Blocking and Performance","pos":[0,31]}]},{"content":"When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <ph id=\"ph1\">&lt;xref:System.TimeoutException?displayProperty=nameWithType&gt;</ph>) is thrown.","pos":[6370,6586],"source":"When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown."},{"content":"This behavior is similar to local behavior.","pos":[6587,6630]},{"content":"When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.","pos":[6631,6838]},{"content":"And while the one-way message exchange pattern (specified by marking an operation with <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType&gt;</ph> set to <ph id=\"ph2\">`true`</ph>) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.","pos":[6839,7178],"source":" And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent."},{"content":"One-way operations are only about the message exchange, no more and no less.","pos":[7179,7255]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>One-Way Services<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/one-way-services.md)</ept>.","pos":[7256,7369],"source":" For more information, see [One-Way Services](../../../../docs/framework/wcf/feature-details/one-way-services.md)."},{"content":"Large data chunks can slow client processing no matter what the message exchange pattern.","pos":[7376,7465]},{"content":"To understand how to handle these issues, see <bpt id=\"p1\">[</bpt>Large Data and Streaming<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)</ept>.","pos":[7466,7615],"source":" To understand how to handle these issues, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)."},{"content":"If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements.","pos":[7622,7802]},{"content":"The easiest way to do this is to use the <ph id=\"ph1\">`/async`</ph> switch on the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.","pos":[7803,8000],"source":" The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)."},{"content":"For an example, see <bpt id=\"p1\">[</bpt>How to: Call Service Operations Asynchronously<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)</ept>.","pos":[8001,8171],"source":" For an example, see [How to: Call Service Operations Asynchronously](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)."},{"pos":[8178,8357],"content":"For more information about increasing client performance, see <bpt id=\"p1\">[</bpt>Middle-Tier Client Applications<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)</ept>.","source":"For more information about increasing client performance, see [Middle-Tier Client Applications](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)."},{"pos":[8367,8418],"content":"Enabling the User to Select Credentials Dynamically","linkify":"Enabling the User to Select Credentials Dynamically","nodes":[{"content":"Enabling the User to Select Credentials Dynamically","pos":[0,51]}]},{"pos":[8422,8662],"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer&gt;</ph> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.","source":"The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start."},{"content":"Application developers can make use of an inserted <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer&gt;</ph> in two ways.","pos":[8669,8801],"source":"Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways."},{"content":"The client application can call either <ph id=\"ph1\">&lt;xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType&gt;</ph> (or an asynchronous version) prior to opening the channel (the <bpt id=\"p1\">*</bpt>explicit<ept id=\"p1\">*</ept> approach) or call the first operation (the <bpt id=\"p2\">*</bpt>implicit<ept id=\"p2\">*</ept> approach).","pos":[8802,9178],"source":" The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach)."},{"content":"If using the implicit approach, the application must call the first operation on a <ph id=\"ph1\">&lt;xref:System.ServiceModel.ClientBase%601&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.IClientChannel&gt;</ph> extension.","pos":[9185,9365],"source":"If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension."},{"content":"If it calls anything other than the first operation, an exception is thrown.","pos":[9366,9442]},{"content":"If using the explicit approach, the application must perform the following steps in order:","pos":[9449,9539]},{"pos":[9549,9789],"content":"Call either <ph id=\"ph1\">&lt;xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType&gt;</ph> (or an asynchronous version).","source":"Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version)."},{"pos":[9799,10144],"content":"When the initializers have returned, call either the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Open%2A&gt;</ph> method on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.IClientChannel&gt;</ph> object or on the <ph id=\"ph3\">&lt;xref:System.ServiceModel.IClientChannel&gt;</ph> object returned from the <ph id=\"ph4\">&lt;xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType&gt;</ph> property.","source":"When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property."},{"content":"Call operations.","pos":[10154,10170]},{"content":"It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.","pos":[10177,10301]},{"content":"Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.","pos":[10308,10546]},{"pos":[10555,10563],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10567,10651],"content":"<bpt id=\"p1\">[</bpt>Duplex Services<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/duplex-services.md)</ept>","source":"[Duplex Services](../../../../docs/framework/wcf/feature-details/duplex-services.md)"},{"pos":[10654,10839],"content":"<bpt id=\"p1\">[</bpt>How to: Access Services with One-Way and Request-Reply Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)</ept>","source":"[How to: Access Services with One-Way and Request-Reply Contracts](../../../../docs/framework/wcf/feature-details/how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)"},{"pos":[10842,10987],"content":"<bpt id=\"p1\">[</bpt>How to: Access Services with a Duplex Contract<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)</ept>","source":"[How to: Access Services with a Duplex Contract](../../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)"},{"pos":[10990,11125],"content":"<bpt id=\"p1\">[</bpt>How to: Access a WSE 3.0 Service<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-access-a-wse-3-0-service-with-a-wcf-client.md)</ept>","source":"[How to: Access a WSE 3.0 Service](../../../../docs/framework/wcf/feature-details/how-to-access-a-wse-3-0-service-with-a-wcf-client.md)"},{"pos":[11128,11241],"content":"<bpt id=\"p1\">[</bpt>How to: Use the ChannelFactory<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-use-the-channelfactory.md)</ept>","source":"[How to: Use the ChannelFactory](../../../../docs/framework/wcf/feature-details/how-to-use-the-channelfactory.md)"},{"pos":[11244,11393],"content":"<bpt id=\"p1\">[</bpt>How to: Call Service Operations Asynchronously<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)</ept>","source":"[How to: Call Service Operations Asynchronously](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)"},{"pos":[11396,11512],"content":"<bpt id=\"p1\">[</bpt>Middle-Tier Client Applications<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)</ept>","source":"[Middle-Tier Client Applications](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)"}]}