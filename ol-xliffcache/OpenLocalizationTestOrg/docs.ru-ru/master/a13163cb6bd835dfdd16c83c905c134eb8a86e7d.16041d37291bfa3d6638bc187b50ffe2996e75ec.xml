{"content":"---\ntitle: Indexers\ndescription: Learn about C# indexers and how they implement indexed properties, which are properties referenced using one or more arguments.\nms.date: 06/20/2016\nms.assetid: 0e9496da-e766-45a9-b92b-91820d4a350e\n---\n\n# Indexers\n\n*Indexers* are similar to properties. In many ways indexers build\non the same language features as [properties](properties.md). Indexers\nenable *indexed* properties: properties referenced using one or more\narguments. Those arguments provide an index into some collection\nof values.\n\n## Indexer Syntax\n\nYou access an indexer through a variable name and square brackets. You place the indexer\narguments inside the brackets:\n\n```csharp\nvar item = someObject[\"key\"];\nsomeObject[\"AnotherKey\"] = item;\n```\n\nYou declare indexers using the `this` keyword as the property name, and\ndeclaring the arguments within square brackets. This declaration would match\nthe usage shown in the previous paragraph:\n\n```csharp\npublic int this[string key]\n{\n    get { return storage.Find(key); }\n    set { storage.SetAt(key, value); }\n}\n```\n\nFrom this initial example, you can see the relationship between the syntax\nfor properties and for indexers. This analogy carries through most of the\nsyntax rules for indexers. Indexers can have any valid access modifiers\n(public, protected internal, protected, internal, private or private protected). They may\nbe sealed, virtual, or abstract. As with properties, you can specify\ndifferent access modifiers for the get and set accessors in an indexer.\nYou may also specify read-only indexers (by omitting the set accessor),\nor write-only indexers (by omitting the get accessor).\n\nYou can apply almost everything you learn from working with properties\nto indexers. The only exception to that rule is\n*auto implemented properties*. The compiler cannot always\ngenerate the correct storage for an indexer.\n\nThe presence of arguments to reference an item in a set of items distinguishes\nindexers from properties. You may define multiple indexers on a type, as long\nas the argument lists for each indexer is unique. Let's explore different\nscenarios where you might use one or more indexers in a class definition. \n\n## Scenarios\n\nYou would define *indexers* in your type when its API models some\ncollection where you define the arguments to that collection. Your indexers\nmay or may not map directly to the collection types that are part of the .NET\ncore framework. Your type\nmay have other responsibilities in addition to modeling a collection.\nIndexers enable you to provide the API that matches your type's abstraction\nwithout exposing the inner details of how the values for that abstraction\nare stored or computed.\n\nLet's walk through some of the common scenarios for using *indexers*. You can access the [sample folder for indexers](https://github.com/dotnet/samples/tree/master/csharp/indexers). For download instructions, see [Samples and Tutorials](../samples-and-tutorials/index.md#viewing-and-downloading-samples).\n\n### Arrays and Vectors\n\nOne of the most common scenarios for creating indexers is when your\ntype models an array, or a vector. You can create an indexer to model\nan ordered list of data. \n\nThe advantage of creating your own indexer is that you can define\nthe storage for that collection to suit your needs. Imagine a\nscenario where your type models historical data that is too large\nto load into memory at once. You need to load and unload sections\nof the collection based on usage. The example following models\nthis behavior. It reports on how many data points exist. It creates\npages to hold sections of the data on demand. It removes pages\nfrom memory to make room for pages needed by more recent requests.\n\n```csharp\npublic class DataSamples\n{\n    private class Page\n    {\n        private readonly List<Measurements> pageData = new List<Measurements>();\n        private readonly int startingIndex;\n        private readonly int length;\n        private bool dirty;\n        private DateTime lastAccess;\n\n        public Page(int startingIndex, int length)\n        {\n            this.startingIndex = startingIndex;\n            this.length = length;\n            lastAccess = DateTime.Now;\n\n            // This stays as random stuff:\n            var generator = new Random();\n            for(int i=0; i < length; i++)\n            {\n                var m = new Measurements\n                {\n                    HiTemp = generator.Next(50, 95),\n                    LoTemp = generator.Next(12, 49),\n                    AirPressure = 28.0 + generator.NextDouble() * 4\n                };\n                pageData.Add(m);\n            }\n        }\n        public bool HasItem(int index) =>\n            ((index >= startingIndex) &&\n            (index < startingIndex + length));\n\n        public Measurements this[int index]\n        {\n            get\n            {\n                lastAccess = DateTime.Now;\n                return pageData[index - startingIndex];\n            }\n            set\n            {\n                pageData[index - startingIndex] = value;\n                dirty = true;\n                lastAccess = DateTime.Now;\n            }\n        }\n\n        public bool Dirty => dirty;\n        public DateTime LastAccess => lastAccess;\n    }\n\n    private readonly int totalSize;\n    private readonly List<Page> pagesInMemory = new List<Page>();\n\n    public DataSamples(int totalSize)\n    {\n        this.totalSize = totalSize;\n    }\n\n    public Measurements this[int index]\n    {\n        get\n        {\n            if (index < 0)\n                throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= totalSize)\n                throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n\n            var page = updateCachedPagesForAccess(index);\n            return page[index];\n        }\n        set\n        {\n            if (index < 0)\n                throw new IndexOutOfRangeException(\"Cannot index less than 0\");\n            if (index >= totalSize)\n                throw new IndexOutOfRangeException(\"Cannot index past the end of storage\");\n            var page = updateCachedPagesForAccess(index);\n\n            page[index] = value;\n        }\n    }\n\n    private Page updateCachedPagesForAccess(int index)\n    {\n        foreach (var p in pagesInMemory)\n        {\n            if (p.HasItem(index))\n            {\n                return p;\n            }\n        }\n        var startingIndex = (index / 1000) * 1000;\n        var newPage = new Page(startingIndex, 1000);\n        addPageToCache(newPage);\n        return newPage;\n    }\n\n    private void addPageToCache(Page p)\n    {\n        if (pagesInMemory.Count > 4)\n        {\n            // remove oldest non-dirty page:\n            var oldest = pagesInMemory\n                .Where(page => !page.Dirty)\n                .OrderBy(page => page.LastAccess)\n                .FirstOrDefault();\n            // Note that this may keep more than 5 pages in memory\n            // if too much is dirty\n            if (oldest != null)\n                pagesInMemory.Remove(oldest);\n        }\n        pagesInMemory.Add(p);\n    }\n}\n```\n\nYou can follow this design idiom to model any sort of collection where\nthere are good reasons not to load the entire set of data into an in-\nmemory collection. Notice that the `Page` class is a private nested\nclass that is not part of the public interface. Those details are hidden\nfrom any users of this class.\n\n### Dictionaries\n\nAnother common scenario is when you need to model a dictionary\nor a map. This scenario is when your type stores values based on key,\ntypically text keys. This example creates a dictionary that maps command\nline arguments to [lambda expressions](delegates-overview.md) that manage\nthose options. The following example shows two classes: an `ArgsActions`\nclass that maps a command line option to an `Action` delegate, and an\n`ArgsProcessor` that uses the `ArgsActions` to execute each `Action` when\nit encounters that option.\n\n```csharp\npublic class ArgsProcessor\n{\n    private readonly ArgsActions actions;\n\n    public ArgsProcessor(ArgsActions actions)\n    {\n        this.actions = actions;\n    }\n\n    public void Process(string[] args)\n    {\n        foreach(var arg in args)\n        {\n            actions[arg]?.Invoke();\n        }\n    }\n\n}\npublic class ArgsActions\n{\n    readonly private Dictionary<string, Action> argsActions = new Dictionary<string, Action>();\n\n    public Action this[string s]\n    {\n        get\n        {\n            Action action;\n            Action defaultAction = () => {} ;\n            return argsActions.TryGetValue(s, out action) ? action : defaultAction;\n        }\n    }\n\n    public void SetOption(string s, Action a)\n    {\n        argsActions[s] = a;\n    }\n}\n```\n\nIn this example, the `ArgsAction` collection maps closely to the underlying collection.\nThe `get` determines if a given option has been configured. If so, it returns\nthe `Action` associated with that option. If not, it returns an `Action` that \ndoes nothing. The public accessor does not include a `set` accessor. Rather,\nthe design using a public method for setting options.\n\n### Multi-Dimensional Maps\n\nYou can create indexers that use multiple arguments. In addition,\nthose arguments are not constrained to be the same type. Let's look at\ntwo examples.   \n\nThe first example shows a class that generates values for a Mandelbrot\nset. For more information on the mathematics behind the set, read\n[this article](https://en.wikipedia.org/wiki/Mandelbrot_set). \nThe indexer uses two doubles to define a point in the X, Y plane.\nThe get accessor computes the number of iterations until a point is\ndetermined to be not in the set. If the maximum iterations is reached, the point\nis in the set, and the class's maxIterations value is returned. (The computer\ngenerated images popularized for the Mandelbrot set define colors for the\nnumber of iterations necessary to determine that a point is outside the set.\n\n```csharp\npublic class Mandelbrot\n{\n    readonly private int maxIterations;\n\n    public Mandelbrot(int maxIterations)\n    {\n        this.maxIterations = maxIterations;\n    }\n\n    public int this [double x, double y]\n    {\n        get\n        {\n            var iterations = 0;\n            var x0 = x;\n            var y0 = y;\n\n            while ((x*x + y * y < 4) &&\n                (iterations < maxIterations))\n            {\n                var newX = x * x - y * y + x0;\n                y = 2 * x * y + y0;\n                x = newX;\n                iterations++;\n            }\n            return iterations;\n        }\n    }\n}\n```\n\nThe Mandelbrot Set defines values at every (x,y) coordinate for real number values.\nThat defines a dictionary that could contain an infinite number of values. Therefore,\nthere is no storage behind the set. Instead, this class computes the value for each\npoint when code calls the `get` accessor. There's no underlying storage used.\n\nLet's examine one last use of indexers, where the indexer takes multiple arguments\nof different types. Consider a program that manages historical temperature\ndata. This indexer uses a city and a date to set or get the high and low \ntemperatures for that location:\n\n```csharp\nusing DateMeasurements = \n    System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>;\nusing CityDataMeasurements = \n    System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>>;\n\npublic class HistoricalWeatherData\n{\n    readonly CityDataMeasurements storage = new CityDataMeasurements();\n\n    public Measurements this[string city, DateTime date]\n    {\n        get\n        {\n            var cityData = default(DateMeasurements);\n\n            if (!storage.TryGetValue(city, out cityData))\n                throw new ArgumentOutOfRangeException(nameof(city), \"City not found\");\n\n            // strip out any time portion:\n            var index = date.Date;\n            var measure = default(Measurements);\n            if (cityData.TryGetValue(index, out measure))\n                return measure;\n            throw new ArgumentOutOfRangeException(nameof(date), \"Date not found\");\n        }\n        set\n        {\n            var cityData = default(DateMeasurements);\n\n            if (!storage.TryGetValue(city, out cityData))\n            {\n                cityData = new DateMeasurements();\n                storage.Add(city, cityData);\n            }\n\n            // Strip out any time portion:\n            var index = date.Date;\n            cityData[index] = value;\n        }\n    }\n}\n```\n\nThis example creates an indexer that maps weather data on two different\narguments: a city (represented by a `string`) and a date (represented by\na `DateTime`). The internal storage uses two `Dictionary` classes to represent\nthe two-dimensional dictionary. The public API no longer represents the\nunderlying storage. Rather, the language features of indexers enables you\nto create a public interface that represents your abstraction, even though\nthe underlying storage must use different core collection types.\n\nThere are two parts of this code that may be unfamiliar\nto some developers. These two `using` statements:\n\n```csharp\nusing DateMeasurements = System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>;\nusing CityDataMeasurements = System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>>;\n```\n\ncreate an *alias* for a constructed generic type. Those statements enable the\ncode later to use the more descriptive `DateMeasurements` and `CityDateMeasurements`\nnames instead of the generic construction of `Dictionary<DateTime, Measurements>`\nand `Dictionary<string, Dictionary<DateTime, Measurements> >`. \nThis construct does require using the fully qualified type names on the right\nside of the `=` sign.\n\nThe second technique is to strip off the time portions of any `DateTime` object\nused to index into the collections. The .NET framework does not include a Date only type.\nDevelopers use the `DateTime` type, but use the `Date` property to ensure that any\n`DateTime` object from that day are equal.\n\n## Summing Up\n\nYou should create indexers anytime you have a property-like element in your\nclass where that property represents not a single value, but rather a collection\nof values where each individual item is identified by a set of arguments. Those\narguments can uniquely identify which item in the collection should be referenced.\nIndexers extend the concept of [properties](properties.md), where a member is treated\nlike a data item from outside the class, but like a method on the side. Indexers allow\narguments to find a single item in a property that represents a set of items.\n","nodes":[{"pos":[4,229],"embed":true,"restype":"x-metadata","content":"title: Indexers\ndescription: Learn about C# indexers and how they implement indexed properties, which are properties referenced using one or more arguments.\nms.date: 06/20/2016\nms.assetid: 0e9496da-e766-45a9-b92b-91820d4a350e","nodes":[{"content":"Indexers","nodes":[{"pos":[0,8],"content":"Indexers","nodes":[{"content":"Indexers","pos":[0,8]}]}],"path":["title"],"nosxs":false},{"content":"Learn about C# indexers and how they implement indexed properties, which are properties referenced using one or more arguments.","nodes":[{"pos":[0,127],"content":"Learn about C# indexers and how they implement indexed properties, which are properties referenced using one or more arguments.","nodes":[{"content":"Learn about C# indexers and how they implement indexed properties, which are properties referenced using one or more arguments.","pos":[0,127]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[237,245],"content":"Indexers","linkify":"Indexers","nodes":[{"content":"Indexers","pos":[0,8]}]},{"content":"<bpt id=\"p1\">*</bpt>Indexers<ept id=\"p1\">*</ept> are similar to properties.","pos":[247,284],"source":"*Indexers* are similar to properties."},{"content":"In many ways indexers build on the same language features as <bpt id=\"p1\">[</bpt>properties<ept id=\"p1\">](properties.md)</ept>.","pos":[285,374],"source":" In many ways indexers build\non the same language features as [properties](properties.md)."},{"content":"Indexers enable <bpt id=\"p1\">*</bpt>indexed<ept id=\"p1\">*</ept> properties: properties referenced using one or more arguments.","pos":[375,463],"source":" Indexers\nenable *indexed* properties: properties referenced using one or more\narguments."},{"content":"Those arguments provide an index into some collection of values.","pos":[464,528],"source":" Those arguments provide an index into some collection\nof values."},{"pos":[533,547],"content":"Indexer Syntax","linkify":"Indexer Syntax","nodes":[{"content":"Indexer Syntax","pos":[0,14]}]},{"content":"You access an indexer through a variable name and square brackets.","pos":[549,615]},{"content":"You place the indexer arguments inside the brackets:","pos":[616,668],"source":" You place the indexer\narguments inside the brackets:"},{"content":"You declare indexers using the <ph id=\"ph1\">`this`</ph> keyword as the property name, and declaring the arguments within square brackets.","pos":[748,867],"source":"You declare indexers using the `this` keyword as the property name, and\ndeclaring the arguments within square brackets."},{"content":"This declaration would match the usage shown in the previous paragraph:","pos":[868,939],"source":" This declaration would match\nthe usage shown in the previous paragraph:"},{"content":"From this initial example, you can see the relationship between the syntax for properties and for indexers.","pos":[1065,1172],"source":"From this initial example, you can see the relationship between the syntax\nfor properties and for indexers."},{"content":"This analogy carries through most of the syntax rules for indexers.","pos":[1173,1240],"source":" This analogy carries through most of the\nsyntax rules for indexers."},{"content":"Indexers can have any valid access modifiers (public, protected internal, protected, internal, private or private protected).","pos":[1241,1366],"source":" Indexers can have any valid access modifiers\n(public, protected internal, protected, internal, private or private protected)."},{"content":"They may be sealed, virtual, or abstract.","pos":[1367,1408],"source":" They may\nbe sealed, virtual, or abstract."},{"content":"As with properties, you can specify different access modifiers for the get and set accessors in an indexer.","pos":[1409,1516],"source":" As with properties, you can specify\ndifferent access modifiers for the get and set accessors in an indexer."},{"content":"You may also specify read-only indexers (by omitting the set accessor), or write-only indexers (by omitting the get accessor).","pos":[1517,1643],"source":"\nYou may also specify read-only indexers (by omitting the set accessor),\nor write-only indexers (by omitting the get accessor)."},{"content":"You can apply almost everything you learn from working with properties to indexers.","pos":[1645,1728],"source":"You can apply almost everything you learn from working with properties\nto indexers."},{"content":"The only exception to that rule is <bpt id=\"p1\">*</bpt>auto implemented properties<ept id=\"p1\">*</ept>.","pos":[1729,1794],"source":" The only exception to that rule is\n*auto implemented properties*."},{"content":"The compiler cannot always generate the correct storage for an indexer.","pos":[1795,1866],"source":" The compiler cannot always\ngenerate the correct storage for an indexer."},{"content":"The presence of arguments to reference an item in a set of items distinguishes indexers from properties.","pos":[1868,1972],"source":"The presence of arguments to reference an item in a set of items distinguishes\nindexers from properties."},{"content":"You may define multiple indexers on a type, as long as the argument lists for each indexer is unique.","pos":[1973,2074],"source":" You may define multiple indexers on a type, as long\nas the argument lists for each indexer is unique."},{"content":"Let's explore different scenarios where you might use one or more indexers in a class definition.","pos":[2075,2172],"source":" Let's explore different\nscenarios where you might use one or more indexers in a class definition."},{"pos":[2178,2187],"content":"Scenarios","linkify":"Scenarios","nodes":[{"content":"Scenarios","pos":[0,9]}]},{"content":"You would define <bpt id=\"p1\">*</bpt>indexers<ept id=\"p1\">*</ept> in your type when its API models some collection where you define the arguments to that collection.","pos":[2189,2316],"source":"You would define *indexers* in your type when its API models some\ncollection where you define the arguments to that collection."},{"content":"Your indexers may or may not map directly to the collection types that are part of the .NET core framework.","pos":[2317,2424],"source":" Your indexers\nmay or may not map directly to the collection types that are part of the .NET\ncore framework."},{"content":"Your type may have other responsibilities in addition to modeling a collection.","pos":[2425,2504],"source":" Your type\nmay have other responsibilities in addition to modeling a collection."},{"content":"Indexers enable you to provide the API that matches your type's abstraction without exposing the inner details of how the values for that abstraction are stored or computed.","pos":[2505,2678],"source":"\nIndexers enable you to provide the API that matches your type's abstraction\nwithout exposing the inner details of how the values for that abstraction\nare stored or computed."},{"content":"Let's walk through some of the common scenarios for using <bpt id=\"p1\">*</bpt>indexers<ept id=\"p1\">*</ept>.","pos":[2680,2749],"source":"Let's walk through some of the common scenarios for using *indexers*."},{"content":"You can access the <bpt id=\"p1\">[</bpt>sample folder for indexers<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/indexers)</ept>.","pos":[2750,2861],"source":" You can access the [sample folder for indexers](https://github.com/dotnet/samples/tree/master/csharp/indexers)."},{"content":"For download instructions, see <bpt id=\"p1\">[</bpt>Samples and Tutorials<ept id=\"p1\">](../samples-and-tutorials/index.md#viewing-and-downloading-samples)</ept>.","pos":[2862,2984],"source":" For download instructions, see [Samples and Tutorials](../samples-and-tutorials/index.md#viewing-and-downloading-samples)."},{"pos":[2990,3008],"content":"Arrays and Vectors","linkify":"Arrays and Vectors","nodes":[{"content":"Arrays and Vectors","pos":[0,18]}]},{"content":"One of the most common scenarios for creating indexers is when your type models an array, or a vector.","pos":[3010,3112],"source":"One of the most common scenarios for creating indexers is when your\ntype models an array, or a vector."},{"content":"You can create an indexer to model an ordered list of data.","pos":[3113,3172],"source":" You can create an indexer to model\nan ordered list of data."},{"content":"The advantage of creating your own indexer is that you can define the storage for that collection to suit your needs.","pos":[3175,3292],"source":"The advantage of creating your own indexer is that you can define\nthe storage for that collection to suit your needs."},{"content":"Imagine a scenario where your type models historical data that is too large to load into memory at once.","pos":[3293,3397],"source":" Imagine a\nscenario where your type models historical data that is too large\nto load into memory at once."},{"content":"You need to load and unload sections of the collection based on usage.","pos":[3398,3468],"source":" You need to load and unload sections\nof the collection based on usage."},{"content":"The example following models this behavior.","pos":[3469,3512],"source":" The example following models\nthis behavior."},{"content":"It reports on how many data points exist.","pos":[3513,3554]},{"content":"It creates pages to hold sections of the data on demand.","pos":[3555,3611],"source":" It creates\npages to hold sections of the data on demand."},{"content":"It removes pages from memory to make room for pages needed by more recent requests.","pos":[3612,3695],"source":" It removes pages\nfrom memory to make room for pages needed by more recent requests."},{"content":"You can follow this design idiom to model any sort of collection where there are good reasons not to load the entire set of data into an in- memory collection.","pos":[7108,7267],"source":"You can follow this design idiom to model any sort of collection where\nthere are good reasons not to load the entire set of data into an in-\nmemory collection."},{"content":"Notice that the <ph id=\"ph1\">`Page`</ph> class is a private nested class that is not part of the public interface.","pos":[7268,7364],"source":" Notice that the `Page` class is a private nested\nclass that is not part of the public interface."},{"content":"Those details are hidden from any users of this class.","pos":[7365,7419],"source":" Those details are hidden\nfrom any users of this class."},{"pos":[7425,7437],"content":"Dictionaries","linkify":"Dictionaries","nodes":[{"content":"Dictionaries","pos":[0,12]}]},{"content":"Another common scenario is when you need to model a dictionary or a map.","pos":[7439,7511],"source":"Another common scenario is when you need to model a dictionary\nor a map."},{"content":"This scenario is when your type stores values based on key, typically text keys.","pos":[7512,7592],"source":" This scenario is when your type stores values based on key,\ntypically text keys."},{"content":"This example creates a dictionary that maps command line arguments to <bpt id=\"p1\">[</bpt>lambda expressions<ept id=\"p1\">](delegates-overview.md)</ept> that manage those options.","pos":[7593,7733],"source":" This example creates a dictionary that maps command\nline arguments to [lambda expressions](delegates-overview.md) that manage\nthose options."},{"content":"The following example shows two classes: an <ph id=\"ph1\">`ArgsActions`</ph> class that maps a command line option to an <ph id=\"ph2\">`Action`</ph> delegate, and an <ph id=\"ph3\">`ArgsProcessor`</ph> that uses the <ph id=\"ph4\">`ArgsActions`</ph> to execute each <ph id=\"ph5\">`Action`</ph> when it encounters that option.","pos":[7734,7962],"source":" The following example shows two classes: an `ArgsActions`\nclass that maps a command line option to an `Action` delegate, and an\n`ArgsProcessor` that uses the `ArgsActions` to execute each `Action` when\nit encounters that option."},{"content":"In this example, the <ph id=\"ph1\">`ArgsAction`</ph> collection maps closely to the underlying collection.","pos":[8732,8819],"source":"In this example, the `ArgsAction` collection maps closely to the underlying collection."},{"content":"The <ph id=\"ph1\">`get`</ph> determines if a given option has been configured.","pos":[8820,8879],"source":"\nThe `get` determines if a given option has been configured."},{"content":"If so, it returns the <ph id=\"ph1\">`Action`</ph> associated with that option.","pos":[8880,8939],"source":" If so, it returns\nthe `Action` associated with that option."},{"content":"If not, it returns an <ph id=\"ph1\">`Action`</ph> that does nothing.","pos":[8940,8990],"source":" If not, it returns an `Action` that \ndoes nothing."},{"content":"The public accessor does not include a <ph id=\"ph1\">`set`</ph> accessor.","pos":[8991,9045],"source":" The public accessor does not include a `set` accessor."},{"content":"Rather, the design using a public method for setting options.","pos":[9046,9107],"source":" Rather,\nthe design using a public method for setting options."},{"pos":[9113,9135],"content":"Multi-Dimensional Maps","linkify":"Multi-Dimensional Maps","nodes":[{"content":"Multi-Dimensional Maps","pos":[0,22]}]},{"content":"You can create indexers that use multiple arguments.","pos":[9137,9189]},{"content":"In addition, those arguments are not constrained to be the same type.","pos":[9190,9259],"source":" In addition,\nthose arguments are not constrained to be the same type."},{"content":"Let's look at two examples.","pos":[9260,9287],"source":" Let's look at\ntwo examples."},{"content":"The first example shows a class that generates values for a Mandelbrot set.","pos":[9292,9367],"source":"The first example shows a class that generates values for a Mandelbrot\nset."},{"content":"For more information on the mathematics behind the set, read <bpt id=\"p1\">[</bpt>this article<ept id=\"p1\">](https://en.wikipedia.org/wiki/Mandelbrot_set)</ept>.","pos":[9368,9490],"source":" For more information on the mathematics behind the set, read\n[this article](https://en.wikipedia.org/wiki/Mandelbrot_set)."},{"content":"The indexer uses two doubles to define a point in the X, Y plane.","pos":[9491,9557],"source":" \nThe indexer uses two doubles to define a point in the X, Y plane."},{"content":"The get accessor computes the number of iterations until a point is determined to be not in the set.","pos":[9558,9658],"source":"\nThe get accessor computes the number of iterations until a point is\ndetermined to be not in the set."},{"content":"If the maximum iterations is reached, the point is in the set, and the class's maxIterations value is returned.","pos":[9659,9770],"source":" If the maximum iterations is reached, the point\nis in the set, and the class's maxIterations value is returned."},{"content":"(The computer generated images popularized for the Mandelbrot set define colors for the number of iterations necessary to determine that a point is outside the set.","pos":[9771,9935],"source":" (The computer\ngenerated images popularized for the Mandelbrot set define colors for the\nnumber of iterations necessary to determine that a point is outside the set."},{"content":"The Mandelbrot Set defines values at every (x,y) coordinate for real number values.","pos":[10569,10652]},{"content":"That defines a dictionary that could contain an infinite number of values.","pos":[10653,10727],"source":"\nThat defines a dictionary that could contain an infinite number of values."},{"content":"Therefore, there is no storage behind the set.","pos":[10728,10774],"source":" Therefore,\nthere is no storage behind the set."},{"content":"Instead, this class computes the value for each point when code calls the <ph id=\"ph1\">`get`</ph> accessor.","pos":[10775,10864],"source":" Instead, this class computes the value for each\npoint when code calls the `get` accessor."},{"content":"There's no underlying storage used.","pos":[10865,10900]},{"content":"Let's examine one last use of indexers, where the indexer takes multiple arguments of different types.","pos":[10902,11004],"source":"Let's examine one last use of indexers, where the indexer takes multiple arguments\nof different types."},{"content":"Consider a program that manages historical temperature data.","pos":[11005,11065],"source":" Consider a program that manages historical temperature\ndata."},{"content":"This indexer uses a city and a date to set or get the high and low temperatures for that location:","pos":[11066,11165],"source":" This indexer uses a city and a date to set or get the high and low \ntemperatures for that location:"},{"content":"This example creates an indexer that maps weather data on two different arguments: a city (represented by a <ph id=\"ph1\">`string`</ph>) and a date (represented by a <ph id=\"ph2\">`DateTime`</ph>).","pos":[12579,12738],"source":"This example creates an indexer that maps weather data on two different\narguments: a city (represented by a `string`) and a date (represented by\na `DateTime`)."},{"content":"The internal storage uses two <ph id=\"ph1\">`Dictionary`</ph> classes to represent the two-dimensional dictionary.","pos":[12739,12834],"source":" The internal storage uses two `Dictionary` classes to represent\nthe two-dimensional dictionary."},{"content":"The public API no longer represents the underlying storage.","pos":[12835,12894],"source":" The public API no longer represents the\nunderlying storage."},{"content":"Rather, the language features of indexers enables you to create a public interface that represents your abstraction, even though the underlying storage must use different core collection types.","pos":[12895,13088],"source":" Rather, the language features of indexers enables you\nto create a public interface that represents your abstraction, even though\nthe underlying storage must use different core collection types."},{"content":"There are two parts of this code that may be unfamiliar to some developers.","pos":[13090,13165],"source":"There are two parts of this code that may be unfamiliar\nto some developers."},{"content":"These two <ph id=\"ph1\">`using`</ph> statements:","pos":[13166,13195],"source":" These two `using` statements:"},{"content":"create an <bpt id=\"p1\">*</bpt>alias<ept id=\"p1\">*</ept> for a constructed generic type.","pos":[13499,13548],"source":"create an *alias* for a constructed generic type."},{"content":"Those statements enable the code later to use the more descriptive <ph id=\"ph1\">`DateMeasurements`</ph> and <ph id=\"ph2\">`CityDateMeasurements`</ph> names instead of the generic construction of <ph id=\"ph3\">`Dictionary&lt;DateTime, Measurements&gt;`</ph> and <ph id=\"ph4\">`Dictionary&lt;string, Dictionary&lt;DateTime, Measurements&gt; &gt;`</ph>.","pos":[13549,13806],"source":" Those statements enable the\ncode later to use the more descriptive `DateMeasurements` and `CityDateMeasurements`\nnames instead of the generic construction of `Dictionary<DateTime, Measurements>`\nand `Dictionary<string, Dictionary<DateTime, Measurements> >`."},{"content":"This construct does require using the fully qualified type names on the right side of the <ph id=\"ph1\">`=`</ph> sign.","pos":[13807,13907],"source":" \nThis construct does require using the fully qualified type names on the right\nside of the `=` sign."},{"content":"The second technique is to strip off the time portions of any <ph id=\"ph1\">`DateTime`</ph> object used to index into the collections.","pos":[13909,14024],"source":"The second technique is to strip off the time portions of any `DateTime` object\nused to index into the collections."},{"content":"The .NET framework does not include a Date only type.","pos":[14025,14078]},{"content":"Developers use the <ph id=\"ph1\">`DateTime`</ph> type, but use the <ph id=\"ph2\">`Date`</ph> property to ensure that any <ph id=\"ph3\">`DateTime`</ph> object from that day are equal.","pos":[14079,14204],"source":"\nDevelopers use the `DateTime` type, but use the `Date` property to ensure that any\n`DateTime` object from that day are equal."},{"pos":[14209,14219],"content":"Summing Up","linkify":"Summing Up","nodes":[{"content":"Summing Up","pos":[0,10]}]},{"content":"You should create indexers anytime you have a property-like element in your class where that property represents not a single value, but rather a collection of values where each individual item is identified by a set of arguments.","pos":[14221,14451],"source":"You should create indexers anytime you have a property-like element in your\nclass where that property represents not a single value, but rather a collection\nof values where each individual item is identified by a set of arguments."},{"content":"Those arguments can uniquely identify which item in the collection should be referenced.","pos":[14452,14540],"source":" Those\narguments can uniquely identify which item in the collection should be referenced."},{"content":"Indexers extend the concept of <bpt id=\"p1\">[</bpt>properties<ept id=\"p1\">](properties.md)</ept>, where a member is treated like a data item from outside the class, but like a method on the side.","pos":[14541,14698],"source":"\nIndexers extend the concept of [properties](properties.md), where a member is treated\nlike a data item from outside the class, but like a method on the side."},{"content":"Indexers allow arguments to find a single item in a property that represents a set of items.","pos":[14699,14791],"source":" Indexers allow\narguments to find a single item in a property that represents a set of items."}]}