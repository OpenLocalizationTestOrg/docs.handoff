{"content":"---\ntitle: \"How to: Test for Reference Equality (Identity) - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"object identity [C#]\"\n  - \"reference equality [C#]\"\nms.assetid: 91307fda-267b-4fd2-a338-2aada39ee791\n---\n# How to: Test for Reference Equality (Identity) (C# Programming Guide)\nYou do not have to implement any custom logic to support reference equality comparisons in your types. This functionality is provided for all types by the static <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.  \n  \n The following example shows how to determine whether two variables have *reference equality*, which means that they refer to the same object in memory.  \n  \n The example also shows why <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> always returns `false` for value types and why you should not use  <xref:System.Object.ReferenceEquals%2A> to determine string equality.  \n  \n## Example  \n [!code-csharp[csProgGuideObjects#90](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideObjects/CS/Objects.cs#90)]  \n  \n The implementation of `Equals` in the <xref:System.Object?displayProperty=nameWithType> universal base class also performs a reference equality check, but it is best not to use this because, if a class happens to override the method, the results might not be what you expect. The same is true for the `==` and `!=` operators. When they are operating on reference types, the default behavior of `==` and `!=` is to perform a reference equality check. However, derived classes can overload the operator to perform a value equality check. To minimize the potential for error, it is best to always use <xref:System.Object.ReferenceEquals%2A> when you have to determine whether two objects have reference equality.  \n  \n Constant strings within the same assembly are always interned by the runtime. That is, only one instance of each unique literal string is maintained. However, the runtime does not guarantee that strings created at runtime are interned, nor does it guarantee that two equal constant strings in different assemblies are interned.  \n  \n## See also\n\n- [Equality Comparisons](../../../csharp/programming-guide/statements-expressions-operators/equality-comparisons.md)\n","nodes":[{"pos":[4,250],"embed":true,"restype":"x-metadata","content":"title: \"How to: Test for Reference Equality (Identity) - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"object identity [C#]\"\n  - \"reference equality [C#]\"\nms.assetid: 91307fda-267b-4fd2-a338-2aada39ee791","nodes":[{"content":"How to: Test for Reference Equality (Identity) - C# Programming Guide","nodes":[{"pos":[0,69],"content":"How to: Test for Reference Equality (Identity) - C# Programming Guide","nodes":[{"content":"How to: Test for Reference Equality (Identity) - C# Programming Guide","pos":[0,69]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[257,326],"content":"How to: Test for Reference Equality (Identity) (C# Programming Guide)","linkify":"How to: Test for Reference Equality (Identity) (C# Programming Guide)","nodes":[{"content":"How to: Test for Reference Equality (Identity) (C# Programming Guide)","pos":[0,69]}]},{"content":"You do not have to implement any custom logic to support reference equality comparisons in your types.","pos":[327,429]},{"content":"This functionality is provided for all types by the static <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[430,565],"source":" This functionality is provided for all types by the static <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method."},{"pos":[572,723],"content":"The following example shows how to determine whether two variables have <bpt id=\"p1\">*</bpt>reference equality<ept id=\"p1\">*</ept>, which means that they refer to the same object in memory.","source":"The following example shows how to determine whether two variables have *reference equality*, which means that they refer to the same object in memory."},{"pos":[730,962],"content":"The example also shows why <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> always returns <ph id=\"ph2\">`false`</ph> for value types and why you should not use  <ph id=\"ph3\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> to determine string equality.","source":"The example also shows why <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> always returns `false` for value types and why you should not use  <xref:System.Object.ReferenceEquals%2A> to determine string equality."},{"pos":[971,978],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The implementation of <ph id=\"ph1\">`Equals`</ph> in the <ph id=\"ph2\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> universal base class also performs a reference equality check, but it is best not to use this because, if a class happens to override the method, the results might not be what you expect.","pos":[1110,1385],"source":"The implementation of `Equals` in the <xref:System.Object?displayProperty=nameWithType> universal base class also performs a reference equality check, but it is best not to use this because, if a class happens to override the method, the results might not be what you expect."},{"content":"The same is true for the <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph> operators.","pos":[1386,1435],"source":" The same is true for the `==` and `!=` operators."},{"content":"When they are operating on reference types, the default behavior of <ph id=\"ph1\">`==`</ph> and <ph id=\"ph2\">`!=`</ph> is to perform a reference equality check.","pos":[1436,1559],"source":" When they are operating on reference types, the default behavior of `==` and `!=` is to perform a reference equality check."},{"content":"However, derived classes can overload the operator to perform a value equality check.","pos":[1560,1645]},{"content":"To minimize the potential for error, it is best to always use <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> when you have to determine whether two objects have reference equality.","pos":[1646,1819],"source":" To minimize the potential for error, it is best to always use <xref:System.Object.ReferenceEquals%2A> when you have to determine whether two objects have reference equality."},{"content":"Constant strings within the same assembly are always interned by the runtime.","pos":[1826,1903]},{"content":"That is, only one instance of each unique literal string is maintained.","pos":[1904,1975]},{"content":"However, the runtime does not guarantee that strings created at runtime are interned, nor does it guarantee that two equal constant strings in different assemblies are interned.","pos":[1976,2153]},{"pos":[2162,2170],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2174,2288],"content":"<bpt id=\"p1\">[</bpt>Equality Comparisons<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/equality-comparisons.md)</ept>","source":"[Equality Comparisons](../../../csharp/programming-guide/statements-expressions-operators/equality-comparisons.md)"}]}