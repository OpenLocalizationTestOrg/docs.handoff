{"content":"---\ntitle: \"Walkthrough: Emitting Code in Partial Trust Scenarios\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"reflection emit, anonymously hosted dynamic methods\"\n  - \"partial trust, reflection\"\n  - \"partial trust, emitting dynamic methods\"\n  - \"reflection emit, partial trust scenarios\"\n  - \"anonymously hosted dynamic methods [.NET Framework]\"\n  - \"emitting dynamic assemblies,partial trust scenarios\"\n  - \"reflection emit, dynamic methods\"\n  - \"dynamic methods\"\nms.assetid: c45be261-2a9d-4c4e-9bd6-27f0931b7d25\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Walkthrough: Emitting Code in Partial Trust Scenarios\nReflection emit uses the same API set in full or partial trust, but some features require special permissions in partially trusted code. In addition, reflection emit has a feature, anonymously hosted dynamic methods, that is designed to be used with partial trust and by security-transparent assemblies.  \n  \n> [!NOTE]\n>  Before [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)], emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set. Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Such libraries require careful security review because coding errors could result in security holes. The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation. That is, the generated code has no more permissions than the assembly that emits it. This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review.  \n  \n This walkthrough illustrates the following tasks:  \n  \n-   [Setting up a simple sandbox for testing partially trusted code](#Setting_up).  \n  \n    > [!IMPORTANT]\n    >  This is a simple way to experiment with code in partial trust. To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  \n  \n-   [Running code in partially trusted application domains](#Running_code).  \n  \n-   [Using anonymously hosted dynamic methods to emit and execute code in partial trust](#Using_methods).  \n  \n For more information about emitting code in partial trust scenarios, see [Security Issues in Reflection Emit](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).  \n  \n For a complete listing of the code shown in these procedures, see the [Example section](#Example) at the end of this walkthrough.  \n  \n<a name=\"Setting_up\"></a>   \n## Setting up Partially Trusted Locations  \n The following two procedures show how to set up locations from which you can test code with partial trust.  \n  \n-   The first procedure shows how to create a sandboxed application domain in which code is granted Internet permissions.  \n  \n-   The second procedure shows how to add <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag to a partially trusted application domain, to enable access to private data in assemblies of equal or lesser trust.  \n  \n### Creating Sandboxed Application Domains  \n To create an application domain in which your assemblies run with partial trust, you must specify the set of permissions to be granted to the assemblies by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to create the application domain. The easiest way to specify the grant set is to retrieve a named permission set from security policy.  \n  \n The following procedure creates a sandboxed application domain that runs your code with partial trust, to test scenarios in which emitted code can access only public members of public types. A subsequent procedure shows how to add <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>, to test scenarios in which emitted code can access nonpublic types and members in assemblies that are granted equal or lesser permissions.  \n  \n##### To create an application domain with partial trust  \n  \n1.  Create a permission set to grant to the assemblies in the sandboxed application domain. In this case, the permission set of the Internet zone is used.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#2)]\n     [!code-vb[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#2)]  \n  \n2.  Create an <xref:System.AppDomainSetup> object to initialize the application domain with an application path.  \n  \n    > [!IMPORTANT]\n    >  For simplicity, this code example uses the current folder. To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#3)]\n     [!code-vb[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#3)]  \n  \n3.  Create the application domain, specifying the application domain setup information and the grant set for all assemblies that execute in the application domain.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#5)]\n     [!code-vb[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#5)]  \n  \n     The last parameter of the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload enables you to specify a set of assemblies that are to be granted full trust, instead of the grant set of the application domain. You do not have to specify the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies that your application uses, because those assemblies are in the global assembly cache. Assemblies in the global assembly cache are always fully trusted. You can use this parameter to specify strong-named assemblies that are not in the global assembly cache.  \n  \n### Adding RestrictedMemberAccess to Sandboxed Domains  \n Host applications can allow anonymously hosted dynamic methods to have access to private data in assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code. To enable this restricted ability to skip just-in-time (JIT) visibility checks, the host application adds a <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) flag to the grant set.  \n  \n For example, a host might grant Internet applications Internet permissions plus RMA, so that an Internet application can emit code that accesses private data in its own assemblies. Because the access is limited to assemblies of equal or lesser trust, an Internet application cannot access members of fully trusted assemblies such as [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies.  \n  \n> [!NOTE]\n>  To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed. When the method is invoked, the stack information is checked. Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.  \n  \n##### To create an application domain with partial trust plus RMA  \n  \n1.  Create a new <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> (RMA) flag, and use the <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> method to add the permission to the grant set.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#7)]\n     [!code-vb[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#7)]  \n  \n     The <xref:System.Security.PermissionSet.AddPermission%2A> method adds the permission to the grant set if it is not already included. If the permission is already included in the grant set, the specified flags are added to the existing permission.  \n  \n    > [!NOTE]\n    >  RMA is a feature of anonymously hosted dynamic methods. When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.  \n  \n2.  Create the application domain, specifying the application domain setup information and the grant set.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#8)]\n     [!code-vb[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#8)]  \n  \n<a name=\"Running_code\"></a>   \n## Running Code in Sandboxed Application Domains  \n The following procedure explains how to define a class by using methods that can be executed in an application domain, how to create an instance of the class in the domain, and how to execute its methods.  \n  \n#### To define and execute a method in an application domain  \n  \n1.  Define a class that derives from <xref:System.MarshalByRefObject>. This enables you to create instances of the class in other application domains and to make method calls across application domain boundaries. The class in this example is named `Worker`.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#10)]\n     [!code-vb[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#10)]  \n  \n2.  Define a public method that contains the code you want to execute. In this example, the code emits a simple dynamic method, creates a delegate to execute the method, and invokes the delegate.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#11)]\n     [!code-vb[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#11)]  \n  \n3.  In your main program, get the display name of your assembly. This name is used when you create instances of the `Worker` class in the sandboxed application domain.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#14)]\n     [!code-vb[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#14)]  \n  \n4.  In your main program, create a sandboxed application domain, as described in [the first procedure](#Setting_up) in this walkthrough. You do not have to add any permissions to the `Internet` permission set, because the `SimpleEmitDemo` method uses only public methods.  \n  \n5.  In your main program, create an instance of the `Worker` class in the sandboxed application domain.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#12)]\n     [!code-vb[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#12)]  \n  \n     The <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method creates the object in the target application domain and returns a proxy that can be used to call the properties and methods of the object.  \n  \n    > [!NOTE]\n    >  If you use this code in Visual Studio, you must change the name of the class to include the namespace. By default, the namespace is the name of the project. For example, if the project is \"PartialTrust\", the class name must be \"PartialTrust.Worker\".  \n  \n6.  Add code to call the `SimpleEmitDemo` method. The call is marshaled across the application domain boundary, and the code is executed in the sandboxed application domain.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#13)]\n     [!code-vb[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#13)]  \n  \n<a name=\"Using_methods\"></a>   \n## Using Anonymously Hosted Dynamic Methods  \n Anonymously hosted dynamic methods are associated with a transparent assembly that is provided by the system. Therefore, the code they contain is transparent. Ordinary dynamic methods, on the other hand, must be associated with an existing module (whether directly specified or inferred from an associated type), and take their security level from that module.  \n  \n> [!NOTE]\n>  The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure. You cannot explicitly specify a module in the anonymous hosting assembly.  \n  \n Ordinary dynamic methods have access to the internal members of the module they are associated with, or to the private members of the type they are associated with. Because anonymously hosted dynamic methods are isolated from other code, they do not have access to private data. However, they do have a restricted ability to skip JIT visibility checks to gain access to private data. This ability is limited to assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.  \n  \n To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed. When the method is invoked, the stack information is checked. An anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the assembly that emitted it.  \n  \n#### To use anonymously hosted dynamic methods  \n  \n-   Create an anonymously hosted dynamic method by using a constructor that does not specify an associated module or type.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#15)]\n     [!code-vb[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#15)]  \n  \n     If an anonymously hosted dynamic method uses only public types and methods, it does not require restricted member access and does not have to skip JIT visibility checks.  \n  \n     No special permissions are required to emit a dynamic method, but the emitted code requires the permissions that are demanded by the types and methods it uses. For example, if the emitted code calls a method that accesses a file, it requires <xref:System.Security.Permissions.FileIOPermission>. If the trust level does not include that permission, a security exception is thrown when the emitted code is executed. The code shown here emits a dynamic method that uses only the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method. Therefore, the code can be executed from partially trusted locations.  \n  \n-   Alternatively, create an anonymously hosted dynamic method with restricted ability to skip JIT visibility checks, by using the <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor and specifying `true` for the `restrictedSkipVisibility` parameter.  \n  \n     [!code-csharp[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#16)]\n     [!code-vb[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#16)]  \n  \n     The restriction is that the anonymously hosted dynamic method can access private data only in assemblies with trust levels equal to or less than the trust level of the emitting assembly. For example, if the dynamic method is executing with Internet trust, it can access private data in other assemblies that are also executing with Internet trust, but it cannot access private data of [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies. [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies are installed in the global assembly cache and are always fully trusted.  \n  \n     Anonymously hosted dynamic methods can use this restricted ability to skip JIT visibility checks only if the host application grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag. The demand for this permission is made when the method is invoked.  \n  \n    > [!NOTE]\n    >  Call stack information for the emitting assembly is included when the dynamic method is constructed. Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method. This prevents the emitted code from being executed with elevated permissions.  \n  \n     The [complete code example](#Example) at the end of this walkthrough demonstrates the use and limitations of restricted member access. Its `Worker` class includes a method that can create anonymously hosted dynamic methods with or without the restricted ability to skip visibility checks, and the example shows the result of executing this method in application domains that have different trust levels.  \n  \n    > [!NOTE]\n    >  The restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods. When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.  \n  \n<a name=\"Example\"></a>   \n## Example  \n  \n### Description  \n The following code example demonstrates the use of the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag to allow anonymously hosted dynamic methods to skip JIT visibility checks, but only when the target member is at an equal or lower level of trust than the assembly that emits the code.  \n  \n The example defines a `Worker` class that can be marshaled across application domain boundaries. The class has two `AccessPrivateMethod` method overloads that emit and execute dynamic methods. The first overload emits a dynamic method that calls the private `PrivateMethod` method of the `Worker` class, and it can emit the dynamic method with or without JIT visibility checks. The second overload emits a dynamic method that accesses an `internal` property (`Friend` property in Visual Basic) of the <xref:System.String> class.  \n  \n The example uses a helper method to create a grant set limited to `Internet` permissions, and then creates an application domain, using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to specify that all code that executes in the domain uses this grant set. The example creates an instance of the `Worker` class in the application domain, and executes the `AccessPrivateMethod` method two times.  \n  \n-   The first time the `AccessPrivateMethod` method is executed, JIT visibility checks are enforced. The dynamic method fails when it is invoked, because JIT visibility checks prevent it from accessing the private method.  \n  \n-   The second time the `AccessPrivateMethod` method is executed, JIT visibility checks are skipped. The dynamic method fails when it is compiled, because the `Internet` grant set does not grant sufficient permissions to skip visibility checks.  \n  \n The example adds <xref:System.Security.Permissions.ReflectionPermission> with <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> to the grant set. The example then creates a second domain, specifying that all code that executes in the domain is granted the permissions in the new grant set. The example creates an instance of the `Worker` class in the new application domain, and executes both overloads of the `AccessPrivateMethod` method.  \n  \n-   The first overload of the `AccessPrivateMethod` method is executed, and JIT visibility checks are skipped. The dynamic method compiles and executes successfully, because the assembly that emits the code is the same as the assembly that contains the private method. Therefore, the trust levels are equal. If the application that contains the `Worker` class had several assemblies, the same process would succeed for any one of those assemblies, because they would all be at the same trust level.  \n  \n-   The second overload of the `AccessPrivateMethod` method is executed, and again JIT visibility checks are skipped. This time the dynamic method fails when it is compiled, because it tries to access the `internal` `FirstChar` property of the <xref:System.String> class. The assembly that contains the <xref:System.String> class is fully trusted. Therefore, it is at a higher level of trust than the assembly that emits the code.  \n  \n This comparison shows how <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> enables partially trusted code to skip visibility checks for other partially trusted code without compromising the security of trusted code.  \n  \n### Code  \n [!code-csharp[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#1)]\n [!code-vb[HowToEmitCodeInPartialTrust#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#1)]  \n  \n## Compiling the Code  \n  \n-   If you build this code example in Visual Studio, you must change the name of the class to include the namespace when you pass it to the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method. By default, the namespace is the name of the project. For example, if the project is \"PartialTrust\", the class name must be \"PartialTrust.Worker\".  \n  \n## See also\n\n- [Security Issues in Reflection Emit](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)\n- [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)\n","nodes":[{"pos":[4,593],"embed":true,"restype":"x-metadata","content":"title: \"Walkthrough: Emitting Code in Partial Trust Scenarios\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"reflection emit, anonymously hosted dynamic methods\"\n  - \"partial trust, reflection\"\n  - \"partial trust, emitting dynamic methods\"\n  - \"reflection emit, partial trust scenarios\"\n  - \"anonymously hosted dynamic methods [.NET Framework]\"\n  - \"emitting dynamic assemblies,partial trust scenarios\"\n  - \"reflection emit, dynamic methods\"\n  - \"dynamic methods\"\nms.assetid: c45be261-2a9d-4c4e-9bd6-27f0931b7d25\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Walkthrough: Emitting Code in Partial Trust Scenarios","nodes":[{"pos":[0,53],"content":"Walkthrough: Emitting Code in Partial Trust Scenarios","nodes":[{"content":"Walkthrough: Emitting Code in Partial Trust Scenarios","pos":[0,53]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[600,653],"content":"Walkthrough: Emitting Code in Partial Trust Scenarios","linkify":"Walkthrough: Emitting Code in Partial Trust Scenarios","nodes":[{"content":"Walkthrough: Emitting Code in Partial Trust Scenarios","pos":[0,53]}]},{"content":"Reflection emit uses the same API set in full or partial trust, but some features require special permissions in partially trusted code.","pos":[654,790]},{"content":"In addition, reflection emit has a feature, anonymously hosted dynamic methods, that is designed to be used with partial trust and by security-transparent assemblies.","pos":[791,957]},{"pos":[965,2336],"content":"[!NOTE]\n Before [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)], emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set. Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Such libraries require careful security review because coding errors could result in security holes. The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation. That is, the generated code has no more permissions than the assembly that emits it. This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review.","leadings":["","> "],"nodes":[{"content":"Before [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)], emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set. Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Such libraries require careful security review because coding errors could result in security holes. The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation. That is, the generated code has no more permissions than the assembly that emits it. This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review.","pos":[9,1369],"nodes":[{"content":"Before <ph id=\"ph1\">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph>, emitting code required <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.","pos":[0,268],"source":"Before [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)], emitting code required <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag."},{"content":"This permission is included by default in the <ph id=\"ph1\">`FullTrust`</ph> and <ph id=\"ph2\">`Intranet`</ph> named permission sets, but not in the <ph id=\"ph3\">`Internet`</ph> permission set.","pos":[269,406],"source":" This permission is included by default in the `FullTrust` and `Intranet` named permission sets, but not in the `Internet` permission set."},{"content":"Therefore, a library could be used from partial trust only if it had the <ph id=\"ph1\">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute and also executed an <ph id=\"ph2\">&lt;xref:System.Security.PermissionSet.Assert%2A&gt;</ph> method for <ph id=\"ph3\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>.","pos":[407,693],"source":" Therefore, a library could be used from partial trust only if it had the <xref:System.Security.SecurityCriticalAttribute> attribute and also executed an <xref:System.Security.PermissionSet.Assert%2A> method for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>."},{"content":"Such libraries require careful security review because coding errors could result in security holes.","pos":[694,794]},{"content":"The <ph id=\"ph1\">[!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)]</ph> allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.","pos":[795,1020],"source":" The [!INCLUDE[net_v35_short](../../../includes/net-v35-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation."},{"content":"That is, the generated code has no more permissions than the assembly that emits it.","pos":[1021,1105]},{"content":"This enables libraries that emit code to be security-transparent and removes the need to assert <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit&gt;</ph>, so that writing a secure library does not require such a thorough security review.","pos":[1106,1360],"source":" This enables libraries that emit code to be security-transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, so that writing a secure library does not require such a thorough security review."}]}]},{"content":"This walkthrough illustrates the following tasks:","pos":[2343,2392]},{"pos":[2402,2480],"content":"<bpt id=\"p1\">[</bpt>Setting up a simple sandbox for testing partially trusted code<ept id=\"p1\">](#Setting_up)</ept>.","source":"[Setting up a simple sandbox for testing partially trusted code](#Setting_up)."},{"pos":[2492,2767],"content":"[!IMPORTANT]\nThis is a simple way to experiment with code in partial trust. To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).","leadings":["","    >  "],"nodes":[{"content":"This is a simple way to experiment with code in partial trust. To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).","pos":[13,268],"nodes":[{"content":"This is a simple way to experiment with code in partial trust.","pos":[0,62]},{"content":"To run code that actually comes from untrusted locations, see <bpt id=\"p1\">[</bpt>How to: Run Partially Trusted Code in a Sandbox<ept id=\"p1\">](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)</ept>.","pos":[63,255],"source":" To run code that actually comes from untrusted locations, see [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)."}]}]},{"pos":[2777,2848],"content":"<bpt id=\"p1\">[</bpt>Running code in partially trusted application domains<ept id=\"p1\">](#Running_code)</ept>.","source":"[Running code in partially trusted application domains](#Running_code)."},{"pos":[2858,2959],"content":"<bpt id=\"p1\">[</bpt>Using anonymously hosted dynamic methods to emit and execute code in partial trust<ept id=\"p1\">](#Using_methods)</ept>.","source":"[Using anonymously hosted dynamic methods to emit and execute code in partial trust](#Using_methods)."},{"pos":[2966,3162],"content":"For more information about emitting code in partial trust scenarios, see <bpt id=\"p1\">[</bpt>Security Issues in Reflection Emit<ept id=\"p1\">](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.","source":"For more information about emitting code in partial trust scenarios, see [Security Issues in Reflection Emit](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)."},{"pos":[3169,3298],"content":"For a complete listing of the code shown in these procedures, see the <bpt id=\"p1\">[</bpt>Example section<ept id=\"p1\">](#Example)</ept> at the end of this walkthrough.","source":"For a complete listing of the code shown in these procedures, see the [Example section](#Example) at the end of this walkthrough."},{"pos":[3336,3374],"content":"Setting up Partially Trusted Locations","linkify":"Setting up Partially Trusted Locations","nodes":[{"content":"Setting up Partially Trusted Locations","pos":[0,38]}]},{"content":"The following two procedures show how to set up locations from which you can test code with partial trust.","pos":[3378,3484]},{"content":"The first procedure shows how to create a sandboxed application domain in which code is granted Internet permissions.","pos":[3494,3611]},{"pos":[3621,3956],"content":"The second procedure shows how to add <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag to a partially trusted application domain, to enable access to private data in assemblies of equal or lesser trust.","source":"The second procedure shows how to add <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag to a partially trusted application domain, to enable access to private data in assemblies of equal or lesser trust."},{"pos":[3966,4004],"content":"Creating Sandboxed Application Domains","linkify":"Creating Sandboxed Application Domains","nodes":[{"content":"Creating Sandboxed Application Domains","pos":[0,38]}]},{"content":"To create an application domain in which your assemblies run with partial trust, you must specify the set of permissions to be granted to the assemblies by using the <ph id=\"ph1\">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload to create the application domain.","pos":[4008,4440],"source":"To create an application domain in which your assemblies run with partial trust, you must specify the set of permissions to be granted to the assemblies by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to create the application domain."},{"content":"The easiest way to specify the grant set is to retrieve a named permission set from security policy.","pos":[4441,4541]},{"content":"The following procedure creates a sandboxed application domain that runs your code with partial trust, to test scenarios in which emitted code can access only public members of public types.","pos":[4548,4738]},{"content":"A subsequent procedure shows how to add <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph>, to test scenarios in which emitted code can access nonpublic types and members in assemblies that are granted equal or lesser permissions.","pos":[4739,5001],"source":" A subsequent procedure shows how to add <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>, to test scenarios in which emitted code can access nonpublic types and members in assemblies that are granted equal or lesser permissions."},{"pos":[5013,5063],"content":"To create an application domain with partial trust","linkify":"To create an application domain with partial trust","nodes":[{"content":"To create an application domain with partial trust","pos":[0,50]}]},{"content":"Create a permission set to grant to the assemblies in the sandboxed application domain.","pos":[5073,5160]},{"content":"In this case, the permission set of the Internet zone is used.","pos":[5161,5223]},{"pos":[5234,5517],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#2)]\n [!code-vb[HowToEmitCodeInPartialTrust#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#2)]","leadings":["","    "],"nodes":[]},{"pos":[5527,5635],"content":"Create an <ph id=\"ph1\">&lt;xref:System.AppDomainSetup&gt;</ph> object to initialize the application domain with an application path.","source":"Create an <xref:System.AppDomainSetup> object to initialize the application domain with an application path."},{"pos":[5647,5969],"content":"[!IMPORTANT]\nFor simplicity, this code example uses the current folder. To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).","leadings":["","    >  "],"nodes":[{"content":"For simplicity, this code example uses the current folder. To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).","pos":[13,315],"nodes":[{"content":"For simplicity, this code example uses the current folder.","pos":[0,58]},{"content":"To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in <bpt id=\"p1\">[</bpt>How to: Run Partially Trusted Code in a Sandbox<ept id=\"p1\">](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)</ept>.","pos":[59,302],"source":" To run code that actually comes from the Internet, use a separate folder for the untrusted code, as described in [How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)."}]}]},{"pos":[5980,6263],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#3)]\n [!code-vb[HowToEmitCodeInPartialTrust#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#3)]","leadings":["","    "],"nodes":[]},{"content":"Create the application domain, specifying the application domain setup information and the grant set for all assemblies that execute in the application domain.","pos":[6273,6432]},{"pos":[6443,6726],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#5)]\n [!code-vb[HowToEmitCodeInPartialTrust#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#5)]","leadings":["","    "],"nodes":[]},{"content":"The last parameter of the <ph id=\"ph1\">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload enables you to specify a set of assemblies that are to be granted full trust, instead of the grant set of the application domain.","pos":[6737,7125],"source":"The last parameter of the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload enables you to specify a set of assemblies that are to be granted full trust, instead of the grant set of the application domain."},{"content":"You do not have to specify the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> assemblies that your application uses, because those assemblies are in the global assembly cache.","pos":[7126,7315],"source":" You do not have to specify the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies that your application uses, because those assemblies are in the global assembly cache."},{"content":"Assemblies in the global assembly cache are always fully trusted.","pos":[7316,7381]},{"content":"You can use this parameter to specify strong-named assemblies that are not in the global assembly cache.","pos":[7382,7486]},{"pos":[7496,7546],"content":"Adding RestrictedMemberAccess to Sandboxed Domains","linkify":"Adding RestrictedMemberAccess to Sandboxed Domains","nodes":[{"content":"Adding RestrictedMemberAccess to Sandboxed Domains","pos":[0,50]}]},{"content":"Host applications can allow anonymously hosted dynamic methods to have access to private data in assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.","pos":[7550,7755]},{"content":"To enable this restricted ability to skip just-in-time (JIT) visibility checks, the host application adds a <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> object with the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> (RMA) flag to the grant set.","pos":[7756,8076],"source":" To enable this restricted ability to skip just-in-time (JIT) visibility checks, the host application adds a <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> (RMA) flag to the grant set."},{"content":"For example, a host might grant Internet applications Internet permissions plus RMA, so that an Internet application can emit code that accesses private data in its own assemblies.","pos":[8083,8263]},{"content":"Because the access is limited to assemblies of equal or lesser trust, an Internet application cannot access members of fully trusted assemblies such as <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> assemblies.","pos":[8264,8488],"source":" Because the access is limited to assemblies of equal or lesser trust, an Internet application cannot access members of fully trusted assemblies such as [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies."},{"pos":[8496,8861],"content":"[!NOTE]\n To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed. When the method is invoked, the stack information is checked. Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.","leadings":["","> "],"nodes":[{"content":"To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed. When the method is invoked, the stack information is checked. Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.","pos":[9,363],"nodes":[{"content":"To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.","pos":[0,147]},{"content":"When the method is invoked, the stack information is checked.","pos":[148,209]},{"content":"Thus, an anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the emitting assembly.","pos":[210,354]}]}]},{"pos":[8873,8932],"content":"To create an application domain with partial trust plus RMA","linkify":"To create an application domain with partial trust plus RMA","nodes":[{"content":"To create an application domain with partial trust plus RMA","pos":[0,59]}]},{"pos":[8942,9263],"content":"Create a new <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> object with the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> (RMA) flag, and use the <ph id=\"ph3\">&lt;xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType&gt;</ph> method to add the permission to the grant set.","source":"Create a new <xref:System.Security.Permissions.ReflectionPermission> object with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> (RMA) flag, and use the <xref:System.Security.PermissionSet.SetPermission%2A?displayProperty=nameWithType> method to add the permission to the grant set."},{"pos":[9274,9557],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#7)]\n [!code-vb[HowToEmitCodeInPartialTrust#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#7)]","leadings":["","    "],"nodes":[]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Security.PermissionSet.AddPermission%2A&gt;</ph> method adds the permission to the grant set if it is not already included.","pos":[9568,9700],"source":"The <xref:System.Security.PermissionSet.AddPermission%2A> method adds the permission to the grant set if it is not already included."},{"content":"If the permission is already included in the grant set, the specified flags are added to the existing permission.","pos":[9701,9814]},{"pos":[9826,9992],"content":"[!NOTE]\nRMA is a feature of anonymously hosted dynamic methods. When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.","leadings":["","    >  "],"nodes":[{"content":"RMA is a feature of anonymously hosted dynamic methods. When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.","pos":[8,159],"nodes":[{"content":"RMA is a feature of anonymously hosted dynamic methods.","pos":[0,55]},{"content":"When ordinary dynamic methods skip JIT visibility checks, the emitted code requires full trust.","pos":[56,151]}]}]},{"content":"Create the application domain, specifying the application domain setup information and the grant set.","pos":[10002,10103]},{"pos":[10114,10397],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#8)]\n [!code-vb[HowToEmitCodeInPartialTrust#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#8)]","leadings":["","    "],"nodes":[]},{"pos":[10437,10482],"content":"Running Code in Sandboxed Application Domains","linkify":"Running Code in Sandboxed Application Domains","nodes":[{"content":"Running Code in Sandboxed Application Domains","pos":[0,45]}]},{"content":"The following procedure explains how to define a class by using methods that can be executed in an application domain, how to create an instance of the class in the domain, and how to execute its methods.","pos":[10486,10690]},{"pos":[10701,10756],"content":"To define and execute a method in an application domain","linkify":"To define and execute a method in an application domain","nodes":[{"content":"To define and execute a method in an application domain","pos":[0,55]}]},{"content":"Define a class that derives from <ph id=\"ph1\">&lt;xref:System.MarshalByRefObject&gt;</ph>.","pos":[10766,10832],"source":"Define a class that derives from <xref:System.MarshalByRefObject>."},{"content":"This enables you to create instances of the class in other application domains and to make method calls across application domain boundaries.","pos":[10833,10974]},{"content":"The class in this example is named <ph id=\"ph1\">`Worker`</ph>.","pos":[10975,11019],"source":" The class in this example is named `Worker`."},{"pos":[11030,11317],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#10)]\n [!code-vb[HowToEmitCodeInPartialTrust#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#10)]","leadings":["","    "],"nodes":[]},{"content":"Define a public method that contains the code you want to execute.","pos":[11327,11393]},{"content":"In this example, the code emits a simple dynamic method, creates a delegate to execute the method, and invokes the delegate.","pos":[11394,11518]},{"pos":[11529,11816],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#11)]\n [!code-vb[HowToEmitCodeInPartialTrust#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#11)]","leadings":["","    "],"nodes":[]},{"content":"In your main program, get the display name of your assembly.","pos":[11826,11886]},{"content":"This name is used when you create instances of the <ph id=\"ph1\">`Worker`</ph> class in the sandboxed application domain.","pos":[11887,11989],"source":" This name is used when you create instances of the `Worker` class in the sandboxed application domain."},{"pos":[12000,12287],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#14)]\n [!code-vb[HowToEmitCodeInPartialTrust#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#14)]","leadings":["","    "],"nodes":[]},{"content":"In your main program, create a sandboxed application domain, as described in <bpt id=\"p1\">[</bpt>the first procedure<ept id=\"p1\">](#Setting_up)</ept> in this walkthrough.","pos":[12297,12429],"source":"In your main program, create a sandboxed application domain, as described in [the first procedure](#Setting_up) in this walkthrough."},{"content":"You do not have to add any permissions to the <ph id=\"ph1\">`Internet`</ph> permission set, because the <ph id=\"ph2\">`SimpleEmitDemo`</ph> method uses only public methods.","pos":[12430,12564],"source":" You do not have to add any permissions to the `Internet` permission set, because the `SimpleEmitDemo` method uses only public methods."},{"pos":[12574,12673],"content":"In your main program, create an instance of the <ph id=\"ph1\">`Worker`</ph> class in the sandboxed application domain.","source":"In your main program, create an instance of the `Worker` class in the sandboxed application domain."},{"pos":[12684,12971],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#12)]\n [!code-vb[HowToEmitCodeInPartialTrust#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#12)]","leadings":["","    "],"nodes":[]},{"pos":[12982,13182],"content":"The <ph id=\"ph1\">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph> method creates the object in the target application domain and returns a proxy that can be used to call the properties and methods of the object.","source":"The <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method creates the object in the target application domain and returns a proxy that can be used to call the properties and methods of the object."},{"pos":[13194,13458],"content":"[!NOTE]\nIf you use this code in Visual Studio, you must change the name of the class to include the namespace. By default, the namespace is the name of the project. For example, if the project is \"PartialTrust\", the class name must be \"PartialTrust.Worker\".","leadings":["","    >  "],"nodes":[{"content":"If you use this code in Visual Studio, you must change the name of the class to include the namespace. By default, the namespace is the name of the project. For example, if the project is \"PartialTrust\", the class name must be \"PartialTrust.Worker\".","pos":[8,257],"nodes":[{"content":"If you use this code in Visual Studio, you must change the name of the class to include the namespace.","pos":[0,102]},{"content":"By default, the namespace is the name of the project.","pos":[103,156]},{"content":"For example, if the project is \"PartialTrust\", the class name must be \"PartialTrust.Worker\".","pos":[157,249]}]}]},{"content":"Add code to call the <ph id=\"ph1\">`SimpleEmitDemo`</ph> method.","pos":[13468,13513],"source":"Add code to call the `SimpleEmitDemo` method."},{"content":"The call is marshaled across the application domain boundary, and the code is executed in the sandboxed application domain.","pos":[13514,13637]},{"pos":[13648,13935],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#13)]\n [!code-vb[HowToEmitCodeInPartialTrust#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#13)]","leadings":["","    "],"nodes":[]},{"pos":[13976,14016],"content":"Using Anonymously Hosted Dynamic Methods","linkify":"Using Anonymously Hosted Dynamic Methods","nodes":[{"content":"Using Anonymously Hosted Dynamic Methods","pos":[0,40]}]},{"content":"Anonymously hosted dynamic methods are associated with a transparent assembly that is provided by the system.","pos":[14020,14129]},{"content":"Therefore, the code they contain is transparent.","pos":[14130,14178]},{"content":"Ordinary dynamic methods, on the other hand, must be associated with an existing module (whether directly specified or inferred from an associated type), and take their security level from that module.","pos":[14179,14380]},{"pos":[14388,14639],"content":"[!NOTE]\n The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure. You cannot explicitly specify a module in the anonymous hosting assembly.","leadings":["","> "],"nodes":[{"content":"The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure. You cannot explicitly specify a module in the anonymous hosting assembly.","pos":[9,249],"nodes":[{"content":"The only way to associate a dynamic method with the assembly that provides anonymous hosting is to use the constructors that are described in the following procedure.","pos":[0,166]},{"content":"You cannot explicitly specify a module in the anonymous hosting assembly.","pos":[167,240]}]}]},{"content":"Ordinary dynamic methods have access to the internal members of the module they are associated with, or to the private members of the type they are associated with.","pos":[14646,14810]},{"content":"Because anonymously hosted dynamic methods are isolated from other code, they do not have access to private data.","pos":[14811,14924]},{"content":"However, they do have a restricted ability to skip JIT visibility checks to gain access to private data.","pos":[14925,15029]},{"content":"This ability is limited to assemblies that have trust levels equal to or less than the trust level of the assembly that emits the code.","pos":[15030,15165]},{"content":"To prevent elevation of privilege, stack information for the emitting assembly is included when anonymously hosted dynamic methods are constructed.","pos":[15172,15319]},{"content":"When the method is invoked, the stack information is checked.","pos":[15320,15381]},{"content":"An anonymously hosted dynamic method that is invoked from fully trusted code is still limited to the trust level of the assembly that emitted it.","pos":[15382,15527]},{"pos":[15538,15579],"content":"To use anonymously hosted dynamic methods","linkify":"To use anonymously hosted dynamic methods","nodes":[{"content":"To use anonymously hosted dynamic methods","pos":[0,41]}]},{"content":"Create an anonymously hosted dynamic method by using a constructor that does not specify an associated module or type.","pos":[15589,15707]},{"pos":[15718,16005],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#15)]\n [!code-vb[HowToEmitCodeInPartialTrust#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#15)]","leadings":["","    "],"nodes":[]},{"content":"If an anonymously hosted dynamic method uses only public types and methods, it does not require restricted member access and does not have to skip JIT visibility checks.","pos":[16016,16185]},{"content":"No special permissions are required to emit a dynamic method, but the emitted code requires the permissions that are demanded by the types and methods it uses.","pos":[16196,16355]},{"content":"For example, if the emitted code calls a method that accesses a file, it requires <ph id=\"ph1\">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>.","pos":[16356,16490],"source":" For example, if the emitted code calls a method that accesses a file, it requires <xref:System.Security.Permissions.FileIOPermission>."},{"content":"If the trust level does not include that permission, a security exception is thrown when the emitted code is executed.","pos":[16491,16609]},{"content":"The code shown here emits a dynamic method that uses only the <ph id=\"ph1\">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[16610,16743],"source":" The code shown here emits a dynamic method that uses only the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method."},{"content":"Therefore, the code can be executed from partially trusted locations.","pos":[16744,16813]},{"pos":[16823,17151],"content":"Alternatively, create an anonymously hosted dynamic method with restricted ability to skip JIT visibility checks, by using the <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29&gt;</ph> constructor and specifying <ph id=\"ph2\">`true`</ph> for the <ph id=\"ph3\">`restrictedSkipVisibility`</ph> parameter.","source":"Alternatively, create an anonymously hosted dynamic method with restricted ability to skip JIT visibility checks, by using the <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> constructor and specifying `true` for the `restrictedSkipVisibility` parameter."},{"pos":[17162,17449],"content":"[!code-csharp[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/cs/source.cs#16)]\n [!code-vb[HowToEmitCodeInPartialTrust#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToEmitCodeInPartialTrust/vb/source.vb#16)]","leadings":["","    "],"nodes":[]},{"content":"The restriction is that the anonymously hosted dynamic method can access private data only in assemblies with trust levels equal to or less than the trust level of the emitting assembly.","pos":[17460,17646]},{"content":"For example, if the dynamic method is executing with Internet trust, it can access private data in other assemblies that are also executing with Internet trust, but it cannot access private data of <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> assemblies.","pos":[17647,17917],"source":" For example, if the dynamic method is executing with Internet trust, it can access private data in other assemblies that are also executing with Internet trust, but it cannot access private data of [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies."},{"content":"<ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)]</ph> assemblies are installed in the global assembly cache and are always fully trusted.","pos":[17918,18062],"source":"[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] assemblies are installed in the global assembly cache and are always fully trusted."},{"content":"Anonymously hosted dynamic methods can use this restricted ability to skip JIT visibility checks only if the host application grants <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag.","pos":[18073,18388],"source":"Anonymously hosted dynamic methods can use this restricted ability to skip JIT visibility checks only if the host application grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag."},{"content":"The demand for this permission is made when the method is invoked.","pos":[18389,18455]},{"pos":[18467,18788],"content":"[!NOTE]\nCall stack information for the emitting assembly is included when the dynamic method is constructed. Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method. This prevents the emitted code from being executed with elevated permissions.","leadings":["","    >  "],"nodes":[{"content":"Call stack information for the emitting assembly is included when the dynamic method is constructed. Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method. This prevents the emitted code from being executed with elevated permissions.","pos":[8,314],"nodes":[{"content":"Call stack information for the emitting assembly is included when the dynamic method is constructed.","pos":[0,100]},{"content":"Therefore, the demand is made against the permissions of the emitting assembly instead of the assembly that invokes the method.","pos":[101,228]},{"content":"This prevents the emitted code from being executed with elevated permissions.","pos":[229,306]}]}]},{"content":"The <bpt id=\"p1\">[</bpt>complete code example<ept id=\"p1\">](#Example)</ept> at the end of this walkthrough demonstrates the use and limitations of restricted member access.","pos":[18799,18933],"source":"The [complete code example](#Example) at the end of this walkthrough demonstrates the use and limitations of restricted member access."},{"content":"Its <ph id=\"ph1\">`Worker`</ph> class includes a method that can create anonymously hosted dynamic methods with or without the restricted ability to skip visibility checks, and the example shows the result of executing this method in application domains that have different trust levels.","pos":[18934,19202],"source":" Its `Worker` class includes a method that can create anonymously hosted dynamic methods with or without the restricted ability to skip visibility checks, and the example shows the result of executing this method in application domains that have different trust levels."},{"pos":[19214,19420],"content":"[!NOTE]\nThe restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods. When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.","leadings":["","    >  "],"nodes":[{"content":"The restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods. When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.","pos":[8,199],"nodes":[{"content":"The restricted ability to skip visibility checks is a feature of anonymously hosted dynamic methods.","pos":[0,100]},{"content":"When ordinary dynamic methods skip JIT visibility checks, they must be granted full trust.","pos":[101,191]}]}]},{"pos":[19455,19462],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[19472,19483],"content":"Description","linkify":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[19487,19814],"content":"The following code example demonstrates the use of the <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess&gt;</ph> flag to allow anonymously hosted dynamic methods to skip JIT visibility checks, but only when the target member is at an equal or lower level of trust than the assembly that emits the code.","source":"The following code example demonstrates the use of the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> flag to allow anonymously hosted dynamic methods to skip JIT visibility checks, but only when the target member is at an equal or lower level of trust than the assembly that emits the code."},{"content":"The example defines a <ph id=\"ph1\">`Worker`</ph> class that can be marshaled across application domain boundaries.","pos":[19821,19917],"source":"The example defines a `Worker` class that can be marshaled across application domain boundaries."},{"content":"The class has two <ph id=\"ph1\">`AccessPrivateMethod`</ph> method overloads that emit and execute dynamic methods.","pos":[19918,20013],"source":" The class has two `AccessPrivateMethod` method overloads that emit and execute dynamic methods."},{"content":"The first overload emits a dynamic method that calls the private <ph id=\"ph1\">`PrivateMethod`</ph> method of the <ph id=\"ph2\">`Worker`</ph> class, and it can emit the dynamic method with or without JIT visibility checks.","pos":[20014,20198],"source":" The first overload emits a dynamic method that calls the private `PrivateMethod` method of the `Worker` class, and it can emit the dynamic method with or without JIT visibility checks."},{"content":"The second overload emits a dynamic method that accesses an <ph id=\"ph1\">`internal`</ph> property (<ph id=\"ph2\">`Friend`</ph> property in Visual Basic) of the <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> class.","pos":[20199,20349],"source":" The second overload emits a dynamic method that accesses an `internal` property (`Friend` property in Visual Basic) of the <xref:System.String> class."},{"content":"The example uses a helper method to create a grant set limited to <ph id=\"ph1\">`Internet`</ph> permissions, and then creates an application domain, using the <ph id=\"ph2\">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload to specify that all code that executes in the domain uses this grant set.","pos":[20356,20802],"source":"The example uses a helper method to create a grant set limited to `Internet` permissions, and then creates an application domain, using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload to specify that all code that executes in the domain uses this grant set."},{"content":"The example creates an instance of the <ph id=\"ph1\">`Worker`</ph> class in the application domain, and executes the <ph id=\"ph2\">`AccessPrivateMethod`</ph> method two times.","pos":[20803,20940],"source":" The example creates an instance of the `Worker` class in the application domain, and executes the `AccessPrivateMethod` method two times."},{"content":"The first time the <ph id=\"ph1\">`AccessPrivateMethod`</ph> method is executed, JIT visibility checks are enforced.","pos":[20950,21046],"source":"The first time the `AccessPrivateMethod` method is executed, JIT visibility checks are enforced."},{"content":"The dynamic method fails when it is invoked, because JIT visibility checks prevent it from accessing the private method.","pos":[21047,21167]},{"content":"The second time the <ph id=\"ph1\">`AccessPrivateMethod`</ph> method is executed, JIT visibility checks are skipped.","pos":[21177,21273],"source":"The second time the `AccessPrivateMethod` method is executed, JIT visibility checks are skipped."},{"content":"The dynamic method fails when it is compiled, because the <ph id=\"ph1\">`Internet`</ph> grant set does not grant sufficient permissions to skip visibility checks.","pos":[21274,21417],"source":" The dynamic method fails when it is compiled, because the `Internet` grant set does not grant sufficient permissions to skip visibility checks."},{"content":"The example adds <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> to the grant set.","pos":[21424,21631],"source":"The example adds <xref:System.Security.Permissions.ReflectionPermission> with <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> to the grant set."},{"content":"The example then creates a second domain, specifying that all code that executes in the domain is granted the permissions in the new grant set.","pos":[21632,21775]},{"content":"The example creates an instance of the <ph id=\"ph1\">`Worker`</ph> class in the new application domain, and executes both overloads of the <ph id=\"ph2\">`AccessPrivateMethod`</ph> method.","pos":[21776,21925],"source":" The example creates an instance of the `Worker` class in the new application domain, and executes both overloads of the `AccessPrivateMethod` method."},{"content":"The first overload of the <ph id=\"ph1\">`AccessPrivateMethod`</ph> method is executed, and JIT visibility checks are skipped.","pos":[21935,22041],"source":"The first overload of the `AccessPrivateMethod` method is executed, and JIT visibility checks are skipped."},{"content":"The dynamic method compiles and executes successfully, because the assembly that emits the code is the same as the assembly that contains the private method.","pos":[22042,22199]},{"content":"Therefore, the trust levels are equal.","pos":[22200,22238]},{"content":"If the application that contains the <ph id=\"ph1\">`Worker`</ph> class had several assemblies, the same process would succeed for any one of those assemblies, because they would all be at the same trust level.","pos":[22239,22429],"source":" If the application that contains the `Worker` class had several assemblies, the same process would succeed for any one of those assemblies, because they would all be at the same trust level."},{"content":"The second overload of the <ph id=\"ph1\">`AccessPrivateMethod`</ph> method is executed, and again JIT visibility checks are skipped.","pos":[22439,22552],"source":"The second overload of the `AccessPrivateMethod` method is executed, and again JIT visibility checks are skipped."},{"content":"This time the dynamic method fails when it is compiled, because it tries to access the <ph id=\"ph1\">`internal`</ph> <ph id=\"ph2\">`FirstChar`</ph> property of the <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> class.","pos":[22553,22706],"source":" This time the dynamic method fails when it is compiled, because it tries to access the `internal` `FirstChar` property of the <xref:System.String> class."},{"content":"The assembly that contains the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class is fully trusted.","pos":[22707,22782],"source":" The assembly that contains the <xref:System.String> class is fully trusted."},{"content":"Therefore, it is at a higher level of trust than the assembly that emits the code.","pos":[22783,22865]},{"pos":[22872,23150],"content":"This comparison shows how <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> enables partially trusted code to skip visibility checks for other partially trusted code without compromising the security of trusted code.","source":"This comparison shows how <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> enables partially trusted code to skip visibility checks for other partially trusted code without compromising the security of trusted code."},{"pos":[23160,23164],"content":"Code","linkify":"Code","nodes":[{"content":"Code","pos":[0,4]}]},{"pos":[23456,23474],"content":"Compiling the Code","linkify":"Compiling the Code","nodes":[{"content":"Compiling the Code","pos":[0,18]}]},{"content":"If you build this code example in Visual Studio, you must change the name of the class to include the namespace when you pass it to the <ph id=\"ph1\">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph> method.","pos":[23484,23678],"source":"If you build this code example in Visual Studio, you must change the name of the class to include the namespace when you pass it to the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> method."},{"content":"By default, the namespace is the name of the project.","pos":[23679,23732]},{"content":"For example, if the project is \"PartialTrust\", the class name must be \"PartialTrust.Worker\".","pos":[23733,23825]},{"pos":[23834,23842],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[23846,23968],"content":"<bpt id=\"p1\">[</bpt>Security Issues in Reflection Emit<ept id=\"p1\">](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>","source":"[Security Issues in Reflection Emit](../../../docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)"},{"pos":[23971,24100],"content":"<bpt id=\"p1\">[</bpt>How to: Run Partially Trusted Code in a Sandbox<ept id=\"p1\">](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)</ept>","source":"[How to: Run Partially Trusted Code in a Sandbox](../../../docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)"}]}