{"content":"---\ntitle: \"Denial of Service\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"denial of service [WCF]\"\nms.assetid: dfb150f3-d598-4697-a5e6-6779e4f9b600\n---\n# Denial of Service\nDenial of service occurs when a system is overwhelmed in such a way that messages cannot be processed, or they are processed extremely slowly.  \n  \n## Excess Memory Consumption  \n A problem can occur when reading an XML document with a large number of unique local names, namespaces, or prefixes. If you are using a class that derives from <xref:System.Xml.XmlReader>, and you call either the <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A> or <xref:System.Xml.XmlReader.NamespaceURI%2A> property for each item, the returned string is added to a <xref:System.Xml.NameTable>. The collection held by the <xref:System.Xml.NameTable> never decreases in size, creating a virtual \"memory leak\" of the string handles.  \n  \n Mitigations include:  \n  \n-   Derive from the <xref:System.Xml.NameTable> class and enforce a maximum size quota. (You cannot prevent the use of a <xref:System.Xml.NameTable> or switch the <xref:System.Xml.NameTable> when it is full.)  \n  \n-   Avoid using the properties mentioned and instead use the <xref:System.Xml.XmlReader.MoveToAttribute%2A> method with the <xref:System.Xml.XmlReader.IsStartElement%2A> method where possible; those methods do not return strings and thus avoid the problem of overfilling the <xref:System.Xml.NameTable> collection.  \n  \n## Malicious Client Sends Excessive License Requests to Service  \n If a malicious client bombards a service with excessive license requests, it can cause the server to use excessive memory.  \n  \n Mitigation: Use the following properties of the <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> class:  \n  \n-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: controls the maximum number of time-bounded `SecurityContextToken`s that the server caches after `SPNego` or `SSL` negotiation.  \n  \n-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: controls the lifetime of the `SecurityContextTokens` that the server issues following `SPNego` or `SSL` negotiation. The server caches the `SecurityContextToken`s for this period of time.  \n  \n-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: controls the maximum number of secure conversations that are established at the server but for which no application messages have been processed. This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.  \n  \n-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>:  controls the maximum time the service keeps a secure conversation alive without receiving an application message from the client for the conversation. This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.  \n  \n## WSDualHttpBinding or Dual Custom Bindings Require Client Authentication  \n By default, the <xref:System.ServiceModel.WSDualHttpBinding> has security enabled. It is possible, however, that if the client authentication is disabled by setting the <xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A> property to <xref:System.ServiceModel.MessageCredentialType.None>, a malicious user can cause a denial of service attack on a third service. This can occur because a malicious client can direct the service to send a stream of messages to a third service.  \n  \n To mitigate this, do not set the property to `None`. Also be aware of this possibility when creating a custom binding that has a dual message pattern.  \n  \n## Auditing Event Log Can Be Filled  \n If a malicious user understands that auditing is enabled, that attacker can send invalid messages that cause audit entries to be written. If the audit log is filled in this manner, the auditing system fails.  \n  \n To mitigate this, set the <xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A> property to `true` and use the properties of the Event Viewer to control the auditing behavior. For more information about using the Event Viewer to view and manage event logs, see [Event Viewer](https://go.microsoft.com/fwlink/?LinkId=186123). For more information, see [Auditing](../../../../docs/framework/wcf/feature-details/auditing-security-events.md).  \n  \n## Invalid Implementations of IAuthorizationPolicy Can Cause Service Hangs  \n Calling the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A> method on a faulty implementation of the <xref:System.IdentityModel.Policy.IAuthorizationPolicy> interface can cause the service to hang.  \n  \n Mitigation: Use only trusted code. That is, use only code that you have written and tested, or that comes from a trusted provider. Do not allow untrusted extensions of <xref:System.IdentityModel.Policy.IAuthorizationPolicy> to be plugged into your code without due consideration. This applies to all extensions used in a service implementation. WCF does not make any distinction between application code and foreign code that is plugged in using extensibility points.  \n  \n## Kerberos Maximum Token Size May Need Resizing  \n If a client belongs to a large number of groups (approximately 900, although the actual number varies depending on the groups), a problem may occur when a message header's block exceeds 64 kilobytes. In that case, you can increase the maximum Kerberos token size, as described in the Microsoft Support article \"[Internet Explorer Kerberos authentication does not work because of an insufficient buffer connecting to IIS](https://go.microsoft.com/fwlink/?LinkId=89176).\" You may also need to increase the maximum WCF message size to accommodate the larger Kerberos token.  \n  \n## Autoenrollment Results in Multiple Certificates with Same Subject Name for Machine  \n *Autoenrollment* is the capability of [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] to automatically enroll users and computers for certificates. When a machine is on a domain with the feature enabled, an X.509 certificate with the intended purpose of client authentication is automatically created and inserted into the local computer's Personal certificates store whenever a new machine is joined to the network. However, autoenrollment uses the same subject name for all certificates it creates in the cache.  \n  \n The impact is that WCF services may fail to open on domains with autoenrollment. This occurs because the default service X.509 credential search criteria might be ambiguous because multiple certificates with the machine's fully qualified Domain Name System (DNS) name exist. One certificate originates from autoenrollment; the other might be a self-issued certificate.  \n  \n To mitigate this, reference the exact certificate to use by using a more precise search criterion on the [\\<serviceCredentials>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecredentials.md). For example, use the <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint> option, and specify the certificate by its unique thumbprint (hash).  \n  \n For more information about the autoenrollment feature, see [Certificate Autoenrollment in Windows Server 2003](https://go.microsoft.com/fwlink/?LinkId=95166).  \n  \n## Last of Multiple Alternative Subject Names Used for Authorization  \n In the rare case when an X.509 certificate contains multiple alternative subject names, and you authorize using the alternative subject name, authorization may fail.  \n  \n## Protect Configuration Files with ACLs  \n You can specify required and optional claims in code and configuration files for [!INCLUDE[infocard](../../../../includes/infocard-md.md)] issued tokens. This results in corresponding elements being emitted in `RequestSecurityToken` messages that are sent to the security token service. An attacker can modify code or configuration to remove required or optional claims, potentially getting the security token service to issue a token that does not allow access to the target service.  \n  \n To mitigate: Require access to the computer to modify the configuration file. Use file access control lists (ACLs) to secure configuration files. WCF requires that code be in the application directory or the global assembly cache before it will allow such code to be loaded from configuration. Use directory ACLs to secure directories.  \n  \n## Maximum Number of Secure Sessions for a Service Is Reached  \n When a client is successfully authenticated by a service and a secure session is established with the service, the service keeps track of the session until the client cancels it or the session expires. Every established session counts against the limit for the maximum number of active simultaneous sessions with a service. When this limit is reached, clients that attempt to create a new session with that service are rejected until one or more active sessions expire or are canceled by a client. A client can have multiple sessions with a service, and each one of those sessions counts toward the limit.  \n  \n> [!NOTE]\n>  When you use stateful sessions, the previous paragraph does not apply. For more information about stateful sessions, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).  \n  \n To mitigate this, set the limit for the maximum number of active sessions and the maximum lifetime for a session by setting the <xref:System.ServiceModel.Channels.SecurityBindingElement> property of the <xref:System.ServiceModel.Channels.SecurityBindingElement> class.  \n  \n## See also\n\n- [Security Considerations](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)\n- [Information Disclosure](../../../../docs/framework/wcf/feature-details/information-disclosure.md)\n- [Elevation of Privilege](../../../../docs/framework/wcf/feature-details/elevation-of-privilege.md)\n- [Denial of Service](../../../../docs/framework/wcf/feature-details/denial-of-service.md)\n- [Replay Attacks](../../../../docs/framework/wcf/feature-details/replay-attacks.md)\n- [Tampering](../../../../docs/framework/wcf/feature-details/tampering.md)\n- [Unsupported Scenarios](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)\n","nodes":[{"pos":[4,153],"embed":true,"restype":"x-metadata","content":"title: \"Denial of Service\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"denial of service [WCF]\"\nms.assetid: dfb150f3-d598-4697-a5e6-6779e4f9b600","nodes":[{"content":"Denial of Service","nodes":[{"pos":[0,17],"content":"Denial of Service","nodes":[{"content":"Denial of Service","pos":[0,17]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[160,177],"content":"Denial of Service","linkify":"Denial of Service","nodes":[{"content":"Denial of Service","pos":[0,17]}]},{"content":"Denial of service occurs when a system is overwhelmed in such a way that messages cannot be processed, or they are processed extremely slowly.","pos":[178,320]},{"pos":[329,354],"content":"Excess Memory Consumption","linkify":"Excess Memory Consumption","nodes":[{"content":"Excess Memory Consumption","pos":[0,25]}]},{"content":"A problem can occur when reading an XML document with a large number of unique local names, namespaces, or prefixes.","pos":[358,474]},{"content":"If you are using a class that derives from <ph id=\"ph1\">&lt;xref:System.Xml.XmlReader&gt;</ph>, and you call either the <ph id=\"ph2\">&lt;xref:System.Xml.XmlReader.LocalName%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Xml.XmlReader.Prefix%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Xml.XmlReader.NamespaceURI%2A&gt;</ph> property for each item, the returned string is added to a <ph id=\"ph5\">&lt;xref:System.Xml.NameTable&gt;</ph>.","pos":[475,784],"source":" If you are using a class that derives from <xref:System.Xml.XmlReader>, and you call either the <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A> or <xref:System.Xml.XmlReader.NamespaceURI%2A> property for each item, the returned string is added to a <xref:System.Xml.NameTable>."},{"content":"The collection held by the <ph id=\"ph1\">&lt;xref:System.Xml.NameTable&gt;</ph> never decreases in size, creating a virtual \"memory leak\" of the string handles.","pos":[785,920],"source":" The collection held by the <xref:System.Xml.NameTable> never decreases in size, creating a virtual \"memory leak\" of the string handles."},{"content":"Mitigations include:","pos":[927,947]},{"content":"Derive from the <ph id=\"ph1\">&lt;xref:System.Xml.NameTable&gt;</ph> class and enforce a maximum size quota.","pos":[957,1040],"source":"Derive from the <xref:System.Xml.NameTable> class and enforce a maximum size quota."},{"content":"(You cannot prevent the use of a <ph id=\"ph1\">&lt;xref:System.Xml.NameTable&gt;</ph> or switch the <ph id=\"ph2\">&lt;xref:System.Xml.NameTable&gt;</ph> when it is full.)","pos":[1041,1161],"source":" (You cannot prevent the use of a <xref:System.Xml.NameTable> or switch the <xref:System.Xml.NameTable> when it is full.)"},{"pos":[1171,1481],"content":"Avoid using the properties mentioned and instead use the <ph id=\"ph1\">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A&gt;</ph> method with the <ph id=\"ph2\">&lt;xref:System.Xml.XmlReader.IsStartElement%2A&gt;</ph> method where possible; those methods do not return strings and thus avoid the problem of overfilling the <ph id=\"ph3\">&lt;xref:System.Xml.NameTable&gt;</ph> collection.","source":"Avoid using the properties mentioned and instead use the <xref:System.Xml.XmlReader.MoveToAttribute%2A> method with the <xref:System.Xml.XmlReader.IsStartElement%2A> method where possible; those methods do not return strings and thus avoid the problem of overfilling the <xref:System.Xml.NameTable> collection."},{"pos":[1490,1550],"content":"Malicious Client Sends Excessive License Requests to Service","linkify":"Malicious Client Sends Excessive License Requests to Service","nodes":[{"content":"Malicious Client Sends Excessive License Requests to Service","pos":[0,60]}]},{"content":"If a malicious client bombards a service with excessive license requests, it can cause the server to use excessive memory.","pos":[1554,1676]},{"pos":[1683,1802],"content":"Mitigation: Use the following properties of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.LocalServiceSecuritySettings&gt;</ph> class:","source":"Mitigation: Use the following properties of the <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> class:"},{"pos":[1812,2025],"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A&gt;</ph>: controls the maximum number of time-bounded <ph id=\"ph2\">`SecurityContextToken`</ph>s that the server caches after <ph id=\"ph3\">`SPNego`</ph> or <ph id=\"ph4\">`SSL`</ph> negotiation.","source":"<xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A>: controls the maximum number of time-bounded `SecurityContextToken`s that the server caches after `SPNego` or `SSL` negotiation."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A&gt;</ph>: controls the lifetime of the <ph id=\"ph2\">`SecurityContextTokens`</ph> that the server issues following <ph id=\"ph3\">`SPNego`</ph> or <ph id=\"ph4\">`SSL`</ph> negotiation.","pos":[2035,2241],"source":"<xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A>: controls the lifetime of the `SecurityContextTokens` that the server issues following `SPNego` or `SSL` negotiation."},{"content":"The server caches the <ph id=\"ph1\">`SecurityContextToken`</ph>s for this period of time.","pos":[2242,2312],"source":" The server caches the `SecurityContextToken`s for this period of time."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A&gt;</ph>: controls the maximum number of secure conversations that are established at the server but for which no application messages have been processed.","pos":[2322,2555],"source":"<xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A>: controls the maximum number of secure conversations that are established at the server but for which no application messages have been processed."},{"content":"This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.","pos":[2556,2718]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A&gt;</ph>:  controls the maximum time the service keeps a secure conversation alive without receiving an application message from the client for the conversation.","pos":[2728,2966],"source":"<xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A>:  controls the maximum time the service keeps a secure conversation alive without receiving an application message from the client for the conversation."},{"content":"This quota prevents clients from establishing secure conversations at the service, thereby causing the service to maintain state per client, but never using them.","pos":[2967,3129]},{"pos":[3138,3209],"content":"WSDualHttpBinding or Dual Custom Bindings Require Client Authentication","linkify":"WSDualHttpBinding or Dual Custom Bindings Require Client Authentication","nodes":[{"content":"WSDualHttpBinding or Dual Custom Bindings Require Client Authentication","pos":[0,71]}]},{"content":"By default, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.WSDualHttpBinding&gt;</ph> has security enabled.","pos":[3213,3295],"source":"By default, the <xref:System.ServiceModel.WSDualHttpBinding> has security enabled."},{"content":"It is possible, however, that if the client authentication is disabled by setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A&gt;</ph> property to <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageCredentialType.None&gt;</ph>, a malicious user can cause a denial of service attack on a third service.","pos":[3296,3597],"source":" It is possible, however, that if the client authentication is disabled by setting the <xref:System.ServiceModel.MessageSecurityOverHttp.ClientCredentialType%2A> property to <xref:System.ServiceModel.MessageCredentialType.None>, a malicious user can cause a denial of service attack on a third service."},{"content":"This can occur because a malicious client can direct the service to send a stream of messages to a third service.","pos":[3598,3711]},{"content":"To mitigate this, do not set the property to <ph id=\"ph1\">`None`</ph>.","pos":[3718,3770],"source":"To mitigate this, do not set the property to `None`."},{"content":"Also be aware of this possibility when creating a custom binding that has a dual message pattern.","pos":[3771,3868]},{"pos":[3877,3909],"content":"Auditing Event Log Can Be Filled","linkify":"Auditing Event Log Can Be Filled","nodes":[{"content":"Auditing Event Log Can Be Filled","pos":[0,32]}]},{"content":"If a malicious user understands that auditing is enabled, that attacker can send invalid messages that cause audit entries to be written.","pos":[3913,4050]},{"content":"If the audit log is filled in this manner, the auditing system fails.","pos":[4051,4120]},{"content":"To mitigate this, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A&gt;</ph> property to <ph id=\"ph2\">`true`</ph> and use the properties of the Event Viewer to control the auditing behavior.","pos":[4127,4340],"source":"To mitigate this, set the <xref:System.ServiceModel.Description.ServiceSecurityAuditBehavior.SuppressAuditFailure%2A> property to `true` and use the properties of the Event Viewer to control the auditing behavior."},{"content":"For more information about using the Event Viewer to view and manage event logs, see <bpt id=\"p1\">[</bpt>Event Viewer<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=186123)</ept>.","pos":[4341,4489],"source":" For more information about using the Event Viewer to view and manage event logs, see [Event Viewer](https://go.microsoft.com/fwlink/?LinkId=186123)."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Auditing<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/auditing-security-events.md)</ept>.","pos":[4490,4603],"source":" For more information, see [Auditing](../../../../docs/framework/wcf/feature-details/auditing-security-events.md)."},{"pos":[4612,4683],"content":"Invalid Implementations of IAuthorizationPolicy Can Cause Service Hangs","linkify":"Invalid Implementations of IAuthorizationPolicy Can Cause Service Hangs","nodes":[{"content":"Invalid Implementations of IAuthorizationPolicy Can Cause Service Hangs","pos":[0,71]}]},{"pos":[4687,4904],"content":"Calling the <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A&gt;</ph> method on a faulty implementation of the <ph id=\"ph2\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ph> interface can cause the service to hang.","source":"Calling the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%2A> method on a faulty implementation of the <xref:System.IdentityModel.Policy.IAuthorizationPolicy> interface can cause the service to hang."},{"content":"Mitigation: Use only trusted code.","pos":[4911,4945]},{"content":"That is, use only code that you have written and tested, or that comes from a trusted provider.","pos":[4946,5041]},{"content":"Do not allow untrusted extensions of <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ph> to be plugged into your code without due consideration.","pos":[5042,5190],"source":" Do not allow untrusted extensions of <xref:System.IdentityModel.Policy.IAuthorizationPolicy> to be plugged into your code without due consideration."},{"content":"This applies to all extensions used in a service implementation.","pos":[5191,5255]},{"content":"WCF does not make any distinction between application code and foreign code that is plugged in using extensibility points.","pos":[5256,5378]},{"pos":[5387,5432],"content":"Kerberos Maximum Token Size May Need Resizing","linkify":"Kerberos Maximum Token Size May Need Resizing","nodes":[{"content":"Kerberos Maximum Token Size May Need Resizing","pos":[0,45]}]},{"content":"If a client belongs to a large number of groups (approximately 900, although the actual number varies depending on the groups), a problem may occur when a message header's block exceeds 64 kilobytes.","pos":[5436,5635]},{"content":"In that case, you can increase the maximum Kerberos token size, as described in the Microsoft Support article \"<bpt id=\"p1\">[</bpt>Internet Explorer Kerberos authentication does not work because of an insufficient buffer connecting to IIS<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=89176)</ept>.\"","pos":[5636,5905],"source":" In that case, you can increase the maximum Kerberos token size, as described in the Microsoft Support article \"[Internet Explorer Kerberos authentication does not work because of an insufficient buffer connecting to IIS](https://go.microsoft.com/fwlink/?LinkId=89176).\""},{"content":"You may also need to increase the maximum WCF message size to accommodate the larger Kerberos token.","pos":[5906,6006]},{"pos":[6015,6097],"content":"Autoenrollment Results in Multiple Certificates with Same Subject Name for Machine","linkify":"Autoenrollment Results in Multiple Certificates with Same Subject Name for Machine","nodes":[{"content":"Autoenrollment Results in Multiple Certificates with Same Subject Name for Machine","pos":[0,82]}]},{"content":"<bpt id=\"p1\">*</bpt>Autoenrollment<ept id=\"p1\">*</ept> is the capability of <ph id=\"ph1\">[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]</ph> to automatically enroll users and computers for certificates.","pos":[6101,6254],"source":"*Autoenrollment* is the capability of [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] to automatically enroll users and computers for certificates."},{"content":"When a machine is on a domain with the feature enabled, an X.509 certificate with the intended purpose of client authentication is automatically created and inserted into the local computer's Personal certificates store whenever a new machine is joined to the network.","pos":[6255,6523]},{"content":"However, autoenrollment uses the same subject name for all certificates it creates in the cache.","pos":[6524,6620]},{"content":"The impact is that WCF services may fail to open on domains with autoenrollment.","pos":[6627,6707]},{"content":"This occurs because the default service X.509 credential search criteria might be ambiguous because multiple certificates with the machine's fully qualified Domain Name System (DNS) name exist.","pos":[6708,6901]},{"content":"One certificate originates from autoenrollment; the other might be a self-issued certificate.","pos":[6902,6995]},{"content":"To mitigate this, reference the exact certificate to use by using a more precise search criterion on the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>serviceCredentials&gt;<ept id=\"p1\">](../../../../docs/framework/configure-apps/file-schema/wcf/servicecredentials.md)</ept>.","pos":[7002,7212],"source":"To mitigate this, reference the exact certificate to use by using a more precise search criterion on the [\\<serviceCredentials>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecredentials.md)."},{"content":"For example, use the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint&gt;</ph> option, and specify the certificate by its unique thumbprint (hash).","pos":[7213,7385],"source":" For example, use the <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint> option, and specify the certificate by its unique thumbprint (hash)."},{"pos":[7392,7550],"content":"For more information about the autoenrollment feature, see <bpt id=\"p1\">[</bpt>Certificate Autoenrollment in Windows Server 2003<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=95166)</ept>.","source":"For more information about the autoenrollment feature, see [Certificate Autoenrollment in Windows Server 2003](https://go.microsoft.com/fwlink/?LinkId=95166)."},{"pos":[7559,7624],"content":"Last of Multiple Alternative Subject Names Used for Authorization","linkify":"Last of Multiple Alternative Subject Names Used for Authorization","nodes":[{"content":"Last of Multiple Alternative Subject Names Used for Authorization","pos":[0,65]}]},{"content":"In the rare case when an X.509 certificate contains multiple alternative subject names, and you authorize using the alternative subject name, authorization may fail.","pos":[7628,7793]},{"pos":[7802,7839],"content":"Protect Configuration Files with ACLs","linkify":"Protect Configuration Files with ACLs","nodes":[{"content":"Protect Configuration Files with ACLs","pos":[0,37]}]},{"content":"You can specify required and optional claims in code and configuration files for <ph id=\"ph1\">[!INCLUDE[infocard](../../../../includes/infocard-md.md)]</ph> issued tokens.","pos":[7843,7996],"source":"You can specify required and optional claims in code and configuration files for [!INCLUDE[infocard](../../../../includes/infocard-md.md)] issued tokens."},{"content":"This results in corresponding elements being emitted in <ph id=\"ph1\">`RequestSecurityToken`</ph> messages that are sent to the security token service.","pos":[7997,8129],"source":" This results in corresponding elements being emitted in `RequestSecurityToken` messages that are sent to the security token service."},{"content":"An attacker can modify code or configuration to remove required or optional claims, potentially getting the security token service to issue a token that does not allow access to the target service.","pos":[8130,8327]},{"content":"To mitigate: Require access to the computer to modify the configuration file.","pos":[8334,8411]},{"content":"Use file access control lists (ACLs) to secure configuration files.","pos":[8412,8479]},{"content":"WCF requires that code be in the application directory or the global assembly cache before it will allow such code to be loaded from configuration.","pos":[8480,8627]},{"content":"Use directory ACLs to secure directories.","pos":[8628,8669]},{"pos":[8678,8736],"content":"Maximum Number of Secure Sessions for a Service Is Reached","linkify":"Maximum Number of Secure Sessions for a Service Is Reached","nodes":[{"content":"Maximum Number of Secure Sessions for a Service Is Reached","pos":[0,58]}]},{"content":"When a client is successfully authenticated by a service and a secure session is established with the service, the service keeps track of the session until the client cancels it or the session expires.","pos":[8740,8941]},{"content":"Every established session counts against the limit for the maximum number of active simultaneous sessions with a service.","pos":[8942,9063]},{"content":"When this limit is reached, clients that attempt to create a new session with that service are rejected until one or more active sessions expire or are canceled by a client.","pos":[9064,9237]},{"content":"A client can have multiple sessions with a service, and each one of those sessions counts toward the limit.","pos":[9238,9345]},{"pos":[9353,9659],"content":"[!NOTE]\n When you use stateful sessions, the previous paragraph does not apply. For more information about stateful sessions, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).","leadings":["","> "],"nodes":[{"content":"When you use stateful sessions, the previous paragraph does not apply. For more information about stateful sessions, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).","pos":[9,304],"nodes":[{"content":"When you use stateful sessions, the previous paragraph does not apply.","pos":[0,70]},{"content":"For more information about stateful sessions, see <bpt id=\"p1\">[</bpt>How to: Create a Security Context Token for a Secure Session<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md)</ept>.","pos":[71,295],"source":" For more information about stateful sessions, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md)."}]}]},{"pos":[9666,9934],"content":"To mitigate this, set the limit for the maximum number of active sessions and the maximum lifetime for a session by setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.SecurityBindingElement&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.SecurityBindingElement&gt;</ph> class.","source":"To mitigate this, set the limit for the maximum number of active sessions and the maximum lifetime for a session by setting the <xref:System.ServiceModel.Channels.SecurityBindingElement> property of the <xref:System.ServiceModel.Channels.SecurityBindingElement> class."},{"pos":[9943,9951],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9955,10062],"content":"<bpt id=\"p1\">[</bpt>Security Considerations<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)</ept>","source":"[Security Considerations](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)"},{"pos":[10065,10163],"content":"<bpt id=\"p1\">[</bpt>Information Disclosure<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/information-disclosure.md)</ept>","source":"[Information Disclosure](../../../../docs/framework/wcf/feature-details/information-disclosure.md)"},{"pos":[10166,10264],"content":"<bpt id=\"p1\">[</bpt>Elevation of Privilege<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/elevation-of-privilege.md)</ept>","source":"[Elevation of Privilege](../../../../docs/framework/wcf/feature-details/elevation-of-privilege.md)"},{"pos":[10267,10355],"content":"<bpt id=\"p1\">[</bpt>Denial of Service<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/denial-of-service.md)</ept>","source":"[Denial of Service](../../../../docs/framework/wcf/feature-details/denial-of-service.md)"},{"pos":[10358,10440],"content":"<bpt id=\"p1\">[</bpt>Replay Attacks<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/replay-attacks.md)</ept>","source":"[Replay Attacks](../../../../docs/framework/wcf/feature-details/replay-attacks.md)"},{"pos":[10443,10515],"content":"<bpt id=\"p1\">[</bpt>Tampering<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/tampering.md)</ept>","source":"[Tampering](../../../../docs/framework/wcf/feature-details/tampering.md)"},{"pos":[10518,10614],"content":"<bpt id=\"p1\">[</bpt>Unsupported Scenarios<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)</ept>","source":"[Unsupported Scenarios](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)"}]}