{"content":"---\ntitle: \"Security Considerations for Data\"\nms.date: \"03/30/2017\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2\n---\n\n# Security Considerations for Data\n\nWhen dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories. The following table lists the most important threat classes that relate to data processing. WCF provides tools to mitigate these threats.\n\nDenial of service\nWhen receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations. A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.\n\nMalicious code execution\nIncoming untrusted data causes the receiving side to run code it did not intend to.\n\nInformation disclosure\nThe remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.\n\n## User-Provided Code and Code Access Security\n\nA number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user. For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors. The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.\n\nIt is the responsibility of the code author to ensure that no security vulnerabilities exist. For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member. In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data). When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).\n\nThe ultimate example of user-provided code is the code inside your service implementation for each operation. The security of your service implementation is your responsibility. It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities. For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string. If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail. (An <xref:System.OutOfMemoryException> is not recoverable in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] and always results in the termination of your application.)\n\nYou should ensure that no malicious code is plugged in to the various extensibility points. This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code. For more information, see \"Partial Trust Threats\" in a later section.\n\nNote that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported. For more information, see [Partial Trust](../../../../docs/framework/wcf/feature-details/partial-trust.md).\n\n## Avoiding Unintentional Information Disclosure\n\nWhen designing serializable types with security in mind, information disclosure is a possible concern.\n\nConsider the following points:\n\n- The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization. Additionally, the shape of a type can be exposed during schema export. Be sure to understand your type's serialization projection. If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).\n\n- Be aware that the same type may have multiple serialization projections, depending on the serializer in use. The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>. Accidentally using the wrong serializer may lead to information disclosure.\n\n- Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.\n\n## Preventing Denial-of-Service Attacks\n\n### Quotas\n\nCausing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack. While this section concentrates on memory consumption issues arising from large messages, other attacks may occur. For example, messages may use a disproportionate amount of processing time.\n\nDenial-of-service attacks are usually mitigated using quotas. When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown. Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.\n\nThe quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages. The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]; the service terminates if it encounters such exceptions.\n\nQuotas in WCF do not involve any pre-allocation. For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message. The actual amount allocated depends on the actual incoming message size.\n\nMany quotas are available at the transport layer. These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on). While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md).\n\n### Hashtable Vulnerability\n\nA vulnerability exists when data contracts contain hashtables or collections. The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value. This can be used as a DOS attack.  This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota. Care must be taken while setting this quota in order to prevent such attacks. This quota puts an upper limit on the size of WCF message. Additionally, avoid using hashtables or collections in your data contracts.\n\n## Limiting Memory Consumption Without Streaming\n\nThe security model around large messages depends on whether streaming is in use. In the basic, non-streamed case, messages are buffered into memory. In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access. Note that a service may be processing multiple messages at the same time, in which case they are all in memory. Use the throttling feature to mitigate this threat.\n\nAlso note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor. For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB. For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data. For example, a data contract \"MyContract\" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction \"\\<MyContract/>\". This XML results in memory being accessed for 150 fields. Note that data members are optional by default. The problem is compounded when such a type is part of an array.\n\n`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks. For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message. Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs. Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>. This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the \"Using XML Safely\" section later in the topic.\n\nSetting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding. Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data. Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form. To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the \"Using XML Safely\" section later in this topic.\n\n## Limiting Memory Consumption with Streaming\n\nWhen streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks. However, more complicated scenarios are possible with streaming. For example, a file upload service accepts files larger than all available memory. In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk. If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.\n\nTo mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering. The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings. When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message. As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor. Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.\n\n### MaxBufferSize Details\n\nThe `MaxBufferSize` property limits any bulk buffering WCF does. For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message. This setting limits the amount of buffering in all these cases.\n\nWCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer. For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter. WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering. It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly. In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.\n\nThe MTOM message encoder also has a `MaxBufferSize` setting. When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value. However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.\n\n## XML-Based Streaming Attacks\n\n`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected. For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element. This is done so that namespaces and attributes are properly processed. If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag. An attempt to read it results in an <xref:System.OutOfMemoryException>. This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the \"Using XML Safely\" section later in this topic. When streaming, it is especially important to set all of these quotas.\n\n### Mixing Streaming and Buffering Programming Models\n\nMany possible attacks arise from mixing streaming and non-streaming programming models in the same service. Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type. Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams. Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called. This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.\n\nFor this reason, avoid mixing stream-based and non-streamed operations in the same contract. If you absolutely must mix the two programming models, use the following precautions:\n\n- Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`. This ensures that only members that are a part of the contract are deserialized.\n\n- Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value. This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration. This quota limits the number of objects that are deserialized in one deserialization episode. Normally, each operation parameter or message body part in a message contract is deserialized in one episode. When deserializing arrays, each array entry is counted as a separate object.\n\n- Set all of the XML reader quotas to safe values. Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.\n\n- Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the \"Preventing Unintended Types from Being Loaded\" section later in this topic).\n\n- Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data. Do not add such types to the list of known types.\n\n- Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.\n\n- Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.\n\nThe preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>. Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.\n\n### Slow Stream Attacks\n\nA class of streaming denial-of-service attacks does not involve memory consumption. Instead, the attack involves a slow sender or receiver of data. While waiting for the data to be sent or received, resources such as threads and available connections are exhausted. This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.\n\nTo mitigate these attacks, set the transport time-outs correctly. For more information, see [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md). Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.\n\n## Using XML Safely\n\n> [!NOTE]\n> Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents. The quotas work similarly, using [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).\n\n### Secure XML Readers\n\nThe XML Infoset forms the basis of all message processing in WCF. When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated. WCF provides special, secure XML readers. These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).\n\nSome of the security features on these readers are always active. For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages. Other security features include reader quotas that must be configured, which are described in the following section.\n\nWhen working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data. Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class. When creating a reader, pass in secure quota values. Do not call the `Create` method overloads. These do not create a WCF reader. Instead, a reader is created that is not protected by the security features described in this section.\n\n### Reader Quotas\n\nThe secure XML readers have five configurable quotas. These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.\n\n#### MaxBytesPerRead\n\nThis quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes. (In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:\n\n- The element name and its attributes are always buffered in memory when they are being read. Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected. See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.\n\n- Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness. `MaxBytesPerRead` mitigates this threat.\n\n#### MaxDepth\n\nThis quota limits the maximum nesting depth of XML elements. For example, the document \"\\<A>\\<B>\\<C/>\\</B>\\</A>\" has a nesting depth of three. <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:\n\n- `MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.\n\n- When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>. A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>. Use `MaxDepth` to mitigate this threat.\n\n#### MaxNameTableCharCount\n\nThis quota limits the size of the reader’s *nametable*. The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document. As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.\n\n#### MaxStringContentLength\n\nThis quota limits the maximum string size that the XML reader returns. This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader. For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota. When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method. The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.\n\n#### MaxArrayLength\n\nThis quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays. This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader. For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota. It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract. Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.\n\n## Threats Specific to the Binary Encoding\n\nThe binary XML encoding WCF supports includes a *dictionary strings* feature. A large string may be encoded using only a few bytes. This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.\n\nThere are two kinds of dictionaries: *static* and *dynamic*. The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding. This list of strings is fixed when the reader is created and cannot be modified. None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack. In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.\n\nThe dynamic dictionaries feature allows messages to define their own strings and associate them with short codes. These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined. These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.\n\nThe first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large. This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately. Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.\n\nUnlike most other quotas, this quota also applies when writing messages. If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual. If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.\n\n### Dictionary Expansion Threats\n\nA significant class of binary-specific attacks arises from dictionary expansion. A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature. The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.\n\nThe <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption. They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`. However, `MaxReceivedMessageSize` counts pre-expansion bytes. When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>. For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.\n\nWhen using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack. This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract. If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding. Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute. Alternatively, do not implement the `IExtensibleDataObject` interface. For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).\n\n### Quotas Summary\n\nThe following table summarizes the guidance about quotas.\n\n|Condition|Important quotas to set|\n|---------------|-----------------------------|\n|No streaming or streaming small messages, text, or MTOM encoding|`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`|\n|No streaming or streaming small messages, binary encoding|`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`|\n|Streaming large messages, text, or MTOM encoding|`MaxBufferSize` and all `ReaderQuotas`|\n|Streaming large messages, binary encoding|`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`|\n\n- Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.\n\n- When in doubt about a quota, set it to a safe value rather than leaving it open.\n\n## Preventing Malicious Code Execution\n\nThe following general classes of threats can execute code and have unintended effects:\n\n- The deserializer loads a malicious, unsafe, or security-sensitive type.\n\n- An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.\n\nThe following sections discuss these classes of threats further.\n\n## DataContractSerializer\n\n(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details. For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute. However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.\n\n### Preventing Unintended Types from Being Loaded\n\nLoading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects. A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions. Types may have class constructors that run as soon as the type is loaded and before any instances are created. For these reasons, it is important to control the set of types that the deserializer may load.\n\nThe <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way. It never reads common language runtime (CLR) type and assembly names from the incoming data. This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>. Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.\n\nThe <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract. For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.\n\nAdditionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism. A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance. This is possible only if the `Customer` type has been made \"known\" to the deserializer through one of these mechanisms:\n\n- <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.\n\n- `KnownTypeAttribute` attribute specifying a method that returns a list of types.\n\n- `ServiceKnownTypeAttribute` attribute.\n\n- The `KnownTypes` configuration section.\n\n- A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.\n\nEach of these mechanisms increases the surface area by introducing more types that the deserializer can load. Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.\n\nOnce a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it. For example, suppose the type \"MyDangerousType\" is added to the known types list using one of the mechanisms above. This means that:\n\n- `MyDangerousType` is loaded and its class constructor runs.\n\n- Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create. Code in `MyDangerousType`, such as property setters, may run. After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.\n\nWhen writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.\n\nIf specifying known types in configuration, ensure that the configuration file is secure. Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load. The type loader automatically picks the latest version, if possible. If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.\n\nHaving too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize. This cache is never cleared as long as the application domain is running. Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.\n\n### Preventing Types from Being in an Unintended State\n\nA type may have internal consistency constraints that must be enforced. Care must be taken to avoid breaking these constraints during deserialization.\n\nThe following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.\n\n[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]\n[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]\n\nAn attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.\n\n```xml\n<SpaceStationAirlock>\n    <innerDoorOpen>true</innerDoorOpen>\n    <outerDoorOpen>true</outerDoorOpen>\n</SpaceStationAirlock>\n```\n\nThis situation can be avoided by being aware of the following points:\n\n- When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run. Therefore, do not rely on any state management done in the constructor.\n\n- Use callbacks to ensure that the object is in a valid state. The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state. For more information, see [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).\n\n- Do not design data contract types to rely on any particular order in which property setters must be called.\n\n- Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute. Many of them were designed to work with [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting for use with trusted data only. Existing types marked with this attribute may not have been designed with state safety in mind.\n\n- Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned. Data could always be `null`, `zero`, or `invalid`.\n\n- Never trust an object graph deserialized from an untrusted data source without validating it first. Each individual object may be in a consistent state, but the object graph as a whole may not be. Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references. For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).\n\n### Using the NetDataContractSerializer Securely\n\nThe <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types. This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>. That is, it determines which type to instantiate by reading the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type name from the incoming data. Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written. The `NetDataContractSerializer` is provided primarily to ease migration from [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting to WCF. For more information, see the relevant section in [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).\n\nBecause the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data. It is possible to make it secure by writing a secure, type-limiting type binder that allows only safe types to load (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property).\n\nEven when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>. Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load. Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.\n\nIn general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process. For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.\n\nAnother security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat. When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value. It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.\n\n### XmlSerializer-Specific Threats\n\nThe <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>. A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.\n\nThe <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory. If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code. The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code. Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.\n\nThe <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime. This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly. The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized. This offers protection from malicious assemblies being disguised as serialization assemblies. However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name. This makes running malicious code possible. Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.\n\nThe <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack. The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>). Thus, it deserializes an arbitrary amount of objects, limited only by the message size.\n\n### Partial Trust Threats\n\nNote the following concerns regarding threats related to code running with partial trust. These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).\n\n- When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects. Such usage may lead to security vulnerabilities.\n\n- In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream. If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.\n\n- If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process. For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream. An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the \"Using the NetDataContractSerializer Securely\" section.\n\n- If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.\n\n- Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust. Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.\n\n- If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.\n\n- For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.\n\n- The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure. For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object. Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.\n\n- <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust. However, in partial trust, only public members can be serialized. A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.\n\n    To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute. This attribute allows an assembly to declare that its internal members are visible to some other assembly. In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.\n\n    The advantage of this approach is that it does not require an elevated code generation path.\n\n    At the same time, there are two major disadvantages.\n\n    The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide. That is, you cannot specify that only a certain class can have its internal members serialized. Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member. Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.\n\n    The second disadvantage is that it still does not support private or protected members.\n\n    To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:\n\n    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]\n\n    In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust. Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.\n\n    However, if we add the following line to the source file, the program runs successfully.\n\n    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]\n\n## Other State Management Concerns\n\nA few other concerns regarding object state management are worth mentioning:\n\n- When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives. The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected. In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted. This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).\n\n- Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted. If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about. Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account. Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.\n\n## Schema Import\n\nNormally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class. However, in more advanced scenarios, you may process schema at runtime. Be aware that doing so can expose you to denial-of-service risks. Some schema may take a long time to be imported. Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.\n\n## Threats Specific to ASP.NET AJAX Integration\n\nWhen the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages. However, there is only one set of reader quotas, used both by the XML reader and the JSON reader. Some quota settings may be appropriate for one reader but too large for the other.\n\nWhen implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint. The following security issues must be considered:\n\n- Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.\n\n- When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.\n\n## A Note on Components\n\nWCF is a flexible and customizable system. Most of the contents of this topic focus on the most common WCF usage scenarios. However, it is possible to compose components WCF provides in many different ways. It is important to understand the security implications of using each component. In particular:\n\n- When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers. Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods. Do not use the <xref:System.Xml.XmlReader.Create%2A> method. Always configure the readers with safe quotas. The serialization engines in WCF are secure only when used with secure XML readers from WCF.\n\n- When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.\n\n- When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.\n\n- When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.\n\n- When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits. Do not use XPath expressions that could take a long time to compute without visiting many nodes.\n\n- In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.\n\n## See also\n\n- <xref:System.Runtime.Serialization.DataContractSerializer>\n- <xref:System.Xml.XmlDictionaryReader>\n- <xref:System.Xml.Serialization.XmlSerializer>\n- [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)\n","nodes":[{"pos":[4,149],"embed":true,"restype":"x-metadata","content":"title: \"Security Considerations for Data\"\nms.date: \"03/30/2017\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2","nodes":[{"content":"Security Considerations for Data","nodes":[{"pos":[0,32],"content":"Security Considerations for Data","nodes":[{"content":"Security Considerations for Data","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[157,189],"content":"Security Considerations for Data","linkify":"Security Considerations for Data","nodes":[{"content":"Security Considerations for Data","pos":[0,32]}]},{"content":"When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.","pos":[191,305]},{"content":"The following table lists the most important threat classes that relate to data processing.","pos":[306,397]},{"content":"WCF provides tools to mitigate these threats.","pos":[398,443]},{"content":"Denial of service When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.","pos":[445,690],"source":"Denial of service\nWhen receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations."},{"content":"A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.","pos":[691,822]},{"pos":[824,932],"content":"Malicious code execution Incoming untrusted data causes the receiving side to run code it did not intend to.","source":"Malicious code execution\nIncoming untrusted data causes the receiving side to run code it did not intend to."},{"pos":[934,1096],"content":"Information disclosure The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.","source":"Information disclosure\nThe remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to."},{"pos":[1101,1144],"content":"User-Provided Code and Code Access Security","linkify":"User-Provided Code and Code Access Security","nodes":[{"content":"User-Provided Code and Code Access Security","pos":[0,43]}]},{"content":"A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.","pos":[1146,1264]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> serialization engine may call user-provided property <ph id=\"ph2\">`set`</ph> accessors and <ph id=\"ph3\">`get`</ph> accessors.","pos":[1265,1430],"source":" For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors."},{"content":"The WCF channel infrastructure may also call into user-provided derived classes of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class.","pos":[1431,1568],"source":" The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class."},{"content":"It is the responsibility of the code author to ensure that no security vulnerabilities exist.","pos":[1570,1663]},{"content":"For example, if you create a data contract type with a data member property of type integer, and in the <ph id=\"ph1\">`set`</ph> accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.","pos":[1664,1980],"source":" For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member."},{"content":"In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).","pos":[1981,2166]},{"content":"When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).","pos":[2167,2326]},{"content":"The ultimate example of user-provided code is the code inside your service implementation for each operation.","pos":[2328,2437]},{"content":"The security of your service implementation is your responsibility.","pos":[2438,2505]},{"content":"It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.","pos":[2506,2629]},{"content":"For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.","pos":[2630,2761]},{"content":"If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.","pos":[2762,2967]},{"content":"(An <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> is not recoverable in the <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> and always results in the termination of your application.)","pos":[2968,3156],"source":" (An <xref:System.OutOfMemoryException> is not recoverable in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] and always results in the termination of your application.)"},{"content":"You should ensure that no malicious code is plugged in to the various extensibility points.","pos":[3158,3249]},{"content":"This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.","pos":[3250,3422]},{"content":"For more information, see \"Partial Trust Threats\" in a later section.","pos":[3423,3492]},{"content":"Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <ph id=\"ph1\">&lt;xref:System.SerializableAttribute&gt;</ph> attribute are not supported.","pos":[3494,3771],"source":"Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Partial Trust<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/partial-trust.md)</ept>.","pos":[3772,3879],"source":" For more information, see [Partial Trust](../../../../docs/framework/wcf/feature-details/partial-trust.md)."},{"pos":[3884,3929],"content":"Avoiding Unintentional Information Disclosure","linkify":"Avoiding Unintentional Information Disclosure","nodes":[{"content":"Avoiding Unintentional Information Disclosure","pos":[0,45]}]},{"content":"When designing serializable types with security in mind, information disclosure is a possible concern.","pos":[3931,4033]},{"content":"Consider the following points:","pos":[4035,4065]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.","pos":[4069,4252],"source":"The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization."},{"content":"Additionally, the shape of a type can be exposed during schema export.","pos":[4253,4323]},{"content":"Be sure to understand your type's serialization projection.","pos":[4324,4383]},{"content":"If you do not want anything exposed, disable serializing it (for example, by not applying the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attribute in the case of a data contract).","pos":[4384,4576],"source":" If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract)."},{"content":"Be aware that the same type may have multiple serialization projections, depending on the serializer in use.","pos":[4580,4688]},{"content":"The same type may expose one set of data when used with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and another set of data when used with the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.","pos":[4689,4897],"source":" The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>."},{"content":"Accidentally using the wrong serializer may lead to information disclosure.","pos":[4898,4973]},{"pos":[4977,5183],"content":"Using the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.","source":"Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side."},{"pos":[5188,5224],"content":"Preventing Denial-of-Service Attacks","linkify":"Preventing Denial-of-Service Attacks","nodes":[{"content":"Preventing Denial-of-Service Attacks","pos":[0,36]}]},{"pos":[5230,5236],"content":"Quotas","linkify":"Quotas","nodes":[{"content":"Quotas","pos":[0,6]}]},{"content":"Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.","pos":[5238,5348]},{"content":"While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.","pos":[5349,5463]},{"content":"For example, messages may use a disproportionate amount of processing time.","pos":[5464,5539]},{"content":"Denial-of-service attacks are usually mitigated using quotas.","pos":[5541,5602]},{"content":"When a quota is exceeded, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.QuotaExceededException&gt;</ph> exception is normally thrown.","pos":[5603,5710],"source":" When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown."},{"content":"Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, or all available stacks to be accessed, resulting in a <ph id=\"ph2\">&lt;xref:System.StackOverflowException&gt;</ph>.","pos":[5711,5951],"source":" Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>."},{"content":"The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.","pos":[5953,6146]},{"content":"The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph>; the service terminates if it encounters such exceptions.","pos":[6147,6361],"source":" The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]; the service terminates if it encounters such exceptions."},{"content":"Quotas in WCF do not involve any pre-allocation.","pos":[6363,6411]},{"content":"For example, if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.","pos":[6412,6642],"source":" For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message."},{"content":"The actual amount allocated depends on the actual incoming message size.","pos":[6643,6715]},{"content":"Many quotas are available at the transport layer.","pos":[6717,6766]},{"content":"These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).","pos":[6767,6857]},{"content":"While this topic discusses some of these quotas, these quotas are described in detail in <bpt id=\"p1\">[</bpt>Transport Quotas<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/transport-quotas.md)</ept>.","pos":[6858,7034],"source":" While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md)."},{"pos":[7040,7063],"content":"Hashtable Vulnerability","linkify":"Hashtable Vulnerability","nodes":[{"content":"Hashtable Vulnerability","pos":[0,23]}]},{"content":"A vulnerability exists when data contracts contain hashtables or collections.","pos":[7065,7142]},{"content":"The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.","pos":[7143,7286]},{"content":"This can be used as a DOS attack.","pos":[7287,7320]},{"content":"This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.","pos":[7322,7410]},{"content":"Care must be taken while setting this quota in order to prevent such attacks.","pos":[7411,7488]},{"content":"This quota puts an upper limit on the size of WCF message.","pos":[7489,7547]},{"content":"Additionally, avoid using hashtables or collections in your data contracts.","pos":[7548,7623]},{"pos":[7628,7673],"content":"Limiting Memory Consumption Without Streaming","linkify":"Limiting Memory Consumption Without Streaming","nodes":[{"content":"Limiting Memory Consumption Without Streaming","pos":[0,45]}]},{"content":"The security model around large messages depends on whether streaming is in use.","pos":[7675,7755]},{"content":"In the basic, non-streamed case, messages are buffered into memory.","pos":[7756,7823]},{"content":"In this case, use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A&gt;</ph> quota on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement&gt;</ph> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.","pos":[7824,8121],"source":" In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access."},{"content":"Note that a service may be processing multiple messages at the same time, in which case they are all in memory.","pos":[8122,8233]},{"content":"Use the throttling feature to mitigate this threat.","pos":[8234,8285]},{"content":"Also note that <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.","pos":[8287,8434],"source":"Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor."},{"content":"For example, if the <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.","pos":[8435,8667],"source":" For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB."},{"content":"For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.","pos":[8668,8798]},{"content":"For example, a data contract \"MyContract\" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction \"<ph id=\"ph1\">\\&lt;</ph>MyContract/&gt;\".","pos":[8799,8979],"source":" For example, a data contract \"MyContract\" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction \"\\<MyContract/>\"."},{"content":"This XML results in memory being accessed for 150 fields.","pos":[8980,9037]},{"content":"Note that data members are optional by default.","pos":[9038,9085]},{"content":"The problem is compounded when such a type is part of an array.","pos":[9086,9149]},{"content":"<ph id=\"ph1\">`MaxReceivedMessageSize`</ph> alone is not enough to prevent all denial-of-service attacks.","pos":[9151,9237],"source":"`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks."},{"content":"For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.","pos":[9238,9431]},{"content":"Both the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> call methods in a nested way to deserialize such graphs.","pos":[9432,9610],"source":" Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs."},{"content":"Deep nesting of method calls may result in an unrecoverable <ph id=\"ph1\">&lt;xref:System.StackOverflowException&gt;</ph>.","pos":[9611,9708],"source":" Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>."},{"content":"This threat is mitigated by setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A&gt;</ph> quota to limit the level of XML nesting, as discussed in the \"Using XML Safely\" section later in the topic.","pos":[9709,9942],"source":" This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the \"Using XML Safely\" section later in the topic."},{"content":"Setting additional quotas to <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> is especially important when using binary XML encoding.","pos":[9944,10053],"source":"Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding."},{"content":"Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.","pos":[10054,10190]},{"content":"Thus, even a message fitting into the <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> limit may take up much more memory in fully expanded form.","pos":[10191,10312],"source":" Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form."},{"content":"To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the \"Using XML Safely\" section later in this topic.","pos":[10313,10471]},{"pos":[10476,10518],"content":"Limiting Memory Consumption with Streaming","linkify":"Limiting Memory Consumption with Streaming","nodes":[{"content":"Limiting Memory Consumption with Streaming","pos":[0,42]}]},{"content":"When streaming, you may use a small <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> setting to protect against denial-of-service attacks.","pos":[10520,10634],"source":"When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks."},{"content":"However, more complicated scenarios are possible with streaming.","pos":[10635,10699]},{"content":"For example, a file upload service accepts files larger than all available memory.","pos":[10700,10782]},{"content":"In this case, set the <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.","pos":[10783,10952],"source":" In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk."},{"content":"If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> no longer protects against the message accessing all available memory.","pos":[10953,11146],"source":" If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory."},{"content":"To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.","pos":[11148,11266]},{"content":"The most important of these is the <ph id=\"ph1\">`MaxBufferSize`</ph> property on various transport binding elements and standard bindings.","pos":[11267,11387],"source":" The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings."},{"content":"When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.","pos":[11388,11518]},{"content":"As with <ph id=\"ph1\">`MaxReceivedMessageSize`</ph>, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.","pos":[11519,11667],"source":" As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor."},{"content":"Also, as with <ph id=\"ph1\">`MaxReceivedMessageSize`</ph>, be aware of the possibility of multiple messages being processed simultaneously.","pos":[11668,11788],"source":" Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously."},{"pos":[11794,11815],"content":"MaxBufferSize Details","linkify":"MaxBufferSize Details","nodes":[{"content":"MaxBufferSize Details","pos":[0,21]}]},{"content":"The <ph id=\"ph1\">`MaxBufferSize`</ph> property limits any bulk buffering WCF does.","pos":[11817,11881],"source":"The `MaxBufferSize` property limits any bulk buffering WCF does."},{"content":"For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.","pos":[11882,12080]},{"content":"This setting limits the amount of buffering in all these cases.","pos":[12081,12144]},{"content":"WCF accomplishes this by passing the <ph id=\"ph1\">`MaxBufferSize`</ph> value to the various components that may buffer.","pos":[12146,12247],"source":"WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer."},{"content":"For example, some <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.CreateMessage%2A&gt;</ph> overloads of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class take a <ph id=\"ph3\">`maxSizeOfHeaders`</ph> parameter.","pos":[12248,12430],"source":" For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter."},{"content":"WCF passes the <ph id=\"ph1\">`MaxBufferSize`</ph> value to this parameter to limit the amount of SOAP header buffering.","pos":[12431,12531],"source":" WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering."},{"content":"It is important to set this parameter when using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class directly.","pos":[12532,12644],"source":" It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly."},{"content":"In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.","pos":[12645,12815]},{"content":"The MTOM message encoder also has a <ph id=\"ph1\">`MaxBufferSize`</ph> setting.","pos":[12817,12877],"source":"The MTOM message encoder also has a `MaxBufferSize` setting."},{"content":"When using standard bindings, this is set automatically to the transport-level <ph id=\"ph1\">`MaxBufferSize`</ph> value.","pos":[12878,12979],"source":" When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value."},{"content":"However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the <ph id=\"ph1\">`MaxBufferSize`</ph> property to a safe value when streaming is used.","pos":[12980,13163],"source":" However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used."},{"pos":[13168,13195],"content":"XML-Based Streaming Attacks","linkify":"XML-Based Streaming Attacks","nodes":[{"content":"XML-Based Streaming Attacks","pos":[0,27]}]},{"content":"<ph id=\"ph1\">`MaxBufferSize`</ph> alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.","pos":[13197,13311],"source":"`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected."},{"content":"For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.","pos":[13312,13428]},{"content":"This is done so that namespaces and attributes are properly processed.","pos":[13429,13499]},{"content":"If <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.","pos":[13500,13729],"source":" If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag."},{"content":"An attempt to read it results in an <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph>.","pos":[13730,13801],"source":" An attempt to read it results in an <xref:System.OutOfMemoryException>."},{"content":"This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the \"Using XML Safely\" section later in this topic.","pos":[13802,13982]},{"content":"When streaming, it is especially important to set all of these quotas.","pos":[13983,14053]},{"pos":[14059,14108],"content":"Mixing Streaming and Buffering Programming Models","linkify":"Mixing Streaming and Buffering Programming Models","nodes":[{"content":"Mixing Streaming and Buffering Programming Models","pos":[0,49]}]},{"content":"Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.","pos":[14110,14217]},{"content":"Suppose there is a service contract with two operations: one takes a <ph id=\"ph1\">&lt;xref:System.IO.Stream&gt;</ph> and another takes an array of some custom type.","pos":[14218,14358],"source":" Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type."},{"content":"Suppose also that <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> is set to a large value to enable the first operation to process large streams.","pos":[14359,14481],"source":" Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams."},{"content":"Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.","pos":[14482,14664]},{"content":"This is a potential denial-of-service attack: the <ph id=\"ph1\">`MaxBufferSize`</ph> quota does not limit the size of the message body, which is what the deserializer works with.","pos":[14665,14824],"source":" This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with."},{"content":"For this reason, avoid mixing stream-based and non-streamed operations in the same contract.","pos":[14826,14918]},{"content":"If you absolutely must mix the two programming models, use the following precautions:","pos":[14919,15004]},{"content":"Turn off the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> feature by setting the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A&gt;</ph> property of the <ph id=\"ph3\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph> to <ph id=\"ph4\">`true`</ph>.","pos":[15008,15261],"source":"Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`."},{"content":"This ensures that only members that are a part of the contract are deserialized.","pos":[15262,15342]},{"content":"Set the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> to a safe value.","pos":[15346,15529],"source":"Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value."},{"content":"This quota is also available on the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute&gt;</ph> attribute or through configuration.","pos":[15530,15653],"source":" This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration."},{"content":"This quota limits the number of objects that are deserialized in one deserialization episode.","pos":[15654,15747]},{"content":"Normally, each operation parameter or message body part in a message contract is deserialized in one episode.","pos":[15748,15857]},{"content":"When deserializing arrays, each array entry is counted as a separate object.","pos":[15858,15934]},{"content":"Set all of the XML reader quotas to safe values.","pos":[15938,15986]},{"content":"Pay attention to <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A&gt;</ph> and avoid strings in non-streaming operations.","pos":[15987,16244],"source":" Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations."},{"content":"Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the \"Preventing Unintended Types from Being Loaded\" section later in this topic).","pos":[16248,16435]},{"content":"Do not use any types that implement the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface that buffer a lot of data.","pos":[16439,16564],"source":"Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data."},{"content":"Do not add such types to the list of known types.","pos":[16565,16614]},{"pos":[16618,16812],"content":"Do not use the <ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Xml.XmlNode&gt;</ph> arrays, <ph id=\"ph3\">&lt;xref:System.Byte&gt;</ph> arrays, or types that implement <ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> in a contract.","source":"Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract."},{"pos":[16816,17023],"content":"Do not use the <ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Xml.XmlNode&gt;</ph> arrays, <ph id=\"ph3\">&lt;xref:System.Byte&gt;</ph> arrays, or types that implement <ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> in the list of known types.","source":"Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types."},{"content":"The preceding precautions apply when the non-streamed operation uses the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.","pos":[17025,17157],"source":"The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>."},{"content":"Never mix streaming and non-streaming programming models on the same service if you are using the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, because it does not have the protection of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A&gt;</ph> quota.","pos":[17158,17460],"source":" Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota."},{"pos":[17466,17485],"content":"Slow Stream Attacks","linkify":"Slow Stream Attacks","nodes":[{"content":"Slow Stream Attacks","pos":[0,19]}]},{"content":"A class of streaming denial-of-service attacks does not involve memory consumption.","pos":[17487,17570]},{"content":"Instead, the attack involves a slow sender or receiver of data.","pos":[17571,17634]},{"content":"While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.","pos":[17635,17752]},{"content":"This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.","pos":[17753,17887]},{"content":"To mitigate these attacks, set the transport time-outs correctly.","pos":[17889,17954]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Transport Quotas<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/transport-quotas.md)</ept>.","pos":[17955,18068],"source":" For more information, see [Transport Quotas](../../../../docs/framework/wcf/feature-details/transport-quotas.md)."},{"content":"Secondly, never use synchronous <ph id=\"ph1\">`Read`</ph> or <ph id=\"ph2\">`Write`</ph> operations when working with streams in WCF.","pos":[18069,18163],"source":" Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF."},{"pos":[18168,18184],"content":"Using XML Safely","linkify":"Using XML Safely","nodes":[{"content":"Using XML Safely","pos":[0,16]}]},{"pos":[18188,18455],"content":"[!NOTE]\nAlthough this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents. The quotas work similarly, using [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).","leadings":["","> "],"nodes":[{"content":"Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents. The quotas work similarly, using [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).","pos":[8,265],"nodes":[{"content":"Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.","pos":[0,112]},{"content":"The quotas work similarly, using <bpt id=\"p1\">[</bpt>Mapping Between JSON and XML<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)</ept>.","pos":[113,257],"source":" The quotas work similarly, using [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)."}]}]},{"pos":[18461,18479],"content":"Secure XML Readers","linkify":"Secure XML Readers","nodes":[{"content":"Secure XML Readers","pos":[0,18]}]},{"content":"The XML Infoset forms the basis of all message processing in WCF.","pos":[18481,18546]},{"content":"When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.","pos":[18547,18677]},{"content":"WCF provides special, secure XML readers.","pos":[18678,18719]},{"content":"These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).","pos":[18720,18832]},{"content":"Some of the security features on these readers are always active.","pos":[18834,18899]},{"content":"For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.","pos":[18900,19083]},{"content":"Other security features include reader quotas that must be configured, which are described in the following section.","pos":[19084,19200]},{"content":"When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class), always use the WCF secure readers when there is a chance of working with untrusted data.","pos":[19202,19461],"source":"When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data."},{"content":"Create the secure readers by calling one of the static factory method overloads of <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A&gt;</ph> on the <ph id=\"ph4\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> class.","pos":[19462,19777],"source":" Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class."},{"content":"When creating a reader, pass in secure quota values.","pos":[19778,19830]},{"content":"Do not call the <ph id=\"ph1\">`Create`</ph> method overloads.","pos":[19831,19873],"source":" Do not call the `Create` method overloads."},{"content":"These do not create a WCF reader.","pos":[19874,19907]},{"content":"Instead, a reader is created that is not protected by the security features described in this section.","pos":[19908,20010]},{"pos":[20016,20029],"content":"Reader Quotas","linkify":"Reader Quotas","nodes":[{"content":"Reader Quotas","pos":[0,13]}]},{"content":"The secure XML readers have five configurable quotas.","pos":[20031,20084]},{"content":"These are normally configured using the <ph id=\"ph1\">`ReaderQuotas`</ph> property on the encoding binding elements or standard bindings, or by using an <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas&gt;</ph> object passed when creating a reader.","pos":[20085,20300],"source":" These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader."},{"pos":[20307,20322],"content":"MaxBytesPerRead","linkify":"MaxBytesPerRead","nodes":[{"content":"MaxBytesPerRead","pos":[0,15]}]},{"content":"This quota limits the number of bytes that are read in a single <ph id=\"ph1\">`Read`</ph> operation when reading the element start tag and its attributes.","pos":[20324,20459],"source":"This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes."},{"content":"(In non-streamed cases, the element name itself is not counted against the quota.) <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A&gt;</ph> is important for the following reasons:","pos":[20460,20645],"source":" (In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:"},{"content":"The element name and its attributes are always buffered in memory when they are being read.","pos":[20649,20740]},{"content":"Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.","pos":[20741,20872]},{"content":"See the <ph id=\"ph1\">`MaxDepth`</ph> quota section for information about the actual amount of buffering that takes place.","pos":[20873,20976],"source":" See the `MaxDepth` quota section for information about the actual amount of buffering that takes place."},{"content":"Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.","pos":[20980,21113]},{"content":"<ph id=\"ph1\">`MaxBytesPerRead`</ph> mitigates this threat.","pos":[21114,21154],"source":"`MaxBytesPerRead` mitigates this threat."},{"pos":[21161,21169],"content":"MaxDepth","linkify":"MaxDepth","nodes":[{"content":"MaxDepth","pos":[0,8]}]},{"content":"This quota limits the maximum nesting depth of XML elements.","pos":[21171,21231]},{"content":"For example, the document \"<ph id=\"ph1\">\\&lt;</ph>A&gt;<ph id=\"ph2\">\\&lt;</ph>B&gt;<ph id=\"ph3\">\\&lt;</ph>C/&gt;<ph id=\"ph4\">\\&lt;</ph>/B&gt;<ph id=\"ph5\">\\&lt;</ph>/A&gt;\" has a nesting depth of three.","pos":[21232,21313],"source":" For example, the document \"\\<A>\\<B>\\<C/>\\</B>\\</A>\" has a nesting depth of three."},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A&gt;</ph> is important for the following reasons:","pos":[21314,21409],"source":"<xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:"},{"pos":[21413,21648],"content":"<ph id=\"ph1\">`MaxDepth`</ph> interacts with <ph id=\"ph2\">`MaxBytesPerRead`</ph>: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.","source":"`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings."},{"content":"When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <ph id=\"ph1\">&lt;xref:System.StackOverflowException&gt;</ph>.","pos":[21652,21819],"source":"When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>."},{"content":"A direct correlation exists between XML nesting and object nesting for both the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.","pos":[21820,22013],"source":" A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>."},{"content":"Use <ph id=\"ph1\">`MaxDepth`</ph> to mitigate this threat.","pos":[22014,22053],"source":" Use `MaxDepth` to mitigate this threat."},{"pos":[22060,22081],"content":"MaxNameTableCharCount","linkify":"MaxNameTableCharCount","nodes":[{"content":"MaxNameTableCharCount","pos":[0,21]}]},{"content":"This quota limits the size of the reader’s <bpt id=\"p1\">*</bpt>nametable<ept id=\"p1\">*</ept>.","pos":[22083,22138],"source":"This quota limits the size of the reader’s *nametable*."},{"content":"The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.","pos":[22139,22265]},{"content":"As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.","pos":[22266,22380]},{"pos":[22387,22409],"content":"MaxStringContentLength","linkify":"MaxStringContentLength","nodes":[{"content":"MaxStringContentLength","pos":[0,22]}]},{"content":"This quota limits the maximum string size that the XML reader returns.","pos":[22411,22481]},{"content":"This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.","pos":[22482,22599]},{"content":"For example, when the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> uses a reader secured with <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A&gt;</ph>, it does not deserialize strings larger than this quota.","pos":[22600,22834],"source":" For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota."},{"content":"When using the <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A&gt;</ph> method.","pos":[22835,23089],"source":" When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.XmlReader.Value%2A&gt;</ph> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.","pos":[23090,23266],"source":" The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary."},{"pos":[23273,23287],"content":"MaxArrayLength","linkify":"MaxArrayLength","nodes":[{"content":"MaxArrayLength","pos":[0,14]}]},{"content":"This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.","pos":[23289,23401]},{"content":"This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.","pos":[23402,23524]},{"content":"For example, when the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> uses a reader secured with <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A&gt;</ph>, it does not deserialize byte arrays larger than this quota.","pos":[23525,23755],"source":" For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota."},{"content":"It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.","pos":[23756,23876]},{"content":"Keep in mind that when using the <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A&gt;</ph>, respect this quota.","pos":[23877,24157],"source":" Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota."},{"pos":[24162,24201],"content":"Threats Specific to the Binary Encoding","linkify":"Threats Specific to the Binary Encoding","nodes":[{"content":"Threats Specific to the Binary Encoding","pos":[0,39]}]},{"content":"The binary XML encoding WCF supports includes a <bpt id=\"p1\">*</bpt>dictionary strings<ept id=\"p1\">*</ept> feature.","pos":[24203,24280],"source":"The binary XML encoding WCF supports includes a *dictionary strings* feature."},{"content":"A large string may be encoded using only a few bytes.","pos":[24281,24334]},{"content":"This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.","pos":[24335,24447]},{"content":"There are two kinds of dictionaries: <bpt id=\"p1\">*</bpt>static<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>dynamic<ept id=\"p2\">*</ept>.","pos":[24449,24509],"source":"There are two kinds of dictionaries: *static* and *dynamic*."},{"content":"The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.","pos":[24510,24633]},{"content":"This list of strings is fixed when the reader is created and cannot be modified.","pos":[24634,24714]},{"content":"None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.","pos":[24715,24917]},{"content":"In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.","pos":[24918,25038]},{"content":"The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.","pos":[25040,25153]},{"content":"These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.","pos":[25154,25355]},{"content":"These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.","pos":[25356,25469]},{"content":"The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.","pos":[25471,25610]},{"content":"This dictionary may be expanded over the course of several messages, and so the <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> quota offers no protection because it applies only to each message separately.","pos":[25611,25794],"source":" This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately."},{"content":"Therefore, a separate <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A&gt;</ph> property exists on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement&gt;</ph> that limits the size of the dictionary.","pos":[25795,26041],"source":" Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary."},{"content":"Unlike most other quotas, this quota also applies when writing messages.","pos":[26043,26115]},{"content":"If it is exceeded when reading a message, the <ph id=\"ph1\">`QuotaExceededException`</ph> is thrown as usual.","pos":[26116,26206],"source":" If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual."},{"content":"If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.","pos":[26207,26363]},{"pos":[26369,26397],"content":"Dictionary Expansion Threats","linkify":"Dictionary Expansion Threats","nodes":[{"content":"Dictionary Expansion Threats","pos":[0,28]}]},{"content":"A significant class of binary-specific attacks arises from dictionary expansion.","pos":[26399,26479]},{"content":"A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.","pos":[26480,26638]},{"content":"The expansion factor for dynamic dictionary strings is limited by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A&gt;</ph> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.","pos":[26639,26893],"source":" The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A&gt;</ph>, <ph id=\"ph2\">`MaxStringContentLength`</ph>, and <ph id=\"ph3\">`MaxArrayLength`</ph> properties only limit memory consumption.","pos":[26895,27057],"source":"The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption."},{"content":"They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by <ph id=\"ph1\">`MaxReceivedMessageSize`</ph>.","pos":[27058,27207],"source":" They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`."},{"content":"However, <ph id=\"ph1\">`MaxReceivedMessageSize`</ph> counts pre-expansion bytes.","pos":[27208,27269],"source":" However, `MaxReceivedMessageSize` counts pre-expansion bytes."},{"content":"When binary encoding is in use, memory consumption could potentially go beyond <ph id=\"ph1\">`MaxReceivedMessageSize`</ph>, limited only by a factor of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A&gt;</ph>.","pos":[27270,27493],"source":" When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>."},{"content":"For this reason, it is important to always set all of the reader quotas (especially <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A&gt;</ph>) when using the binary encoding.","pos":[27494,27680],"source":" For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding."},{"content":"When using binary encoding together with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, the <ph id=\"ph2\">`IExtensibleDataObject`</ph> interface can be misused to mount a dictionary expansion attack.","pos":[27682,27879],"source":"When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack."},{"content":"This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.","pos":[27880,27988]},{"content":"If quotas cannot be set low enough such that <ph id=\"ph1\">`MaxSessionSize`</ph> multiplied by <ph id=\"ph2\">`MaxReceivedMessageSize`</ph> does not pose a problem, disable the <ph id=\"ph3\">`IExtensibleDataObject`</ph> feature when using the binary encoding.","pos":[27989,28190],"source":" If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding."},{"content":"Set the <ph id=\"ph1\">`IgnoreExtensionDataObject`</ph> property to <ph id=\"ph2\">`true`</ph> on the <ph id=\"ph3\">`ServiceBehaviorAttribute`</ph> attribute.","pos":[28191,28290],"source":" Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute."},{"content":"Alternatively, do not implement the <ph id=\"ph1\">`IExtensibleDataObject`</ph> interface.","pos":[28291,28361],"source":" Alternatively, do not implement the `IExtensibleDataObject` interface."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>.","pos":[28362,28509],"source":" For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)."},{"pos":[28515,28529],"content":"Quotas Summary","linkify":"Quotas Summary","nodes":[{"content":"Quotas Summary","pos":[0,14]}]},{"content":"The following table summarizes the guidance about quotas.","pos":[28531,28588]},{"content":"Condition","pos":[28591,28600]},{"content":"Important quotas to set","pos":[28601,28624]},{"content":"No streaming or streaming small messages, text, or MTOM encoding","pos":[28675,28739]},{"pos":[28740,28799],"content":"<ph id=\"ph1\">`MaxReceivedMessageSize`</ph>, <ph id=\"ph2\">`MaxBytesPerRead`</ph>, and <ph id=\"ph3\">`MaxDepth`</ph>","source":"`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`"},{"content":"No streaming or streaming small messages, binary encoding","pos":[28802,28859]},{"pos":[28860,28926],"content":"<ph id=\"ph1\">`MaxReceivedMessageSize`</ph>, <ph id=\"ph2\">`MaxSessionSize`</ph>, and all <ph id=\"ph3\">`ReaderQuotas`</ph>","source":"`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`"},{"content":"Streaming large messages, text, or MTOM encoding","pos":[28929,28977]},{"pos":[28978,29016],"content":"<ph id=\"ph1\">`MaxBufferSize`</ph> and all <ph id=\"ph2\">`ReaderQuotas`</ph>","source":"`MaxBufferSize` and all `ReaderQuotas`"},{"content":"Streaming large messages, binary encoding","pos":[29019,29060]},{"pos":[29061,29118],"content":"<ph id=\"ph1\">`MaxBufferSize`</ph>, <ph id=\"ph2\">`MaxSessionSize`</ph>, and all <ph id=\"ph3\">`ReaderQuotas`</ph>","source":"`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`"},{"content":"Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.","pos":[29123,29297]},{"content":"When in doubt about a quota, set it to a safe value rather than leaving it open.","pos":[29301,29381]},{"pos":[29386,29421],"content":"Preventing Malicious Code Execution","linkify":"Preventing Malicious Code Execution","nodes":[{"content":"Preventing Malicious Code Execution","pos":[0,35]}]},{"content":"The following general classes of threats can execute code and have unintended effects:","pos":[29423,29509]},{"content":"The deserializer loads a malicious, unsafe, or security-sensitive type.","pos":[29513,29584]},{"content":"An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.","pos":[29588,29731]},{"content":"The following sections discuss these classes of threats further.","pos":[29733,29797]},{"pos":[29802,29824],"content":"DataContractSerializer","linkify":"DataContractSerializer","nodes":[{"content":"DataContractSerializer","pos":[0,22]}]},{"content":"(For security information on the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, see the relevant documentation.) The security model for the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> is similar to that of the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, and differs mostly in details.","pos":[29826,30128],"source":"(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlIncludeAttribute&gt;</ph> attribute is used for type inclusion instead of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute.","pos":[30129,30315],"source":" For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute."},{"content":"However, some threats unique to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> are discussed later in this topic.","pos":[30316,30432],"source":" However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic."},{"pos":[30438,30483],"content":"Preventing Unintended Types from Being Loaded","linkify":"Preventing Unintended Types from Being Loaded","nodes":[{"content":"Preventing Unintended Types from Being Loaded","pos":[0,45]}]},{"content":"Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.","pos":[30485,30619]},{"content":"A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.","pos":[30620,30865]},{"content":"Types may have class constructors that run as soon as the type is loaded and before any instances are created.","pos":[30866,30976]},{"content":"For these reasons, it is important to control the set of types that the deserializer may load.","pos":[30977,31071]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> deserializes in a loosely coupled way.","pos":[31073,31174],"source":"The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way."},{"content":"It never reads common language runtime (CLR) type and assembly names from the incoming data.","pos":[31175,31267]},{"content":"This is similar to the behavior of the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, but differs from the behavior of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph>, and the <ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter&gt;</ph>.","pos":[31268,31599],"source":" This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>."},{"content":"Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.","pos":[31600,31756]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is always allowed to load a type that is currently expected according to the contract.","pos":[31758,31907],"source":"The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract."},{"content":"For example, if a data contract has a data member of type <ph id=\"ph1\">`Customer`</ph>, the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is allowed to load the <ph id=\"ph3\">`Customer`</ph> type when it deserializes this data member.","pos":[31908,32118],"source":" For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member."},{"content":"Additionally, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> supports polymorphism.","pos":[32120,32219],"source":"Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism."},{"content":"A data member may be declared as <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, but the incoming data may contain a <ph id=\"ph2\">`Customer`</ph> instance.","pos":[32220,32331],"source":" A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance."},{"content":"This is possible only if the <ph id=\"ph1\">`Customer`</ph> type has been made \"known\" to the deserializer through one of these mechanisms:","pos":[32332,32451],"source":" This is possible only if the `Customer` type has been made \"known\" to the deserializer through one of these mechanisms:"},{"pos":[32455,32538],"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute applied to a type.","source":"<xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type."},{"pos":[32542,32622],"content":"<ph id=\"ph1\">`KnownTypeAttribute`</ph> attribute specifying a method that returns a list of types.","source":"`KnownTypeAttribute` attribute specifying a method that returns a list of types."},{"pos":[32626,32664],"content":"<ph id=\"ph1\">`ServiceKnownTypeAttribute`</ph> attribute.","source":"`ServiceKnownTypeAttribute` attribute."},{"pos":[32668,32707],"content":"The <ph id=\"ph1\">`KnownTypes`</ph> configuration section.","source":"The `KnownTypes` configuration section."},{"pos":[32711,32871],"content":"A list of known types explicitly passed to the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> during construction, if using the serializer directly.","source":"A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly."},{"content":"Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.","pos":[32873,32982]},{"content":"Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.","pos":[32983,33093]},{"content":"Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.","pos":[33095,33245]},{"content":"For example, suppose the type \"MyDangerousType\" is added to the known types list using one of the mechanisms above.","pos":[33246,33361]},{"content":"This means that:","pos":[33362,33378]},{"pos":[33382,33441],"content":"<ph id=\"ph1\">`MyDangerousType`</ph> is loaded and its class constructor runs.","source":"`MyDangerousType` is loaded and its class constructor runs."},{"content":"Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of <ph id=\"ph1\">`MyDangerousType`</ph> to create.","pos":[33445,33591],"source":"Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create."},{"content":"Code in <ph id=\"ph1\">`MyDangerousType`</ph>, such as property setters, may run.","pos":[33592,33653],"source":" Code in `MyDangerousType`, such as property setters, may run."},{"content":"After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.","pos":[33654,33774]},{"pos":[33776,34033],"content":"When writing a method that returns a list of known types, or when passing a list directly to the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.","source":"When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data."},{"content":"If specifying known types in configuration, ensure that the configuration file is secure.","pos":[34035,34124]},{"content":"Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.","pos":[34125,34295]},{"content":"The type loader automatically picks the latest version, if possible.","pos":[34296,34364]},{"content":"If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.","pos":[34365,34618]},{"content":"Having too many known types has another consequence: The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.","pos":[34620,34879],"source":"Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize."},{"content":"This cache is never cleared as long as the application domain is running.","pos":[34880,34953]},{"content":"Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.","pos":[34954,35155]},{"pos":[35161,35211],"content":"Preventing Types from Being in an Unintended State","linkify":"Preventing Types from Being in an Unintended State","nodes":[{"content":"Preventing Types from Being in an Unintended State","pos":[0,50]}]},{"content":"A type may have internal consistency constraints that must be enforced.","pos":[35213,35284]},{"content":"Care must be taken to avoid breaking these constraints during deserialization.","pos":[35285,35363]},{"content":"The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.","pos":[35365,35549]},{"content":"An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.","pos":[35817,36003]},{"content":"This situation can be avoided by being aware of the following points:","pos":[36142,36211]},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> deserializes most classes, constructors do not run.","pos":[36215,36334],"source":"When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run."},{"content":"Therefore, do not rely on any state management done in the constructor.","pos":[36335,36406]},{"content":"Use callbacks to ensure that the object is in a valid state.","pos":[36410,36470]},{"content":"The callback marked with the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.OnDeserializedAttribute&gt;</ph> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.","pos":[36471,36699],"source":" The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Version-Tolerant Serialization Callbacks<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)</ept>.","pos":[36700,36861],"source":" For more information, see [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)."},{"content":"Do not design data contract types to rely on any particular order in which property setters must be called.","pos":[36865,36972]},{"content":"Take care using legacy types marked with the <ph id=\"ph1\">&lt;xref:System.SerializableAttribute&gt;</ph> attribute.","pos":[36976,37067],"source":"Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute."},{"content":"Many of them were designed to work with <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> remoting for use with trusted data only.","pos":[37068,37212],"source":" Many of them were designed to work with [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting for use with trusted data only."},{"content":"Existing types marked with this attribute may not have been designed with state safety in mind.","pos":[37213,37308]},{"content":"Do not rely on the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attribute to guarantee presence of data as far as state safety is concerned.","pos":[37312,37549],"source":"Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned."},{"content":"Data could always be <ph id=\"ph1\">`null`</ph>, <ph id=\"ph2\">`zero`</ph>, or <ph id=\"ph3\">`invalid`</ph>.","pos":[37550,37600],"source":" Data could always be `null`, `zero`, or `invalid`."},{"content":"Never trust an object graph deserialized from an untrusted data source without validating it first.","pos":[37604,37703]},{"content":"Each individual object may be in a consistent state, but the object graph as a whole may not be.","pos":[37704,37800]},{"content":"Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.","pos":[37801,37969]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.","pos":[37970,38117],"source":" For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)."},{"pos":[38123,38167],"content":"Using the NetDataContractSerializer Securely","linkify":"Using the NetDataContractSerializer Securely","nodes":[{"content":"Using the NetDataContractSerializer Securely","pos":[0,44]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> is a serialization engine that uses tight coupling to types.","pos":[38169,38295],"source":"The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types."},{"content":"This is similar to the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter&gt;</ph>.","pos":[38296,38463],"source":" This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>."},{"content":"That is, it determines which type to instantiate by reading the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> assembly and type name from the incoming data.","pos":[38464,38638],"source":" That is, it determines which type to instantiate by reading the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] assembly and type name from the incoming data."},{"content":"Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.","pos":[38639,38764]},{"content":"The <ph id=\"ph1\">`NetDataContractSerializer`</ph> is provided primarily to ease migration from <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> remoting to WCF.","pos":[38765,38922],"source":" The `NetDataContractSerializer` is provided primarily to ease migration from [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting to WCF."},{"content":"For more information, see the relevant section in <bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.","pos":[38923,39094],"source":" For more information, see the relevant section in [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)."},{"content":"Because the message itself may indicate any type can be loaded, the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> mechanism is inherently insecure and should be used only with trusted data.","pos":[39096,39301],"source":"Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data."},{"content":"It is possible to make it secure by writing a secure, type-limiting type binder that allows only safe types to load (using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A&gt;</ph> property).","pos":[39302,39511],"source":" It is possible to make it secure by writing a secure, type-limiting type binder that allows only safe types to load (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property)."},{"content":"Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A&gt;</ph> property is set to <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple&gt;</ph>.","pos":[39513,39804],"source":"Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>."},{"content":"Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.","pos":[39805,39964]},{"content":"Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.","pos":[39965,40090]},{"content":"In general, if you allow partially trusted code access to your <ph id=\"ph1\">`NetDataContractSerializer`</ph> instance or otherwise control the surrogate selector (<ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.ISurrogateSelector&gt;</ph>) or the serialization binder (<ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.SerializationBinder&gt;</ph>), the code may exercise a great deal of control over the serialization/deserialization process.","pos":[40092,40473],"source":"In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process."},{"content":"For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.","pos":[40474,40653]},{"content":"Another security concern with the <ph id=\"ph1\">`NetDataContractSerializer`</ph> is a denial of service, not a malicious code execution threat.","pos":[40655,40779],"source":"Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat."},{"content":"When using the <ph id=\"ph1\">`NetDataContractSerializer`</ph>, always set the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A&gt;</ph> quota to a safe value.","pos":[40780,40948],"source":" When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value."},{"content":"It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.","pos":[40949,41075]},{"pos":[41081,41111],"content":"XmlSerializer-Specific Threats","linkify":"XmlSerializer-Specific Threats","nodes":[{"content":"XmlSerializer-Specific Threats","pos":[0,30]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> security model is similar to that of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.","pos":[41113,41263],"source":"The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>."},{"content":"A few threats, however, are unique to the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>.","pos":[41264,41352],"source":" A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> generates <bpt id=\"p1\">*</bpt>serialization assemblies<ept id=\"p1\">*</ept> at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.","pos":[41354,41573],"source":"The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory."},{"content":"If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.","pos":[41574,41719]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> then runs this code using its security context, instead of the serialization/deserialization code.","pos":[41720,41868],"source":" The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code."},{"content":"Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.","pos":[41869,41977]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.","pos":[41979,42139],"source":"The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime."},{"content":"This mode is triggered whenever the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> can find a suitable serialization assembly.","pos":[42140,42265],"source":" This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.","pos":[42266,42468],"source":" The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized."},{"content":"This offers protection from malicious assemblies being disguised as serialization assemblies.","pos":[42469,42562]},{"content":"However, if the assembly that contains your serializable types is not signed, the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> cannot perform this check and uses any assembly with the correct name.","pos":[42563,42761],"source":" However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name."},{"content":"This makes running malicious code possible.","pos":[42762,42805]},{"content":"Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.","pos":[42806,43011]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> can be subject to a denial of service attack.","pos":[43013,43108],"source":"The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> does not have a <ph id=\"ph2\">`MaxItemsInObjectGraph`</ph> quota (as is available on the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>).","pos":[43109,43289],"source":" The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>)."},{"content":"Thus, it deserializes an arbitrary amount of objects, limited only by the message size.","pos":[43290,43377]},{"pos":[43383,43404],"content":"Partial Trust Threats","linkify":"Partial Trust Threats","nodes":[{"content":"Partial Trust Threats","pos":[0,21]}]},{"content":"Note the following concerns regarding threats related to code running with partial trust.","pos":[43406,43495]},{"content":"These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).","pos":[43496,43736]},{"content":"When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.","pos":[43740,43966]},{"content":"Such usage may lead to security vulnerabilities.","pos":[43967,44015]},{"content":"In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.","pos":[44019,44383]},{"content":"If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.","pos":[44384,44571]},{"content":"If you allow partially-trusted code access to your <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> instance or otherwise control the <bpt id=\"p1\">[</bpt>Data Contract Surrogates<ept id=\"p1\">](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)</ept>, it may exercise a great deal of control over the serialization/deserialization process.","pos":[44575,44904],"source":"If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process."},{"content":"For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.","pos":[44905,45084]},{"content":"An equivalent <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> threat is described in the \"Using the NetDataContractSerializer Securely\" section.","pos":[45085,45243],"source":" An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the \"Using the NetDataContractSerializer Securely\" section."},{"pos":[45247,45584],"content":"If the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute is applied to a type (or the type marked as <ph id=\"ph2\">&lt;xref:System.SerializableAttribute&gt;</ph> but is not <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.","source":"If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands."},{"content":"Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.","pos":[45588,45742]},{"content":"Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.","pos":[45743,45905]},{"pos":[45909,46103],"content":"If you pass a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.","source":"If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate."},{"content":"For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.","pos":[46107,46267]},{"content":"The fact that the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ExtensionDataObject&gt;</ph> type has no public members does not mean that data within it is secure.","pos":[46271,46416],"source":"The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure."},{"content":"For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the <ph id=\"ph1\">`ExtensionDataObject`</ph> by serializing the object.","pos":[46417,46671],"source":" For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object."},{"content":"Consider setting <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A&gt;</ph> to <ph id=\"ph2\">`true`</ph> when deserializing from a privileged data source into an object that is later passed to partially-trusted code.","pos":[46672,46898],"source":" Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.Json.DataContractJsonSerializer&gt;</ph> support the serialization of private, protected, internal, and public members in full trust.","pos":[46902,47125],"source":"<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust."},{"content":"However, in partial trust, only public members can be serialized.","pos":[47126,47191]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if an application attempts to serialize a non-public member.","pos":[47192,47305],"source":" A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member."},{"content":"To allow internal or protected internal members to be serialized in partial trust, use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> assembly attribute.","pos":[47311,47488],"source":"To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute."},{"content":"This attribute allows an assembly to declare that its internal members are visible to some other assembly.","pos":[47489,47595]},{"content":"In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.","pos":[47596,47756]},{"content":"The advantage of this approach is that it does not require an elevated code generation path.","pos":[47762,47854]},{"content":"At the same time, there are two major disadvantages.","pos":[47860,47912]},{"content":"The first disadvantage is that the opt-in property of the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute is assembly-wide.","pos":[47918,48070],"source":"The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide."},{"content":"That is, you cannot specify that only a certain class can have its internal members serialized.","pos":[48071,48166]},{"content":"Of course, you can still choose not to serialize a specific internal member, by simply not adding a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> attribute to that member.","pos":[48167,48348],"source":" Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member."},{"content":"Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.","pos":[48349,48480]},{"content":"The second disadvantage is that it still does not support private or protected members.","pos":[48486,48573]},{"pos":[48579,48734],"content":"To illustrate the use of the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute in partial trust, consider the following program:","source":"To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:"},{"content":"In the example above, <ph id=\"ph1\">`PermissionsHelper.InternetZone`</ph> corresponds to the <ph id=\"ph2\">&lt;xref:System.Security.PermissionSet&gt;</ph> for partial trust.","pos":[48908,49037],"source":"In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust."},{"content":"Now, without the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute&gt;</ph> attribute, the application will fail, throwing a <ph id=\"ph2\">&lt;xref:System.Security.SecurityException&gt;</ph> indicating that non-public members cannot be serialized in partial trust.","pos":[49038,49285],"source":" Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust."},{"content":"However, if we add the following line to the source file, the program runs successfully.","pos":[49291,49379]},{"pos":[49552,49583],"content":"Other State Management Concerns","linkify":"Other State Management Concerns","nodes":[{"content":"Other State Management Concerns","pos":[0,31]}]},{"content":"A few other concerns regarding object state management are worth mentioning:","pos":[49585,49661]},{"content":"When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.","pos":[49665,49795]},{"content":"The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.","pos":[49796,49953]},{"content":"In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.","pos":[49954,50121]},{"content":"This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).","pos":[50122,50315]},{"content":"Using the <ph id=\"ph1\">`IExtensibleDataObject`</ph> feature may cause sensitive data to be emitted.","pos":[50319,50400],"source":"Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted."},{"content":"If you are accepting data from an untrusted source into data contracts with <ph id=\"ph1\">`IExtensibleObjectData`</ph> and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.","pos":[50401,50634],"source":" If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about."},{"content":"Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.","pos":[50635,50761]},{"content":"Avoid this situation by either selectively setting the extension data property to <ph id=\"ph1\">`null`</ph> or by selectively disabling the <ph id=\"ph2\">`IExtensibleObjectData`</ph> feature.","pos":[50762,50915],"source":" Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature."},{"pos":[50920,50933],"content":"Schema Import","linkify":"Schema Import","nodes":[{"content":"Schema Import","pos":[0,13]}]},{"content":"Normally, the process of importing schema to generate types happens only at design time, for example, when using the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept> on a Web service to generate a client class.","pos":[50935,51229],"source":"Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class."},{"content":"However, in more advanced scenarios, you may process schema at runtime.","pos":[51230,51301]},{"content":"Be aware that doing so can expose you to denial-of-service risks.","pos":[51302,51367]},{"content":"Some schema may take a long time to be imported.","pos":[51368,51416]},{"content":"Never use the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> schema import component in such scenarios if schemas are possibly coming from an untrusted source.","pos":[51417,51575],"source":" Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source."},{"pos":[51580,51624],"content":"Threats Specific to ASP.NET AJAX Integration","linkify":"Threats Specific to ASP.NET AJAX Integration","nodes":[{"content":"Threats Specific to ASP.NET AJAX Integration","pos":[0,44]}]},{"content":"When the user implements <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.WebScriptEnablingBehavior&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.WebHttpBehavior&gt;</ph>, WCF exposes an endpoint that can accept both XML and JSON messages.","pos":[51626,51842],"source":"When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages."},{"content":"However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.","pos":[51843,51940]},{"content":"Some quota settings may be appropriate for one reader but too large for the other.","pos":[51941,52023]},{"content":"When implementing <ph id=\"ph1\">`WebScriptEnablingBehavior`</ph>, the user has the option to expose a JavaScript proxy at the endpoint.","pos":[52025,52141],"source":"When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint."},{"content":"The following security issues must be considered:","pos":[52142,52191]},{"content":"Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.","pos":[52195,52321]},{"content":"When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.","pos":[52325,52445]},{"pos":[52450,52470],"content":"A Note on Components","linkify":"A Note on Components","nodes":[{"content":"A Note on Components","pos":[0,20]}]},{"content":"WCF is a flexible and customizable system.","pos":[52472,52514]},{"content":"Most of the contents of this topic focus on the most common WCF usage scenarios.","pos":[52515,52595]},{"content":"However, it is possible to compose components WCF provides in many different ways.","pos":[52596,52678]},{"content":"It is important to understand the security implications of using each component.","pos":[52679,52759]},{"content":"In particular:","pos":[52760,52774]},{"content":"When you must use XML readers, use the readers the <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> class provides as opposed to any other readers.","pos":[52778,52914],"source":"When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers."},{"content":"Safe readers are created using <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A&gt;</ph> methods.","pos":[52915,53135],"source":" Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods."},{"content":"Do not use the <ph id=\"ph1\">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> method.","pos":[53136,53196],"source":" Do not use the <xref:System.Xml.XmlReader.Create%2A> method."},{"content":"Always configure the readers with safe quotas.","pos":[53197,53243]},{"content":"The serialization engines in WCF are secure only when used with secure XML readers from WCF.","pos":[53244,53336]},{"pos":[53340,53565],"content":"When using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> to deserialize potentially untrusted data, always set the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A&gt;</ph> property.","source":"When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property."},{"pos":[53569,53692],"content":"When creating a message, set the <ph id=\"ph1\">`maxSizeOfHeaders`</ph> parameter if <ph id=\"ph2\">`MaxReceivedMessageSize`</ph> does not offer enough protection.","source":"When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection."},{"pos":[53696,53805],"content":"When creating an encoder, always configure the relevant quotas, such as <ph id=\"ph1\">`MaxSessionSize`</ph> and <ph id=\"ph2\">`MaxBufferSize`</ph>.","source":"When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`."},{"content":"When using an XPath message filter, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A&gt;</ph> to limit the amount of XML nodes the filter visits.","pos":[53809,53974],"source":"When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits."},{"content":"Do not use XPath expressions that could take a long time to compute without visiting many nodes.","pos":[53975,54071]},{"content":"In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.","pos":[54075,54198]},{"pos":[54203,54211],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[54364,54468],"content":"<bpt id=\"p1\">[</bpt>Data Contract Known Types<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>","source":"[Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)"}]}