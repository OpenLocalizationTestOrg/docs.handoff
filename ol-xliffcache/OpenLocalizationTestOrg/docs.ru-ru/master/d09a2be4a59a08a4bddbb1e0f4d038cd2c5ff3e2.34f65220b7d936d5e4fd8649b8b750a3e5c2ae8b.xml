{"content":"---\ntitle: \"Limiting Message Distribution\"\nms.date: \"03/30/2017\"\nms.assetid: 8b5ec4b8-1ce9-45ef-bb90-2c840456bcc1\n---\n# Limiting Message Distribution\nPeer Channel is by design a broadcast mesh. Its basic flooding model involves distributing each message sent by any member of a mesh to all other members of that mesh. This is ideal in situations where every message generated by a member is relevant and useful to all other members (for example, a chat room). However, many applications have an occasional need for limiting message distribution. For example, if a new member joins a mesh and wants to retrieve the last message sent through the mesh, this request does not need to be flooded to every member of the mesh. The request could be limited to near neighbors, or locally generated messages can be filtered out. Messages can also be sent to an individual node on the mesh. This topic discusses using Hop Count, a Message Propagation Filter, a local filter, or a direct connection to control how messages are forwarded throughout the mesh, and provides general guidelines for choosing an approach.  \n  \n## Hop Counts  \n The concept of `PeerHopCount` is similar to TTL (Time-To-Live) used in IP protocol. The value of `PeerHopCount` is tied to a message instance, and it specifies how many times a message should be forwarded before being dropped. Each time a message is received by a Peer Channel client, the client examines the message to see if `PeerHopCount` is specified. If it is specified, then the client decrements the hop count value by one before forwarding the message to neighboring nodes. When a client receives a message with a hop count value of zero, the client processes the message, but does not forward the message to neighbors.  \n  \n Hop count may be added to a message by adding `PeerHopCount` as an attribute to the applicable property or field in the implementation of the message class. You can set this to a specific value before sending the message to the mesh. In this manner, you can use hop count to limit distribution of messages throughout the mesh when necessary, potentially avoiding unnecessary message duplication. This is useful in cases where the mesh contains a high amount of redundant data, or for sending a message to immediate neighbors, or neighbors within a few hops.  \n  \n-   For code snippets and related information, see the [Peer Channel blog](https://go.microsoft.com/fwlink/?LinkID=114531).  \n  \n## Message Propagation Filter  \n `MessagePropagationFilter` can be used for customized control of message flooding, especially when the content of the message or other specific scenarios determine propagation. The filter makes propagation decisions for every message that passes through the node. This is true for messages that originated elsewhere in the mesh that your node has received as well as messages created by your application. The filter has access to both the message and its origination, so decisions about forwarding or dropping the message can be based on the full information available.  \n  \n <xref:System.ServiceModel.PeerMessagePropagationFilter> is a base abstract class with a single function, <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>. The first argument of the method call passes in a full copy of the message. Any changes made to the message do not affect the actual message. The last argument of the method call identifies the origin of the message (`PeerMessageOrigination.Local` or `PeerMessageOrigination.Remote`). Concrete implementations of this method must return a constant from the <xref:System.ServiceModel.PeerMessagePropagation> enumeration indicating that the message is to be forwarded to the local application (`Local`), forwarded to remote clients (`Remote`), both (`LocalAndRemote`), or neither (`None`). This filter can be applied by accessing the corresponding `PeerNode` object and specifying an instance of the derived propagation filter class in the `PeerNode.MessagePropagationFilter` property. Ensure that the propagation filter is attached before opening the Peer Channel.  \n  \n-   For code snippets and related information, see the [Peer Channel blog](https://go.microsoft.com/fwlink/?LinkID=114532).  \n  \n## Contacting an Individual Node in the Mesh  \n An individual node in a mesh can be contacted by setting up a local filter, or by setting up a direct connection.  \n  \n If the nodes in a mesh each have an individual ID, a destination ID can be specified in the implementation of your message. A local filter can be set up by writing a function in your message contract that will only display the message to the current node if its ID matches the destination ID you specified. The mesh transports the message, so the overhead of setting up a new connection does not have to be incurred. However, there is a loss of efficiency since the message is sent many times throughout the mesh. This works well for sending messages to individual members of a mesh as long as the messages are neither too big nor too frequent.  \n  \n For long-lasting, high-bandwidth connections, direct connections are preferable. You can send connection information over the mesh, and then set up a direct connection of your choosing to send/receive messages.  \n  \n## Choosing an Approach for Limiting Message Distribution  \n When you discover a scenario in which you need to limit message distribution, ask yourself the following questions:  \n  \n-   **Who** needs to receive the message? Just one neighbor node? A node somewhere else in the mesh? Half the mesh?  \n  \n-   **How often** will this message be sent?  \n  \n-   What kind of **bandwidth** will this message use?  \n  \n The answers to these questions can help you determine whether to use Hop Count, a Message Propagation Filter, a local filter, or a direct connection. Consider the following general guidelines:  \n  \n-   **Who**  \n  \n    -   *Individual node*:  Local filter or direct connection.  \n  \n    -   *Neighbors within a certain vicinity*:  PeerHopCount.  \n  \n    -   *Complex subset of the mesh*:  MessagePropagationFilter.  \n  \n-   **How often**  \n  \n    -   *Very frequent*:  Direct connection, PeerHopCount, MessagePropagationFilter.  \n  \n    -   *Occasional*:  Local filter.  \n  \n-   **Bandwidth use**  \n  \n    -   *High*:  Direct connection, less advisable to use MessagePropagationFilter or local filter.  \n  \n    -   *Low*:  Any, direct connection probably not needed.  \n  \n## See also\n\n- [Building a Peer Channel Application](../../../../docs/framework/wcf/feature-details/building-a-peer-channel-application.md)\n","nodes":[{"pos":[4,113],"embed":true,"restype":"x-metadata","content":"title: \"Limiting Message Distribution\"\nms.date: \"03/30/2017\"\nms.assetid: 8b5ec4b8-1ce9-45ef-bb90-2c840456bcc1","nodes":[{"content":"Limiting Message Distribution","nodes":[{"pos":[0,29],"content":"Limiting Message Distribution","nodes":[{"content":"Limiting Message Distribution","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[120,149],"content":"Limiting Message Distribution","linkify":"Limiting Message Distribution","nodes":[{"content":"Limiting Message Distribution","pos":[0,29]}]},{"content":"Peer Channel is by design a broadcast mesh.","pos":[150,193]},{"content":"Its basic flooding model involves distributing each message sent by any member of a mesh to all other members of that mesh.","pos":[194,317]},{"content":"This is ideal in situations where every message generated by a member is relevant and useful to all other members (for example, a chat room).","pos":[318,459]},{"content":"However, many applications have an occasional need for limiting message distribution.","pos":[460,545]},{"content":"For example, if a new member joins a mesh and wants to retrieve the last message sent through the mesh, this request does not need to be flooded to every member of the mesh.","pos":[546,719]},{"content":"The request could be limited to near neighbors, or locally generated messages can be filtered out. Messages can also be sent to an individual node on the mesh.","pos":[720,879]},{"content":"This topic discusses using Hop Count, a Message Propagation Filter, a local filter, or a direct connection to control how messages are forwarded throughout the mesh, and provides general guidelines for choosing an approach.","pos":[880,1103]},{"pos":[1112,1122],"content":"Hop Counts","linkify":"Hop Counts","nodes":[{"content":"Hop Counts","pos":[0,10]}]},{"content":"The concept of <ph id=\"ph1\">`PeerHopCount`</ph> is similar to TTL (Time-To-Live) used in IP protocol.","pos":[1126,1209],"source":"The concept of `PeerHopCount` is similar to TTL (Time-To-Live) used in IP protocol."},{"content":"The value of <ph id=\"ph1\">`PeerHopCount`</ph> is tied to a message instance, and it specifies how many times a message should be forwarded before being dropped.","pos":[1210,1352],"source":" The value of `PeerHopCount` is tied to a message instance, and it specifies how many times a message should be forwarded before being dropped."},{"content":"Each time a message is received by a Peer Channel client, the client examines the message to see if <ph id=\"ph1\">`PeerHopCount`</ph> is specified.","pos":[1353,1481],"source":" Each time a message is received by a Peer Channel client, the client examines the message to see if `PeerHopCount` is specified."},{"content":"If it is specified, then the client decrements the hop count value by one before forwarding the message to neighboring nodes.","pos":[1482,1607]},{"content":"When a client receives a message with a hop count value of zero, the client processes the message, but does not forward the message to neighbors.","pos":[1608,1753]},{"content":"Hop count may be added to a message by adding <ph id=\"ph1\">`PeerHopCount`</ph> as an attribute to the applicable property or field in the implementation of the message class.","pos":[1760,1916],"source":"Hop count may be added to a message by adding `PeerHopCount` as an attribute to the applicable property or field in the implementation of the message class."},{"content":"You can set this to a specific value before sending the message to the mesh.","pos":[1917,1993]},{"content":"In this manner, you can use hop count to limit distribution of messages throughout the mesh when necessary, potentially avoiding unnecessary message duplication.","pos":[1994,2155]},{"content":"This is useful in cases where the mesh contains a high amount of redundant data, or for sending a message to immediate neighbors, or neighbors within a few hops.","pos":[2156,2317]},{"pos":[2327,2446],"content":"For code snippets and related information, see the <bpt id=\"p1\">[</bpt>Peer Channel blog<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkID=114531)</ept>.","source":"For code snippets and related information, see the [Peer Channel blog](https://go.microsoft.com/fwlink/?LinkID=114531)."},{"pos":[2455,2481],"content":"Message Propagation Filter","linkify":"Message Propagation Filter","nodes":[{"content":"Message Propagation Filter","pos":[0,26]}]},{"content":"<ph id=\"ph1\">`MessagePropagationFilter`</ph> can be used for customized control of message flooding, especially when the content of the message or other specific scenarios determine propagation.","pos":[2485,2661],"source":"`MessagePropagationFilter` can be used for customized control of message flooding, especially when the content of the message or other specific scenarios determine propagation."},{"content":"The filter makes propagation decisions for every message that passes through the node.","pos":[2662,2748]},{"content":"This is true for messages that originated elsewhere in the mesh that your node has received as well as messages created by your application.","pos":[2749,2889]},{"content":"The filter has access to both the message and its origination, so decisions about forwarding or dropping the message can be based on the full information available.","pos":[2890,3054]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.PeerMessagePropagationFilter&gt;</ph> is a base abstract class with a single function, <ph id=\"ph2\">&lt;xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A&gt;</ph>.","pos":[3061,3248],"source":"<xref:System.ServiceModel.PeerMessagePropagationFilter> is a base abstract class with a single function, <xref:System.ServiceModel.PeerMessagePropagationFilter.ShouldMessagePropagate%2A>."},{"content":"The first argument of the method call passes in a full copy of the message.","pos":[3249,3324]},{"content":"Any changes made to the message do not affect the actual message.","pos":[3325,3390]},{"content":"The last argument of the method call identifies the origin of the message (<ph id=\"ph1\">`PeerMessageOrigination.Local`</ph> or <ph id=\"ph2\">`PeerMessageOrigination.Remote`</ph>).","pos":[3391,3533],"source":" The last argument of the method call identifies the origin of the message (`PeerMessageOrigination.Local` or `PeerMessageOrigination.Remote`)."},{"content":"Concrete implementations of this method must return a constant from the <ph id=\"ph1\">&lt;xref:System.ServiceModel.PeerMessagePropagation&gt;</ph> enumeration indicating that the message is to be forwarded to the local application (<ph id=\"ph2\">`Local`</ph>), forwarded to remote clients (<ph id=\"ph3\">`Remote`</ph>), both (<ph id=\"ph4\">`LocalAndRemote`</ph>), or neither (<ph id=\"ph5\">`None`</ph>).","pos":[3534,3836],"source":" Concrete implementations of this method must return a constant from the <xref:System.ServiceModel.PeerMessagePropagation> enumeration indicating that the message is to be forwarded to the local application (`Local`), forwarded to remote clients (`Remote`), both (`LocalAndRemote`), or neither (`None`)."},{"content":"This filter can be applied by accessing the corresponding <ph id=\"ph1\">`PeerNode`</ph> object and specifying an instance of the derived propagation filter class in the <ph id=\"ph2\">`PeerNode.MessagePropagationFilter`</ph> property.","pos":[3837,4032],"source":" This filter can be applied by accessing the corresponding `PeerNode` object and specifying an instance of the derived propagation filter class in the `PeerNode.MessagePropagationFilter` property."},{"content":"Ensure that the propagation filter is attached before opening the Peer Channel.","pos":[4033,4112]},{"pos":[4122,4241],"content":"For code snippets and related information, see the <bpt id=\"p1\">[</bpt>Peer Channel blog<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkID=114532)</ept>.","source":"For code snippets and related information, see the [Peer Channel blog](https://go.microsoft.com/fwlink/?LinkID=114532)."},{"pos":[4250,4291],"content":"Contacting an Individual Node in the Mesh","linkify":"Contacting an Individual Node in the Mesh","nodes":[{"content":"Contacting an Individual Node in the Mesh","pos":[0,41]}]},{"content":"An individual node in a mesh can be contacted by setting up a local filter, or by setting up a direct connection.","pos":[4295,4408]},{"content":"If the nodes in a mesh each have an individual ID, a destination ID can be specified in the implementation of your message.","pos":[4415,4538]},{"content":"A local filter can be set up by writing a function in your message contract that will only display the message to the current node if its ID matches the destination ID you specified.","pos":[4539,4721]},{"content":"The mesh transports the message, so the overhead of setting up a new connection does not have to be incurred.","pos":[4722,4831]},{"content":"However, there is a loss of efficiency since the message is sent many times throughout the mesh.","pos":[4832,4928]},{"content":"This works well for sending messages to individual members of a mesh as long as the messages are neither too big nor too frequent.","pos":[4929,5059]},{"content":"For long-lasting, high-bandwidth connections, direct connections are preferable.","pos":[5066,5146]},{"content":"You can send connection information over the mesh, and then set up a direct connection of your choosing to send/receive messages.","pos":[5147,5276]},{"pos":[5285,5339],"content":"Choosing an Approach for Limiting Message Distribution","linkify":"Choosing an Approach for Limiting Message Distribution","nodes":[{"content":"Choosing an Approach for Limiting Message Distribution","pos":[0,54]}]},{"content":"When you discover a scenario in which you need to limit message distribution, ask yourself the following questions:","pos":[5343,5458]},{"content":"<bpt id=\"p1\">**</bpt>Who<ept id=\"p1\">**</ept> needs to receive the message?","pos":[5468,5505],"source":"**Who** needs to receive the message?"},{"content":"Just one neighbor node?","pos":[5506,5529]},{"content":"A node somewhere else in the mesh?","pos":[5530,5564]},{"content":"Half the mesh?","pos":[5565,5579]},{"pos":[5589,5629],"content":"<bpt id=\"p1\">**</bpt>How often<ept id=\"p1\">**</ept> will this message be sent?","source":"**How often** will this message be sent?"},{"pos":[5639,5688],"content":"What kind of <bpt id=\"p1\">**</bpt>bandwidth<ept id=\"p1\">**</ept> will this message use?","source":"What kind of **bandwidth** will this message use?"},{"content":"The answers to these questions can help you determine whether to use Hop Count, a Message Propagation Filter, a local filter, or a direct connection.","pos":[5695,5844]},{"content":"Consider the following general guidelines:","pos":[5845,5887]},{"pos":[5897,5904],"content":"<bpt id=\"p1\">**</bpt>Who<ept id=\"p1\">**</ept>","source":"**Who**"},{"pos":[5918,5972],"content":"<bpt id=\"p1\">*</bpt>Individual node<ept id=\"p1\">*</ept>:  Local filter or direct connection.","source":"*Individual node*:  Local filter or direct connection."},{"pos":[5986,6039],"content":"<bpt id=\"p1\">*</bpt>Neighbors within a certain vicinity<ept id=\"p1\">*</ept>:  PeerHopCount.","source":"*Neighbors within a certain vicinity*:  PeerHopCount."},{"pos":[6053,6109],"content":"<bpt id=\"p1\">*</bpt>Complex subset of the mesh<ept id=\"p1\">*</ept>:  MessagePropagationFilter.","source":"*Complex subset of the mesh*:  MessagePropagationFilter."},{"pos":[6119,6132],"content":"<bpt id=\"p1\">**</bpt>How often<ept id=\"p1\">**</ept>","source":"**How often**"},{"pos":[6146,6222],"content":"<bpt id=\"p1\">*</bpt>Very frequent<ept id=\"p1\">*</ept>:  Direct connection, PeerHopCount, MessagePropagationFilter.","source":"*Very frequent*:  Direct connection, PeerHopCount, MessagePropagationFilter."},{"pos":[6236,6264],"content":"<bpt id=\"p1\">*</bpt>Occasional<ept id=\"p1\">*</ept>:  Local filter.","source":"*Occasional*:  Local filter."},{"pos":[6274,6291],"content":"<bpt id=\"p1\">**</bpt>Bandwidth use<ept id=\"p1\">**</ept>","source":"**Bandwidth use**"},{"pos":[6305,6396],"content":"<bpt id=\"p1\">*</bpt>High<ept id=\"p1\">*</ept>:  Direct connection, less advisable to use MessagePropagationFilter or local filter.","source":"*High*:  Direct connection, less advisable to use MessagePropagationFilter or local filter."},{"pos":[6410,6461],"content":"<bpt id=\"p1\">*</bpt>Low<ept id=\"p1\">*</ept>:  Any, direct connection probably not needed.","source":"*Low*:  Any, direct connection probably not needed."},{"pos":[6470,6478],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6482,6606],"content":"<bpt id=\"p1\">[</bpt>Building a Peer Channel Application<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/building-a-peer-channel-application.md)</ept>","source":"[Building a Peer Channel Application](../../../../docs/framework/wcf/feature-details/building-a-peer-channel-application.md)"}]}