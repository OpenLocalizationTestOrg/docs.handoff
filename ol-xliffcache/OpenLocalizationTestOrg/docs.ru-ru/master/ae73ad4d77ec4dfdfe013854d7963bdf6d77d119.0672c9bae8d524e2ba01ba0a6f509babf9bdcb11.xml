{"content":"---\ntitle: \"Optimizing Performance: Layout and Design | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"layout, optimizing performance\"\n  - \"design considerations\"\n  - \"layout pass\"\nms.assetid: 005f4cda-a849-448b-916b-38d14d9a96fe\ncaps.latest.revision: 8\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Optimizing Performance: Layout and Design\nThe design of your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application can impact its performance by creating unnecessary overhead in calculating layout and validating object references. The construction of objects, particularly at run time, can affect the performance characteristics of your application.  \n  \n This topic provides performance recommendations in these areas.  \n  \n## Layout  \n The term \"layout pass\" describes the process of measuring and arranging the members of a <xref:System.Windows.Controls.Panel>-derived object's collection of children, and then drawing them onscreen. The layout pass is a mathematically-intensive process—the larger the number of children in the collection, the greater the number of calculations required. For example, each time a child <xref:System.Windows.UIElement> object in the collection changes its position, it has the potential to trigger a new pass by the layout system. Because of the close relationship between object characteristics and layout behavior, it's important to understand the type of events that can invoke the layout system. Your application will perform better by reducing as much as possible any unnecessary invocations of the layout pass.  \n  \n The layout system completes two passes for each child member in a collection: a measure pass, and an arrange pass. Each child object provides its own overridden implementation of the <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> methods in order to provide its own specific layout behavior. At its simplest, layout is a recursive system that leads to an element being sized, positioned, and drawn onscreen.  \n  \n-   A child <xref:System.Windows.UIElement> object begins the layout process by first having its core properties measured.  \n  \n-   The object's <xref:System.Windows.FrameworkElement> properties that are related to size, such as <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A>, are evaluated.  \n  \n-   <xref:System.Windows.Controls.Panel>-specific logic is applied, such as the <xref:System.Windows.Controls.DockPanel.Dock%2A> property of the <xref:System.Windows.Controls.DockPanel>, or the <xref:System.Windows.Controls.StackPanel.Orientation%2A> property of the <xref:System.Windows.Controls.StackPanel>.  \n  \n-   Content is arranged, or positioned, after all child objects have been measured.  \n  \n-   The collection of child objects is drawn to the screen.  \n  \n The layout pass process is invoked again if any of the following actions occur:  \n  \n-   A child object is added to the collection.  \n  \n-   A <xref:System.Windows.FrameworkElement.LayoutTransform%2A> is applied to the child object.  \n  \n-   The <xref:System.Windows.UIElement.UpdateLayout%2A> method is called for the child object.  \n  \n-   When a change occurs to the value of a dependency property that is marked with metadata affecting the measure or arrange passes.  \n  \n### Use the Most Efficient Panel where Possible  \n The complexity of the layout process is directly based on the layout behavior of the <xref:System.Windows.Controls.Panel>-derived elements you use. For example, a <xref:System.Windows.Controls.Grid> or <xref:System.Windows.Controls.StackPanel> control provides much more functionality than a <xref:System.Windows.Controls.Canvas> control. The price for this greater increase in functionality is a greater increase in performance costs. However, if you do not require the functionality that a <xref:System.Windows.Controls.Grid> control provides, you should use the less costly alternatives, such as a <xref:System.Windows.Controls.Canvas> or a custom panel.  \n  \n For more information, see [Panels Overview](../../../../docs/framework/wpf/controls/panels-overview.md).  \n  \n### Update Rather than Replace a RenderTransform  \n You may be able to update a <xref:System.Windows.Media.Transform> rather than replacing it as the value of a <xref:System.Windows.UIElement.RenderTransform%2A> property. This is particularly true in scenarios that involve animation. By updating an existing <xref:System.Windows.Media.Transform>, you avoid initiating an unnecessary layout calculation.  \n  \n### Build Your Tree Top-Down  \n When a node is added or removed from the logical tree, property invalidations are raised on the node's parent and all its children. As a result, a top-down construction pattern should always be followed to avoid the cost of unnecessary invalidations on nodes that have already been validated. The following table shows the difference in execution speed between building a tree top-down versus bottom-up, where the tree is 150 levels deep with a single <xref:System.Windows.Controls.TextBlock> and <xref:System.Windows.Controls.DockPanel> at each level.  \n  \n|**Action**|**Tree building (in ms)**|**Render—includes tree building (in ms)**|  \n|----------------|---------------------------------|-------------------------------------------------|  \n|Bottom-up|366|454|  \n|Top-down|11|96|  \n  \n The following code example demonstrates how to create a tree top down.  \n  \n [!code-csharp[Performance#PerformanceSnippet1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet1)]\n [!code-vb[Performance#PerformanceSnippet1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet1)]  \n  \n For more information on the logical tree, see [Trees in WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).  \n  \n## See Also  \n [Optimizing WPF Application Performance](../../../../docs/framework/wpf/advanced/optimizing-wpf-application-performance.md)   \n [Planning for Application Performance](../../../../docs/framework/wpf/advanced/planning-for-application-performance.md)   \n [Taking Advantage of Hardware](../../../../docs/framework/wpf/advanced/optimizing-performance-taking-advantage-of-hardware.md)   \n [2D Graphics and Imaging](../../../../docs/framework/wpf/advanced/optimizing-performance-2d-graphics-and-imaging.md)   \n [Object Behavior](../../../../docs/framework/wpf/advanced/optimizing-performance-object-behavior.md)   \n [Application Resources](../../../../docs/framework/wpf/advanced/optimizing-performance-application-resources.md)   \n [Text](../../../../docs/framework/wpf/advanced/optimizing-performance-text.md)   \n [Data Binding](../../../../docs/framework/wpf/advanced/optimizing-performance-data-binding.md)   \n [Other Performance Recommendations](../../../../docs/framework/wpf/advanced/optimizing-performance-other-recommendations.md)   \n [Layout](../../../../docs/framework/wpf/advanced/layout.md)","nodes":[{"pos":[4,475],"embed":true,"restype":"x-metadata","content":"title: \"Optimizing Performance: Layout and Design | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"layout, optimizing performance\"\n  - \"design considerations\"\n  - \"layout pass\"\nms.assetid: 005f4cda-a849-448b-916b-38d14d9a96fe\ncaps.latest.revision: 8\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","nodes":[{"content":"Optimizing Performance: Layout and Design | Microsoft Docs","nodes":[{"pos":[0,58],"content":"Optimizing Performance: Layout and Design | Microsoft Docs","nodes":[{"content":"Optimizing Performance: Layout and Design | Microsoft Docs","pos":[0,58]}]}],"path":["title"]}],"yml":true},{"pos":[482,523],"content":"Optimizing Performance: Layout and Design","linkify":"Optimizing Performance: Layout and Design","nodes":[{"content":"Optimizing Performance: Layout and Design","pos":[0,41]}]},{"content":"The design of your <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application can impact its performance by creating unnecessary overhead in calculating layout and validating object references.","pos":[524,752],"source":"The design of your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application can impact its performance by creating unnecessary overhead in calculating layout and validating object references."},{"content":"The construction of objects, particularly at run time, can affect the performance characteristics of your application.","pos":[753,871]},{"content":"This topic provides performance recommendations in these areas.","pos":[878,941]},{"pos":[950,956],"content":"Layout","linkify":"Layout","nodes":[{"content":"Layout","pos":[0,6]}]},{"content":"The term \"layout pass\" describes the process of measuring and arranging the members of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Panel&gt;</ph>-derived object's collection of children, and then drawing them onscreen.","pos":[960,1158],"source":"The term \"layout pass\" describes the process of measuring and arranging the members of a <xref:System.Windows.Controls.Panel>-derived object's collection of children, and then drawing them onscreen."},{"content":"The layout pass is a mathematically-intensive process—the larger the number of children in the collection, the greater the number of calculations required.","pos":[1159,1314]},{"content":"For example, each time a child <ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> object in the collection changes its position, it has the potential to trigger a new pass by the layout system.","pos":[1315,1489],"source":" For example, each time a child <xref:System.Windows.UIElement> object in the collection changes its position, it has the potential to trigger a new pass by the layout system."},{"content":"Because of the close relationship between object characteristics and layout behavior, it's important to understand the type of events that can invoke the layout system.","pos":[1490,1658]},{"content":"Your application will perform better by reducing as much as possible any unnecessary invocations of the layout pass.","pos":[1659,1775]},{"content":"The layout system completes two passes for each child member in a collection: a measure pass, and an arrange pass.","pos":[1782,1896]},{"content":"Each child object provides its own overridden implementation of the <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> methods in order to provide its own specific layout behavior.","pos":[1897,2116],"source":" Each child object provides its own overridden implementation of the <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> methods in order to provide its own specific layout behavior."},{"content":"At its simplest, layout is a recursive system that leads to an element being sized, positioned, and drawn onscreen.","pos":[2117,2232]},{"content":"A child <ph id=\"ph1\">&lt;xref:System.Windows.UIElement&gt;</ph> object begins the layout process by first having its core properties measured.","pos":[2242,2360],"source":"A child <xref:System.Windows.UIElement> object begins the layout process by first having its core properties measured."},{"content":"The object's <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> properties that are related to size, such as <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph>, are evaluated.","pos":[2370,2634],"source":"The object's <xref:System.Windows.FrameworkElement> properties that are related to size, such as <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A>, are evaluated."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Controls.Panel&gt;</ph>-specific logic is applied, such as the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A&gt;</ph> property of the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph>, or the <ph id=\"ph4\">&lt;xref:System.Windows.Controls.StackPanel.Orientation%2A&gt;</ph> property of the <ph id=\"ph5\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph>.","pos":[2644,2949],"source":"<xref:System.Windows.Controls.Panel>-specific logic is applied, such as the <xref:System.Windows.Controls.DockPanel.Dock%2A> property of the <xref:System.Windows.Controls.DockPanel>, or the <xref:System.Windows.Controls.StackPanel.Orientation%2A> property of the <xref:System.Windows.Controls.StackPanel>."},{"content":"Content is arranged, or positioned, after all child objects have been measured.","pos":[2959,3038]},{"content":"The collection of child objects is drawn to the screen.","pos":[3048,3103]},{"content":"The layout pass process is invoked again if any of the following actions occur:","pos":[3110,3189]},{"content":"A child object is added to the collection.","pos":[3199,3241]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> is applied to the child object.","pos":[3251,3342],"source":"A <xref:System.Windows.FrameworkElement.LayoutTransform%2A> is applied to the child object."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.UpdateLayout%2A&gt;</ph> method is called for the child object.","pos":[3352,3442],"source":"The <xref:System.Windows.UIElement.UpdateLayout%2A> method is called for the child object."},{"content":"When a change occurs to the value of a dependency property that is marked with metadata affecting the measure or arrange passes.","pos":[3452,3580]},{"pos":[3590,3633],"content":"Use the Most Efficient Panel where Possible","linkify":"Use the Most Efficient Panel where Possible","nodes":[{"content":"Use the Most Efficient Panel where Possible","pos":[0,43]}]},{"content":"The complexity of the layout process is directly based on the layout behavior of the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Panel&gt;</ph>-derived elements you use.","pos":[3637,3784],"source":"The complexity of the layout process is directly based on the layout behavior of the <xref:System.Windows.Controls.Panel>-derived elements you use."},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Grid&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> control provides much more functionality than a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> control.","pos":[3785,3975],"source":" For example, a <xref:System.Windows.Controls.Grid> or <xref:System.Windows.Controls.StackPanel> control provides much more functionality than a <xref:System.Windows.Controls.Canvas> control."},{"content":"The price for this greater increase in functionality is a greater increase in performance costs.","pos":[3976,4072]},{"content":"However, if you do not require the functionality that a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Grid&gt;</ph> control provides, you should use the less costly alternatives, such as a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> or a custom panel.","pos":[4073,4294],"source":" However, if you do not require the functionality that a <xref:System.Windows.Controls.Grid> control provides, you should use the less costly alternatives, such as a <xref:System.Windows.Controls.Canvas> or a custom panel."},{"pos":[4301,4405],"content":"For more information, see <bpt id=\"p1\">[</bpt>Panels Overview<ept id=\"p1\">](../../../../docs/framework/wpf/controls/panels-overview.md)</ept>.","source":"For more information, see [Panels Overview](../../../../docs/framework/wpf/controls/panels-overview.md)."},{"pos":[4415,4459],"content":"Update Rather than Replace a RenderTransform","linkify":"Update Rather than Replace a RenderTransform","nodes":[{"content":"Update Rather than Replace a RenderTransform","pos":[0,44]}]},{"content":"You may be able to update a <ph id=\"ph1\">&lt;xref:System.Windows.Media.Transform&gt;</ph> rather than replacing it as the value of a <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph> property.","pos":[4463,4632],"source":"You may be able to update a <xref:System.Windows.Media.Transform> rather than replacing it as the value of a <xref:System.Windows.UIElement.RenderTransform%2A> property."},{"content":"This is particularly true in scenarios that involve animation.","pos":[4633,4695]},{"content":"By updating an existing <ph id=\"ph1\">&lt;xref:System.Windows.Media.Transform&gt;</ph>, you avoid initiating an unnecessary layout calculation.","pos":[4696,4814],"source":" By updating an existing <xref:System.Windows.Media.Transform>, you avoid initiating an unnecessary layout calculation."},{"pos":[4824,4848],"content":"Build Your Tree Top-Down","linkify":"Build Your Tree Top-Down","nodes":[{"content":"Build Your Tree Top-Down","pos":[0,24]}]},{"content":"When a node is added or removed from the logical tree, property invalidations are raised on the node's parent and all its children.","pos":[4852,4983]},{"content":"As a result, a top-down construction pattern should always be followed to avoid the cost of unnecessary invalidations on nodes that have already been validated.","pos":[4984,5144]},{"content":"The following table shows the difference in execution speed between building a tree top-down versus bottom-up, where the tree is 150 levels deep with a single <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> at each level.","pos":[5145,5404],"source":" The following table shows the difference in execution speed between building a tree top-down versus bottom-up, where the tree is 150 levels deep with a single <xref:System.Windows.Controls.TextBlock> and <xref:System.Windows.Controls.DockPanel> at each level."},{"pos":[5411,5421],"content":"<bpt id=\"p1\">**</bpt>Action<ept id=\"p1\">**</ept>","source":"**Action**"},{"pos":[5422,5447],"content":"<bpt id=\"p1\">**</bpt>Tree building (in ms)<ept id=\"p1\">**</ept>","source":"**Tree building (in ms)**"},{"pos":[5448,5489],"content":"<bpt id=\"p1\">**</bpt>Render—includes tree building (in ms)<ept id=\"p1\">**</ept>","source":"**Render—includes tree building (in ms)**"},{"content":"Bottom-up","pos":[5599,5608]},{"content":"366","pos":[5609,5612]},{"content":"454","pos":[5613,5616]},{"content":"Top-down","pos":[5621,5629]},{"content":"11","pos":[5630,5632]},{"content":"96","pos":[5633,5635]},{"content":"The following code example demonstrates how to create a tree top down.","pos":[5643,5713]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Performance#PerformanceSnippet1<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet1)</ept><ept id=\"p1\">]</ept>","pos":[5720,5875],"source":"[!code-csharp[Performance#PerformanceSnippet1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>Performance#PerformanceSnippet1<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet1)</ept><ept id=\"p1\">]</ept>","pos":[5877,6038],"source":"[!code-vb[Performance#PerformanceSnippet1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet1)]"},{"pos":[6045,6163],"content":"For more information on the logical tree, see <bpt id=\"p1\">[</bpt>Trees in WPF<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.","source":"For more information on the logical tree, see [Trees in WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)."},{"pos":[6172,6180],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Optimizing WPF Application Performance<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-wpf-application-performance.md)</ept><ph id=\"ph1\"> </ph>","pos":[6184,6308],"source":"[Optimizing WPF Application Performance](../../../../docs/framework/wpf/advanced/optimizing-wpf-application-performance.md) "},{"content":"<bpt id=\"p1\">[</bpt>Planning for Application Performance<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/planning-for-application-performance.md)</ept><ph id=\"ph1\"> </ph>","pos":[6312,6432],"source":"[Planning for Application Performance](../../../../docs/framework/wpf/advanced/planning-for-application-performance.md) "},{"content":"<bpt id=\"p1\">[</bpt>Taking Advantage of Hardware<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-taking-advantage-of-hardware.md)</ept><ph id=\"ph1\"> </ph>","pos":[6436,6563],"source":"[Taking Advantage of Hardware](../../../../docs/framework/wpf/advanced/optimizing-performance-taking-advantage-of-hardware.md) "},{"content":"<bpt id=\"p1\">[</bpt>2D Graphics and Imaging<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-2d-graphics-and-imaging.md)</ept><ph id=\"ph1\"> </ph>","pos":[6567,6684],"source":"[2D Graphics and Imaging](../../../../docs/framework/wpf/advanced/optimizing-performance-2d-graphics-and-imaging.md) "},{"content":"<bpt id=\"p1\">[</bpt>Object Behavior<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-object-behavior.md)</ept><ph id=\"ph1\"> </ph>","pos":[6688,6789],"source":"[Object Behavior](../../../../docs/framework/wpf/advanced/optimizing-performance-object-behavior.md) "},{"content":"<bpt id=\"p1\">[</bpt>Application Resources<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-application-resources.md)</ept><ph id=\"ph1\"> </ph>","pos":[6793,6906],"source":"[Application Resources](../../../../docs/framework/wpf/advanced/optimizing-performance-application-resources.md) "},{"content":"<bpt id=\"p1\">[</bpt>Text<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-text.md)</ept><ph id=\"ph1\"> </ph>","pos":[6910,6989],"source":"[Text](../../../../docs/framework/wpf/advanced/optimizing-performance-text.md) "},{"content":"<bpt id=\"p1\">[</bpt>Data Binding<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-data-binding.md)</ept><ph id=\"ph1\"> </ph>","pos":[6993,7088],"source":"[Data Binding](../../../../docs/framework/wpf/advanced/optimizing-performance-data-binding.md) "},{"content":"<bpt id=\"p1\">[</bpt>Other Performance Recommendations<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/optimizing-performance-other-recommendations.md)</ept><ph id=\"ph1\"> </ph>","pos":[7092,7217],"source":"[Other Performance Recommendations](../../../../docs/framework/wpf/advanced/optimizing-performance-other-recommendations.md) "},{"content":"<bpt id=\"p1\">[</bpt>Layout<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/layout.md)</ept>","pos":[7221,7280],"source":"[Layout](../../../../docs/framework/wpf/advanced/layout.md)"}]}