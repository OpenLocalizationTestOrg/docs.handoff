<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="globalization.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b2a8af3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cf28834839df781a5eac2a6772a8145a7c698836</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\globalization-localization\globalization.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6325bed6d35d2d434caa532889d5a6d42ade5df6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cc4b50b5f4d89d3c038cdc07960021d2ac52888d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Globalization | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Globalization</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Globalization involves designing and developing a world-ready app that supports localized interfaces and regional data for users in multiple cultures.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Before beginning the design phase, you should determine which cultures your app will support.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Although an app targets a single culture or region as its default, you can design and write it so that it can easily be extended to users in other cultures or regions.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>As developers, we all have assumptions about user interfaces and data that are formed by our cultures.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For example, for an English-speaking developer in the United States, serializing date and time data as a string in the format <ph id="ph1">`MM/dd/yyyy hh:mm:ss`</ph> seems perfectly reasonable.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>However, deserializing that string on a system in a different culture is likely to throw a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception or produce inaccurate data.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Globalization enables us to identify such culture-specific assumptions and ensure that they do not affect our app's design or code.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following sections discuss some of the major issues you should consider and the best practices you can follow when handling strings, date and time values, and numeric values in a globalized app.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handling Strings<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#HandlingStrings)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use Unicode Internally<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Strings_Unicode)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Use Resource Files<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Strings_Resources)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Searching and Comparing Strings <ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Strings_Searching)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Testing Strings for Equality<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Strings_Equality)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Ordering and Sorting Strings <ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Strings_Ordering)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Avoid String Concatenation<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Strings_Concat)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handling Dates and Times<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#DatesAndTimes)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Persisting Dates and Times<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#DatesAndTimes_Persist)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Displaying Dates and Times<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#DatesAndTimes_Display)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Serialization and Time Zone Awareness<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#DatesAndTimes_TimeZones)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Performing Date and Time Arithmetic<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#DatesAndTimes_Arithmetic)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Handling Numeric Values<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Numbers)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Displaying Numeric Values<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Numbers_Display)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Persisting Numeric Values<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Numbers_Persist)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Working with Culture-Specific Settings<ept id="p1">](../../../docs/standard/globalization-localization/globalization.md#Cultures)</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Handling Strings</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The handling of characters and strings is a central focus of globalization, because each culture or region may use different characters and character sets and sort them differently.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This section provides recommendations for using strings in globalized apps.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Use Unicode Internally</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>By default, the .NET Framework uses Unicode strings.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A Unicode string consists of zero, one, or more <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, each of which represents a UTF-16 code unit.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>There is a Unicode representation for almost every character in every character set in use throughout the world.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Many applications and operating systems, including the Windows operating system, can use also use code pages to represent character sets.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Code pages typically contain the standard ASCII values from 0x00 through 0x7F and map other characters to the remaining values from 0x80 through 0xFF.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The interpretation of values from 0x80 through 0xFF depends on the specific code page.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Because of this, you should avoid using code pages in a globalized app if possible.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example illustrates the dangers of interpreting code page data when the default code page on a system is different from the code page on which the data was saved.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>(To simulate this scenario, the example explicitly specifies different code pages.) First, the example defines an array that consists of the uppercase characters of the Greek alphabet.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It encodes them into a byte array by using code page 737 (also known as MS-DOS Greek) and saves the byte array to a file.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If the file is retrieved and its byte array is decoded by using code page 737, the original characters are restored.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>However, if the file is retrieved and its byte array is decoded by using code page 1252 (or Windows-1252, which represents characters in the Latin alphabet), the original characters are lost.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/codepages1.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#1<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/codepages1.vb#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The use of Unicode ensures that the same code units always map to the same characters, and that the same characters always map to the same byte arrays.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Use Resource Files</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Even if you are developing an app that targets a single culture or region, you should use resource files to store strings and other resources that are displayed in the user interface.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You should never add them directly to your code.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Using resource files has a number of advantages:</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>All the strings are in a single location.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You don't have to search throughout your source code to identify strings to modify for a specific language or culture.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>There is no need to duplicate strings.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Developers who don't use resource files often define the same string in multiple source code files.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This duplication increases the probability that one or more instances will be overlooked when a string is modified.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can include non-string resources, such as images or binary data, in the resource file instead of storing them in a separate standalone file, so they can be retrieved easily.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Using resource files has particular advantages if you are creating a localized app.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>When you deploy resources in satellite assemblies, the common language runtime automatically selects a culture-appropriate resource based on the user's current UI culture as defined by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>As long as you provide an appropriate culture-specific resource and correctly instantiate a <ph id="ph1">&lt;xref:System.Resources.ResourceManager&gt;</ph> object or use a strongly typed resource class, the runtime handles the details of retrieving the appropriate resources.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For more information about creating resource files, see <bpt id="p1">[</bpt>Creating Resource Files<ept id="p1">](../../../docs/framework/resources/creating-resource-files-for-desktop-apps.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For information about creating and deploying satellite assemblies, see <bpt id="p1">[</bpt>Creating Satellite Assemblies<ept id="p1">](../../../docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)</ept> and <bpt id="p2">[</bpt>Packaging and Deploying Resources<ept id="p2">](../../../docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Searching and Comparing Strings</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should handle strings as entire strings instead of handling them as a series of individual characters.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This is especially important when you sort or search for substrings, to prevent problems associated with parsing combined characters.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo&gt;</ph> class to work with the text elements rather than the individual characters in a string.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In string searches and comparisons, a common mistake is to treat the string as a collection of characters, each of which is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In fact, a single character may be formed by one, two, or more <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Such characters are found most frequently in strings from cultures whose alphabets consist of characters outside the Unicode Basic Latin character range (U+0021 through U+007E).</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following example tries to find the index of the LATIN CAPITAL LETTER A WITH GRAVE character (U+00C0) in a string.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>However, this character can be represented in two different ways: as a single code unit (U+00C0) or as a composite character (two code units: U+0021 and U+007E).</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>In this case, the character is represented in the string instance by two <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, U+0021 and U+007E.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The example code calls the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29?displayProperty=fullName&gt;</ph> overloads to find the position of this character in the string instance, but these return different results.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The first method call has a <ph id="ph1">&lt;xref:System.Char&gt;</ph> argument; it performs an ordinal comparison and therefore cannot find a match.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The second call has a <ph id="ph1">&lt;xref:System.String&gt;</ph> argument; it performs a culture-sensitive comparison and therefore finds a match.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#18<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/search1.cs#18)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#18<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/search1.vb#18)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can avoid some of the ambiguity of this example (calls to two similar overloads of a method returning different results) by calling an overload that includes a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter, such as the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, searches are not always culture-sensitive.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If the purpose of the search is to make a security decision or to allow or disallow access to some resource, the comparison should be ordinal, as discussed in the next section.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Testing Strings for Equality</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If you want to test two strings for equality rather than determining how they compare in the sort order, use the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=fullName&gt;</ph> method instead of a string comparison method such as <ph id="ph2">&lt;xref:System.String.Compare%2A?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Comparisons for equality are typically performed to access some resource conditionally.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, you might perform a comparison for equality to verify a password or to confirm that a file exists.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Such non-linguistic comparisons should always be ordinal rather than culture-sensitive.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In general, you should call the instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29?displayProperty=fullName&gt;</ph> method or the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName&gt;</ph> method with a value of <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> for strings such as passwords, and a value of <ph id="ph4">&lt;xref:System.StringComparison?displayProperty=fullName&gt;</ph> for strings such as file names or URIs.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Comparisons for equality sometimes involve searches or substring comparisons rather than calls to the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In some cases, you may use a substring search to determine whether that substring equals another string.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If the purpose of this comparison is non-linguistic, the search should also be ordinal rather than culture-sensitive.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The following example illustrates the danger of a culture-sensitive search on non-linguistic data.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AccessesFileSystem`</ph> method is designed to prohibit file system access for URIs that begin with the substring "FILE".</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To do this, it performs a culture-sensitive, case-insensitive comparison of the beginning of the URI with the string "FILE".</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Because a URI that accesses the file system can begin with either "FILE:" or "file:", the implicit assumption is that that "i" (U+0069) is always the lowercase equivalent of "I" (U+0049).</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>However, in Turkish and Azerbaijani, the uppercase version of "i" is "Ä°" (U+0130).</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Because of this discrepancy, the culture-sensitive comparison allows file system access when it should be prohibited.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#12<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals1.cs#12)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#12<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals1.vb#12)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can avoid this problem by performing an ordinal comparison that ignores case, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#13<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals2.cs#13)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#13<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals2.vb#13)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Ordering and Sorting Strings</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Typically, ordered strings that are to be displayed in the user interface should be sorted based on culture.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For the most part, such string comparisons are handled implicitly by the .NET Framework when you call a method that sorts strings, such as <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>By default, strings are sorted by using the sorting conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference when an array of strings is sorted by using the conventions of the English (United States) culture and the Swedish (Sweden) culture.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#14<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sort1.cs#14)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#14<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sort1.vb#14)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Culture-sensitive string comparison is defined by the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> object, which is returned by each culture's <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Culture-sensitive string comparisons that use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=fullName&gt;</ph> method overloads also use the <ph id="ph2">&lt;xref:System.Globalization.CompareInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The .NET Framework uses tables to perform culture-sensitive sorts on string data.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The content of these tables, which contain data on sort weights and string normalization, is determined by the version of the Unicode standard implemented by a particular version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following table lists the versions of Unicode implemented by the specified versions of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that this list of supported Unicode versions applies to character comparison and sorting only; it does not apply to classification of Unicode characters by category.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For more information, see the "Strings and The Unicode Standard" section in the <ph id="ph1">&lt;xref:System.String&gt;</ph> article.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>.NET Framework version</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Operating system</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Unicode version</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>.NET Framework 2.0</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>All operating systems</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Unicode 4.1</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.0</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>All operating systems</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Unicode 4.1</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>.NET Framework 3.5</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>All operating systems</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Unicode 4.1</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>.NET Framework 4</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>All operating systems</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Unicode 5.0</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Unicode 5.0</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>.NET Framework 4.5</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Unicode 6.0</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In the <ph id="ph1">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, string comparison and sorting depends on the operating system.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> running on <ph id="ph2">[!INCLUDE[win7](../../../includes/win7-md.md)]</ph> retrieves data from its own tables that implement Unicode 5.0.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> running on <ph id="ph2">[!INCLUDE[win8](../../../includes/win8-md.md)]</ph> retrieves data from operating system tables that implement Unicode 6.0.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If you serialize culture-sensitive sorted data, you can use the <ph id="ph1">&lt;xref:System.Globalization.SortVersion&gt;</ph> class to determine when your serialized data needs to be sorted so that it is consistent with the .NET Framework and the operating system's sort order.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.Globalization.SortVersion&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>If your app performs extensive culture-specific sorts of string data, you can work with the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class to compare strings.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A sort key reflects the culture-specific sort weights, including the alphabetic, case, and diacritic weights of a particular string.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Because comparisons using sort keys are binary, they are faster than comparisons that use a <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> object either implicitly or explicitly.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>You create a culture-specific sort key for a particular string by passing the string to the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.GetSortKey%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The following example is similar to the previous example.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>However, instead of calling the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=fullName&gt;</ph> method, which implicitly calls the <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=fullName&gt;</ph> method, it defines an <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601?displayProperty=fullName&gt;</ph> implementation that compares sort keys, which it instantiates and passes to the <ph id="ph4">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#15<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sortkey1.cs#15)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#15<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sortkey1.vb#15)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Avoid String Concatenation</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If at all possible, avoid using composite strings that are built at run time from concatenated phrases.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Composite strings are difficult to localize, because they often assume a grammatical order in the app's original language that does not apply to other localized languages.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Handling Dates and Times</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>How you handle date and time values depends on whether they are displayed in the user interface or persisted.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This section examines both usages.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>It also discusses how you can handle time zone differences and arithmetic operations when working with dates and times.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Displaying Dates and Times</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Typically, when dates and times are displayed in the user interface, you should use the formatting conventions of the user's culture, which is defined by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</ph> property and by the <ph id="ph2">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object returned by the <ph id="ph3">`CultureInfo.CurrentCulture.DateTimeFormat`</ph> property.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The formatting conventions of the current culture are automatically used when you format a date by using any of these methods:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The parameterless <ph id="ph1">&lt;xref:System.DateTime.ToString?displayProperty=fullName&gt;</ph> method</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.DateTime.ToString%28System.String%29?displayProperty=fullName&gt;</ph> method, which includes a format string</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The parameterless <ph id="ph1">&lt;xref:System.DateTimeOffset.ToString?displayProperty=fullName&gt;</ph> method</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.DateTimeOffset.ToString%28System.String%29?displayProperty=fullName&gt;</ph>, which includes a format string</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>composite formatting<ept id="p1">](../../../docs/standard/base-types/composite-formatting.md)</ept> feature, when it is used with dates</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The following example displays sunrise and sunset data twice for October 11, 2012.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>It first sets the current culture to Croatian (Croatia), and then to English (Great Britain).</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>In each case, the dates and times are displayed in the format that is appropriate for that culture.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#2<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates1.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#2<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates1.vb#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Persisting Dates and Times</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>You should never persist date and time data in a format that can vary by culture.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This is a common programming error that results in either corrupted data or a run-time exception.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The following example serializes two dates, January 9, 2013 and August 18, 2013, as strings by using the formatting conventions of the English (United States) culture.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>When the data is retrieved and parsed by using the conventions of the English (United States) culture, it is successfully restored.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>However, when it is retrieved and parsed by using the conventions of the English (United Kingdom) culture, the first date is wrongly interpreted as September 1, and the second fails to parse because the Gregorian calendar does not have an eighteenth month.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#3<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates2.cs#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#3<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates2.vb#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can avoid this problem in any of three ways:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Serialize the date and time in binary format rather than as a string.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Save and parse the string representation of the date and time by using a custom format string that is the same regardless of the user's culture.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Save the string by using the formatting conventions of the invariant culture.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The following example illustrates the last approach.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>It uses the formatting conventions of the invariant culture returned by the static <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#4<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates3.cs#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#4<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates3.vb#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Serialization and Time Zone Awareness</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>A date and time value can have multiple interpretations, ranging from a general time ("The stores open on January 2, 2013, at 9:00 A.M.") to a specific moment in time ("Date of birth: January 2, 2013 6:32:00 A.M.").</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>When a time value represents a specific moment in time and you restore it from a serialized value, you should ensure that it represents the same moment in time regardless of the user's geographical location or time zone.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The following example illustrates this problem.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>It saves a single local date and time value as a string in three <bpt id="p1">[</bpt>standard formats<ept id="p1">](../../../docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> ("G" for general date long time, "s" for sortable date/time, and "o" for round-trip date/time) as well as in binary format.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#10<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates4.cs#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#10<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates4.vb#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>When the data is restored on a system in the same time zone as the system on which it was serialized, the deserialized date and time values accurately reflect the original value, as the output shows:</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>However, if you restore the data on a system in a different time zone, only the date and time value that was formatted with the "o" (round-trip) standard format string preserves time zone information and therefore represents the same instant in time.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Here's the output when the date and time data is restored on a system in the Romance Standard Time zone:</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>To accurately reflect a date and time value that represents a single moment of time regardless of the time zone of the system on which the data is deserialized, you can do any of the following:</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Save the value as a string by using the "o" (round-trip) standard format string.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Then deserialize it on the target system.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Convert it to UTC and save it as a string by using the "r" (RFC1123) standard format string.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Then deserialize it on the target system and convert it to local time.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Convert it to UTC and save it as a string by using the "u" (universal sortable) standard format string.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Then deserialize it on the target system and convert it to local time.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Convert it to UTC and save it in binary format.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Then deserialize it on the target system and convert it to local time.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The following example illustrates each technique.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#11<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates8.cs#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#11<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates8.vb#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>When the data is serialized on a system in the Pacific Standard Time zone and deserialized on a system in the Romance Standard Time zone, the example displays the following output:</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Converting Times Between Time Zones<ept id="p1">](../../../docs/standard/datetime/converting-between-time-zones.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Performing Date and Time Arithmetic</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Both the <ph id="ph1">&lt;xref:System.DateTime&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph> types support arithmetic operations.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>You can calculate the difference between two date values, or you can add or subtract particular time intervals to or from a date value.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>However, arithmetic operations on date and time values do not take time zones and time zone adjustment rules into account.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Because of this, date and time arithmetic on values that represent moments in time can return inaccurate results.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>For example, the transition from Pacific Standard Time to Pacific Daylight Time occurs on the second Sunday of March, which is March 10 for the year 2013.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>As the following example shows, if you calculate the date and time that is 48 hours after March 9, 2013 at 10:30 A.M.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>on a system in the Pacific Standard Time zone, the result, March 11, 2013 at 10:30 A.M., does not take the intervening time adjustment into account.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#8<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates5.cs#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#8<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates5.vb#8)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>To ensure that an arithmetic operation on date and time values produces accurate results, follow these steps:</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Convert the time in the source time zone to UTC.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Perform the arithmetic operation.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>If the result is a date and time value, convert it from UTC to the time in the source time zone.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The following example is similar to the previous example, except that it follows these three steps to correctly add 48 hours to March 9, 2013 at 10:30 A.M.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#9<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates6.cs#9)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#9<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates6.vb#9)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Performing Arithmetic Operations with Dates and Times<ept id="p1">](../../../docs/standard/datetime/performing-arithmetic-operations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Using Culture-Sensitive Names for Date Elements</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Your app may need to display the name of the month or the day of the week.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>To do this, code such as the following is common.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#19<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname1.cs#19)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#19<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname1.vb#19)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>However, this code always returns the names of the days of the week in English.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Code that extracts the name of the month is often even more inflexible.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>It frequently assumes a twelve-month calendar with names of months in a specific language.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>By using <bpt id="p1">[</bpt>custom date and time format strings<ept id="p1">](../../../docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> or the properties of the <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object, it is easy to extract strings that reflect the names of days of the week or months in the user's culture, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>It changes the current culture to French (France) and displays the name of the day of the week and the name of the month for July 1, 2013.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#20<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname2.cs#20)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#20<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname2.vb#20)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Handling Numeric Values</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The handling of numbers depends on whether they are displayed in the user interface or persisted.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This section examines both usages.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In parsing and formatting operations, the .NET Framework recognizes only the Basic Latin characters 0 through 9 (U+0030 through U+0039) as numeric digits.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Displaying Numeric Values</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Typically, when numbers are displayed in the user interface, you should use the formatting conventions of the user's culture, which is defined by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</ph> property and by the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object returned by the <ph id="ph3">`CultureInfo.CurrentCulture.NumberFormat`</ph> property.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The formatting conventions of the current culture are automatically used when you format a date by using any of the following methods:</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The parameterless <ph id="ph1">`ToString`</ph> method of any numeric type</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ToString(String)`</ph> method of any numeric type, which includes a format string as an argument</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>composite formatting<ept id="p1">](../../../docs/standard/base-types/composite-formatting.md)</ept> feature, when it is used with numeric values</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The following example displays the average temperature per month in Paris, France.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>It first sets the current culture to French (France) before displaying the data, and then sets it to English (United States).</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>In each case, the month names and temperatures are displayed in the format that is appropriate for that culture.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Note that the two cultures use different decimal separators in the temperature value.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Also note that the example uses the "MMMM" custom date and time format string to display the full month name, and that it allocates the appropriate amount of space for the month name in the result string by determining the length of the longest month name in the <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.MonthNames%2A?displayProperty=fullName&gt;</ph> array.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers1.cs#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#5<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers1.vb#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Persisting Numeric Values</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>You should never persist numeric data in a culture-specific format.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>This is a common programming error that results in either corrupted data or a run-time exception.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The following example generates ten random floating-point numbers, and then serializes them as strings by using the formatting conventions of the English (United States) culture.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>When the data is retrieved and parsed by using the conventions of the English (United States) culture, it is successfully restored.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>However, when it is retrieved and parsed by using the conventions of the French (France) culture, none of the numbers can be parsed because the cultures use different decimal separators.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#6<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers2.cs#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#6<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers2.vb#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>To avoid this problem, you can use one of these techniques:</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Save and parse the string representation of the number by using a custom format string that is the same regardless of the user's culture.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Save the number as a string by using the formatting conventions of the invariant culture, which is returned by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Serialize the number in binary instead of string format.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The following example illustrates the last approach.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>It serializes the array of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, and then deserializes and displays them by using the formatting conventions of the English (United States) and French (France) cultures.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#7<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers3.cs#7)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#7<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers3.vb#7)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Serializing currency values is a special case.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Because a currency value depends on the unit of currency in which it is expressed; it makes little sense to treat it as an independent numeric value.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>However, if you save a currency value as a formatted string that includes a currency symbol, it cannot be deserialized on a system whose default culture uses a different currency symbol, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#16<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency1.cs#16)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#16<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency1.vb#16)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Instead, you should serialize the numeric value along with some cultural information, such as the name of the culture, so that the value and its currency symbol can be deserialized independently of the current culture.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The following example does that by defining a <ph id="ph1">`CurrencyValue`</ph> structure with two members: the <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> value and the name of the culture to which the value belongs.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#17<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency2.cs#17)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>Conceptual.Globalization#17<ept id="p2">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency2.vb#17)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Working with Culture-Specific Settings</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>In the .NET Framework, the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class represents a particular culture or region.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Some of its properties return objects that provide specific information about some aspect of a culture:</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=fullName&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Globalization.CompareInfo&gt;</ph> object that contains information about how the culture compares and orders strings.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=fullName&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object that provides culture-specific information used in formatting date and time data.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A?displayProperty=fullName&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information used in formatting numeric data.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A?displayProperty=fullName&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Globalization.TextInfo&gt;</ph> object that provides information about the culture's writing system.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>In general, do not make any assumptions about the values of specific <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> properties and their related objects.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Instead, you should view culture-specific data as subject to change, for these reasons:</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Individual property values are subject to change and revision over time, as data is corrected, better data becomes available, or culture-specific conventions change.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Individual property values may vary across versions of the .NET Framework or operating system versions.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>The .NET Framework supports replacement cultures.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>This makes it possible to define a new custom culture that either supplements existing standard cultures or completely replaces an existing standard culture.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>The user can customize culture-specific settings by using the <bpt id="p1">**</bpt>Region and Language<ept id="p1">**</ept> app in Control Panel.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>When you instantiate a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object, you can determine whether it reflects these user customizations by calling the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Typically, for end-user apps, you should respect user preferences so that the user is presented with data in a format that he or she expects.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Globalization and Localization<ept id="p1">](../../../docs/standard/globalization-localization/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](../../../docs/standard/base-types/best-practices-strings.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>