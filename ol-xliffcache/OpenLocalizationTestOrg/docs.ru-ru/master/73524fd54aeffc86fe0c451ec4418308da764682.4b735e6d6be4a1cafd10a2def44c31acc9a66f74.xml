{"content":"---\ntitle: C# switch statement\nms.date: 08/14/2018\nf1_keywords:\n  - \"switch_CSharpKeyword\"\n  - \"switch\"\n  - \"case\"\n  - \"case_CSharpKeyword\"\nhelpviewer_keywords:\n  - \"switch statement [C#]\"\n  - \"switch keyword [C#]\"\n  - \"case statement [C#]\"\n  - \"default keyword [C#]\"\nms.assetid: 44bae8b8-8841-4d85-826b-8a94277daecb\n---\n# switch (C# reference)\n\n`switch` is a selection statement that chooses a single *switch section* to execute from a list of candidates based on a pattern match with the *match expression*.\n\n[!code-csharp[switch#1](~/samples/snippets/csharp/language-reference/keywords/switch/switch1.cs#1)]\n\nThe `switch` statement is often used as an alternative to an [if-else](if-else.md) construct if a single expression is tested against three or more conditions. For example, the following `switch` statement determines whether a variable of type `Color` has one of three values:\n\n[!code-csharp[switch#3](~/samples/snippets/csharp/language-reference/keywords/switch/switch3.cs#1)]\n\nIt is equivalent to the following example that uses an `if`-`else` construct.\n\n[!code-csharp[switch#3a](~/samples/snippets/csharp/language-reference/keywords/switch/switch3a.cs#1)]\n\n## The match expression\n\nThe match expression provides the value to match against the patterns in `case` labels. Its syntax is:\n\n```csharp\n   switch (expr)\n```\n\nIn C# 6, the match expression must be an expression that returns a value of the following types:\n\n- a [char](char.md).\n- a [string](string.md).\n- a [bool](bool.md).\n- an integral value, such as an [int](int.md) or a [long](long.md).\n- an [enum](enum.md) value.\n\nStarting with C# 7.0, the match expression can be any non-null expression.\n\n## The switch section\n\nA `switch` statement includes one or more switch sections. Each switch section contains one or more *case labels* (either a case or default label) followed by one or more statements. The `switch` statement may include at most one default label placed in any switch section. The following example shows a simple `switch` statement that has three switch sections, each containing two statements. The second switch section contains the `case 2:` and `case 3:` labels.\n\nA `switch` statement can include any number of switch sections, and each section can have one or more case labels, as shown in the following example. However, no two case labels may contain the same expression.\n\n[!code-csharp[switch#2](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch2.cs#1)]\n\nOnly one switch section in a switch statement executes. C# does not allow execution to continue from one switch section to the next. Because of this, the following code generates a compiler error, CS0163: \"Control cannot fall through from one case label (\\<case label>) to another.\"\n\n```csharp\nswitch (caseSwitch)\n{\n    // The following switch section causes an error.\n    case 1:\n        Console.WriteLine(\"Case 1...\");\n        // Add a break or other jump statement here.\n    case 2:\n        Console.WriteLine(\"... and/or Case 2\");\n        break;\n}\n```\n\nThis requirement is usually met by explicitly exiting the switch section by using a [break](break.md), [goto](goto.md), or [return](return.md) statement. However, the following code is also valid, because it ensures that program control cannot fall through to the `default` switch section.\n\n[!code-csharp[switch#4](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch4.cs#1)]\n\nExecution of the statement list in the switch section with a case label that matches the match expression begins with the first statement and proceeds through the statement list, typically until a jump statement, such as a `break`, `goto case`, `goto label`, `return`, or `throw`, is reached. At that point, control is transferred outside the `switch` statement or to another case label. A `goto` statement, if it is used, must transfer control to a constant label. This restriction is necessary, since attempting to transfer control to a non-constant label can have undesirable side-effects, such transferring control to an unintended location in code or creating an endless loop.\n\n## Case labels\n\nEach case label specifies a pattern to compare to the match expression (the `caseSwitch` variable in the previous examples). If they match, control is transferred to the switch section that contains the **first** matching case label. If no case label pattern matches the match expression, control is transferred to the section with the `default` case label, if there is one. If there is no `default` case, no statements in any switch section are executed, and control is transferred outside the `switch` statement.\n\nFor information on the `switch` statement and pattern matching, see the [Pattern matching with the `switch` statement](#pattern) section.\n\nBecause C# 6 supports only the constant pattern and does not allow the repetition of constant values, case labels define mutually exclusive values, and only one pattern can match the match expression. As a result, the order in which `case` statements appear is unimportant.\n\nIn C# 7.0, however, because other patterns are supported, case labels need not define mutually exclusive values, and multiple patterns can match the match expression. Because only the statements in the first switch section that contains the matching pattern are executed, the order in which `case` statements appear is now important. If C# detects a switch section whose case statement or statements are equivalent to or are subsets of previous statements, it generates a compiler error, CS8120, \"The switch case has already been handled by a previous case.\"\n\nThe following example illustrates a `switch` statement that uses a variety of non-mutually exclusive patterns. If you move the `case 0:` switch section so that it is no longer the first section in the `switch` statement, C# generates a compiler error because an integer whose value is zero is a subset of all integers, which is the pattern defined by the `case int val` statement.\n\n[!code-csharp[switch#5](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch5.cs#1)]\n\nYou can correct this issue and eliminate the compiler warning in one of two ways:\n\n- By changing the order of the switch sections.\n\n- By using a [when clause](#when) in the `case` label.\n\n## The `default` case\n\nThe `default` case specifies the switch section to execute if the match expression does not match any other `case` label. If a `default` case is not present and the match expression does not match any other `case` label, program flow falls through the `switch` statement.\n\nThe `default` case can appear in any order in the `switch` statement. Regardless of its order in the source code, it is always evaluated last, after all `case` labels have been evaluated.\n\n## <a name=\"pattern\" /> Pattern matching with the `switch` statement\n\nEach `case` statement defines a pattern that, if it matches the match expression, causes its  containing switch section to be executed. All versions of C# support the constant pattern. The remaining patterns are supported beginning with C# 7.0.\n\n### Constant pattern\n\nThe constant pattern tests whether the match expression equals a specified constant. Its syntax is:\n\n```csharp\n   case constant:\n```\n\nwhere *constant* is the value to test for. *constant* can be any of the following constant expressions:\n\n- A [bool](bool.md) literal, either `true` or `false`.\n- Any integral constant, such as an [int](int.md), a [long](long.md), or a [byte](byte.md).\n- The name of a declared `const` variable.\n- An enumeration constant.\n- A [char](char.md) literal.\n- A [string](string.md) literal.\n\nThe constant expression is evaluated as follows:\n\n- If *expr* and *constant* are integral types, the C# equality operator determines whether the expression returns `true` (that is, whether `expr == constant`).\n\n- Otherwise, the value of the expression is determined by a call to the static [Object.Equals(expr, constant)](xref:System.Object.Equals(System.Object,System.Object)) method.\n\nThe following example uses the constant pattern to determine whether a particular date is a weekend, the first day of the work week, the last day of the work week, or the middle of the work week. It evaluates the <xref:System.DateTime.DayOfWeek?displayProperty=nameWithType> property of the current day against the members of the <xref:System.DayOfWeek> enumeration.\n\n[!code-csharp[switch#7](../../../../samples/snippets/csharp/language-reference/keywords/switch/const-pattern.cs#1)]\n\nThe following example uses the constant pattern to handle user input in a console application that simulates an automatic coffee machine.\n\n[!code-csharp[switch#6](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch6.cs)]\n\n### Type pattern\n\nThe type pattern enables concise type evaluation and conversion. When used with the `switch` statement to perform pattern matching, it tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type. Its syntax is:\n\n```csharp\n   case type varname\n```\n\nwhere *type* is the name of the type to which the result of *expr* is to be converted, and *varname* is the object to which the result of *expr* is converted if the match succeeds.\n\nThe `case` expression is `true` if any of the following is true:\n\n- *expr* is an instance of the same type as *type*.\n\n- *expr* is an instance of a type that derives from *type*. In other words, the result of *expr* can be upcast to an instance of *type*.\n\n- *expr* has a compile-time type that is a base class of *type*, and *expr* has a runtime type that is *type* or is derived from *type*. The *compile-time type* of a variable is the variable's type as defined in its type declaration. The *runtime type* of a variable is the type of the instance that is assigned to that variable.\n\n- *expr* is an instance of a type that implements the *type* interface.\n\nIf the case expression is true, *varname* is definitely assigned and has local scope within the switch section only.\n\nNote that `null` does not match a type. To match a `null`, you use the following `case` label:\n\n```csharp\ncase null:\n```\n\nThe following example uses the type pattern to provide information about various kinds of collection types.\n\n[!code-csharp[type-pattern#1](~/samples/snippets/csharp/language-reference/keywords/switch/type-pattern.cs#1)]\n\nWithout pattern matching, this code might be written as follows. The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a `null` or to perform repeated casts.\n\n[!code-csharp[type-pattern2#1](~/samples/snippets/csharp/language-reference/keywords/switch/type-pattern2.cs#1)]\n\n## <a name=\"when\" /> The `case` statement and the `when` clause\n\nStarting with C# 7.0, because case statements need not be mutually exclusive, you can add a `when` clause to specify an additional condition that must be satisfied for the case statement to evaluate to true. The `when` clause can be any expression that returns a Boolean value.\n\nThe following example defines a base `Shape` class, a `Rectangle` class that derives from `Shape`, and a `Square` class that derives from `Rectangle`. It uses the `when` clause to ensure that the `ShowShapeInfo` treats a `Rectangle` object that has been assigned equal lengths and widths as a `Square` even if it has not been instantiated as a `Square` object. The method does not attempt to display information either about an object that is `null` or a shape whose area is zero.\n\n[!code-csharp[when-clause#1](~/samples/snippets/csharp/language-reference/keywords/switch/when-clause.cs#1)]\n\nNote that the `when` clause in the example that attempts to test whether a `Shape` object is `null` does not execute. The correct type pattern to test for a `null` is `case null:`.\n\n## C# language specification\n\nFor more information, see [The switch statement](~/_csharplang/spec/statements.md#the-switch-statement) in the [C# Language Specification](../language-specification/index.md). The language specification is the definitive source for C# syntax and usage.\n\n## See also\n\n- [C# Reference](../index.md)\n- [C# Programming Guide](../../programming-guide/index.md)\n- [C# Keywords](index.md)\n- [if-else](if-else.md)\n- [Pattern Matching](../../pattern-matching.md)\n","nodes":[{"pos":[4,316],"embed":true,"restype":"x-metadata","content":"title: C# switch statement\nms.date: 08/14/2018\nf1_keywords:\n  - \"switch_CSharpKeyword\"\n  - \"switch\"\n  - \"case\"\n  - \"case_CSharpKeyword\"\nhelpviewer_keywords:\n  - \"switch statement [C#]\"\n  - \"switch keyword [C#]\"\n  - \"case statement [C#]\"\n  - \"default keyword [C#]\"\nms.assetid: 44bae8b8-8841-4d85-826b-8a94277daecb","nodes":[{"content":"C# switch statement","nodes":[{"pos":[0,19],"content":"C# switch statement","nodes":[{"content":"C# switch statement","pos":[0,19]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[323,344],"content":"switch (C# reference)","linkify":"switch (C# reference)","nodes":[{"content":"switch (C# reference)","pos":[0,21]}]},{"pos":[346,509],"content":"<ph id=\"ph1\">`switch`</ph> is a selection statement that chooses a single <bpt id=\"p1\">*</bpt>switch section<ept id=\"p1\">*</ept> to execute from a list of candidates based on a pattern match with the <bpt id=\"p2\">*</bpt>match expression<ept id=\"p2\">*</ept>.","source":"`switch` is a selection statement that chooses a single *switch section* to execute from a list of candidates based on a pattern match with the *match expression*."},{"content":"The <ph id=\"ph1\">`switch`</ph> statement is often used as an alternative to an <bpt id=\"p1\">[</bpt>if-else<ept id=\"p1\">](if-else.md)</ept> construct if a single expression is tested against three or more conditions.","pos":[612,771],"source":"The `switch` statement is often used as an alternative to an [if-else](if-else.md) construct if a single expression is tested against three or more conditions."},{"content":"For example, the following <ph id=\"ph1\">`switch`</ph> statement determines whether a variable of type <ph id=\"ph2\">`Color`</ph> has one of three values:","pos":[772,888],"source":" For example, the following `switch` statement determines whether a variable of type `Color` has one of three values:"},{"pos":[991,1068],"content":"It is equivalent to the following example that uses an <ph id=\"ph1\">`if`</ph><ph id=\"ph2\">-</ph><ph id=\"ph3\">`else`</ph> construct.","source":"It is equivalent to the following example that uses an `if`-`else` construct."},{"pos":[1176,1196],"content":"The match expression","linkify":"The match expression","nodes":[{"content":"The match expression","pos":[0,20]}]},{"content":"The match expression provides the value to match against the patterns in <ph id=\"ph1\">`case`</ph> labels.","pos":[1198,1285],"source":"The match expression provides the value to match against the patterns in `case` labels."},{"content":"Its syntax is:","pos":[1286,1300]},{"content":"In C# 6, the match expression must be an expression that returns a value of the following types:","pos":[1334,1430]},{"pos":[1434,1452],"content":"a <bpt id=\"p1\">[</bpt>char<ept id=\"p1\">](char.md)</ept>.","source":"a [char](char.md)."},{"pos":[1455,1477],"content":"a <bpt id=\"p1\">[</bpt>string<ept id=\"p1\">](string.md)</ept>.","source":"a [string](string.md)."},{"pos":[1480,1498],"content":"a <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](bool.md)</ept>.","source":"a [bool](bool.md)."},{"pos":[1501,1566],"content":"an integral value, such as an <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](int.md)</ept> or a <bpt id=\"p2\">[</bpt>long<ept id=\"p2\">](long.md)</ept>.","source":"an integral value, such as an [int](int.md) or a [long](long.md)."},{"pos":[1569,1594],"content":"an <bpt id=\"p1\">[</bpt>enum<ept id=\"p1\">](enum.md)</ept> value.","source":"an [enum](enum.md) value."},{"content":"Starting with C# 7.0, the match expression can be any non-null expression.","pos":[1596,1670]},{"pos":[1675,1693],"content":"The switch section","linkify":"The switch section","nodes":[{"content":"The switch section","pos":[0,18]}]},{"content":"A <ph id=\"ph1\">`switch`</ph> statement includes one or more switch sections.","pos":[1695,1753],"source":"A `switch` statement includes one or more switch sections."},{"content":"Each switch section contains one or more <bpt id=\"p1\">*</bpt>case labels<ept id=\"p1\">*</ept> (either a case or default label) followed by one or more statements.","pos":[1754,1877],"source":" Each switch section contains one or more *case labels* (either a case or default label) followed by one or more statements."},{"content":"The <ph id=\"ph1\">`switch`</ph> statement may include at most one default label placed in any switch section.","pos":[1878,1968],"source":" The `switch` statement may include at most one default label placed in any switch section."},{"content":"The following example shows a simple <ph id=\"ph1\">`switch`</ph> statement that has three switch sections, each containing two statements.","pos":[1969,2088],"source":" The following example shows a simple `switch` statement that has three switch sections, each containing two statements."},{"content":"The second switch section contains the <ph id=\"ph1\">`case 2:`</ph> and <ph id=\"ph2\">`case 3:`</ph> labels.","pos":[2089,2159],"source":" The second switch section contains the `case 2:` and `case 3:` labels."},{"content":"A <ph id=\"ph1\">`switch`</ph> statement can include any number of switch sections, and each section can have one or more case labels, as shown in the following example.","pos":[2161,2310],"source":"A `switch` statement can include any number of switch sections, and each section can have one or more case labels, as shown in the following example."},{"content":"However, no two case labels may contain the same expression.","pos":[2311,2371]},{"content":"Only one switch section in a switch statement executes.","pos":[2484,2539]},{"content":"C# does not allow execution to continue from one switch section to the next.","pos":[2540,2616]},{"content":"Because of this, the following code generates a compiler error, CS0163: \"Control cannot fall through from one case label (<ph id=\"ph1\">\\&lt;</ph>case label&gt;) to another.\"","pos":[2617,2766],"source":" Because of this, the following code generates a compiler error, CS0163: \"Control cannot fall through from one case label (\\<case label>) to another.\""},{"content":"This requirement is usually met by explicitly exiting the switch section by using a <bpt id=\"p1\">[</bpt>break<ept id=\"p1\">](break.md)</ept>, <bpt id=\"p2\">[</bpt>goto<ept id=\"p2\">](goto.md)</ept>, or <bpt id=\"p3\">[</bpt>return<ept id=\"p3\">](return.md)</ept> statement.","pos":[3040,3193],"source":"This requirement is usually met by explicitly exiting the switch section by using a [break](break.md), [goto](goto.md), or [return](return.md) statement."},{"content":"However, the following code is also valid, because it ensures that program control cannot fall through to the <ph id=\"ph1\">`default`</ph> switch section.","pos":[3194,3329],"source":" However, the following code is also valid, because it ensures that program control cannot fall through to the `default` switch section."},{"content":"Execution of the statement list in the switch section with a case label that matches the match expression begins with the first statement and proceeds through the statement list, typically until a jump statement, such as a <ph id=\"ph1\">`break`</ph>, <ph id=\"ph2\">`goto case`</ph>, <ph id=\"ph3\">`goto label`</ph>, <ph id=\"ph4\">`return`</ph>, or <ph id=\"ph5\">`throw`</ph>, is reached.","pos":[3442,3734],"source":"Execution of the statement list in the switch section with a case label that matches the match expression begins with the first statement and proceeds through the statement list, typically until a jump statement, such as a `break`, `goto case`, `goto label`, `return`, or `throw`, is reached."},{"content":"At that point, control is transferred outside the <ph id=\"ph1\">`switch`</ph> statement or to another case label.","pos":[3735,3829],"source":" At that point, control is transferred outside the `switch` statement or to another case label."},{"content":"A <ph id=\"ph1\">`goto`</ph> statement, if it is used, must transfer control to a constant label.","pos":[3830,3907],"source":" A `goto` statement, if it is used, must transfer control to a constant label."},{"content":"This restriction is necessary, since attempting to transfer control to a non-constant label can have undesirable side-effects, such transferring control to an unintended location in code or creating an endless loop.","pos":[3908,4123]},{"pos":[4128,4139],"content":"Case labels","linkify":"Case labels","nodes":[{"content":"Case labels","pos":[0,11]}]},{"content":"Each case label specifies a pattern to compare to the match expression (the <ph id=\"ph1\">`caseSwitch`</ph> variable in the previous examples).","pos":[4141,4265],"source":"Each case label specifies a pattern to compare to the match expression (the `caseSwitch` variable in the previous examples)."},{"content":"If they match, control is transferred to the switch section that contains the <bpt id=\"p1\">**</bpt>first<ept id=\"p1\">**</ept> matching case label.","pos":[4266,4374],"source":" If they match, control is transferred to the switch section that contains the **first** matching case label."},{"content":"If no case label pattern matches the match expression, control is transferred to the section with the <ph id=\"ph1\">`default`</ph> case label, if there is one.","pos":[4375,4515],"source":" If no case label pattern matches the match expression, control is transferred to the section with the `default` case label, if there is one."},{"content":"If there is no <ph id=\"ph1\">`default`</ph> case, no statements in any switch section are executed, and control is transferred outside the <ph id=\"ph2\">`switch`</ph> statement.","pos":[4516,4655],"source":" If there is no `default` case, no statements in any switch section are executed, and control is transferred outside the `switch` statement."},{"pos":[4657,4794],"content":"For information on the <ph id=\"ph1\">`switch`</ph> statement and pattern matching, see the <bpt id=\"p1\">[</bpt>Pattern matching with the <ph id=\"ph2\">`switch`</ph> statement<ept id=\"p1\">](#pattern)</ept> section.","source":"For information on the `switch` statement and pattern matching, see the [Pattern matching with the `switch` statement](#pattern) section."},{"content":"Because C# 6 supports only the constant pattern and does not allow the repetition of constant values, case labels define mutually exclusive values, and only one pattern can match the match expression.","pos":[4796,4996]},{"content":"As a result, the order in which <ph id=\"ph1\">`case`</ph> statements appear is unimportant.","pos":[4997,5069],"source":" As a result, the order in which `case` statements appear is unimportant."},{"content":"In C# 7.0, however, because other patterns are supported, case labels need not define mutually exclusive values, and multiple patterns can match the match expression.","pos":[5071,5237]},{"content":"Because only the statements in the first switch section that contains the matching pattern are executed, the order in which <ph id=\"ph1\">`case`</ph> statements appear is now important.","pos":[5238,5404],"source":" Because only the statements in the first switch section that contains the matching pattern are executed, the order in which `case` statements appear is now important."},{"content":"If C# detects a switch section whose case statement or statements are equivalent to or are subsets of previous statements, it generates a compiler error, CS8120, \"The switch case has already been handled by a previous case.\"","pos":[5405,5629]},{"content":"The following example illustrates a <ph id=\"ph1\">`switch`</ph> statement that uses a variety of non-mutually exclusive patterns.","pos":[5631,5741],"source":"The following example illustrates a `switch` statement that uses a variety of non-mutually exclusive patterns."},{"content":"If you move the <ph id=\"ph1\">`case 0:`</ph> switch section so that it is no longer the first section in the <ph id=\"ph2\">`switch`</ph> statement, C# generates a compiler error because an integer whose value is zero is a subset of all integers, which is the pattern defined by the <ph id=\"ph3\">`case int val`</ph> statement.","pos":[5742,6011],"source":" If you move the `case 0:` switch section so that it is no longer the first section in the `switch` statement, C# generates a compiler error because an integer whose value is zero is a subset of all integers, which is the pattern defined by the `case int val` statement."},{"content":"You can correct this issue and eliminate the compiler warning in one of two ways:","pos":[6124,6205]},{"content":"By changing the order of the switch sections.","pos":[6209,6254]},{"pos":[6258,6310],"content":"By using a <bpt id=\"p1\">[</bpt>when clause<ept id=\"p1\">](#when)</ept> in the <ph id=\"ph1\">`case`</ph> label.","source":"By using a [when clause](#when) in the `case` label."},{"pos":[6315,6333],"content":"The <ph id=\"ph1\">`default`</ph> case","linkify":"The `default` case","source":"The `default` case"},{"content":"The <ph id=\"ph1\">`default`</ph> case specifies the switch section to execute if the match expression does not match any other <ph id=\"ph2\">`case`</ph> label.","pos":[6335,6456],"source":"The `default` case specifies the switch section to execute if the match expression does not match any other `case` label."},{"content":"If a <ph id=\"ph1\">`default`</ph> case is not present and the match expression does not match any other <ph id=\"ph2\">`case`</ph> label, program flow falls through the <ph id=\"ph3\">`switch`</ph> statement.","pos":[6457,6606],"source":" If a `default` case is not present and the match expression does not match any other `case` label, program flow falls through the `switch` statement."},{"content":"The <ph id=\"ph1\">`default`</ph> case can appear in any order in the <ph id=\"ph2\">`switch`</ph> statement.","pos":[6608,6677],"source":"The `default` case can appear in any order in the `switch` statement."},{"content":"Regardless of its order in the source code, it is always evaluated last, after all <ph id=\"ph1\">`case`</ph> labels have been evaluated.","pos":[6678,6795],"source":" Regardless of its order in the source code, it is always evaluated last, after all `case` labels have been evaluated."},{"pos":[6800,6865],"content":"<ph id=\"ph1\">&lt;a name=\"pattern\" /&gt;</ph> Pattern matching with the <ph id=\"ph2\">`switch`</ph> statement","linkify":"<a name=\"pattern\" /> Pattern matching with the `switch` statement","source":"<a name=\"pattern\" /> Pattern matching with the `switch` statement"},{"content":"Each <ph id=\"ph1\">`case`</ph> statement defines a pattern that, if it matches the match expression, causes its  containing switch section to be executed.","pos":[6867,7002],"source":"Each `case` statement defines a pattern that, if it matches the match expression, causes its  containing switch section to be executed."},{"content":"All versions of C# support the constant pattern.","pos":[7003,7051]},{"content":"The remaining patterns are supported beginning with C# 7.0.","pos":[7052,7111]},{"pos":[7117,7133],"content":"Constant pattern","linkify":"Constant pattern","nodes":[{"content":"Constant pattern","pos":[0,16]}]},{"content":"The constant pattern tests whether the match expression equals a specified constant.","pos":[7135,7219]},{"content":"Its syntax is:","pos":[7220,7234]},{"content":"where <bpt id=\"p1\">*</bpt>constant<ept id=\"p1\">*</ept> is the value to test for.","pos":[7269,7311],"source":"where *constant* is the value to test for."},{"content":"<bpt id=\"p1\">*</bpt>constant<ept id=\"p1\">*</ept> can be any of the following constant expressions:","pos":[7312,7372],"source":"*constant* can be any of the following constant expressions:"},{"pos":[7376,7428],"content":"A <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](bool.md)</ept> literal, either <ph id=\"ph1\">`true`</ph> or <ph id=\"ph2\">`false`</ph>.","source":"A [bool](bool.md) literal, either `true` or `false`."},{"pos":[7431,7520],"content":"Any integral constant, such as an <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](int.md)</ept>, a <bpt id=\"p2\">[</bpt>long<ept id=\"p2\">](long.md)</ept>, or a <bpt id=\"p3\">[</bpt>byte<ept id=\"p3\">](byte.md)</ept>.","source":"Any integral constant, such as an [int](int.md), a [long](long.md), or a [byte](byte.md)."},{"pos":[7523,7563],"content":"The name of a declared <ph id=\"ph1\">`const`</ph> variable.","source":"The name of a declared `const` variable."},{"content":"An enumeration constant.","pos":[7566,7590]},{"pos":[7593,7619],"content":"A <bpt id=\"p1\">[</bpt>char<ept id=\"p1\">](char.md)</ept> literal.","source":"A [char](char.md) literal."},{"pos":[7622,7652],"content":"A <bpt id=\"p1\">[</bpt>string<ept id=\"p1\">](string.md)</ept> literal.","source":"A [string](string.md) literal."},{"content":"The constant expression is evaluated as follows:","pos":[7654,7702]},{"pos":[7706,7863],"content":"If <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>constant<ept id=\"p2\">*</ept> are integral types, the C# equality operator determines whether the expression returns <ph id=\"ph1\">`true`</ph> (that is, whether <ph id=\"ph2\">`expr == constant`</ph>).","source":"If *expr* and *constant* are integral types, the C# equality operator determines whether the expression returns `true` (that is, whether `expr == constant`)."},{"pos":[7867,8039],"content":"Otherwise, the value of the expression is determined by a call to the static <bpt id=\"p1\">[</bpt>Object.Equals(expr, constant)<ept id=\"p1\">](xref:System.Object.Equals(System.Object,System.Object))</ept> method.","source":"Otherwise, the value of the expression is determined by a call to the static [Object.Equals(expr, constant)](xref:System.Object.Equals(System.Object,System.Object)) method."},{"content":"The following example uses the constant pattern to determine whether a particular date is a weekend, the first day of the work week, the last day of the work week, or the middle of the work week.","pos":[8041,8236]},{"content":"It evaluates the <ph id=\"ph1\">&lt;xref:System.DateTime.DayOfWeek?displayProperty=nameWithType&gt;</ph> property of the current day against the members of the <ph id=\"ph2\">&lt;xref:System.DayOfWeek&gt;</ph> enumeration.","pos":[8237,8407],"source":" It evaluates the <xref:System.DateTime.DayOfWeek?displayProperty=nameWithType> property of the current day against the members of the <xref:System.DayOfWeek> enumeration."},{"content":"The following example uses the constant pattern to handle user input in a console application that simulates an automatic coffee machine.","pos":[8526,8663]},{"pos":[8778,8790],"content":"Type pattern","linkify":"Type pattern","nodes":[{"content":"Type pattern","pos":[0,12]}]},{"content":"The type pattern enables concise type evaluation and conversion.","pos":[8792,8856]},{"content":"When used with the <ph id=\"ph1\">`switch`</ph> statement to perform pattern matching, it tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type.","pos":[8857,9047],"source":" When used with the `switch` statement to perform pattern matching, it tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type."},{"content":"Its syntax is:","pos":[9048,9062]},{"pos":[9100,9280],"content":"where <bpt id=\"p1\">*</bpt>type<ept id=\"p1\">*</ept> is the name of the type to which the result of <bpt id=\"p2\">*</bpt>expr<ept id=\"p2\">*</ept> is to be converted, and <bpt id=\"p3\">*</bpt>varname<ept id=\"p3\">*</ept> is the object to which the result of <bpt id=\"p4\">*</bpt>expr<ept id=\"p4\">*</ept> is converted if the match succeeds.","source":"where *type* is the name of the type to which the result of *expr* is to be converted, and *varname* is the object to which the result of *expr* is converted if the match succeeds."},{"pos":[9282,9346],"content":"The <ph id=\"ph1\">`case`</ph> expression is <ph id=\"ph2\">`true`</ph> if any of the following is true:","source":"The `case` expression is `true` if any of the following is true:"},{"pos":[9350,9399],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of the same type as <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","source":"*expr* is an instance of the same type as *type*."},{"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of a type that derives from <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","pos":[9403,9460],"source":"*expr* is an instance of a type that derives from *type*."},{"content":"In other words, the result of <bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> can be upcast to an instance of <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>.","pos":[9461,9537],"source":" In other words, the result of *expr* can be upcast to an instance of *type*."},{"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> has a compile-time type that is a base class of <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept>, and <bpt id=\"p3\">*</bpt>expr<ept id=\"p3\">*</ept> has a runtime type that is <bpt id=\"p4\">*</bpt>type<ept id=\"p4\">*</ept> or is derived from <bpt id=\"p5\">*</bpt>type<ept id=\"p5\">*</ept>.","pos":[9541,9675],"source":"*expr* has a compile-time type that is a base class of *type*, and *expr* has a runtime type that is *type* or is derived from *type*."},{"content":"The <bpt id=\"p1\">*</bpt>compile-time type<ept id=\"p1\">*</ept> of a variable is the variable's type as defined in its type declaration.","pos":[9676,9772],"source":" The *compile-time type* of a variable is the variable's type as defined in its type declaration."},{"content":"The <bpt id=\"p1\">*</bpt>runtime type<ept id=\"p1\">*</ept> of a variable is the type of the instance that is assigned to that variable.","pos":[9773,9868],"source":" The *runtime type* of a variable is the type of the instance that is assigned to that variable."},{"pos":[9872,9941],"content":"<bpt id=\"p1\">*</bpt>expr<ept id=\"p1\">*</ept> is an instance of a type that implements the <bpt id=\"p2\">*</bpt>type<ept id=\"p2\">*</ept> interface.","source":"*expr* is an instance of a type that implements the *type* interface."},{"pos":[9943,10059],"content":"If the case expression is true, <bpt id=\"p1\">*</bpt>varname<ept id=\"p1\">*</ept> is definitely assigned and has local scope within the switch section only.","source":"If the case expression is true, *varname* is definitely assigned and has local scope within the switch section only."},{"content":"Note that <ph id=\"ph1\">`null`</ph> does not match a type.","pos":[10061,10100],"source":"Note that `null` does not match a type."},{"content":"To match a <ph id=\"ph1\">`null`</ph>, you use the following <ph id=\"ph2\">`case`</ph> label:","pos":[10101,10155],"source":" To match a `null`, you use the following `case` label:"},{"content":"The following example uses the type pattern to provide information about various kinds of collection types.","pos":[10183,10290]},{"content":"Without pattern matching, this code might be written as follows.","pos":[10404,10468]},{"content":"The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a <ph id=\"ph1\">`null`</ph> or to perform repeated casts.","pos":[10469,10647],"source":" The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a `null` or to perform repeated casts."},{"pos":[10766,10826],"content":"<ph id=\"ph1\">&lt;a name=\"when\" /&gt;</ph> The <ph id=\"ph2\">`case`</ph> statement and the <ph id=\"ph3\">`when`</ph> clause","linkify":"<a name=\"when\" /> The `case` statement and the `when` clause","source":"<a name=\"when\" /> The `case` statement and the `when` clause"},{"content":"Starting with C# 7.0, because case statements need not be mutually exclusive, you can add a <ph id=\"ph1\">`when`</ph> clause to specify an additional condition that must be satisfied for the case statement to evaluate to true.","pos":[10828,11035],"source":"Starting with C# 7.0, because case statements need not be mutually exclusive, you can add a `when` clause to specify an additional condition that must be satisfied for the case statement to evaluate to true."},{"content":"The <ph id=\"ph1\">`when`</ph> clause can be any expression that returns a Boolean value.","pos":[11036,11105],"source":" The `when` clause can be any expression that returns a Boolean value."},{"content":"The following example defines a base <ph id=\"ph1\">`Shape`</ph> class, a <ph id=\"ph2\">`Rectangle`</ph> class that derives from <ph id=\"ph3\">`Shape`</ph>, and a <ph id=\"ph4\">`Square`</ph> class that derives from <ph id=\"ph5\">`Rectangle`</ph>.","pos":[11107,11257],"source":"The following example defines a base `Shape` class, a `Rectangle` class that derives from `Shape`, and a `Square` class that derives from `Rectangle`."},{"content":"It uses the <ph id=\"ph1\">`when`</ph> clause to ensure that the <ph id=\"ph2\">`ShowShapeInfo`</ph> treats a <ph id=\"ph3\">`Rectangle`</ph> object that has been assigned equal lengths and widths as a <ph id=\"ph4\">`Square`</ph> even if it has not been instantiated as a <ph id=\"ph5\">`Square`</ph> object.","pos":[11258,11467],"source":" It uses the `when` clause to ensure that the `ShowShapeInfo` treats a `Rectangle` object that has been assigned equal lengths and widths as a `Square` even if it has not been instantiated as a `Square` object."},{"content":"The method does not attempt to display information either about an object that is <ph id=\"ph1\">`null`</ph> or a shape whose area is zero.","pos":[11468,11587],"source":" The method does not attempt to display information either about an object that is `null` or a shape whose area is zero."},{"content":"Note that the <ph id=\"ph1\">`when`</ph> clause in the example that attempts to test whether a <ph id=\"ph2\">`Shape`</ph> object is <ph id=\"ph3\">`null`</ph> does not execute.","pos":[11699,11816],"source":"Note that the `when` clause in the example that attempts to test whether a `Shape` object is `null` does not execute."},{"content":"The correct type pattern to test for a <ph id=\"ph1\">`null`</ph> is <ph id=\"ph2\">`case null:`</ph>.","pos":[11817,11879],"source":" The correct type pattern to test for a `null` is `case null:`."},{"pos":[11884,11909],"content":"C# language specification","linkify":"C# language specification","nodes":[{"content":"C# language specification","pos":[0,25]}]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>The switch statement<ept id=\"p1\">](~/_csharplang/spec/statements.md#the-switch-statement)</ept> in the <bpt id=\"p2\">[</bpt>C# Language Specification<ept id=\"p2\">](../language-specification/index.md)</ept>.","pos":[11911,12086],"source":"For more information, see [The switch statement](~/_csharplang/spec/statements.md#the-switch-statement) in the [C# Language Specification](../language-specification/index.md)."},{"content":"The language specification is the definitive source for C# syntax and usage.","pos":[12087,12163]},{"pos":[12168,12176],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[12180,12207],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../index.md)</ept>","source":"[C# Reference](../index.md)"},{"pos":[12210,12266],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../programming-guide/index.md)"},{"pos":[12269,12292],"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](index.md)</ept>","source":"[C# Keywords](index.md)"},{"pos":[12295,12316],"content":"<bpt id=\"p1\">[</bpt>if-else<ept id=\"p1\">](if-else.md)</ept>","source":"[if-else](if-else.md)"},{"pos":[12319,12364],"content":"<bpt id=\"p1\">[</bpt>Pattern Matching<ept id=\"p1\">](../../pattern-matching.md)</ept>","source":"[Pattern Matching](../../pattern-matching.md)"}]}