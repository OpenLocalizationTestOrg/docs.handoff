{"content":"---\ntitle: \"COM Callable Wrapper\"\nms.date: \"10/23/2018\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"CCW\"\n  - \"COM interop, COM wrappers\"\n  - \"COM wrappers\"\n  - \"callable wrappers\"\n  - \"interoperation with unmanaged code, COM wrappers\"\n  - \"COM callable wrappers\"\nms.assetid: d04be3b5-27b9-4f5b-8469-a44149fabf78\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n\n# COM Callable Wrapper\n\nWhen a COM client calls a .NET object, the common language runtime creates the managed object and a COM callable wrapper (CCW) for the object. Unable to reference a .NET object directly, COM clients use the CCW as a proxy for the managed object.\n\nThe runtime creates exactly one CCW for a managed object, regardless of the number of COM clients requesting its services. As the following illustration shows, multiple COM clients can hold a reference to the CCW that exposes the INew interface. The CCW, in turn, holds a single reference to the managed object that implements the interface and is garbage collected. Both COM and .NET clients can make requests on the same managed object simultaneously.\n\n![COM callable wrapper](./media/ccw.gif \"ccw\")\nAccessing .NET objects through COM callable wrapper\n\nCOM callable wrappers are invisible to other classes running within the .NET Framework. Their primary purpose is to marshal calls between managed and unmanaged code; however, CCWs also manage the object identity and object lifetime of the managed objects they wrap.\n\n## Object Identity\n\nThe runtime allocates memory for the .NET object from its garbage-collected heap, which enables the runtime to move the object around in memory as necessary. In contrast, the runtime allocates memory for the CCW from a noncollected heap, making it possible for COM clients to reference the wrapper directly.\n\n## Object Lifetime\n\nUnlike the .NET client it wraps, the CCW is reference-counted in traditional COM fashion. When the reference count on the CCW reaches zero, the wrapper releases its reference on the managed object. A managed object with no remaining references is collected during the next garbage-collection cycle.\n\n## Simulating COM interfaces\n\nCCW exposes all public, COM-visible interfaces, data types, and return values to COM clients in a manner that is consistent with COM's enforcement of interface-based interaction. For a COM client, invoking methods on a .NET Framework object is identical to invoking methods on a COM object.\n\nTo create this seamless approach, the CCW manufactures traditional COM interfaces, such as **IUnknown** and **IDispatch**. As the following illustration shows, the CCW maintains a single reference on the .NET object that it wraps. Both the COM client and .NET object interact with each other through the proxy and stub construction of the CCW.\n\n![COM interfaces](./media/ccwwithinterfaces.gif \"ccwwithinterfaces\")\nCOM interfaces and the COM callable wrapper\n\nIn addition to exposing the interfaces that are explicitly implemented by a class in the managed environment, the .NET Framework supplies implementations of the COM interfaces listed in the following table on behalf of the object. A .NET class can override the default behavior by providing its own implementation of these interfaces. However, the runtime always provides the implementation for the **IUnknown** and **IDispatch** interfaces.\n\n|Interface|Description|\n|---------------|-----------------|\n|**IDispatch**|Provides a mechanism for late binding to type.|\n|**IErrorInfo**|Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).|\n|**IProvideClassInfo**|Enables COM clients to gain access to the **ITypeInfo** interface implemented by a managed class.|\n|**ISupportErrorInfo**|Enables a COM client to determine whether the managed object supports the **IErrorInfo** interface. If so, enables the client to obtain a pointer to the latest exception object. All managed types support the **IErrorInfo** interface.|\n|**ITypeInfo**|Provides type information for a class that is exactly the same as the type information produced by Tlbexp.exe.|\n|**IUnknown**|Provides the standard implementation of the **IUnknown** interface with which the COM client manages the lifetime of the CCW and provides type coercion.|\n\n A managed class can also provide the COM interfaces described in the following table.\n\n|Interface|Description|\n|---------------|-----------------|\n|The (\\_*classname*) class interface|Interface, exposed by the runtime and not explicitly defined, that exposes all public interfaces, methods, properties, and fields that are explicitly exposed on a managed object.|\n|**IConnectionPoint** and **IConnectionPointContainer**|Interface for objects that source delegate-based events (an interface for registering event subscribers).|\n|**IDispatchEx**|Interface supplied by the runtime if the class implements **IExpando**. The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.|\n|**IEnumVARIANT**|Interface for collection-type classes, which enumerates the objects in the collection if the class implements **IEnumerable**.|\n\n## Introducing the class interface\n\nThe class interface, which is not explicitly defined in managed code, is an interface that exposes all public methods, properties, fields, and events that are explicitly exposed on the .NET object. This interface can be a dual or dispatch-only interface. The class interface receives the name of the .NET class itself, preceded by an underscore. For example, for class Mammal, the class interface is \\_Mammal.\n\nFor derived classes, the class interface also exposes all public methods, properties, and fields of the base class. The derived class also exposes a class interface for each base class. For example, if class Mammal extends class MammalSuperclass, which itself extends System.Object, the .NET object exposes to COM clients three class interfaces named \\_Mammal, \\_MammalSuperclass, and \\_Object.\n\nFor example, consider the following .NET class:\n\n```vb\n' Applies the ClassInterfaceAttribute to set the interface to dual.\n<ClassInterface(ClassInterfaceType.AutoDual)> _\n' Implicitly extends System.Object.\nPublic Class Mammal\n    Sub Eat()\n    Sub Breathe()\n    Sub Sleep()\nEnd Class\n```\n\n```csharp\n// Applies the ClassInterfaceAttribute to set the interface to dual.\n[ClassInterface(ClassInterfaceType.AutoDual)]\n// Implicitly extends System.Object.\npublic class Mammal\n{\n    public void Eat() {}\n    public void Breathe() {}\n    public void Sleep() {}\n}\n```\n\nThe COM client can obtain a pointer to a class interface named `_Mammal`, which is described in the type library that the [Type Library Exporter (Tlbexp.exe)](../tools/tlbexp-exe-type-library-exporter.md) tool generates. If the `Mammal` class implemented one or more interfaces, the interfaces would appear under the coclass.\n\n```\n[odl, uuid(…), hidden, dual, nonextensible, oleautomation]\ninterface _Mammal : IDispatch\n{\n    [id(0x00000000), propget] HRESULT ToString([out, retval] BSTR*\n        pRetVal);\n    [id(0x60020001)] HRESULT Equals([in] VARIANT obj, [out, retval]\n        VARIANT_BOOL* pRetVal);\n    [id(0x60020002)] HRESULT GetHashCode([out, retval] short* pRetVal);\n    [id(0x60020003)] HRESULT GetType([out, retval] _Type** pRetVal);\n    [id(0x6002000d)] HRESULT Eat();\n    [id(0x6002000e)] HRESULT Breathe();\n    [id(0x6002000f)] HRESULT Sleep();\n}\n[uuid(…)]\ncoclass Mammal\n{\n    [default] interface _Mammal;\n}\n```\n\nGenerating the class interface is optional. By default, COM interop generates a dispatch-only interface for each class you export to a type library. You can prevent or modify the automatic creation of this interface by applying the <xref:System.Runtime.InteropServices.ClassInterfaceAttribute> to your class. Although the class interface can ease the task of exposing managed classes to COM, its uses are limited.\n\n> [!CAUTION]\n> Using the class interface, instead of explicitly defining your own, can complicate the future versioning of your managed class. Please read the following guidelines before using the class interface.\n\n### Define an explicit interface for COM clients to use rather than generating the class interface.\n\nBecause COM interop generates a class interface automatically, post-version changes to your class can alter the layout of the class interface exposed by the common language runtime. Since COM clients are typically unprepared to handle changes in the layout of an interface, they break if you change the member layout of the class.\n\nThis guideline reinforces the notion that interfaces exposed to COM clients must remain unchangeable. To reduce the risk of breaking COM clients by inadvertently reordering the interface layout, isolate all changes to the class from the interface layout by explicitly defining interfaces.\n\nUse the **ClassInterfaceAttribute** to disengage the automatic generation of the class interface and implement an explicit interface for the class, as the following code fragment shows:\n\n```vb\n<ClassInterface(ClassInterfaceType.None)>Public Class LoanApp\n    Implements IExplicit\n    Sub M() Implements IExplicit.M\n…\nEnd Class\n```\n\n```csharp\n[ClassInterface(ClassInterfaceType.None)]\npublic class LoanApp : IExplicit\n{\n    int IExplicit.M() { return 0; }\n}\n```\n\nThe **ClassInterfaceType.None** value prevents the class interface from being generated when the class metadata is exported to a type library. In the preceding example, COM clients can access the `LoanApp` class only through the `IExplicit` interface.\n\n### Avoid caching dispatch identifiers (DispIds)\n\nUsing the class interface is an acceptable option for scripted clients, Microsoft Visual Basic 6.0 clients, or any late-bound client that does not cache the DispIds of interface members. DispIds identify interface members to enable late binding.\n\nFor the class interface, generation of DispIds is based on the position of the member in the interface. If you change the order of the member and export the class to a type library, you will alter the DispIds generated in the class interface.\n\nTo avoid breaking late-bound COM clients when using the class interface, apply the **ClassInterfaceAttribute** with the **ClassInterfaceType.AutoDispatch** value. This value implements a dispatch-only class interface, but omits the interface description from the type library. Without an interface description, clients are unable to cache DispIds at compile time. Although this is the default interface type for the class interface, you can apply the attribute value explicitly.\n\n```vb\n<ClassInterface(ClassInterfaceType.AutoDispatch)> Public Class LoanApp\n    Implements IAnother\n    Sub M() Implements IAnother.M\n…\nEnd Class\n```\n\n```csharp\n[ClassInterface(ClassInterfaceType.AutoDispatch)]\npublic class LoanApp\n{\n    public int M() { return 0; }\n}\n```\n\nTo get the DispId of an interface member at run time, COM clients can call **IDispatch.GetIdsOfNames**. To invoke a method on the interface, pass the returned DispId as an argument to **IDispatch.Invoke**.\n\n### Restrict using the dual interface option for the class interface.\n\nDual interfaces enable early and late binding to interface members by COM clients. At design time and during testing, you might find it useful to set the class interface to dual. For a managed class (and its base classes) that will never be modified, this option is also acceptable. In all other cases, avoid setting the class interface to dual.\n\nAn automatically generated dual interface might be appropriate in rare cases; however, more often it creates version-related complexity. For example, COM clients using the class interface of a derived class can easily break with changes to the base class. When a third party provides the base class, the layout of the class interface is out of your control. Further, unlike a dispatch-only interface, a dual interface (**ClassInterfaceType.AutoDual**) provides a description of the class interface in the exported type library. Such a description encourages late-bound clients to cache DispIds at run time.\n\n### Ensure that all COM event notifications are late-bound.\n\nBy default, COM type information is embedded directly into managed assemblies, which eliminates the need for primary interop assemblies (PIAs). However, one of the limitations of embedded type information is that it does not supported delivery of COM event notifications by early-bound vtable calls, but only supports late-bound `IDispatch::Invoke` calls.\n\nIf your application requires early-bound calls to COM event interface methods, you can set the **Embed Interop Types** property in Visual Studio to `true`, or include the following element in your project file:\n\n```xml\n<EmbedInteropTypes>True</EmbedInteropTypes>\n```\n\n## See also\n\n- <xref:System.Runtime.InteropServices.ClassInterfaceAttribute>\n- [COM Wrappers](com-wrappers.md)\n- [Exposing .NET Framework Components to COM](exposing-dotnet-components-to-com.md)\n- [Qualifying .NET Types for Interoperation](qualifying-net-types-for-interoperation.md)\n- [Runtime Callable Wrapper](runtime-callable-wrapper.md)\n","nodes":[{"pos":[4,366],"embed":true,"restype":"x-metadata","content":"title: \"COM Callable Wrapper\"\nms.date: \"10/23/2018\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"CCW\"\n  - \"COM interop, COM wrappers\"\n  - \"COM wrappers\"\n  - \"callable wrappers\"\n  - \"interoperation with unmanaged code, COM wrappers\"\n  - \"COM callable wrappers\"\nms.assetid: d04be3b5-27b9-4f5b-8469-a44149fabf78\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"COM Callable Wrapper","nodes":[{"pos":[0,20],"content":"COM Callable Wrapper","nodes":[{"content":"COM Callable Wrapper","pos":[0,20]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[374,394],"content":"COM Callable Wrapper","linkify":"COM Callable Wrapper","nodes":[{"content":"COM Callable Wrapper","pos":[0,20]}]},{"content":"When a COM client calls a .NET object, the common language runtime creates the managed object and a COM callable wrapper (CCW) for the object.","pos":[396,538]},{"content":"Unable to reference a .NET object directly, COM clients use the CCW as a proxy for the managed object.","pos":[539,641]},{"content":"The runtime creates exactly one CCW for a managed object, regardless of the number of COM clients requesting its services.","pos":[643,765]},{"content":"As the following illustration shows, multiple COM clients can hold a reference to the CCW that exposes the INew interface.","pos":[766,888]},{"content":"The CCW, in turn, holds a single reference to the managed object that implements the interface and is garbage collected.","pos":[889,1009]},{"content":"Both COM and .NET clients can make requests on the same managed object simultaneously.","pos":[1010,1096]},{"pos":[1098,1196],"content":"<bpt id=\"p1\">![</bpt>COM callable wrapper<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/ccw.gif \"</bpt>ccw<ept id=\"p2\">\")</ept> Accessing .NET objects through COM callable wrapper","source":"![COM callable wrapper](./media/ccw.gif \"ccw\")\nAccessing .NET objects through COM callable wrapper"},{"content":"COM callable wrappers are invisible to other classes running within the .NET Framework.","pos":[1198,1285]},{"content":"Their primary purpose is to marshal calls between managed and unmanaged code; however, CCWs also manage the object identity and object lifetime of the managed objects they wrap.","pos":[1286,1463]},{"pos":[1468,1483],"content":"Object Identity","linkify":"Object Identity","nodes":[{"content":"Object Identity","pos":[0,15]}]},{"content":"The runtime allocates memory for the .NET object from its garbage-collected heap, which enables the runtime to move the object around in memory as necessary.","pos":[1485,1642]},{"content":"In contrast, the runtime allocates memory for the CCW from a noncollected heap, making it possible for COM clients to reference the wrapper directly.","pos":[1643,1792]},{"pos":[1797,1812],"content":"Object Lifetime","linkify":"Object Lifetime","nodes":[{"content":"Object Lifetime","pos":[0,15]}]},{"content":"Unlike the .NET client it wraps, the CCW is reference-counted in traditional COM fashion.","pos":[1814,1903]},{"content":"When the reference count on the CCW reaches zero, the wrapper releases its reference on the managed object.","pos":[1904,2011]},{"content":"A managed object with no remaining references is collected during the next garbage-collection cycle.","pos":[2012,2112]},{"pos":[2117,2142],"content":"Simulating COM interfaces","linkify":"Simulating COM interfaces","nodes":[{"content":"Simulating COM interfaces","pos":[0,25]}]},{"content":"CCW exposes all public, COM-visible interfaces, data types, and return values to COM clients in a manner that is consistent with COM's enforcement of interface-based interaction.","pos":[2144,2322]},{"content":"For a COM client, invoking methods on a .NET Framework object is identical to invoking methods on a COM object.","pos":[2323,2434]},{"content":"To create this seamless approach, the CCW manufactures traditional COM interfaces, such as <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IDispatch<ept id=\"p2\">**</ept>.","pos":[2436,2558],"source":"To create this seamless approach, the CCW manufactures traditional COM interfaces, such as **IUnknown** and **IDispatch**."},{"content":"As the following illustration shows, the CCW maintains a single reference on the .NET object that it wraps.","pos":[2559,2666]},{"content":"Both the COM client and .NET object interact with each other through the proxy and stub construction of the CCW.","pos":[2667,2779]},{"pos":[2781,2893],"content":"<bpt id=\"p1\">![</bpt>COM interfaces<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/ccwwithinterfaces.gif \"</bpt>ccwwithinterfaces<ept id=\"p2\">\")</ept> COM interfaces and the COM callable wrapper","source":"![COM interfaces](./media/ccwwithinterfaces.gif \"ccwwithinterfaces\")\nCOM interfaces and the COM callable wrapper"},{"content":"In addition to exposing the interfaces that are explicitly implemented by a class in the managed environment, the .NET Framework supplies implementations of the COM interfaces listed in the following table on behalf of the object.","pos":[2895,3125]},{"content":"A .NET class can override the default behavior by providing its own implementation of these interfaces.","pos":[3126,3229]},{"content":"However, the runtime always provides the implementation for the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IDispatch<ept id=\"p2\">**</ept> interfaces.","pos":[3230,3336],"source":" However, the runtime always provides the implementation for the **IUnknown** and **IDispatch** interfaces."},{"content":"Interface","pos":[3339,3348]},{"content":"Description","pos":[3349,3360]},{"pos":[3399,3412],"content":"<bpt id=\"p1\">**</bpt>IDispatch<ept id=\"p1\">**</ept>","source":"**IDispatch**"},{"content":"Provides a mechanism for late binding to type.","pos":[3413,3459]},{"pos":[3462,3476],"content":"<bpt id=\"p1\">**</bpt>IErrorInfo<ept id=\"p1\">**</ept>","source":"**IErrorInfo**"},{"pos":[3477,3654],"content":"Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always <bpt id=\"p1\">**</bpt>GUID_NULL<ept id=\"p1\">**</ept> for .NET classes).","source":"Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes)."},{"pos":[3657,3678],"content":"<bpt id=\"p1\">**</bpt>IProvideClassInfo<ept id=\"p1\">**</ept>","source":"**IProvideClassInfo**"},{"pos":[3679,3776],"content":"Enables COM clients to gain access to the <bpt id=\"p1\">**</bpt>ITypeInfo<ept id=\"p1\">**</ept> interface implemented by a managed class.","source":"Enables COM clients to gain access to the **ITypeInfo** interface implemented by a managed class."},{"pos":[3779,3800],"content":"<bpt id=\"p1\">**</bpt>ISupportErrorInfo<ept id=\"p1\">**</ept>","source":"**ISupportErrorInfo**"},{"content":"Enables a COM client to determine whether the managed object supports the <bpt id=\"p1\">**</bpt>IErrorInfo<ept id=\"p1\">**</ept> interface.","pos":[3801,3900],"source":"Enables a COM client to determine whether the managed object supports the **IErrorInfo** interface."},{"content":"If so, enables the client to obtain a pointer to the latest exception object.","pos":[3901,3978]},{"content":"All managed types support the <bpt id=\"p1\">**</bpt>IErrorInfo<ept id=\"p1\">**</ept> interface.","pos":[3979,4034],"source":" All managed types support the **IErrorInfo** interface."},{"pos":[4037,4050],"content":"<bpt id=\"p1\">**</bpt>ITypeInfo<ept id=\"p1\">**</ept>","source":"**ITypeInfo**"},{"content":"Provides type information for a class that is exactly the same as the type information produced by Tlbexp.exe.","pos":[4051,4161]},{"pos":[4164,4176],"content":"<bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept>","source":"**IUnknown**"},{"pos":[4177,4329],"content":"Provides the standard implementation of the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> interface with which the COM client manages the lifetime of the CCW and provides type coercion.","source":"Provides the standard implementation of the **IUnknown** interface with which the COM client manages the lifetime of the CCW and provides type coercion."},{"content":"A managed class can also provide the COM interfaces described in the following table.","pos":[4333,4418]},{"content":"Interface","pos":[4421,4430]},{"content":"Description","pos":[4431,4442]},{"pos":[4481,4516],"content":"The (<ph id=\"ph1\">\\_</ph><bpt id=\"p1\">*</bpt>classname<ept id=\"p1\">*</ept>) class interface","source":"The (\\_*classname*) class interface"},{"content":"Interface, exposed by the runtime and not explicitly defined, that exposes all public interfaces, methods, properties, and fields that are explicitly exposed on a managed object.","pos":[4517,4695]},{"pos":[4698,4752],"content":"<bpt id=\"p1\">**</bpt>IConnectionPoint<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IConnectionPointContainer<ept id=\"p2\">**</ept>","source":"**IConnectionPoint** and **IConnectionPointContainer**"},{"content":"Interface for objects that source delegate-based events (an interface for registering event subscribers).","pos":[4753,4858]},{"pos":[4861,4876],"content":"<bpt id=\"p1\">**</bpt>IDispatchEx<ept id=\"p1\">**</ept>","source":"**IDispatchEx**"},{"content":"Interface supplied by the runtime if the class implements <bpt id=\"p1\">**</bpt>IExpando<ept id=\"p1\">**</ept>.","pos":[4877,4948],"source":"Interface supplied by the runtime if the class implements **IExpando**."},{"content":"The <bpt id=\"p1\">**</bpt>IDispatchEx<ept id=\"p1\">**</ept> interface is an extension of the <bpt id=\"p2\">**</bpt>IDispatch<ept id=\"p2\">**</ept> interface that, unlike <bpt id=\"p3\">**</bpt>IDispatch<ept id=\"p3\">**</ept>, enables enumeration, addition, deletion, and case-sensitive calling of members.","pos":[4949,5133],"source":" The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members."},{"pos":[5136,5152],"content":"<bpt id=\"p1\">**</bpt>IEnumVARIANT<ept id=\"p1\">**</ept>","source":"**IEnumVARIANT**"},{"pos":[5153,5279],"content":"Interface for collection-type classes, which enumerates the objects in the collection if the class implements <bpt id=\"p1\">**</bpt>IEnumerable<ept id=\"p1\">**</ept>.","source":"Interface for collection-type classes, which enumerates the objects in the collection if the class implements **IEnumerable**."},{"pos":[5285,5316],"content":"Introducing the class interface","linkify":"Introducing the class interface","nodes":[{"content":"Introducing the class interface","pos":[0,31]}]},{"content":"The class interface, which is not explicitly defined in managed code, is an interface that exposes all public methods, properties, fields, and events that are explicitly exposed on the .NET object.","pos":[5318,5515]},{"content":"This interface can be a dual or dispatch-only interface.","pos":[5516,5572]},{"content":"The class interface receives the name of the .NET class itself, preceded by an underscore.","pos":[5573,5663]},{"content":"For example, for class Mammal, the class interface is <ph id=\"ph1\">\\_</ph>Mammal.","pos":[5664,5727],"source":" For example, for class Mammal, the class interface is \\_Mammal."},{"content":"For derived classes, the class interface also exposes all public methods, properties, and fields of the base class.","pos":[5729,5844]},{"content":"The derived class also exposes a class interface for each base class.","pos":[5845,5914]},{"content":"For example, if class Mammal extends class MammalSuperclass, which itself extends System.Object, the .NET object exposes to COM clients three class interfaces named <ph id=\"ph1\">\\_</ph>Mammal, <ph id=\"ph2\">\\_</ph>MammalSuperclass, and <ph id=\"ph3\">\\_</ph>Object.","pos":[5915,6123],"source":" For example, if class Mammal extends class MammalSuperclass, which itself extends System.Object, the .NET object exposes to COM clients three class interfaces named \\_Mammal, \\_MammalSuperclass, and \\_Object."},{"content":"For example, consider the following .NET class:","pos":[6125,6172]},{"content":"The COM client can obtain a pointer to a class interface named <ph id=\"ph1\">`_Mammal`</ph>, which is described in the type library that the <bpt id=\"p1\">[</bpt>Type Library Exporter (Tlbexp.exe)<ept id=\"p1\">](../tools/tlbexp-exe-type-library-exporter.md)</ept> tool generates.","pos":[6687,6907],"source":"The COM client can obtain a pointer to a class interface named `_Mammal`, which is described in the type library that the [Type Library Exporter (Tlbexp.exe)](../tools/tlbexp-exe-type-library-exporter.md) tool generates."},{"content":"If the <ph id=\"ph1\">`Mammal`</ph> class implemented one or more interfaces, the interfaces would appear under the coclass.","pos":[6908,7012],"source":" If the `Mammal` class implemented one or more interfaces, the interfaces would appear under the coclass."},{"content":"Generating the class interface is optional.","pos":[7618,7661]},{"content":"By default, COM interop generates a dispatch-only interface for each class you export to a type library.","pos":[7662,7766]},{"content":"You can prevent or modify the automatic creation of this interface by applying the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.ClassInterfaceAttribute&gt;</ph> to your class.","pos":[7767,7926],"source":" You can prevent or modify the automatic creation of this interface by applying the <xref:System.Runtime.InteropServices.ClassInterfaceAttribute> to your class."},{"content":"Although the class interface can ease the task of exposing managed classes to COM, its uses are limited.","pos":[7927,8031]},{"pos":[8035,8246],"content":"[!CAUTION]\nUsing the class interface, instead of explicitly defining your own, can complicate the future versioning of your managed class. Please read the following guidelines before using the class interface.","leadings":["","> "],"nodes":[{"content":"Using the class interface, instead of explicitly defining your own, can complicate the future versioning of your managed class. Please read the following guidelines before using the class interface.","pos":[11,209],"nodes":[{"content":"Using the class interface, instead of explicitly defining your own, can complicate the future versioning of your managed class.","pos":[0,127]},{"content":"Please read the following guidelines before using the class interface.","pos":[128,198]}]}]},{"pos":[8252,8347],"content":"Define an explicit interface for COM clients to use rather than generating the class interface.","linkify":"Define an explicit interface for COM clients to use rather than generating the class interface.","nodes":[{"content":"Define an explicit interface for COM clients to use rather than generating the class interface.","pos":[0,95]}]},{"content":"Because COM interop generates a class interface automatically, post-version changes to your class can alter the layout of the class interface exposed by the common language runtime.","pos":[8349,8530]},{"content":"Since COM clients are typically unprepared to handle changes in the layout of an interface, they break if you change the member layout of the class.","pos":[8531,8679]},{"content":"This guideline reinforces the notion that interfaces exposed to COM clients must remain unchangeable.","pos":[8681,8782]},{"content":"To reduce the risk of breaking COM clients by inadvertently reordering the interface layout, isolate all changes to the class from the interface layout by explicitly defining interfaces.","pos":[8783,8969]},{"pos":[8971,9156],"content":"Use the <bpt id=\"p1\">**</bpt>ClassInterfaceAttribute<ept id=\"p1\">**</ept> to disengage the automatic generation of the class interface and implement an explicit interface for the class, as the following code fragment shows:","source":"Use the **ClassInterfaceAttribute** to disengage the automatic generation of the class interface and implement an explicit interface for the class, as the following code fragment shows:"},{"content":"The <bpt id=\"p1\">**</bpt>ClassInterfaceType.None<ept id=\"p1\">**</ept> value prevents the class interface from being generated when the class metadata is exported to a type library.","pos":[9433,9575],"source":"The **ClassInterfaceType.None** value prevents the class interface from being generated when the class metadata is exported to a type library."},{"content":"In the preceding example, COM clients can access the <ph id=\"ph1\">`LoanApp`</ph> class only through the <ph id=\"ph2\">`IExplicit`</ph> interface.","pos":[9576,9684],"source":" In the preceding example, COM clients can access the `LoanApp` class only through the `IExplicit` interface."},{"pos":[9690,9734],"content":"Avoid caching dispatch identifiers (DispIds)","linkify":"Avoid caching dispatch identifiers (DispIds)","nodes":[{"content":"Avoid caching dispatch identifiers (DispIds)","pos":[0,44]}]},{"content":"Using the class interface is an acceptable option for scripted clients, Microsoft Visual Basic 6.0 clients, or any late-bound client that does not cache the DispIds of interface members.","pos":[9736,9922]},{"content":"DispIds identify interface members to enable late binding.","pos":[9923,9981]},{"content":"For the class interface, generation of DispIds is based on the position of the member in the interface.","pos":[9983,10086]},{"content":"If you change the order of the member and export the class to a type library, you will alter the DispIds generated in the class interface.","pos":[10087,10225]},{"content":"To avoid breaking late-bound COM clients when using the class interface, apply the <bpt id=\"p1\">**</bpt>ClassInterfaceAttribute<ept id=\"p1\">**</ept> with the <bpt id=\"p2\">**</bpt>ClassInterfaceType.AutoDispatch<ept id=\"p2\">**</ept> value.","pos":[10227,10389],"source":"To avoid breaking late-bound COM clients when using the class interface, apply the **ClassInterfaceAttribute** with the **ClassInterfaceType.AutoDispatch** value."},{"content":"This value implements a dispatch-only class interface, but omits the interface description from the type library.","pos":[10390,10503]},{"content":"Without an interface description, clients are unable to cache DispIds at compile time.","pos":[10504,10590]},{"content":"Although this is the default interface type for the class interface, you can apply the attribute value explicitly.","pos":[10591,10705]},{"content":"To get the DispId of an interface member at run time, COM clients can call <bpt id=\"p1\">**</bpt>IDispatch.GetIdsOfNames<ept id=\"p1\">**</ept>.","pos":[10982,11085],"source":"To get the DispId of an interface member at run time, COM clients can call **IDispatch.GetIdsOfNames**."},{"content":"To invoke a method on the interface, pass the returned DispId as an argument to <bpt id=\"p1\">**</bpt>IDispatch.Invoke<ept id=\"p1\">**</ept>.","pos":[11086,11187],"source":" To invoke a method on the interface, pass the returned DispId as an argument to **IDispatch.Invoke**."},{"pos":[11193,11258],"content":"Restrict using the dual interface option for the class interface.","linkify":"Restrict using the dual interface option for the class interface.","nodes":[{"content":"Restrict using the dual interface option for the class interface.","pos":[0,65]}]},{"content":"Dual interfaces enable early and late binding to interface members by COM clients.","pos":[11260,11342]},{"content":"At design time and during testing, you might find it useful to set the class interface to dual.","pos":[11343,11438]},{"content":"For a managed class (and its base classes) that will never be modified, this option is also acceptable.","pos":[11439,11542]},{"content":"In all other cases, avoid setting the class interface to dual.","pos":[11543,11605]},{"content":"An automatically generated dual interface might be appropriate in rare cases; however, more often it creates version-related complexity.","pos":[11607,11743]},{"content":"For example, COM clients using the class interface of a derived class can easily break with changes to the base class.","pos":[11744,11862]},{"content":"When a third party provides the base class, the layout of the class interface is out of your control.","pos":[11863,11964]},{"content":"Further, unlike a dispatch-only interface, a dual interface (<bpt id=\"p1\">**</bpt>ClassInterfaceType.AutoDual<ept id=\"p1\">**</ept>) provides a description of the class interface in the exported type library.","pos":[11965,12134],"source":" Further, unlike a dispatch-only interface, a dual interface (**ClassInterfaceType.AutoDual**) provides a description of the class interface in the exported type library."},{"content":"Such a description encourages late-bound clients to cache DispIds at run time.","pos":[12135,12213]},{"pos":[12219,12274],"content":"Ensure that all COM event notifications are late-bound.","linkify":"Ensure that all COM event notifications are late-bound.","nodes":[{"content":"Ensure that all COM event notifications are late-bound.","pos":[0,55]}]},{"content":"By default, COM type information is embedded directly into managed assemblies, which eliminates the need for primary interop assemblies (PIAs).","pos":[12276,12419]},{"content":"However, one of the limitations of embedded type information is that it does not supported delivery of COM event notifications by early-bound vtable calls, but only supports late-bound <ph id=\"ph1\">`IDispatch::Invoke`</ph> calls.","pos":[12420,12631],"source":" However, one of the limitations of embedded type information is that it does not supported delivery of COM event notifications by early-bound vtable calls, but only supports late-bound `IDispatch::Invoke` calls."},{"pos":[12633,12843],"content":"If your application requires early-bound calls to COM event interface methods, you can set the <bpt id=\"p1\">**</bpt>Embed Interop Types<ept id=\"p1\">**</ept> property in Visual Studio to <ph id=\"ph1\">`true`</ph>, or include the following element in your project file:","source":"If your application requires early-bound calls to COM event interface methods, you can set the **Embed Interop Types** property in Visual Studio to `true`, or include the following element in your project file:"},{"pos":[12904,12912],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[12980,13011],"content":"<bpt id=\"p1\">[</bpt>COM Wrappers<ept id=\"p1\">](com-wrappers.md)</ept>","source":"[COM Wrappers](com-wrappers.md)"},{"pos":[13014,13095],"content":"<bpt id=\"p1\">[</bpt>Exposing .NET Framework Components to COM<ept id=\"p1\">](exposing-dotnet-components-to-com.md)</ept>","source":"[Exposing .NET Framework Components to COM](exposing-dotnet-components-to-com.md)"},{"pos":[13098,13184],"content":"<bpt id=\"p1\">[</bpt>Qualifying .NET Types for Interoperation<ept id=\"p1\">](qualifying-net-types-for-interoperation.md)</ept>","source":"[Qualifying .NET Types for Interoperation](qualifying-net-types-for-interoperation.md)"},{"pos":[13187,13242],"content":"<bpt id=\"p1\">[</bpt>Runtime Callable Wrapper<ept id=\"p1\">](runtime-callable-wrapper.md)</ept>","source":"[Runtime Callable Wrapper](runtime-callable-wrapper.md)"}]}