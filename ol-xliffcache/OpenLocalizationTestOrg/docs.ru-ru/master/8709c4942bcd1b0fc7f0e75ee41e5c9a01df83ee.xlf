<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="libraries.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8709c4942bcd1b0fc7f0e75ee41e5c9a01df83ee</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\porting\libraries.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb14182ead858bcfb40ed05ad73ccfb72d7f8c73</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23fb3c0c66b69e2e8436c4bd12e6f2b7098560d1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Port libraries to .NET Core</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn how to port library projects from the .NET Framework to .NET Core.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Port .NET Framework libraries to .NET Core</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Learn how to port .NET Framework library code to .NET Core, to run cross-platform and expand the reach of the apps that use it.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article assumes that you:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Are using Visual Studio 2017 or later.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>.NET Core isn't supported on earlier versions of Visual Studio</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Understand the <bpt id="p1">[</bpt>recommended porting process<ept id="p1">](index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Have resolved any issues with <bpt id="p1">[</bpt>third-party dependencies<ept id="p1">](third-party-deps.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You should also become familiar with the content of the following topics:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Standard<ept id="p1">](../../standard/net-standard.md)</ept><ph id="ph1">\</ph></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This topic describes the formal specification of .NET APIs that are intended to be available on all .NET implementations.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Packages, Metapackages and Frameworks<ept id="p1">](~/docs/core/packages.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This article discusses how .NET Core defines and uses packages and how packages support code running on multiple .NET implementations.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Developing Libraries with Cross Platform Tools<ept id="p1">](~/docs/core/tutorials/libraries.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This topic explains how to write libraries for .NET using cross-platform CLI tools.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Additions to the <bpt id="p2">*</bpt>csproj<ept id="p2">*</ept> format for .NET Core<ept id="p1">](~/docs/core/tools/csproj.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>This article outlines the changes that were added to the project file as part of the move to <bpt id="p1">*</bpt>csproj<ept id="p1">*</ept> and MSBuild.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Porting to .NET Core - Analyzing your Third-Party Party Dependencies<ept id="p1">](~/docs/core/porting/third-party-deps.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This topic discusses the portability of third-party dependencies and what to do when a NuGet package dependency doesn't run on .NET Core.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Retargeting your .NET Framework code to .NET Framework 4.7.2</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If your code isn't targeting .NET Framework 4.7.2, we recommended that you retarget to .NET Framework 4.7.2.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This ensures the availability of the latest API alternatives for cases where the .NET Standard doesn't support existing APIs.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For each of your projects in Visual Studio you wish to port, do the following:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Right-click on the project and select <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Target Framework<ept id="p1">**</ept> dropdown, select <bpt id="p2">**</bpt>.NET Framework 4.7.2<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Recompile your projects.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because your projects now target .NET Framework 4.7.2, use that version of the .NET Framework as your base for porting code.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Determining the portability of your code</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report for analysis.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Make sure you understand the <bpt id="p1">[</bpt>API Portability Analyzer (ApiPort)<ept id="p1">](../../standard/analyzers/portability-analyzer.md)</ept> and how to generate portability reports for targeting .NET Core.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>How you do this likely varies based on your needs and personal tastes.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>What follows are a few different approaches.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You may find yourself mixing steps of these approaches depending on how your code is structured.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Dealing primarily with the compiler</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The approach is simple:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Optionally, run ApiPort on your project.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you run ApiPort, gain knowledge from the report on issues you'll need to address.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Copy all of your code over into a new .NET Core project.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>While referring to the portability report (if generated), solve compiler errors until the project fully compiles.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Although this approach is unstructured, the code-focused approach often leads to resolving issues quickly and might be the best approach for smaller projects or libraries.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A project that contains only data models might be an ideal candidate for this approach.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Staying on the .NET Framework until portability issues are resolved</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This approach might be the best if you prefer to have code that compiles during the entire process.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Address issues by using different APIs that are portable.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Take note of any areas where you're prevented from using a direct alternative.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Repeat the prior steps for all projects you're porting until you're confident each is ready to be copied over into a new .NET Core project.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Copy the code into a new .NET Core project.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Work out any issues where you noted that a direct alternative doesn't exist.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This careful approach is more structured than simply working out compiler errors, but it's still relatively code-focused and has the benefit of always having code that compiles.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The way you resolve certain issues that couldn't be addressed by just using another API varies greatly.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Developing a comprehensive plan of attack</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This approach might be best for larger and more complex projects, where restructuring code or completely rewriting certain areas of code might be necessary to support .NET Core.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The approach is as follows:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Run ApiPort on a project.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Understand where each non-portable type is used and how that affects overall portability.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Understand the nature of those types.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Are they small in number but used frequently?</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Are they large in number but used infrequently?</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Is their use concentrated, or is it spread throughout your code?</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Is it easy to isolate code that isn't portable so that you can deal with it more effectively?</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Do you need to refactor your code?</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For those types which aren't portable, are there alternative APIs that accomplish the same task?</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example if you're using the <ph id="ph1">&lt;xref:System.Net.WebClient&gt;</ph> class, you might be able to use the <ph id="ph2">&lt;xref:System.Net.Http.HttpClient&gt;</ph> class instead.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Are there different portable APIs available to accomplish a task, even if it's not a drop-in replacement?</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example if you're using <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchema&gt;</ph> to parse XML but don't require XML schema discovery, you could use <ph id="ph2">&lt;xref:System.Xml.Linq&gt;</ph> APIs and implement parsing yourself as opposed to relying on an API.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Here are some things to consider:</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework or Windows-specific functionality.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features on a temporary basis until resources are available to port the features?</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Would a refactor help?</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Is it reasonable to write your own implementation of an unavailable .NET Framework API?</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You could consider copying, modifying, and using code from the <bpt id="p1">[</bpt>.NET Framework Reference Source<ept id="p1">](https://github.com/Microsoft/referencesource)</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The reference source code is licensed under the <bpt id="p1">[</bpt>MIT License<ept id="p1">](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)</ept>, so you have significant freedom to use the source as a basis for your own code.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Just be sure to properly attribute Microsoft in your code.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Repeat this process as needed for different projects.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The analysis phase could take some time depending on the size of your codebase.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan usually saves you time in the long run, particularly if you have a complex codebase.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.7.2, making this a more structured version of the previous approach.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>How you go about executing your plan is dependent on your codebase.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Mixing approaches</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>It's likely that you'll mix the above approaches on a per-project basis.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You should do what makes the most sense to you and for your codebase.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Porting your tests</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>To do this, you'll need to use a testing framework that builds and runs tests for .NET Core.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Currently, you have three options:</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>xUnit<ept id="p1">](https://xunit.github.io/)</ept></source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started<ept id="p1">](https://xunit.github.io/docs/getting-started-dotnet-core.html)</ept></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tool to convert an MSTest project to xUnit<ept id="p1">](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>NUnit<ept id="p1">](https://nunit.org/)</ept></source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Getting Started<ept id="p1">](https://github.com/nunit/docs/wiki/Installation)</ept></source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Blog post about migrating from MSTest to NUnit<ept id="p1">](https://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)</ept></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>MSTest<ept id="p1">](https://docs.microsoft.com/visualstudio/test/unit-test-basics)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Recommended approach to porting</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Ultimately, the porting effort depends heavily on how your .NET Framework code is structured.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A good way to port your code is to begin with the <bpt id="p1">*</bpt>base<ept id="p1">*</ept> of your library, which are the foundational components of your code.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This might be data models or some other foundational classes and methods that everything else uses directly or indirectly.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Port the test project that tests the layer of your library that you're currently porting.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Copy over the base of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Make any changes needed to get the code to compile.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Much of this may require adding NuGet package dependencies to your <bpt id="p1">*</bpt>csproj<ept id="p1">*</ept> file.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Run the tests and make any needed adjustments.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Pick the next layer of code to port over and repeat the prior steps.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If you start with the base of your library and move outward from the base and test each layer as needed, porting is a systematic process where problems are isolated to one layer of code at a time.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Next<ept id="p1">](project-structure.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>