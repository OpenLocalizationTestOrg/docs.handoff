<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2131c4a231ff35eea3ce6aabe454fd85b9c9d8c4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\base-types\backtracking-in-regular-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23be9ad0569cbf8a22d2b140e559564d1ee6fe70</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">574bdc813a2dd87f6f3f0a9ad7a4d544360c75e3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Backtracking in Regular Expressions | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Backtracking in Regular Expressions</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> Backtracking occurs when a regular expression pattern contains optional <bpt id="p2">[</bpt>quantifiers<ept id="p2">](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)</ept> or <bpt id="p3">[</bpt>alternation constructs<ept id="p3">](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)</ept>, and the regular expression engine returns to a previous saved state to continue its search for a match.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>At the same time, this power comes at a cost.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Backtracking is often the single most important factor that affects the performance of the regular expression engine.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This topic explains how backtracking works and how it can be controlled.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Linear Comparison Without Backtracking<ept id="p1">](#linear_comparison_without_backtracking)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with Optional Quantifiers or Alternation Constructs<ept id="p1">](#backtracking_with_optional_quantifiers_or_alternation_constructs)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Backtracking with Nested Optional Quantifiers<ept id="p1">](#backtracking_with_nested_optional_quantifiers)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Controlling Backtracking<ept id="p1">](#controlling_backtracking)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Linear Comparison Without Backtracking</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This continues until the match either succeeds or fails.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In either case, the regular expression engine advances by one character at a time in the input string.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The regular expression <ph id="ph1">`e{2}\w\b`</ph> looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.Backtracking#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegularExpressions.Backtracking#1<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Although this regular expression includes the quantifier <ph id="ph1">`{2}`</ph>, it is evaluated in a linear manner.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The regular expression engine does not backtrack because <ph id="ph1">`{2}`</ph> is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Operation</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Position in pattern</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Position in string</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Result</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>"needing a reed" (index 0)</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>2</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>"eeding a reed" (index 1)</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>3</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>e{2}</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>4</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>\w</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>5</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>\b</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>6</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>"eding a reed" (index 2)</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>7</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>e{2}</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Possible match fails.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>8</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>"ding a reed" (index 3)</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Match fails.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>9</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>"ing a reed" (index 4)</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>10</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>"ng a reed" (index 5)</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>11</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>"g a reed" (index 6)</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>12</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>" a reed" (index 7)</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>13</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>"a reed" (index 8)</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>14</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>" reed" (index 9)</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>No match.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>15</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>"reed" (index 10)</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>No match</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>16</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>e</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>"eed" (index 11)</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>17</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>e{2}</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>"ed" (index 12)</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>18</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>\w</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>"d" (index 13)</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Possible match.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>19</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>\b</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>"" (index 14)</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Match.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Backtracking with Optional Quantifiers or Alternation Constructs</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This process of returning to a previous saved state to find a match is known as backtracking.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, consider the regular expression pattern <ph id="ph1">`.*(es)`</ph>, which matches the characters "es" and all the characters that precede it.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.Backtracking#2<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegularExpressions.Backtracking#2<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>To do this, the regular expression engine uses backtracking as follows:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>It matches the <ph id="ph1">`.*`</ph> (which matches zero, one, or more occurrences of any character) with the whole input string.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>It attempts to match "e" in the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>However, the input string has no remaining characters available to match.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The match fails.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The match is successful.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Interestingly, if the regular expression pattern included a lazy quantifier, .<ph id="ph1">`*?(es)`</ph>, matching the regular expression would require additional comparisons.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>In this case, instead of having to backtrack from the end of the string to the "r" in "expressions", the regular expression engine would have to backtrack all the way to the beginning of the string to match "Es" and would require 113 comparisons.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Backtracking with Nested Optional Quantifiers</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example, the regular expression pattern <ph id="ph1">`^(a+)+$`</ph> is designed to match a complete string that contains one or more "a" characters.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The example provides two input strings of identical length, but only the first string matches the pattern.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Diagnostics.Stopwatch?displayProperty=fullName&gt;</ph> class is used to determine how long the match operation takes.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.Backtracking#3<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegularExpressions.Backtracking#3<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>This is because an unsuccessful match always represents a worst-case scenario.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The regular expression engine concludes that the second string did not match the pattern by doing the following:</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern <ph id="ph1">`a+`</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>It then determines that there are no additional groups of "a" characters in the string.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This failed match requires 9 comparisons.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 4.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>It determines that there is one additional "a" character to assign to an additional captured group.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Finally, it tests for the end of the string.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Because one additional character remains in the string, the match fails.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This failed match requires 4 comparisons.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>So far, a total of 13 comparisons have been performed.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>It returns to the previously saved match 3.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>It determines that there are two additional "a" characters to assign to an additional captured group.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>However, the end-of-string test fails.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The end-of-string test still fails.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>These failed matches require 12 comparisons.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>So far, a total of 25 comparisons have been performed.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Because of the nested quantifiers, this comparison is an O(2<bpt id="p1">&lt;sup&gt;</bpt><ph id="ph1">n</ph><ept id="p1">&lt;/sup&gt;</ept>) or an exponential operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of characters in the input string.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Controlling Backtracking</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Backtracking lets you create powerful, flexible regular expressions.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>To prevent excessive backtracking, you should define a time-out interval when you instantiate a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object or call a static regular expression matching method.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This is discussed in the next section.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: <bpt id="p1">[</bpt>nonbacktracking subexpressions<ept id="p1">](#Nonbacktracking)</ept>, <bpt id="p2">[</bpt>lookbehind assertions<ept id="p2">](#Lookbehind)</ept>, and <bpt id="p3">[</bpt>lookahead assertions<ept id="p3">](#Lookahead)</ept>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For more information about each language element, see <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Defining a Time-out Interval</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>You specify the time-out interval by supplying a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> value to the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=fullName&gt;</ph> constructor for instance regular expressions.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>In addition, each static pattern matching method has an overload with a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> parameter that allows you to specify a time-out value.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>By default, the time-out interval is set to <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=fullName&gt;</ph> and the regular expression engine does not time out.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>We recommend that you always set a time-out interval if your regular expression relies on backtracking.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>For example, the following code calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=fullName&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex&gt;</ph> object with a time-out value of one second.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The regular expression pattern <ph id="ph1">`(a+)+$`</ph>, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>After that, it abandons the attempt to match the pattern.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Text.RegularExpressions.Regex.ctor#1<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Text.RegularExpressions.Regex.ctor#1<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Nonbacktracking Subexpression</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`(?&gt;`</ph> <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> language element suppresses backtracking in a subexpression.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>It is useful for preventing the performance problems associated with failed matches.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The second regular expression is identical to the first, except that it disables backtracking.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, the performance improvement from disabling backtracking is significant.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.Backtracking#4<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegularExpressions.Backtracking#4<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Lookbehind Assertions</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <ph id="ph1">`(?&lt;=`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> and <ph id="ph3">`(?&lt;!`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph4">`)`</ph>, that match the previous character or characters in the input string.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?&lt;=`</ph> <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> <ph id="ph2">`)`</ph> is a positive lookbehind assertion; that is, the character or characters before the current position must match <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?&lt;!`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> is a negative lookbehind assertion; that is, the character or characters before the current position must not match <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookbehind assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the previous subexpression.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate the user name in an e-mail address.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.Backtracking#5<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegularExpressions.Backtracking#5<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^[0-9A-Z]([-.\w]*[0-9A-Z])*@`</ph>, is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Match zero, one, or more occurrences of a hyphen, period, or word character.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>This is the first capturing group.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])@`</ph>, uses a positive lookbehind assertion.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Match an alphanumeric character.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Match zero or more occurrences of a hyphen, period, or word character.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Look back at the last matched character and continue the match if it is alphanumeric.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Match an at sign ("@").</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Lookahead Assertions</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>.NET includes two language elements, <ph id="ph1">`(?=`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> and <ph id="ph3">`(?!`</ph><bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept><ph id="ph4">`)`</ph>, that match the next character or characters in the input string.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept>, without advancing or backtracking.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?=`</ph> <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> <ph id="ph2">`)`</ph> is a positive lookahead assertion; that is, the character or characters after the current position must match <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`(?!`</ph><bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept><ph id="ph2">`)`</ph> is a negative lookahead assertion; that is, the character or characters after the current position must not match <bpt id="p2">*</bpt>subexpression<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Both positive and negative lookahead assertions are most useful when <bpt id="p1">*</bpt>subexpression<ept id="p1">*</ept> is a subset of the next subexpression.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The first pattern is subject to poor performance because of excessive backtracking.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The output from the example displays the execution time of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>Conceptual.RegularExpressions.Backtracking#6<ept id="p2">](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>Conceptual.RegularExpressions.Backtracking#6<ept id="p4">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The first regular expression pattern, <ph id="ph1">`^(([A-Z]\w*)+\.)*[A-Z]\w*$`</ph>, is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Match the previous pattern zero or more times.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The second regular expression pattern, <ph id="ph1">`^((?=[A-Z])\w+\.)*[A-Z]\w*$`</ph>, uses a positive lookahead assertion.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>It is defined as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Pattern</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Start the match at the beginning of the string.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Look ahead to the first character and continue the match if it is alphabetical (A-Z).</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>This comparison is case-insensitive, because the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=fullName&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.RegexOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Match one or more word characters followed by a period.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Match the pattern of one or more word characters followed by a period zero or more times.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The initial word character must be alphabetical.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Match an alphabetical character followed by zero or more word characters.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>End the match at the end of the input string.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>.NET Regular Expressions<ept id="p1">](../../../docs/standard/base-types/regular-expressions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Regular Expression Language - Quick Reference<ept id="p1">](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Quantifiers<ept id="p1">](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Alternation Constructs<ept id="p1">](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>