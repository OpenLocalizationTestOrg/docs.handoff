{"content":"---\ntitle: \"Constraints on Type Parameters - C# Programming Guide\"\nms.custom: seodec18\nms.date: 04/12/2018\nhelpviewer_keywords: \n  - \"generics [C#], type constraints\"\n  - \"type constraints [C#]\"\n  - \"type parameters [C#], constraints\"\n  - \"unbound type parameter [C#]\"\n---\n# Constraints on type parameters (C# Programming Guide)\n\nConstraints inform the compiler about the capabilities a type argument must have. Without any constraints, the type argument could be any type. The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type. For more information, see [Why use constraints](#why-use-constraints). If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error. Constraints are specified by using the `where` contextual keyword. The following table lists the seven types of constraints:\n\n|Constraint|Description|\n|----------------|-----------------|\n|`where T : struct`|The type argument must be a value type. Any value type except <xref:System.Nullable%601> can be specified. For more information about nullable types, see [Nullable types](../nullable-types/index.md).|\n|`where T : class`|The type argument must be a reference type. This constraint applies also to any class, interface, delegate, or array type.|\n|`where T : unmanaged`|The type argument must not be a reference type and must not contain any reference type members at any level of nesting.|\n|`where T : new()`|The type argument must have a public parameterless constructor. When used together with other constraints, the `new()` constraint must be specified last.|\n|`where T :` *\\<base class name>*|The type argument must be or derive from the specified base class.|\n|`where T :` *\\<interface name>*|The type argument must be or implement the specified interface. Multiple interface constraints can be specified. The constraining interface can also be generic.|\n|`where T : U`|The type argument supplied for T must be or derive from the argument supplied for U.|\n\nSome of the constraints are mutually exclusive. All value types must have an accessible parameterless constructor. The `struct` constraint implies the `new()` constraint and the `new()` constraint cannot be combined with the `struct` constraint. The `unmanaged` constraint implies the `struct` constraint. The `unmanaged` constraint cannot be combined with either the `struct` or `new()` constraints.\n\n## Why use constraints\n\nBy constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy. When you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you will have to apply constraints to the type parameter. For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments. Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class. The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](introduction-to-generics.md)) by applying a base class constraint.\n\n[!code-csharp[using the class and struct constraints](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#9)]\n\nThe constraint enables the generic class to use the `Employee.Name` property. The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.\n\nMultiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:\n\n[!code-csharp[using the class and struct constraints](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#10)]\n\nWhen applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality. This behavior occurs even if these operators are overloaded in a type that is used as an argument. The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.\n\n[!code-csharp[using the class and struct constraints](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#11)]\n\nThe compiler only knows that T is a reference type at compile time and must use the default operators that are valid for all reference types. If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class.\n\n## Constraining multiple parameters\n\nYou can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:\n\n[!code-csharp[using the class and struct constraints](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#12)]\n\n## Unbounded type parameters\n\n Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters. Unbounded type parameters have the following rules:\n\n- The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.\n- They can be converted to and from `System.Object` or explicitly converted to any interface type.\n- You can compare them to [null](../../language-reference/keywords/null.md). If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.\n\n## Type parameters as constraints\n\nThe use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:\n\n[!code-csharp[using the class and struct constraints](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#13)]\n\nIn the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.\n\nType parameters can also be used as constraints in generic class definitions. The type parameter must be declared within the angle brackets together with any other type parameters:\n\n[!code-csharp[using the class and struct constraints](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#14)]\n\nThe usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`. Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.\n\n## Unmanaged constraint\n\nBeginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be an **unmanaged type**. An **unmanaged type** is a type that is not a reference type and doesn't contain reference type fields at any level of nesting. The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:\n\n[!code-csharp[using the unmanaged constraint](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#15)]\n\nThe preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type. Without the `unmanaged` constraint, the `sizeof` operator is unavailable.\n\n## Delegate constraints\n\nAlso beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint. The CLR always allowed this constraint, but the C# language disallowed it. The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner. The following code defines an extension method that combines two delegates provided they are the same type:\n\n[!code-csharp[using the delegate constraint](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#16)]\n\nYou can use the above method to combine delegates that are the same type:\n\n[!code-csharp[using the unmanaged constraint](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#17)]\n\nIf you uncomment the last line, it won't compile. Both `first` and `test` are delegate types, but they are different delegate types.\n\n## Enum constraints\n\nBeginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint. The CLR always allowed this constraint, but the C# language disallowed it. Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`. The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.\n\n[!code-csharp[using the unmanaged constraint](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#18)]\n\nThe methods used make use of reflection, which has performance implications. You can call this method to build a collection that is cached and reused rather than repeating the calls that require reflection.\n\nYou could use it as shown in the following sample to create an enum and build a dictionary of its values and names:\n\n[!code-csharp[using the unmanaged constraint](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#19)]\n\n[!code-csharp[using the unmanaged constraint](../../../../samples/snippets/csharp/keywords/GenericWhereConstraints.cs#20)]\n\n## See also\n\n- <xref:System.Collections.Generic>\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)\n- [Generic Classes](../../../csharp/programming-guide/generics/generic-classes.md)\n- [new Constraint](../../../csharp/language-reference/keywords/new-constraint.md)\n","nodes":[{"pos":[4,268],"embed":true,"restype":"x-metadata","content":"title: \"Constraints on Type Parameters - C# Programming Guide\"\nms.custom: seodec18\nms.date: 04/12/2018\nhelpviewer_keywords: \n  - \"generics [C#], type constraints\"\n  - \"type constraints [C#]\"\n  - \"type parameters [C#], constraints\"\n  - \"unbound type parameter [C#]\"","nodes":[{"content":"Constraints on Type Parameters - C# Programming Guide","nodes":[{"pos":[0,53],"content":"Constraints on Type Parameters - C# Programming Guide","nodes":[{"content":"Constraints on Type Parameters - C# Programming Guide","pos":[0,53]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[275,328],"content":"Constraints on type parameters (C# Programming Guide)","linkify":"Constraints on type parameters (C# Programming Guide)","nodes":[{"content":"Constraints on type parameters (C# Programming Guide)","pos":[0,53]}]},{"content":"Constraints inform the compiler about the capabilities a type argument must have.","pos":[330,411]},{"content":"Without any constraints, the type argument could be any type.","pos":[412,473]},{"content":"The compiler can only assume the members of <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>, which is the ultimate base class for any .NET type.","pos":[474,620],"source":" The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Why use constraints<ept id=\"p1\">](#why-use-constraints)</ept>.","pos":[621,691],"source":" For more information, see [Why use constraints](#why-use-constraints)."},{"content":"If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.","pos":[692,827]},{"content":"Constraints are specified by using the <ph id=\"ph1\">`where`</ph> contextual keyword.","pos":[828,894],"source":" Constraints are specified by using the `where` contextual keyword."},{"content":"The following table lists the seven types of constraints:","pos":[895,952]},{"content":"Constraint","pos":[955,965]},{"content":"Description","pos":[966,977]},{"content":"The type argument must be a value type.","pos":[1036,1075]},{"content":"Any value type except <ph id=\"ph1\">&lt;xref:System.Nullable%601&gt;</ph> can be specified.","pos":[1076,1142],"source":" Any value type except <xref:System.Nullable%601> can be specified."},{"content":"For more information about nullable types, see <bpt id=\"p1\">[</bpt>Nullable types<ept id=\"p1\">](../nullable-types/index.md)</ept>.","pos":[1143,1235],"source":" For more information about nullable types, see [Nullable types](../nullable-types/index.md)."},{"content":"The type argument must be a reference type.","pos":[1256,1299]},{"content":"This constraint applies also to any class, interface, delegate, or array type.","pos":[1300,1378]},{"content":"The type argument must not be a reference type and must not contain any reference type members at any level of nesting.","pos":[1403,1522]},{"content":"The type argument must have a public parameterless constructor.","pos":[1543,1606]},{"content":"When used together with other constraints, the <ph id=\"ph1\">`new()`</ph> constraint must be specified last.","pos":[1607,1696],"source":" When used together with other constraints, the `new()` constraint must be specified last."},{"pos":[1699,1731],"content":"<ph id=\"ph1\">`where T :`</ph> <bpt id=\"p1\">*</bpt><ph id=\"ph2\">\\&lt;</ph>base class name&gt;<ept id=\"p1\">*</ept>","source":"`where T :` *\\<base class name>*"},{"content":"The type argument must be or derive from the specified base class.","pos":[1732,1798]},{"pos":[1801,1832],"content":"<ph id=\"ph1\">`where T :`</ph> <bpt id=\"p1\">*</bpt><ph id=\"ph2\">\\&lt;</ph>interface name&gt;<ept id=\"p1\">*</ept>","source":"`where T :` *\\<interface name>*"},{"content":"The type argument must be or implement the specified interface.","pos":[1833,1896]},{"content":"Multiple interface constraints can be specified.","pos":[1897,1945]},{"content":"The constraining interface can also be generic.","pos":[1946,1993]},{"content":"The type argument supplied for T must be or derive from the argument supplied for U.","pos":[2010,2094]},{"content":"Some of the constraints are mutually exclusive.","pos":[2097,2144]},{"content":"All value types must have an accessible parameterless constructor.","pos":[2145,2211]},{"content":"The <ph id=\"ph1\">`struct`</ph> constraint implies the <ph id=\"ph2\">`new()`</ph> constraint and the <ph id=\"ph3\">`new()`</ph> constraint cannot be combined with the <ph id=\"ph4\">`struct`</ph> constraint.","pos":[2212,2342],"source":" The `struct` constraint implies the `new()` constraint and the `new()` constraint cannot be combined with the `struct` constraint."},{"content":"The <ph id=\"ph1\">`unmanaged`</ph> constraint implies the <ph id=\"ph2\">`struct`</ph> constraint.","pos":[2343,2402],"source":" The `unmanaged` constraint implies the `struct` constraint."},{"content":"The <ph id=\"ph1\">`unmanaged`</ph> constraint cannot be combined with either the <ph id=\"ph2\">`struct`</ph> or <ph id=\"ph3\">`new()`</ph> constraints.","pos":[2403,2497],"source":" The `unmanaged` constraint cannot be combined with either the `struct` or `new()` constraints."},{"pos":[2502,2521],"content":"Why use constraints","linkify":"Why use constraints","nodes":[{"content":"Why use constraints","pos":[0,19]}]},{"content":"By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.","pos":[2523,2711]},{"content":"When you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by <ph id=\"ph1\">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>, you will have to apply constraints to the type parameter.","pos":[2712,2992],"source":" When you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you will have to apply constraints to the type parameter."},{"content":"For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.","pos":[2993,3139]},{"content":"Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.","pos":[3140,3246]},{"content":"The following code example demonstrates the functionality you can add to the <ph id=\"ph1\">`GenericList&lt;T&gt;`</ph> class (in <bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](introduction-to-generics.md)</ept>) by applying a base class constraint.","pos":[3247,3444],"source":" The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](introduction-to-generics.md)) by applying a base class constraint."},{"content":"The constraint enables the generic class to use the <ph id=\"ph1\">`Employee.Name`</ph> property.","pos":[3577,3654],"source":"The constraint enables the generic class to use the `Employee.Name` property."},{"content":"The constraint specifies that all items of type <ph id=\"ph1\">`T`</ph> are guaranteed to be either an <ph id=\"ph2\">`Employee`</ph> object or an object that inherits from <ph id=\"ph3\">`Employee`</ph>.","pos":[3655,3799],"source":" The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`."},{"content":"Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:","pos":[3801,3929]},{"content":"When applying the <ph id=\"ph1\">`where T : class`</ph> constraint, avoid the <ph id=\"ph2\">`==`</ph> and <ph id=\"ph3\">`!=`</ph> operators on the type parameter because these operators will test for reference identity only, not for value equality.","pos":[4063,4253],"source":"When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality."},{"content":"This behavior occurs even if these operators are overloaded in a type that is used as an argument.","pos":[4254,4352]},{"content":"The following code illustrates this point; the output is false even though the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class overloads the <ph id=\"ph2\">`==`</ph> operator.","pos":[4353,4487],"source":" The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator."},{"content":"The compiler only knows that T is a reference type at compile time and must use the default operators that are valid for all reference types.","pos":[4621,4762]},{"content":"If you must test for value equality, the recommended way is to also apply the <ph id=\"ph1\">`where T : IEquatable&lt;T&gt;`</ph> or <ph id=\"ph2\">`where T : IComparable&lt;T&gt;`</ph> constraint and implement the interface in any class that will be used to construct the generic class.","pos":[4763,4998],"source":" If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class."},{"pos":[5003,5035],"content":"Constraining multiple parameters","linkify":"Constraining multiple parameters","nodes":[{"content":"Constraining multiple parameters","pos":[0,32]}]},{"content":"You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:","pos":[5037,5169]},{"pos":[5306,5331],"content":"Unbounded type parameters","linkify":"Unbounded type parameters","nodes":[{"content":"Unbounded type parameters","pos":[0,25]}]},{"content":"Type parameters that have no constraints, such as T in public class <ph id=\"ph1\">`SampleClass&lt;T&gt;{}`</ph>, are called unbounded type parameters.","pos":[5334,5459],"source":"Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters."},{"content":"Unbounded type parameters have the following rules:","pos":[5460,5511]},{"pos":[5515,5649],"content":"The <ph id=\"ph1\">`!=`</ph> and <ph id=\"ph2\">`==`</ph> operators cannot be used because there is no guarantee that the concrete type argument will support these operators.","source":"The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators."},{"pos":[5652,5748],"content":"They can be converted to and from <ph id=\"ph1\">`System.Object`</ph> or explicitly converted to any interface type.","source":"They can be converted to and from `System.Object` or explicitly converted to any interface type."},{"content":"You can compare them to <bpt id=\"p1\">[</bpt>null<ept id=\"p1\">](../../language-reference/keywords/null.md)</ept>.","pos":[5751,5825],"source":"You can compare them to [null](../../language-reference/keywords/null.md)."},{"content":"If an unbounded parameter is compared to <ph id=\"ph1\">`null`</ph>, the comparison will always return false if the type argument is a value type.","pos":[5826,5952],"source":" If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type."},{"pos":[5957,5987],"content":"Type parameters as constraints","linkify":"Type parameters as constraints","nodes":[{"content":"Type parameters as constraints","pos":[0,30]}]},{"content":"The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:","pos":[5989,6214]},{"pos":[6348,6501],"content":"In the previous example, <ph id=\"ph1\">`T`</ph> is a type constraint in the context of the <ph id=\"ph2\">`Add`</ph> method, and an unbounded type parameter in the context of the <ph id=\"ph3\">`List`</ph> class.","source":"In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class."},{"content":"Type parameters can also be used as constraints in generic class definitions.","pos":[6503,6580]},{"content":"The type parameter must be declared within the angle brackets together with any other type parameters:","pos":[6581,6683]},{"content":"The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from <ph id=\"ph1\">`System.Object`</ph>.","pos":[6817,7007],"source":"The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`."},{"content":"Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.","pos":[7008,7160]},{"pos":[7165,7185],"content":"Unmanaged constraint","linkify":"Unmanaged constraint","nodes":[{"content":"Unmanaged constraint","pos":[0,20]}]},{"content":"Beginning with C# 7.3, you can use the <ph id=\"ph1\">`unmanaged`</ph> constraint to specify that the type parameter must be an <bpt id=\"p1\">**</bpt>unmanaged type<ept id=\"p1\">**</ept>.","pos":[7187,7314],"source":"Beginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be an **unmanaged type**."},{"content":"An <bpt id=\"p1\">**</bpt>unmanaged type<ept id=\"p1\">**</ept> is a type that is not a reference type and doesn't contain reference type fields at any level of nesting.","pos":[7315,7442],"source":" An **unmanaged type** is a type that is not a reference type and doesn't contain reference type fields at any level of nesting."},{"content":"The <ph id=\"ph1\">`unmanaged`</ph> constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:","pos":[7443,7607],"source":" The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:"},{"content":"The preceding method must be compiled in an <ph id=\"ph1\">`unsafe`</ph> context because it uses the <ph id=\"ph2\">`sizeof`</ph> operator on a type not known to be a built-in type.","pos":[7733,7874],"source":"The preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type."},{"content":"Without the <ph id=\"ph1\">`unmanaged`</ph> constraint, the <ph id=\"ph2\">`sizeof`</ph> operator is unavailable.","pos":[7875,7948],"source":" Without the `unmanaged` constraint, the `sizeof` operator is unavailable."},{"pos":[7953,7973],"content":"Delegate constraints","linkify":"Delegate constraints","nodes":[{"content":"Delegate constraints","pos":[0,20]}]},{"content":"Also beginning with C# 7.3, you can use <ph id=\"ph1\">&lt;xref:System.Delegate?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph> as a base class constraint.","pos":[7975,8158],"source":"Also beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint."},{"content":"The CLR always allowed this constraint, but the C# language disallowed it.","pos":[8159,8233]},{"content":"The <ph id=\"ph1\">`System.Delegate`</ph> constraint enables you to write code that works with delegates in a type-safe manner.","pos":[8234,8341],"source":" The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner."},{"content":"The following code defines an extension method that combines two delegates provided they are the same type:","pos":[8342,8449]},{"content":"You can use the above method to combine delegates that are the same type:","pos":[8574,8647]},{"content":"If you uncomment the last line, it won't compile.","pos":[8773,8822]},{"content":"Both <ph id=\"ph1\">`first`</ph> and <ph id=\"ph2\">`test`</ph> are delegate types, but they are different delegate types.","pos":[8823,8905],"source":" Both `first` and `test` are delegate types, but they are different delegate types."},{"pos":[8910,8926],"content":"Enum constraints","linkify":"Enum constraints","nodes":[{"content":"Enum constraints","pos":[0,16]}]},{"content":"Beginning in C# 7.3, you can also specify the <ph id=\"ph1\">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph> type as a base class constraint.","pos":[8928,9054],"source":"Beginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint."},{"content":"The CLR always allowed this constraint, but the C# language disallowed it.","pos":[9055,9129]},{"content":"Generics using <ph id=\"ph1\">`System.Enum`</ph> provide type-safe programming to cache results from using the static methods in <ph id=\"ph2\">`System.Enum`</ph>.","pos":[9130,9253],"source":" Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`."},{"content":"The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.","pos":[9254,9401]},{"content":"The methods used make use of reflection, which has performance implications.","pos":[9527,9603]},{"content":"You can call this method to build a collection that is cached and reused rather than repeating the calls that require reflection.","pos":[9604,9733]},{"content":"You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:","pos":[9735,9850]},{"pos":[10103,10111],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10151,10217],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[10220,10318],"content":"<bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept>","source":"[Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)"},{"pos":[10321,10401],"content":"<bpt id=\"p1\">[</bpt>Generic Classes<ept id=\"p1\">](../../../csharp/programming-guide/generics/generic-classes.md)</ept>","source":"[Generic Classes](../../../csharp/programming-guide/generics/generic-classes.md)"},{"pos":[10404,10483],"content":"<bpt id=\"p1\">[</bpt>new Constraint<ept id=\"p1\">](../../../csharp/language-reference/keywords/new-constraint.md)</ept>","source":"[new Constraint](../../../csharp/language-reference/keywords/new-constraint.md)"}]}