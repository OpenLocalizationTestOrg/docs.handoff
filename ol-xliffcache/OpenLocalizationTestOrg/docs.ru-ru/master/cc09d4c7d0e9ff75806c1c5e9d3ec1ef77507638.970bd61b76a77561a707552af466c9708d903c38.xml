{"content":"---\ntitle: \"Streaming Feeds Sample\"\nms.date: \"03/30/2017\"\nms.assetid: 1f1228c0-daaa-45f0-b93e-c4a158113744\n---\n# Streaming Feeds Sample\nThis sample demonstrates how to manage syndication feeds that contain large numbers of items. On the server, the sample demonstrates how to delay the creation of individual <xref:System.ServiceModel.Syndication.SyndicationItem> objects within the feed until immediately before the item is written to the network stream.  \n  \n On the client, the sample shows how a custom syndication feed formatter can be used to read individual items from the network stream so that the feed being read is never fully buffered into memory.  \n  \n To best demonstrate the streaming capability of the syndication API, this sample uses a somewhat unlikely scenario in which the server exposes a feed that contains an infinite number of items. In this case, the server continues generating new items into the feed until it determines that the client has read a specified number of items from the feed (by default, 10). For simplicity, both the client and the server are implemented in the same process and use a shared `ItemCounter` object to keep track of how many items the client has produced. The `ItemCounter` type exists only for the purpose of allowing the sample scenario to terminate cleanly, and is not a core element of the pattern being demonstrated.  \n  \n The demonstration makes use of Visual C# iterators (using the `yield return` keyword construct). For more information about iterators, see the \"Using Iterators\" topic on MSDN.  \n  \n## Service  \n The service implements a basic <xref:System.ServiceModel.Web.WebGetAttribute> contract that consists of one operation, as shown in the following code.  \n  \n```  \n[ServiceContract]  \ninterface IStreamingFeedService  \n{  \n    [WebGet]  \n    [OperationContract]  \n    Atom10FeedFormatter StreamedFeed();  \n}  \n```  \n  \n The service implements this contract by using an `ItemGenerator` class to create a potentially infinite stream of <xref:System.ServiceModel.Syndication.SyndicationItem> instances using an iterator, as shown in the following code.  \n  \n```  \nclass ItemGenerator  \n{  \n    public IEnumerable<SyndicationItem> GenerateItems()  \n    {  \n        while (counter.GetCount() < maxItemsRead)  \n        {  \n            itemsReturned++;  \n            yield return CreateNextItem();  \n        }  \n  \n    }  \n    ...  \n}  \n```  \n  \n When the service implementation creates the feed, the output of `ItemGenerator.GenerateItems()` is used instead of a buffered collection of items.  \n  \n```  \npublic Atom10FeedFormatter StreamedFeed()  \n{  \n    SyndicationFeed feed = new SyndicationFeed(\"Streamed feed\", \"Feed to test streaming\", null);  \n    //Generate an infinite stream of items. Both the client and the service share  \n    //a reference to the ItemCounter, which allows the sample to terminate  \n    //execution after the client has read 10 items from the stream  \n    ItemGenerator itemGenerator = new ItemGenerator(this.counter, 10);  \n  \n    feed.Items = itemGenerator.GenerateItems();  \n    return feed.GetAtom10Formatter();  \n}  \n```  \n  \n As a result, the item stream is never fully buffered into memory. You can observe this behavior by setting a breakpoint on the `yield return` statement inside of the `ItemGenerator.GenerateItems()` method and noting that this breakpoint is encountered for the first time after the service has returned the result of the `StreamedFeed()` method.  \n  \n## Client  \n The client in this sample uses a custom <xref:System.ServiceModel.Syndication.SyndicationFeedFormatter> implementation that delays the materialization of individual items in the feed instead of buffering them into memory. The custom `StreamedAtom10FeedFormatter` instance is used as follows.  \n  \n```  \nXmlReader reader = XmlReader.Create(\"http://localhost:8000/Service/Feeds/StreamedFeed\");  \nStreamedAtom10FeedFormatter formatter = new StreamedAtom10FeedFormatter(counter);  \n  \nSyndicationFeed feed = formatter.ReadFrom(reader);  \n```  \n  \n Normally, a call to <xref:System.ServiceModel.Syndication.SyndicationFeedFormatter.ReadFrom%28System.Xml.XmlReader%29> does not return until the entire contents of the feed have been read from the network and buffered into memory. However, the `StreamedAtom10FeedFormatter` object overrides <xref:System.ServiceModel.Syndication.Atom10FeedFormatter.ReadItems%28System.Xml.XmlReader%2CSystem.ServiceModel.Syndication.SyndicationFeed%2CSystem.Boolean%40%29> to return an iterator instead of a buffered collection, as shown in the following code.  \n  \n```  \nprotected override IEnumerable<SyndicationItem> ReadItems(XmlReader reader, SyndicationFeed feed, out bool areAllItemsRead)  \n{  \n    areAllItemsRead = false;  \n    return DelayReadItems(reader, feed);  \n}  \n  \nprivate IEnumerable<SyndicationItem> DelayReadItems(XmlReader reader, SyndicationFeed feed)  \n{  \n    while (reader.IsStartElement(\"entry\", \"http://www.w3.org/2005/Atom\"))  \n    {  \n        yield return this.ReadItem(reader, feed);  \n    }  \n  \n    reader.ReadEndElement();  \n}  \n```  \n  \n As a result, each item is not read from the network until the client application traversing the results of `ReadItems()` is ready to use it. You can observe this behavior by setting a breakpoint on the `yield return` statement inside of `StreamedAtom10FeedFormatter.DelayReadItems()` and noticing that this breakpoint is encountered for the first time after the call to `ReadFrom()` completes.  \n  \n The following instructions show how to build and run the sample. Note that although the server stops generating items after the client has read 10 items, the output shows that the client reads significantly more than 10 items. This is because the networking binding used by the sample transmits data in four-kilobyte (KB) segments. As such, the client receives 4KB of item data before it has the opportunity to read even one item. This is normal behavior (sending streamed HTTP data in reasonably-sized segments increases performance).  \n  \n#### To set up, build, and run the sample  \n  \n1.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n2.  To build the C# or Visual Basic .NET edition of the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n3.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your computer. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Syndication\\StreamingFeeds`  \n  \n## See also\n\n- [Stand-Alone Diagnostics Feed](../../../../docs/framework/wcf/samples/stand-alone-diagnostics-feed-sample.md)\n","nodes":[{"pos":[4,106],"embed":true,"restype":"x-metadata","content":"title: \"Streaming Feeds Sample\"\nms.date: \"03/30/2017\"\nms.assetid: 1f1228c0-daaa-45f0-b93e-c4a158113744","nodes":[{"content":"Streaming Feeds Sample","nodes":[{"pos":[0,22],"content":"Streaming Feeds Sample","nodes":[{"content":"Streaming Feeds Sample","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[113,135],"content":"Streaming Feeds Sample","linkify":"Streaming Feeds Sample","nodes":[{"content":"Streaming Feeds Sample","pos":[0,22]}]},{"content":"This sample demonstrates how to manage syndication feeds that contain large numbers of items.","pos":[136,229]},{"content":"On the server, the sample demonstrates how to delay the creation of individual <ph id=\"ph1\">&lt;xref:System.ServiceModel.Syndication.SyndicationItem&gt;</ph> objects within the feed until immediately before the item is written to the network stream.","pos":[230,455],"source":" On the server, the sample demonstrates how to delay the creation of individual <xref:System.ServiceModel.Syndication.SyndicationItem> objects within the feed until immediately before the item is written to the network stream."},{"content":"On the client, the sample shows how a custom syndication feed formatter can be used to read individual items from the network stream so that the feed being read is never fully buffered into memory.","pos":[462,659]},{"content":"To best demonstrate the streaming capability of the syndication API, this sample uses a somewhat unlikely scenario in which the server exposes a feed that contains an infinite number of items.","pos":[666,858]},{"content":"In this case, the server continues generating new items into the feed until it determines that the client has read a specified number of items from the feed (by default, 10).","pos":[859,1033]},{"content":"For simplicity, both the client and the server are implemented in the same process and use a shared <ph id=\"ph1\">`ItemCounter`</ph> object to keep track of how many items the client has produced.","pos":[1034,1211],"source":" For simplicity, both the client and the server are implemented in the same process and use a shared `ItemCounter` object to keep track of how many items the client has produced."},{"content":"The <ph id=\"ph1\">`ItemCounter`</ph> type exists only for the purpose of allowing the sample scenario to terminate cleanly, and is not a core element of the pattern being demonstrated.","pos":[1212,1377],"source":" The `ItemCounter` type exists only for the purpose of allowing the sample scenario to terminate cleanly, and is not a core element of the pattern being demonstrated."},{"content":"The demonstration makes use of Visual C# iterators (using the <ph id=\"ph1\">`yield return`</ph> keyword construct).","pos":[1384,1480],"source":"The demonstration makes use of Visual C# iterators (using the `yield return` keyword construct)."},{"content":"For more information about iterators, see the \"Using Iterators\" topic on MSDN.","pos":[1481,1559]},{"pos":[1568,1575],"content":"Service","linkify":"Service","nodes":[{"content":"Service","pos":[0,7]}]},{"pos":[1579,1729],"content":"The service implements a basic <ph id=\"ph1\">&lt;xref:System.ServiceModel.Web.WebGetAttribute&gt;</ph> contract that consists of one operation, as shown in the following code.","source":"The service implements a basic <xref:System.ServiceModel.Web.WebGetAttribute> contract that consists of one operation, as shown in the following code."},{"pos":[1896,2125],"content":"The service implements this contract by using an <ph id=\"ph1\">`ItemGenerator`</ph> class to create a potentially infinite stream of <ph id=\"ph2\">&lt;xref:System.ServiceModel.Syndication.SyndicationItem&gt;</ph> instances using an iterator, as shown in the following code.","source":"The service implements this contract by using an `ItemGenerator` class to create a potentially infinite stream of <xref:System.ServiceModel.Syndication.SyndicationItem> instances using an iterator, as shown in the following code."},{"pos":[2416,2562],"content":"When the service implementation creates the feed, the output of <ph id=\"ph1\">`ItemGenerator.GenerateItems()`</ph> is used instead of a buffered collection of items.","source":"When the service implementation creates the feed, the output of `ItemGenerator.GenerateItems()` is used instead of a buffered collection of items."},{"content":"As a result, the item stream is never fully buffered into memory.","pos":[3131,3196]},{"content":"You can observe this behavior by setting a breakpoint on the <ph id=\"ph1\">`yield return`</ph> statement inside of the <ph id=\"ph2\">`ItemGenerator.GenerateItems()`</ph> method and noting that this breakpoint is encountered for the first time after the service has returned the result of the <ph id=\"ph3\">`StreamedFeed()`</ph> method.","pos":[3197,3475],"source":" You can observe this behavior by setting a breakpoint on the `yield return` statement inside of the `ItemGenerator.GenerateItems()` method and noting that this breakpoint is encountered for the first time after the service has returned the result of the `StreamedFeed()` method."},{"pos":[3484,3490],"content":"Client","linkify":"Client","nodes":[{"content":"Client","pos":[0,6]}]},{"content":"The client in this sample uses a custom <ph id=\"ph1\">&lt;xref:System.ServiceModel.Syndication.SyndicationFeedFormatter&gt;</ph> implementation that delays the materialization of individual items in the feed instead of buffering them into memory.","pos":[3494,3715],"source":"The client in this sample uses a custom <xref:System.ServiceModel.Syndication.SyndicationFeedFormatter> implementation that delays the materialization of individual items in the feed instead of buffering them into memory."},{"content":"The custom <ph id=\"ph1\">`StreamedAtom10FeedFormatter`</ph> instance is used as follows.","pos":[3716,3785],"source":" The custom `StreamedAtom10FeedFormatter` instance is used as follows."},{"content":"Normally, a call to <ph id=\"ph1\">&lt;xref:System.ServiceModel.Syndication.SyndicationFeedFormatter.ReadFrom%28System.Xml.XmlReader%29&gt;</ph> does not return until the entire contents of the feed have been read from the network and buffered into memory.","pos":[4038,4268],"source":"Normally, a call to <xref:System.ServiceModel.Syndication.SyndicationFeedFormatter.ReadFrom%28System.Xml.XmlReader%29> does not return until the entire contents of the feed have been read from the network and buffered into memory."},{"content":"However, the <ph id=\"ph1\">`StreamedAtom10FeedFormatter`</ph> object overrides <ph id=\"ph2\">&lt;xref:System.ServiceModel.Syndication.Atom10FeedFormatter.ReadItems%28System.Xml.XmlReader%2CSystem.ServiceModel.Syndication.SyndicationFeed%2CSystem.Boolean%40%29&gt;</ph> to return an iterator instead of a buffered collection, as shown in the following code.","pos":[4269,4581],"source":" However, the `StreamedAtom10FeedFormatter` object overrides <xref:System.ServiceModel.Syndication.Atom10FeedFormatter.ReadItems%28System.Xml.XmlReader%2CSystem.ServiceModel.Syndication.SyndicationFeed%2CSystem.Boolean%40%29> to return an iterator instead of a buffered collection, as shown in the following code."},{"content":"As a result, each item is not read from the network until the client application traversing the results of <ph id=\"ph1\">`ReadItems()`</ph> is ready to use it.","pos":[5094,5234],"source":"As a result, each item is not read from the network until the client application traversing the results of `ReadItems()` is ready to use it."},{"content":"You can observe this behavior by setting a breakpoint on the <ph id=\"ph1\">`yield return`</ph> statement inside of <ph id=\"ph2\">`StreamedAtom10FeedFormatter.DelayReadItems()`</ph> and noticing that this breakpoint is encountered for the first time after the call to <ph id=\"ph3\">`ReadFrom()`</ph> completes.","pos":[5235,5487],"source":" You can observe this behavior by setting a breakpoint on the `yield return` statement inside of `StreamedAtom10FeedFormatter.DelayReadItems()` and noticing that this breakpoint is encountered for the first time after the call to `ReadFrom()` completes."},{"content":"The following instructions show how to build and run the sample.","pos":[5494,5558]},{"content":"Note that although the server stops generating items after the client has read 10 items, the output shows that the client reads significantly more than 10 items.","pos":[5559,5720]},{"content":"This is because the networking binding used by the sample transmits data in four-kilobyte (KB) segments.","pos":[5721,5825]},{"content":"As such, the client receives 4KB of item data before it has the opportunity to read even one item.","pos":[5826,5924]},{"content":"This is normal behavior (sending streamed HTTP data in reasonably-sized segments increases performance).","pos":[5925,6029]},{"pos":[6040,6076],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[6086,6285],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[6295,6504],"content":"To build the C# or Visual Basic .NET edition of the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the C# or Visual Basic .NET edition of the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[6514,6722],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"pos":[6730,6863],"content":"[!IMPORTANT]\n The samples may already be installed on your computer. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your computer. Check for the following (default) directory before continuing.","pos":[14,131],"nodes":[{"content":"The samples may already be installed on your computer.","pos":[0,54]},{"content":"Check for the following (default) directory before continuing.","pos":[55,117]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[6917,7227],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[7228,7278]},{"pos":[7375,7383],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7387,7496],"content":"<bpt id=\"p1\">[</bpt>Stand-Alone Diagnostics Feed<ept id=\"p1\">](../../../../docs/framework/wcf/samples/stand-alone-diagnostics-feed-sample.md)</ept>","source":"[Stand-Alone Diagnostics Feed](../../../../docs/framework/wcf/samples/stand-alone-diagnostics-feed-sample.md)"}]}