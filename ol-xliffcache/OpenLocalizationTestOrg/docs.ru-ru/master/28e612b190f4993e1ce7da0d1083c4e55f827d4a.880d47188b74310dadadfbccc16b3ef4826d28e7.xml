{"content":"---\ntitle: \"Synchronous Scenarios using HTTP, TCP or Named-Pipe\"\nms.date: \"03/30/2017\"\nms.assetid: 7e90af1b-f8f6-41b9-a63a-8490ada502b1\n---\n# Synchronous Scenarios using HTTP, TCP or Named-Pipe\nThis topic describes the activities and transfers for different synchronous request/reply scenarios, with a single-threaded client, using HTTP, TCP or named pipe. See [Asynchronous Scenarios using HTTP, TCP, or Named-Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/asynchronous-scenarios-using-http-tcp-or-named-pipe.md) for more information on multi-threaded requests.  \n  \n## Synchronous Request/Reply without Errors  \n This section describes the activities and transfers for a valid synchronous request/reply scenario, with single-threaded client.  \n  \n### Client  \n  \n#### Establishing Communication with Service Endpoint  \n A client is constructed and opened. For each of these steps, the ambient activity (A) is transferred to a \"Construct Client\" (B) and \"Open Client\" (C) activity respectively. For each activity being transferred to, the ambient activity is suspended until there is a transfer back, that is, until ServiceModel code is executed.  \n  \n#### Making a Request to Service Endpoint  \n The ambient activity is transferred to a \"ProcessAction\" (D) activity. Within this activity, a request message is sent, and a response message is received. The activity ends when control returns to user code. Because this is a synchronous request, the ambient activity suspends until control returns.  \n  \n#### Closing Communication with Service Endpoint  \n The client's close activity (I) is created from the ambient activity. This is identical to new and open.  \n  \n### Server  \n  \n#### Setting up a Service Host  \n The ServiceHost’s new and open activities (N and O) are created from the ambient activity (M).  \n  \n A listener activity (P) is created from opening a ServiceHost for each listener. The listener activity waits to receive and process data.  \n  \n#### Receiving Data on the Wire  \n When data arrives on the wire, a \"ReceiveBytes\" activity is created if it does not already exist (Q) to process the received data. This activity can be reused for multiple messages within a connection or queue.  \n  \n The ReceiveBytes activity launches a ProcessMessage activity (R) if it has enough data to form a SOAP action message.  \n  \n In activity R, the message headers are processed, and the activityID header is verified. If this header is present, the activity ID is set to the ProcessAction activity; otherwise, a new ID is created.  \n  \n ProcessAction activity (S) is created and being transferred to, when the call is processed. This activity ends when all processing related to the incoming message is completed, including executing user code (T) and sending the response message if applicable.  \n  \n#### Closing a Service Host  \n The ServiceHost’s close activity (Z) is created from the ambient activity.  \n  \n ![Diagram showing synchronous scenarios: HTTP, TCP, or named pipes.](./media/synchronous-scenarios-using-http-tcp-or-named-pipe/synchronous-scenario-http-tcp-named-pipes.gif)  \n  \n In \\<A: name>, `A` is a shortcut symbol that describes the activity in the previous text and in table 3. `Name` is a shortened name of the activity.  \n  \n If `propagateActivity`=`true`, Process Action on both the client and service have the same activity ID.  \n  \n## Synchronous Request/Reply with Errors  \n The only difference with the previous scenario is that a SOAP fault message is returned as a response message. If `propagateActivity`=`true`, the activity ID of the request message is added to the SOAP fault message.  \n  \n## Synchronous One-Way without Errors  \n The only difference with the first scenario is that no message is returned to the server. For HTTP-based protocols, a status (valid or error) is still returned to the client. This is because HTTP is the only protocol with a request-response semantics that is part of the WCF protocol stack. Because TCP processing is hidden from WCF, no acknowledgement is sent to the client.  \n  \n## Synchronous One-Way with Errors  \n If an error occurs while processing the message (Q or beyond), no notification is returned to the client. This is identical to the \"Synchronous One-Way without Errors\" scenario. You should not use a One-Way scenario if you want to receive an error message.  \n  \n## Duplex  \n The difference with the previous scenarios is that the client acts as a service, in which it creates the ReceiveBytes and ProcessMessage activities, similar to the Asynchronous scenarios.\n","nodes":[{"pos":[4,135],"embed":true,"restype":"x-metadata","content":"title: \"Synchronous Scenarios using HTTP, TCP or Named-Pipe\"\nms.date: \"03/30/2017\"\nms.assetid: 7e90af1b-f8f6-41b9-a63a-8490ada502b1","nodes":[{"content":"Synchronous Scenarios using HTTP, TCP or Named-Pipe","nodes":[{"pos":[0,51],"content":"Synchronous Scenarios using HTTP, TCP or Named-Pipe","nodes":[{"content":"Synchronous Scenarios using HTTP, TCP or Named-Pipe","pos":[0,51]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[142,193],"content":"Synchronous Scenarios using HTTP, TCP or Named-Pipe","linkify":"Synchronous Scenarios using HTTP, TCP or Named-Pipe","nodes":[{"content":"Synchronous Scenarios using HTTP, TCP or Named-Pipe","pos":[0,51]}]},{"content":"This topic describes the activities and transfers for different synchronous request/reply scenarios, with a single-threaded client, using HTTP, TCP or named pipe.","pos":[194,356]},{"content":"See <bpt id=\"p1\">[</bpt>Asynchronous Scenarios using HTTP, TCP, or Named-Pipe<ept id=\"p1\">](../../../../../docs/framework/wcf/diagnostics/tracing/asynchronous-scenarios-using-http-tcp-or-named-pipe.md)</ept> for more information on multi-threaded requests.","pos":[357,575],"source":" See [Asynchronous Scenarios using HTTP, TCP, or Named-Pipe](../../../../../docs/framework/wcf/diagnostics/tracing/asynchronous-scenarios-using-http-tcp-or-named-pipe.md) for more information on multi-threaded requests."},{"pos":[584,624],"content":"Synchronous Request/Reply without Errors","linkify":"Synchronous Request/Reply without Errors","nodes":[{"content":"Synchronous Request/Reply without Errors","pos":[0,40]}]},{"content":"This section describes the activities and transfers for a valid synchronous request/reply scenario, with single-threaded client.","pos":[628,756]},{"pos":[766,772],"content":"Client","linkify":"Client","nodes":[{"content":"Client","pos":[0,6]}]},{"pos":[783,831],"content":"Establishing Communication with Service Endpoint","linkify":"Establishing Communication with Service Endpoint","nodes":[{"content":"Establishing Communication with Service Endpoint","pos":[0,48]}]},{"content":"A client is constructed and opened.","pos":[835,870]},{"content":"For each of these steps, the ambient activity (A) is transferred to a \"Construct Client\" (B) and \"Open Client\" (C) activity respectively.","pos":[871,1008]},{"content":"For each activity being transferred to, the ambient activity is suspended until there is a transfer back, that is, until ServiceModel code is executed.","pos":[1009,1160]},{"pos":[1171,1207],"content":"Making a Request to Service Endpoint","linkify":"Making a Request to Service Endpoint","nodes":[{"content":"Making a Request to Service Endpoint","pos":[0,36]}]},{"content":"The ambient activity is transferred to a \"ProcessAction\" (D) activity.","pos":[1211,1281]},{"content":"Within this activity, a request message is sent, and a response message is received.","pos":[1282,1366]},{"content":"The activity ends when control returns to user code.","pos":[1367,1419]},{"content":"Because this is a synchronous request, the ambient activity suspends until control returns.","pos":[1420,1511]},{"pos":[1522,1565],"content":"Closing Communication with Service Endpoint","linkify":"Closing Communication with Service Endpoint","nodes":[{"content":"Closing Communication with Service Endpoint","pos":[0,43]}]},{"content":"The client's close activity (I) is created from the ambient activity.","pos":[1569,1638]},{"content":"This is identical to new and open.","pos":[1639,1673]},{"pos":[1683,1689],"content":"Server","linkify":"Server","nodes":[{"content":"Server","pos":[0,6]}]},{"pos":[1700,1725],"content":"Setting up a Service Host","linkify":"Setting up a Service Host","nodes":[{"content":"Setting up a Service Host","pos":[0,25]}]},{"content":"The ServiceHost’s new and open activities (N and O) are created from the ambient activity (M).","pos":[1729,1823]},{"content":"A listener activity (P) is created from opening a ServiceHost for each listener.","pos":[1830,1910]},{"content":"The listener activity waits to receive and process data.","pos":[1911,1967]},{"pos":[1978,2004],"content":"Receiving Data on the Wire","linkify":"Receiving Data on the Wire","nodes":[{"content":"Receiving Data on the Wire","pos":[0,26]}]},{"content":"When data arrives on the wire, a \"ReceiveBytes\" activity is created if it does not already exist (Q) to process the received data.","pos":[2008,2138]},{"content":"This activity can be reused for multiple messages within a connection or queue.","pos":[2139,2218]},{"content":"The ReceiveBytes activity launches a ProcessMessage activity (R) if it has enough data to form a SOAP action message.","pos":[2225,2342]},{"content":"In activity R, the message headers are processed, and the activityID header is verified.","pos":[2349,2437]},{"content":"If this header is present, the activity ID is set to the ProcessAction activity; otherwise, a new ID is created.","pos":[2438,2550]},{"content":"ProcessAction activity (S) is created and being transferred to, when the call is processed.","pos":[2557,2648]},{"content":"This activity ends when all processing related to the incoming message is completed, including executing user code (T) and sending the response message if applicable.","pos":[2649,2815]},{"pos":[2826,2848],"content":"Closing a Service Host","linkify":"Closing a Service Host","nodes":[{"content":"Closing a Service Host","pos":[0,22]}]},{"content":"The ServiceHost’s close activity (Z) is created from the ambient activity.","pos":[2852,2926]},{"content":"Diagram showing synchronous scenarios: HTTP, TCP, or named pipes.","pos":[2935,3000]},{"content":"In <ph id=\"ph1\">\\&lt;</ph>A: name&gt;, <ph id=\"ph2\">`A`</ph> is a shortcut symbol that describes the activity in the previous text and in table 3.","pos":[3114,3218],"source":"In \\<A: name>, `A` is a shortcut symbol that describes the activity in the previous text and in table 3."},{"content":"<ph id=\"ph1\">`Name`</ph> is a shortened name of the activity.","pos":[3219,3262],"source":"`Name` is a shortened name of the activity."},{"pos":[3269,3372],"content":"If <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph>, Process Action on both the client and service have the same activity ID.","source":"If `propagateActivity`=`true`, Process Action on both the client and service have the same activity ID."},{"pos":[3381,3418],"content":"Synchronous Request/Reply with Errors","linkify":"Synchronous Request/Reply with Errors","nodes":[{"content":"Synchronous Request/Reply with Errors","pos":[0,37]}]},{"content":"The only difference with the previous scenario is that a SOAP fault message is returned as a response message.","pos":[3422,3532]},{"content":"If <ph id=\"ph1\">`propagateActivity`</ph><ph id=\"ph2\">=</ph><ph id=\"ph3\">`true`</ph>, the activity ID of the request message is added to the SOAP fault message.","pos":[3533,3638],"source":" If `propagateActivity`=`true`, the activity ID of the request message is added to the SOAP fault message."},{"pos":[3647,3681],"content":"Synchronous One-Way without Errors","linkify":"Synchronous One-Way without Errors","nodes":[{"content":"Synchronous One-Way without Errors","pos":[0,34]}]},{"content":"The only difference with the first scenario is that no message is returned to the server.","pos":[3685,3774]},{"content":"For HTTP-based protocols, a status (valid or error) is still returned to the client.","pos":[3775,3859]},{"content":"This is because HTTP is the only protocol with a request-response semantics that is part of the WCF protocol stack.","pos":[3860,3975]},{"content":"Because TCP processing is hidden from WCF, no acknowledgement is sent to the client.","pos":[3976,4060]},{"pos":[4069,4100],"content":"Synchronous One-Way with Errors","linkify":"Synchronous One-Way with Errors","nodes":[{"content":"Synchronous One-Way with Errors","pos":[0,31]}]},{"content":"If an error occurs while processing the message (Q or beyond), no notification is returned to the client.","pos":[4104,4209]},{"content":"This is identical to the \"Synchronous One-Way without Errors\" scenario.","pos":[4210,4281]},{"content":"You should not use a One-Way scenario if you want to receive an error message.","pos":[4282,4360]},{"pos":[4369,4375],"content":"Duplex","linkify":"Duplex","nodes":[{"content":"Duplex","pos":[0,6]}]},{"content":"The difference with the previous scenarios is that the client acts as a service, in which it creates the ReceiveBytes and ProcessMessage activities, similar to the Asynchronous scenarios.","pos":[4379,4566]}]}