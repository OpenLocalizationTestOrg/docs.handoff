{"content":"---\ntitle: \"Recursive Procedures (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Visual Basic code, procedures\"\n  - \"procedures [Visual Basic], that call themselves\"\n  - \"procedures [Visual Basic], recursive\"\n  - \"procedures [Visual Basic], calling\"\n  - \"recursive procedures\"\n  - \"functions [Visual Basic], calling recursively\"\n  - \"recursion\"\nms.assetid: ba1d3962-b4c3-48d3-875e-96fdb4198327\n---\n# Recursive Procedures (Visual Basic)\nA *recursive* procedure is one that calls itself. In general, this is not the most effective way to write Visual Basic code.  \n  \n The following procedure uses recursion to calculate the factorial of its original argument.  \n  \n [!code-vb[VbVbcnProcedures#51](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#51)]  \n  \n## Considerations with Recursive Procedures  \n **Limiting Conditions**. You must design a recursive procedure to test for at least one condition that can terminate the recursion, and you must also handle the case where no such condition is satisfied within a reasonable number of recursive calls. Without at least one condition that can be met without fail, your procedure runs a high risk of executing in an infinite loop.  \n  \n **Memory Usage**. Your application has a limited amount of space for local variables. Each time a procedure calls itself, it uses more of that space for additional copies of its local variables. If this process continues indefinitely, it eventually causes a <xref:System.StackOverflowException> error.  \n  \n **Efficiency**. You can almost always substitute a loop for recursion. A loop does not have the overhead of passing arguments, initializing additional storage, and returning values. Your performance can be much better without recursive calls.  \n  \n **Mutual Recursion**. You might observe very poor performance, or even an infinite loop, if two procedures call each other. Such a design presents the same problems as a single recursive procedure, but can be harder to detect and debug.  \n  \n **Calling with Parentheses**. When a `Function` procedure calls itself recursively, you must follow the procedure name with parentheses, even if there is no argument list. Otherwise, the function name is taken as representing the return value of the function.  \n  \n **Testing**. If you write a recursive procedure, you should test it very carefully to make sure it always meets some limiting condition. You should also ensure that you cannot run out of memory due to having too many recursive calls.  \n  \n## See also\n\n- <xref:System.StackOverflowException>\n- [Procedures](./index.md)\n- [Sub Procedures](./sub-procedures.md)\n- [Function Procedures](./function-procedures.md)\n- [Property Procedures](./property-procedures.md)\n- [Operator Procedures](./operator-procedures.md)\n- [Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md)\n- [Procedure Overloading](./procedure-overloading.md)\n- [Troubleshooting Procedures](./troubleshooting-procedures.md)\n- [Loop Structures](../../../../visual-basic/programming-guide/language-features/control-flow/loop-structures.md)\n","nodes":[{"pos":[4,408],"embed":true,"restype":"x-metadata","content":"title: \"Recursive Procedures (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Visual Basic code, procedures\"\n  - \"procedures [Visual Basic], that call themselves\"\n  - \"procedures [Visual Basic], recursive\"\n  - \"procedures [Visual Basic], calling\"\n  - \"recursive procedures\"\n  - \"functions [Visual Basic], calling recursively\"\n  - \"recursion\"\nms.assetid: ba1d3962-b4c3-48d3-875e-96fdb4198327","nodes":[{"content":"Recursive Procedures (Visual Basic)","nodes":[{"pos":[0,35],"content":"Recursive Procedures (Visual Basic)","nodes":[{"content":"Recursive Procedures (Visual Basic)","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[415,450],"content":"Recursive Procedures (Visual Basic)","linkify":"Recursive Procedures (Visual Basic)","nodes":[{"content":"Recursive Procedures (Visual Basic)","pos":[0,35]}]},{"content":"A <bpt id=\"p1\">*</bpt>recursive<ept id=\"p1\">*</ept> procedure is one that calls itself.","pos":[451,500],"source":"A *recursive* procedure is one that calls itself."},{"content":"In general, this is not the most effective way to write Visual Basic code.","pos":[501,575]},{"content":"The following procedure uses recursion to calculate the factorial of its original argument.","pos":[582,673]},{"pos":[806,846],"content":"Considerations with Recursive Procedures","linkify":"Considerations with Recursive Procedures","nodes":[{"content":"Considerations with Recursive Procedures","pos":[0,40]}]},{"content":"<bpt id=\"p1\">**</bpt>Limiting Conditions<ept id=\"p1\">**</ept>.","pos":[850,874],"source":"**Limiting Conditions**."},{"content":"You must design a recursive procedure to test for at least one condition that can terminate the recursion, and you must also handle the case where no such condition is satisfied within a reasonable number of recursive calls.","pos":[875,1099]},{"content":"Without at least one condition that can be met without fail, your procedure runs a high risk of executing in an infinite loop.","pos":[1100,1226]},{"content":"<bpt id=\"p1\">**</bpt>Memory Usage<ept id=\"p1\">**</ept>.","pos":[1233,1250],"source":"**Memory Usage**."},{"content":"Your application has a limited amount of space for local variables.","pos":[1251,1318]},{"content":"Each time a procedure calls itself, it uses more of that space for additional copies of its local variables.","pos":[1319,1427]},{"content":"If this process continues indefinitely, it eventually causes a <ph id=\"ph1\">&lt;xref:System.StackOverflowException&gt;</ph> error.","pos":[1428,1534],"source":" If this process continues indefinitely, it eventually causes a <xref:System.StackOverflowException> error."},{"content":"<bpt id=\"p1\">**</bpt>Efficiency<ept id=\"p1\">**</ept>.","pos":[1541,1556],"source":"**Efficiency**."},{"content":"You can almost always substitute a loop for recursion.","pos":[1557,1611]},{"content":"A loop does not have the overhead of passing arguments, initializing additional storage, and returning values.","pos":[1612,1722]},{"content":"Your performance can be much better without recursive calls.","pos":[1723,1783]},{"content":"<bpt id=\"p1\">**</bpt>Mutual Recursion<ept id=\"p1\">**</ept>.","pos":[1790,1811],"source":"**Mutual Recursion**."},{"content":"You might observe very poor performance, or even an infinite loop, if two procedures call each other.","pos":[1812,1913]},{"content":"Such a design presents the same problems as a single recursive procedure, but can be harder to detect and debug.","pos":[1914,2026]},{"content":"<bpt id=\"p1\">**</bpt>Calling with Parentheses<ept id=\"p1\">**</ept>.","pos":[2033,2062],"source":"**Calling with Parentheses**."},{"content":"When a <ph id=\"ph1\">`Function`</ph> procedure calls itself recursively, you must follow the procedure name with parentheses, even if there is no argument list.","pos":[2063,2204],"source":" When a `Function` procedure calls itself recursively, you must follow the procedure name with parentheses, even if there is no argument list."},{"content":"Otherwise, the function name is taken as representing the return value of the function.","pos":[2205,2292]},{"content":"<bpt id=\"p1\">**</bpt>Testing<ept id=\"p1\">**</ept>.","pos":[2299,2311],"source":"**Testing**."},{"content":"If you write a recursive procedure, you should test it very carefully to make sure it always meets some limiting condition.","pos":[2312,2435]},{"content":"You should also ensure that you cannot run out of memory due to having too many recursive calls.","pos":[2436,2532]},{"pos":[2541,2549],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2592,2616],"content":"<bpt id=\"p1\">[</bpt>Procedures<ept id=\"p1\">](./index.md)</ept>","source":"[Procedures](./index.md)"},{"pos":[2619,2656],"content":"<bpt id=\"p1\">[</bpt>Sub Procedures<ept id=\"p1\">](./sub-procedures.md)</ept>","source":"[Sub Procedures](./sub-procedures.md)"},{"pos":[2659,2706],"content":"<bpt id=\"p1\">[</bpt>Function Procedures<ept id=\"p1\">](./function-procedures.md)</ept>","source":"[Function Procedures](./function-procedures.md)"},{"pos":[2709,2756],"content":"<bpt id=\"p1\">[</bpt>Property Procedures<ept id=\"p1\">](./property-procedures.md)</ept>","source":"[Property Procedures](./property-procedures.md)"},{"pos":[2759,2806],"content":"<bpt id=\"p1\">[</bpt>Operator Procedures<ept id=\"p1\">](./operator-procedures.md)</ept>","source":"[Operator Procedures](./operator-procedures.md)"},{"pos":[2809,2886],"content":"<bpt id=\"p1\">[</bpt>Procedure Parameters and Arguments<ept id=\"p1\">](./procedure-parameters-and-arguments.md)</ept>","source":"[Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md)"},{"pos":[2889,2940],"content":"<bpt id=\"p1\">[</bpt>Procedure Overloading<ept id=\"p1\">](./procedure-overloading.md)</ept>","source":"[Procedure Overloading](./procedure-overloading.md)"},{"pos":[2943,3004],"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Procedures<ept id=\"p1\">](./troubleshooting-procedures.md)</ept>","source":"[Troubleshooting Procedures](./troubleshooting-procedures.md)"},{"pos":[3007,3118],"content":"<bpt id=\"p1\">[</bpt>Loop Structures<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/control-flow/loop-structures.md)</ept>","source":"[Loop Structures](../../../../visual-basic/programming-guide/language-features/control-flow/loop-structures.md)"}]}