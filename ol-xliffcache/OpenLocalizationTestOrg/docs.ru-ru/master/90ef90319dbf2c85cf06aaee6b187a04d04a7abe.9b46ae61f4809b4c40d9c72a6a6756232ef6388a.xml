{"content":"---\ntitle: \"invalidOverlappedToPinvoke MDA | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"overlapped pointers\"\n  - \"managed debugging assistants (MDAs), overlapped pointers\"\n  - \"invalid overlapped pointer to platform invoke\"\n  - \"InvalidOverlappedToPinvoke MDA\"\n  - \"MDAs (managed debugging assistants), overlapped pointers\"\n  - \"pointers, overlapped\"\nms.assetid: 28876047-58bd-4fed-9452-c7da346d67c0\ncaps.latest.revision: 14\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# invalidOverlappedToPinvoke MDA\nThe `invalidOverlappedToPinvoke` managed debugging assistant (MDA) is activated when an overlapped pointer that was not created on the garbage collection heap is passed to specific Win32 functions.  \n  \n> [!NOTE]\n>  By default, this MDA is activated only if the platform invoke call is defined in your code and the debugger reports the JustMyCode status of each method. A debugger that does not understand JustMyCode (such as MDbg.exe with no extensions) will not activate this MDA. This MDA can be enabled for those debuggers by using a configuration file and explicitly settting `justMyCode=\"false\"` in the .mda.config file `(<invalidOverlappedToPinvoke enable=\"true\" justMyCode=\"false\"/>`).  \n  \n## Symptoms  \n Crashes or unexplainable heap corruptions.  \n  \n## Cause  \n An overlapped pointer that was not created on the garbage collection heap is passed to specific operating system functions.  \n  \n The following table shows the functions that this MDA tracks.  \n  \n|Module|Function|  \n|------------|--------------|  \n|HttpApi.dll|`HttpReceiveHttpRequest`|  \n|IpHlpApi.dll|`NotifyAddrChange`|  \n|kernel32.dll|`ReadFile`|  \n|kernel32.dll|`ReadFileEx`|  \n|kernel32.dll|`WriteFile`|  \n|kernel32.dll|`WriteFileEx`|  \n|kernel32.dll|`ReadDirectoryChangesW`|  \n|kernel32.dll|`PostQueuedCompletionStatus`|  \n|MSWSock.dll|`ConnectEx`|  \n|WS2_32.dll|`WSASend`|  \n|WS2_32.dll|`WSASendTo`|  \n|WS2_32.dll|`WSARecv`|  \n|WS2_32.dll|`WSARecvFrom`|  \n|MQRT.dll|`MQReceiveMessage`|  \n  \n The potential for heap corruption is high for this condition because the <xref:System.AppDomain> making the call might unload. If the <xref:System.AppDomain> unloads, the application code will either free the memory for the overlapped pointer, causing corruption when the operation finishes, or the code will leak the memory, causing difficulties later.  \n  \n## Resolution  \n Use an <xref:System.Threading.Overlapped> object, calling the <xref:System.Threading.Overlapped.Pack%2A> method to get a <xref:System.Threading.NativeOverlapped> structure that can be passed to the function. If the <xref:System.AppDomain> unloads, the CLR waits until the asynchronous operation completes before freeing the pointer.  \n  \n## Effect on the Runtime  \n This MDA had no effect on the CLR.  \n  \n## Output  \n The following is an example of output from this MDA.  \n  \n `An overlapped pointer (0x00ea3430) that was not allocated on the GC heap was passed via Pinvoke to the Win32 function 'WriteFile' in module 'KERNEL32.DLL'. If the AppDomain is shut down, this can cause heap corruption when the async I/O completes. The best solution is to pass a NativeOverlapped structure retrieved from a call to System.Threading.Overlapped.Pack(). If the AppDomain exits, the CLR will keep this structure alive and pinned until the I/O completes.`  \n  \n## Configuration  \n  \n```  \n<mdaConfig>  \n  <assistants>  \n    <invalidOverlappedToPinvoke/>  \n  </assistants>  \n</mdaConfig>  \n```  \n  \n## See Also  \n <xref:System.Runtime.InteropServices.MarshalAsAttribute>   \n [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)   \n [Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)","nodes":[{"pos":[12,59],"content":"invalidOverlappedToPinvoke MDA | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"invalidOverlappedToPinvoke MDA | Microsoft Docs","pos":[0,47]}]},{"pos":[707,737],"content":"invalidOverlappedToPinvoke MDA","linkify":"invalidOverlappedToPinvoke MDA","nodes":[{"content":"invalidOverlappedToPinvoke MDA","pos":[0,30]}]},{"pos":[738,935],"content":"The <ph id=\"ph1\">`invalidOverlappedToPinvoke`</ph> managed debugging assistant (MDA) is activated when an overlapped pointer that was not created on the garbage collection heap is passed to specific Win32 functions.","source":"The `invalidOverlappedToPinvoke` managed debugging assistant (MDA) is activated when an overlapped pointer that was not created on the garbage collection heap is passed to specific Win32 functions."},{"pos":[943,1431],"content":"[!NOTE]\n By default, this MDA is activated only if the platform invoke call is defined in your code and the debugger reports the JustMyCode status of each method. A debugger that does not understand JustMyCode (such as MDbg.exe with no extensions) will not activate this MDA. This MDA can be enabled for those debuggers by using a configuration file and explicitly settting `justMyCode=\"false\"` in the .mda.config file `(<invalidOverlappedToPinvoke enable=\"true\" justMyCode=\"false\"/>`).","leadings":["","> "],"nodes":[{"content":" By default, this MDA is activated only if the platform invoke call is defined in your code and the debugger reports the JustMyCode status of each method. A debugger that does not understand JustMyCode (such as MDbg.exe with no extensions) will not activate this MDA. This MDA can be enabled for those debuggers by using a configuration file and explicitly settting `justMyCode=\"false\"` in the .mda.config file `(<invalidOverlappedToPinvoke enable=\"true\" justMyCode=\"false\"/>`).","pos":[8,486],"nodes":[{"content":"By default, this MDA is activated only if the platform invoke call is defined in your code and the debugger reports the JustMyCode status of each method.","pos":[1,154]},{"content":"A debugger that does not understand JustMyCode (such as MDbg.exe with no extensions) will not activate this MDA.","pos":[155,267]},{"content":"This MDA can be enabled for those debuggers by using a configuration file and explicitly settting <ph id=\"ph1\">`justMyCode=\"false\"`</ph> in the .mda.config file <ph id=\"ph2\">`(&lt;invalidOverlappedToPinvoke enable=\"true\" justMyCode=\"false\"/&gt;`</ph>).","pos":[268,478],"source":" This MDA can be enabled for those debuggers by using a configuration file and explicitly settting `justMyCode=\"false\"` in the .mda.config file `(<invalidOverlappedToPinvoke enable=\"true\" justMyCode=\"false\"/>`)."}]}]},{"pos":[1440,1448],"content":"Symptoms","linkify":"Symptoms","nodes":[{"content":"Symptoms","pos":[0,8]}]},{"content":"Crashes or unexplainable heap corruptions.","pos":[1452,1494]},{"pos":[1503,1508],"content":"Cause","linkify":"Cause","nodes":[{"content":"Cause","pos":[0,5]}]},{"content":"An overlapped pointer that was not created on the garbage collection heap is passed to specific operating system functions.","pos":[1512,1635]},{"content":"The following table shows the functions that this MDA tracks.","pos":[1642,1703]},{"content":"Module","pos":[1710,1716]},{"content":"Function","pos":[1717,1725]},{"content":"HttpApi.dll","pos":[1762,1773]},{"content":"IpHlpApi.dll","pos":[1803,1815]},{"content":"kernel32.dll","pos":[1839,1851]},{"content":"kernel32.dll","pos":[1867,1879]},{"content":"kernel32.dll","pos":[1897,1909]},{"content":"kernel32.dll","pos":[1926,1938]},{"content":"kernel32.dll","pos":[1957,1969]},{"content":"kernel32.dll","pos":[1998,2010]},{"content":"MSWSock.dll","pos":[2044,2055]},{"content":"WS2_32.dll","pos":[2072,2082]},{"content":"WS2_32.dll","pos":[2097,2107]},{"content":"WS2_32.dll","pos":[2124,2134]},{"content":"WS2_32.dll","pos":[2149,2159]},{"content":"MQRT.dll","pos":[2178,2186]},{"content":"The potential for heap corruption is high for this condition because the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> making the call might unload.","pos":[2213,2339],"source":"The potential for heap corruption is high for this condition because the <xref:System.AppDomain> making the call might unload."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> unloads, the application code will either free the memory for the overlapped pointer, causing corruption when the operation finishes, or the code will leak the memory, causing difficulties later.","pos":[2340,2566],"source":" If the <xref:System.AppDomain> unloads, the application code will either free the memory for the overlapped pointer, causing corruption when the operation finishes, or the code will leak the memory, causing difficulties later."},{"pos":[2575,2585],"content":"Resolution","linkify":"Resolution","nodes":[{"content":"Resolution","pos":[0,10]}]},{"content":"Use an <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped&gt;</ph> object, calling the <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.Pack%2A&gt;</ph> method to get a <ph id=\"ph3\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure that can be passed to the function.","pos":[2589,2796],"source":"Use an <xref:System.Threading.Overlapped> object, calling the <xref:System.Threading.Overlapped.Pack%2A> method to get a <xref:System.Threading.NativeOverlapped> structure that can be passed to the function."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> unloads, the CLR waits until the asynchronous operation completes before freeing the pointer.","pos":[2797,2921],"source":" If the <xref:System.AppDomain> unloads, the CLR waits until the asynchronous operation completes before freeing the pointer."},{"pos":[2930,2951],"content":"Effect on the Runtime","linkify":"Effect on the Runtime","nodes":[{"content":"Effect on the Runtime","pos":[0,21]}]},{"content":"This MDA had no effect on the CLR.","pos":[2955,2989]},{"pos":[2998,3004],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The following is an example of output from this MDA.","pos":[3008,3060]},{"pos":[3543,3556],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"pos":[3680,3688],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\"> [</bpt>Diagnosing Errors with Managed Debugging Assistants<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)</ept><ph id=\"ph1\"> </ph>","pos":[3752,3907],"source":" [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Interop Marshaling<ept id=\"p1\">](../../../docs/framework/interop/interop-marshaling.md)</ept>","pos":[3910,3986],"source":" [Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)"}]}