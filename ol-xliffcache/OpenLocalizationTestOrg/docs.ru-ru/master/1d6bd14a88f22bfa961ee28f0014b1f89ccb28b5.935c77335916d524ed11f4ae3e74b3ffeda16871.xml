{"content":"---\ntitle: \"Query Syntax and Method Syntax in LINQ (C#)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"LINQ [C#], query syntax vs. method syntax\"\n  - \"queries [LINQ in C#], syntax comparisons\"\nms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded\n---\n# Query Syntax and Method Syntax in LINQ (C#)\nMost queries in the introductory Language Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) documentation are written by using the LINQ declarative query syntax. However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled. These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`. You can call them directly by using method syntax instead of query syntax.  \n  \n Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read. Some queries must be expressed as method calls. For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition. You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence. The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax. Therefore, even when getting started writing [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.  \n  \n## Standard Query Operator Extension Methods  \n The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*.  \n  \n [!code-csharp[csLINQGettingStarted#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQGettingStarted/CS/Class1.cs#22)]  \n  \n The output from the two examples is identical. You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>.  \n  \n To understand the method-based query, let's examine it more closely. On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`. If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method. However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`. These are all the standard query operators.  \n  \n ![Screenshot showing all the standard query operators in Intellisense.](./media/query-syntax-and-method-syntax-in-linq/standard-query-operators.png)  \n  \n Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case. The standard query operators are implemented as a new kind of method called *extension methods*. Extensions methods \"extend\" an existing type; they can be called as if they were instance methods on the type. The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`.  \n  \n To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives. From your application's point of view, an extension method and a regular instance method are the same.  \n  \n For more information about extension methods, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md). For more information about standard query operators, see [Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md). Some [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>.  \n  \n## Lambda Expressions  \n In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression. It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree. In C# `=>` is the lambda operator, which is read as \"goes to\". The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression. The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type. The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic. The \"return value\" is just the expression result.  \n  \n To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], you do not have to use lambdas extensively. However, certain queries can only be expressed in method syntax and some of those require lambda expressions. After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] toolbox. For more information, see [Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).  \n  \n## Composability of Queries  \n In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`. `Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it. Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together. This is what the compiler does behind the scenes when you write queries by using query syntax. And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.  \n  \n## See also\n\n- [Getting Started with LINQ in C#](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)\n","nodes":[{"pos":[4,242],"embed":true,"restype":"x-metadata","content":"title: \"Query Syntax and Method Syntax in LINQ (C#)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"LINQ [C#], query syntax vs. method syntax\"\n  - \"queries [LINQ in C#], syntax comparisons\"\nms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded","nodes":[{"content":"Query Syntax and Method Syntax in LINQ (C#)","nodes":[{"pos":[0,43],"content":"Query Syntax and Method Syntax in LINQ (C#)","nodes":[{"content":"Query Syntax and Method Syntax in LINQ (C#)","pos":[0,43]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[249,292],"content":"Query Syntax and Method Syntax in LINQ (C#)","linkify":"Query Syntax and Method Syntax in LINQ (C#)","nodes":[{"content":"Query Syntax and Method Syntax in LINQ (C#)","pos":[0,43]}]},{"content":"Most queries in the introductory Language Integrated Query (<ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>) documentation are written by using the LINQ declarative query syntax.","pos":[293,473],"source":"Most queries in the introductory Language Integrated Query ([!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]) documentation are written by using the LINQ declarative query syntax."},{"content":"However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled.","pos":[474,606]},{"content":"These method calls invoke the standard query operators, which have names such as <ph id=\"ph1\">`Where`</ph>, <ph id=\"ph2\">`Select`</ph>, <ph id=\"ph3\">`GroupBy`</ph>, <ph id=\"ph4\">`Join`</ph>, <ph id=\"ph5\">`Max`</ph>, and <ph id=\"ph6\">`Average`</ph>.","pos":[607,747],"source":" These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`."},{"content":"You can call them directly by using method syntax instead of query syntax.","pos":[748,822]},{"content":"Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read.","pos":[829,949]},{"content":"Some queries must be expressed as method calls.","pos":[950,997]},{"content":"For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition.","pos":[998,1128]},{"content":"You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence.","pos":[1129,1248]},{"content":"The reference documentation for the standard query operators in the <ph id=\"ph1\">&lt;xref:System.Linq&gt;</ph> namespace generally uses method syntax.","pos":[1249,1375],"source":" The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax."},{"content":"Therefore, even when getting started writing <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.","pos":[1376,1585],"source":" Therefore, even when getting started writing [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves."},{"pos":[1594,1635],"content":"Standard Query Operator Extension Methods","linkify":"Standard Query Operator Extension Methods","nodes":[{"content":"Standard Query Operator Extension Methods","pos":[0,41]}]},{"pos":[1639,1767],"content":"The following example shows a simple <bpt id=\"p1\">*</bpt>query expression<ept id=\"p1\">*</ept> and the semantically equivalent query written as a <bpt id=\"p2\">*</bpt>method-based query<ept id=\"p2\">*</ept>.","source":"The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*."},{"content":"The output from the two examples is identical.","pos":[1905,1951]},{"content":"You can see that the type of the query variable is the same in both forms: <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[1952,2077],"source":" You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>."},{"content":"To understand the method-based query, let's examine it more closely.","pos":[2084,2152]},{"content":"On the right side of the expression, notice that the <ph id=\"ph1\">`where`</ph> clause is now expressed as an instance method on the <ph id=\"ph2\">`numbers`</ph> object, which as you will recall has a type of <ph id=\"ph3\">`IEnumerable&lt;int&gt;`</ph>.","pos":[2153,2343],"source":" On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`."},{"content":"If you are familiar with the generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface, you know that it does not have a <ph id=\"ph2\">`Where`</ph> method.","pos":[2344,2490],"source":" If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method."},{"content":"However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a <ph id=\"ph1\">`Where`</ph> method, but many other methods such as <ph id=\"ph2\">`Select`</ph>, <ph id=\"ph3\">`SelectMany`</ph>, <ph id=\"ph4\">`Join`</ph>, and <ph id=\"ph5\">`Orderby`</ph>.","pos":[2491,2690],"source":" However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`."},{"content":"These are all the standard query operators.","pos":[2691,2734]},{"content":"Screenshot showing all the standard query operators in Intellisense.","pos":[2743,2811]},{"content":"Although it looks as if <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> has been redefined to include these additional methods, in fact this is not the case.","pos":[2896,3055],"source":"Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case."},{"content":"The standard query operators are implemented as a new kind of method called <bpt id=\"p1\">*</bpt>extension methods<ept id=\"p1\">*</ept>.","pos":[3056,3152],"source":" The standard query operators are implemented as a new kind of method called *extension methods*."},{"content":"Extensions methods \"extend\" an existing type; they can be called as if they were instance methods on the type.","pos":[3153,3263]},{"content":"The standard query operators extend <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> and that is why you can write <ph id=\"ph2\">`numbers.Where(...)`</ph>.","pos":[3264,3401],"source":" The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`."},{"content":"To get started using <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>, all that you really have to know about extension methods is how to bring them into scope in your application by using the correct <ph id=\"ph2\">`using`</ph> directives.","pos":[3408,3629],"source":"To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives."},{"content":"From your application's point of view, an extension method and a regular instance method are the same.","pos":[3630,3732]},{"content":"For more information about extension methods, see <bpt id=\"p1\">[</bpt>Extension Methods<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept>.","pos":[3739,3888],"source":"For more information about extension methods, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)."},{"content":"For more information about standard query operators, see <bpt id=\"p1\">[</bpt>Standard Query Operators Overview (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>.","pos":[3889,4076],"source":" For more information about standard query operators, see [Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)."},{"content":"Some <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> providers, such as <ph id=\"ph2\">[!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)]</ph> and <ph id=\"ph3\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph>, implement their own standard query operators and additional extension methods for other types besides <ph id=\"ph4\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[4077,4414],"source":" Some [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>."},{"pos":[4423,4441],"content":"Lambda Expressions","linkify":"Lambda Expressions","nodes":[{"content":"Lambda Expressions","pos":[0,18]}]},{"content":"In the previous example, notice that the conditional expression (<ph id=\"ph1\">`num % 2 == 0`</ph>) is passed as an in-line argument to the <ph id=\"ph2\">`Where`</ph> method: <ph id=\"ph3\">`Where(num =&gt; num % 2 == 0).`</ph> This inline expression is called a lambda expression.","pos":[4445,4665],"source":"In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression."},{"content":"It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree.","pos":[4666,4834]},{"content":"In C# <ph id=\"ph1\">`=&gt;`</ph> is the lambda operator, which is read as \"goes to\".","pos":[4835,4897],"source":" In C# `=>` is the lambda operator, which is read as \"goes to\"."},{"content":"The <ph id=\"ph1\">`num`</ph> on the left of the operator is the input variable which corresponds to <ph id=\"ph2\">`num`</ph> in the query expression.","pos":[4898,5009],"source":" The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression."},{"content":"The compiler can infer the type of <ph id=\"ph1\">`num`</ph> because it knows that <ph id=\"ph2\">`numbers`</ph> is a generic <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> type.","pos":[5010,5151],"source":" The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type."},{"content":"The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic.","pos":[5152,5322]},{"content":"The \"return value\" is just the expression result.","pos":[5323,5372]},{"content":"To get started using <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph>, you do not have to use lambdas extensively.","pos":[5379,5494],"source":"To get started using [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], you do not have to use lambdas extensively."},{"content":"However, certain queries can only be expressed in method syntax and some of those require lambda expressions.","pos":[5495,5604]},{"content":"After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> toolbox.","pos":[5605,5773],"source":" After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] toolbox."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Lambda Expressions<ept id=\"p1\">](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)</ept>.","pos":[5774,5914],"source":" For more information, see [Lambda Expressions](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)."},{"pos":[5923,5947],"content":"Composability of Queries","linkify":"Composability of Queries","nodes":[{"content":"Composability of Queries","pos":[0,24]}]},{"content":"In the previous code example, note that the <ph id=\"ph1\">`OrderBy`</ph> method is invoked by using the dot operator on the call to <ph id=\"ph2\">`Where`</ph>.","pos":[5951,6072],"source":"In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`."},{"content":"<ph id=\"ph1\">`Where`</ph> produces a filtered sequence, and then <ph id=\"ph2\">`Orderby`</ph> operates on that sequence by sorting it.","pos":[6073,6170],"source":"`Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it."},{"content":"Because queries return an <ph id=\"ph1\">`IEnumerable`</ph>, you compose them in method syntax by chaining the method calls together.","pos":[6171,6284],"source":" Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together."},{"content":"This is what the compiler does behind the scenes when you write queries by using query syntax.","pos":[6285,6379]},{"content":"And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.","pos":[6380,6552]},{"pos":[6561,6569],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6573,6687],"content":"<bpt id=\"p1\">[</bpt>Getting Started with LINQ in C#<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)</ept>","source":"[Getting Started with LINQ in C#](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)"}]}