{"content":"---\ntitle: \"Manipulations and Inertia Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: dd31b89b-eab6-45a1-8d0b-11e0eb84b234\ncaps.latest.revision: 7\nauthor: \"wadepickett\"\nms.author: \"wpickett\"\nmanager: \"wpickett\"\n---\n# Manipulations and Inertia Overview\n*Manipulations* enable users to move, rotate, and resize user interface (UI) elements by using *manipulators*. A manipulator represents a mouse or (in a touch-enabled scenario) a stylus or a finger.  \n  \n *Inertia* emulates real-world behavior for UI elements that are in motion by simulating friction forces on the elements. This enables elements to gradually slow their movement (both linear and angular) before coming to a stop. This article provides an introduction to manipulations and inertia for the .NET Framework.  \n  \n## Manipulations  \n A manipulation treats a collection of manipulators as a composite object. An application can track the changes to the composite object instead of the individual components.  \n  \n Consider the image in the following illustration. A user can use two manipulators to move, rotate, and scale the image. The changes to each manipulator are interpreted together with the other manipulators.  \n  \n For example, if you have two manipulators (1 and 2) on the image, and you move manipulator 1 in a +Y direction (down), the change to the image depends on what happens to manipulator 2. If manipulator 2 also moves in the +Y direction (down), the image simply moves in the +Y direction. But if manipulator 2 does not change, or it moves in a -Y direction (up), the image is made smaller or rotated.  \n  \n ![A virtual photo that two fingers are manipulating.](../../../docs/framework/common-client-technologies/media/manipulation-resize.png \"Manipulation_Resize\")  \n  \n An image being manipulated by two manipulators  \n  \n Manipulation processing provides a framework that monitors a subset of manipulators and interprets them as if they are acting together, instead of independently. You can create several manipulation processor objects simultaneously, one for each UI element to be manipulated in an application. A manipulation processor is informed of which input devices to observe and it reports manipulations through [.NET events](http://msdn.microsoft.com/library/17sde2xt.aspx).  \n  \n A manipulation processor does not have information about the particular element that is being manipulated. An application separately applies the changes to an application-specific element. For example, an application applies transformations to an image or redraws it to display it at its new location or with a new size or orientation.  \n  \n Manipulations are designed for two-dimensional (2-D) [affine transformations](http://msdn.microsoft.com/library/ms533810\\(VS.85\\).aspx). These transformations include translate, rotate, and scale.  \n  \n### Parts of a Manipulation  \n A manipulation is a collection of <xref:System.Windows.Input.Manipulations.Manipulator2D> objects. This aggregate manipulation is represented by an origin point and an ellipse. The origin point is the average position of all manipulators that are manipulating an element. The ellipse has a radius that is the average distance from the origin to each of the <xref:System.Windows.Input.Manipulations.Manipulator2D> objects.  \n  \n ![The parts of a manipulation.](../../../docs/framework/common-client-technologies/media/manipulation-definition.png \"Manipulation_Definition\")  \n  \n Two manipulators (1 and 2), an origin, and an ellipse specify a manipulation  \n  \n As manipulators are added, moved, or removed for a UI element, an application updates the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object by calling the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method. When the manipulation first begins, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started> event is raised.  \n  \n> [!NOTE]\n>  Manipulation processing is more efficient when used in a frame-based update environment. When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the [Game.Update](http://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx) method. In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method as a batch.  \n  \n As the number of manipulators or their position change, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event is raised. Properties of the <xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs> object that is passed to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event handler specify changes in origin, scale, rotation, and translation that have occurred since the last event. The origin of the manipulation changes when manipulators move, and when manipulators are added or removed. Translation values specify how much X or Y movement the manipulation includes.  \n  \n Using the new values, an application redraws the UI element.  \n  \n ![A manipulation after contact A moved to the right.](../../../docs/framework/common-client-technologies/media/manipulation-changed.png \"Manipulation_Changed\")  \n  \n Manipulator 1 moves and causes the origin to change  \n  \n When the last manipulator that is associated with the manipulation is removed from the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event is raised.  \n  \n### The Manipulation Processing Model  \n A manipulation processor uses a direct-usage model. With this simple model, an application must pass any input event details to the manipulation processor. An input event might be raised by any input primitive, such as a mouse device, a stylus, or a finger. This process provides a direct filtering mechanism and a simple usage model, so the application can batch input events when it is necessary.  \n  \n For an application to include an input primitive in the manipulation process, it creates a <xref:System.Windows.Input.Manipulations.Manipulator2D> structure from the details of the input primitive, and passes the structure to the manipulation processor using the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method. The manipulation processor then raises events, which the application must handle to update the visual component in an appropriate way.  \n  \n ![The flow of the manipulations direct&#45;usage model.](../../../docs/framework/common-client-technologies/media/manipulation-flow.png \"Manipulation_Flow\")  \n  \n The manipulation processing model  \n  \n## Inertia  \n The inertia processor enables applications to extrapolate location, orientation, and other properties of a UI element by simulating real-world behavior.  \n  \n For instance, when a user flicks an element, it can continue moving, decelerate, and then slowly stop. The inertia processor implements this behavior by causing the affine 2-D values (origin, scale, translation, and rotation) to change over a specified time at a specified deceleration rate.  \n  \n As with manipulation processing, an inertia processor does not have information about any particular UI element. In response to events that are raised on an <xref:System.Windows.Input.Manipulations.InertiaProcessor2D> object, an application separately applies the changes to an application-specific element.  \n  \n Inertia processing and manipulation processing are often used together. Their interfaces are similar, and the events that they raise are (in some cases) identical. Generally, inertia processing begins when the manipulation of the UI element is completed. This is accomplished by listening to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event and starting the inertia processing from that event handler.  \n  \n## See Also  \n <xref:System.Windows.Input.Manipulations>","nodes":[{"pos":[12,63],"content":"Manipulations and Inertia Overview | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Manipulations and Inertia Overview | Microsoft Docs","pos":[0,51]}]},{"pos":[370,404],"content":"Manipulations and Inertia Overview","linkify":"Manipulations and Inertia Overview","nodes":[{"content":"Manipulations and Inertia Overview","pos":[0,34]}]},{"content":"<bpt id=\"p1\">*</bpt>Manipulations<ept id=\"p1\">*</ept> enable users to move, rotate, and resize user interface (UI) elements by using <bpt id=\"p2\">*</bpt>manipulators<ept id=\"p2\">*</ept>.","pos":[405,515],"source":"*Manipulations* enable users to move, rotate, and resize user interface (UI) elements by using *manipulators*."},{"content":"A manipulator represents a mouse or (in a touch-enabled scenario) a stylus or a finger.","pos":[516,603]},{"content":"<bpt id=\"p1\">*</bpt>Inertia<ept id=\"p1\">*</ept> emulates real-world behavior for UI elements that are in motion by simulating friction forces on the elements.","pos":[610,730],"source":"*Inertia* emulates real-world behavior for UI elements that are in motion by simulating friction forces on the elements."},{"content":"This enables elements to gradually slow their movement (both linear and angular) before coming to a stop.","pos":[731,836]},{"content":"This article provides an introduction to manipulations and inertia for the .NET Framework.","pos":[837,927]},{"pos":[936,949],"content":"Manipulations","linkify":"Manipulations","nodes":[{"content":"Manipulations","pos":[0,13]}]},{"content":"A manipulation treats a collection of manipulators as a composite object.","pos":[953,1026]},{"content":"An application can track the changes to the composite object instead of the individual components.","pos":[1027,1125]},{"content":"Consider the image in the following illustration.","pos":[1132,1181]},{"content":"A user can use two manipulators to move, rotate, and scale the image.","pos":[1182,1251]},{"content":"The changes to each manipulator are interpreted together with the other manipulators.","pos":[1252,1337]},{"content":"For example, if you have two manipulators (1 and 2) on the image, and you move manipulator 1 in a +Y direction (down), the change to the image depends on what happens to manipulator 2.","pos":[1344,1528]},{"content":"If manipulator 2 also moves in the +Y direction (down), the image simply moves in the +Y direction.","pos":[1529,1628]},{"content":"But if manipulator 2 does not change, or it moves in a -Y direction (up), the image is made smaller or rotated.","pos":[1629,1740]},{"pos":[1747,1904],"content":"<bpt id=\"p1\">![</bpt>A virtual photo that two fingers are manipulating.<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../docs/framework/common-client-technologies/media/manipulation-resize.png \"</bpt>Manipulation_Resize<ept id=\"p2\">\")</ept>","source":"![A virtual photo that two fingers are manipulating.](../../../docs/framework/common-client-technologies/media/manipulation-resize.png \"Manipulation_Resize\")"},{"content":"An image being manipulated by two manipulators","pos":[1911,1957]},{"content":"Manipulation processing provides a framework that monitors a subset of manipulators and interprets them as if they are acting together, instead of independently.","pos":[1964,2125]},{"content":"You can create several manipulation processor objects simultaneously, one for each UI element to be manipulated in an application.","pos":[2126,2256]},{"content":"A manipulation processor is informed of which input devices to observe and it reports manipulations through <bpt id=\"p1\">[</bpt>.NET events<ept id=\"p1\">](http://msdn.microsoft.com/library/17sde2xt.aspx)</ept>.","pos":[2257,2428],"source":" A manipulation processor is informed of which input devices to observe and it reports manipulations through [.NET events](http://msdn.microsoft.com/library/17sde2xt.aspx)."},{"content":"A manipulation processor does not have information about the particular element that is being manipulated.","pos":[2435,2541]},{"content":"An application separately applies the changes to an application-specific element.","pos":[2542,2623]},{"content":"For example, an application applies transformations to an image or redraws it to display it at its new location or with a new size or orientation.","pos":[2624,2770]},{"content":"Manipulations are designed for two-dimensional (2-D) <bpt id=\"p1\">[</bpt>affine transformations<ept id=\"p1\">](http://msdn.microsoft.com/library/ms533810\\(VS.85\\).aspx)</ept>.","pos":[2777,2913],"source":"Manipulations are designed for two-dimensional (2-D) [affine transformations](http://msdn.microsoft.com/library/ms533810\\(VS.85\\).aspx)."},{"content":"These transformations include translate, rotate, and scale.","pos":[2914,2973]},{"pos":[2983,3006],"content":"Parts of a Manipulation","linkify":"Parts of a Manipulation","nodes":[{"content":"Parts of a Manipulation","pos":[0,23]}]},{"content":"A manipulation is a collection of <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.Manipulator2D&gt;</ph> objects.","pos":[3010,3108],"source":"A manipulation is a collection of <xref:System.Windows.Input.Manipulations.Manipulator2D> objects."},{"content":"This aggregate manipulation is represented by an origin point and an ellipse.","pos":[3109,3186]},{"content":"The origin point is the average position of all manipulators that are manipulating an element.","pos":[3187,3281]},{"content":"The ellipse has a radius that is the average distance from the origin to each of the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.Manipulator2D&gt;</ph> objects.","pos":[3282,3431],"source":" The ellipse has a radius that is the average distance from the origin to each of the <xref:System.Windows.Input.Manipulations.Manipulator2D> objects."},{"pos":[3438,3581],"content":"<bpt id=\"p1\">![</bpt>The parts of a manipulation.<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../docs/framework/common-client-technologies/media/manipulation-definition.png \"</bpt>Manipulation_Definition<ept id=\"p2\">\")</ept>","source":"![The parts of a manipulation.](../../../docs/framework/common-client-technologies/media/manipulation-definition.png \"Manipulation_Definition\")"},{"content":"Two manipulators (1 and 2), an origin, and an ellipse specify a manipulation","pos":[3588,3664]},{"content":"As manipulators are added, moved, or removed for a UI element, an application updates the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D&gt;</ph> object by calling the <ph id=\"ph2\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A&gt;</ph> method.","pos":[3671,3945],"source":"As manipulators are added, moved, or removed for a UI element, an application updates the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object by calling the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method."},{"content":"When the manipulation first begins, the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started&gt;</ph> event is raised.","pos":[3946,4076],"source":" When the manipulation first begins, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started> event is raised."},{"pos":[4084,4698],"content":"[!NOTE]\n Manipulation processing is more efficient when used in a frame-based update environment. When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the [Game.Update](http://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx) method. In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method as a batch.","leadings":["","> "],"nodes":[{"content":" Manipulation processing is more efficient when used in a frame-based update environment. When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the [Game.Update](http://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx) method. In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method as a batch.","pos":[8,612],"nodes":[{"content":"Manipulation processing is more efficient when used in a frame-based update environment.","pos":[1,89]},{"content":"When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the <bpt id=\"p1\">[</bpt>Game.Update<ept id=\"p1\">](http://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx)</ept> method.","pos":[90,341],"source":" When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the [Game.Update](http://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx) method."},{"content":"In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A&gt;</ph> method as a batch.","pos":[342,604],"source":" In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method as a batch."}]}]},{"content":"As the number of manipulators or their position change, the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta&gt;</ph> event is raised.","pos":[4705,4853],"source":"As the number of manipulators or their position change, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event is raised."},{"content":"Properties of the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs&gt;</ph> object that is passed to the <ph id=\"ph2\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta&gt;</ph> event handler specify changes in origin, scale, rotation, and translation that have occurred since the last event.","pos":[4854,5158],"source":" Properties of the <xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs> object that is passed to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event handler specify changes in origin, scale, rotation, and translation that have occurred since the last event."},{"content":"The origin of the manipulation changes when manipulators move, and when manipulators are added or removed.","pos":[5159,5265]},{"content":"Translation values specify how much X or Y movement the manipulation includes.","pos":[5266,5344]},{"content":"Using the new values, an application redraws the UI element.","pos":[5351,5411]},{"pos":[5418,5577],"content":"<bpt id=\"p1\">![</bpt>A manipulation after contact A moved to the right.<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../docs/framework/common-client-technologies/media/manipulation-changed.png \"</bpt>Manipulation_Changed<ept id=\"p2\">\")</ept>","source":"![A manipulation after contact A moved to the right.](../../../docs/framework/common-client-technologies/media/manipulation-changed.png \"Manipulation_Changed\")"},{"content":"Manipulator 1 moves and causes the origin to change","pos":[5584,5635]},{"content":"When the last manipulator that is associated with the manipulation is removed from the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D&gt;</ph> object, the <ph id=\"ph2\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed&gt;</ph> event is raised.","pos":[5642,5899],"source":"When the last manipulator that is associated with the manipulation is removed from the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event is raised."},{"pos":[5909,5942],"content":"The Manipulation Processing Model","linkify":"The Manipulation Processing Model","nodes":[{"content":"The Manipulation Processing Model","pos":[0,33]}]},{"content":"A manipulation processor uses a direct-usage model.","pos":[5946,5997]},{"content":"With this simple model, an application must pass any input event details to the manipulation processor.","pos":[5998,6101]},{"content":"An input event might be raised by any input primitive, such as a mouse device, a stylus, or a finger.","pos":[6102,6203]},{"content":"This process provides a direct filtering mechanism and a simple usage model, so the application can batch input events when it is necessary.","pos":[6204,6344]},{"content":"For an application to include an input primitive in the manipulation process, it creates a <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.Manipulator2D&gt;</ph> structure from the details of the input primitive, and passes the structure to the manipulation processor using the <ph id=\"ph2\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A&gt;</ph> method.","pos":[6351,6710],"source":"For an application to include an input primitive in the manipulation process, it creates a <xref:System.Windows.Input.Manipulations.Manipulator2D> structure from the details of the input primitive, and passes the structure to the manipulation processor using the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method."},{"content":"The manipulation processor then raises events, which the application must handle to update the visual component in an appropriate way.","pos":[6711,6845]},{"pos":[6852,7008],"content":"<bpt id=\"p1\">![</bpt>The flow of the manipulations direct&amp;#45;usage model.<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../docs/framework/common-client-technologies/media/manipulation-flow.png \"</bpt>Manipulation_Flow<ept id=\"p2\">\")</ept>","source":"![The flow of the manipulations direct&#45;usage model.](../../../docs/framework/common-client-technologies/media/manipulation-flow.png \"Manipulation_Flow\")"},{"content":"The manipulation processing model","pos":[7015,7048]},{"pos":[7057,7064],"content":"Inertia","linkify":"Inertia","nodes":[{"content":"Inertia","pos":[0,7]}]},{"content":"The inertia processor enables applications to extrapolate location, orientation, and other properties of a UI element by simulating real-world behavior.","pos":[7068,7220]},{"content":"For instance, when a user flicks an element, it can continue moving, decelerate, and then slowly stop.","pos":[7227,7329]},{"content":"The inertia processor implements this behavior by causing the affine 2-D values (origin, scale, translation, and rotation) to change over a specified time at a specified deceleration rate.","pos":[7330,7518]},{"content":"As with manipulation processing, an inertia processor does not have information about any particular UI element.","pos":[7525,7637]},{"content":"In response to events that are raised on an <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.InertiaProcessor2D&gt;</ph> object, an application separately applies the changes to an application-specific element.","pos":[7638,7832],"source":" In response to events that are raised on an <xref:System.Windows.Input.Manipulations.InertiaProcessor2D> object, an application separately applies the changes to an application-specific element."},{"content":"Inertia processing and manipulation processing are often used together.","pos":[7839,7910]},{"content":"Their interfaces are similar, and the events that they raise are (in some cases) identical.","pos":[7911,8002]},{"content":"Generally, inertia processing begins when the manipulation of the UI element is completed.","pos":[8003,8093]},{"content":"This is accomplished by listening to the <ph id=\"ph1\">&lt;xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed&gt;</ph> event and starting the inertia processing from that event handler.","pos":[8094,8277],"source":" This is accomplished by listening to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event and starting the inertia processing from that event handler."},{"pos":[8286,8294],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]}]}