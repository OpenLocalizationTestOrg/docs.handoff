{"content":"---\ntitle: \"Result Tree Fragment in Transformations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nms.assetid: df363480-ba02-4233-9ddf-8434e421c4f1\ncaps.latest.revision: 3\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# Result Tree Fragment in Transformations\n> [!NOTE]\n>  The <xref:System.Xml.Xsl.XslTransform> class is obsolete in the [!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]. You can perform Extensible Stylesheet Language for Transformations (XSLT) transformations using the <xref:System.Xml.Xsl.XslCompiledTransform> class. See [Using the XslCompiledTransform Class](../../../../docs/standard/data/xml/using-the-xslcompiledtransform-class.md) and [Migrating From the XslTransform Class](../../../../docs/standard/data/xml/migrating-from-the-xsltransform-class.md) for more information.  \n  \n Result tree fragments, also known as result tree fragments, are nothing more than a special type of node set. You can perform any function on them that can be performed on a node set. Or, you can also convert a result tree fragment to a node set using the `node-set()` function and subsequently use it any place that a node set can be used.  \n  \n A result tree fragment is created as a result of using an `<xsl:variable>` or `<xsl:param>` element in a specific manner in a style sheet. The syntax for the `variable` and `parameter` elements is as follows:  \n  \n```  \n<xsl:param name=Qname select= XPath Expression >  \n    template body  \n</xsl:param>  \n  \n<xsl:variable name=Qname select=XPath Expression >  \n    template body  \n</xsl:variable>  \n```  \n  \n For the `parameter` element, the value is assigned to the qualified name (`Qname`) in several ways. You can assign a default value to the parameter by returning content from the XML Path Language (XPath) expression in the `select` attribute, or by assigning it the contents of the template body.  \n  \n For the `variable` element, the value is also assigned in several ways. You can assign it by returning content from the XPath expression in the `select` attribute, or by assigning it the contents of the template body.  \n  \n For both the `parameter` and `variable` elements, if a value is assigned by the XPath expression, then one of the four basic XPath types will be returned: Boolean, string, number, or node set. When the value is given by using a non-empty template body, then a non-XPath data type is returned, and that will be a result tree fragment.  \n  \n When a variable is bound to a result tree fragment instead of one of the four basic XPath data types, this is the only time that an XPath query returns a type that is not one of the four XPath object types. Result tree fragments and their behavior are discussed in the World Wide Web Consortium (W3C) specification at www.w3.org/XSLT, section 11.1 Result Tree Fragments through section 11.6 Passing Parameters to Templates. Also, section 1 Introduction discusses how templates can contain elements from the XSLT namespace that return or create result tree fragments.  \n  \n A result tree fragment, in concept, behaves like a node set with nothing more than a single root node. However, the rest of the nodes returned are child nodes. To programmatically see the child nodes, copy the result tree fragment to the result tree using the `<xsl:copy-of>` element. When the copy-of is performed, all the child nodes are also copied to the result tree in sequence. Until a `copy` or `copy-of` is used, a result tree fragment is not part of the result tree or the output from the transformation.  \n  \n To iterate over the returned nodes of a result tree fragment, an <xref:System.Xml.XPath.XPathNavigator> is used. The following code sample shows how to create a result tree fragment within a style sheet by calling the function with a parameter `fragment`, which contains XML.  \n  \n```  \n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"  \n                xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\"  \n                xmlns:user=\"http://www.adventure-works.com\"  \n                version=\"1.0\">  \n    <xsl:var name=\"fragment\">  \n        <node1>  \n            <node2/>  \n        </node1>  \n    <xsl:var>  \n  \n  <msxsl:script language=\"C#\" implements-prefix=\"user\">  \n    function NodeFragment(XPathNavigator nav)  \n    {  \n      if (nav.HasSelection == false)  \n        XPathNavigator.MoveToNext();  \n      return;  \n    }  \n  </msxsl:script>  \n  \n    <xsl:template match=\"/\">  \n            <xsl:value-of select=\"user:NodeFragment(msxml:node-set($fragment))\"/>  \n    </xsl:template>  \n</xsl:stylesheet>  \n```  \n  \n Here is another sample showing a variable, which is in Rich Text Format (RTF), and hence, a type of result tree fragment, that is not converted to a node set. Instead, it is passed to a script function, and the <xref:System.Xml.XPath.XPathNavigator> is used to navigate over the nodes.  \n  \n```  \n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"  \n        xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\"  \n        xmlns:user=\"urn:books\"  \n        exclude-result-prefixes=\"msxsl\">  \n  \n<xsl:output method=\"xml\" indent=\"yes\" omit-xml-declaration=\"yes\"/>  \n  \n<xsl:variable name=\"node-fragment\">  \n    <book>Book1</book>  \n    <book>Book2</book>  \n    <book>Book3</book>  \n    <book>Book4</book>  \n</xsl:variable>  \n  \n<msxsl:script implements-prefix=\"user\" language=\"c#\">  \n  \n<![CDATA[  \n    string func(XPathNavigator nav)  \n    {  \n        bool b = nav.MoveToFirstChild();  \n        if (b)  \n            return nav.Value;  \n        else  \n            return \"Does not exist\";  \n    }  \n  \n]]>  \n  \n</msxsl:script>  \n  \n<xsl:template match=\"/\">  \n    <first_book>  \n        <xsl:value-of select=\"user:func($node-fragment)\"/>  \n    </first_book>  \n</xsl:template>  \n  \n</xsl:stylesheet>  \n```  \n  \n The result of transforming any XML with this style sheet is shown in the following output.  \n  \n## Output  \n  \n```  \n<first_book xmlns:user=\"urn:books\">Book1</first_book>  \n```  \n  \n As stated above, the `node-set` function enables you to convert a result tree fragment into a node set. The resulting node always contains a single node that is the root node of the tree. If you convert a result tree fragment to a node set, then you can use it anywhere a regular node set is used, such as in a for-each statement or in the value of a `select` attribute. The following lines of code show the fragment being converted to a node set and used as a node set:  \n  \n `<xsl:for-each select=\"msxsl:node-set($node-fragment)\">`  \n  \n `<xsl:value-of select=\"user:func(msxsl:node-set($node-fragment))\"/>`  \n  \n When a fragment is converted to a node set, you no longer use the <xref:System.Xml.XPath.XPathNavigator> to navigate over it. For a node set, you use the <xref:System.Xml.XPath.XPathNodeIterator> instead.  \n  \n In the following example, `$var` is a variable that is a node tree in the style sheet. The for-each statement, combined with the `node-set` function, allows the user to iterate over this tree as a node set.  \n  \n```  \n<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"  \n                xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\"  \n                xmlns:user=\"http://www.adventure-works.com\"  \n                version=\"1.0\">  \n    <xsl:variable name=\"states\">  \n        <node1>AL</node1>  \n        <node1>CA</node1>  \n        <node1>CO</node1>  \n        <node1>WA</node1>  \n    </xsl:variable>  \n  \n    <xsl:template match=\"/\">  \n            <xsl:for-each select=\"msxsl:node-set($states)\"/>   \n    </xsl:template>  \n</xsl:stylesheet>  \n```  \n  \n Here is another example of a variable that is in RTF, and hence of type result tree fragment, that is converted to a node set before being passed to a script function as XPathNodeIterator.  \n  \n```  \n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"  \n        xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\"  \n        xmlns:user=\"urn:books\"  \n        exclude-result-prefixes=\"msxsl\">  \n  \n<xsl:output method=\"xml\" indent=\"yes\" omit-xml-declaration=\"yes\"/>  \n  \n<xsl:variable name=\"node-fragment\">  \n    <book>Book1</book>  \n    <book>Book2</book>  \n    <book>Book3</book>  \n    <book>Book4</book>  \n</xsl:variable>  \n  \n<msxsl:script implements-prefix=\"user\" language=\"c#\">  \n  \n<![CDATA[  \n    string func(XPathNodeIterator it)  \n    {  \n        it.MoveNext();   \n        return it.Current.Value;   \n        //it.Current returns XPathNavigator positioned on the current node  \n    }  \n  \n]]>  \n  \n</msxsl:script>  \n<xsl:template match=\"/\">  \n    <books>  \n        <xsl:value-of select=\"user:func(msxsl:node-set($node-fragment))\"/>  \n    </books>  \n</xsl:template>  \n  \n</xsl:stylesheet>  \n```  \n  \n The following is the result of transforming XML with this style sheet:  \n  \n```  \n<books xmlns:user=\"urn:books\">Book1Book2Book3Book4</books>  \n```  \n  \n## See Also  \n <xref:System.Xml.XPath.XPathNodeIterator>   \n <xref:System.Xml.XPath.XPathNodeIterator>   \n [XSLT Transformations with the XslTransform Class](../../../../docs/standard/data/xml/xslt-transformations-with-the-xsltransform-class.md)   \n [XslTransform Class Implements the XSLT Processor](../../../../docs/standard/data/xml/xsltransform-class-implements-the-xslt-processor.md)","nodes":[{"pos":[4,406],"nodes":[{"content":"Result Tree Fragment in Transformations | Microsoft Docs","nodes":[{"pos":[0,56],"content":"Result Tree Fragment in Transformations | Microsoft Docs","nodes":[{"content":"Result Tree Fragment in Transformations | Microsoft Docs","pos":[0,56]}]}],"pos":[6,65],"yaml":true}],"content":"title: \"Result Tree Fragment in Transformations | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nms.assetid: df363480-ba02-4233-9ddf-8434e421c4f1\ncaps.latest.revision: 3\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[413,452],"content":"Result Tree Fragment in Transformations","linkify":"Result Tree Fragment in Transformations","nodes":[{"content":"Result Tree Fragment in Transformations","pos":[0,39]}]},{"pos":[455,1002],"content":"[!NOTE]\n The <xref:System.Xml.Xsl.XslTransform> class is obsolete in the [!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]. You can perform Extensible Stylesheet Language for Transformations (XSLT) transformations using the <xref:System.Xml.Xsl.XslCompiledTransform> class. See [Using the XslCompiledTransform Class](../../../../docs/standard/data/xml/using-the-xslcompiledtransform-class.md) and [Migrating From the XslTransform Class](../../../../docs/standard/data/xml/migrating-from-the-xsltransform-class.md) for more information.","leadings":["","> "],"nodes":[{"content":"The <xref:System.Xml.Xsl.XslTransform> class is obsolete in the [!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]. You can perform Extensible Stylesheet Language for Transformations (XSLT) transformations using the <xref:System.Xml.Xsl.XslCompiledTransform> class. See [Using the XslCompiledTransform Class](../../../../docs/standard/data/xml/using-the-xslcompiledtransform-class.md) and [Migrating From the XslTransform Class](../../../../docs/standard/data/xml/migrating-from-the-xsltransform-class.md) for more information.","pos":[9,545],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Xsl.XslTransform&gt;</ph> class is obsolete in the <ph id=\"ph2\">[!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]</ph>.","pos":[0,124],"source":"The <xref:System.Xml.Xsl.XslTransform> class is obsolete in the [!INCLUDE[dnprdnext](../../../../includes/dnprdnext-md.md)]."},{"content":"You can perform Extensible Stylesheet Language for Transformations (XSLT) transformations using the <ph id=\"ph1\">&lt;xref:System.Xml.Xsl.XslCompiledTransform&gt;</ph> class.","pos":[125,274],"source":" You can perform Extensible Stylesheet Language for Transformations (XSLT) transformations using the <xref:System.Xml.Xsl.XslCompiledTransform> class."},{"content":"See <bpt id=\"p1\">[</bpt>Using the XslCompiledTransform Class<ept id=\"p1\">](../../../../docs/standard/data/xml/using-the-xslcompiledtransform-class.md)</ept> and <bpt id=\"p2\">[</bpt>Migrating From the XslTransform Class<ept id=\"p2\">](../../../../docs/standard/data/xml/migrating-from-the-xsltransform-class.md)</ept> for more information.","pos":[275,536],"source":" See [Using the XslCompiledTransform Class](../../../../docs/standard/data/xml/using-the-xslcompiledtransform-class.md) and [Migrating From the XslTransform Class](../../../../docs/standard/data/xml/migrating-from-the-xsltransform-class.md) for more information."}]}]},{"content":"Result tree fragments, also known as result tree fragments, are nothing more than a special type of node set.","pos":[1009,1118]},{"content":"You can perform any function on them that can be performed on a node set.","pos":[1119,1192]},{"content":"Or, you can also convert a result tree fragment to a node set using the <ph id=\"ph1\">`node-set()`</ph> function and subsequently use it any place that a node set can be used.","pos":[1193,1349],"source":" Or, you can also convert a result tree fragment to a node set using the `node-set()` function and subsequently use it any place that a node set can be used."},{"content":"A result tree fragment is created as a result of using an <ph id=\"ph1\">`&lt;xsl:variable&gt;`</ph> or <ph id=\"ph2\">`&lt;xsl:param&gt;`</ph> element in a specific manner in a style sheet.","pos":[1356,1494],"source":"A result tree fragment is created as a result of using an `<xsl:variable>` or `<xsl:param>` element in a specific manner in a style sheet."},{"content":"The syntax for the <ph id=\"ph1\">`variable`</ph> and <ph id=\"ph2\">`parameter`</ph> elements is as follows:","pos":[1495,1564],"source":" The syntax for the `variable` and `parameter` elements is as follows:"},{"content":"For the <ph id=\"ph1\">`parameter`</ph> element, the value is assigned to the qualified name (<ph id=\"ph2\">`Qname`</ph>) in several ways.","pos":[1766,1865],"source":"For the `parameter` element, the value is assigned to the qualified name (`Qname`) in several ways."},{"content":"You can assign a default value to the parameter by returning content from the XML Path Language (XPath) expression in the <ph id=\"ph1\">`select`</ph> attribute, or by assigning it the contents of the template body.","pos":[1866,2061],"source":" You can assign a default value to the parameter by returning content from the XML Path Language (XPath) expression in the `select` attribute, or by assigning it the contents of the template body."},{"content":"For the <ph id=\"ph1\">`variable`</ph> element, the value is also assigned in several ways.","pos":[2068,2139],"source":"For the `variable` element, the value is also assigned in several ways."},{"content":"You can assign it by returning content from the XPath expression in the <ph id=\"ph1\">`select`</ph> attribute, or by assigning it the contents of the template body.","pos":[2140,2285],"source":" You can assign it by returning content from the XPath expression in the `select` attribute, or by assigning it the contents of the template body."},{"content":"For both the <ph id=\"ph1\">`parameter`</ph> and <ph id=\"ph2\">`variable`</ph> elements, if a value is assigned by the XPath expression, then one of the four basic XPath types will be returned: Boolean, string, number, or node set.","pos":[2292,2484],"source":"For both the `parameter` and `variable` elements, if a value is assigned by the XPath expression, then one of the four basic XPath types will be returned: Boolean, string, number, or node set."},{"content":"When the value is given by using a non-empty template body, then a non-XPath data type is returned, and that will be a result tree fragment.","pos":[2485,2625]},{"content":"When a variable is bound to a result tree fragment instead of one of the four basic XPath data types, this is the only time that an XPath query returns a type that is not one of the four XPath object types.","pos":[2632,2838]},{"content":"Result tree fragments and their behavior are discussed in the World Wide Web Consortium (W3C) specification at www.w3.org/XSLT, section 11.1 Result Tree Fragments through section 11.6 Passing Parameters to Templates.","pos":[2839,3055]},{"content":"Also, section 1 Introduction discusses how templates can contain elements from the XSLT namespace that return or create result tree fragments.","pos":[3056,3198]},{"content":"A result tree fragment, in concept, behaves like a node set with nothing more than a single root node.","pos":[3205,3307]},{"content":"However, the rest of the nodes returned are child nodes.","pos":[3308,3364]},{"content":"To programmatically see the child nodes, copy the result tree fragment to the result tree using the <ph id=\"ph1\">`&lt;xsl:copy-of&gt;`</ph> element.","pos":[3365,3489],"source":" To programmatically see the child nodes, copy the result tree fragment to the result tree using the `<xsl:copy-of>` element."},{"content":"When the copy-of is performed, all the child nodes are also copied to the result tree in sequence.","pos":[3490,3588]},{"content":"Until a <ph id=\"ph1\">`copy`</ph> or <ph id=\"ph2\">`copy-of`</ph> is used, a result tree fragment is not part of the result tree or the output from the transformation.","pos":[3589,3718],"source":" Until a `copy` or `copy-of` is used, a result tree fragment is not part of the result tree or the output from the transformation."},{"content":"To iterate over the returned nodes of a result tree fragment, an <ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNavigator&gt;</ph> is used.","pos":[3725,3837],"source":"To iterate over the returned nodes of a result tree fragment, an <xref:System.Xml.XPath.XPathNavigator> is used."},{"content":"The following code sample shows how to create a result tree fragment within a style sheet by calling the function with a parameter <ph id=\"ph1\">`fragment`</ph>, which contains XML.","pos":[3838,4000],"source":" The following code sample shows how to create a result tree fragment within a style sheet by calling the function with a parameter `fragment`, which contains XML."},{"content":"Here is another sample showing a variable, which is in Rich Text Format (RTF), and hence, a type of result tree fragment, that is not converted to a node set.","pos":[4754,4912]},{"content":"Instead, it is passed to a script function, and the <ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNavigator&gt;</ph> is used to navigate over the nodes.","pos":[4913,5039],"source":" Instead, it is passed to a script function, and the <xref:System.Xml.XPath.XPathNavigator> is used to navigate over the nodes."},{"content":"The result of transforming any XML with this style sheet is shown in the following output.","pos":[5979,6069]},{"pos":[6078,6084],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"As stated above, the <ph id=\"ph1\">`node-set`</ph> function enables you to convert a result tree fragment into a node set.","pos":[6162,6265],"source":"As stated above, the `node-set` function enables you to convert a result tree fragment into a node set."},{"content":"The resulting node always contains a single node that is the root node of the tree.","pos":[6266,6349]},{"content":"If you convert a result tree fragment to a node set, then you can use it anywhere a regular node set is used, such as in a for-each statement or in the value of a <ph id=\"ph1\">`select`</ph> attribute.","pos":[6350,6532],"source":" If you convert a result tree fragment to a node set, then you can use it anywhere a regular node set is used, such as in a for-each statement or in the value of a `select` attribute."},{"content":"The following lines of code show the fragment being converted to a node set and used as a node set:","pos":[6533,6632]},{"content":"When a fragment is converted to a node set, you no longer use the <ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNavigator&gt;</ph> to navigate over it.","pos":[6777,6902],"source":"When a fragment is converted to a node set, you no longer use the <xref:System.Xml.XPath.XPathNavigator> to navigate over it."},{"content":"For a node set, you use the <ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNodeIterator&gt;</ph> instead.","pos":[6903,6981],"source":" For a node set, you use the <xref:System.Xml.XPath.XPathNodeIterator> instead."},{"content":"In the following example, <ph id=\"ph1\">`$var`</ph> is a variable that is a node tree in the style sheet.","pos":[6988,7074],"source":"In the following example, `$var` is a variable that is a node tree in the style sheet."},{"content":"The for-each statement, combined with the <ph id=\"ph1\">`node-set`</ph> function, allows the user to iterate over this tree as a node set.","pos":[7075,7194],"source":" The for-each statement, combined with the `node-set` function, allows the user to iterate over this tree as a node set."},{"content":"Here is another example of a variable that is in RTF, and hence of type result tree fragment, that is converted to a node set before being passed to a script function as XPathNodeIterator.","pos":[7750,7938]},{"content":"The following is the result of transforming XML with this style sheet:","pos":[8876,8946]},{"pos":[9031,9039],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNodeIterator&gt;</ph>","pos":[9043,9084],"source":"<xref:System.Xml.XPath.XPathNodeIterator> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.XPath.XPathNodeIterator&gt;</ph>","pos":[9089,9130],"source":"<xref:System.Xml.XPath.XPathNodeIterator> "},{"content":"<bpt id=\"p1\">[</bpt>XSLT Transformations with the XslTransform Class<ept id=\"p1\">](../../../../docs/standard/data/xml/xslt-transformations-with-the-xsltransform-class.md)</ept><ph id=\"ph1\"> </ph>","pos":[9135,9274],"source":"[XSLT Transformations with the XslTransform Class](../../../../docs/standard/data/xml/xslt-transformations-with-the-xsltransform-class.md) "},{"content":"<bpt id=\"p1\">[</bpt>XslTransform Class Implements the XSLT Processor<ept id=\"p1\">](../../../../docs/standard/data/xml/xsltransform-class-implements-the-xslt-processor.md)</ept>","pos":[9278,9416],"source":"[XslTransform Class Implements the XSLT Processor](../../../../docs/standard/data/xml/xsltransform-class-implements-the-xslt-processor.md)"}]}