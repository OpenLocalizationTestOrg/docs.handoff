{"content":"---\ntitle: \"ICorDebugThread::SetDebugState Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorDebugThread.SetDebugState\"\napi_location: \n  - \"mscordbi.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorDebugThread::SetDebugState\"\nhelpviewer_keywords: \n  - \"ICorDebugThread::SetDebugState method [.NET Framework debugging]\"\n  - \"SetDebugState method [.NET Framework debugging]\"\nms.assetid: 6382bdf6-d488-4952-b653-cb09b6e1c6c2\ntopic_type: \n  - \"apiref\"\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# ICorDebugThread::SetDebugState Method\nSets flags that describe the debugging state of this ICorDebugThread.  \n  \n## Syntax  \n  \n```  \nHRESULT SetDebugState (  \n    [in] CorDebugThreadState state  \n);  \n```  \n  \n## Parameters  \n `state`  \n [in] A bitwise combination of CorDebugThreadState enumeration values that specify the debugging state of this thread.  \n  \n## Remarks  \n `SetDebugState` sets the current debug state of the thread. (The \"current debug state\" represents the debug state if the process were to be continued, not the actual current state.) The normal value for this is THREAD_RUNNING. Only the debugger can affect the debug state of a thread. Debug states do last across continues, so if you want to keep a thread THREAD_SUSPENDed over multiple continues, you can set it once and thereafter not have to worry about it. Suspending threads and resuming the process can cause deadlocks, though it's usually unlikely. This is an intrinsic quality of threads and processes and is by-design. A debugger can asynchronously break and resume the threads to break the deadlock. If the thread's user state includes USER_UNSAFE_POINT, then the thread may block a garbage collection (GC). This means the suspended thread has a much higher chance of causing a deadlock. This may not affect debug events already queued. Thus a debugger should drain the entire event queue (by calling [ICorDebugController::HasQueuedCallbacks](../../../../docs/framework/unmanaged-api/debugging/icordebugcontroller-hasqueuedcallbacks-method.md)) before suspending or resuming threads. Else it may get events on a thread that it believes it has already suspended.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorDebug.idl, CorDebug.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v10plus](../../../../includes/net-current-v10plus-md.md)]\n","nodes":[{"pos":[4,487],"embed":true,"restype":"x-metadata","content":"title: \"ICorDebugThread::SetDebugState Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorDebugThread.SetDebugState\"\napi_location: \n  - \"mscordbi.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorDebugThread::SetDebugState\"\nhelpviewer_keywords: \n  - \"ICorDebugThread::SetDebugState method [.NET Framework debugging]\"\n  - \"SetDebugState method [.NET Framework debugging]\"\nms.assetid: 6382bdf6-d488-4952-b653-cb09b6e1c6c2\ntopic_type: \n  - \"apiref\"\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"ICorDebugThread::SetDebugState Method","nodes":[{"pos":[0,37],"content":"ICorDebugThread::SetDebugState Method","nodes":[{"content":"ICorDebugThread::SetDebugState Method","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[494,531],"content":"ICorDebugThread::SetDebugState Method","linkify":"ICorDebugThread::SetDebugState Method","nodes":[{"content":"ICorDebugThread::SetDebugState Method","pos":[0,37]}]},{"content":"Sets flags that describe the debugging state of this ICorDebugThread.","pos":[532,601]},{"pos":[610,616],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[708,718],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] A bitwise combination of CorDebugThreadState enumeration values that specify the debugging state of this thread.","pos":[733,850]},{"pos":[859,866],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`SetDebugState`</ph> sets the current debug state of the thread.","pos":[870,929],"source":"`SetDebugState` sets the current debug state of the thread."},{"content":"(The \"current debug state\" represents the debug state if the process were to be continued, not the actual current state.) The normal value for this is THREAD_RUNNING.","pos":[930,1096]},{"content":"Only the debugger can affect the debug state of a thread.","pos":[1097,1154]},{"content":"Debug states do last across continues, so if you want to keep a thread THREAD_SUSPENDed over multiple continues, you can set it once and thereafter not have to worry about it.","pos":[1155,1330]},{"content":"Suspending threads and resuming the process can cause deadlocks, though it's usually unlikely.","pos":[1331,1425]},{"content":"This is an intrinsic quality of threads and processes and is by-design.","pos":[1426,1497]},{"content":"A debugger can asynchronously break and resume the threads to break the deadlock.","pos":[1498,1579]},{"content":"If the thread's user state includes USER_UNSAFE_POINT, then the thread may block a garbage collection (GC).","pos":[1580,1687]},{"content":"This means the suspended thread has a much higher chance of causing a deadlock.","pos":[1688,1767]},{"content":"This may not affect debug events already queued.","pos":[1768,1816]},{"content":"Thus a debugger should drain the entire event queue (by calling <bpt id=\"p1\">[</bpt>ICorDebugController::HasQueuedCallbacks<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/debugging/icordebugcontroller-hasqueuedcallbacks-method.md)</ept>) before suspending or resuming threads.","pos":[1817,2063],"source":" Thus a debugger should drain the entire event queue (by calling [ICorDebugController::HasQueuedCallbacks](../../../../docs/framework/unmanaged-api/debugging/icordebugcontroller-hasqueuedcallbacks-method.md)) before suspending or resuming threads."},{"content":"Else it may get events on a thread that it believes it has already suspended.","pos":[2064,2141]},{"pos":[2150,2162],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2166,2270],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[2277,2313],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorDebug.idl, CorDebug.h","source":"**Header:** CorDebug.idl, CorDebug.h"},{"pos":[2320,2345],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[2352,2460],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept> <ph id=\"ph1\">[!INCLUDE[net_current_v10plus](../../../../includes/net-current-v10plus-md.md)]</ph>","source":"**.NET Framework Versions:** [!INCLUDE[net_current_v10plus](../../../../includes/net-current-v10plus-md.md)]"}]}