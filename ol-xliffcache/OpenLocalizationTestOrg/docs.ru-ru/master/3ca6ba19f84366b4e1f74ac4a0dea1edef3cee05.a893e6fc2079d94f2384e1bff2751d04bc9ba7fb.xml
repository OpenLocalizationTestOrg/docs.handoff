{"content":"---\ntitle: Get started with syntax transformation (Roslyn APIs)\ndescription: An introduction to traversing, querying and walking syntax trees.\nms.date: 06/01/2018\nms.custom: mvc\n---\n# Get started with syntax transformation\n\nThis tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts. If you haven't already, you should complete those quickstarts before beginning this one.\n\nIn this quickstart, you explore techniques for creating and transforming syntax trees. In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!\n\n[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]\n\n## Immutability and the .NET compiler platform\n\n**Immutability** is a fundamental tenet of the .NET compiler platform. Immutable data structures can't be changed after they're created. Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously. There's no danger that one consumer affects another in unpredictable ways. Your analyzer doesn't need locks or other concurrency measures. This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter. Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones. You apply this concept to syntax trees to create new trees using transformations.\n\n## Create and transform trees\n\nYou choose one of two strategies for syntax transformations. **Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code. **Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.\n\n### Create nodes with factory methods\n\nThe first syntax transformation demonstrates the factory methods. You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement. This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods. For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type. You create syntax trees by composing nodes hierarchically in a bottom-up fashion. Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.\n\nStart Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project. In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog. Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**. This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**. Click **OK**.\n\nThis project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.\n\nAdd the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:\n\n[!code-csharp[import the SyntaxFactory class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings \"import the Syntax Factory class and the System.Console class\")]\n\nYou'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement. <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#. You compose these four types of names together to create any name that can appear in the C# language:\n\n* <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.\n* <xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.\n* <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.\n* <xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.\n\nYou use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node. Add the following code in your `Main` method in `Program.cs`:\n\n[!code-csharp[create the system identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName \"Create and display the system name identifier\")]\n\nThe preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`. Many of the Roslyn APIs return base classes to make it easier to work with related types. The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>. Don't use type inference as you build the sample. You'll automate that step in this project.\n\nYou've created the name. Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>. The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>. Add the following code to `program.cs`:\n\n[!code-csharp[create the collections identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName \"Build the System.Collections identifier\")]\n\nRun the code again, and see the results. You're building a tree of nodes that represents code. You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`. Add the following code to `Program.cs`:\n\n[!code-csharp[create the full identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace \"Build the System.Collections.Generic identifier\")]\n\nRun the program again to see that you've build the tree for the code to add.\n\n### Create a modified tree\n\nYou've built a small syntax tree that contains one statement. The APIs to create new nodes are the right choice to create single statements or other small code blocks. However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree. Remember that syntax trees are immutable. The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction. Instead, it provides methods that produce new trees based on changes to existing ones. `With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class. These methods create a new node by applying changes to an existing node's child properties. Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree. This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree.\n\nThe next step is to create a tree that represents an entire (small) program and then modify it. Add the following code to the beginning of the `Program` class:\n\n[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode \"Create a tree that represents a small program\")]\n\n> [!NOTE]\n> The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.\n\nNext, add the following code to the bottom of the `Main` method to parse the text and create a tree:\n\n[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree \"Create a tree that represents a small program\")]\n\nThis example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.\n\nCreate a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code. Add the following code to the bottom of the `Main` method:\n\n[!code-csharp[create a new subtree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing \"Create the subtree with the replaced namespace\")]\n\nRun the program and look carefully at the output. The `newusing` hasn't been placed in the root tree. The original tree hasn't been changed.\n\nAdd the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree. The new tree is the result of replacing the existing import with the updated `newUsing` node. You assign this new tree to the existing `root` variable:\n\n[!code-csharp[create a new root tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree \"Create the transformed root tree with the replaced namespace\")]\n\nRun the program again. This time the tree now correctly imports the `System.Collections.Generic` namespace.\n\n### Transform trees using `SyntaxRewriters`\n\nThe `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree. The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree. The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>. The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>. You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree. The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.\n\nCreate a new C# **Stand-Alone Code Analysis Tool** project. In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node. Choose **Add** > **New Project** to display the **New Project dialog**. Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**. Name your project `TransformationCS` and click OK.\n\nThe first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations. Add a new class file to the project. In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.\n\nAdd the following using directives to the `TypeInferenceRewriter.cs` file:\n\n[!code-csharp[add necessary usings](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings \"Add required usings\")]\n\nNext, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:\n\n[!code-csharp[add base class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass \"Add base class\")]\n\nAdd the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor. You will need this field later on to determine where type inference can be used:\n\n[!code-csharp[initialize members](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction \"Declare and initialize member variables\")]\n\nOverride the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:\n\n```C#\npublic override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)\n{\n\n}\n```\n\n> [!NOTE]\n> Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned. In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed. In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>. This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.\n\nThis quickstart handles local variable declarations. You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions. Furthermore this rewriter will only transform declarations of the simplest form:\n\n```csharp\nType variable = expression;\n```\n\nIf you want to explore on your own, consider extending the finished sample for these types of variable declarations:\n\n```csharp\n// Multiple variables in a single declaration.\nType variable1 = expression1,\n     variable2 = expression2;\n// No initializer.\nType variable;\n```\n\nAdd the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:\n\n[!code-csharp[exclude other declarations](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions \"Exclude variables declarations not processed by this sample\")]\n\nThe method indicates that no rewriting takes place by returning the `node` parameter unmodified. If neither of those `if` expressions are true, the node represents a possible declaration with initialization. Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:\n\n[!code-csharp[extract type name](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol \"Extract the type name specified by the declaration\")]\n\nNow, add this statement to bind the initializer expression:\n\n[!code-csharp[bind initializer](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer \"Bind the initializer expressions\")]\n\nFinally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:\n\n[!code-csharp[ReplaceNode](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode \"Replace the initializer node\")]\n\nThe conditional is required because the declaration may cast the initializer expression to a base class or interface. If that's desired, the types on the left and right-hand side of the assignment don't match. Removing the explicit type in these cases would change the semantics of a program. `var` is specified as an identifier rather than a keyword because `var` is a contextual keyword. The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation. It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.\n\nYou've finished the `TypeInferenceRewriter`. Now return to your `Program.cs` file to finish the example. Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it. Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`. You'll do this step last. In the meantime declare a placeholder variable representing your test compilation:\n\n[!code-csharp[DeclareCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation \"Declare the test compilation\")]\n\nAfter pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists. Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command. This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class. You'll come back to fill in this method later:\n\n![C# Generate method from usage](./media/syntax-transformation/generate-from-usage.png)\n\nWrite the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>. For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:\n\n[!code-csharp[IterateTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees \"Iterate all the source trees in the test compilation\")]\n\nInside the `foreach` statement you created, add the following code to perform the transformation on each source tree. This code conditionally writes out the new transformed tree if any edits were made. Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:\n\n[!code-csharp[TransformTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees \"Transform and save any trees that are modified by the rewriter\")]\n\nYou should see squiggles under the `File.WriteAllText` code. Select the light bulb, and add the necessary `using System.IO;` statement.\n\nYou're almost done! There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>. Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case. Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough. But fortunately, if you've been following instructions carefully, there's hope. Replace the contents of the `CreateTestCompilation` method with the following code. It creates a test compilation that coincidentally matches the project described in this quickstart:\n\n[!code-csharp[CreateTestCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation \"Create a test compilation using the code written for this quickstart.\")]\n\nCross your fingers and run the project. In Visual Studio, choose **Debug** > **Start Debugging**. You should be prompted by Visual Studio that the files in your project have changed. Click \"**Yes to All**\" to reload the modified files. Examine them to observe your awesomeness. Note how much cleaner the code looks without all those explicit and redundant type specifiers.\n\nCongratulations! You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it. You're now officially refactoring author!\n","nodes":[{"pos":[4,177],"embed":true,"restype":"x-metadata","content":"title: Get started with syntax transformation (Roslyn APIs)\ndescription: An introduction to traversing, querying and walking syntax trees.\nms.date: 06/01/2018\nms.custom: mvc","nodes":[{"content":"Get started with syntax transformation (Roslyn APIs)","nodes":[{"pos":[0,52],"content":"Get started with syntax transformation (Roslyn APIs)","nodes":[{"content":"Get started with syntax transformation (Roslyn APIs)","pos":[0,52]}]}],"path":["title"],"nosxs":false},{"content":"An introduction to traversing, querying and walking syntax trees.","nodes":[{"pos":[0,65],"content":"An introduction to traversing, querying and walking syntax trees.","nodes":[{"content":"An introduction to traversing, querying and walking syntax trees.","pos":[0,65]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[184,222],"content":"Get started with syntax transformation","linkify":"Get started with syntax transformation","nodes":[{"content":"Get started with syntax transformation","pos":[0,38]}]},{"content":"This tutorial builds on concepts and techniques explored in the <bpt id=\"p1\">[</bpt>Get started with syntax analysis<ept id=\"p1\">](syntax-analysis.md)</ept> and <bpt id=\"p2\">[</bpt>Get started with semantic analysis<ept id=\"p2\">](semantic-analysis.md)</ept> quickstarts.","pos":[224,418],"source":"This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts."},{"content":"If you haven't already, you should complete those quickstarts before beginning this one.","pos":[419,507]},{"content":"In this quickstart, you explore techniques for creating and transforming syntax trees.","pos":[509,595]},{"content":"In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!","pos":[596,715]},{"pos":[785,828],"content":"Immutability and the .NET compiler platform","linkify":"Immutability and the .NET compiler platform","nodes":[{"content":"Immutability and the .NET compiler platform","pos":[0,43]}]},{"content":"<bpt id=\"p1\">**</bpt>Immutability<ept id=\"p1\">**</ept> is a fundamental tenet of the .NET compiler platform.","pos":[830,900],"source":"**Immutability** is a fundamental tenet of the .NET compiler platform."},{"content":"Immutable data structures can't be changed after they're created.","pos":[901,966]},{"content":"Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.","pos":[967,1064]},{"content":"There's no danger that one consumer affects another in unpredictable ways.","pos":[1065,1139]},{"content":"Your analyzer doesn't need locks or other concurrency measures.","pos":[1140,1203]},{"content":"This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.","pos":[1204,1324]},{"content":"Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.","pos":[1325,1438]},{"content":"You apply this concept to syntax trees to create new trees using transformations.","pos":[1439,1520]},{"pos":[1525,1551],"content":"Create and transform trees","linkify":"Create and transform trees","nodes":[{"content":"Create and transform trees","pos":[0,26]}]},{"content":"You choose one of two strategies for syntax transformations.","pos":[1553,1613]},{"content":"<bpt id=\"p1\">**</bpt>Factory methods<ept id=\"p1\">**</ept> are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.","pos":[1614,1757],"source":"**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code."},{"content":"<bpt id=\"p1\">**</bpt>Rewriters<ept id=\"p1\">**</ept> are best when you want to scan an entire project for code patterns that you want to replace.","pos":[1758,1864],"source":"**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace."},{"pos":[1870,1903],"content":"Create nodes with factory methods","linkify":"Create nodes with factory methods","nodes":[{"content":"Create nodes with factory methods","pos":[0,33]}]},{"content":"The first syntax transformation demonstrates the factory methods.","pos":[1905,1970]},{"content":"You're going to replace a <ph id=\"ph1\">`using System.Collections;`</ph> statement with a <ph id=\"ph2\">`using System.Collections.Generic;`</ph> statement.","pos":[1971,2088],"source":" You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement."},{"content":"This example demonstrates how you create <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType&gt;</ph> objects using the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType&gt;</ph> factory methods.","pos":[2089,2327],"source":" This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods."},{"content":"For each kind of <bpt id=\"p1\">**</bpt>node<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>token<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>trivia<ept id=\"p3\">**</ept> there's a factory method that creates an instance of that type.","pos":[2328,2443],"source":" For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type."},{"content":"You create syntax trees by composing nodes hierarchically in a bottom-up fashion.","pos":[2444,2525]},{"content":"Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.","pos":[2526,2631]},{"content":"Start Visual Studio, and create a new C# <bpt id=\"p1\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p1\">**</ept> project.","pos":[2633,2717],"source":"Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project."},{"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>File<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept><ph id=\"ph2\"> &gt; </ph><bpt id=\"p3\">**</bpt>Project<ept id=\"p3\">**</ept> to display the New Project dialog.","pos":[2718,2810],"source":" In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog."},{"content":"Under <bpt id=\"p1\">**</bpt>Visual C#<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Extensibility<ept id=\"p2\">**</ept> choose a <bpt id=\"p3\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p3\">**</ept>.","pos":[2811,2895],"source":" Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**."},{"content":"This quickstart has two example projects, so name the solution <bpt id=\"p1\">**</bpt>SyntaxTransformationQuickStart<ept id=\"p1\">**</ept>, and name the project <bpt id=\"p2\">**</bpt>ConstructionCS<ept id=\"p2\">**</ept>.","pos":[2896,3035],"source":" This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**."},{"content":"Click <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept>.","pos":[3036,3049],"source":" Click **OK**."},{"pos":[3051,3322],"content":"This project uses the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType&gt;</ph> class methods to construct a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType&gt;</ph> representing the <ph id=\"ph3\">`System.Collections.Generic`</ph> namespace.","source":"This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace."},{"pos":[3324,3584],"content":"Add the following using directive to the top of the <ph id=\"ph1\">`Program.cs`</ph> file to import the factory methods of the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory&gt;</ph> class and the methods of <ph id=\"ph3\">&lt;xref:System.Console&gt;</ph> so that you can use them later without qualifying them:","source":"Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:"},{"content":"You'll create <bpt id=\"p1\">**</bpt>name syntax nodes<ept id=\"p1\">**</ept> to build the tree that represents the <ph id=\"ph1\">`using System.Collections.Generic;`</ph> statement.","pos":[3806,3926],"source":"You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement."},{"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax&gt;</ph> is the base class for four types of names that appear in C#.","pos":[3927,4042],"source":"<xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#."},{"content":"You compose these four types of names together to create any name that can appear in the C# language:","pos":[4043,4144]},{"pos":[4148,4311],"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType&gt;</ph>, which represents simple single identifier names like <ph id=\"ph2\">`System`</ph> and <ph id=\"ph3\">`Microsoft`</ph>.","source":"<xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`."},{"pos":[4314,4473],"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType&gt;</ph>, which represents a generic type or method name such as <ph id=\"ph2\">`List&lt;int&gt;`</ph>.","source":"<xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`."},{"pos":[4476,4685],"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType&gt;</ph>, which represents a qualified name of the form <ph id=\"ph2\">`&lt;left-name&gt;.&lt;right-identifier-or-generic-name&gt;`</ph> such as <ph id=\"ph3\">`System.IO`</ph>.","source":"<xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`."},{"pos":[4688,4866],"content":"<ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType&gt;</ph>, which represents a name using an assembly extern alias such a <ph id=\"ph2\">`LibraryV2::Foo`</ph>.","source":"<xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`."},{"content":"You use the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)&gt;</ph> method to create a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax&gt;</ph> node.","pos":[4868,5040],"source":"You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node."},{"content":"Add the following code in your <ph id=\"ph1\">`Main`</ph> method in <ph id=\"ph2\">`Program.cs`</ph>:","pos":[5041,5102],"source":" Add the following code in your `Main` method in `Program.cs`:"},{"content":"The preceding code creates an <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax&gt;</ph> object and assigns it to the variable <ph id=\"ph2\">`name`</ph>.","pos":[5315,5455],"source":"The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`."},{"content":"Many of the Roslyn APIs return base classes to make it easier to work with related types.","pos":[5456,5545]},{"content":"The variable <ph id=\"ph1\">`name`</ph>, an <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax&gt;</ph>, can be reused as you build the <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax&gt;</ph>.","pos":[5546,5721],"source":" The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>."},{"content":"Don't use type inference as you build the sample.","pos":[5722,5771]},{"content":"You'll automate that step in this project.","pos":[5772,5814]},{"content":"You've created the name.","pos":[5816,5840]},{"content":"Now, it's time to build more nodes into the tree by building a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax&gt;</ph>.","pos":[5841,5968],"source":" Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>."},{"content":"The new tree uses <ph id=\"ph1\">`name`</ph> as the left of the name, and a new <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax&gt;</ph> for the <ph id=\"ph3\">`Collections`</ph> namespace as the right side of the <ph id=\"ph4\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax&gt;</ph>.","pos":[5969,6215],"source":" The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>."},{"content":"Add the following code to <ph id=\"ph1\">`program.cs`</ph>:","pos":[6216,6255],"source":" Add the following code to `program.cs`:"},{"content":"Run the code again, and see the results.","pos":[6476,6516]},{"content":"You're building a tree of nodes that represents code.","pos":[6517,6570]},{"content":"You'll continue this pattern to build the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax&gt;</ph> for the namespace <ph id=\"ph2\">`System.Collections.Generic`</ph>.","pos":[6571,6724],"source":" You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`."},{"content":"Add the following code to <ph id=\"ph1\">`Program.cs`</ph>:","pos":[6725,6764],"source":" Add the following code to `Program.cs`:"},{"content":"Run the program again to see that you've build the tree for the code to add.","pos":[6976,7052]},{"pos":[7058,7080],"content":"Create a modified tree","linkify":"Create a modified tree","nodes":[{"content":"Create a modified tree","pos":[0,22]}]},{"content":"You've built a small syntax tree that contains one statement.","pos":[7082,7143]},{"content":"The APIs to create new nodes are the right choice to create single statements or other small code blocks.","pos":[7144,7249]},{"content":"However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.","pos":[7250,7371]},{"content":"Remember that syntax trees are immutable.","pos":[7372,7413]},{"content":"The <bpt id=\"p1\">**</bpt>Syntax API<ept id=\"p1\">**</ept> doesn't provide any mechanism for modifying an existing syntax tree after construction.","pos":[7414,7520],"source":" The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction."},{"content":"Instead, it provides methods that produce new trees based on changes to existing ones.","pos":[7521,7607]},{"content":"<ph id=\"ph1\">`With*`</ph> methods are defined in concrete classes that derive from <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode&gt;</ph> or in extension methods declared in the <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions&gt;</ph> class.","pos":[7608,7811],"source":"`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class."},{"content":"These methods create a new node by applying changes to an existing node's child properties.","pos":[7812,7903]},{"content":"Additionally, the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A&gt;</ph> extension method can be used to replace a descendent node in a subtree.","pos":[7904,8059],"source":" Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree."},{"content":"This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as <bpt id=\"p1\">_</bpt>re-spining<ept id=\"p1\">_</ept> the tree.","pos":[8060,8219],"source":" This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree."},{"content":"The next step is to create a tree that represents an entire (small) program and then modify it.","pos":[8221,8316]},{"content":"Add the following code to the beginning of the <ph id=\"ph1\">`Program`</ph> class:","pos":[8317,8380],"source":" Add the following code to the beginning of the `Program` class:"},{"pos":[8583,8701],"content":"[!NOTE]\nThe example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.","leadings":["","> "],"nodes":[{"content":"The example code uses the <ph id=\"ph1\">`System.Collections`</ph> namespace and not the <ph id=\"ph2\">`System.Collections.Generic`</ph> namespace.","pos":[8,116],"source":"The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace."}]},{"pos":[8703,8803],"content":"Next, add the following code to the bottom of the <ph id=\"ph1\">`Main`</ph> method to parse the text and create a tree:","source":"Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:"},{"pos":[9002,9325],"content":"This example uses the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType&gt;</ph> method to replace the name in a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax&gt;</ph> node with the one constructed in the preceding code.","source":"This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code."},{"content":"Create a new <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax&gt;</ph> node using the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)&gt;</ph> method to update the <ph id=\"ph3\">`System.Collections`</ph> name with the name you created in the preceding code.","pos":[9327,9638],"source":"Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code."},{"content":"Add the following code to the bottom of the <ph id=\"ph1\">`Main`</ph> method:","pos":[9639,9697],"source":" Add the following code to the bottom of the `Main` method:"},{"content":"Run the program and look carefully at the output.","pos":[9896,9945]},{"content":"The <ph id=\"ph1\">`newusing`</ph> hasn't been placed in the root tree.","pos":[9946,9997],"source":" The `newusing` hasn't been placed in the root tree."},{"content":"The original tree hasn't been changed.","pos":[9998,10036]},{"content":"Add the following code using the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A&gt;</ph> extension method to create a new tree.","pos":[10038,10175],"source":"Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree."},{"content":"The new tree is the result of replacing the existing import with the updated <ph id=\"ph1\">`newUsing`</ph> node.","pos":[10176,10269],"source":" The new tree is the result of replacing the existing import with the updated `newUsing` node."},{"content":"You assign this new tree to the existing <ph id=\"ph1\">`root`</ph> variable:","pos":[10270,10327],"source":" You assign this new tree to the existing `root` variable:"},{"content":"Run the program again.","pos":[10542,10564]},{"content":"This time the tree now correctly imports the <ph id=\"ph1\">`System.Collections.Generic`</ph> namespace.","pos":[10565,10649],"source":" This time the tree now correctly imports the `System.Collections.Generic` namespace."},{"pos":[10655,10694],"content":"Transform trees using <ph id=\"ph1\">`SyntaxRewriters`</ph>","linkify":"Transform trees using `SyntaxRewriters`","source":"Transform trees using `SyntaxRewriters`"},{"content":"The <ph id=\"ph1\">`With*`</ph> and <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A&gt;</ph> methods provide convenient means to transform individual branches of a syntax tree.","pos":[10696,10861],"source":"The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType&gt;</ph> class performs multiple transformations on a syntax tree.","pos":[10862,11010],"source":" The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType&gt;</ph> class is a subclass of <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType&gt;</ph>.","pos":[11011,11215],"source":" The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter&gt;</ph> applies a transformation to a specific type of <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode&gt;</ph>.","pos":[11216,11366],"source":" The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>."},{"content":"You can apply transformations to multiple types of <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode&gt;</ph> objects wherever they appear in a syntax tree.","pos":[11367,11505],"source":" You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree."},{"content":"The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.","pos":[11506,11681]},{"content":"Create a new C# <bpt id=\"p1\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p1\">**</ept> project.","pos":[11683,11742],"source":"Create a new C# **Stand-Alone Code Analysis Tool** project."},{"content":"In Visual Studio, right-click the <ph id=\"ph1\">`SyntaxTransformationQuickStart`</ph> solution node.","pos":[11743,11824],"source":" In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node."},{"content":"Choose <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>New Project<ept id=\"p2\">**</ept> to display the <bpt id=\"p3\">**</bpt>New Project dialog<ept id=\"p3\">**</ept>.","pos":[11825,11896],"source":" Choose **Add** > **New Project** to display the **New Project dialog**."},{"content":"Under <bpt id=\"p1\">**</bpt>Visual C#<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Extensibility<ept id=\"p2\">**</ept>, choose <bpt id=\"p3\">**</bpt>Stand-Alone Code Analysis Tool<ept id=\"p3\">**</ept>.","pos":[11897,11980],"source":" Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**."},{"content":"Name your project <ph id=\"ph1\">`TransformationCS`</ph> and click OK.","pos":[11981,12031],"source":" Name your project `TransformationCS` and click OK."},{"content":"The first step is to create a class that derives from <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter&gt;</ph> to perform your transformations.","pos":[12033,12177],"source":"The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations."},{"content":"Add a new class file to the project.","pos":[12178,12214]},{"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>Project<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Add Class...<ept id=\"p2\">**</ept>. In the <bpt id=\"p3\">**</bpt>Add New Item<ept id=\"p3\">**</ept> dialog type <ph id=\"ph2\">`TypeInferenceRewriter.cs`</ph> as the filename.","pos":[12215,12351],"source":" In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename."},{"pos":[12353,12427],"content":"Add the following using directives to the <ph id=\"ph1\">`TypeInferenceRewriter.cs`</ph> file:","source":"Add the following using directives to the `TypeInferenceRewriter.cs` file:"},{"pos":[12611,12731],"content":"Next, make the <ph id=\"ph1\">`TypeInferenceRewriter`</ph> class extend the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter&gt;</ph> class:","source":"Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:"},{"content":"Add the following code to declare a private read-only field to hold a <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> and initialize it in the constructor.","pos":[12904,13055],"source":"Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor."},{"content":"You will need this field later on to determine where type inference can be used:","pos":[13056,13136]},{"pos":[13341,13520],"content":"Override the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)&gt;</ph> method:","source":"Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:"},{"pos":[13636,14339],"content":"[!NOTE]\nMany of the Roslyn APIs declare return types that are base classes of the actual runtime types returned. In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed. In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>. This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.","leadings":["","> "],"nodes":[{"content":"Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned. In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed. In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>. This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.","pos":[8,701],"nodes":[{"content":"Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.","pos":[0,104]},{"content":"In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.","pos":[105,208]},{"content":"In this example, the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)&gt;</ph> method returns a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SyntaxNode&gt;</ph>, instead of the derived type of   <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax&gt;</ph>.","pos":[209,557],"source":" In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>."},{"content":"This rewriter returns a new <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax&gt;</ph> node based on the existing one.","pos":[558,693],"source":" This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one."}]}]},{"content":"This quickstart handles local variable declarations.","pos":[14341,14393]},{"content":"You could extend it to other declarations such as <ph id=\"ph1\">`foreach`</ph> loops, <ph id=\"ph2\">`for`</ph> loops, LINQ expressions, and lambda expressions.","pos":[14394,14515],"source":" You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions."},{"content":"Furthermore this rewriter will only transform declarations of the simplest form:","pos":[14516,14596]},{"content":"If you want to explore on your own, consider extending the finished sample for these types of variable declarations:","pos":[14641,14757]},{"pos":[14915,15043],"content":"Add the following code to the body of the <ph id=\"ph1\">`VisitLocalDeclarationStatement`</ph> method to skip rewriting these forms of declarations:","source":"Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:"},{"content":"The method indicates that no rewriting takes place by returning the <ph id=\"ph1\">`node`</ph> parameter unmodified.","pos":[15274,15370],"source":"The method indicates that no rewriting takes place by returning the `node` parameter unmodified."},{"content":"If neither of those <ph id=\"ph1\">`if`</ph> expressions are true, the node represents a possible declaration with initialization.","pos":[15371,15481],"source":" If neither of those `if` expressions are true, the node represents a possible declaration with initialization."},{"content":"Add these statements to extract the type name specified in the declaration and bind it using the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> field to obtain a type symbol:","pos":[15482,15653],"source":" Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:"},{"content":"Now, add this statement to bind the initializer expression:","pos":[15873,15932]},{"pos":[16131,16299],"content":"Finally, add the following <ph id=\"ph1\">`if`</ph> statement to replace the existing type name with the <ph id=\"ph2\">`var`</ph> keyword if the type of the initializer expression matches the type specified:","source":"Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:"},{"content":"The conditional is required because the declaration may cast the initializer expression to a base class or interface.","pos":[16485,16602]},{"content":"If that's desired, the types on the left and right-hand side of the assignment don't match.","pos":[16603,16694]},{"content":"Removing the explicit type in these cases would change the semantics of a program.","pos":[16695,16777]},{"content":"<ph id=\"ph1\">`var`</ph> is specified as an identifier rather than a keyword because <ph id=\"ph2\">`var`</ph> is a contextual keyword.","pos":[16778,16874],"source":"`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword."},{"content":"The leading and trailing trivia (white space) are transferred from the old type name to the <ph id=\"ph1\">`var`</ph> keyword to maintain vertical white space and indentation.","pos":[16875,17030],"source":" The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation."},{"content":"It's simpler to use <ph id=\"ph1\">`ReplaceNode`</ph> rather than <ph id=\"ph2\">`With*`</ph> to transform the <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax&gt;</ph> because the type name is actually the grandchild of the declaration statement.","pos":[17031,17256],"source":" It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement."},{"content":"You've finished the <ph id=\"ph1\">`TypeInferenceRewriter`</ph>.","pos":[17258,17302],"source":"You've finished the `TypeInferenceRewriter`."},{"content":"Now return to your <ph id=\"ph1\">`Program.cs`</ph> file to finish the example.","pos":[17303,17362],"source":" Now return to your `Program.cs` file to finish the example."},{"content":"Create a test <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> and obtain the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> from it.","pos":[17363,17486],"source":" Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it."},{"content":"Use that <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> to try your <ph id=\"ph2\">`TypeInferenceRewriter`</ph>.","pos":[17487,17576],"source":" Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`."},{"content":"You'll do this step last.","pos":[17577,17602]},{"content":"In the meantime declare a placeholder variable representing your test compilation:","pos":[17603,17685]},{"content":"After pausing a moment, you should see an error squiggle appear reporting that no <ph id=\"ph1\">`CreateTestCompilation`</ph> method exists.","pos":[17875,17995],"source":"After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists."},{"content":"Press <bpt id=\"p1\">**</bpt>Ctrl+Period<ept id=\"p1\">**</ept> to open the light-bulb and then press Enter to invoke the <bpt id=\"p2\">**</bpt>Generate Method Stub<ept id=\"p2\">**</ept> command.","pos":[17996,18109],"source":" Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command."},{"content":"This command will generate a method stub for the <ph id=\"ph1\">`CreateTestCompilation`</ph> method in the <ph id=\"ph2\">`Program`</ph> class.","pos":[18110,18213],"source":" This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class."},{"content":"You'll come back to fill in this method later:","pos":[18214,18260]},{"content":"C# Generate method from usage","pos":[18264,18293]},{"content":"Write the following code to iterate over each <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SyntaxTree&gt;</ph> in the test <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph>.","pos":[18351,18492],"source":"Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>."},{"content":"For each one, initialize a new <ph id=\"ph1\">`TypeInferenceRewriter`</ph> with the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel&gt;</ph> for that tree:","pos":[18493,18615],"source":" For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:"},{"content":"Inside the <ph id=\"ph1\">`foreach`</ph> statement you created, add the following code to perform the transformation on each source tree.","pos":[18813,18930],"source":"Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree."},{"content":"This code conditionally writes out the new transformed tree if any edits were made.","pos":[18931,19014]},{"content":"Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:","pos":[19015,19158]},{"content":"You should see squiggles under the <ph id=\"ph1\">`File.WriteAllText`</ph> code.","pos":[19370,19430],"source":"You should see squiggles under the `File.WriteAllText` code."},{"content":"Select the light bulb, and add the necessary <ph id=\"ph1\">`using System.IO;`</ph> statement.","pos":[19431,19505],"source":" Select the light bulb, and add the necessary `using System.IO;` statement."},{"content":"You're almost done!","pos":[19507,19526]},{"content":"There's once step left: creating a test <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph>.","pos":[19527,19609],"source":" There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>."},{"content":"Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.","pos":[19610,19724]},{"content":"Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.","pos":[19725,19826]},{"content":"But fortunately, if you've been following instructions carefully, there's hope.","pos":[19827,19906]},{"content":"Replace the contents of the <ph id=\"ph1\">`CreateTestCompilation`</ph> method with the following code.","pos":[19907,19990],"source":" Replace the contents of the `CreateTestCompilation` method with the following code."},{"content":"It creates a test compilation that coincidentally matches the project described in this quickstart:","pos":[19991,20090]},{"content":"Cross your fingers and run the project.","pos":[20323,20362]},{"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>Debug<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Start Debugging<ept id=\"p2\">**</ept>.","pos":[20363,20420],"source":" In Visual Studio, choose **Debug** > **Start Debugging**."},{"content":"You should be prompted by Visual Studio that the files in your project have changed.","pos":[20421,20505]},{"content":"Click \"<bpt id=\"p1\">**</bpt>Yes to All<ept id=\"p1\">**</ept>\" to reload the modified files.","pos":[20506,20558],"source":" Click \"**Yes to All**\" to reload the modified files."},{"content":"Examine them to observe your awesomeness.","pos":[20559,20600]},{"content":"Note how much cleaner the code looks without all those explicit and redundant type specifiers.","pos":[20601,20695]},{"content":"Congratulations!","pos":[20697,20713]},{"content":"You've used the <bpt id=\"p1\">**</bpt>Compiler APIs<ept id=\"p1\">**</ept> to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.","pos":[20714,20935],"source":" You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it."},{"content":"You're now officially refactoring author!","pos":[20936,20977]}]}