{"content":"---\ntitle: Developing Libraries with Cross Platform Tools\ndescription: Developing Libraries with Cross Platform Tools\nkeywords: .NET, .NET Core\nauthor: cartermp\nms.author: mairaw\nms.date: 05/01/2017\nms.topic: article\nms.prod: .net-core\nms.technology: dotnet-cli\nms.devlang: dotnet\nms.assetid: 9f6e8679-bd7e-4317-b3f9-7255a260d9cf\n---\n\n# Developing Libraries with Cross Platform Tools\n\nThis article covers how to write libraries for .NET using cross-platform CLI tools.  The CLI provides an efficient and low-level experience that works across any supported OS.  You can still build libraries with Visual Studio, and if that is your preferred experience [refer to the Visual Studio guide](libraries-with-vs.md).\n\n## Prerequisites\n\nYou need [the .NET Core SDK and CLI](https://www.microsoft.com/net/core) installed on your machine.\n\nFor the sections of this document dealing with .NET Framework versions, you need the [.NET Framework](http://getdotnet.azurewebsites.net/) installed on a Windows machine.  \n\nAdditionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the [.NET target platforms page](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html).  Refer to this table:\n\n| .NET Framework Version | What to download |\n| ---------------------- | ----------------- |\n| 4.6.1 | .NET Framework 4.6.1 Targeting Pack |\n| 4.6 | .NET Framework 4.6 Targeting Pack |\n| 4.5.2 | .NET Framework 4.5.2 Developer Pack |\n| 4.5.1 | .NET Framework 4.5.1 Developer Pack |\n| 4.5 | Windows Software Development Kit for Windows 8 |\n| 4.0 | Windows SDK for Windows 7 and .NET Framework 4 |\n| 2.0, 3.0, and 3.5 | .NET Framework 3.5 SP1 Runtime (or Windows 8+ version) |\n\n## How to target the .NET Standard\n\nIf you're not quite familiar with the .NET Standard, refer to [the .NET Standard Library](../../standard/library.md) to learn more.\n\nIn that article, there is a table which maps .NET Standard versions to various implementations:\n\n[!INCLUDE [net-standard-table](../../includes/net-standard-table.md)]\n\nHere's what this table means for the purposes of creating a library:\n\nThe version of the .NET Platform Standard you pick will be a tradeoff between access to the newest APIs and ability to target more .NET platforms and Framework versions.  You control the range of targetable platforms and versions by picking a version of `netstandardX.X` (Where `X.X` is a version number) and adding it to your project file (`.csproj` or `.fsproj`).\n\nYou have three primary options when targeting the .NET Standard, depending on your needs.\n\n1. You can use the default version of the .NET Standard supplied by templates - `netstandard1.4` - which gives you access to most APIs on .NET Standard while still being compatible with UWP, .NET Framework 4.6.1, and the forthcoming .NET Standard 2.0.\n\n    ```xml\n    <Project Sdk=\"Microsoft.NET.Sdk\">\n        <PropertyGroup>\n            <TargetFramework>netstandard1.4</TargetFramework>\n        </PropertyGroup>\n    </Project>\n    ```\n\n2. You can use a lower or higher version of the .NET Standard by modifying the value in the `TargetFramework` node of your project file.\n    \n    .NET Standard versions are backward compatible. That means that `netstandard1.0` libraries run on `netstandard1.1` platforms and higher.  However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.  This means that `netstandard1.0` libraries cannot reference libraries targeting `netstandard1.1` or higher.  Select the Standard version that has the right mix of APIs and platform support for your needs.  We recommend `netstandard1.4` for now.\n    \n3. If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, `System.Drawing`), read the following sections and learn how to multitarget.\n\n## How to target the .NET Framework\n\n> [!NOTE]\n> These instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) to get dependencies installed.\n\nKeep in mind that some of the .NET Framework versions used here are no longer in support.  Refer to the [.NET Framework Support Lifecycle Policy FAQ](https://support.microsoft.com/gp/framework_faq/en-us) about unsupported versions.\n\nIf you want to reach the maximum number of developers and projects, use the .NET Framework 4.0 as your baseline target. To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.\n\n```\n.NET Framework 2.0   --> net20\n.NET Framework 3.0   --> net30\n.NET Framework 3.5   --> net35\n.NET Framework 4.0   --> net40\n.NET Framework 4.5   --> net45\n.NET Framework 4.5.1 --> net451\n.NET Framework 4.5.2 --> net452\n.NET Framework 4.6   --> net46\n.NET Framework 4.6.1 --> net461\n.NET Framework 4.6.2 --> net462\n.NET Framework 4.7 --> net47\n```\n\nYou then insert this TFM into the `TargetFramework` section of your project file.  For example, here's how you would write a library which targets the .NET Framework 4.0:\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n    <PropertyGroup>\n        <TargetFramework>net40</TargetFramework>\n    </PropertyGroup>\n</Project>\n```\n\nAnd that's it!  Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.\n\n## How to Multitarget\n\n> [!NOTE]\n> The following instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) section to learn which dependencies you need to install and where to download them from.\n\nYou may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core. In this scenario, if you want to use newer APIs and language constructs for the newer targets, use `#if` directives in your code. You also might need to add different packages and dependencies for each platform you're targeting to include the different APIs needed for each case.\n\nFor example, let's say you have a library that performs networking operations over HTTP. For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the `HttpClient` class from the `System.Net.Http` namespace. However, earlier versions of the .NET Framework don't have the `HttpClient` class, so you could use the `WebClient` class from the `System.Net` namespace for those instead.\n\nYour project file could look like this:\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <TargetFrameworks>netstandard1.4;net40;net45</TargetFrameworks>\n  </PropertyGroup>\n\n  <!-- Need to conditionally bring in references for the .NET Framework 4.0 target -->\n  <ItemGroup Condition=\"'$(TargetFramework)' == 'net40'\">\n    <Reference Include=\"System.Net\" />\n  </ItemGroup>\n\n  <!-- Need to conditionally bring in references for the .NET Framework 4.5 target -->\n  <ItemGroup Condition=\"'$(TargetFramework)' == 'net45'\">\n    <Reference Include=\"System.Net.Http\" />\n    <Reference Include=\"System.Threading.Tasks\" />\n  </ItemGroup>\n</Project>\n```\n\nYou'll notice three major changes here:\n\n1. The `TargetFramework` node has been replaced by `TargetFrameworks`, and three TFMs are expressed inside.\n2. There is an `<ItemGroup>` node for the `net40 ` target pulling in one .NET Framework references.\n3. There is an `<ItemGroup>` node for the `net45` target pulling in two .NET Framework references.\n\nThe build system is aware of the following preprocessor symbols used in `#if` directives:\n\n```\n.NET Framework 2.0   --> NET20\n.NET Framework 3.5   --> NET35\n.NET Framework 4.0   --> NET40\n.NET Framework 4.5   --> NET45\n.NET Framework 4.5.1 --> NET451\n.NET Framework 4.5.2 --> NET452\n.NET Framework 4.6   --> NET46\n.NET Framework 4.6.1 --> NET461\n.NET Framework 4.6.2 --> NET462\n.NET Standard 1.0    --> NETSTANDARD1_0\n.NET Standard 1.1    --> NETSTANDARD1_1\n.NET Standard 1.2    --> NETSTANDARD1_2\n.NET Standard 1.3    --> NETSTANDARD1_3\n.NET Standard 1.4    --> NETSTANDARD1_4\n.NET Standard 1.5    --> NETSTANDARD1_5\n.NET Standard 1.6    --> NETSTANDARD1_6\n```\n\nHere is an example making use of conditional compilation per-target:\n\n```csharp\nusing System;\nusing System.Text.RegularExpressions;\n#if NET40\n// This only compiles for the .NET Framework 4 targets\nusing System.Net;\n#else\n // This compiles for all other targets\nusing System.Net.Http;\nusing System.Threading.Tasks;\n#endif\n\nnamespace MultitargetLib\n{\n    public class Library\n    {\n#if NET40\n         private readonly WebClient _client = new WebClient();\n         private readonly object _locker = new object();\n#else\n        private readonly HttpClient _client = new HttpClient();\n#endif\n\n#if NET40\n        // .NET Framework 4.0 does not have async/await\n        public string GetDotNetCount()\n        {\n            string url = \"http://www.dotnetfoundation.org/\";\n\n            var uri = new Uri(url);\n\n            string result = \"\";\n\n            // Lock here to provide thread-safety.\n            lock(_locker)\n            {\n                result = _client.DownloadString(uri);\n            }\n\n            int dotNetCount = Regex.Matches(result, \".NET\").Count;\n\n            return $\"Dotnet Foundation mentions .NET {dotNetCount} times!\";\n        }\n#else\n         // .NET 4.5+ can use async/await!\n         public async Task<string> GetDotNetCountAsync()\n         {\n             string url = \"http://www.dotnetfoundation.org/\";\n\n             // HttpClient is thread-safe, so no need to explicitly lock here\n             var result = await _client.GetStringAsync(url);\n\n             int dotNetCount = Regex.Matches(result, \".NET\").Count;\n\n             return $\"dotnetfoundation.org mentions .NET {dotNetCount} times in its HTML!\";\n         }\n #endif\n    }\n}\n```\n\nIf you build this project with `dotnet build`, you'll notice three directories under the `bin/` folder:\n\n```\nnet40/\nnet45/\nnetstandard1.4/\n```\n\nEach of these contain the `.dll` files for each target.\n\n## How to test libraries on .NET Core\n\nIt's important to be able to test across platforms.  You can use either [xUnit](http://xunit.github.io/) or MSTest out of the box.  Both either are perfectly suitable for unit testing your library on .NET Core.  How you set up your solution with test projects will depend on the [structure of your solution](#structuring-a-solution).  The following example assumes that test and source directories live in the same top-level directory.\n\n> [!INFO] This uses some [.NET CLI commands](../tools/index.md).  See [dotnet new](../tools/dotnet-new.md) and [dotnet sln](../tools/dotnet-sln.md) for more information.\n\n1. Set up your solution.  You can do so with the following commands:\n\n```bash\nmkdir SolutionWithSrcAndTest\ncd SolutionWithSrcAndTest\ndotnet new sln\ndotnet new classlib -o MyProject\ndotnet new xunit -o MyProject.Test\ndotnet sln add MyProject/MyProject.csproj\ndotnet sln add MyProject.Test/MyProject.Test.csproj\n```\n\nThis will create projects and link them together in a solution.  Your directory for `SolutionWithSrcAndTest` should look like this:\n\n```    \n/SolutionWithSrcAndTest\n|__SolutionWithSrcAndTest.sln\n|__MyProject/\n|__MyProject.Test/\n```\n\n2. Navigate to the test project's directory and add a reference to `MyProject.Test` from `MyProject`.\n\n```bash\ncd MyProject.Test\ndotnet add reference ../MyProject/MyProject.csproj\n```\n\n3. Restore packages and build projects:\n\n```bash\ndotnet restore\ndotnet build\n```\n\n4. Verify that xUnit runs by executing the `dotnet test` command.  If you chose to use MSTest, then the MSTest console runner should run instead.\n    \nAnd that's it!  You can now test your library across all platforms using command line tools.  To continue testing now that you have everything set up, testing your library is very simple:\n\n1. Make changes to your library.\n2. Run tests from the command line, in your test directory, with `dotnet test` command.\n\nYour code will be automatically rebuilt when you invoke `dotnet test` command.\n\n## How to use multiple projects\n\nA common need for larger libraries is to place functionality in different projects.\n\nImagine you wished to build a library which could be consumed in idiomatic C# and F#.  That would mean that consumers of your library consume them in ways which are natural to C# or F#.  For example, in C# you might consume the library like this:\n\n```csharp\nusing AwesomeLibrary.CSharp;\n\n...\npublic Task DoThings(Data data)\n{\n    var convertResult = await AwesomeLibrary.ConvertAsync(data);\n    var result = AwesomeLibrary.Process(convertResult);\n    // do something with result\n}\n```  \n\nIn F#, it might look like this:\n\n```fsharp\nopen AwesomeLibrary.FSharp\n\n...\n\nlet doWork data = async {\n    let! result = AwesomeLibrary.AsyncConvert data // Uses an F# async function rather than C# async method\n    // do something with result\n}\n```\n\nConsumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.  A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.  The rest of the section will use the following names:\n\n* **AwesomeLibrary.Core** - A core project which contains all logic for the library\n* **AwesomeLibrary.CSharp** - A project with public APIs intended for consumption in C#\n* **AwesomeLibrary.FSharp** - A project with public APIs intended for consumption in F#\n\nYou can run the following commands in your terminal to produce the same structure as this guide:\n\n```console\ndotnet new sln\nmkdir AwesomeLibrary.Core && cd AwesomeLibrary.Core && dotnet new classlib\ncd ..\nmkdir AwesomeLibrary.CSharp && cd AwesomeLibrary.CSharp && dotnet new classlib\ncd ..\nmkdir AwesomeLibrary.FSharp && cd AwesomeLibrary.FSharp && dotnet new classlib -lang F#\ncd ..\ndotnet sln add AwesomeLibrary.Core/AwesomeLibrary.Core/csproj\ndotnet sln add AwesomeLibrary.CSharp/AwesomeLibrary.CSharp/csproj\ndotnet sln add AwesomeLibrary.FSharp/AwesomeLibrary.FSharp/csproj\n```\n\nThis will add the three projects above and a solution file which links them together.  Creating the solution file and linking projects will allow you to restore and build projects from a top-level.\n\n### Project-to-project referencing\n\nThe best way to reference a project is to use the .NET CLI to add a project reference.  From the **AwesomeLibrary.CSharp** and **AwesomeLibrary.FSharp** project directories, you can run the following command:\n\n```console\n$ dotnet add reference ../AwesomeLibrary.Core.csproj\n```\n\nThe project files for both **AwesomeLibrary.CSharp** and **AwesomeLibrary.FSharp** will now reference **AwesomeLibrary.Core** as a `ProjectReference` target.  You can verify this by inspecting the project files and seeing the following in them:\n\n```xml\n<ItemGroup>\n    <ProjectReference Include=\"..\\AwesomeLibrary.Core\\AwesomeLibrary.Core.csproj\" />\n</ItemGroup>\n```\n\nYou can add this section to each project file manually if you prefer not to use the .NET CLI.\n\n### Structuring a Solution\n\nAnother important aspect of multi-project solutions is establishing a good overall project structure. You can organize code however you like, and as long as you link each project to your solution file with `dotnet sln add`, you will be able to run `dotnet restore` and `dotnet build` at the solution level.","nodes":[{"pos":[11,57],"content":"Developing Libraries with Cross Platform Tools","needQuote":true,"needEscape":true,"nodes":[{"content":"Developing Libraries with Cross Platform Tools","pos":[0,46]}]},{"pos":[71,117],"content":"Developing Libraries with Cross Platform Tools","needQuote":true,"needEscape":true,"nodes":[{"content":"Developing Libraries with Cross Platform Tools","pos":[0,46]}]},{"pos":[128,143],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[337,383],"content":"Developing Libraries with Cross Platform Tools","linkify":"Developing Libraries with Cross Platform Tools","nodes":[{"content":"Developing Libraries with Cross Platform Tools","pos":[0,46]}]},{"content":"This article covers how to write libraries for .NET using cross-platform CLI tools.","pos":[385,468]},{"content":"The CLI provides an efficient and low-level experience that works across any supported OS.","pos":[470,560]},{"content":"You can still build libraries with Visual Studio, and if that is your preferred experience <bpt id=\"p1\">[</bpt>refer to the Visual Studio guide<ept id=\"p1\">](libraries-with-vs.md)</ept>.","pos":[562,710],"source":"  You can still build libraries with Visual Studio, and if that is your preferred experience [refer to the Visual Studio guide](libraries-with-vs.md)."},{"pos":[715,728],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"pos":[730,829],"content":"You need <bpt id=\"p1\">[</bpt>the .NET Core SDK and CLI<ept id=\"p1\">](https://www.microsoft.com/net/core)</ept> installed on your machine.","source":"You need [the .NET Core SDK and CLI](https://www.microsoft.com/net/core) installed on your machine."},{"pos":[831,1001],"content":"For the sections of this document dealing with .NET Framework versions, you need the <bpt id=\"p1\">[</bpt>.NET Framework<ept id=\"p1\">](http://getdotnet.azurewebsites.net/)</ept> installed on a Windows machine.","source":"For the sections of this document dealing with .NET Framework versions, you need the [.NET Framework](http://getdotnet.azurewebsites.net/) installed on a Windows machine."},{"content":"Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the <bpt id=\"p1\">[</bpt>.NET target platforms page<ept id=\"p1\">](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)</ept>.","pos":[1005,1250],"source":"Additionally, if you wish to support older .NET Framework targets, you need to install targeting/developer packs for older framework versions from the [.NET target platforms page](http://getdotnet.azurewebsites.net/target-dotnet-platforms.html)."},{"content":"Refer to this table:","pos":[1252,1272]},{"content":".NET Framework Version","pos":[1276,1298]},{"content":"What to download","pos":[1301,1317]},{"content":"4.6.1","pos":[1369,1374]},{"content":".NET Framework 4.6.1 Targeting Pack","pos":[1377,1412]},{"content":"4.6","pos":[1417,1420]},{"content":".NET Framework 4.6 Targeting Pack","pos":[1423,1456]},{"content":"4.5.2","pos":[1461,1466]},{"content":".NET Framework 4.5.2 Developer Pack","pos":[1469,1504]},{"content":"4.5.1","pos":[1509,1514]},{"content":".NET Framework 4.5.1 Developer Pack","pos":[1517,1552]},{"content":"4.5","pos":[1557,1560]},{"content":"Windows Software Development Kit for Windows 8","pos":[1563,1609]},{"content":"4.0","pos":[1614,1617]},{"content":"Windows SDK for Windows 7 and .NET Framework 4","pos":[1620,1666]},{"content":"2.0, 3.0, and 3.5","pos":[1671,1688]},{"content":".NET Framework 3.5 SP1 Runtime (or Windows 8+ version)","pos":[1691,1745]},{"pos":[1752,1783],"content":"How to target the .NET Standard","linkify":"How to target the .NET Standard","nodes":[{"content":"How to target the .NET Standard","pos":[0,31]}]},{"pos":[1785,1916],"content":"If you're not quite familiar with the .NET Standard, refer to <bpt id=\"p1\">[</bpt>the .NET Standard Library<ept id=\"p1\">](../../standard/library.md)</ept> to learn more.","source":"If you're not quite familiar with the .NET Standard, refer to [the .NET Standard Library](../../standard/library.md) to learn more."},{"content":"In that article, there is a table which maps .NET Standard versions to various implementations:","pos":[1918,2013]},{"content":"Here's what this table means for the purposes of creating a library:","pos":[2086,2154]},{"content":"The version of the .NET Platform Standard you pick will be a tradeoff between access to the newest APIs and ability to target more .NET platforms and Framework versions.","pos":[2156,2325]},{"content":"You control the range of targetable platforms and versions by picking a version of <ph id=\"ph1\">`netstandardX.X`</ph> (Where <ph id=\"ph2\">`X.X`</ph> is a version number) and adding it to your project file (<ph id=\"ph3\">`.csproj`</ph> or <ph id=\"ph4\">`.fsproj`</ph>).","pos":[2327,2521],"source":"  You control the range of targetable platforms and versions by picking a version of `netstandardX.X` (Where `X.X` is a version number) and adding it to your project file (`.csproj` or `.fsproj`)."},{"content":"You have three primary options when targeting the .NET Standard, depending on your needs.","pos":[2523,2612]},{"pos":[2617,2865],"content":"You can use the default version of the .NET Standard supplied by templates - <ph id=\"ph1\">`netstandard1.4`</ph> - which gives you access to most APIs on .NET Standard while still being compatible with UWP, .NET Framework 4.6.1, and the forthcoming .NET Standard 2.0.","source":"You can use the default version of the .NET Standard supplied by templates - `netstandard1.4` - which gives you access to most APIs on .NET Standard while still being compatible with UWP, .NET Framework 4.6.1, and the forthcoming .NET Standard 2.0."},{"pos":[3054,3187],"content":"You can use a lower or higher version of the .NET Standard by modifying the value in the <ph id=\"ph1\">`TargetFramework`</ph> node of your project file.","source":"You can use a lower or higher version of the .NET Standard by modifying the value in the `TargetFramework` node of your project file."},{"content":".NET Standard versions are backward compatible.","pos":[3197,3244]},{"content":"That means that <ph id=\"ph1\">`netstandard1.0`</ph> libraries run on <ph id=\"ph2\">`netstandard1.1`</ph> platforms and higher.","pos":[3245,3333],"source":" That means that `netstandard1.0` libraries run on `netstandard1.1` platforms and higher."},{"content":"However, there is no forward compatibility - lower .NET Standard platforms cannot reference higher ones.","pos":[3335,3439]},{"content":"This means that <ph id=\"ph1\">`netstandard1.0`</ph> libraries cannot reference libraries targeting <ph id=\"ph2\">`netstandard1.1`</ph> or higher.","pos":[3441,3548],"source":"  This means that `netstandard1.0` libraries cannot reference libraries targeting `netstandard1.1` or higher."},{"content":"Select the Standard version that has the right mix of APIs and platform support for your needs.","pos":[3550,3645]},{"content":"We recommend <ph id=\"ph1\">`netstandard1.4`</ph> for now.","pos":[3647,3685],"source":"  We recommend `netstandard1.4` for now."},{"pos":[3694,3935],"content":"If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, <ph id=\"ph1\">`System.Drawing`</ph>), read the following sections and learn how to multitarget.","source":"If you want to target the .NET Framework versions 4.0 or below, or you wish to use an API available in the .NET Framework but not in the .NET Standard (for example, `System.Drawing`), read the following sections and learn how to multitarget."},{"pos":[3940,3972],"content":"How to target the .NET Framework","linkify":"How to target the .NET Framework","nodes":[{"content":"How to target the .NET Framework","pos":[0,32]}]},{"pos":[3976,4143],"content":"[!NOTE]\nThese instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) to get dependencies installed.","leadings":["","> "],"nodes":[{"content":"These instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) to get dependencies installed.","pos":[8,165],"nodes":[{"content":"These instructions assume you have the .NET Framework installed on your machine.","pos":[0,80]},{"content":"Refer to the <bpt id=\"p1\">[</bpt>Prerequisites<ept id=\"p1\">](#prerequisites)</ept> to get dependencies installed.","pos":[82,157],"source":"  Refer to the [Prerequisites](#prerequisites) to get dependencies installed."}]}]},{"content":"Keep in mind that some of the .NET Framework versions used here are no longer in support.","pos":[4145,4234]},{"content":"Refer to the <bpt id=\"p1\">[</bpt>.NET Framework Support Lifecycle Policy FAQ<ept id=\"p1\">](https://support.microsoft.com/gp/framework_faq/en-us)</ept> about unsupported versions.","pos":[4236,4376],"source":"  Refer to the [.NET Framework Support Lifecycle Policy FAQ](https://support.microsoft.com/gp/framework_faq/en-us) about unsupported versions."},{"content":"If you want to reach the maximum number of developers and projects, use the .NET Framework 4.0 as your baseline target.","pos":[4378,4497]},{"content":"To target the .NET Framework, you will need to begin by using the correct Target Framework Moniker (TFM) that corresponds to the .NET Framework version you wish to support.","pos":[4498,4670]},{"content":"You then insert this TFM into the <ph id=\"ph1\">`TargetFramework`</ph> section of your project file.","pos":[5024,5105],"source":"You then insert this TFM into the `TargetFramework` section of your project file."},{"content":"For example, here's how you would write a library which targets the .NET Framework 4.0:","pos":[5107,5194]},{"content":"And that's it!","pos":[5343,5357]},{"content":"Although this compiled only for the .NET Framework 4, you can use the library on newer versions of the .NET Framework.","pos":[5359,5477]},{"pos":[5482,5500],"content":"How to Multitarget","linkify":"How to Multitarget","nodes":[{"content":"How to Multitarget","pos":[0,18]}]},{"pos":[5504,5737],"content":"[!NOTE]\nThe following instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) section to learn which dependencies you need to install and where to download them from.","leadings":["","> "],"nodes":[{"content":"The following instructions assume you have the .NET Framework installed on your machine.  Refer to the [Prerequisites](#prerequisites) section to learn which dependencies you need to install and where to download them from.","pos":[8,231],"nodes":[{"content":"The following instructions assume you have the .NET Framework installed on your machine.","pos":[0,88]},{"content":"Refer to the <bpt id=\"p1\">[</bpt>Prerequisites<ept id=\"p1\">](#prerequisites)</ept> section to learn which dependencies you need to install and where to download them from.","pos":[90,223],"source":"  Refer to the [Prerequisites](#prerequisites) section to learn which dependencies you need to install and where to download them from."}]}]},{"content":"You may need to target older versions of the .NET Framework when your project supports both the .NET Framework and .NET Core.","pos":[5739,5864]},{"content":"In this scenario, if you want to use newer APIs and language constructs for the newer targets, use <ph id=\"ph1\">`#if`</ph> directives in your code.","pos":[5865,5994],"source":" In this scenario, if you want to use newer APIs and language constructs for the newer targets, use `#if` directives in your code."},{"content":"You also might need to add different packages and dependencies for each platform you're targeting to include the different APIs needed for each case.","pos":[5995,6144]},{"content":"For example, let's say you have a library that performs networking operations over HTTP.","pos":[6146,6234]},{"content":"For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the <ph id=\"ph1\">`HttpClient`</ph> class from the <ph id=\"ph2\">`System.Net.Http`</ph> namespace.","pos":[6235,6372],"source":" For .NET Standard and the .NET Framework versions 4.5 or higher, you can use the `HttpClient` class from the `System.Net.Http` namespace."},{"content":"However, earlier versions of the .NET Framework don't have the <ph id=\"ph1\">`HttpClient`</ph> class, so you could use the <ph id=\"ph2\">`WebClient`</ph> class from the <ph id=\"ph3\">`System.Net`</ph> namespace for those instead.","pos":[6373,6545],"source":" However, earlier versions of the .NET Framework don't have the `HttpClient` class, so you could use the `WebClient` class from the `System.Net` namespace for those instead."},{"content":"Your project file could look like this:","pos":[6547,6586]},{"content":"You'll notice three major changes here:","pos":[7206,7245]},{"pos":[7250,7354],"content":"The <ph id=\"ph1\">`TargetFramework`</ph> node has been replaced by <ph id=\"ph2\">`TargetFrameworks`</ph>, and three TFMs are expressed inside.","source":"The `TargetFramework` node has been replaced by `TargetFrameworks`, and three TFMs are expressed inside."},{"pos":[7358,7454],"content":"There is an <ph id=\"ph1\">`&lt;ItemGroup&gt;`</ph> node for the <ph id=\"ph2\">`net40 `</ph> target pulling in one .NET Framework references.","source":"There is an `<ItemGroup>` node for the `net40 ` target pulling in one .NET Framework references."},{"pos":[7458,7553],"content":"There is an <ph id=\"ph1\">`&lt;ItemGroup&gt;`</ph> node for the <ph id=\"ph2\">`net45`</ph> target pulling in two .NET Framework references.","source":"There is an `<ItemGroup>` node for the `net45` target pulling in two .NET Framework references."},{"pos":[7555,7644],"content":"The build system is aware of the following preprocessor symbols used in <ph id=\"ph1\">`#if`</ph> directives:","source":"The build system is aware of the following preprocessor symbols used in `#if` directives:"},{"content":"Here is an example making use of conditional compilation per-target:","pos":[8218,8286]},{"pos":[9880,9983],"content":"If you build this project with <ph id=\"ph1\">`dotnet build`</ph>, you'll notice three directories under the <ph id=\"ph2\">`bin/`</ph> folder:","source":"If you build this project with `dotnet build`, you'll notice three directories under the `bin/` folder:"},{"pos":[10024,10079],"content":"Each of these contain the <ph id=\"ph1\">`.dll`</ph> files for each target.","source":"Each of these contain the `.dll` files for each target."},{"pos":[10084,10118],"content":"How to test libraries on .NET Core","linkify":"How to test libraries on .NET Core","nodes":[{"content":"How to test libraries on .NET Core","pos":[0,34]}]},{"content":"It's important to be able to test across platforms.","pos":[10120,10171]},{"content":"You can use either <bpt id=\"p1\">[</bpt>xUnit<ept id=\"p1\">](http://xunit.github.io/)</ept> or MSTest out of the box.","pos":[10173,10250],"source":"  You can use either [xUnit](http://xunit.github.io/) or MSTest out of the box."},{"content":"Both either are perfectly suitable for unit testing your library on .NET Core.","pos":[10252,10330]},{"content":"How you set up your solution with test projects will depend on the <bpt id=\"p1\">[</bpt>structure of your solution<ept id=\"p1\">](#structuring-a-solution)</ept>.","pos":[10332,10453],"source":"  How you set up your solution with test projects will depend on the [structure of your solution](#structuring-a-solution)."},{"content":"The following example assumes that test and source directories live in the same top-level directory.","pos":[10455,10555]},{"content":"[!INFO] This uses some <bpt id=\"p1\">[</bpt>.NET CLI commands<ept id=\"p1\">](../tools/index.md)</ept>.","pos":[10559,10621],"source":"[!INFO] This uses some [.NET CLI commands](../tools/index.md)."},{"content":"See <bpt id=\"p1\">[</bpt>dotnet new<ept id=\"p1\">](../tools/dotnet-new.md)</ept> and <bpt id=\"p2\">[</bpt>dotnet sln<ept id=\"p2\">](../tools/dotnet-sln.md)</ept> for more information.","pos":[10623,10726],"source":"  See [dotnet new](../tools/dotnet-new.md) and [dotnet sln](../tools/dotnet-sln.md) for more information."},{"content":"Set up your solution.","pos":[10731,10752]},{"content":"You can do so with the following commands:","pos":[10754,10796]},{"content":"This will create projects and link them together in a solution.","pos":[11043,11106]},{"content":"Your directory for <ph id=\"ph1\">`SolutionWithSrcAndTest`</ph> should look like this:","pos":[11108,11174],"source":"  Your directory for `SolutionWithSrcAndTest` should look like this:"},{"pos":[11279,11377],"content":"Navigate to the test project's directory and add a reference to <ph id=\"ph1\">`MyProject.Test`</ph> from <ph id=\"ph2\">`MyProject`</ph>.","source":"Navigate to the test project's directory and add a reference to `MyProject.Test` from `MyProject`."},{"content":"Restore packages and build projects:","pos":[11464,11500]},{"content":"Verify that xUnit runs by executing the <ph id=\"ph1\">`dotnet test`</ph> command.","pos":[11546,11608],"source":"Verify that xUnit runs by executing the `dotnet test` command."},{"content":"If you chose to use MSTest, then the MSTest console runner should run instead.","pos":[11610,11688]},{"content":"And that's it!","pos":[11694,11708]},{"content":"You can now test your library across all platforms using command line tools.","pos":[11710,11786]},{"content":"To continue testing now that you have everything set up, testing your library is very simple:","pos":[11788,11881]},{"content":"Make changes to your library.","pos":[11886,11915]},{"pos":[11919,12003],"content":"Run tests from the command line, in your test directory, with <ph id=\"ph1\">`dotnet test`</ph> command.","source":"Run tests from the command line, in your test directory, with `dotnet test` command."},{"pos":[12005,12083],"content":"Your code will be automatically rebuilt when you invoke <ph id=\"ph1\">`dotnet test`</ph> command.","source":"Your code will be automatically rebuilt when you invoke `dotnet test` command."},{"pos":[12088,12116],"content":"How to use multiple projects","linkify":"How to use multiple projects","nodes":[{"content":"How to use multiple projects","pos":[0,28]}]},{"content":"A common need for larger libraries is to place functionality in different projects.","pos":[12118,12201]},{"content":"Imagine you wished to build a library which could be consumed in idiomatic C# and F#.","pos":[12203,12288]},{"content":"That would mean that consumers of your library consume them in ways which are natural to C# or F#.","pos":[12290,12388]},{"content":"For example, in C# you might consume the library like this:","pos":[12390,12449]},{"content":"In F#, it might look like this:","pos":[12691,12722]},{"content":"Consumption scenarios like this mean that the APIs being accessed have to have a different structure for C# and F#.","pos":[12940,13055]},{"content":"A common approach to accomplishing this is to factor all of the logic of a library into a core project, with C# and F# projects defining the API layers that call into that core project.","pos":[13057,13242]},{"content":"The rest of the section will use the following names:","pos":[13244,13297]},{"pos":[13301,13382],"content":"<bpt id=\"p1\">**</bpt>AwesomeLibrary.Core<ept id=\"p1\">**</ept> - A core project which contains all logic for the library","source":"**AwesomeLibrary.Core** - A core project which contains all logic for the library"},{"pos":[13385,13470],"content":"<bpt id=\"p1\">**</bpt>AwesomeLibrary.CSharp<ept id=\"p1\">**</ept> - A project with public APIs intended for consumption in C#","source":"**AwesomeLibrary.CSharp** - A project with public APIs intended for consumption in C#"},{"pos":[13473,13558],"content":"<bpt id=\"p1\">**</bpt>AwesomeLibrary.FSharp<ept id=\"p1\">**</ept> - A project with public APIs intended for consumption in F#","source":"**AwesomeLibrary.FSharp** - A project with public APIs intended for consumption in F#"},{"content":"You can run the following commands in your terminal to produce the same structure as this guide:","pos":[13560,13656]},{"content":"This will add the three projects above and a solution file which links them together.","pos":[14143,14228]},{"content":"Creating the solution file and linking projects will allow you to restore and build projects from a top-level.","pos":[14230,14340]},{"pos":[14346,14376],"content":"Project-to-project referencing","linkify":"Project-to-project referencing","nodes":[{"content":"Project-to-project referencing","pos":[0,30]}]},{"content":"The best way to reference a project is to use the .NET CLI to add a project reference.","pos":[14378,14464]},{"content":"From the <bpt id=\"p1\">**</bpt>AwesomeLibrary.CSharp<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>AwesomeLibrary.FSharp<ept id=\"p2\">**</ept> project directories, you can run the following command:","pos":[14466,14586],"source":"  From the **AwesomeLibrary.CSharp** and **AwesomeLibrary.FSharp** project directories, you can run the following command:"},{"content":"The project files for both <bpt id=\"p1\">**</bpt>AwesomeLibrary.CSharp<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>AwesomeLibrary.FSharp<ept id=\"p2\">**</ept> will now reference <bpt id=\"p3\">**</bpt>AwesomeLibrary.Core<ept id=\"p3\">**</ept> as a <ph id=\"ph1\">`ProjectReference`</ph> target.","pos":[14657,14814],"source":"The project files for both **AwesomeLibrary.CSharp** and **AwesomeLibrary.FSharp** will now reference **AwesomeLibrary.Core** as a `ProjectReference` target."},{"content":"You can verify this by inspecting the project files and seeing the following in them:","pos":[14816,14901]},{"content":"You can add this section to each project file manually if you prefer not to use the .NET CLI.","pos":[15025,15118]},{"pos":[15124,15146],"content":"Structuring a Solution","linkify":"Structuring a Solution","nodes":[{"content":"Structuring a Solution","pos":[0,22]}]},{"content":"Another important aspect of multi-project solutions is establishing a good overall project structure.","pos":[15148,15249]},{"content":"You can organize code however you like, and as long as you link each project to your solution file with <ph id=\"ph1\">`dotnet sln add`</ph>, you will be able to run <ph id=\"ph2\">`dotnet restore`</ph> and <ph id=\"ph3\">`dotnet build`</ph> at the solution level.","pos":[15250,15454],"source":" You can organize code however you like, and as long as you link each project to your solution file with `dotnet sln add`, you will be able to run `dotnet restore` and `dotnet build` at the solution level."}]}