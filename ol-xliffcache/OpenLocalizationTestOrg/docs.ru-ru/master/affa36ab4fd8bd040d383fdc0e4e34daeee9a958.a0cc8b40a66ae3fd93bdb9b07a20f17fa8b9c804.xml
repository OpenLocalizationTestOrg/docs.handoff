{"content":"---\ntitle: \"Defining Custom Types for Use with .NET Framework XAML Services | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"defining custom types [XAML Services]\"\nms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4\ncaps.latest.revision: 11\nauthor: \"wadepickett\"\nms.author: \"wpickett\"\nmanager: \"wpickett\"\n---\n# Defining Custom Types for Use with .NET Framework XAML Services\nWhen you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow. If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system. This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.  \n  \n## Constructor Patterns and Type Definitions for XAML  \n To be instantiated as an object element in XAML, a custom class must meet the following requirements:  \n  \n-   The custom class must be public and must expose a default (parameterless) public constructor. (See following section for notes regarding structures.)  \n  \n-   The custom class must not be a nested class. The extra \"dot\" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.  \n  \n If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.  \n  \n You can still provide object values for types that do not meet these criteria, if you enable a value converter. For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  \n  \n### Structures  \n Structures are always able to be constructed in XAML, by CLR definition. This is because a CLR compiler implicitly creates a default constructor for a structure. This constructor initializes all property values to their defaults.  \n  \n In some cases, the default construction behavior for a structure is not desirable. This might be because the structure is intended to fill values and function conceptually as a union. As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable. An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>. Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values. The structure should also expose similar behavior for code construction through a non-default constructor.  \n  \n### Interfaces  \n Interfaces can be used as underlying types of members. The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface. There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.  \n  \n### Factory Methods  \n Factory methods are a XAML 2009 feature. They modify the XAML principle that objects must have default constructors. Factory methods are not documented in this topic. See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).  \n  \n## Enumerations  \n Enumerations have XAML native type conversion behavior. Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.  \n  \n XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied. For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md). ([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)  \n  \n## Member Definitions  \n Types can define members for XAML usage. It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable. This is possible because of CLR inheritance. So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.  \n  \n### Properties  \n If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.  \n  \n Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>. For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  \n  \n In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.  \n  \n If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.  \n  \n### Events  \n If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`. Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.  \n  \n### Methods  \n Inline code for methods is not a default XAML capability. In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns. [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.  \n  \n### Fields  \n CLR design guidelines discourage nonstatic fields. For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.  \n  \n## Attachable Members  \n Attachable members are exposed to XAML through an accessor method pattern on a defining type. The defining type itself does not need to be XAML-usable as an object. In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation. For the following sections, the placeholder *PropertyName* represents the name of your attachable member. That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).  \n  \n Be cautious of name collisions between these patterns and other methods of a type. If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.  \n  \n#### The GetPropertyName Accessor  \n The signature for the `Get`*PropertyName* accessor must be:  \n  \n `public static object Get` *PropertyName* `(object`  `target` `)`  \n  \n-   The `target` object can be specified as a more specific type in your implementation. You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error. The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.  \n  \n-   The return value can be specified as a more specific type in your implementation.  \n  \n To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor. Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.  \n  \n#### The SetPropertyName Accessor  \n The signature for the Set*PropertyName* accessor must be:  \n  \n `public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`  \n  \n-   The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.  \n  \n-   The `value` object can be specified as a more specific type in your implementation.  \n  \n Remember that the value for this method is the input coming from the XAML usage, typically in attribute form. From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.  \n  \n### Attachable Member Stores  \n The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly. To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values. The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list. .NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>. <xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors. The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.  \n  \n## XAML-Related CLR Attributes  \n Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services. This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.  \n  \n For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).  \n  \n## Usage  \n Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type. This procedure is not documented in this topic.  \n  \n## Access Level  \n XAML provides a means to load and instantiate types that have an `internal` access level. This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.  \n  \n An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level. Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.  \n  \n For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.  \n  \n For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API. Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.  \n  \n### WPF Implementation  \n WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source. For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=fullName> as a mechanism for passing the access level information.  \n  \n In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML. Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local=\"clr-namespace:WPFApplication1\"`.  If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly. If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.  \n  \n## See Also  \n [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)   \n [XAML Services](../../../docs/framework/xaml-services/index.md)","nodes":[{"pos":[12,92],"content":"Defining Custom Types for Use with .NET Framework XAML Services | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Defining Custom Types for Use with .NET Framework XAML Services | Microsoft Docs","pos":[0,80]}]},{"pos":[466,529],"content":"Defining Custom Types for Use with .NET Framework XAML Services","linkify":"Defining Custom Types for Use with .NET Framework XAML Services","nodes":[{"content":"Defining Custom Types for Use with .NET Framework XAML Services","pos":[0,63]}]},{"content":"When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.","pos":[530,709]},{"content":"If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.","pos":[710,947]},{"content":"This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.","pos":[948,1066]},{"pos":[1075,1125],"content":"Constructor Patterns and Type Definitions for XAML","linkify":"Constructor Patterns and Type Definitions for XAML","nodes":[{"content":"Constructor Patterns and Type Definitions for XAML","pos":[0,50]}]},{"content":"To be instantiated as an object element in XAML, a custom class must meet the following requirements:","pos":[1129,1230]},{"content":"The custom class must be public and must expose a default (parameterless) public constructor.","pos":[1240,1333]},{"content":"(See following section for notes regarding structures.)","pos":[1334,1389]},{"content":"The custom class must not be a nested class.","pos":[1399,1443]},{"content":"The extra \"dot\" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.","pos":[1444,1596]},{"content":"If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.","pos":[1603,1776]},{"content":"You can still provide object values for types that do not meet these criteria, if you enable a value converter.","pos":[1783,1894]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Type Converters and Markup Extensions for XAML<ept id=\"p1\">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept>.","pos":[1895,2059],"source":" For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)."},{"pos":[2069,2079],"content":"Structures","linkify":"Structures","nodes":[{"content":"Structures","pos":[0,10]}]},{"content":"Structures are always able to be constructed in XAML, by CLR definition.","pos":[2083,2155]},{"content":"This is because a CLR compiler implicitly creates a default constructor for a structure.","pos":[2156,2244]},{"content":"This constructor initializes all property values to their defaults.","pos":[2245,2312]},{"content":"In some cases, the default construction behavior for a structure is not desirable.","pos":[2319,2401]},{"content":"This might be because the structure is intended to fill values and function conceptually as a union.","pos":[2402,2502]},{"content":"As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.","pos":[2503,2634]},{"content":"An example of such a structure in the WPF vocabulary is <ph id=\"ph1\">&lt;xref:System.Windows.GridLength&gt;</ph>.","pos":[2635,2724],"source":" An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>."},{"content":"Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.","pos":[2725,2933]},{"content":"The structure should also expose similar behavior for code construction through a non-default constructor.","pos":[2934,3040]},{"pos":[3050,3060],"content":"Interfaces","linkify":"Interfaces","nodes":[{"content":"Interfaces","pos":[0,10]}]},{"content":"Interfaces can be used as underlying types of members.","pos":[3064,3118]},{"content":"The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.","pos":[3119,3258]},{"content":"There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.","pos":[3259,3415]},{"pos":[3425,3440],"content":"Factory Methods","linkify":"Factory Methods","nodes":[{"content":"Factory Methods","pos":[0,15]}]},{"content":"Factory methods are a XAML 2009 feature.","pos":[3444,3484]},{"content":"They modify the XAML principle that objects must have default constructors.","pos":[3485,3560]},{"content":"Factory methods are not documented in this topic.","pos":[3561,3610]},{"content":"See <bpt id=\"p1\">[</bpt>x:FactoryMethod Directive<ept id=\"p1\">](../../../docs/framework/xaml-services/x-factorymethod-directive.md)</ept>.","pos":[3611,3711],"source":" See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md)."},{"pos":[3720,3732],"content":"Enumerations","linkify":"Enumerations","nodes":[{"content":"Enumerations","pos":[0,12]}]},{"content":"Enumerations have XAML native type conversion behavior.","pos":[3736,3791]},{"content":"Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.","pos":[3792,3948]},{"content":"XAML supports a flags-style usage for enumerations with <ph id=\"ph1\">&lt;xref:System.FlagsAttribute&gt;</ph> applied.","pos":[3955,4048],"source":"XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>XAML Syntax In Detail<ept id=\"p1\">](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.","pos":[4049,4162],"source":" For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)."},{"content":"(<bpt id=\"p1\">[</bpt>XAML Syntax In Detail<ept id=\"p1\">](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept> is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)","pos":[4163,4408],"source":" ([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)"},{"pos":[4417,4435],"content":"Member Definitions","linkify":"Member Definitions","nodes":[{"content":"Member Definitions","pos":[0,18]}]},{"content":"Types can define members for XAML usage.","pos":[4439,4479]},{"content":"It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.","pos":[4480,4592]},{"content":"This is possible because of CLR inheritance.","pos":[4593,4637]},{"content":"So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.","pos":[4638,4840]},{"pos":[4850,4860],"content":"Properties","linkify":"Properties","nodes":[{"content":"Properties","pos":[0,10]}]},{"pos":[4864,5253],"content":"If you define properties as a public CLR property using the typical CLR <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <ph id=\"ph3\">&lt;xref:System.Xaml.XamlMember&gt;</ph> properties, such as <ph id=\"ph4\">&lt;xref:System.Xaml.XamlMember.IsReadPublic%2A&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Xaml.XamlMember.IsWritePublic%2A&gt;</ph>.","source":"If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>."},{"content":"Specific properties can enable a text syntax by applying <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph>.","pos":[5260,5369],"source":"Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Type Converters and Markup Extensions for XAML<ept id=\"p1\">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept>.","pos":[5370,5534],"source":" For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)."},{"content":"In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember.TargetType%2A&gt;</ph> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.","pos":[5541,5870],"source":"In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type."},{"pos":[5877,6141],"content":"If using XAML 2009, <bpt id=\"p1\">[</bpt>x:Reference Markup Extension<ept id=\"p1\">](../../../docs/framework/xaml-services/x-reference-markup-extension.md)</ept> can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.","source":"If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue."},{"pos":[6151,6157],"content":"Events","linkify":"Events","nodes":[{"content":"Events","pos":[0,6]}]},{"content":"If you define events as a public CLR event, the XAML type system can report the event as a member with <ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember.IsEvent%2A&gt;</ph> as <ph id=\"ph2\">`true`</ph>.","pos":[6161,6315],"source":"If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`."},{"content":"Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.","pos":[6316,6468]},{"pos":[6478,6485],"content":"Methods","linkify":"Methods","nodes":[{"content":"Methods","pos":[0,7]}]},{"content":"Inline code for methods is not a default XAML capability.","pos":[6489,6546]},{"content":"In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.","pos":[6547,6703]},{"content":"<bpt id=\"p1\">[</bpt>x:FactoryMethod Directive<ept id=\"p1\">](../../../docs/framework/xaml-services/x-factorymethod-directive.md)</ept> is an exception.","pos":[6704,6816],"source":"[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception."},{"pos":[6826,6832],"content":"Fields","linkify":"Fields","nodes":[{"content":"Fields","pos":[0,6]}]},{"content":"CLR design guidelines discourage nonstatic fields.","pos":[6836,6886]},{"content":"For static fields, you can access static field values only through <bpt id=\"p1\">[</bpt>x:Static Markup Extension<ept id=\"p1\">](../../../docs/framework/xaml-services/x-static-markup-extension.md)</ept>; in this case you are not doing anything special in the CLR definition to expose a field for <bpt id=\"p2\">[</bpt>x:Static<ept id=\"p2\">](../../../docs/framework/xaml-services/x-static-markup-extension.md)</ept> usages.","pos":[6887,7229],"source":" For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages."},{"pos":[7238,7256],"content":"Attachable Members","linkify":"Attachable Members","nodes":[{"content":"Attachable Members","pos":[0,18]}]},{"content":"Attachable members are exposed to XAML through an accessor method pattern on a defining type.","pos":[7260,7353]},{"content":"The defining type itself does not need to be XAML-usable as an object.","pos":[7354,7424]},{"content":"In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.","pos":[7425,7617]},{"content":"For the following sections, the placeholder <bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> represents the name of your attachable member.","pos":[7618,7723],"source":" For the following sections, the placeholder *PropertyName* represents the name of your attachable member."},{"content":"That name must be valid in the <bpt id=\"p1\">[</bpt>XamlName Grammar<ept id=\"p1\">](../../../docs/framework/xaml-services/xamlname-grammar.md)</ept>.","pos":[7724,7833],"source":" That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md)."},{"content":"Be cautious of name collisions between these patterns and other methods of a type.","pos":[7840,7922]},{"content":"If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.","pos":[7923,8092]},{"pos":[8103,8131],"content":"The GetPropertyName Accessor","linkify":"The GetPropertyName Accessor","nodes":[{"content":"The GetPropertyName Accessor","pos":[0,28]}]},{"pos":[8135,8194],"content":"The signature for the <ph id=\"ph1\">`Get`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> accessor must be:","source":"The signature for the `Get`*PropertyName* accessor must be:"},{"pos":[8201,8266],"content":"<ph id=\"ph1\">`public static object Get`</ph> <bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> <ph id=\"ph2\">`(object`</ph>  <ph id=\"ph3\">`target`</ph> <ph id=\"ph4\">`)`</ph>","source":"`public static object Get` *PropertyName* `(object`  `target` `)`"},{"content":"The <ph id=\"ph1\">`target`</ph> object can be specified as a more specific type in your implementation.","pos":[8276,8360],"source":"The `target` object can be specified as a more specific type in your implementation."},{"content":"You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.","pos":[8361,8539]},{"content":"The parameter name <ph id=\"ph1\">`target`</ph> is not a requirement, but is named <ph id=\"ph2\">`target`</ph> by convention in most implementations.","pos":[8540,8650],"source":" The parameter name `target` is not a requirement, but is named `target` by convention in most implementations."},{"content":"The return value can be specified as a more specific type in your implementation.","pos":[8660,8741]},{"content":"To support a <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> enabled text syntax for attribute usage of the attachable member, apply <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to the <ph id=\"ph3\">`Get`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> accessor.","pos":[8748,8964],"source":"To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor."},{"content":"Applying to the <ph id=\"ph1\">`get`</ph> instead of the <ph id=\"ph2\">`set`</ph> may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.","pos":[8965,9173],"source":" Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios."},{"pos":[9184,9212],"content":"The SetPropertyName Accessor","linkify":"The SetPropertyName Accessor","nodes":[{"content":"The SetPropertyName Accessor","pos":[0,28]}]},{"pos":[9216,9273],"content":"The signature for the Set<bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> accessor must be:","source":"The signature for the Set*PropertyName* accessor must be:"},{"pos":[9280,9363],"content":"<ph id=\"ph1\">`public static void Set`</ph> <bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> <ph id=\"ph2\">`(object`</ph>  <ph id=\"ph3\">`target`</ph> <ph id=\"ph4\">`, object`</ph>  <ph id=\"ph5\">`value`</ph> <ph id=\"ph6\">`)`</ph>","source":"`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`"},{"pos":[9373,9528],"content":"The <ph id=\"ph1\">`target`</ph> object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.","source":"The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section."},{"pos":[9538,9621],"content":"The <ph id=\"ph1\">`value`</ph> object can be specified as a more specific type in your implementation.","source":"The `value` object can be specified as a more specific type in your implementation."},{"content":"Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.","pos":[9628,9737]},{"content":"From attribute form there must be value converter support for a text syntax, and you attribute on the <ph id=\"ph1\">`Get`</ph><bpt id=\"p1\">*</bpt>PropertyName<ept id=\"p1\">*</ept> accessor.","pos":[9738,9869],"source":" From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor."},{"pos":[9879,9903],"content":"Attachable Member Stores","linkify":"Attachable Member Stores","nodes":[{"content":"Attachable Member Stores","pos":[0,24]}]},{"content":"The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.","pos":[9907,10102]},{"content":"To provide this functionality, the <ph id=\"ph1\">`target`</ph> objects in the previous accessor signatures must be capable of storing values.","pos":[10103,10225],"source":" To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values."},{"content":"The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.","pos":[10226,10402]},{"content":".NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <ph id=\"ph1\">&lt;xref:System.Xaml.IAttachedPropertyStore&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Xaml.AttachablePropertyServices&gt;</ph>.","pos":[10403,10607],"source":" .NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Xaml.IAttachedPropertyStore&gt;</ph> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the <ph id=\"ph2\">`target`</ph> of the accessors.","pos":[10608,10792],"source":"<xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors."},{"content":"The static <ph id=\"ph1\">&lt;xref:System.Xaml.AttachablePropertyServices&gt;</ph> APIs are used within the body of the accessors, and refer to the attachable member by its <ph id=\"ph2\">&lt;xref:System.Xaml.AttachableMemberIdentifier&gt;</ph>.","pos":[10793,10986],"source":" The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>."},{"pos":[10995,11022],"content":"XAML-Related CLR Attributes","linkify":"XAML-Related CLR Attributes","nodes":[{"content":"XAML-Related CLR Attributes","pos":[0,27]}]},{"content":"Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.","pos":[11026,11177]},{"content":"This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.","pos":[11178,11437]},{"pos":[11444,11711],"content":"For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see <bpt id=\"p1\">[</bpt>XAML-Related CLR Attributes for Custom Types and Libraries<ept id=\"p1\">](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)</ept>.","source":"For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)."},{"pos":[11720,11725],"content":"Usage","linkify":"Usage","nodes":[{"content":"Usage","pos":[0,5]}]},{"content":"Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.","pos":[11729,11865]},{"content":"This procedure is not documented in this topic.","pos":[11866,11913]},{"pos":[11922,11934],"content":"Access Level","linkify":"Access Level","nodes":[{"content":"Access Level","pos":[0,12]}]},{"content":"XAML provides a means to load and instantiate types that have an <ph id=\"ph1\">`internal`</ph> access level.","pos":[11938,12027],"source":"XAML provides a means to load and instantiate types that have an `internal` access level."},{"content":"This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.","pos":[12028,12193]},{"content":"An example from WPF is whenever user code defines a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with <ph id=\"ph2\">`public`</ph> access level.","pos":[12200,12483],"source":"An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level."},{"content":"Such a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> can be declared with <ph id=\"ph2\">`internal`</ph> access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.","pos":[12484,12671],"source":" Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type."},{"pos":[12678,12839],"content":"For an application that loads XAML under full trust and uses <ph id=\"ph1\">&lt;xref:System.Xaml.XamlObjectWriter&gt;</ph>, loading classes with <ph id=\"ph2\">`internal`</ph> access level is always enabled.","source":"For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled."},{"content":"For an application that loads XAML under partial trust, you can control the access level characteristics by using the <ph id=\"ph1\">&lt;xref:System.Xaml.Permissions.XamlAccessLevel&gt;</ph> API.","pos":[12846,13015],"source":"For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API."},{"content":"Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <ph id=\"ph1\">&lt;xref:System.Xaml.Permissions.XamlAccessLevel&gt;</ph> information.","pos":[13016,13289],"source":" Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information."},{"pos":[13299,13317],"content":"WPF Implementation","linkify":"WPF Implementation","nodes":[{"content":"WPF Implementation","pos":[0,18]}]},{"content":"WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <ph id=\"ph1\">&lt;xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A&gt;</ph> for the assembly that is the BAML source.","pos":[13321,13541],"source":"WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source."},{"content":"For deferral, WPF uses <ph id=\"ph1\">&lt;xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=fullName&gt;</ph> as a mechanism for passing the access level information.","pos":[13542,13711],"source":" For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=fullName> as a mechanism for passing the access level information."},{"content":"In WPF XAML terminology, an <bpt id=\"p1\">*</bpt>internal type<ept id=\"p1\">*</ept> is a type that is defined by the same assembly that also includes the referencing XAML.","pos":[13718,13849],"source":"In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML."},{"content":"Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, <ph id=\"ph1\">`xmlns:local=\"clr-namespace:WPFApplication1\"`</ph>.","pos":[13850,14020],"source":" Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local=\"clr-namespace:WPFApplication1\"`."},{"content":"If BAML references an internal type and that type has <ph id=\"ph1\">`internal`</ph> access level, this generates a <ph id=\"ph2\">`GeneratedInternalTypeHelper`</ph> class for the assembly.","pos":[14022,14171],"source":"  If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly."},{"content":"If you want to avoid <ph id=\"ph1\">`GeneratedInternalTypeHelper`</ph>, you either must use <ph id=\"ph2\">`public`</ph> access level, or must factor the relevant class into a separate assembly and make that assembly dependent.","pos":[14172,14359],"source":" If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent."},{"pos":[14368,14376],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>XAML-Related CLR Attributes for Custom Types and Libraries<ept id=\"p1\">](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)</ept><ph id=\"ph1\"> </ph>","pos":[14380,14542],"source":"[XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md) "},{"content":"<bpt id=\"p1\"> [</bpt>XAML Services<ept id=\"p1\">](../../../docs/framework/xaml-services/index.md)</ept>","pos":[14545,14609],"source":" [XAML Services](../../../docs/framework/xaml-services/index.md)"}]}