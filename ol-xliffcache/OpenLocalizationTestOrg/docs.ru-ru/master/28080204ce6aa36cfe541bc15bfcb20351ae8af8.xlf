<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="input-overview.md" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">28080204ce6aa36cfe541bc15bfcb20351ae8af8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\advanced\input-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3887952607dfa365fe3dc61cbcc39a72b8797926</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad09cab7f232088f9c38e2902347f97ad7b6a339</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Input Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Input Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="introduction"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> The<ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> subsystem provides a powerful <ph id="ph2">[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]</ph> for obtaining input from a variety of devices, including the mouse, keyboard, touch, and stylus.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic describes the services provided by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> and explains the architecture of the input systems.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Input API</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The primary input <ph id="ph1">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> exposure is found on the base element classes: <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.ContentElement&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, and <ph id="ph5">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For more information about the base elements, see <bpt id="p1">[</bpt>Base Elements Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/base-elements-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>These classes provide functionality for input events related to key presses, mouse buttons, mouse wheel, mouse movement, focus management, and mouse capture, to name a few.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>By placing the input <ph id="ph1">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> on the base elements, rather than treating all input events as a service, the input architecture enables the input events to be sourced by a particular object in the UI, and to support an event routing scheme whereby more than one element has an opportunity to handle an input event.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Many input events have a pair of events associated with them.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, the key down event is associated with the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.KeyDown&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.PreviewKeyDown&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The difference in these events is in how they are routed to the target element.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Preview events tunnel down the element tree from the root element to the target element.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Bubbling events bubble up from the target element to the root element.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Event routing in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is discussed in more detail later in this overview and in the <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Keyboard and Mouse Classes</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In addition to the input <ph id="ph1">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> on the base element classes, the <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph> class and <ph id="ph3">&lt;xref:System.Windows.Input.Mouse&gt;</ph> classes provide additional <ph id="ph4">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> for working with keyboard and mouse input.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Examples of input <ph id="ph1">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph> class are the <ph id="ph3">&lt;xref:System.Windows.Input.Keyboard.Modifiers%2A&gt;</ph> property, which returns the <ph id="ph4">&lt;xref:System.Windows.Input.ModifierKeys&gt;</ph> currently pressed, and the <ph id="ph5">&lt;xref:System.Windows.Input.Keyboard.IsKeyDown%2A&gt;</ph> method, which determines whether a specified key is pressed.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.GetKeyStates%2A&gt;</ph> method to determine if a <ph id="ph2">&lt;xref:System.Windows.Input.Key&gt;</ph> is in the down state.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Examples of input <ph id="ph1">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> on the <ph id="ph2">&lt;xref:System.Windows.Input.Mouse&gt;</ph> class are <ph id="ph3">&lt;xref:System.Windows.Input.Mouse.MiddleButton%2A&gt;</ph>, which obtains the state of the middle mouse button, and <ph id="ph4">&lt;xref:System.Windows.Input.Mouse.DirectlyOver%2A&gt;</ph>, which gets the element the mouse pointer is currently over.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following example determines whether the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.LeftButton%2A&gt;</ph> on the mouse is in the <ph id="ph2">&lt;xref:System.Windows.Input.MouseButtonState&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph> classes are covered in more detail throughout this overview.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Stylus Input</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> has integrated support for the <ph id="ph2">&lt;xref:System.Windows.Input.Stylus&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Input.Stylus&gt;</ph> is a pen input made popular by the <ph id="ph2">[!INCLUDE[TLA#tla_tpc](../../../../includes/tlasharptla-tpc-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications can treat the stylus as a mouse by using the mouse <ph id="ph2">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph>, but <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> also exposes a stylus device abstraction that use a model similar to the keyboard and mouse.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>All stylus-related <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph> contain the word "Stylus".</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Because the stylus can act as a mouse, applications that support only mouse input can still obtain some level of stylus support automatically.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When the stylus is used in such a manner, the application is given the opportunity to handle the appropriate stylus event and then handles the corresponding mouse event.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In addition, higher-level services such as ink input are also available through the stylus device abstraction.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information about ink as input, see <bpt id="p1">[</bpt>Getting Started with Ink<ept id="p1">](../../../../docs/framework/wpf/advanced/getting-started-with-ink.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Event Routing</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> can contain other elements as child elements in its content model, forming a tree of elements.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, the parent element can participate in input directed to its child elements or other descendants by handing events.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This is especially useful for building controls out of smaller controls, a process known as "control composition" or "compositing."</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For more information about element trees and how element trees relate to event routes, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Event routing is the process of forwarding events to multiple elements, so that a particular object or element along the route can choose to offer a significant response (through handling) to an event that might have been sourced by a different element.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Routed events use one of three routing mechanisms: direct, bubbling, and tunneling.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In direct routing, the source element is the only element notified, and the event is not routed to any other elements.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, the direct routed event still offers some additional capabilities that are only present for routed events as opposed to standard <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> events.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Bubbling works up the element tree by first notifying the element that sourced the event, then the parent element, and so on.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Tunneling starts at the root of the element tree and works down, ending with the original source element.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information about routed events, see <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> input events generally come in pairs that consists of a tunneling event and a bubbling event.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Tunneling events are distinguished from bubbling events with the "Preview" prefix.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For instance, <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.PreviewMouseMove&gt;</ph> is the tunneling version of a mouse move event and <ph id="ph2">&lt;xref:System.Windows.Input.Mouse.MouseMove&gt;</ph> is the bubbling version of this event.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This event pairing is a convention that is implemented at the element level and is not an inherent capability of the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event system.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For details, see the WPF Input Events section in <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Handling Input Events</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>To receive input on an element, an event handler must be associated with that particular event.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> this is straightforward: you reference the name of the event as an attribute of the element that will be listening for this event.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Then, you set the value of the attribute to the name of the event handler that you define, based on a delegate.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The event handler must be written in code such as <ph id="ph1">[!INCLUDE[TLA#tla_cshrp](../../../../includes/tlasharptla-cshrp-md.md)]</ph> and can be included in a code-behind file.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Keyboard events occur when the operating system reports key actions that occur while keyboard focus is on an element.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Mouse and stylus events each fall into two categories: events that report changes in pointer position relative to the element, and events that report changes in the state of device buttons.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Keyboard Input Event Example</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example listens for a left arrow key press.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> is created that has a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>An event handler to listen for the left arrow key press is attached to the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The first section of the example creates the <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> and attaches the event handler for the <ph id="ph3">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The second section is written in code and defines the event handler.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When the left arrow key is pressed and the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> has keyboard focus, the handler runs and the <ph id="ph2">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> color of the <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> is changed.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If the key is pressed, but it is not the left arrow key, the <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> color of the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> is changed back to its starting color.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Mouse Input Event Example</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> color of a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> is changed when the mouse pointer enters the <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> color is restored when the mouse leaves the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The first section of the example creates the <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> and the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> control and attaches the event handlers for the <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseEnter&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.UIElement.MouseLeave&gt;</ph> events to the <ph id="ph5">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The second section of the example is written in code and defines the event handlers.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When the mouse enters the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>, the <ph id="ph2">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> color of the <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> is changed to <ph id="ph4">&lt;xref:System.Windows.Media.Brushes.SlateGray%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>When the mouse leaves the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>, the <ph id="ph2">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> color of the <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> is changed back to <ph id="ph4">&lt;xref:System.Windows.Media.Brushes.AliceBlue%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Text Input</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.ContentElement.TextInput&gt;</ph> event enables you to listen for text input in a device-independent manner.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The keyboard is the primary means of text input, but speech, handwriting, and other input devices can generate text input also.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For keyboard input, <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> first sends the appropriate <ph id="ph2">&lt;xref:System.Windows.ContentElement.KeyDown&gt;</ph><ph id="ph3">/</ph><ph id="ph4">&lt;xref:System.Windows.ContentElement.KeyUp&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If those events are not handled and the key is textual (rather than a control key such as directional arrows or function keys), then a <ph id="ph1">&lt;xref:System.Windows.ContentElement.TextInput&gt;</ph> event is raised.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>There is not always a simple one-to-one mapping between <ph id="ph1">&lt;xref:System.Windows.ContentElement.KeyDown&gt;</ph><ph id="ph2">/</ph><ph id="ph3">&lt;xref:System.Windows.ContentElement.KeyUp&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.ContentElement.TextInput&gt;</ph> events because multiple keystrokes can generate a single character of text input and single keystrokes can generate multi-character strings.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This is especially true for languages such as Chinese, Japanese, and Korean which use <ph id="ph1">[!INCLUDE[TLA#tla_ime#plural](../../../../includes/tlasharptla-imesharpplural-md.md)]</ph> to generate the thousands of possible characters in their corresponding alphabets.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> sends a <ph id="ph2">&lt;xref:System.Windows.ContentElement.KeyUp&gt;</ph><ph id="ph3">/</ph><ph id="ph4">&lt;xref:System.Windows.ContentElement.KeyDown&gt;</ph> event, <ph id="ph5">&lt;xref:System.Windows.Input.KeyEventArgs.Key%2A&gt;</ph> is set to <ph id="ph6">&lt;xref:System.Windows.Input.Key?displayProperty=fullName&gt;</ph> if the keystrokes could become part of a <ph id="ph7">&lt;xref:System.Windows.ContentElement.TextInput&gt;</ph> event (if ALT+S is pressed, for example).</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This allows code in a <ph id="ph1">&lt;xref:System.Windows.ContentElement.KeyDown&gt;</ph> event handler to check for <ph id="ph2">&lt;xref:System.Windows.Input.Key?displayProperty=fullName&gt;</ph> and, if found, leave processing for the handler of the subsequently raised <ph id="ph3">&lt;xref:System.Windows.ContentElement.TextInput&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In these cases, the various properties of the <ph id="ph1">&lt;xref:System.Windows.Input.TextCompositionEventArgs&gt;</ph> argument can be used to determine the original keystrokes.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Similarly, if an <ph id="ph1">[!INCLUDE[TLA2#tla_ime](../../../../includes/tla2sharptla-ime-md.md)]</ph> is active, <ph id="ph2">&lt;xref:System.Windows.Input.Key&gt;</ph> has the value of <ph id="ph3">&lt;xref:System.Windows.Input.Key?displayProperty=fullName&gt;</ph>, and <ph id="ph4">&lt;xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A&gt;</ph> gives the original keystroke or keystrokes.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following example defines a handler for the <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event and a handler for the <ph id="ph2">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The first segment of code or markup creates the user interface.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The second segment of code contains the event handlers.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Because input events bubble up the event route, the <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> receives the input regardless of which element has keyboard focus.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> control is notified first and the <ph id="ph2">`OnTextInputKeyDown`</ph> handler is called only if the <ph id="ph3">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> did not handle the input.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.UIElement.PreviewKeyDown&gt;</ph> event is used instead of the <ph id="ph2">&lt;xref:System.Windows.UIElement.KeyDown&gt;</ph> event, the <ph id="ph3">`OnTextInputKeyDown`</ph> handler is called first.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In this example, the handling logic is written two timesâ€”one time for CTRL+O, and again for button's click event.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This can be simplified by using commands, instead of handling the input events directly.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Commands are discussed in this overview and in <bpt id="p1">[</bpt>Commanding Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/commanding-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Touch and Manipulation</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>New hardware and API in the Windows 7 operating system provide applications the ability to receive input from multiple touches simultaneously.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> enables applications to detect and respond to touch in a manner similar to responding to other input, such as the mouse or keyboard, by raising events when touch occurs.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> exposes two types of events when touch occurs: touch events and manipulation events.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Touch events provide raw data about each finger on a touchscreen and its movement.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Manipulation events interpret the input as certain actions.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Both types of events are discussed in this section.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You need the following components to develop an application that responds to touch.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[vs_dev10_ext](../../../../includes/vs-dev10-ext-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Windows 7.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>A device, such as a touchscreen, that supports Windows Touch.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Terminology</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The following terms are used when touch is discussed.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Touch<ept id="p1">**</ept> is a type of user input that is recognized by Windows 7.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Usually, touch is initiated by putting fingers on a touch-sensitive screen.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Note that devices such as a touchpad that is common on laptop computers do not support touch if the device merely converts the finger's position and movement as mouse input.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Multitouch<ept id="p1">**</ept> is touch that occurs from more than one point simultaneously.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Windows 7 and <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> supports multitouch.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Whenever touch is discussed in the documentation for <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, the concepts apply to multitouch.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>manipulation<ept id="p1">**</ept> occurs when touch is interpreted as a physical action that is applied to an object.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, manipulation events interpret input as a translation, expansion, or rotation manipulation.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`touch device`</ph> represents a device that produces touch input, such as a single finger on a touchscreen.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Controls that Respond to Touch</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The following controls can be scrolled by dragging a finger across the control if it has content that is scrolled out of view.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> defines the <ph id="ph2">&lt;xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=fullName&gt;</ph> attached property that enables you to specify whether touch panning is enabled horizontally, vertically, both, or neither.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=fullName&gt;</ph> property specifies how quickly the scrolling slows down when the user lifts the finger from the touchscreen.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=fullName&gt;</ph> attached property specifies the ratio of scrolling offset to translate manipulation offset.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Touch Events</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The base classes, <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.UIElement3D&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.ContentElement&gt;</ph>, define events that you can subscribe to so your application will respond to touch.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Touch events are useful when your application interprets touch as something other than manipulating an object.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For example, an application that enables a user to draw with one or more fingers would subscribe to touch events.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>All three classes define the following events, which behave similarly, regardless of the defining class.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Like keyboard and mouse events, the touch events are routed events.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The events that begin with <ph id="ph1">`Preview`</ph> are tunneling events and the events that begin with <ph id="ph2">`Touch`</ph> are bubbling events.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For more information about routed events, see <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When you handle these events, you can get the position of the input, relative to any element, by calling the <ph id="ph1">&lt;xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>To understand the interaction among the touch events, consider the scenario where a user puts one finger on an element, moves the finger in the element, and then lifts the finger from the element.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following illustration shows the execution of the bubbling events (the tunneling events are omitted for simplicity).</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>The sequence of touch events.<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/advanced/media/ndp-touchevents.png "</bpt>NDP_TouchEvents<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Touch events</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The following list describes the sequence of the events in the preceding illustration.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchEnter&gt;</ph> event occurs one time when the user puts a finger on the element.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> event occurs one time.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchMove&gt;</ph> event occurs multiple times as the user moves the finger within the element.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchUp&gt;</ph> event occurs one time when the user lifts the finger from the element.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchLeave&gt;</ph> event occurs one time.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>When more than two fingers are used, the events occur for each finger.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Manipulation Events</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For cases where an application enables a user to manipulate an object, the <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> class defines manipulation events.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Unlike the touch events that simply report the position of touch, the manipulation events report how the input can be interpreted.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>There are three types of manipulations, translation, expansion, and rotation.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The following list describes how to invoke the three types of manipulations.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Put a finger on an object and move the finger across the touchscreen to invoke a translation manipulation.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This usually moves the object.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Put two fingers on an object and move the fingers closer together or farther apart from one another to invoke an expansion manipulation.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>This usually resizes the object.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Put two fingers on an object and rotate the fingers around each other to invoke a rotation manipulation.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>This usually rotates the object.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>More than one type of manipulation can occur simultaneously.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>When you cause objects to respond to manipulations, you can have the object appear to have inertia.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>This can make your objects simulate the physical world.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For example, when you push a book across a table, if you push hard enough the book will continue to move after you release it.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> enables you to simulate this behavior by raising manipulation events after the user's fingers releases the object.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For information about how to create an application that enables the user to move, resize, and rotate an object, see <bpt id="p1">[</bpt>Walkthrough: Creating Your First Touch Application<ept id="p1">](../../../../docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> defines the following manipulation events.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>By default, a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> does not receive these manipulation events.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>To receive manipulation events on a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph>, set <ph id="ph2">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=fullName&gt;</ph> to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The Execution Path of Manipulation Events</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Consider a scenario where a user "throws" an object.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The user puts a finger on the object, moves the finger across the touchscreen for a short distance, and then lifts the finger while it is moving.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The result of this is that the object will move under the user's finger and continue to move after the user lifts the finger.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The following illustration shows the execution path of manipulation events and important information about each event.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>The sequence of manipulation events.<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/advanced/media/ndp-manipulationevents.png "</bpt>NDP_ManipulationEvents<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Manipulation events</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The following list describes the sequence of the events in the preceding illustration.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event occurs when the user places a finger on the object.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Among other things, this event allows you to set the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In the subsequent events, the position of the manipulation will be relative to the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>In events other than <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph>, this property is read-only, so the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event is the only time that you can set this property.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph> event occurs next.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>This event reports the origin of the manipulation.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event occurs multiple times as a user's fingers move on a touchscreen.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs&gt;</ph> class reports whether the manipulation is interpreted as movement, expansion, or translation.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>This is where you perform most of the work of manipulating an object.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event occurs when the user's fingers lose contact with the object.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This event enables you to specify the deceleration of the manipulations during inertia.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This is so your object can emulate different physical spaces or attributes if you choose.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>For example, suppose your application has two objects that represent items in the physical world, and one is heavier than the other.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>You can make the heavier object decelerate faster than the lighter object.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event occurs multiple times as inertia occurs.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Note that this event occurs when the user's fingers move across the touchscreen and when <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> simulates inertia.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>In other words, <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> occurs before and after the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=fullName&gt;</ph> property reports whether the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event occurs during inertia, so you can check that property and perform different actions, depending on its value.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph> event occurs when the manipulation and any inertia ends.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>That is, after all the <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> events occur, the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph> event occurs to signal that the manipulation is complete.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> also defines the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>This event occurs when the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A&gt;</ph> method is called in the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph> event enables applications or components to provide visual feedback when an object hits a boundary.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph> class handles the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph> event to cause the window to slightly move when its edge is encountered.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>You can cancel the manipulation by calling the <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A&gt;</ph> method on the event arguments in any manipulation event except <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationBoundaryFeedback&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A&gt;</ph>, the manipulation events are no longer raised and mouse events occur for touch.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The following table describes the relationship between the time the manipulation is canceled and the mouse events that occur.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The event that Cancel is called in</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The mouse events that occur for input that already occurred</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationStarted&gt;</ph></source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Mouse down events.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Mouse down and mouse move events.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationCompleted&gt;</ph></source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Mouse down, mouse move, and mouse up events.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Note that if you call <ph id="ph1">&lt;xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A&gt;</ph> when the manipulation is in inertia, the method returns <ph id="ph2">`false`</ph> and the input does not raise mouse events.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The Relationship Between Touch and Manipulation Events</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> can always receive touch events.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Windows.UIElement.IsManipulationEnabled%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph>, a <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> can receive both touch and manipulation events.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> event is not handled (that is, the <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> property is <ph id="ph3">`false`</ph>), the manipulation logic captures the touch to the element and generates the manipulation events.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph> in the <ph id="ph3">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> event, the manipulation logic does not generate manipulation events.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The following illustration shows the relationship between touch events and manipulation events.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Relationship between touch and manipulation events<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/advanced/media/ndp-touchmanipulateevents.png "</bpt>NDP_TouchManipulateEvents<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Touch and manipulation events</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The following list describes the relationship between the touch and manipulation events that is shown in the preceding illustration.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>When the first touch device generates a <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchDown&gt;</ph> event on a <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>, the manipulation logic calls the <ph id="ph3">&lt;xref:System.Windows.UIElement.CaptureTouch%2A&gt;</ph> method, which generates the <ph id="ph4">&lt;xref:System.Windows.UIElement.GotTouchCapture&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Windows.UIElement.GotTouchCapture&gt;</ph> occurs, the manipulation logic calls the <ph id="ph2">&lt;xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=fullName&gt;</ph> method, which generates the <ph id="ph3">&lt;xref:System.Windows.UIElement.ManipulationStarting&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchMove&gt;</ph> events occur, the manipulation logic generates the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationDelta&gt;</ph> events that occur before the <ph id="ph3">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>When the last touch device on the element raises the <ph id="ph1">&lt;xref:System.Windows.UIElement.TouchUp&gt;</ph> event, the manipulation logic generates the <ph id="ph2">&lt;xref:System.Windows.UIElement.ManipulationInertiaStarting&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Focus</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>There are two main concepts that pertain to focus in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>: keyboard focus and logical focus.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Keyboard Focus</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Keyboard focus refers to the element that is receiving keyboard input.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>There can be only one element on the whole desktop that has keyboard focus.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, the element that has keyboard focus will have <ph id="ph2">&lt;xref:System.Windows.IInputElement.IsKeyboardFocused%2A&gt;</ph> set to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The static <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard&gt;</ph> method <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard.FocusedElement%2A&gt;</ph> returns the element that currently has keyboard focus.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Keyboard focus can be obtained by tabbing to an element or by clicking the mouse on certain elements, such as a <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Keyboard focus can also be obtained programmatically by using the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.Focus%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.Focus%2A&gt;</ph> attempts to give the specified element keyboard focus.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The element returned by <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.Focus%2A&gt;</ph> is the element that currently has keyboard focus.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>In order for an element to obtain keyboard focus the <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Windows.UIElement.IsVisible%2A&gt;</ph> properties must be set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Some classes, such as <ph id="ph1">&lt;xref:System.Windows.Controls.Panel&gt;</ph>, have <ph id="ph2">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> set to <ph id="ph3">`false`</ph> by default; therefore, you may have to set this property to <ph id="ph4">`true`</ph> if you want that element to be able to obtain focus.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.Focus%2A&gt;</ph> to set keyboard focus on a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The recommended place to set initial focus in an application is in the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> event handler.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>For more information about keyboard focus, see <bpt id="p1">[</bpt>Focus Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/focus-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Logical Focus</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Logical focus refers to the <ph id="ph1">&lt;xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=fullName&gt;</ph> in a focus scope.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>There can be multiple elements that have logical focus in an application, but there may only be one element that has logical focus in a particular focus scope.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>A focus scope is a container element that keeps track of the <ph id="ph1">&lt;xref:System.Windows.Input.FocusManager.FocusedElement%2A&gt;</ph> within its scope.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>When focus leaves a focus scope, the focused element will lose keyboard focus but will retain logical focus.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>When focus returns to the focus scope, the focused element will obtain keyboard focus.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>This allows for keyboard focus to be changed between multiple focus scopes but insures that the focused element within the focus scope remains the focused element when focus returns.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>An element can be turned into a focus scope in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph> by setting the <ph id="ph2">&lt;xref:System.Windows.Input.FocusManager&gt;</ph> attached property <ph id="ph3">&lt;xref:System.Windows.Input.FocusManager.IsFocusScope%2A&gt;</ph> to <ph id="ph4">`true`</ph>, or in code by setting the attached property by using the <ph id="ph5">&lt;xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The following example makes a <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> into a focus scope by setting the <ph id="ph2">&lt;xref:System.Windows.Input.FocusManager.IsFocusScope%2A&gt;</ph> attached property.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Classes in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> which are focus scopes by default are <ph id="ph2">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Controls.Menu&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Controls.ToolBar&gt;</ph>, and <ph id="ph5">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>An element that has keyboard focus will also have logical focus for the focus scope it belongs to; therefore, setting focus on an element with the <ph id="ph1">&lt;xref:System.Windows.Input.Keyboard.Focus%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph> class or the base element classes will attempt to give the element keyboard focus and logical focus.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>To determine the focused element in a focus scope, use <ph id="ph1">&lt;xref:System.Windows.Input.FocusManager.GetFocusedElement%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>To change the focused element for a focus scope, use <ph id="ph1">&lt;xref:System.Windows.Input.FocusManager.SetFocusedElement%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>For more information about logical focus, see <bpt id="p1">[</bpt>Focus Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/focus-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Mouse Position</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> input <ph id="ph2">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> provides helpful information with regard to coordinate spaces.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>For example, coordinate <ph id="ph1">`(0,0)`</ph> is the upper-left coordinate, but the upper-left of which element in the tree?</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The element that is the input target?</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The element you attached your event handler to?</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Or something else?</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>To avoid confusion, the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> input <ph id="ph2">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> requires that you specify your frame of reference when you work with coordinates obtained through the mouse.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.GetPosition%2A&gt;</ph> method returns the coordinate of the mouse pointer relative to the specified element.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Mouse Capture</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Mouse devices specifically hold a modal characteristic known as mouse capture.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Mouse capture is used to maintain a transitional input state when a drag-and-drop operation is started, so that other operations involving the nominal on-screen position of the mouse pointer do not necessarily occur.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>During the drag, the user cannot click without aborting the drag-and-drop, which makes most mouseover cues inappropriate while the mouse capture is held by the drag origin.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The input system exposes <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph> that can determine mouse capture state, as well as <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph> that can force mouse capture to a specific element, or clear mouse capture state.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>For more information on drag-and-drop operations, see <bpt id="p1">[</bpt>Drag and Drop Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/drag-and-drop-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Commands</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Commands enable input handling at a more semantic level than device input.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>Commands are simple directives, such as <ph id="ph1">`Cut`</ph>, <ph id="ph2">`Copy`</ph>, <ph id="ph3">`Paste`</ph>, or <ph id="ph4">`Open`</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Commands are useful for centralizing your command logic.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The same command might be accessed from a <ph id="ph1">&lt;xref:System.Windows.Controls.Menu&gt;</ph>, on a <ph id="ph2">&lt;xref:System.Windows.Controls.ToolBar&gt;</ph>, or through a keyboard shortcut.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Commands also provide a mechanism for disabling controls when the command becomes unavailable.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Input.RoutedCommand&gt;</ph> is the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> implementation of <ph id="ph3">&lt;xref:System.Windows.Input.ICommand&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>When a <ph id="ph1">&lt;xref:System.Windows.Input.RoutedCommand&gt;</ph> is executed, a <ph id="ph2">&lt;xref:System.Windows.Input.CommandManager.PreviewExecuted&gt;</ph> and an <ph id="ph3">&lt;xref:System.Windows.Input.CommandManager.Executed&gt;</ph> event are raised on the command target, which tunnel and bubble through the element tree like other input.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>If a command target is not set, the element with keyboard focus will be the command target.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The logic that performs the command is attached to a <ph id="ph1">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>When an <ph id="ph1">&lt;xref:System.Windows.Input.CommandManager.Executed&gt;</ph> event reaches a <ph id="ph2">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> for that specific command, the <ph id="ph3">&lt;xref:System.Windows.Input.ExecutedRoutedEventHandler&gt;</ph> on the <ph id="ph4">&lt;xref:System.Windows.Input.CommandBinding&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>This handler performs the action of the command.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>For more information on commanding, see <bpt id="p1">[</bpt>Commanding Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/commanding-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provides a library of common commands which consists of <ph id="ph2">&lt;xref:System.Windows.Input.ApplicationCommands&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Input.MediaCommands&gt;</ph>, <ph id="ph4">&lt;xref:System.Windows.Input.ComponentCommands&gt;</ph>, <ph id="ph5">&lt;xref:System.Windows.Input.NavigationCommands&gt;</ph>, and <ph id="ph6">&lt;xref:System.Windows.Documents.EditingCommands&gt;</ph>, or you can define your own.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The following example shows how to set up a <ph id="ph1">&lt;xref:System.Windows.Controls.MenuItem&gt;</ph> so that when it is clicked it will invoke the <ph id="ph2">&lt;xref:System.Windows.Input.ApplicationCommands.Paste%2A&gt;</ph> command on the <ph id="ph3">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, assuming the <ph id="ph4">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> has keyboard focus.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>For more information about commands in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, see <bpt id="p1">[</bpt>Commanding Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/commanding-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The Input System and Base Elements</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Input events such as the attached events defined by the <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Input.Stylus&gt;</ph> classes are raised by the input system and injected into a particular position in the object model based on hit testing the visual tree at run time.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Each of the events that <ph id="ph1">&lt;xref:System.Windows.Input.Mouse&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Input.Keyboard&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Input.Stylus&gt;</ph> define as an attached event is also re-exposed by the base element classes <ph id="ph4">&lt;xref:System.Windows.UIElement&gt;</ph> and <ph id="ph5">&lt;xref:System.Windows.ContentElement&gt;</ph> as a new routed event.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The base element routed events are generated by classes handling the original attached event and reusing the event data.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>When the input event becomes associated with a particular source element through its base element input event implementation, it can be routed through the remainder of an event route that is based on a combination of logical and visual tree objects, and be handled by application code.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Generally, it is more convenient to handle these device-related input events using the routed events on <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.ContentElement&gt;</ph>, because you can use more intuitive event handler syntax both in <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> and in code.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>You could choose to handle the attached event that initiated the process instead, but you would face several issues: the attached event may be marked handled by the base element class handling, and you need to use accessor methods rather than true event syntax in order to attach handlers for attached events.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>What's Next</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>You now have several techniques to handle input in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>You should also have an improved understanding of the various types of input events and the routed event mechanisms used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Additional resources are available that explain <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> framework elements and event routing in more detail.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>See the following overviews for more information, <bpt id="p1">[</bpt>Commanding Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/commanding-overview.md)</ept>, <bpt id="p2">[</bpt>Focus Overview<ept id="p2">](../../../../docs/framework/wpf/advanced/focus-overview.md)</ept>, <bpt id="p3">[</bpt>Base Elements Overview<ept id="p3">](../../../../docs/framework/wpf/advanced/base-elements-overview.md)</ept>, <bpt id="p4">[</bpt>Trees in WPF<ept id="p4">](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)</ept>, and <bpt id="p5">[</bpt>Routed Events Overview<ept id="p5">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Focus Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/focus-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Commanding Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/commanding-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Base Elements Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/base-elements-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/properties-wpf.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>