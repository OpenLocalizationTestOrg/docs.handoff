{"content":"---\ntitle: \"@ - C# Reference\"\nms.custom: seodec18\n\nms.date: 02/09/2017\nf1_keywords: \n  - \"@_CSharpKeyword\"\n  - \"@\"\nhelpviewer_keywords: \n  - \"@ special character [C#]\"\n  - \"@ language element [C#]\"\nms.assetid: 89bc7e53-85f5-478a-866d-1cca003c4e8c\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# @ (C# Reference)\n\nThe `@` special character serves as a verbatim identifier. It can be used in the following ways:\n\n1. To enable C# keywords to be used as identifiers. The `@` character prefixes a code element that the compiler is to interpret as an identifier rather than a C# keyword. The following example uses the `@` character to define an identifier named `for` that it uses in a `for` loop.\n\n   [!code-csharp[verbatim1](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#1)]\n\n1. To indicate that a string literal is to be interpreted verbatim. The `@` character in this instance defines a *verbatim string literal*. Simple escape sequences (such as `\"\\\\\"` for a backslash), hexadecimal escape sequences (such as `\"\\x0041\"` for an uppercase A), and Unicode escape sequences (such as `\"\\u0041\"` for an uppercase A) are interpreted literally. Only a quote escape sequence (`\"\"`) is not interpreted literally; it produces a single quotation mark. Additionally, in case of a verbatim [interpolated string](interpolated.md) brace escape sequences (`{{` and `}}`) are not interpreted literally; they produce single brace characters. The following example defines two identical file paths, one by using a regular string literal and the other by using a verbatim string literal. This is one of the more common uses of verbatim string literals.\n\n   [!code-csharp[verbatim2](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#2)]\n\n   The following example illustrates the effect of defining a regular string literal and a verbatim string literal that contain identical character sequences.\n\n   [!code-csharp[verbatim3](../../../../samples/snippets/csharp/language-reference/keywords/verbatim1.cs#3)]\n\n1. To enable the compiler to distinguish between attributes in cases of a naming conflict. An attribute is a class that derives from <xref:System.Attribute>. Its type name typically includes the suffix **Attribute**, although the compiler does not enforce this convention. The attribute can then be referenced in code either by its full type name (for example, `[InfoAttribute]` or its shortened name (for example, `[Info]`). However, a naming conflict occurs if two shortened attribute type names are identical, and one type name includes the **Attribute** suffix but the other does not. For example, the following code fails to compile because the compiler cannot determine whether the `Info` or `InfoAttribute` attribute is applied to the `Example` class. See [CS1614](../compiler-messages/cs1614.md) for more information.\n\n   [!code-csharp[verbatim4](../../../../samples/snippets/csharp/language-reference/keywords/verbatim2.cs#1)]\n\n## See also\n\n- [C# Reference](../../../csharp/language-reference/index.md)\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [C# Special Characters](../../../csharp/language-reference/tokens/index.md)\n","nodes":[{"pos":[4,286],"embed":true,"restype":"x-metadata","content":"title: \"@ - C# Reference\"\nms.custom: seodec18\n\nms.date: 02/09/2017\nf1_keywords: \n  - \"@_CSharpKeyword\"\n  - \"@\"\nhelpviewer_keywords: \n  - \"@ special character [C#]\"\n  - \"@ language element [C#]\"\nms.assetid: 89bc7e53-85f5-478a-866d-1cca003c4e8c\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"@ - C# Reference","nodes":[{"pos":[0,16],"content":"@ - C# Reference","nodes":[{"content":"@ - C# Reference","pos":[0,16]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[293,309],"content":"@ (C# Reference)","linkify":"@ (C# Reference)","nodes":[{"content":"@ (C# Reference)","pos":[0,16]}]},{"content":"The <ph id=\"ph1\">`@`</ph> special character serves as a verbatim identifier.","pos":[311,369],"source":"The `@` special character serves as a verbatim identifier."},{"content":"It can be used in the following ways:","pos":[370,407]},{"content":"To enable C# keywords to be used as identifiers.","pos":[412,460]},{"content":"The <ph id=\"ph1\">`@`</ph> character prefixes a code element that the compiler is to interpret as an identifier rather than a C# keyword.","pos":[461,579],"source":" The `@` character prefixes a code element that the compiler is to interpret as an identifier rather than a C# keyword."},{"content":"The following example uses the <ph id=\"ph1\">`@`</ph> character to define an identifier named <ph id=\"ph2\">`for`</ph> that it uses in a <ph id=\"ph3\">`for`</ph> loop.","pos":[580,690],"source":" The following example uses the `@` character to define an identifier named `for` that it uses in a `for` loop."},{"content":"To indicate that a string literal is to be interpreted verbatim.","pos":[805,869]},{"content":"The <ph id=\"ph1\">`@`</ph> character in this instance defines a <bpt id=\"p1\">*</bpt>verbatim string literal<ept id=\"p1\">*</ept>.","pos":[870,941],"source":" The `@` character in this instance defines a *verbatim string literal*."},{"content":"Simple escape sequences (such as <ph id=\"ph1\">`\"\\\\\"`</ph> for a backslash), hexadecimal escape sequences (such as <ph id=\"ph2\">`\"\\x0041\"`</ph> for an uppercase A), and Unicode escape sequences (such as <ph id=\"ph3\">`\"\\u0041\"`</ph> for an uppercase A) are interpreted literally.","pos":[942,1165],"source":" Simple escape sequences (such as `\"\\\\\"` for a backslash), hexadecimal escape sequences (such as `\"\\x0041\"` for an uppercase A), and Unicode escape sequences (such as `\"\\u0041\"` for an uppercase A) are interpreted literally."},{"content":"Only a quote escape sequence (<ph id=\"ph1\">`\"\"`</ph>) is not interpreted literally; it produces a single quotation mark.","pos":[1166,1268],"source":" Only a quote escape sequence (`\"\"`) is not interpreted literally; it produces a single quotation mark."},{"content":"Additionally, in case of a verbatim <bpt id=\"p1\">[</bpt>interpolated string<ept id=\"p1\">](interpolated.md)</ept> brace escape sequences (<ph id=\"ph1\">`{{`</ph> and <ph id=\"ph2\">`}}`</ph>) are not interpreted literally; they produce single brace characters.","pos":[1269,1451],"source":" Additionally, in case of a verbatim [interpolated string](interpolated.md) brace escape sequences (`{{` and `}}`) are not interpreted literally; they produce single brace characters."},{"content":"The following example defines two identical file paths, one by using a regular string literal and the other by using a verbatim string literal.","pos":[1452,1595]},{"content":"This is one of the more common uses of verbatim string literals.","pos":[1596,1660]},{"content":"The following example illustrates the effect of defining a regular string literal and a verbatim string literal that contain identical character sequences.","pos":[1775,1930]},{"content":"To enable the compiler to distinguish between attributes in cases of a naming conflict.","pos":[2045,2132]},{"content":"An attribute is a class that derives from <ph id=\"ph1\">&lt;xref:System.Attribute&gt;</ph>.","pos":[2133,2199],"source":" An attribute is a class that derives from <xref:System.Attribute>."},{"content":"Its type name typically includes the suffix <bpt id=\"p1\">**</bpt>Attribute<ept id=\"p1\">**</ept>, although the compiler does not enforce this convention.","pos":[2200,2314],"source":" Its type name typically includes the suffix **Attribute**, although the compiler does not enforce this convention."},{"content":"The attribute can then be referenced in code either by its full type name (for example, <ph id=\"ph1\">`[InfoAttribute]`</ph> or its shortened name (for example, <ph id=\"ph2\">`[Info]`</ph>).","pos":[2315,2467],"source":" The attribute can then be referenced in code either by its full type name (for example, `[InfoAttribute]` or its shortened name (for example, `[Info]`)."},{"content":"However, a naming conflict occurs if two shortened attribute type names are identical, and one type name includes the <bpt id=\"p1\">**</bpt>Attribute<ept id=\"p1\">**</ept> suffix but the other does not.","pos":[2468,2630],"source":" However, a naming conflict occurs if two shortened attribute type names are identical, and one type name includes the **Attribute** suffix but the other does not."},{"content":"For example, the following code fails to compile because the compiler cannot determine whether the <ph id=\"ph1\">`Info`</ph> or <ph id=\"ph2\">`InfoAttribute`</ph> attribute is applied to the <ph id=\"ph3\">`Example`</ph> class.","pos":[2631,2800],"source":" For example, the following code fails to compile because the compiler cannot determine whether the `Info` or `InfoAttribute` attribute is applied to the `Example` class."},{"content":"See <bpt id=\"p1\">[</bpt>CS1614<ept id=\"p1\">](../compiler-messages/cs1614.md)</ept> for more information.","pos":[2801,2867],"source":" See [CS1614](../compiler-messages/cs1614.md) for more information."},{"pos":[2982,2990],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2994,3053],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept>","source":"[C# Reference](../../../csharp/language-reference/index.md)"},{"pos":[3056,3122],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[3125,3200],"content":"<bpt id=\"p1\">[</bpt>C# Special Characters<ept id=\"p1\">](../../../csharp/language-reference/tokens/index.md)</ept>","source":"[C# Special Characters](../../../csharp/language-reference/tokens/index.md)"}]}