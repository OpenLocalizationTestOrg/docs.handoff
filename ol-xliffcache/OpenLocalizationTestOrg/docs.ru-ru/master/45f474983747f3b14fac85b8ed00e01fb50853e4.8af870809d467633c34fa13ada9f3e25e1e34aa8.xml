{"content":"---\ntitle: \"Operators (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"operators [C#]\"\n  - \"C# language, operators\"\n  - \"operators [C#], about operators\"\nms.assetid: 214e7b83-1a41-4f7c-9867-64e9c0bab39f\ncaps.latest.revision: 42\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Operators (C# Programming Guide)\nIn C#, an *operator* is a program element that is applied to one or more *operands* in an expression or statement. Operators that take one operand, such as the increment operator (`++`) or `new`, are referred to as *unary* operators. Operators that take two operands, such as arithmetic operators (`+`,`-`,`*`,`/`), are referred to as *binary* operators. One operator, the conditional operator (`?:`), takes three operands and is the sole ternary operator in C#.  \n  \n The following C# statement contains a single unary operator and a single operand. The increment operator, `++`, modifies the value of the operand `y`.  \n  \n [!code-cs[csProgGuideStatements#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/operators_1.cs)]  \n  \n The following C# statement contains two binary operators, each with two operands. The assignment operator, `=`, has the integer variable `y` and the expression `2 + 3` as operands. The expression `2 + 3` itself consists of the addition operator and two operands, `2` and `3`.  \n  \n [!code-cs[csProgGuideStatements#6](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/operators_2.cs)]  \n  \n## Operators, Evaluation, and Operator Precedence  \n An operand can be a valid expression that is composed of any length of code, and it can comprise any number of sub expressions. In an expression that contains multiple operators, the order in which the operators are applied is determined by *operator precedence*, *associativity*, and parentheses.  \n  \n Each operator has a defined precedence. In an expression that contains multiple operators that have different precedence levels, the precedence of the operators determines the order in which the operators are evaluated. For example, the following statement assigns 3 to `n1`.  \n  \n `n1 = 11 - 2 * 4;`  \n  \n The multiplication is executed first because multiplication takes precedence over subtraction.  \n  \n The following table separates the operators into categories based on the type of operation they perform. The categories are listed in order of precedence.  \n  \n **Primary Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|x[.](../../../csharp/language-reference/operators/member-access-operator.md)y<br /><br /> x?.y|Member access<br /><br /> Conditional member access|  \n|f[(x)](../../../csharp/language-reference/operators/invocation-operator.md)|Method and delegate invocation|  \n|a[&#91;x&#93;](../../../csharp/language-reference/operators/index-operator.md)<br /><br /> a?[x]|Array and indexer access<br /><br /> Conditional array and indexer access|  \n|x[++](../../../csharp/language-reference/operators/increment-operator.md)|Post-increment|  \n|x[--](../../../csharp/language-reference/operators/decrement-operator.md)|Post-decrement|  \n|[new](../../../csharp/language-reference/keywords/new-operator.md) T(...)|Object and delegate creation|  \n|`new` T(...){...}|Object creation with initializer. See [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).|  \n|`new` {...}|Anonymous object initializer. See [Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md).|  \n|`new` T[...]|Array creation. See [Arrays](../../../csharp/programming-guide/arrays/index.md).|  \n|[typeof](../../../csharp/language-reference/keywords/typeof.md)(T)|Obtain System.Type object for T|  \n|[checked](../../../csharp/language-reference/keywords/checked.md)(x)|Evaluate expression in checked context|  \n|[unchecked](../../../csharp/language-reference/keywords/unchecked.md)(x)|Evaluate expression in unchecked context|  \n|[default](../../../csharp/language-reference/keywords/default.md) (T)|Obtain default value of type T|  \n|[delegate](../../../csharp/language-reference/keywords/delegate.md) {}|Anonymous function (anonymous method)|  \n  \n **Unary Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|[+](../../../csharp/language-reference/operators/addition-operator.md)x|Identity|  \n|[-](../../../csharp/language-reference/operators/subtraction-operator.md)x|Negation|  \n|[!](../../../csharp/language-reference/operators/logical-negation-operator.md)x|Logical negation|  \n|[~](../../../csharp/language-reference/operators/bitwise-complement-operator.md)x|Bitwise negation|  \n|[++](../../../csharp/language-reference/operators/increment-operator.md)x|Pre-increment|  \n|[--](../../../csharp/language-reference/operators/decrement-operator.md)x|Pre-decrement|  \n|[(T)](../../../csharp/language-reference/operators/invocation-operator.md)x|Explicitly convert x to type T|  \n  \n **Multiplicative Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|[*](../../../csharp/language-reference/operators/multiplication-operator.md)|Multiplication|  \n|[/](../../../csharp/language-reference/operators/division-operator.md)|Division|  \n|[%](../../../csharp/language-reference/operators/modulus-operator.md)|Remainder|  \n  \n **Additive Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|x [+](../../../csharp/language-reference/operators/addition-operator.md) y|Addition, string concatenation, delegate combination|  \n|x [-](../../../csharp/language-reference/operators/subtraction-operator.md) y|Subtraction, delegate removal|  \n  \n **Shift Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|x [<\\<](../../../csharp/language-reference/operators/left-shift-operator.md) y|Shift left|  \n|x [>>](../../../csharp/language-reference/operators/right-shift-operator.md) y|Shift right|  \n  \n **Relational and Type Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|x [\\<](../../../csharp/language-reference/operators/less-than-operator.md) y|Less than|  \n|x [>](../../../csharp/language-reference/operators/greater-than-operator.md) y|Greater than|  \n|x [\\<=](../../../csharp/language-reference/operators/less-than-equal-operator.md) y|Less than or equal|  \n|x [>=](../../../csharp/language-reference/operators/greater-than-equal-operator.md) y|Greater than or equal|  \n|x [is](../../../csharp/language-reference/keywords/is.md) T|Return true if x is a T, false otherwise|  \n|x [as](../../../csharp/language-reference/keywords/as.md) T|Return x typed as T, or null if x is not a T|  \n  \n **Equality Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|x [==](../../../csharp/language-reference/operators/equality-comparison-operator.md) y|Equal|  \n|x [!=](../../../csharp/language-reference/operators/not-equal-operator.md) y|Not equal|  \n  \n **Logical, Conditional, and Null Operators**  \n  \n|Category|Expression|Description|  \n|--------------|----------------|-----------------|  \n|Logical AND|x [&](../../../csharp/language-reference/operators/and-operator.md) y|Integer bitwise AND, Boolean logical AND|  \n|Logical XOR|x [^](../../../csharp/language-reference/operators/xor-operator.md) y|Integer bitwise XOR, boolean logical XOR|  \n|Logical OR|x [&#124;](../../../csharp/language-reference/operators/or-operator.md) y|Integer bitwise OR, boolean logical OR|  \n|Conditional AND|x [&&](../../../csharp/language-reference/operators/conditional-and-operator.md) y|Evaluates y only if x is true|  \n|Conditional OR|x [&#124;&#124;](../../../csharp/language-reference/operators/conditional-or-operator.md) y|Evaluates y only if x is false|  \n|Null coalescing|x [??](../../../csharp/language-reference/operators/null-conditional-operator.md) y|Evaluates to y if x is null, to x otherwise|  \n|Conditional|x [?](../../../csharp/language-reference/operators/conditional-operator.md) y : z|Evaluates to y if x is true, z if x is false|  \n  \n **Assignment and Anonymous Operators**  \n  \n|Expression|Description|  \n|----------------|-----------------|  \n|[=](../../../csharp/language-reference/operators/assignment-operator.md)|Assignment|  \n|x op= y|Compound assignment. Supports these operators: [+=](../../../csharp/language-reference/operators/addition-assignment-operator.md), [-=](../../../csharp/language-reference/operators/subtraction-assignment-operator.md), [*=](../../../csharp/language-reference/operators/multiplication-assignment-operator.md), [/=](../../../csharp/language-reference/operators/division-assignment-operator.md), [%=](../../../csharp/language-reference/operators/modulus-assignment-operator.md), [&=](../../../csharp/language-reference/operators/and-assignment-operator.md), [&#124;=](../../../csharp/language-reference/operators/or-assignment-operator.md), [!=](../../../csharp/language-reference/operators/not-equal-operator.md), [<\\<=](../../../csharp/language-reference/operators/left-shift-assignment-operator.md), [>>=](../../../csharp/language-reference/operators/right-shift-assignment-operator.md)|  \n|(T x) [=>](../../../csharp/language-reference/operators/lambda-operator.md) y|Anonymous function (lambda expression)|  \n  \n## Associativity  \n When two or more operators that have the same precedence are present in an expression, they are evaluated based on associativity. Left-associative operators are evaluated in order from left to right. For example, `x * y / z` is evaluated as `(x * y) / z`. Right-associative operators are evaluated in order from right to left. For example, the assignment operator is right associative. If it were not, the following code would result in an error.  \n  \n```csharp  \nint a, b, c;  \nc = 1;  \n// The following two lines are equivalent.  \na = b = c;  \na = (b = c);  \n  \n// The following line, which forces left associativity, causes an error.  \n//(a = b) = c;  \n```  \n  \n As another example the ternary operator ([?:](../../../csharp/language-reference/operators/conditional-operator.md)) is right associative. Most binary operators are left associative.  \n  \n Whether the operators in an expression are left associative or right associative, the operands of each expression are evaluated first, from left to right. The following examples illustrate the order of evaluation of operators and operands.  \n  \n|Statement|Order of evaluation|  \n|---------------|-------------------------|  \n|`a = b`|a, b, =|  \n|`a = b + c`|a, b, c, +, =|  \n|`a = b + c * d`|a, b, c, d, *, +, =|  \n|`a = b * c + d`|a, b, c, *, d, +, =|  \n|`a = b - c + d`|a, b, c, -, d, +, =|  \n|`a += b -= c`|a, b, c, -=, +=|  \n  \n## Adding Parentheses  \n You can change the order imposed by operator precedence and associativity by using parentheses. For example, `2 + 3 * 2` ordinarily evaluates to 8, because multiplicative operators take precedence over additive operators. However, if you write the expression as `(2 + 3) * 2`, the addition is evaluated before the multiplication, and the result is 10. The following examples illustrate the order of evaluation in parenthesized expressions. As in previous examples, the operands are evaluated before the operator is applied.  \n  \n|Statement|Order of evaluation|  \n|---------------|-------------------------|  \n|`a = (b + c) * d`|a, b, c, +, d, *, =|  \n|`a = b - (c + d)`|a, b, c, d, +, -, =|  \n|`a = (b + c) * (d - e)`|a, b, c, +, d, e, -, *, =|  \n  \n## Operator Overloading  \n You can change the behavior of operators for custom classes and structs. This process is referred to as *operator overloading*. For more information, see [Overloadable Operators](../../../csharp/programming-guide/statements-expressions-operators/overloadable-operators.md).  \n  \n## Related Sections  \n For more information, see [Operator Keywords](../../../csharp/language-reference/keywords/operator-keywords.md) and [C# Operators](../../../csharp/language-reference/operators/index.md).  \n  \n## See Also  \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [Statements, Expressions, and Operators](../../../csharp/programming-guide/statements-expressions-operators/index.md)\n","nodes":[{"pos":[4,618],"embed":true,"restype":"x-metadata","content":"title: \"Operators (C# Programming Guide) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\n\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"operators [C#]\"\n  - \"C# language, operators\"\n  - \"operators [C#], about operators\"\nms.assetid: 214e7b83-1a41-4f7c-9867-64e9c0bab39f\ncaps.latest.revision: 42\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\ntranslation.priority.ht: \n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"ru-ru\"\n  - \"zh-cn\"\n  - \"zh-tw\"\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"","nodes":[{"content":"Operators (C# Programming Guide) | Microsoft Docs","nodes":[{"pos":[0,49],"content":"Operators (C# Programming Guide) | Microsoft Docs","nodes":[{"content":"Operators (C# Programming Guide) | Microsoft Docs","pos":[0,49]}]}],"path":["title"]}],"yml":true},{"pos":[625,657],"content":"Operators (C# Programming Guide)","linkify":"Operators (C# Programming Guide)","nodes":[{"content":"Operators (C# Programming Guide)","pos":[0,32]}]},{"content":"In C#, an <bpt id=\"p1\">*</bpt>operator<ept id=\"p1\">*</ept> is a program element that is applied to one or more <bpt id=\"p2\">*</bpt>operands<ept id=\"p2\">*</ept> in an expression or statement.","pos":[658,772],"source":"In C#, an *operator* is a program element that is applied to one or more *operands* in an expression or statement."},{"content":"Operators that take one operand, such as the increment operator (<ph id=\"ph1\">`++`</ph>) or <ph id=\"ph2\">`new`</ph>, are referred to as <bpt id=\"p1\">*</bpt>unary<ept id=\"p1\">*</ept> operators.","pos":[773,891],"source":" Operators that take one operand, such as the increment operator (`++`) or `new`, are referred to as *unary* operators."},{"content":"Operators that take two operands, such as arithmetic operators (<ph id=\"ph1\">`+`</ph>,<ph id=\"ph2\">`-`</ph>,<ph id=\"ph3\">`*`</ph>,<ph id=\"ph4\">`/`</ph>), are referred to as <bpt id=\"p1\">*</bpt>binary<ept id=\"p1\">*</ept> operators.","pos":[892,1012],"source":" Operators that take two operands, such as arithmetic operators (`+`,`-`,`*`,`/`), are referred to as *binary* operators."},{"content":"One operator, the conditional operator (<ph id=\"ph1\">`?:`</ph>), takes three operands and is the sole ternary operator in C#.","pos":[1013,1120],"source":" One operator, the conditional operator (`?:`), takes three operands and is the sole ternary operator in C#."},{"content":"The following C# statement contains a single unary operator and a single operand.","pos":[1127,1208]},{"content":"The increment operator, <ph id=\"ph1\">`++`</ph>, modifies the value of the operand <ph id=\"ph2\">`y`</ph>.","pos":[1209,1277],"source":" The increment operator, `++`, modifies the value of the operand `y`."},{"content":"The following C# statement contains two binary operators, each with two operands.","pos":[1415,1496]},{"content":"The assignment operator, <ph id=\"ph1\">`=`</ph>, has the integer variable <ph id=\"ph2\">`y`</ph> and the expression <ph id=\"ph3\">`2 + 3`</ph> as operands.","pos":[1497,1595],"source":" The assignment operator, `=`, has the integer variable `y` and the expression `2 + 3` as operands."},{"content":"The expression <ph id=\"ph1\">`2 + 3`</ph> itself consists of the addition operator and two operands, <ph id=\"ph2\">`2`</ph> and <ph id=\"ph3\">`3`</ph>.","pos":[1596,1690],"source":" The expression `2 + 3` itself consists of the addition operator and two operands, `2` and `3`."},{"pos":[1830,1876],"content":"Operators, Evaluation, and Operator Precedence","linkify":"Operators, Evaluation, and Operator Precedence","nodes":[{"content":"Operators, Evaluation, and Operator Precedence","pos":[0,46]}]},{"content":"An operand can be a valid expression that is composed of any length of code, and it can comprise any number of sub expressions.","pos":[1880,2007]},{"content":"In an expression that contains multiple operators, the order in which the operators are applied is determined by <bpt id=\"p1\">*</bpt>operator precedence<ept id=\"p1\">*</ept>, <bpt id=\"p2\">*</bpt>associativity<ept id=\"p2\">*</ept>, and parentheses.","pos":[2008,2177],"source":" In an expression that contains multiple operators, the order in which the operators are applied is determined by *operator precedence*, *associativity*, and parentheses."},{"content":"Each operator has a defined precedence.","pos":[2184,2223]},{"content":"In an expression that contains multiple operators that have different precedence levels, the precedence of the operators determines the order in which the operators are evaluated.","pos":[2224,2403]},{"content":"For example, the following statement assigns 3 to <ph id=\"ph1\">`n1`</ph>.","pos":[2404,2459],"source":" For example, the following statement assigns 3 to `n1`."},{"content":"The multiplication is executed first because multiplication takes precedence over subtraction.","pos":[2491,2585]},{"content":"The following table separates the operators into categories based on the type of operation they perform.","pos":[2592,2696]},{"content":"The categories are listed in order of precedence.","pos":[2697,2746]},{"pos":[2753,2774],"content":"<bpt id=\"p1\">**</bpt>Primary Operators<ept id=\"p1\">**</ept>","source":"**Primary Operators**"},{"content":"Expression","pos":[2781,2791]},{"content":"Description","pos":[2792,2803]},{"content":"x<bpt id=\"p1\">[</bpt>.<ept id=\"p1\">](../../../csharp/language-reference/operators/member-access-operator.md)</ept>y","pos":[2847,2924],"source":"x[.](../../../csharp/language-reference/operators/member-access-operator.md)y"},{"content":"x?.y","pos":[2937,2941]},{"content":"Member access","pos":[2942,2955]},{"content":"Conditional member access","pos":[2968,2993]},{"pos":[2998,3073],"content":"f<bpt id=\"p1\">[</bpt>(x)<ept id=\"p1\">](../../../csharp/language-reference/operators/invocation-operator.md)</ept>","source":"f[(x)](../../../csharp/language-reference/operators/invocation-operator.md)"},{"content":"Method and delegate invocation","pos":[3074,3104]},{"content":"a<bpt id=\"p1\">[</bpt>&amp;#91;x&amp;#93;<ept id=\"p1\">](../../../csharp/language-reference/operators/index-operator.md)</ept>","pos":[3109,3187],"source":"a[&#91;x&#93;](../../../csharp/language-reference/operators/index-operator.md)"},{"content":"a?[x]","pos":[3200,3205]},{"content":"Array and indexer access","pos":[3206,3230]},{"content":"Conditional array and indexer access","pos":[3243,3279]},{"pos":[3284,3357],"content":"x<bpt id=\"p1\">[</bpt><ph id=\"ph1\">++</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/increment-operator.md)</ept>","source":"x[++](../../../csharp/language-reference/operators/increment-operator.md)"},{"content":"Post-increment","pos":[3358,3372]},{"pos":[3377,3450],"content":"x<bpt id=\"p1\">[</bpt><ph id=\"ph1\">--</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/decrement-operator.md)</ept>","source":"x[--](../../../csharp/language-reference/operators/decrement-operator.md)"},{"content":"Post-decrement","pos":[3451,3465]},{"pos":[3470,3543],"content":"<bpt id=\"p1\">[</bpt>new<ept id=\"p1\">](../../../csharp/language-reference/keywords/new-operator.md)</ept> T(...)","source":"[new](../../../csharp/language-reference/keywords/new-operator.md) T(...)"},{"content":"Object and delegate creation","pos":[3544,3572]},{"pos":[3577,3594],"content":"<ph id=\"ph1\">`new`</ph> T(...){...}","source":"`new` T(...){...}"},{"content":"Object creation with initializer.","pos":[3595,3628]},{"content":"See <bpt id=\"p1\">[</bpt>Object and Collection Initializers<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)</ept>.","pos":[3629,3763],"source":" See [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)."},{"pos":[3768,3779],"content":"<ph id=\"ph1\">`new`</ph> {...}","source":"`new` {...}"},{"content":"Anonymous object initializer.","pos":[3780,3809]},{"content":"See <bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>.","pos":[3810,3906],"source":" See [Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)."},{"pos":[3911,3923],"content":"<ph id=\"ph1\">`new`</ph> T[...]","source":"`new` T[...]"},{"content":"Array creation.","pos":[3924,3939]},{"content":"See <bpt id=\"p1\">[</bpt>Arrays<ept id=\"p1\">](../../../csharp/programming-guide/arrays/index.md)</ept>.","pos":[3940,4004],"source":" See [Arrays](../../../csharp/programming-guide/arrays/index.md)."},{"pos":[4009,4075],"content":"<bpt id=\"p1\">[</bpt>typeof<ept id=\"p1\">](../../../csharp/language-reference/keywords/typeof.md)</ept>(T)","source":"[typeof](../../../csharp/language-reference/keywords/typeof.md)(T)"},{"content":"Obtain System.Type object for T","pos":[4076,4107]},{"pos":[4112,4180],"content":"<bpt id=\"p1\">[</bpt>checked<ept id=\"p1\">](../../../csharp/language-reference/keywords/checked.md)</ept>(x)","source":"[checked](../../../csharp/language-reference/keywords/checked.md)(x)"},{"content":"Evaluate expression in checked context","pos":[4181,4219]},{"pos":[4224,4296],"content":"<bpt id=\"p1\">[</bpt>unchecked<ept id=\"p1\">](../../../csharp/language-reference/keywords/unchecked.md)</ept>(x)","source":"[unchecked](../../../csharp/language-reference/keywords/unchecked.md)(x)"},{"content":"Evaluate expression in unchecked context","pos":[4297,4337]},{"pos":[4342,4411],"content":"<bpt id=\"p1\">[</bpt>default<ept id=\"p1\">](../../../csharp/language-reference/keywords/default.md)</ept> (T)","source":"[default](../../../csharp/language-reference/keywords/default.md) (T)"},{"content":"Obtain default value of type T","pos":[4412,4442]},{"pos":[4447,4517],"content":"<bpt id=\"p1\">[</bpt>delegate<ept id=\"p1\">](../../../csharp/language-reference/keywords/delegate.md)</ept> {}","source":"[delegate](../../../csharp/language-reference/keywords/delegate.md) {}"},{"content":"Anonymous function (anonymous method)","pos":[4518,4555]},{"pos":[4563,4582],"content":"<bpt id=\"p1\">**</bpt>Unary Operators<ept id=\"p1\">**</ept>","source":"**Unary Operators**"},{"content":"Expression","pos":[4589,4599]},{"content":"Description","pos":[4600,4611]},{"pos":[4655,4726],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">+</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/addition-operator.md)</ept>x","source":"[+](../../../csharp/language-reference/operators/addition-operator.md)x"},{"content":"Identity","pos":[4727,4735]},{"pos":[4740,4814],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">-</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/subtraction-operator.md)</ept>x","source":"[-](../../../csharp/language-reference/operators/subtraction-operator.md)x"},{"content":"Negation","pos":[4815,4823]},{"pos":[4828,4907],"content":"<bpt id=\"p1\">[</bpt>!<ept id=\"p1\">](../../../csharp/language-reference/operators/logical-negation-operator.md)</ept>x","source":"[!](../../../csharp/language-reference/operators/logical-negation-operator.md)x"},{"content":"Logical negation","pos":[4908,4924]},{"pos":[4929,5010],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">~</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/bitwise-complement-operator.md)</ept>x","source":"[~](../../../csharp/language-reference/operators/bitwise-complement-operator.md)x"},{"content":"Bitwise negation","pos":[5011,5027]},{"pos":[5032,5105],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">++</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/increment-operator.md)</ept>x","source":"[++](../../../csharp/language-reference/operators/increment-operator.md)x"},{"content":"Pre-increment","pos":[5106,5119]},{"pos":[5124,5197],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">--</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/decrement-operator.md)</ept>x","source":"[--](../../../csharp/language-reference/operators/decrement-operator.md)x"},{"content":"Pre-decrement","pos":[5198,5211]},{"pos":[5216,5291],"content":"<bpt id=\"p1\">[</bpt>(T)<ept id=\"p1\">](../../../csharp/language-reference/operators/invocation-operator.md)</ept>x","source":"[(T)](../../../csharp/language-reference/operators/invocation-operator.md)x"},{"content":"Explicitly convert x to type T","pos":[5292,5322]},{"pos":[5330,5358],"content":"<bpt id=\"p1\">**</bpt>Multiplicative Operators<ept id=\"p1\">**</ept>","source":"**Multiplicative Operators**"},{"content":"Expression","pos":[5365,5375]},{"content":"Description","pos":[5376,5387]},{"content":"Multiplication","pos":[5508,5522]},{"content":"Division","pos":[5598,5606]},{"content":"Remainder","pos":[5681,5690]},{"pos":[5698,5720],"content":"<bpt id=\"p1\">**</bpt>Additive Operators<ept id=\"p1\">**</ept>","source":"**Additive Operators**"},{"content":"Expression","pos":[5727,5737]},{"content":"Description","pos":[5738,5749]},{"pos":[5793,5867],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">+</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/addition-operator.md)</ept> y","source":"x [+](../../../csharp/language-reference/operators/addition-operator.md) y"},{"content":"Addition, string concatenation, delegate combination","pos":[5868,5920]},{"pos":[5925,6002],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">-</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/subtraction-operator.md)</ept> y","source":"x [-](../../../csharp/language-reference/operators/subtraction-operator.md) y"},{"content":"Subtraction, delegate removal","pos":[6003,6032]},{"pos":[6040,6059],"content":"<bpt id=\"p1\">**</bpt>Shift Operators<ept id=\"p1\">**</ept>","source":"**Shift Operators**"},{"content":"Expression","pos":[6066,6076]},{"content":"Description","pos":[6077,6088]},{"pos":[6132,6210],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&lt;</ph><ph id=\"ph2\">\\&lt;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/left-shift-operator.md)</ept> y","source":"x [<\\<](../../../csharp/language-reference/operators/left-shift-operator.md) y"},{"content":"Shift left","pos":[6211,6221]},{"pos":[6226,6304],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&gt;&gt;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/right-shift-operator.md)</ept> y","source":"x [>>](../../../csharp/language-reference/operators/right-shift-operator.md) y"},{"content":"Shift right","pos":[6305,6316]},{"pos":[6324,6357],"content":"<bpt id=\"p1\">**</bpt>Relational and Type Operators<ept id=\"p1\">**</ept>","source":"**Relational and Type Operators**"},{"content":"Expression","pos":[6364,6374]},{"content":"Description","pos":[6375,6386]},{"pos":[6430,6506],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/less-than-operator.md)</ept> y","source":"x [\\<](../../../csharp/language-reference/operators/less-than-operator.md) y"},{"content":"Less than","pos":[6507,6516]},{"pos":[6521,6599],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&gt;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/greater-than-operator.md)</ept> y","source":"x [>](../../../csharp/language-reference/operators/greater-than-operator.md) y"},{"content":"Greater than","pos":[6600,6612]},{"pos":[6617,6700],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph><ph id=\"ph2\">=</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/less-than-equal-operator.md)</ept> y","source":"x [\\<=](../../../csharp/language-reference/operators/less-than-equal-operator.md) y"},{"content":"Less than or equal","pos":[6701,6719]},{"pos":[6724,6809],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&gt;=</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/greater-than-equal-operator.md)</ept> y","source":"x [>=](../../../csharp/language-reference/operators/greater-than-equal-operator.md) y"},{"content":"Greater than or equal","pos":[6810,6831]},{"pos":[6836,6895],"content":"x <bpt id=\"p1\">[</bpt>is<ept id=\"p1\">](../../../csharp/language-reference/keywords/is.md)</ept> T","source":"x [is](../../../csharp/language-reference/keywords/is.md) T"},{"content":"Return true if x is a T, false otherwise","pos":[6896,6936]},{"pos":[6941,7000],"content":"x <bpt id=\"p1\">[</bpt>as<ept id=\"p1\">](../../../csharp/language-reference/keywords/as.md)</ept> T","source":"x [as](../../../csharp/language-reference/keywords/as.md) T"},{"content":"Return x typed as T, or null if x is not a T","pos":[7001,7045]},{"pos":[7053,7075],"content":"<bpt id=\"p1\">**</bpt>Equality Operators<ept id=\"p1\">**</ept>","source":"**Equality Operators**"},{"content":"Expression","pos":[7082,7092]},{"content":"Description","pos":[7093,7104]},{"pos":[7148,7234],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">==</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/equality-comparison-operator.md)</ept> y","source":"x [==](../../../csharp/language-reference/operators/equality-comparison-operator.md) y"},{"content":"Equal","pos":[7235,7240]},{"pos":[7245,7321],"content":"x <bpt id=\"p1\">[</bpt>!=<ept id=\"p1\">](../../../csharp/language-reference/operators/not-equal-operator.md)</ept> y","source":"x [!=](../../../csharp/language-reference/operators/not-equal-operator.md) y"},{"content":"Not equal","pos":[7322,7331]},{"pos":[7339,7383],"content":"<bpt id=\"p1\">**</bpt>Logical, Conditional, and Null Operators<ept id=\"p1\">**</ept>","source":"**Logical, Conditional, and Null Operators**"},{"content":"Category","pos":[7390,7398]},{"content":"Expression","pos":[7399,7409]},{"content":"Description","pos":[7410,7421]},{"content":"Logical AND","pos":[7480,7491]},{"pos":[7492,7561],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&amp;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/and-operator.md)</ept> y","source":"x [&](../../../csharp/language-reference/operators/and-operator.md) y"},{"content":"Integer bitwise AND, Boolean logical AND","pos":[7562,7602]},{"content":"Logical XOR","pos":[7607,7618]},{"pos":[7619,7688],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">^</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/xor-operator.md)</ept> y","source":"x [^](../../../csharp/language-reference/operators/xor-operator.md) y"},{"content":"Integer bitwise XOR, boolean logical XOR","pos":[7689,7729]},{"content":"Logical OR","pos":[7734,7744]},{"pos":[7745,7818],"content":"x <bpt id=\"p1\">[</bpt>&amp;#124;<ept id=\"p1\">](../../../csharp/language-reference/operators/or-operator.md)</ept> y","source":"x [&#124;](../../../csharp/language-reference/operators/or-operator.md) y"},{"content":"Integer bitwise OR, boolean logical OR","pos":[7819,7857]},{"content":"Conditional AND","pos":[7862,7877]},{"pos":[7878,7960],"content":"x <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&amp;&amp;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/conditional-and-operator.md)</ept> y","source":"x [&&](../../../csharp/language-reference/operators/conditional-and-operator.md) y"},{"content":"Evaluates y only if x is true","pos":[7961,7990]},{"content":"Conditional OR","pos":[7995,8009]},{"pos":[8010,8101],"content":"x <bpt id=\"p1\">[</bpt>&amp;#124;&amp;#124;<ept id=\"p1\">](../../../csharp/language-reference/operators/conditional-or-operator.md)</ept> y","source":"x [&#124;&#124;](../../../csharp/language-reference/operators/conditional-or-operator.md) y"},{"content":"Evaluates y only if x is false","pos":[8102,8132]},{"content":"Null coalescing","pos":[8137,8152]},{"content":"x <bpt id=\"p1\">[</bpt>??<ept id=\"p1\">](../../../csharp/language-reference/operators/null-conditional-operator.md)</ept>","pos":[8153,8234],"source":"x [??](../../../csharp/language-reference/operators/null-conditional-operator.md)"},{"content":"y","pos":[8235,8236]},{"content":"Evaluates to y if x is null, to x otherwise","pos":[8237,8280]},{"content":"Conditional","pos":[8285,8296]},{"content":"x <bpt id=\"p1\">[</bpt>?<ept id=\"p1\">](../../../csharp/language-reference/operators/conditional-operator.md)</ept>","pos":[8297,8372],"source":"x [?](../../../csharp/language-reference/operators/conditional-operator.md)"},{"content":"y : z","pos":[8373,8378]},{"content":"Evaluates to y if x is true, z if x is false","pos":[8379,8423]},{"pos":[8431,8469],"content":"<bpt id=\"p1\">**</bpt>Assignment and Anonymous Operators<ept id=\"p1\">**</ept>","source":"**Assignment and Anonymous Operators**"},{"content":"Expression","pos":[8476,8486]},{"content":"Description","pos":[8487,8498]},{"content":"Assignment","pos":[8615,8625]},{"content":"x op= y","pos":[8630,8637]},{"content":"Compound assignment.","pos":[8638,8658]},{"content":"Supports these operators: <bpt id=\"p1\">[</bpt><ph id=\"ph1\">+=</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/addition-assignment-operator.md)</ept>, <bpt id=\"p2\">[</bpt><ph id=\"ph2\">-=</ph><ept id=\"p2\">](../../../csharp/language-reference/operators/subtraction-assignment-operator.md)</ept>, <bpt id=\"p3\">[</bpt><ph id=\"ph3\">*=</ph><ept id=\"p3\">](../../../csharp/language-reference/operators/multiplication-assignment-operator.md)</ept>, <bpt id=\"p4\">[</bpt><ph id=\"ph4\">/=</ph><ept id=\"p4\">](../../../csharp/language-reference/operators/division-assignment-operator.md)</ept>, <bpt id=\"p5\">[</bpt><ph id=\"ph5\">%=</ph><ept id=\"p5\">](../../../csharp/language-reference/operators/modulus-assignment-operator.md)</ept>, <bpt id=\"p6\">[</bpt><ph id=\"ph6\">&amp;=</ph><ept id=\"p6\">](../../../csharp/language-reference/operators/and-assignment-operator.md)</ept>, <bpt id=\"p7\">[</bpt>&amp;#124;=<ept id=\"p7\">](../../../csharp/language-reference/operators/or-assignment-operator.md)</ept>, <bpt id=\"p8\">[</bpt>!=<ept id=\"p8\">](../../../csharp/language-reference/operators/not-equal-operator.md)</ept>, <bpt id=\"p9\">[</bpt><ph id=\"ph7\">&lt;</ph><ph id=\"ph8\">\\&lt;</ph><ph id=\"ph9\">=</ph><ept id=\"p9\">](../../../csharp/language-reference/operators/left-shift-assignment-operator.md)</ept>, <bpt id=\"p10\">[</bpt><ph id=\"ph10\">&gt;&gt;=</ph><ept id=\"p10\">](../../../csharp/language-reference/operators/right-shift-assignment-operator.md)</ept>","pos":[8659,9523],"source":" Supports these operators: [+=](../../../csharp/language-reference/operators/addition-assignment-operator.md), [-=](../../../csharp/language-reference/operators/subtraction-assignment-operator.md), [*=](../../../csharp/language-reference/operators/multiplication-assignment-operator.md), [/=](../../../csharp/language-reference/operators/division-assignment-operator.md), [%=](../../../csharp/language-reference/operators/modulus-assignment-operator.md), [&=](../../../csharp/language-reference/operators/and-assignment-operator.md), [&#124;=](../../../csharp/language-reference/operators/or-assignment-operator.md), [!=](../../../csharp/language-reference/operators/not-equal-operator.md), [<\\<=](../../../csharp/language-reference/operators/left-shift-assignment-operator.md), [>>=](../../../csharp/language-reference/operators/right-shift-assignment-operator.md)"},{"pos":[9528,9605],"content":"(T x) <bpt id=\"p1\">[</bpt><ph id=\"ph1\">=&gt;</ph><ept id=\"p1\">](../../../csharp/language-reference/operators/lambda-operator.md)</ept> y","source":"(T x) [=>](../../../csharp/language-reference/operators/lambda-operator.md) y"},{"content":"Anonymous function (lambda expression)","pos":[9606,9644]},{"pos":[9654,9667],"content":"Associativity","linkify":"Associativity","nodes":[{"content":"Associativity","pos":[0,13]}]},{"content":"When two or more operators that have the same precedence are present in an expression, they are evaluated based on associativity.","pos":[9671,9800]},{"content":"Left-associative operators are evaluated in order from left to right.","pos":[9801,9870]},{"content":"For example, <ph id=\"ph1\">`x * y / z`</ph> is evaluated as <ph id=\"ph2\">`(x * y) / z`</ph>.","pos":[9871,9926],"source":" For example, `x * y / z` is evaluated as `(x * y) / z`."},{"content":"Right-associative operators are evaluated in order from right to left.","pos":[9927,9997]},{"content":"For example, the assignment operator is right associative.","pos":[9998,10056]},{"content":"If it were not, the following code would result in an error.","pos":[10057,10117]},{"content":"As another example the ternary operator (<bpt id=\"p1\">[</bpt>?:<ept id=\"p1\">](../../../csharp/language-reference/operators/conditional-operator.md)</ept>) is right associative.","pos":[10337,10475],"source":"As another example the ternary operator ([?:](../../../csharp/language-reference/operators/conditional-operator.md)) is right associative."},{"content":"Most binary operators are left associative.","pos":[10476,10519]},{"content":"Whether the operators in an expression are left associative or right associative, the operands of each expression are evaluated first, from left to right.","pos":[10526,10680]},{"content":"The following examples illustrate the order of evaluation of operators and operands.","pos":[10681,10765]},{"content":"Statement","pos":[10772,10781]},{"content":"Order of evaluation","pos":[10782,10801]},{"content":"a, b, =","pos":[10860,10867]},{"content":"a, b, c, +, =","pos":[10884,10897]},{"content":"a, b, c, d, *, +, =","pos":[10918,10937]},{"content":"a, b, c, *, d, +, =","pos":[10958,10977]},{"content":"a, b, c, -, d, +, =","pos":[10998,11017]},{"content":"a, b, c, -=, +=","pos":[11036,11051]},{"pos":[11061,11079],"content":"Adding Parentheses","linkify":"Adding Parentheses","nodes":[{"content":"Adding Parentheses","pos":[0,18]}]},{"content":"You can change the order imposed by operator precedence and associativity by using parentheses.","pos":[11083,11178]},{"content":"For example, <ph id=\"ph1\">`2 + 3 * 2`</ph> ordinarily evaluates to 8, because multiplicative operators take precedence over additive operators.","pos":[11179,11304],"source":" For example, `2 + 3 * 2` ordinarily evaluates to 8, because multiplicative operators take precedence over additive operators."},{"content":"However, if you write the expression as <ph id=\"ph1\">`(2 + 3) * 2`</ph>, the addition is evaluated before the multiplication, and the result is 10.","pos":[11305,11434],"source":" However, if you write the expression as `(2 + 3) * 2`, the addition is evaluated before the multiplication, and the result is 10."},{"content":"The following examples illustrate the order of evaluation in parenthesized expressions.","pos":[11435,11522]},{"content":"As in previous examples, the operands are evaluated before the operator is applied.","pos":[11523,11606]},{"content":"Statement","pos":[11613,11622]},{"content":"Order of evaluation","pos":[11623,11642]},{"content":"a, b, c, +, d, *, =","pos":[11711,11730]},{"content":"a, b, c, d, +, -, =","pos":[11753,11772]},{"content":"a, b, c, +, d, e, -, *, =","pos":[11801,11826]},{"pos":[11836,11856],"content":"Operator Overloading","linkify":"Operator Overloading","nodes":[{"content":"Operator Overloading","pos":[0,20]}]},{"content":"You can change the behavior of operators for custom classes and structs.","pos":[11860,11932]},{"content":"This process is referred to as <bpt id=\"p1\">*</bpt>operator overloading<ept id=\"p1\">*</ept>.","pos":[11933,11987],"source":" This process is referred to as *operator overloading*."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Overloadable Operators<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/overloadable-operators.md)</ept>.","pos":[11988,12133],"source":" For more information, see [Overloadable Operators](../../../csharp/programming-guide/statements-expressions-operators/overloadable-operators.md)."},{"pos":[12142,12158],"content":"Related Sections","linkify":"Related Sections","nodes":[{"content":"Related Sections","pos":[0,16]}]},{"pos":[12162,12348],"content":"For more information, see <bpt id=\"p1\">[</bpt>Operator Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/operator-keywords.md)</ept> and <bpt id=\"p2\">[</bpt>C# Operators<ept id=\"p2\">](../../../csharp/language-reference/operators/index.md)</ept>.","source":"For more information, see [Operator Keywords](../../../csharp/language-reference/keywords/operator-keywords.md) and [C# Operators](../../../csharp/language-reference/operators/index.md)."},{"pos":[12357,12365],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[12369,12436],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Statements, Expressions, and Operators<ept id=\"p1\">](../../../csharp/programming-guide/statements-expressions-operators/index.md)</ept>","pos":[12440,12557],"source":"[Statements, Expressions, and Operators](../../../csharp/programming-guide/statements-expressions-operators/index.md)"}]}