{"content":"---\ntitle: \"Dependency Property Value Precedence | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"dependency properties, classes as owners\"\n  - \"dependency properties, metadata\"\n  - \"classes, owners of dependency properties\"\n  - \"metadata, dependency properties\"\nms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc\ncaps.latest.revision: 27\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Dependency Property Value Precedence\n<a name=\"introduction\"></a> This topic explains how the workings of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system can affect the value of a dependency property, and describes the precedence by which aspects of the property system apply to the effective value of a property.  \n    \n  \n<a name=\"prerequisites\"></a>   \n## Prerequisites  \n This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md). To follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.  \n  \n<a name=\"intro\"></a>   \n## The WPF Property System  \n The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system offers a powerful way to have the value of dependency properties be determined by a variety of factors, enabling features such as real-time property validation, late binding, and notifying related properties of changes to values for other properties. The exact order and logic that is used to determine dependency property values is reasonably complex. Knowing this order will help you avoid unnecessary property setting, and might also clear up confusion over exactly why some attempt to influence or anticipate a dependency property value did not end up resulting in the value you expected.  \n  \n<a name=\"multiple_sets\"></a>   \n## Dependency Properties Might Be \"Set\" in Multiple Places  \n The following is example [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] where the same property (<xref:System.Windows.Controls.Control.Background%2A>) has three different \"set\" operations that might influence the value.  \n  \n [!code-xml[PropertiesOvwSupport#DPPrecedence](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  \n  \n Here, which color do you expect will applyâ€”red, green, or blue?  \n  \n With the exception of animated values and coercion, local property sets are set at the highest precedence. If you set a value locally you can expect that the value will be honored, even above any styles or control templates. Here in the example, <xref:System.Windows.Controls.Control.Background%2A> is set to Red locally. Therefore, the style defined in this scope, even though it is an implicit style that would otherwise apply to all elements of that type in that scope, is not the highest precedence for giving the <xref:System.Windows.Controls.Control.Background%2A> property its value.  If you removed the local value of Red from that Button instance, then the style would have precedence and the button would obtain the Background value from the style.  Within the style, triggers take precedence, so the button will be blue if the mouse is over it, and green otherwise.  \n  \n<a name=\"listing\"></a>   \n## Dependency Property Setting Precedence List  \n The following is the definitive order that the property system uses when assigning the run-time values of dependency properties. Highest precedence is listed first. This list expands on some of the generalizations made in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).  \n  \n1.  **Property system coercion.** For details on coercion, see [Coercion, Animation, and Base Value](#animations) later in this topic.  \n  \n2.  **Active animations, or animations with a Hold behavior.** In order to have any practical effect, an animation of a property must be able to have precedence over the base (unanimated) value, even if that value was set locally. For details, see [Coercion, Animation, and Base Value](#animations) later in this topic.  \n  \n3.  **Local value.** A local value might be set through the convenience of the \"wrapper\" property, which also equates to setting as an attribute or property element in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or by a call to the <xref:System.Windows.DependencyObject.SetValue%2A> [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] using a property of a specific instance. If you set a local value by using a binding or a resource, these each act in the precedence as if a direct value was set.  \n  \n4.  **TemplatedParent template properties.** An element has a <xref:System.Windows.FrameworkElement.TemplatedParent%2A> if it was created as part of a template (a <xref:System.Windows.Controls.ControlTemplate> or <xref:System.Windows.DataTemplate>). For details on when this applies, see [TemplatedParent](#templatedparent) later in this topic. Within the template, the following precedence applies:  \n  \n    1.  Triggers from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.  \n  \n    2.  Property sets (typically through [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes) in the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.  \n  \n5.  **Implicit style.** Applies only to the `Style` property. The `Style` property is filled by any style resource with a key that matches the type of that element. That style resource must exist either in the page or the application; lookup for an implicit style resource does not proceed into the themes.  \n  \n6.  **Style triggers.** The triggers within styles from page or application (these styles might be either explicit or implicit styles, but not from the default styles, which have lower precedence).  \n  \n7.  **Template triggers.** Any trigger from a template within a style, or a directly applied template.  \n  \n8.  **Style setters.** Values from a <xref:System.Windows.Setter> within styles from page or application.  \n  \n9. **Default (theme) style.** For details on when this applies, and how theme styles relate to the templates within theme styles, see [Default (Theme) Styles](#themestyles) later in this topic. Within a default style, the following order of precedence applies:  \n  \n    1.  Active triggers in the theme style.  \n  \n    2.  Setters in the theme style.  \n  \n10. **Inheritance.** A few dependency properties inherit their values from parent element to child elements, such that they need not be set specifically on each element throughout an application. For details see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  \n  \n11. **Default value from dependency property metadata.** Any given dependency property may have a default value as established by the property system registration of that particular property. Also, derived classes that inherit a dependency property have the option to override that metadata (including the default value) on a per-type basis. See [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for more information. Because inheritance is checked before default value, for an inherited property, a parent element default value takes precedence over a child element.  Consequently, if an inheritable property is not set anywhere, the default value as specified on the root or parent is used instead of the child element default value.  \n  \n<a name=\"templatedparent\"></a>   \n## TemplatedParent  \n TemplatedParent as a precedence item does not apply to any property of an element that you declare directly in standard application markup. The TemplatedParent concept exists only for child items within a visual tree that come into existence through the application of the template. When the property system searches the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template for a value, it is searching the template that created that element. The property values from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template generally act as if they were set as a local value on the child element, but this lesser precedence versus the local value exists because the templates are potentially shared. For details, see <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  \n  \n<a name=\"style_property\"></a>   \n## The Style Property  \n The order of lookup described earlier applies to all possible dependency properties except one: the <xref:System.Windows.FrameworkElement.Style%2A> property. The <xref:System.Windows.FrameworkElement.Style%2A> property is unique in that it cannot itself be styled, so the precedence items 5 through 8 do not apply. Also, either animating or coercing <xref:System.Windows.FrameworkElement.Style%2A> is not recommended (and animating <xref:System.Windows.FrameworkElement.Style%2A> would require a custom animation class). This leaves three ways that the <xref:System.Windows.FrameworkElement.Style%2A> property might be set:  \n  \n-   **Explicit style.** The <xref:System.Windows.FrameworkElement.Style%2A> property is set directly. In most scenarios, the style is not defined inline, but instead is referenced as a resource, by explicit key. In this case the Style property itself acts as if it were a local value, precedence item 3.  \n  \n-   **Implicit style.** The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly. However, the <xref:System.Windows.FrameworkElement.Style%2A> exists at some level in the resource lookup sequence (page, application) and is keyed using a resource key that matches the type the style is to be applied to. In this case, the <xref:System.Windows.FrameworkElement.Style%2A> property itself acts by a precedence identified in the sequence as item 5. This condition can be detected by using <xref:System.Windows.DependencyPropertyHelper> against the <xref:System.Windows.FrameworkElement.Style%2A> property and looking for <xref:System.Windows.BaseValueSource> in the results.  \n  \n-   **Default style**, also known as **theme style.** The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly, and in fact will read as `null` up until run time. In this case, the style comes from the run-time theme evaluation that is part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation engine.  \n  \n For implicit styles not in themes, the type must match exactlyâ€”a `MyButton``Button`-derived class will not implicitly use a style for `Button`.  \n  \n<a name=\"themestyles\"></a>   \n## Default (Theme) Styles  \n Every control that ships with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a default style. That default style potentially varies by theme, which is why this default style is sometimes referred to as a theme style.  \n  \n The most important information that is found within a default style for a control is its control template, which exists in the theme style as a setter for its <xref:System.Windows.Controls.Control.Template%2A> property. If there were no template from default styles, a control without a custom template as part of a custom style would have no visual appearance at all. The template from the default style gives the visual appearance of each control a basic structure, and also defines the connections between properties defined in the visual tree of the template and the corresponding control class. Each control exposes a set of properties that can influence the visual appearance of the control without completely replacing the template. For example, consider the default visual appearance of a <xref:System.Windows.Controls.Primitives.Thumb> control, which is a component of a <xref:System.Windows.Controls.Primitives.ScrollBar>.  \n  \n A <xref:System.Windows.Controls.Primitives.Thumb> has certain customizable properties. The default template of a <xref:System.Windows.Controls.Primitives.Thumb> creates a basic stucture / visual tree with several nested <xref:System.Windows.Controls.Border> components to create a bevel look. If a property that is part of the template is intended to be exposed for customization by the <xref:System.Windows.Controls.Primitives.Thumb> class, then that property must be exposed by a [TemplateBinding](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md), within the template. In the case of <xref:System.Windows.Controls.Primitives.Thumb>, various properties of these borders share a template binding to properties such as <xref:System.Windows.Controls.Border.Background%2A> or <xref:System.Windows.Controls.Border.BorderThickness%2A>. But certain other properties or visual arrangements are hard-coded into the control template or are bound to values that come directly from the theme, and cannot be changed short of replacing the entire template. Generally, if a property comes from a templated parent and is not exposed by a template binding, it cannot be adjusted by styles because there is no easy way to target it. But that property could still be influenced by property value inheritance in the applied template, or by default value.  \n  \n The theme styles use a type as the key in their definitions. However, when themes are applied to a given element instance, themes lookup for this type is performed by checking the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> property on a control. This is in contrast to using the literal Type, as implicit styles do. The value of <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> would inherit to derived classes even if the implementer did not change it (the intended way of changing the property is not to override it at the property level, but to instead change its default value in property metadata). This indirection enables base classes to define the theme styles for derived elements that do not otherwise have a style (or more importantly, do not have a template within that style and would thus have no default visual appearance at all). Thus, you can derive `MyButton` from <xref:System.Windows.Controls.Button> and will still get the <xref:System.Windows.Controls.Button> default template. If you were the control author of `MyButton` and you wanted a different behavior, you could override the dependency property metadata for <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> on `MyButton` to return a different key, and then define the relevant theme styles including template for `MyButton` that you must package with your `MyButton` control. For more details on themes, styles, and control authoring, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).  \n  \n<a name=\"resources\"></a>   \n## Dynamic Resource References and Binding  \n Dynamic resource references and binding operations respect the precedence of the location at which they are set. For example, a dynamic resource applied to a local value acts per precedence item 3, a binding for a property setter within a theme style applies at precedence item 9, and so on. Because dynamic resource references and binding must both be able to obtain values from the run time state of the application, this entails that the actual process of determining the property value precedence for any given property extends into the run time as well.  \n  \n Dynamic resource references are not strictly speaking part of the property system, but they do have a lookup order of their own which interacts with the sequence listed above. That precedence is documented more thoroughly in the [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md). The basic summation of that precedence is: element to page root, application, theme, system.  \n  \n Dynamic resources and bindings have the precedence of where they were set, but the value is deferred. One consequence of this is that if you set a dynamic resource or binding to a local value, any change to the local value replaces the dynamic resource or binding entirely. Even if you call the <xref:System.Windows.DependencyObject.ClearValue%2A> method to clear the locally set value, the dynamic resource or binding will not be restored. In fact, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property that has a dynamic resource or binding in place (with no literal local value), they are cleared by the <xref:System.Windows.DependencyObject.ClearValue%2A> call too.  \n  \n<a name=\"setcurrentvalue\"></a>   \n## SetCurrentValue  \n The <xref:System.Windows.DependencyObject.SetCurrentValue%2A> method is another way to set a property, but it is not in the order of precedence. Instead, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the value of a property without overwriting the source of a previous value. You can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> any time that you want to set a value without giving that value the precedence of a local value. For example, if a property is set by a trigger and then assigned another value via <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, the property system still respects the trigger and the property will change if the triggerâ€™s action occurs. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the propertyâ€™s value without giving it a source with a higher precedence. Likewise, you can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> to change the value of a property without overwriting a binding.  \n  \n<a name=\"animations\"></a>   \n## Coercion, Animations, and Base Value  \n Coercion and animation both act on a value that is termed as the \"base value\" throughout this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]. The base value is thus whatever value is determined through evaluating upwards in the items until item 2 is reached.  \n  \n For an animation, the base value can have an effect on the animated value, if that animation does not specify both \"From\" and \"To\" for certain behaviors, or if the animation deliberately reverts to the base value when completed. To see this in practice, run the [From, To, and By Animation Target Values Sample](http://go.microsoft.com/fwlink/?LinkID=159988). Try setting the local values of the rectangle height in the example, such that the initial local value differs from any \"From\" in the animation. You will note that the animations start right away using the \"From\" values and replace the base value once started. The animation might specify to return to the value found before animation once it is completed by specifying the Stop <xref:System.Windows.Media.Animation.FillBehavior>. Afterwards, normal precedence is used for the base value determination.  \n  \n Multiple animations might be applied to a single property, with each of these animations possibly having been defined from different points in the value precedence. However, these animations will potentially composite their values, rather than just applying the animation from the higher precedence. This depends on exactly how the animations are defined, and the type of the value that is being animated. For more information about animating properties, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).  \n  \n Coercion applies at the highest level of all. Even an already running animation is subject to value coercion. Certain existing dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have built-in coercion. For a custom dependency property, you define the coercion behavior for a custom dependency property by writing a <xref:System.Windows.CoerceValueCallback> and passing the callback as part of metadata when you create the property. You can also override coercion behavior of existing properties by overriding the metadata on that property in a derived class. Coercion interacts with the base value in such a way that the constraints on coercion are applied as those constraints exist at the time, but the base value is still retained. Therefore, if constraints in coercion are later lifted, the coercion will return the closest value possible to that base value, and potentially the coercion influence on a property will cease as soon as all constraints are lifted. For more information about coercion behavior, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  \n  \n<a name=\"triggers\"></a>   \n## Trigger Behaviors  \n Controls often define trigger behaviors as part of their default style in themes. Setting local properties on controls might prevent the triggers from being able to respond to user-driven events either visually or behaviorally. The most common use of a property trigger is for control or state properties such as <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>. For example, by default when a <xref:System.Windows.Controls.Button> is disabled (trigger for <xref:System.Windows.UIElement.IsEnabled%2A> is `false`) then the <xref:System.Windows.Controls.Control.Foreground%2A> value in the theme style is what causes the control to appear \"grayed out\". But if you have set a local <xref:System.Windows.Controls.Control.Foreground%2A> value, that normal gray-out color will be overruled in precedence by your local property set, even in this property-triggered scenario. Be cautious of setting values for properties that have theme-level trigger behaviors and make sure you are not unduly interfering with the intended user experience for that control.  \n  \n<a name=\"clearvalue\"></a>   \n## ClearValue and Value Precedence  \n The <xref:System.Windows.DependencyObject.ClearValue%2A> method provides an expedient means to clear any locally applied value from a dependency property that is set on an element. However, calling <xref:System.Windows.DependencyObject.ClearValue%2A> is not a guarantee that the default as established in metadata during property registration is the new effective value. All of the other participants in value precedence are still active. Only the locally set value has been removed from the precedence sequence. For example, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property where that property is also set by a theme style, then the theme value is applied as the new value rather than the metadata-based default. If you want to take all property value participants out of the process and set the value to the registered metadata default, you can obtain that default value definitively by querying the dependency property metadata, and then you can use the default value to locally set the property with a call to <xref:System.Windows.DependencyObject.SetValue%2A>.  \n  \n## See Also  \n <xref:System.Windows.DependencyObject>   \n <xref:System.Windows.DependencyProperty>   \n [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   \n [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)   \n [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)","nodes":[{"pos":[4,558],"nodes":[{"content":"Dependency Property Value Precedence | Microsoft Docs","nodes":[{"pos":[0,53],"content":"Dependency Property Value Precedence | Microsoft Docs","nodes":[{"content":"Dependency Property Value Precedence | Microsoft Docs","pos":[0,53]}]}],"pos":[6,62],"yaml":true}],"content":"title: \"Dependency Property Value Precedence | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"dependency properties, classes as owners\"\n  - \"dependency properties, metadata\"\n  - \"classes, owners of dependency properties\"\n  - \"metadata, dependency properties\"\nms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc\ncaps.latest.revision: 27\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","yamlblock":true},{"pos":[565,601],"content":"Dependency Property Value Precedence","linkify":"Dependency Property Value Precedence","nodes":[{"content":"Dependency Property Value Precedence","pos":[0,36]}]},{"pos":[602,929],"content":"<bpt id=\"p1\">&lt;a name=\"introduction\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> This topic explains how the workings of the <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> property system can affect the value of a dependency property, and describes the precedence by which aspects of the property system apply to the effective value of a property.","source":"<a name=\"introduction\"></a> This topic explains how the workings of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system can affect the value of a dependency property, and describes the precedence by which aspects of the property system apply to the effective value of a property."},{"pos":[975,988],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> classes, and have read <bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.","pos":[992,1338],"source":"This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)."},{"content":"To follow the examples in this topic, you should also understand <ph id=\"ph1\">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph> and know how to write <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications.","pos":[1339,1591],"source":" To follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications."},{"pos":[1624,1647],"content":"The WPF Property System","linkify":"The WPF Property System","nodes":[{"content":"The WPF Property System","pos":[0,23]}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system offers a powerful way to have the value of dependency properties be determined by a variety of factors, enabling features such as real-time property validation, late binding, and notifying related properties of changes to values for other properties.","pos":[1651,2003],"source":"The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system offers a powerful way to have the value of dependency properties be determined by a variety of factors, enabling features such as real-time property validation, late binding, and notifying related properties of changes to values for other properties."},{"content":"The exact order and logic that is used to determine dependency property values is reasonably complex.","pos":[2004,2105]},{"content":"Knowing this order will help you avoid unnecessary property setting, and might also clear up confusion over exactly why some attempt to influence or anticipate a dependency property value did not end up resulting in the value you expected.","pos":[2106,2345]},{"pos":[2386,2441],"content":"Dependency Properties Might Be \"Set\" in Multiple Places","linkify":"Dependency Properties Might Be \"Set\" in Multiple Places","nodes":[{"content":"Dependency Properties Might Be \"Set\" in Multiple Places","pos":[0,55]}]},{"pos":[2445,2689],"content":"The following is example <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> where the same property (<ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph>) has three different \"set\" operations that might influence the value.","source":"The following is example [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] where the same property (<xref:System.Windows.Controls.Control.Background%2A>) has three different \"set\" operations that might influence the value."},{"pos":[2696,2847],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>PropertiesOvwSupport#DPPrecedence<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[PropertiesOvwSupport#DPPrecedence](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]"},{"content":"Here, which color do you expect will applyâ€”red, green, or blue?","pos":[2854,2917]},{"content":"With the exception of animated values and coercion, local property sets are set at the highest precedence.","pos":[2924,3030]},{"content":"If you set a value locally you can expect that the value will be honored, even above any styles or control templates.","pos":[3031,3148]},{"content":"Here in the example, <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> is set to Red locally.","pos":[3149,3245],"source":" Here in the example, <xref:System.Windows.Controls.Control.Background%2A> is set to Red locally."},{"content":"Therefore, the style defined in this scope, even though it is an implicit style that would otherwise apply to all elements of that type in that scope, is not the highest precedence for giving the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> property its value.","pos":[3246,3514],"source":" Therefore, the style defined in this scope, even though it is an implicit style that would otherwise apply to all elements of that type in that scope, is not the highest precedence for giving the <xref:System.Windows.Controls.Control.Background%2A> property its value."},{"content":"If you removed the local value of Red from that Button instance, then the style would have precedence and the button would obtain the Background value from the style.","pos":[3516,3682]},{"content":"Within the style, triggers take precedence, so the button will be blue if the mouse is over it, and green otherwise.","pos":[3684,3800]},{"pos":[3835,3878],"content":"Dependency Property Setting Precedence List","linkify":"Dependency Property Setting Precedence List","nodes":[{"content":"Dependency Property Setting Precedence List","pos":[0,43]}]},{"content":"The following is the definitive order that the property system uses when assigning the run-time values of dependency properties.","pos":[3882,4010]},{"content":"Highest precedence is listed first.","pos":[4011,4046]},{"content":"This list expands on some of the generalizations made in the <bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.","pos":[4047,4216],"source":" This list expands on some of the generalizations made in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)."},{"content":"<bpt id=\"p1\">**</bpt>Property system coercion.<ept id=\"p1\">**</ept>","pos":[4226,4255],"source":"**Property system coercion.**"},{"content":"For details on coercion, see <bpt id=\"p1\">[</bpt>Coercion, Animation, and Base Value<ept id=\"p1\">](#animations)</ept> later in this topic.","pos":[4256,4356],"source":" For details on coercion, see [Coercion, Animation, and Base Value](#animations) later in this topic."},{"content":"<bpt id=\"p1\">**</bpt>Active animations, or animations with a Hold behavior.<ept id=\"p1\">**</ept>","pos":[4366,4424],"source":"**Active animations, or animations with a Hold behavior.**"},{"content":"In order to have any practical effect, an animation of a property must be able to have precedence over the base (unanimated) value, even if that value was set locally.","pos":[4425,4592]},{"content":"For details, see <bpt id=\"p1\">[</bpt>Coercion, Animation, and Base Value<ept id=\"p1\">](#animations)</ept> later in this topic.","pos":[4593,4681],"source":" For details, see [Coercion, Animation, and Base Value](#animations) later in this topic."},{"content":"<bpt id=\"p1\">**</bpt>Local value.<ept id=\"p1\">**</ept>","pos":[4691,4707],"source":"**Local value.**"},{"content":"A local value might be set through the convenience of the \"wrapper\" property, which also equates to setting as an attribute or property element in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, or by a call to the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> <ph id=\"ph3\">[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]</ph> using a property of a specific instance.","pos":[4708,5107],"source":" A local value might be set through the convenience of the \"wrapper\" property, which also equates to setting as an attribute or property element in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or by a call to the <xref:System.Windows.DependencyObject.SetValue%2A> [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] using a property of a specific instance."},{"content":"If you set a local value by using a binding or a resource, these each act in the precedence as if a direct value was set.","pos":[5108,5229]},{"content":"<bpt id=\"p1\">**</bpt>TemplatedParent template properties.<ept id=\"p1\">**</ept>","pos":[5239,5279],"source":"**TemplatedParent template properties.**"},{"content":"An element has a <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> if it was created as part of a template (a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Windows.DataTemplate&gt;</ph>).","pos":[5280,5484],"source":" An element has a <xref:System.Windows.FrameworkElement.TemplatedParent%2A> if it was created as part of a template (a <xref:System.Windows.Controls.ControlTemplate> or <xref:System.Windows.DataTemplate>)."},{"content":"For details on when this applies, see <bpt id=\"p1\">[</bpt>TemplatedParent<ept id=\"p1\">](#templatedparent)</ept> later in this topic.","pos":[5485,5579],"source":" For details on when this applies, see [TemplatedParent](#templatedparent) later in this topic."},{"content":"Within the template, the following precedence applies:","pos":[5580,5634]},{"content":"Triggers from the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> template.","pos":[5648,5733],"source":"Triggers from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template."},{"pos":[5747,5938],"content":"Property sets (typically through <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> attributes) in the <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> template.","source":"Property sets (typically through [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes) in the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template."},{"content":"<bpt id=\"p1\">**</bpt>Implicit style.<ept id=\"p1\">**</ept>","pos":[5948,5967],"source":"**Implicit style.**"},{"content":"Applies only to the <ph id=\"ph1\">`Style`</ph> property.","pos":[5968,6005],"source":" Applies only to the `Style` property."},{"content":"The <ph id=\"ph1\">`Style`</ph> property is filled by any style resource with a key that matches the type of that element.","pos":[6006,6108],"source":" The `Style` property is filled by any style resource with a key that matches the type of that element."},{"content":"That style resource must exist either in the page or the application; lookup for an implicit style resource does not proceed into the themes.","pos":[6109,6250]},{"content":"<bpt id=\"p1\">**</bpt>Style triggers.<ept id=\"p1\">**</ept>","pos":[6260,6279],"source":"**Style triggers.**"},{"content":"The triggers within styles from page or application (these styles might be either explicit or implicit styles, but not from the default styles, which have lower precedence).","pos":[6280,6453]},{"content":"<bpt id=\"p1\">**</bpt>Template triggers.<ept id=\"p1\">**</ept>","pos":[6463,6485],"source":"**Template triggers.**"},{"content":"Any trigger from a template within a style, or a directly applied template.","pos":[6486,6561]},{"content":"<bpt id=\"p1\">**</bpt>Style setters.<ept id=\"p1\">**</ept>","pos":[6571,6589],"source":"**Style setters.**"},{"content":"Values from a <ph id=\"ph1\">&lt;xref:System.Windows.Setter&gt;</ph> within styles from page or application.","pos":[6590,6672],"source":" Values from a <xref:System.Windows.Setter> within styles from page or application."},{"content":"<bpt id=\"p1\">**</bpt>Default (theme) style.<ept id=\"p1\">**</ept>","pos":[6681,6707],"source":"**Default (theme) style.**"},{"content":"For details on when this applies, and how theme styles relate to the templates within theme styles, see <bpt id=\"p1\">[</bpt>Default (Theme) Styles<ept id=\"p1\">](#themestyles)</ept> later in this topic.","pos":[6708,6871],"source":" For details on when this applies, and how theme styles relate to the templates within theme styles, see [Default (Theme) Styles](#themestyles) later in this topic."},{"content":"Within a default style, the following order of precedence applies:","pos":[6872,6938]},{"content":"Active triggers in the theme style.","pos":[6952,6987]},{"content":"Setters in the theme style.","pos":[7001,7028]},{"content":"<bpt id=\"p1\">**</bpt>Inheritance.<ept id=\"p1\">**</ept>","pos":[7038,7054],"source":"**Inheritance.**"},{"content":"A few dependency properties inherit their values from parent element to child elements, such that they need not be set specifically on each element throughout an application.","pos":[7055,7229]},{"content":"For details see <bpt id=\"p1\">[</bpt>Property Value Inheritance<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.","pos":[7230,7346],"source":" For details see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)."},{"content":"<bpt id=\"p1\">**</bpt>Default value from dependency property metadata.<ept id=\"p1\">**</ept>","pos":[7356,7408],"source":"**Default value from dependency property metadata.**"},{"content":"Any given dependency property may have a default value as established by the property system registration of that particular property.","pos":[7409,7543]},{"content":"Also, derived classes that inherit a dependency property have the option to override that metadata (including the default value) on a per-type basis.","pos":[7544,7693]},{"content":"See <bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> for more information.","pos":[7694,7823],"source":" See [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for more information."},{"content":"Because inheritance is checked before default value, for an inherited property, a parent element default value takes precedence over a child element.","pos":[7824,7973]},{"content":"Consequently, if an inheritable property is not set anywhere, the default value as specified on the root or parent is used instead of the child element default value.","pos":[7975,8141]},{"pos":[8184,8199],"content":"TemplatedParent","linkify":"TemplatedParent","nodes":[{"content":"TemplatedParent","pos":[0,15]}]},{"content":"TemplatedParent as a precedence item does not apply to any property of an element that you declare directly in standard application markup.","pos":[8203,8342]},{"content":"The TemplatedParent concept exists only for child items within a visual tree that come into existence through the application of the template.","pos":[8343,8485]},{"content":"When the property system searches the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> template for a value, it is searching the template that created that element.","pos":[8486,8659],"source":" When the property system searches the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template for a value, it is searching the template that created that element."},{"content":"The property values from the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> template generally act as if they were set as a local value on the child element, but this lesser precedence versus the local value exists because the templates are potentially shared.","pos":[8660,8931],"source":" The property values from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template generally act as if they were set as a local value on the child element, but this lesser precedence versus the local value exists because the templates are potentially shared."},{"content":"For details, see <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph>.","pos":[8932,9007],"source":" For details, see <xref:System.Windows.FrameworkElement.TemplatedParent%2A>."},{"pos":[9049,9067],"content":"The Style Property","linkify":"The Style Property","nodes":[{"content":"The Style Property","pos":[0,18]}]},{"content":"The order of lookup described earlier applies to all possible dependency properties except one: the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property.","pos":[9071,9228],"source":"The order of lookup described earlier applies to all possible dependency properties except one: the <xref:System.Windows.FrameworkElement.Style%2A> property."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property is unique in that it cannot itself be styled, so the precedence items 5 through 8 do not apply.","pos":[9229,9385],"source":" The <xref:System.Windows.FrameworkElement.Style%2A> property is unique in that it cannot itself be styled, so the precedence items 5 through 8 do not apply."},{"content":"Also, either animating or coercing <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> is not recommended (and animating <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> would require a custom animation class).","pos":[9386,9591],"source":" Also, either animating or coercing <xref:System.Windows.FrameworkElement.Style%2A> is not recommended (and animating <xref:System.Windows.FrameworkElement.Style%2A> would require a custom animation class)."},{"content":"This leaves three ways that the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property might be set:","pos":[9592,9694],"source":" This leaves three ways that the <xref:System.Windows.FrameworkElement.Style%2A> property might be set:"},{"content":"<bpt id=\"p1\">**</bpt>Explicit style.<ept id=\"p1\">**</ept>","pos":[9704,9723],"source":"**Explicit style.**"},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property is set directly.","pos":[9724,9801],"source":" The <xref:System.Windows.FrameworkElement.Style%2A> property is set directly."},{"content":"In most scenarios, the style is not defined inline, but instead is referenced as a resource, by explicit key.","pos":[9802,9911]},{"content":"In this case the Style property itself acts as if it were a local value, precedence item 3.","pos":[9912,10003]},{"content":"<bpt id=\"p1\">**</bpt>Implicit style.<ept id=\"p1\">**</ept>","pos":[10013,10032],"source":"**Implicit style.**"},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property is not set directly.","pos":[10033,10114],"source":" The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> exists at some level in the resource lookup sequence (page, application) and is keyed using a resource key that matches the type the style is to be applied to.","pos":[10115,10335],"source":" However, the <xref:System.Windows.FrameworkElement.Style%2A> exists at some level in the resource lookup sequence (page, application) and is keyed using a resource key that matches the type the style is to be applied to."},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property itself acts by a precedence identified in the sequence as item 5.","pos":[10336,10476],"source":" In this case, the <xref:System.Windows.FrameworkElement.Style%2A> property itself acts by a precedence identified in the sequence as item 5."},{"content":"This condition can be detected by using <ph id=\"ph1\">&lt;xref:System.Windows.DependencyPropertyHelper&gt;</ph> against the <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property and looking for <ph id=\"ph3\">&lt;xref:System.Windows.BaseValueSource&gt;</ph> in the results.","pos":[10477,10702],"source":" This condition can be detected by using <xref:System.Windows.DependencyPropertyHelper> against the <xref:System.Windows.FrameworkElement.Style%2A> property and looking for <xref:System.Windows.BaseValueSource> in the results."},{"content":"<bpt id=\"p1\">**</bpt>Default style<ept id=\"p1\">**</ept>, also known as <bpt id=\"p2\">**</bpt>theme style.<ept id=\"p2\">**</ept>","pos":[10712,10761],"source":"**Default style**, also known as **theme style.**"},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property is not set directly, and in fact will read as <ph id=\"ph2\">`null`</ph> up until run time.","pos":[10762,10894],"source":" The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly, and in fact will read as `null` up until run time."},{"content":"In this case, the style comes from the run-time theme evaluation that is part of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> presentation engine.","pos":[10895,11082],"source":" In this case, the style comes from the run-time theme evaluation that is part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation engine."},{"pos":[11089,11232],"content":"For implicit styles not in themes, the type must match exactlyâ€”a <ph id=\"ph1\">`MyButton``Button`</ph>-derived class will not implicitly use a style for <ph id=\"ph2\">`Button`</ph>.","source":"For implicit styles not in themes, the type must match exactlyâ€”a `MyButton``Button`-derived class will not implicitly use a style for `Button`."},{"pos":[11271,11293],"content":"Default (Theme) Styles","linkify":"Default (Theme) Styles","nodes":[{"content":"Default (Theme) Styles","pos":[0,22]}]},{"content":"Every control that ships with <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> has a default style.","pos":[11297,11429],"source":"Every control that ships with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a default style."},{"content":"That default style potentially varies by theme, which is why this default style is sometimes referred to as a theme style.","pos":[11430,11552]},{"content":"The most important information that is found within a default style for a control is its control template, which exists in the theme style as a setter for its <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Template%2A&gt;</ph> property.","pos":[11559,11778],"source":"The most important information that is found within a default style for a control is its control template, which exists in the theme style as a setter for its <xref:System.Windows.Controls.Control.Template%2A> property."},{"content":"If there were no template from default styles, a control without a custom template as part of a custom style would have no visual appearance at all.","pos":[11779,11927]},{"content":"The template from the default style gives the visual appearance of each control a basic structure, and also defines the connections between properties defined in the visual tree of the template and the corresponding control class.","pos":[11928,12158]},{"content":"Each control exposes a set of properties that can influence the visual appearance of the control without completely replacing the template.","pos":[12159,12298]},{"content":"For example, consider the default visual appearance of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Thumb&gt;</ph> control, which is a component of a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Primitives.ScrollBar&gt;</ph>.","pos":[12299,12491],"source":" For example, consider the default visual appearance of a <xref:System.Windows.Controls.Primitives.Thumb> control, which is a component of a <xref:System.Windows.Controls.Primitives.ScrollBar>."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Thumb&gt;</ph> has certain customizable properties.","pos":[12498,12584],"source":"A <xref:System.Windows.Controls.Primitives.Thumb> has certain customizable properties."},{"content":"The default template of a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Thumb&gt;</ph> creates a basic stucture / visual tree with several nested <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border&gt;</ph> components to create a bevel look.","pos":[12585,12790],"source":" The default template of a <xref:System.Windows.Controls.Primitives.Thumb> creates a basic stucture / visual tree with several nested <xref:System.Windows.Controls.Border> components to create a bevel look."},{"content":"If a property that is part of the template is intended to be exposed for customization by the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Thumb&gt;</ph> class, then that property must be exposed by a <bpt id=\"p1\">[</bpt>TemplateBinding<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md)</ept>, within the template.","pos":[12791,13096],"source":" If a property that is part of the template is intended to be exposed for customization by the <xref:System.Windows.Controls.Primitives.Thumb> class, then that property must be exposed by a [TemplateBinding](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md), within the template."},{"content":"In the case of <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Thumb&gt;</ph>, various properties of these borders share a template binding to properties such as <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border.Background%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Border.BorderThickness%2A&gt;</ph>.","pos":[13097,13356],"source":" In the case of <xref:System.Windows.Controls.Primitives.Thumb>, various properties of these borders share a template binding to properties such as <xref:System.Windows.Controls.Border.Background%2A> or <xref:System.Windows.Controls.Border.BorderThickness%2A>."},{"content":"But certain other properties or visual arrangements are hard-coded into the control template or are bound to values that come directly from the theme, and cannot be changed short of replacing the entire template.","pos":[13357,13569]},{"content":"Generally, if a property comes from a templated parent and is not exposed by a template binding, it cannot be adjusted by styles because there is no easy way to target it.","pos":[13570,13741]},{"content":"But that property could still be influenced by property value inheritance in the applied template, or by default value.","pos":[13742,13861]},{"content":"The theme styles use a type as the key in their definitions.","pos":[13868,13928]},{"content":"However, when themes are applied to a given element instance, themes lookup for this type is performed by checking the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> property on a control.","pos":[13929,14128],"source":" However, when themes are applied to a given element instance, themes lookup for this type is performed by checking the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> property on a control."},{"content":"This is in contrast to using the literal Type, as implicit styles do.","pos":[14129,14198]},{"content":"The value of <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> would inherit to derived classes even if the implementer did not change it (the intended way of changing the property is not to override it at the property level, but to instead change its default value in property metadata).","pos":[14199,14495],"source":" The value of <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> would inherit to derived classes even if the implementer did not change it (the intended way of changing the property is not to override it at the property level, but to instead change its default value in property metadata)."},{"content":"This indirection enables base classes to define the theme styles for derived elements that do not otherwise have a style (or more importantly, do not have a template within that style and would thus have no default visual appearance at all).","pos":[14496,14737]},{"content":"Thus, you can derive <ph id=\"ph1\">`MyButton`</ph> from <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph> and will still get the <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Button&gt;</ph> default template.","pos":[14738,14891],"source":" Thus, you can derive `MyButton` from <xref:System.Windows.Controls.Button> and will still get the <xref:System.Windows.Controls.Button> default template."},{"content":"If you were the control author of <ph id=\"ph1\">`MyButton`</ph> and you wanted a different behavior, you could override the dependency property metadata for <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> on <ph id=\"ph3\">`MyButton`</ph> to return a different key, and then define the relevant theme styles including template for <ph id=\"ph4\">`MyButton`</ph> that you must package with your <ph id=\"ph5\">`MyButton`</ph> control.","pos":[14892,15256],"source":" If you were the control author of `MyButton` and you wanted a different behavior, you could override the dependency property metadata for <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> on `MyButton` to return a different key, and then define the relevant theme styles including template for `MyButton` that you must package with your `MyButton` control."},{"content":"For more details on themes, styles, and control authoring, see <bpt id=\"p1\">[</bpt>Control Authoring Overview<ept id=\"p1\">](../../../../docs/framework/wpf/controls/control-authoring-overview.md)</ept>.","pos":[15257,15420],"source":" For more details on themes, styles, and control authoring, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md)."},{"pos":[15457,15496],"content":"Dynamic Resource References and Binding","linkify":"Dynamic Resource References and Binding","nodes":[{"content":"Dynamic Resource References and Binding","pos":[0,39]}]},{"content":"Dynamic resource references and binding operations respect the precedence of the location at which they are set.","pos":[15500,15612]},{"content":"For example, a dynamic resource applied to a local value acts per precedence item 3, a binding for a property setter within a theme style applies at precedence item 9, and so on.","pos":[15613,15791]},{"content":"Because dynamic resource references and binding must both be able to obtain values from the run time state of the application, this entails that the actual process of determining the property value precedence for any given property extends into the run time as well.","pos":[15792,16058]},{"content":"Dynamic resource references are not strictly speaking part of the property system, but they do have a lookup order of their own which interacts with the sequence listed above.","pos":[16065,16240]},{"content":"That precedence is documented more thoroughly in the <bpt id=\"p1\">[</bpt>XAML Resources<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-resources.md)</ept>.","pos":[16241,16370],"source":" That precedence is documented more thoroughly in the [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md)."},{"content":"The basic summation of that precedence is: element to page root, application, theme, system.","pos":[16371,16463]},{"content":"Dynamic resources and bindings have the precedence of where they were set, but the value is deferred.","pos":[16470,16571]},{"content":"One consequence of this is that if you set a dynamic resource or binding to a local value, any change to the local value replaces the dynamic resource or binding entirely.","pos":[16572,16743]},{"content":"Even if you call the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> method to clear the locally set value, the dynamic resource or binding will not be restored.","pos":[16744,16910],"source":" Even if you call the <xref:System.Windows.DependencyObject.ClearValue%2A> method to clear the locally set value, the dynamic resource or binding will not be restored."},{"content":"In fact, if you call <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> on a property that has a dynamic resource or binding in place (with no literal local value), they are cleared by the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> call too.","pos":[16911,17164],"source":" In fact, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property that has a dynamic resource or binding in place (with no literal local value), they are cleared by the <xref:System.Windows.DependencyObject.ClearValue%2A> call too."},{"pos":[17207,17222],"content":"SetCurrentValue","linkify":"SetCurrentValue","nodes":[{"content":"SetCurrentValue","pos":[0,15]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph> method is another way to set a property, but it is not in the order of precedence.","pos":[17226,17370],"source":"The <xref:System.Windows.DependencyObject.SetCurrentValue%2A> method is another way to set a property, but it is not in the order of precedence."},{"content":"Instead, <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph> enables you to change the value of a property without overwriting the source of a previous value.","pos":[17371,17535],"source":" Instead, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the value of a property without overwriting the source of a previous value."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph> any time that you want to set a value without giving that value the precedence of a local value.","pos":[17536,17702],"source":" You can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> any time that you want to set a value without giving that value the precedence of a local value."},{"content":"For example, if a property is set by a trigger and then assigned another value via <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph>, the property system still respects the trigger and the property will change if the triggerâ€™s action occurs.","pos":[17703,17952],"source":" For example, if a property is set by a trigger and then assigned another value via <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, the property system still respects the trigger and the property will change if the triggerâ€™s action occurs."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph> enables you to change the propertyâ€™s value without giving it a source with a higher precedence.","pos":[17953,18106],"source":" <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the propertyâ€™s value without giving it a source with a higher precedence."},{"content":"Likewise, you can use <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetCurrentValue%2A&gt;</ph> to change the value of a property without overwriting a binding.","pos":[18107,18251],"source":" Likewise, you can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> to change the value of a property without overwriting a binding."},{"pos":[18289,18325],"content":"Coercion, Animations, and Base Value","linkify":"Coercion, Animations, and Base Value","nodes":[{"content":"Coercion, Animations, and Base Value","pos":[0,36]}]},{"content":"Coercion and animation both act on a value that is termed as the \"base value\" throughout this <ph id=\"ph1\">[!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]</ph>.","pos":[18329,18493],"source":"Coercion and animation both act on a value that is termed as the \"base value\" throughout this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]."},{"content":"The base value is thus whatever value is determined through evaluating upwards in the items until item 2 is reached.","pos":[18494,18610]},{"content":"For an animation, the base value can have an effect on the animated value, if that animation does not specify both \"From\" and \"To\" for certain behaviors, or if the animation deliberately reverts to the base value when completed.","pos":[18617,18845]},{"content":"To see this in practice, run the <bpt id=\"p1\">[</bpt>From, To, and By Animation Target Values Sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=159988)</ept>.","pos":[18846,18976],"source":" To see this in practice, run the [From, To, and By Animation Target Values Sample](http://go.microsoft.com/fwlink/?LinkID=159988)."},{"content":"Try setting the local values of the rectangle height in the example, such that the initial local value differs from any \"From\" in the animation.","pos":[18977,19121]},{"content":"You will note that the animations start right away using the \"From\" values and replace the base value once started.","pos":[19122,19237]},{"content":"The animation might specify to return to the value found before animation once it is completed by specifying the Stop <ph id=\"ph1\">&lt;xref:System.Windows.Media.Animation.FillBehavior&gt;</ph>.","pos":[19238,19407],"source":" The animation might specify to return to the value found before animation once it is completed by specifying the Stop <xref:System.Windows.Media.Animation.FillBehavior>."},{"content":"Afterwards, normal precedence is used for the base value determination.","pos":[19408,19479]},{"content":"Multiple animations might be applied to a single property, with each of these animations possibly having been defined from different points in the value precedence.","pos":[19486,19650]},{"content":"However, these animations will potentially composite their values, rather than just applying the animation from the higher precedence.","pos":[19651,19785]},{"content":"This depends on exactly how the animations are defined, and the type of the value that is being animated.","pos":[19786,19891]},{"content":"For more information about animating properties, see <bpt id=\"p1\">[</bpt>Animation Overview<ept id=\"p1\">](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.","pos":[19892,20040],"source":" For more information about animating properties, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)."},{"content":"Coercion applies at the highest level of all.","pos":[20047,20092]},{"content":"Even an already running animation is subject to value coercion.","pos":[20093,20156]},{"content":"Certain existing dependency properties in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> have built-in coercion.","pos":[20157,20304],"source":" Certain existing dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have built-in coercion."},{"content":"For a custom dependency property, you define the coercion behavior for a custom dependency property by writing a <ph id=\"ph1\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> and passing the callback as part of metadata when you create the property.","pos":[20305,20534],"source":" For a custom dependency property, you define the coercion behavior for a custom dependency property by writing a <xref:System.Windows.CoerceValueCallback> and passing the callback as part of metadata when you create the property."},{"content":"You can also override coercion behavior of existing properties by overriding the metadata on that property in a derived class.","pos":[20535,20661]},{"content":"Coercion interacts with the base value in such a way that the constraints on coercion are applied as those constraints exist at the time, but the base value is still retained.","pos":[20662,20837]},{"content":"Therefore, if constraints in coercion are later lifted, the coercion will return the closest value possible to that base value, and potentially the coercion influence on a property will cease as soon as all constraints are lifted.","pos":[20838,21068]},{"content":"For more information about coercion behavior, see <bpt id=\"p1\">[</bpt>Dependency Property Callbacks and Validation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.","pos":[21069,21255],"source":" For more information about coercion behavior, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)."},{"pos":[21291,21308],"content":"Trigger Behaviors","linkify":"Trigger Behaviors","nodes":[{"content":"Trigger Behaviors","pos":[0,17]}]},{"content":"Controls often define trigger behaviors as part of their default style in themes.","pos":[21312,21393]},{"content":"Setting local properties on controls might prevent the triggers from being able to respond to user-driven events either visually or behaviorally.","pos":[21394,21539]},{"content":"The most common use of a property trigger is for control or state properties such as <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A&gt;</ph>.","pos":[21540,21690],"source":" The most common use of a property trigger is for control or state properties such as <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>."},{"content":"For example, by default when a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> is disabled (trigger for <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.IsEnabled%2A&gt;</ph> is <ph id=\"ph3\">`false`</ph>) then the <ph id=\"ph4\">&lt;xref:System.Windows.Controls.Control.Foreground%2A&gt;</ph> value in the theme style is what causes the control to appear \"grayed out\".","pos":[21691,21979],"source":" For example, by default when a <xref:System.Windows.Controls.Button> is disabled (trigger for <xref:System.Windows.UIElement.IsEnabled%2A> is `false`) then the <xref:System.Windows.Controls.Control.Foreground%2A> value in the theme style is what causes the control to appear \"grayed out\"."},{"content":"But if you have set a local <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Foreground%2A&gt;</ph> value, that normal gray-out color will be overruled in precedence by your local property set, even in this property-triggered scenario.","pos":[21980,22196],"source":" But if you have set a local <xref:System.Windows.Controls.Control.Foreground%2A> value, that normal gray-out color will be overruled in precedence by your local property set, even in this property-triggered scenario."},{"content":"Be cautious of setting values for properties that have theme-level trigger behaviors and make sure you are not unduly interfering with the intended user experience for that control.","pos":[22197,22378]},{"pos":[22416,22447],"content":"ClearValue and Value Precedence","linkify":"ClearValue and Value Precedence","nodes":[{"content":"ClearValue and Value Precedence","pos":[0,31]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> method provides an expedient means to clear any locally applied value from a dependency property that is set on an element.","pos":[22451,22631],"source":"The <xref:System.Windows.DependencyObject.ClearValue%2A> method provides an expedient means to clear any locally applied value from a dependency property that is set on an element."},{"content":"However, calling <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> is not a guarantee that the default as established in metadata during property registration is the new effective value.","pos":[22632,22821],"source":" However, calling <xref:System.Windows.DependencyObject.ClearValue%2A> is not a guarantee that the default as established in metadata during property registration is the new effective value."},{"content":"All of the other participants in value precedence are still active.","pos":[22822,22889]},{"content":"Only the locally set value has been removed from the precedence sequence.","pos":[22890,22963]},{"content":"For example, if you call <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> on a property where that property is also set by a theme style, then the theme value is applied as the new value rather than the metadata-based default.","pos":[22964,23194],"source":" For example, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property where that property is also set by a theme style, then the theme value is applied as the new value rather than the metadata-based default."},{"content":"If you want to take all property value participants out of the process and set the value to the registered metadata default, you can obtain that default value definitively by querying the dependency property metadata, and then you can use the default value to locally set the property with a call to <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>.","pos":[23195,23546],"source":" If you want to take all property value participants out of the process and set the value to the registered metadata default, you can obtain that default value definitively by querying the dependency property metadata, and then you can use the default value to locally set the property with a call to <xref:System.Windows.DependencyObject.SetValue%2A>."},{"pos":[23555,23563],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph>","pos":[23567,23605],"source":"<xref:System.Windows.DependencyObject> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph>","pos":[23610,23650],"source":"<xref:System.Windows.DependencyProperty> "},{"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept><ph id=\"ph1\"> </ph>","pos":[23655,23763],"source":"[Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) "},{"content":"<bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept><ph id=\"ph1\"> </ph>","pos":[23767,23871],"source":"[Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) "},{"content":"<bpt id=\"p1\">[</bpt>Dependency Property Callbacks and Validation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>","pos":[23875,24010],"source":"[Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)"}]}