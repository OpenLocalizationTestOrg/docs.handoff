{"content":"---\ntitle: \"Hosting Win32 Content in WPF | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"interoperability [WPF], tutorials\"\n  - \"Win32 code, WPF interoperation\"\n  - \"interoperability [WPF], Win32\"\nms.assetid: 3cc8644a-34f3-4082-9ddc-77623e4df2d8\ncaps.latest.revision: 7\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Hosting Win32 Content in WPF\n## Prerequisites  \n See [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md).  \n  \n## A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)  \n To reuse [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] content inside [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, use <xref:System.Windows.Interop.HwndHost>, which is a control that makes HWNDs look like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content.  Like <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost> is straightforward to use: derive from <xref:System.Windows.Interop.HwndHost> and implement `BuildWindowCore` and `DestroyWindowCore` methods, then instantiate your <xref:System.Windows.Interop.HwndHost> derived class and place it inside your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.  \n  \n If your [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] logic is already packaged as a control, then your `BuildWindowCore` implementation is little more than a call to `CreateWindow`.  For example, to create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] LISTBOX control in [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]:  \n  \n```  \nvirtual HandleRef BuildWindowCore(HandleRef hwndParent) override {  \n    HWND handle = CreateWindowEx(0, L\"LISTBOX\",   \n    L\"this is a Win32 listbox\",  \n    WS_CHILD | WS_VISIBLE | LBS_NOTIFY  \n    | WS_VSCROLL | WS_BORDER,  \n    0, 0, // x, y  \n    30, 70, // height, width  \n    (HWND) hwndParent.Handle.ToPointer(), // parent hwnd  \n    0, // hmenu  \n    0, // hinstance  \n    0); // lparam  \n  \n    return HandleRef(this, IntPtr(handle));  \n}  \n  \nvirtual void DestroyWindowCore(HandleRef hwnd) override {  \n    // HwndHost will dispose the hwnd for us  \n}  \n```  \n  \n But suppose the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code is not quite so self-contained? If so, you can create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] dialog box and embed its contents into a larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.  The sample shows this in [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)], although it is also possible to do this in a different language or at the command line.  \n  \n Start with a simple dialog, which is compiled into a [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] project.  \n  \n Next, introduce the dialog into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application:  \n  \n-   Compile the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] as managed (`/clr`)  \n  \n-   Turn the dialog into a control  \n  \n-   Define the derived class of <xref:System.Windows.Interop.HwndHost> with `BuildWindowCore` and `DestroyWindowCore` methods  \n  \n-   Override `TranslateAccelerator` method to handle dialog keys  \n  \n-   Override `TabInto` method to support tabbing  \n  \n-   Override `OnMnemonic` method to support mnemonics  \n  \n-   Instantiate the <xref:System.Windows.Interop.HwndHost> subclass and put it under the right [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element  \n  \n### Turn the Dialog into a Control  \n You can turn a dialog box into a child HWND using the WS_CHILD and DS_CONTROL styles.  Go into the resource file (.rc) where the dialog is defined, and find the beginning of the definition of the dialog:  \n  \n```  \nIDD_DIALOG1 DIALOGEX 0, 0, 303, 121  \nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU  \n```  \n  \n Change the second line to:  \n  \n```  \nSTYLE DS_SETFONT | WS_CHILD | WS_BORDER | DS_CONTROL  \n```  \n  \n This action does not fully package it into a self-contained control; you still need to call `IsDialogMessage()` so [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] can process certain messages, but the control change does provide a straightforward way of putting those controls inside another HWND.  \n  \n## Subclass HwndHost  \n Import the following namespaces:  \n  \n```  \nnamespace ManagedCpp  \n{  \n    using namespace System;  \n    using namespace System::Windows;  \n    using namespace System::Windows::Interop;  \n    using namespace System::Windows::Input;  \n    using namespace System::Windows::Media;  \n    using namespace System::Runtime::InteropServices;  \n```  \n  \n Then create a derived class of <xref:System.Windows.Interop.HwndHost> and override the `BuildWindowCore` and `DestroyWindowCore` methods:  \n  \n```  \npublic ref class MyHwndHost : public HwndHost, IKeyboardInputSink {  \n    private:  \n        HWND dialog;  \n  \n    protected:   \n        virtual HandleRef BuildWindowCore(HandleRef hwndParent) override {  \n            InitializeGlobals();   \n            dialog = CreateDialog(hInstance,   \n                MAKEINTRESOURCE(IDD_DIALOG1),   \n                (HWND) hwndParent.Handle.ToPointer(),  \n                (DLGPROC) About);   \n            return HandleRef(this, IntPtr(dialog));  \n        }  \n  \n        virtual void DestroyWindowCore(HandleRef hwnd) override {  \n            // hwnd will be disposed for us  \n        }  \n```  \n  \n Here you use the `CreateDialog` to create the dialog box that is really a control.  Since this is one of the first methods called inside the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)], you should also do some standard [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] initialization by calling a function you will define later, called `InitializeGlobals()`:  \n  \n```  \nbool initialized = false;  \n    void InitializeGlobals() {  \n        if (initialized) return;  \n        initialized = true;  \n  \n        // TODO: Place code here.  \n        MSG msg;  \n        HACCEL hAccelTable;  \n  \n        // Initialize global strings  \n        LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);  \n        LoadString(hInstance, IDC_TYPICALWIN32DIALOG, szWindowClass, MAX_LOADSTRING);  \n        MyRegisterClass(hInstance);  \n  \n```  \n  \n### Override TranslateAccelerator Method to Handle Dialog Keys  \n If you ran this sample now, you would get a dialog control that displays, but it would ignore all of the keyboard processing that makes a dialog box a functional dialog box.  You should now override the `TranslateAccelerator` implementation (which comes from `IKeyboardInputSink`, an interface that <xref:System.Windows.Interop.HwndHost> implements).  This method gets called when the application receives WM_KEYDOWN and WM_SYSKEYDOWN.  \n  \n```  \n  \n#undef TranslateAccelerator  \n        virtual bool TranslateAccelerator(System::Windows::Interop::MSG% msg,   \n            ModifierKeys modifiers) override   \n        {  \n            ::MSG m = ConvertMessage(msg);  \n  \n            // Win32's IsDialogMessage() will handle most of our tabbing, but doesn't know   \n            // what to do when it reaches the last tab stop  \n            if (m.message == WM_KEYDOWN && m.wParam == VK_TAB) {  \n                HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1);  \n                HWND lastTabStop = GetDlgItem(dialog, IDCANCEL);  \n                TraversalRequest^ request = nullptr;  \n  \n                if (GetKeyState(VK_SHIFT) && GetFocus() == firstTabStop) {  \n                    // this code should work, but thereâ€™s a bug with interop shift-tab in current builds                      \n                    request = gcnew TraversalRequest(FocusNavigationDirection::Last);  \n                }  \n                else if (!GetKeyState(VK_SHIFT) && GetFocus() == lastTabStop) {  \n                    request = gcnew TraversalRequest(FocusNavigationDirection::Next);  \n                }  \n  \n                if (request != nullptr)  \n                    return ((IKeyboardInputSink^) this)->KeyboardInputSite->OnNoMoreTabStops(request);  \n  \n            }  \n  \n            // Only call IsDialogMessage for keys it will do something with.  \n            if (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN) {  \n                switch (m.wParam) {  \n                    case VK_TAB:  \n                    case VK_LEFT:  \n                    case VK_UP:  \n                    case VK_RIGHT:  \n                    case VK_DOWN:  \n                    case VK_EXECUTE:  \n                    case VK_RETURN:  \n                    case VK_ESCAPE:  \n                    case VK_CANCEL:  \n                        IsDialogMessage(dialog, &m);  \n                        // IsDialogMessage should be called ProcessDialogMessage --  \n                        // it processes messages without ever really telling you  \n                        // if it handled a specific message or not  \n                        return true;  \n                }  \n            }  \n  \n            return false; // not a key we handled  \n        }  \n```  \n  \n This is a lot of code in one piece, so it could use some more detailed explanations.  First, the code using [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] macros; you need to be aware that there is already a macro named `TranslateAccelerator`, which is defined in winuser.h:  \n  \n```  \n#define TranslateAccelerator  TranslateAcceleratorW  \n```  \n  \n So make sure to define a `TranslateAccelerator` method and not a `TranslateAcceleratorW` method.  \n  \n Similarly, there is both the unmanaged winuser.h MSG and the managed `Microsoft::Win32::MSG` struct.  You can disambiguate between the two using the [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] `::` operator.  \n  \n```  \n  \nvirtual bool TranslateAccelerator(System::Windows::Interop::MSG% msg,   \n    ModifierKeys modifiers) override   \n{  \n    ::MSG m = ConvertMessage(msg);  \n```  \n  \n Both MSGs have the same data, but sometimes it is easier to work with the unmanaged definition, so in this sample you can define the obvious conversion routine:  \n  \n```  \n::MSG ConvertMessage(System::Windows::Interop::MSG% msg) {  \n    ::MSG m;  \n    m.hwnd = (HWND) msg.hwnd.ToPointer();  \n    m.lParam = (LPARAM) msg.lParam.ToPointer();  \n    m.message = msg.message;  \n    m.wParam = (WPARAM) msg.wParam.ToPointer();  \n  \n    m.time = msg.time;  \n  \n    POINT pt;  \n    pt.x = msg.pt_x;  \n    pt.y = msg.pt_y;  \n    m.pt = pt;  \n  \n    return m;  \n}  \n```  \n  \n Back to `TranslateAccelerator`.  The basic principle is to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `IsDialogMessage` to do as much work as possible, but `IsDialogMessage` does not have access to anything outside the dialog. As a user tab around the dialog, when tabbing runs past the last control in our dialog, you need to set focus to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] portion by calling `IKeyboardInputSite::OnNoMoreStops`.  \n  \n```  \n// Win32's IsDialogMessage() will handle most of the tabbing, but doesn't know   \n// what to do when it reaches the last tab stop  \nif (m.message == WM_KEYDOWN && m.wParam == VK_TAB) {  \n    HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1);  \n    HWND lastTabStop = GetDlgItem(dialog, IDCANCEL);  \n    TraversalRequest^ request = nullptr;  \n  \n    if (GetKeyState(VK_SHIFT) && GetFocus() == firstTabStop) {  \n        request = gcnew TraversalRequest(FocusNavigationDirection::Last);  \n    }  \n    else if (!GetKeyState(VK_SHIFT) && GetFocus() ==  lastTabStop) { {  \n        request = gcnew TraversalRequest(FocusNavigationDirection::Next);  \n    }  \n  \n    if (request != nullptr)  \n        return ((IKeyboardInputSink^) this)->KeyboardInputSite->OnNoMoreTabStops(request);  \n}  \n```  \n  \n Finally, call `IsDialogMessage`.  But one of the responsibilities of a `TranslateAccelerator` method is telling [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] whether you handled the keystroke or not. If you did not handle it, the input event can tunnel and bubble through the rest of the application. Here, you will expose a quirk of keyboard messange handling and the nature of the input architecture in [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]. Unfortunately, `IsDialogMessage` does not return in any way whether it handles a particular keystroke.  Even worse, it will call `DispatchMessage()` on keystrokes it should not handle!  So you will have to reverse-engineer `IsDialogMessage`, and only call it for the keys you know it will handle:  \n  \n```  \n// Only call IsDialogMessage for keys it will do something with.  \nif (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN) {  \n    switch (m.wParam) {  \n        case VK_TAB:  \n        case VK_LEFT:  \n        case VK_UP:  \n        case VK_RIGHT:  \n        case VK_DOWN:  \n        case VK_EXECUTE:  \n        case VK_RETURN:  \n        case VK_ESCAPE:  \n        case VK_CANCEL:  \n            IsDialogMessage(dialog, &m);  \n            // IsDialogMessage should be called ProcessDialogMessage --  \n            // it processes messages without ever really telling you  \n            // if it handled a specific message or not  \n            return true;  \n    }  \n```  \n  \n### Override TabInto Method to Support Tabbing  \n Now that you have implemented `TranslateAccelerator`, a user can tab around inside the dialog box and tab out of it into the greater [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.  But a user cannot tab back into the dialog box.  To solve that, you override `TabInto`:  \n  \n```  \n  \npublic:   \n    virtual bool TabInto(TraversalRequest^ request) override {  \n        if (request->FocusNavigationDirection == FocusNavigationDirection::Last) {  \n            HWND lastTabStop = GetDlgItem(dialog, IDCANCEL);  \n            SetFocus(lastTabStop);  \n        }  \n        else {  \n            HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1);  \n            SetFocus(firstTabStop);  \n        }  \n        return true;  \n    }  \n  \n```  \n  \n The `TraversalRequest` parameter tells you whether the tab action is a tab or shift tab.  \n  \n### Override OnMnemonic Method to Support Mnemonics  \n Keyboard handling is almost complete, but there is one thing missing â€“ mnemonics do not work.  If a user presses alt-F, focus doe not jump to the \"First name:\" edit box. So, you override the `OnMnemonic` method:  \n  \n```  \nvirtual bool OnMnemonic(System::Windows::Interop::MSG% msg, ModifierKeys modifiers) override {  \n    ::MSG m = ConvertMessage(msg);  \n  \n    // If it's one of our mnemonics, set focus to the appropriate hwnd  \n    if (msg.message == WM_SYSCHAR && GetKeyState(VK_MENU /*alt*/)) {  \n        int dialogitem = 9999;  \n        switch (m.wParam) {  \n            case 's': dialogitem = IDOK; break;  \n            case 'c': dialogitem = IDCANCEL; break;  \n            case 'f': dialogitem = IDC_EDIT1; break;  \n            case 'l': dialogitem = IDC_EDIT2; break;  \n            case 'p': dialogitem = IDC_EDIT3; break;  \n            case 'a': dialogitem = IDC_EDIT4; break;  \n            case 'i': dialogitem = IDC_EDIT5; break;  \n            case 't': dialogitem = IDC_EDIT6; break;  \n            case 'z': dialogitem = IDC_EDIT7; break;  \n        }  \n        if (dialogitem != 9999) {  \n            HWND hwnd = GetDlgItem(dialog, dialogitem);  \n            SetFocus(hwnd);  \n            return true;  \n        }  \n    }  \n    return false; // key unhandled  \n};  \n```  \n  \n Why not call `IsDialogMessage` here?  You have the same issue as before--you need to be able to inform [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] code whether your code handled the keystroke or not, and `IsDialogMessage` cannot do that.  There is also a second issue, because `IsDialogMessage` refuses to process the mnemonic if the focused HWND is not inside the dialog box.  \n  \n### Instantiate the HwndHost Derived Class  \n Finally, now that all the key and tab support is in place, you can put your <xref:System.Windows.Interop.HwndHost> into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.  If the main application is written in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the easiest way to put it in the right place is to leave an empty <xref:System.Windows.Controls.Border> element where you want to put the <xref:System.Windows.Interop.HwndHost>.  Here you create a <xref:System.Windows.Controls.Border> named `insertHwndHostHere`:  \n  \n```  \n<Window x:Class=\"WPFApplication1.Window1\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"  \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    Title=\"Windows Presentation Framework Application\"  \n    Loaded=\"Window1_Loaded\"  \n    >  \n    <StackPanel>  \n        <Button Content=\"WPF button\"/>  \n        <Border Name=\"insertHwndHostHere\" Height=\"200\" Width=\"500\"/>  \n        <Button Content=\"WPF button\"/>  \n    </StackPanel>  \n</Window>  \n```  \n  \n Then all that remains is to find a good place in code sequence to instantiate the <xref:System.Windows.Interop.HwndHost> and connect it to the <xref:System.Windows.Controls.Border>.  In this example, you will put it inside the constructor for the <xref:System.Windows.Window> derived class:  \n  \n```  \npublic partial class Window1 : Window {  \n    public Window1() {  \n    }  \n  \n    void Window1_Loaded(object sender, RoutedEventArgs e) {  \n        HwndHost host = new ManagedCpp.MyHwndHost();  \n        insertHwndHostHere.Child = host;  \n    }  \n}  \n```  \n  \n Which gives you:  \n  \n ![WPF application screen shot](../../../../docs/framework/wpf/advanced/media/interoparch09.PNG \"InteropArch09\")  \n  \n## See Also  \n [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)","nodes":[{"pos":[12,57],"content":"Hosting Win32 Content in WPF | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Hosting Win32 Content in WPF | Microsoft Docs","pos":[0,45]}]},{"pos":[499,527],"content":"Hosting Win32 Content in WPF","linkify":"Hosting Win32 Content in WPF","nodes":[{"content":"Hosting Win32 Content in WPF","pos":[0,28]}]},{"pos":[531,544],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"pos":[548,656],"content":"See <bpt id=\"p1\">[</bpt>WPF and Win32 Interoperation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)</ept>.","source":"See [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)."},{"pos":[665,736],"content":"A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)","linkify":"A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)","nodes":[{"content":"A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)","pos":[0,71]}]},{"content":"To reuse <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> content inside <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications, use <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>, which is a control that makes HWNDs look like <ph id=\"ph4\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> content.","pos":[740,1114],"source":"To reuse [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] content inside [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, use <xref:System.Windows.Interop.HwndHost>, which is a control that makes HWNDs look like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] content."},{"content":"Like <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndSource&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> is straightforward to use: derive from <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and implement <ph id=\"ph4\">`BuildWindowCore`</ph> and <ph id=\"ph5\">`DestroyWindowCore`</ph> methods, then instantiate your <ph id=\"ph6\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> derived class and place it inside your <ph id=\"ph7\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[1116,1539],"source":"  Like <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost> is straightforward to use: derive from <xref:System.Windows.Interop.HwndHost> and implement `BuildWindowCore` and `DestroyWindowCore` methods, then instantiate your <xref:System.Windows.Interop.HwndHost> derived class and place it inside your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"If your <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> logic is already packaged as a control, then your <ph id=\"ph2\">`BuildWindowCore`</ph> implementation is little more than a call to <ph id=\"ph3\">`CreateWindow`</ph>.","pos":[1546,1756],"source":"If your [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] logic is already packaged as a control, then your `BuildWindowCore` implementation is little more than a call to `CreateWindow`."},{"content":"For example, to create a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> LISTBOX control in <ph id=\"ph2\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph>:","pos":[1758,1944],"source":"  For example, to create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] LISTBOX control in [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]:"},{"content":"But suppose the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> code is not quite so self-contained?","pos":[2530,2656],"source":"But suppose the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] code is not quite so self-contained?"},{"content":"If so, you can create a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> dialog box and embed its contents into a larger <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[2657,2897],"source":" If so, you can create a [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] dialog box and embed its contents into a larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"The sample shows this in <ph id=\"ph1\">[!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph>, although it is also possible to do this in a different language or at the command line.","pos":[2899,3164],"source":"  The sample shows this in [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)], although it is also possible to do this in a different language or at the command line."},{"pos":[3171,3370],"content":"Start with a simple dialog, which is compiled into a <ph id=\"ph1\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> <ph id=\"ph2\">[!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]</ph> project.","source":"Start with a simple dialog, which is compiled into a [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] project."},{"pos":[3377,3514],"content":"Next, introduce the dialog into the larger <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application:","source":"Next, introduce the dialog into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application:"},{"pos":[3524,3625],"content":"Compile the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]</ph> as managed (<ph id=\"ph2\">`/clr`</ph>)","source":"Compile the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)] as managed (`/clr`)"},{"content":"Turn the dialog into a control","pos":[3635,3665]},{"pos":[3675,3796],"content":"Define the derived class of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> with <ph id=\"ph2\">`BuildWindowCore`</ph> and <ph id=\"ph3\">`DestroyWindowCore`</ph> methods","source":"Define the derived class of <xref:System.Windows.Interop.HwndHost> with `BuildWindowCore` and `DestroyWindowCore` methods"},{"pos":[3806,3866],"content":"Override <ph id=\"ph1\">`TranslateAccelerator`</ph> method to handle dialog keys","source":"Override `TranslateAccelerator` method to handle dialog keys"},{"pos":[3876,3920],"content":"Override <ph id=\"ph1\">`TabInto`</ph> method to support tabbing","source":"Override `TabInto` method to support tabbing"},{"pos":[3930,3979],"content":"Override <ph id=\"ph1\">`OnMnemonic`</ph> method to support mnemonics","source":"Override `OnMnemonic` method to support mnemonics"},{"pos":[3989,4169],"content":"Instantiate the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> subclass and put it under the right <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> element","source":"Instantiate the <xref:System.Windows.Interop.HwndHost> subclass and put it under the right [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] element"},{"pos":[4179,4209],"content":"Turn the Dialog into a Control","linkify":"Turn the Dialog into a Control","nodes":[{"content":"Turn the Dialog into a Control","pos":[0,30]}]},{"content":"You can turn a dialog box into a child HWND using the WS_CHILD and DS_CONTROL styles.","pos":[4213,4298]},{"content":"Go into the resource file (.rc) where the dialog is defined, and find the beginning of the definition of the dialog:","pos":[4300,4416]},{"content":"Change the second line to:","pos":[4562,4588]},{"pos":[4665,4988],"content":"This action does not fully package it into a self-contained control; you still need to call <ph id=\"ph1\">`IsDialogMessage()`</ph> so <ph id=\"ph2\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> can process certain messages, but the control change does provide a straightforward way of putting those controls inside another HWND.","source":"This action does not fully package it into a self-contained control; you still need to call `IsDialogMessage()` so [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] can process certain messages, but the control change does provide a straightforward way of putting those controls inside another HWND."},{"pos":[4997,5014],"content":"Subclass HwndHost","linkify":"Subclass HwndHost","nodes":[{"content":"Subclass HwndHost","pos":[0,17]}]},{"content":"Import the following namespaces:","pos":[5018,5050]},{"pos":[5364,5501],"content":"Then create a derived class of <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and override the <ph id=\"ph2\">`BuildWindowCore`</ph> and <ph id=\"ph3\">`DestroyWindowCore`</ph> methods:","source":"Then create a derived class of <xref:System.Windows.Interop.HwndHost> and override the `BuildWindowCore` and `DestroyWindowCore` methods:"},{"content":"Here you use the <ph id=\"ph1\">`CreateDialog`</ph> to create the dialog box that is really a control.","pos":[6150,6232],"source":"Here you use the `CreateDialog` to create the dialog box that is really a control."},{"content":"Since this is one of the first methods called inside the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)]</ph>, you should also do some standard <ph id=\"ph2\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> initialization by calling a function you will define later, called <ph id=\"ph3\">`InitializeGlobals()`</ph>:","pos":[6234,6558],"source":"  Since this is one of the first methods called inside the [!INCLUDE[TLA2#tla_dll](../../../../includes/tla2sharptla-dll-md.md)], you should also do some standard [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] initialization by calling a function you will define later, called `InitializeGlobals()`:"},{"pos":[7041,7099],"content":"Override TranslateAccelerator Method to Handle Dialog Keys","linkify":"Override TranslateAccelerator Method to Handle Dialog Keys","nodes":[{"content":"Override TranslateAccelerator Method to Handle Dialog Keys","pos":[0,58]}]},{"content":"If you ran this sample now, you would get a dialog control that displays, but it would ignore all of the keyboard processing that makes a dialog box a functional dialog box.","pos":[7103,7276]},{"content":"You should now override the <ph id=\"ph1\">`TranslateAccelerator`</ph> implementation (which comes from <ph id=\"ph2\">`IKeyboardInputSink`</ph>, an interface that <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> implements).","pos":[7278,7453],"source":"  You should now override the `TranslateAccelerator` implementation (which comes from `IKeyboardInputSink`, an interface that <xref:System.Windows.Interop.HwndHost> implements)."},{"content":"This method gets called when the application receives WM_KEYDOWN and WM_SYSKEYDOWN.","pos":[7455,7538]},{"content":"This is a lot of code in one piece, so it could use some more detailed explanations.","pos":[9835,9919]},{"content":"First, the code using <ph id=\"ph1\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> macros; you need to be aware that there is already a macro named <ph id=\"ph3\">`TranslateAccelerator`</ph>, which is defined in winuser.h:","pos":[9921,10202],"source":"  First, the code using [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] and [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] macros; you need to be aware that there is already a macro named `TranslateAccelerator`, which is defined in winuser.h:"},{"pos":[10278,10374],"content":"So make sure to define a <ph id=\"ph1\">`TranslateAccelerator`</ph> method and not a <ph id=\"ph2\">`TranslateAcceleratorW`</ph> method.","source":"So make sure to define a `TranslateAccelerator` method and not a `TranslateAcceleratorW` method."},{"content":"Similarly, there is both the unmanaged winuser.h MSG and the managed <ph id=\"ph1\">`Microsoft::Win32::MSG`</ph> struct.","pos":[10381,10481],"source":"Similarly, there is both the unmanaged winuser.h MSG and the managed `Microsoft::Win32::MSG` struct."},{"content":"You can disambiguate between the two using the <ph id=\"ph1\">[!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)]</ph> <ph id=\"ph2\">`::`</ph> operator.","pos":[10483,10612],"source":"  You can disambiguate between the two using the [!INCLUDE[TLA#tla_cpp](../../../../includes/tlasharptla-cpp-md.md)] `::` operator."},{"content":"Both MSGs have the same data, but sometimes it is easier to work with the unmanaged definition, so in this sample you can define the obvious conversion routine:","pos":[10791,10951]},{"content":"Back to <ph id=\"ph1\">`TranslateAccelerator`</ph>.","pos":[11357,11388],"source":"Back to `TranslateAccelerator`."},{"content":"The basic principle is to call the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> function <ph id=\"ph2\">`IsDialogMessage`</ph> to do as much work as possible, but <ph id=\"ph3\">`IsDialogMessage`</ph> does not have access to anything outside the dialog.","pos":[11390,11632],"source":"  The basic principle is to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `IsDialogMessage` to do as much work as possible, but `IsDialogMessage` does not have access to anything outside the dialog."},{"content":"As a user tab around the dialog, when tabbing runs past the last control in our dialog, you need to set focus to the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> portion by calling <ph id=\"ph2\">`IKeyboardInputSite::OnNoMoreStops`</ph>.","pos":[11633,11887],"source":" As a user tab around the dialog, when tabbing runs past the last control in our dialog, you need to set focus to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] portion by calling `IKeyboardInputSite::OnNoMoreStops`."},{"content":"Finally, call <ph id=\"ph1\">`IsDialogMessage`</ph>.","pos":[12690,12722],"source":"Finally, call `IsDialogMessage`."},{"content":"But one of the responsibilities of a <ph id=\"ph1\">`TranslateAccelerator`</ph> method is telling <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> whether you handled the keystroke or not.","pos":[12724,12925],"source":"  But one of the responsibilities of a `TranslateAccelerator` method is telling [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] whether you handled the keystroke or not."},{"content":"If you did not handle it, the input event can tunnel and bubble through the rest of the application.","pos":[12926,13026]},{"content":"Here, you will expose a quirk of keyboard messange handling and the nature of the input architecture in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph>.","pos":[13027,13205],"source":" Here, you will expose a quirk of keyboard messange handling and the nature of the input architecture in [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]."},{"content":"Unfortunately, <ph id=\"ph1\">`IsDialogMessage`</ph> does not return in any way whether it handles a particular keystroke.","pos":[13206,13308],"source":" Unfortunately, `IsDialogMessage` does not return in any way whether it handles a particular keystroke."},{"content":"Even worse, it will call <ph id=\"ph1\">`DispatchMessage()`</ph> on keystrokes it should not handle!","pos":[13310,13390],"source":"  Even worse, it will call `DispatchMessage()` on keystrokes it should not handle!"},{"content":"So you will have to reverse-engineer <ph id=\"ph1\">`IsDialogMessage`</ph>, and only call it for the keys you know it will handle:","pos":[13392,13502],"source":"  So you will have to reverse-engineer `IsDialogMessage`, and only call it for the keys you know it will handle:"},{"pos":[14190,14232],"content":"Override TabInto Method to Support Tabbing","linkify":"Override TabInto Method to Support Tabbing","nodes":[{"content":"Override TabInto Method to Support Tabbing","pos":[0,42]}]},{"content":"Now that you have implemented <ph id=\"ph1\">`TranslateAccelerator`</ph>, a user can tab around inside the dialog box and tab out of it into the greater <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[14236,14463],"source":"Now that you have implemented `TranslateAccelerator`, a user can tab around inside the dialog box and tab out of it into the greater [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"But a user cannot tab back into the dialog box.","pos":[14465,14512]},{"content":"To solve that, you override <ph id=\"ph1\">`TabInto`</ph>:","pos":[14514,14552],"source":"  To solve that, you override `TabInto`:"},{"pos":[15016,15104],"content":"The <ph id=\"ph1\">`TraversalRequest`</ph> parameter tells you whether the tab action is a tab or shift tab.","source":"The `TraversalRequest` parameter tells you whether the tab action is a tab or shift tab."},{"pos":[15114,15161],"content":"Override OnMnemonic Method to Support Mnemonics","linkify":"Override OnMnemonic Method to Support Mnemonics","nodes":[{"content":"Override OnMnemonic Method to Support Mnemonics","pos":[0,47]}]},{"content":"Keyboard handling is almost complete, but there is one thing missing â€“ mnemonics do not work.","pos":[15165,15258]},{"content":"If a user presses alt-F, focus doe not jump to the \"First name:\" edit box.","pos":[15260,15334]},{"content":"So, you override the <ph id=\"ph1\">`OnMnemonic`</ph> method:","pos":[15335,15376],"source":" So, you override the `OnMnemonic` method:"},{"content":"Why not call <ph id=\"ph1\">`IsDialogMessage`</ph> here?","pos":[16456,16492],"source":"Why not call `IsDialogMessage` here?"},{"content":"You have the same issue as before--you need to be able to inform <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> code whether your code handled the keystroke or not, and <ph id=\"ph2\">`IsDialogMessage`</ph> cannot do that.","pos":[16494,16731],"source":"  You have the same issue as before--you need to be able to inform [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] code whether your code handled the keystroke or not, and `IsDialogMessage` cannot do that."},{"content":"There is also a second issue, because <ph id=\"ph1\">`IsDialogMessage`</ph> refuses to process the mnemonic if the focused HWND is not inside the dialog box.","pos":[16733,16870],"source":"  There is also a second issue, because `IsDialogMessage` refuses to process the mnemonic if the focused HWND is not inside the dialog box."},{"pos":[16880,16918],"content":"Instantiate the HwndHost Derived Class","linkify":"Instantiate the HwndHost Derived Class","nodes":[{"content":"Instantiate the HwndHost Derived Class","pos":[0,38]}]},{"content":"Finally, now that all the key and tab support is in place, you can put your <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> into the larger <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[16922,17147],"source":"Finally, now that all the key and tab support is in place, you can put your <xref:System.Windows.Interop.HwndHost> into the larger [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"If the main application is written in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, the easiest way to put it in the right place is to leave an empty <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border&gt;</ph> element where you want to put the <ph id=\"ph3\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph>.","pos":[17149,17437],"source":"  If the main application is written in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the easiest way to put it in the right place is to leave an empty <xref:System.Windows.Controls.Border> element where you want to put the <xref:System.Windows.Interop.HwndHost>."},{"content":"Here you create a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Border&gt;</ph> named <ph id=\"ph2\">`insertHwndHostHere`</ph>:","pos":[17439,17522],"source":"  Here you create a <xref:System.Windows.Controls.Border> named `insertHwndHostHere`:"},{"content":"Then all that remains is to find a good place in code sequence to instantiate the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.HwndHost&gt;</ph> and connect it to the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Border&gt;</ph>.","pos":[18020,18201],"source":"Then all that remains is to find a good place in code sequence to instantiate the <xref:System.Windows.Interop.HwndHost> and connect it to the <xref:System.Windows.Controls.Border>."},{"content":"In this example, you will put it inside the constructor for the <ph id=\"ph1\">&lt;xref:System.Windows.Window&gt;</ph> derived class:","pos":[18203,18310],"source":"  In this example, you will put it inside the constructor for the <xref:System.Windows.Window> derived class:"},{"content":"Which gives you:","pos":[18582,18598]},{"pos":[18605,18716],"content":"<bpt id=\"p1\">![</bpt>WPF application screen shot<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wpf/advanced/media/interoparch09.PNG \"</bpt>InteropArch09<ept id=\"p2\">\")</ept>","source":"![WPF application screen shot](../../../../docs/framework/wpf/advanced/media/interoparch09.PNG \"InteropArch09\")"},{"pos":[18725,18733],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[18737,18840],"content":"<bpt id=\"p1\">[</bpt>WPF and Win32 Interoperation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)</ept>","source":"[WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)"}]}