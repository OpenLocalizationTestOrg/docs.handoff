{"content":"---\ntitle: \"Enhanced Strong Naming\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"strong-named assemblies\"\n  - \"strong naming [.NET Framework], enhanced\"\nms.assetid: 6cf17a82-62a1-4f6d-8d5a-d7d06dec2bb5\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Enhanced Strong Naming\nA strong name signature is an identity mechanism in the .NET Framework for identifying assemblies. It is a public-key digital signature that is typically used to verify the integrity of data being passed from an originator (signer) to a recipient (verifier). This signature is used as a unique identity for an assembly and ensures that references to the assembly are not ambiguous. The assembly is signed as part of the build process and then verified when it is loaded.  \n  \n Strong name signatures help prevent malicious parties from tampering with an assembly and then re-signing the assembly with the original signer’s key. However, strong name keys don’t contain any reliable information about the publisher, nor do they contain a certificate hierarchy. A strong name signature does not guarantee the trustworthiness of the person who signed the assembly or indicate whether that person was a legitimate owner of the key; it indicates only that the owner of the key signed the assembly. Therefore, we do not recommend using a strong name signature as a security validator for trusting third-party code. Microsoft Authenticode is the recommended way to authenticate code.  \n  \n## Limitations of Conventional Strong Names  \n The strong naming technology used in versions before the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] has the following shortcomings:  \n  \n-   Keys are constantly under attack, and improved techniques and hardware make it easier to infer a private key from a public key. To guard against attacks, larger keys are necessary. .NET Framework versions before the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] provide the ability to sign with any size key (the default size is 1024 bits), but signing an assembly with a new key breaks all binaries that reference the older identity of the assembly. Therefore, it is extremely difficult to upgrade the size of a signing key if you want to maintain compatibility.  \n  \n-   Strong name signing supports only the SHA-1 algorithm. SHA-1 has recently been found to be inadequate for secure hashing applications. Therefore, a stronger algorithm (SHA-256 or greater) is necessary. It is possible that SHA-1 will lose its FIPS-compliant standing, which would present problems for those who choose to use only FIPS-compliant software and algorithms.  \n  \n## Advantages of Enhanced Strong Names  \n The main advantages of enhanced strong names are compatibility with pre-existing strong names and the ability to claim that one identity is equivalent to another:  \n  \n-   Developers who have pre-existing signed assemblies can migrate their identities to the SHA-2 algorithms while maintaining compatibility with assemblies that reference the old identities.  \n  \n-   Developers who create new assemblies and are not concerned with pre-existing strong name signatures can use the more secure SHA-2 algorithms and sign the assemblies as they always have.  \n  \n## Using Enhanced Strong Names  \n Strong name keys consist of a signature key and an identity key. The assembly is signed with the signature key and is identified by the identity key. Prior to the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], these two keys were identical. Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], the identity key remains the same as in earlier .NET Framework versions, but the signature key is enhanced with a stronger hash algorithm. In addition, the signature key is signed with the identity key to create a counter-signature.  \n  \n The <xref:System.Reflection.AssemblySignatureKeyAttribute> attribute enables the assembly metadata to use the pre-existing public key for assembly identity, which allows old assembly references to continue to work.  The <xref:System.Reflection.AssemblySignatureKeyAttribute> attribute uses the counter-signature to ensure that the owner of the new signature key is also the owner of the old identity key.  \n  \n### Signing with SHA-2, Without Key Migration  \n Run the following commands from a Command Prompt window to sign an assembly without migrating a strong name signature:  \n  \n1.  Generate the new identity key (if necessary).  \n  \n    ```  \n    sn -k IdentityKey.snk  \n    ```  \n  \n2.  Extract the identity public key, and specify that a SHA-2 algorithm should be used when signing with this key.  \n  \n    ```  \n    sn -p IdentityKey.snk IdentityPubKey.snk sha256  \n    ```  \n  \n3.  Delay-sign the assembly with the identity public key file.  \n  \n    ```  \n    csc MyAssembly.cs /keyfile:IdentityPubKey.snk /delaySign+  \n    ```  \n  \n4.  Re-sign the assembly with the full identity key pair.  \n  \n    ```  \n    sn -Ra MyAssembly.exe IdentityKey.snk  \n    ```  \n  \n### Signing with SHA-2, with Key Migration  \n Run the following commands from a Command Prompt window to sign an assembly with a migrated strong name signature.  \n  \n1.  Generate an identity and signature key pair (if necessary).  \n  \n    ```  \n    sn -k IdentityKey.snk  \n    sn -k SignatureKey.snk  \n    ```  \n  \n2.  Extract the signature public key, and specify that a SHA-2 algorithm should be used when signing with this key.  \n  \n    ```  \n    sn -p SignatureKey.snk SignaturePubKey.snk sha256  \n    ```  \n  \n3.  Extract the identity public key, which determines the hash algorithm that generates a counter-signature.  \n  \n    ```  \n    sn -p IdentityKey.snk IdentityPubKey.snk  \n    ```  \n  \n4.  Generate the parameters for a <xref:System.Reflection.AssemblySignatureKeyAttribute> attribute, and attach the attribute to the assembly.  \n  \n    ```  \n    sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk  \n    ```  \n\n    This produces output similar to the following.\n\n    ```\n    Information for key migration attribute.\n    (System.Reflection.AssemblySignatureKeyAttribute):\n    publicKey=\n    002400000c80000094000000060200000024000052534131000400000100010005a3a81ac0a519\n    d96244a9c589fc147c7d403e40ccf184fc290bdd06c7339389a76b738e255a2bce1d56c3e7e936\n    e4fc87d45adc82ca94c716b50a65d39d373eea033919a613e4341c66863cb2dc622bcb541762b4\n    3893434d219d1c43f07e9c83fada2aed400b9f6e44ff05e3ecde6c2827830b8f43f7ac8e3270a3\n    4d153cdd\n\n    counterSignature=\n    e3cf7c211678c4d1a7b8fb20276c894ab74c29f0b5a34de4d61e63d4a997222f78cdcbfe4c91eb\n    e1ddf9f3505a32edcb2a76f34df0450c4f61e376b70fa3cdeb7374b1b8e2078b121e2ee6e8c6a8\n    ed661cc35621b4af53ac29c9e41738f199a81240e8fd478c887d1a30729d34e954a97cddce66e3\n    ae5fec2c682e57b7442738\n    ```\n\n    This output can then be transformed into an AssemblySignatureKeyAttribute.\n\n    ```\n    [assembly:System.Reflection.AssemblySignatureKeyAttribute(\n    \"002400000c80000094000000060200000024000052534131000400000100010005a3a81ac0a519d96244a9c589fc147c7d403e40ccf184fc290bdd06c7339389a76b738e255a2bce1d56c3e7e936e4fc87d45adc82ca94c716b50a65d39d373eea033919a613e4341c66863cb2dc622bcb541762b43893434d219d1c43f07e9c83fada2aed400b9f6e44ff05e3ecde6c2827830b8f43f7ac8e3270a34d153cdd\",\n    \"e3cf7c211678c4d1a7b8fb20276c894ab74c29f0b5a34de4d61e63d4a997222f78cdcbfe4c91ebe1ddf9f3505a32edcb2a76f34df0450c4f61e376b70fa3cdeb7374b1b8e2078b121e2ee6e8c6a8ed661cc35621b4af53ac29c9e41738f199a81240e8fd478c887d1a30729d34e954a97cddce66e3ae5fec2c682e57b7442738\"\n    )]\n    ```\n  \n5.  Delay-sign the assembly with the identity public key.  \n  \n    ```  \n    csc MyAssembly.cs /keyfile:IdentityPubKey.snk /delaySign+  \n    ```  \n  \n6.  Fully sign the assembly with the signature key pair.  \n  \n    ```  \n    sn -Ra MyAssembly.exe SignatureKey.snk  \n    ```  \n  \n## See also\n\n- [Creating and Using Strong-Named Assemblies](../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md)\n","nodes":[{"pos":[4,245],"embed":true,"restype":"x-metadata","content":"title: \"Enhanced Strong Naming\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"strong-named assemblies\"\n  - \"strong naming [.NET Framework], enhanced\"\nms.assetid: 6cf17a82-62a1-4f6d-8d5a-d7d06dec2bb5\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Enhanced Strong Naming","nodes":[{"pos":[0,22],"content":"Enhanced Strong Naming","nodes":[{"content":"Enhanced Strong Naming","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[252,274],"content":"Enhanced Strong Naming","linkify":"Enhanced Strong Naming","nodes":[{"content":"Enhanced Strong Naming","pos":[0,22]}]},{"content":"A strong name signature is an identity mechanism in the .NET Framework for identifying assemblies.","pos":[275,373]},{"content":"It is a public-key digital signature that is typically used to verify the integrity of data being passed from an originator (signer) to a recipient (verifier).","pos":[374,533]},{"content":"This signature is used as a unique identity for an assembly and ensures that references to the assembly are not ambiguous.","pos":[534,656]},{"content":"The assembly is signed as part of the build process and then verified when it is loaded.","pos":[657,745]},{"content":"Strong name signatures help prevent malicious parties from tampering with an assembly and then re-signing the assembly with the original signer’s key.","pos":[752,902]},{"content":"However, strong name keys don’t contain any reliable information about the publisher, nor do they contain a certificate hierarchy.","pos":[903,1033]},{"content":"A strong name signature does not guarantee the trustworthiness of the person who signed the assembly or indicate whether that person was a legitimate owner of the key; it indicates only that the owner of the key signed the assembly.","pos":[1034,1266]},{"content":"Therefore, we do not recommend using a strong name signature as a security validator for trusting third-party code.","pos":[1267,1382]},{"content":"Microsoft Authenticode is the recommended way to authenticate code.","pos":[1383,1450]},{"pos":[1459,1499],"content":"Limitations of Conventional Strong Names","linkify":"Limitations of Conventional Strong Names","nodes":[{"content":"Limitations of Conventional Strong Names","pos":[0,40]}]},{"pos":[1503,1644],"content":"The strong naming technology used in versions before the <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> has the following shortcomings:","source":"The strong naming technology used in versions before the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] has the following shortcomings:"},{"content":"Keys are constantly under attack, and improved techniques and hardware make it easier to infer a private key from a public key.","pos":[1654,1781]},{"content":"To guard against attacks, larger keys are necessary.","pos":[1782,1834]},{"content":".NET Framework versions before the <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> provide the ability to sign with any size key (the default size is 1024 bits), but signing an assembly with a new key breaks all binaries that reference the older identity of the assembly.","pos":[1835,2111],"source":" .NET Framework versions before the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] provide the ability to sign with any size key (the default size is 1024 bits), but signing an assembly with a new key breaks all binaries that reference the older identity of the assembly."},{"content":"Therefore, it is extremely difficult to upgrade the size of a signing key if you want to maintain compatibility.","pos":[2112,2224]},{"content":"Strong name signing supports only the SHA-1 algorithm.","pos":[2234,2288]},{"content":"SHA-1 has recently been found to be inadequate for secure hashing applications.","pos":[2289,2368]},{"content":"Therefore, a stronger algorithm (SHA-256 or greater) is necessary.","pos":[2369,2435]},{"content":"It is possible that SHA-1 will lose its FIPS-compliant standing, which would present problems for those who choose to use only FIPS-compliant software and algorithms.","pos":[2436,2602]},{"pos":[2611,2646],"content":"Advantages of Enhanced Strong Names","linkify":"Advantages of Enhanced Strong Names","nodes":[{"content":"Advantages of Enhanced Strong Names","pos":[0,35]}]},{"content":"The main advantages of enhanced strong names are compatibility with pre-existing strong names and the ability to claim that one identity is equivalent to another:","pos":[2650,2812]},{"content":"Developers who have pre-existing signed assemblies can migrate their identities to the SHA-2 algorithms while maintaining compatibility with assemblies that reference the old identities.","pos":[2822,3008]},{"content":"Developers who create new assemblies and are not concerned with pre-existing strong name signatures can use the more secure SHA-2 algorithms and sign the assemblies as they always have.","pos":[3018,3203]},{"pos":[3212,3239],"content":"Using Enhanced Strong Names","linkify":"Using Enhanced Strong Names","nodes":[{"content":"Using Enhanced Strong Names","pos":[0,27]}]},{"content":"Strong name keys consist of a signature key and an identity key.","pos":[3243,3307]},{"content":"The assembly is signed with the signature key and is identified by the identity key.","pos":[3308,3392]},{"content":"Prior to the <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, these two keys were identical.","pos":[3393,3490],"source":" Prior to the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], these two keys were identical."},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, the identity key remains the same as in earlier .NET Framework versions, but the signature key is enhanced with a stronger hash algorithm.","pos":[3491,3701],"source":" Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], the identity key remains the same as in earlier .NET Framework versions, but the signature key is enhanced with a stronger hash algorithm."},{"content":"In addition, the signature key is signed with the identity key to create a counter-signature.","pos":[3702,3795]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblySignatureKeyAttribute&gt;</ph> attribute enables the assembly metadata to use the pre-existing public key for assembly identity, which allows old assembly references to continue to work.","pos":[3802,4016],"source":"The <xref:System.Reflection.AssemblySignatureKeyAttribute> attribute enables the assembly metadata to use the pre-existing public key for assembly identity, which allows old assembly references to continue to work."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblySignatureKeyAttribute&gt;</ph> attribute uses the counter-signature to ensure that the owner of the new signature key is also the owner of the old identity key.","pos":[4018,4206],"source":"  The <xref:System.Reflection.AssemblySignatureKeyAttribute> attribute uses the counter-signature to ensure that the owner of the new signature key is also the owner of the old identity key."},{"pos":[4216,4257],"content":"Signing with SHA-2, Without Key Migration","linkify":"Signing with SHA-2, Without Key Migration","nodes":[{"content":"Signing with SHA-2, Without Key Migration","pos":[0,41]}]},{"content":"Run the following commands from a Command Prompt window to sign an assembly without migrating a strong name signature:","pos":[4261,4379]},{"content":"Generate the new identity key (if necessary).","pos":[4389,4434]},{"content":"Extract the identity public key, and specify that a SHA-2 algorithm should be used when signing with this key.","pos":[4495,4605]},{"content":"Delay-sign the assembly with the identity public key file.","pos":[4692,4750]},{"content":"Re-sign the assembly with the full identity key pair.","pos":[4847,4900]},{"pos":[4977,5015],"content":"Signing with SHA-2, with Key Migration","linkify":"Signing with SHA-2, with Key Migration","nodes":[{"content":"Signing with SHA-2, with Key Migration","pos":[0,38]}]},{"content":"Run the following commands from a Command Prompt window to sign an assembly with a migrated strong name signature.","pos":[5019,5133]},{"content":"Generate an identity and signature key pair (if necessary).","pos":[5143,5202]},{"content":"Extract the signature public key, and specify that a SHA-2 algorithm should be used when signing with this key.","pos":[5292,5403]},{"content":"Extract the identity public key, which determines the hash algorithm that generates a counter-signature.","pos":[5492,5596]},{"pos":[5676,5813],"content":"Generate the parameters for a <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblySignatureKeyAttribute&gt;</ph> attribute, and attach the attribute to the assembly.","source":"Generate the parameters for a <xref:System.Reflection.AssemblySignatureKeyAttribute> attribute, and attach the attribute to the assembly."},{"content":"This produces output similar to the following.","pos":[5911,5957]},{"content":"This output can then be transformed into an AssemblySignatureKeyAttribute.","pos":[6739,6813]},{"content":"Delay-sign the assembly with the identity public key.","pos":[7499,7552]},{"content":"Fully sign the assembly with the signature key pair.","pos":[7649,7701]},{"pos":[7778,7786],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7790,7913],"content":"<bpt id=\"p1\">[</bpt>Creating and Using Strong-Named Assemblies<ept id=\"p1\">](../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md)</ept>","source":"[Creating and Using Strong-Named Assemblies](../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md)"}]}