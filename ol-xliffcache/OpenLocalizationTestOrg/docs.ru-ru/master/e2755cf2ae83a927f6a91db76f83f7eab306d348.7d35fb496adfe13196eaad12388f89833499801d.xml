{"content":"---\ntitle: \"Decimal Data Type (Visual Basic) | Microsoft Docs\"\n\nms.date: \"2015-07-20\"\nms.prod: .net\n\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\nf1_keywords: \n  - \"vb.Decimal\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"literal type characters, D\"\n  - \"trailing zeros\"\n  - \"real numbers\"\n  - \"trailing 0 characters\"\n  - \"Decimal data type\"\n  - \"D literal type character\"\n  - \"decimals, Decimal data type\"\n  - \"0 characters, trailing\"\n  - \"data types [Visual Basic], assigning\"\n  - \"decimal keyword\"\n  - \"numbers, real\"\n  - \"variable-precision numbers\"\n  - \"zeros, trailing\"\n  - \"@ identifier type character\"\n  - \"identifier type characters, @\"\nms.assetid: 1d855b45-afe2-45b0-a623-96b6f63a43d5\ncaps.latest.revision: 20\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Decimal Data Type (Visual Basic)\nHolds signed 128-bit (16-byte) values representing 96-bit (12-byte) integer numbers scaled by a variable power of 10. The scaling factor specifies the number of digits to the right of the decimal point; it ranges from 0 through 28. With a scale of 0 (no decimal places), the largest possible value is +/-79,228,162,514,264,337,593,543,950,335 (+/-7.9228162514264337593543950335E+28). With 28 decimal places, the largest value is +/-7.9228162514264337593543950335, and the smallest nonzero value is +/-0.0000000000000000000000000001 (+/-1E-28).  \n  \n## Remarks  \n The `Decimal` data type provides the greatest number of significant digits for a number. It supports up to 29 significant digits and can represent values in excess of 7.9228 x 10^28. It is particularly suitable for calculations, such as financial, that require a large number of digits but cannot tolerate rounding errors.  \n  \n The default value of `Decimal` is 0.  \n  \n## Programming Tips  \n  \n-   **Precision.** `Decimal` is not a floating-point data type. The `Decimal` structure holds a binary integer value, together with a sign bit and an integer scaling factor that specifies what portion of the value is a decimal fraction. Because of this, `Decimal` numbers have a more precise representation in memory than floating-point types (`Single` and `Double`).  \n  \n-   **Performance.** The `Decimal` data type is the slowest of all the numeric types. You should weigh the importance of precision against performance before choosing a data type.  \n  \n-   **Widening.** The `Decimal` data type widens to `Single` or `Double`. This means you can convert `Decimal` to either of these types without encountering a <xref:System.OverflowException?displayProperty=fullName> error.  \n  \n-   **Trailing Zeros.** Visual Basic does not store trailing zeros in a `Decimal` literal. However, a `Decimal` variable preserves any trailing zeros acquired computationally. The following example illustrates this.  \n  \n    ```  \n    Dim d1, d2, d3, d4 As Decimal  \n    d1 = 2.375D  \n    d2 = 1.625D  \n    d3 = d1 + d2  \n    d4 = 4.000D  \n    MsgBox(\"d1 = \" & CStr(d1) & \", d2 = \" & CStr(d2) &  \n          \", d3 = \" & CStr(d3) & \", d4 = \" & CStr(d4))  \n    ```  \n  \n     The output of `MsgBox` in the preceding example is as follows:  \n  \n     d1 = 2.375, d2 = 1.625, d3 = 4.000, d4 = 4  \n  \n-   **Type Characters.** Appending the literal type character `D` to a literal forces it to the `Decimal` data type. Appending the identifier type character `@` to any identifier forces it to `Decimal`.  \n  \n-   **Framework Type.** The corresponding type in the .NET Framework is the <xref:System.Decimal?displayProperty=fullName> structure.  \n  \n## Range  \n You might need to use the `D` type character to assign a large value to a `Decimal` variable or constant. This requirement is because the compiler interprets a literal as `Long` unless a literal type character follows the literal, as the following example shows.  \n  \n```  \nDim bigDec1 As Decimal = 9223372036854775807   ' No overflow.  \nDim bigDec2 As Decimal = 9223372036854775808   ' Overflow.  \nDim bigDec3 As Decimal = 9223372036854775808D  ' No overflow.  \n```  \n  \n The declaration for `bigDec1` doesn't produce an overflow because the value that's assigned to it falls within the range for `Long`. The `Long` value can be assigned to the `Decimal` variable.  \n  \n The declaration for `bigDec2` generates an overflow error because the value that's assigned to it is too large for `Long`. Because the numeric literal can't first be interpreted as a `Long`, it can't be assigned to the `Decimal` variable.  \n  \n For `bigDec3`, the literal type character `D` solves the problem by forcing the compiler to interpret the literal as a `Decimal` instead of as a `Long`.  \n  \n## See Also  \n <xref:System.Decimal?displayProperty=fullName>   \n <xref:System.Decimal.%23ctor%2A?displayProperty=fullName>   \n <xref:System.Math.Round%2A?displayProperty=fullName>   \n [Data Types](../../../visual-basic/language-reference/data-types/data-type-summary.md)   \n [Single Data Type](../../../visual-basic/language-reference/data-types/single-data-type.md)   \n [Double Data Type](../../../visual-basic/language-reference/data-types/double-data-type.md)   \n [Type Conversion Functions](../../../visual-basic/language-reference/functions/type-conversion-functions.md)   \n [Conversion Summary](../../../visual-basic/language-reference/keywords/conversion-summary.md)   \n [Efficient Use of Data Types](../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)","nodes":[{"pos":[12,61],"content":"Decimal Data Type (Visual Basic) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Decimal Data Type (Visual Basic) | Microsoft Docs","pos":[0,49]}]},{"pos":[988,1020],"content":"Decimal Data Type (Visual Basic)","linkify":"Decimal Data Type (Visual Basic)","nodes":[{"content":"Decimal Data Type (Visual Basic)","pos":[0,32]}]},{"content":"Holds signed 128-bit (16-byte) values representing 96-bit (12-byte) integer numbers scaled by a variable power of 10.","pos":[1021,1138]},{"content":"The scaling factor specifies the number of digits to the right of the decimal point; it ranges from 0 through 28.","pos":[1139,1252]},{"content":"With a scale of 0 (no decimal places), the largest possible value is +/-79,228,162,514,264,337,593,543,950,335 (+/-7.9228162514264337593543950335E+28).","pos":[1253,1404]},{"content":"With 28 decimal places, the largest value is +/-7.9228162514264337593543950335, and the smallest nonzero value is +/-0.0000000000000000000000000001 (+/-1E-28).","pos":[1405,1564]},{"pos":[1573,1580],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">`Decimal`</ph> data type provides the greatest number of significant digits for a number.","pos":[1584,1672],"source":"The `Decimal` data type provides the greatest number of significant digits for a number."},{"content":"It supports up to 29 significant digits and can represent values in excess of 7.9228 x 10^28.","pos":[1673,1766]},{"content":"It is particularly suitable for calculations, such as financial, that require a large number of digits but cannot tolerate rounding errors.","pos":[1767,1906]},{"pos":[1913,1949],"content":"The default value of <ph id=\"ph1\">`Decimal`</ph> is 0.","source":"The default value of `Decimal` is 0."},{"pos":[1958,1974],"content":"Programming Tips","linkify":"Programming Tips","nodes":[{"content":"Programming Tips","pos":[0,16]}]},{"content":"<bpt id=\"p1\">**</bpt>Precision.<ept id=\"p1\">**</ept>","pos":[1984,1998],"source":"**Precision.**"},{"content":"<ph id=\"ph1\">`Decimal`</ph> is not a floating-point data type.","pos":[1999,2043],"source":"`Decimal` is not a floating-point data type."},{"content":"The <ph id=\"ph1\">`Decimal`</ph> structure holds a binary integer value, together with a sign bit and an integer scaling factor that specifies what portion of the value is a decimal fraction.","pos":[2044,2216],"source":" The `Decimal` structure holds a binary integer value, together with a sign bit and an integer scaling factor that specifies what portion of the value is a decimal fraction."},{"content":"Because of this, <ph id=\"ph1\">`Decimal`</ph> numbers have a more precise representation in memory than floating-point types (<ph id=\"ph2\">`Single`</ph> and <ph id=\"ph3\">`Double`</ph>).","pos":[2217,2347],"source":" Because of this, `Decimal` numbers have a more precise representation in memory than floating-point types (`Single` and `Double`)."},{"content":"<bpt id=\"p1\">**</bpt>Performance.<ept id=\"p1\">**</ept>","pos":[2357,2373],"source":"**Performance.**"},{"content":"The <ph id=\"ph1\">`Decimal`</ph> data type is the slowest of all the numeric types.","pos":[2374,2438],"source":" The `Decimal` data type is the slowest of all the numeric types."},{"content":"You should weigh the importance of precision against performance before choosing a data type.","pos":[2439,2532]},{"content":"<bpt id=\"p1\">**</bpt>Widening.<ept id=\"p1\">**</ept>","pos":[2542,2555],"source":"**Widening.**"},{"content":"The <ph id=\"ph1\">`Decimal`</ph> data type widens to <ph id=\"ph2\">`Single`</ph> or <ph id=\"ph3\">`Double`</ph>.","pos":[2556,2611],"source":" The `Decimal` data type widens to `Single` or `Double`."},{"content":"This means you can convert <ph id=\"ph1\">`Decimal`</ph> to either of these types without encountering a <ph id=\"ph2\">&lt;xref:System.OverflowException?displayProperty=fullName&gt;</ph> error.","pos":[2612,2760],"source":" This means you can convert `Decimal` to either of these types without encountering a <xref:System.OverflowException?displayProperty=fullName> error."},{"content":"<bpt id=\"p1\">**</bpt>Trailing Zeros.<ept id=\"p1\">**</ept>","pos":[2770,2789],"source":"**Trailing Zeros.**"},{"content":"Visual Basic does not store trailing zeros in a <ph id=\"ph1\">`Decimal`</ph> literal.","pos":[2790,2856],"source":" Visual Basic does not store trailing zeros in a `Decimal` literal."},{"content":"However, a <ph id=\"ph1\">`Decimal`</ph> variable preserves any trailing zeros acquired computationally.","pos":[2857,2941],"source":" However, a `Decimal` variable preserves any trailing zeros acquired computationally."},{"content":"The following example illustrates this.","pos":[2942,2981]},{"pos":[3238,3300],"content":"The output of <ph id=\"ph1\">`MsgBox`</ph> in the preceding example is as follows:","source":"The output of `MsgBox` in the preceding example is as follows:"},{"content":"d1 = 2.375, d2 = 1.625, d3 = 4.000, d4 = 4","pos":[3311,3353]},{"content":"<bpt id=\"p1\">**</bpt>Type Characters.<ept id=\"p1\">**</ept>","pos":[3363,3383],"source":"**Type Characters.**"},{"content":"Appending the literal type character <ph id=\"ph1\">`D`</ph> to a literal forces it to the <ph id=\"ph2\">`Decimal`</ph> data type.","pos":[3384,3475],"source":" Appending the literal type character `D` to a literal forces it to the `Decimal` data type."},{"content":"Appending the identifier type character <ph id=\"ph1\">`@`</ph> to any identifier forces it to <ph id=\"ph2\">`Decimal`</ph>.","pos":[3476,3561],"source":" Appending the identifier type character `@` to any identifier forces it to `Decimal`."},{"content":"<bpt id=\"p1\">**</bpt>Framework Type.<ept id=\"p1\">**</ept>","pos":[3571,3590],"source":"**Framework Type.**"},{"content":"The corresponding type in the .NET Framework is the <ph id=\"ph1\">&lt;xref:System.Decimal?displayProperty=fullName&gt;</ph> structure.","pos":[3591,3700],"source":" The corresponding type in the .NET Framework is the <xref:System.Decimal?displayProperty=fullName> structure."},{"pos":[3709,3714],"content":"Range","linkify":"Range","nodes":[{"content":"Range","pos":[0,5]}]},{"content":"You might need to use the <ph id=\"ph1\">`D`</ph> type character to assign a large value to a <ph id=\"ph2\">`Decimal`</ph> variable or constant.","pos":[3718,3823],"source":"You might need to use the `D` type character to assign a large value to a `Decimal` variable or constant."},{"content":"This requirement is because the compiler interprets a literal as <ph id=\"ph1\">`Long`</ph> unless a literal type character follows the literal, as the following example shows.","pos":[3824,3980],"source":" This requirement is because the compiler interprets a literal as `Long` unless a literal type character follows the literal, as the following example shows."},{"content":"The declaration for <ph id=\"ph1\">`bigDec1`</ph> doesn't produce an overflow because the value that's assigned to it falls within the range for <ph id=\"ph2\">`Long`</ph>.","pos":[4191,4323],"source":"The declaration for `bigDec1` doesn't produce an overflow because the value that's assigned to it falls within the range for `Long`."},{"content":"The <ph id=\"ph1\">`Long`</ph> value can be assigned to the <ph id=\"ph2\">`Decimal`</ph> variable.","pos":[4324,4383],"source":" The `Long` value can be assigned to the `Decimal` variable."},{"content":"The declaration for <ph id=\"ph1\">`bigDec2`</ph> generates an overflow error because the value that's assigned to it is too large for <ph id=\"ph2\">`Long`</ph>.","pos":[4390,4512],"source":"The declaration for `bigDec2` generates an overflow error because the value that's assigned to it is too large for `Long`."},{"content":"Because the numeric literal can't first be interpreted as a <ph id=\"ph1\">`Long`</ph>, it can't be assigned to the <ph id=\"ph2\">`Decimal`</ph> variable.","pos":[4513,4628],"source":" Because the numeric literal can't first be interpreted as a `Long`, it can't be assigned to the `Decimal` variable."},{"pos":[4635,4787],"content":"For <ph id=\"ph1\">`bigDec3`</ph>, the literal type character <ph id=\"ph2\">`D`</ph> solves the problem by forcing the compiler to interpret the literal as a <ph id=\"ph3\">`Decimal`</ph> instead of as a <ph id=\"ph4\">`Long`</ph>.","source":"For `bigDec3`, the literal type character `D` solves the problem by forcing the compiler to interpret the literal as a `Decimal` instead of as a `Long`."},{"pos":[4796,4804],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\"> [</bpt>Data Types<ept id=\"p1\">](../../../visual-basic/language-reference/data-types/data-type-summary.md)</ept><ph id=\"ph1\"> </ph>","pos":[4977,5065],"source":" [Data Types](../../../visual-basic/language-reference/data-types/data-type-summary.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Single Data Type<ept id=\"p1\">](../../../visual-basic/language-reference/data-types/single-data-type.md)</ept><ph id=\"ph1\"> </ph>","pos":[5068,5161],"source":" [Single Data Type](../../../visual-basic/language-reference/data-types/single-data-type.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Double Data Type<ept id=\"p1\">](../../../visual-basic/language-reference/data-types/double-data-type.md)</ept><ph id=\"ph1\"> </ph>","pos":[5164,5257],"source":" [Double Data Type](../../../visual-basic/language-reference/data-types/double-data-type.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Type Conversion Functions<ept id=\"p1\">](../../../visual-basic/language-reference/functions/type-conversion-functions.md)</ept><ph id=\"ph1\"> </ph>","pos":[5260,5370],"source":" [Type Conversion Functions](../../../visual-basic/language-reference/functions/type-conversion-functions.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Conversion Summary<ept id=\"p1\">](../../../visual-basic/language-reference/keywords/conversion-summary.md)</ept><ph id=\"ph1\"> </ph>","pos":[5373,5468],"source":" [Conversion Summary](../../../visual-basic/language-reference/keywords/conversion-summary.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Efficient Use of Data Types<ept id=\"p1\">](../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)</ept>","pos":[5471,5602],"source":" [Efficient Use of Data Types](../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)"}]}