{"content":"---\ntitle: Group results by contiguous keys (LINQ in C#)\ndescription: How to group results by contiguous keys using LINQ in C#.\nms.date: 08/14/2018\nms.assetid: cbda9c08-151b-4c9e-82f7-c3d7f3dac66b\n---\n# Group results by contiguous keys\n\nThe following example shows how to group elements into chunks that represent subsequences of contiguous keys. For example, assume that you are given the following sequence of key-value pairs:\n\n|Key|Value|\n|---------|-----------|\n|A|We|\n|A|think|\n|A|that|\n|B|Linq|\n|C|is|\n|A|really|\n|B|cool|\n|B|!|\n\nThe following groups will be created in this order:\n\n1. We, think, that\n\n2. Linq\n\n3. is\n\n4. really\n\n5. cool, !\n\nThe solution is implemented as an extension method that is thread-safe and that returns its results in a streaming manner. In other words, it produces its groups as it moves through the source sequence. Unlike the `group` or `orderby` operators, it can begin returning groups to the caller before all of the sequence has been read.\n\nThread-safety is accomplished by making a copy of each group or chunk as the source sequence is iterated, as explained in the source code comments. If the source sequence has a large sequence of contiguous items, the common language runtime may throw an <xref:System.OutOfMemoryException>.\n\n## Example\n\nThe following example shows both the extension method and the client code that uses it:\n\n[!code-csharp[cscsrefContiguousGroups#1](~/samples/snippets/csharp/concepts/linq/how-to-group-results-by-contiguous-keys_1.cs)]\n\nTo use the extension method in your project, copy the `MyExtensions` static class to a new or existing source code file and if it is required, add a `using` directive for the namespace where it is located.\n\n## See also\n\n- [Language Integrated Query (LINQ)](index.md)\n","nodes":[{"pos":[4,196],"embed":true,"restype":"x-metadata","content":"title: Group results by contiguous keys (LINQ in C#)\ndescription: How to group results by contiguous keys using LINQ in C#.\nms.date: 08/14/2018\nms.assetid: cbda9c08-151b-4c9e-82f7-c3d7f3dac66b","nodes":[{"content":"Group results by contiguous keys (LINQ in C#)","nodes":[{"pos":[0,45],"content":"Group results by contiguous keys (LINQ in C#)","nodes":[{"content":"Group results by contiguous keys (LINQ in C#)","pos":[0,45]}]}],"path":["title"],"nosxs":false},{"content":"How to group results by contiguous keys using LINQ in C#.","nodes":[{"pos":[0,57],"content":"How to group results by contiguous keys using LINQ in C#.","nodes":[{"content":"How to group results by contiguous keys using LINQ in C#.","pos":[0,57]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[203,235],"content":"Group results by contiguous keys","linkify":"Group results by contiguous keys","nodes":[{"content":"Group results by contiguous keys","pos":[0,32]}]},{"content":"The following example shows how to group elements into chunks that represent subsequences of contiguous keys.","pos":[237,346]},{"content":"For example, assume that you are given the following sequence of key-value pairs:","pos":[347,428]},{"content":"Key","pos":[431,434]},{"content":"Value","pos":[435,440]},{"content":"A","pos":[467,468]},{"content":"We","pos":[469,471]},{"content":"A","pos":[474,475]},{"content":"think","pos":[476,481]},{"content":"A","pos":[484,485]},{"content":"that","pos":[486,490]},{"content":"B","pos":[493,494]},{"content":"Linq","pos":[495,499]},{"content":"C","pos":[502,503]},{"content":"is","pos":[504,506]},{"content":"A","pos":[509,510]},{"content":"really","pos":[511,517]},{"content":"B","pos":[520,521]},{"content":"cool","pos":[522,526]},{"content":"B","pos":[529,530]},{"content":"!","pos":[531,532]},{"content":"The following groups will be created in this order:","pos":[535,586]},{"content":"We, think, that","pos":[591,606]},{"content":"Linq","pos":[611,615]},{"content":"is","pos":[620,622]},{"content":"really","pos":[627,633]},{"content":"cool, !","pos":[638,645]},{"content":"The solution is implemented as an extension method that is thread-safe and that returns its results in a streaming manner.","pos":[647,769]},{"content":"In other words, it produces its groups as it moves through the source sequence.","pos":[770,849]},{"content":"Unlike the <ph id=\"ph1\">`group`</ph> or <ph id=\"ph2\">`orderby`</ph> operators, it can begin returning groups to the caller before all of the sequence has been read.","pos":[850,978],"source":" Unlike the `group` or `orderby` operators, it can begin returning groups to the caller before all of the sequence has been read."},{"content":"Thread-safety is accomplished by making a copy of each group or chunk as the source sequence is iterated, as explained in the source code comments.","pos":[980,1127]},{"content":"If the source sequence has a large sequence of contiguous items, the common language runtime may throw an <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph>.","pos":[1128,1269],"source":" If the source sequence has a large sequence of contiguous items, the common language runtime may throw an <xref:System.OutOfMemoryException>."},{"pos":[1274,1281],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows both the extension method and the client code that uses it:","pos":[1283,1370]},{"pos":[1501,1706],"content":"To use the extension method in your project, copy the <ph id=\"ph1\">`MyExtensions`</ph> static class to a new or existing source code file and if it is required, add a <ph id=\"ph2\">`using`</ph> directive for the namespace where it is located.","source":"To use the extension method in your project, copy the `MyExtensions` static class to a new or existing source code file and if it is required, add a `using` directive for the namespace where it is located."},{"pos":[1711,1719],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[1723,1767],"content":"<bpt id=\"p1\">[</bpt>Language Integrated Query (LINQ)<ept id=\"p1\">](index.md)</ept>","source":"[Language Integrated Query (LINQ)](index.md)"}]}