{"content":"---\ntitle: \"in parameter modifier - C# Reference\"\nms.custom: seodec18\nms.date: 03/26/2019\nhelpviewer_keywords: \n  - \"parameters [C#], in\"\n  - \"in parameters [C#]\"\n---\n\n# in parameter modifier (C# Reference)\n\nThe `in` keyword causes arguments to be passed by reference. It makes the formal parameter an alias for the argument, which must be a variable. In other words, any operation on the parameter is made on the argument. It is like the [ref](ref.md) or [out](out-parameter-modifier.md) keywords, except that `in` arguments cannot be modified by the called method. Whereas `ref` arguments may be modified, `out` arguments must be modified by the called method, and those modifications are observable in the calling context.\n\n[!code-csharp-interactive[cs-in-keyword](../../../../samples/snippets/csharp/language-reference/keywords/in-ref-out-modifier/InParameterModifier.cs#1)]  \n\nThe preceding example demonstrates that the `in` modifier is usually unnecessary at the call site. It is only required in the method declaration.\n\n> [!NOTE] \n> The `in` keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as part of a `foreach` statement, or as part of a `join` clause in a LINQ query. For more information on the use of the `in` keyword in these contexts, see [in](in.md), which provides links to all those uses.\n  \nVariables passed as `in` arguments must be initialized before being passed in a method call. However, the called method may not assign a value or modify the argument.  \n\nThe `in` parameter modifier is available in C# 7.2 and later. Previous versions generate compiler error `CS8107` (\"Feature 'readonly references' is not available in C# 7.0. Please use language version 7.2 or greater.\") To configure the compiler language version, see [Select the C# language version](../configure-language-version.md).\n\nThe `in`, `ref`, and `out` keywords are not considered part of the method signature for the purpose of overload resolution. Therefore, methods cannot be overloaded if the only difference is that one method takes a `ref` or `in` argument and the other takes an `out` argument. The following code, for example, will not compile:  \n  \n```csharp\nclass CS0663_Example\n{\n    // Compiler error CS0663: \"Cannot define overloaded \n    // methods that differ only on in, ref and out\".\n    public void SampleMethod(in int i) { }\n    public void SampleMethod(ref int i) { }\n}\n```\n  \nOverloading based on the presence of `in` is allowed:  \n  \n```csharp\nclass InOverloads\n{\n    public void SampleMethod(in int i) { }\n    public void SampleMethod(int i) { }\n}\n```\n\n## Overload resolution rules\n\nYou can understand the overload resolution rules for methods with by value vs. `in` arguments by understanding the motivation for `in` arguments. Defining methods using `in` parameters is a potential performance optimization. Some `struct` type arguments may be large in size, and when methods are called in tight loops or critical code paths, the cost of copying those structures is critical. Methods declare `in` parameters to specify that arguments may be passed by reference safely because the called method does not modify the state of that argument. Passing those arguments by reference avoids the (potentially) expensive copy. \n\nSpecifying `in` for arguments at the call site is typically optional. There is no semantic difference between passing arguments by value and passing them by reference using the `in` modifier. The `in` modifier at the call site is optional because you don't need to indicate that the argument's value might be changed. You explicitly add the `in` modifier at the call site to ensure the argument is passed by reference, not by value. Explicitly using `in` has the following two effects:\n\nFirst, specifying `in` at the call site forces the compiler to select a method defined with a matching `in` parameter. Otherwise, when two methods differ only in the presence of `in`, the by value overload is a better match.\n\nSecond, specifying `in` declares your intent to pass an argument by reference. The argument used with `in` must represent a location that can be directly referred to. The same general rules for `out` and `ref` arguments apply: You cannot use constants, ordinary properties, or other expressions that produce values. Otherwise, omitting `in` at the call site informs the compiler that you will allow it to create a temporary variable to pass by read-only reference to the method. The compiler creates a temporary variable to overcome several restrictions with `in` arguments:\n\n- A temporary variable allows compile-time constants as `in` parameters.\n- A temporary variable allows properties, or other expressions for `in` parameters.\n- A temporary variable allows arguments where there is an implicit conversion from the argument type to the parameter type.\n\nIn all the preceding instances, the compiler creates a temporary variable that stores the value of the constant, property, or other expression.\n\nThe following code illustrates these rules:\n\n```csharp\nstatic void Method(in int argument)\n{\n    // implementation removed\n}\n\nMethod(5); // OK, temporary variable created.\nMethod(5L); // CS1503: no implicit conversion from long to int\nshort s = 0;\nMethod(s); // OK, temporary int created with the value 0\nMethod(in s); // CS1503: cannot convert from in short to in int\nint i = 42;\nMethod(i); // passed by readonly reference\nMethod(in i); // passed by readonly reference, explicitly using `in`\n```\n\nNow, suppose another method using by value arguments was available. The results change as shown in the following code:\n\n```csharp\nstatic void Method(int argument)\n{\n    // implementation removed\n}\n\nstatic void Method(in int argument)\n{\n    // implementation removed\n}\n\nMethod(5); // Calls overload passed by value\nMethod(5L); // CS1503: no implicit conversion from long to int\nshort s = 0;\nMethod(s); // Calls overload passed by value.\nMethod(in s); // CS1503: cannot convert from in short to in int\nint i = 42;\nMethod(i); // Calls overload passed by value\nMethod(in i); // passed by readonly reference, explicitly using `in`\n```\n\nThe only method call where the argument is passed by reference is the final one.\n\n> [!NOTE]\n> The preceding code uses `int` as the argument type for simplicity. Because `int` is no larger than a reference in most modern machines, there is no benefit to passing a single `int` as a readonly reference. \n\n## Limitations on `in` parameters\n\nYou can't use the `in`, `ref`, and `out` keywords for the following kinds of methods:  \n  \n- Async methods, which you define by using the [async](async.md) modifier.  \n- Iterator methods, which include a [yield return](yield.md) or `yield break` statement.  \n\n## C# Language Specification  \n [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  \n  \n## See also\n\n- [C# Reference](../index.md)\n- [C# Programming Guide](../../programming-guide/index.md)\n- [C# Keywords](index.md)\n- [Method Parameters](method-parameters.md)\n- [Write safe efficient code](../../write-safe-efficient-code.md)\n","nodes":[{"pos":[4,162],"embed":true,"restype":"x-metadata","content":"title: \"in parameter modifier - C# Reference\"\nms.custom: seodec18\nms.date: 03/26/2019\nhelpviewer_keywords: \n  - \"parameters [C#], in\"\n  - \"in parameters [C#]\"","nodes":[{"content":"in parameter modifier - C# Reference","nodes":[{"pos":[0,36],"content":"in parameter modifier - C# Reference","nodes":[{"content":"in parameter modifier - C# Reference","pos":[0,36]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[170,206],"content":"in parameter modifier (C# Reference)","linkify":"in parameter modifier (C# Reference)","nodes":[{"content":"in parameter modifier (C# Reference)","pos":[0,36]}]},{"content":"The <ph id=\"ph1\">`in`</ph> keyword causes arguments to be passed by reference.","pos":[208,268],"source":"The `in` keyword causes arguments to be passed by reference."},{"content":"It makes the formal parameter an alias for the argument, which must be a variable.","pos":[269,351]},{"content":"In other words, any operation on the parameter is made on the argument.","pos":[352,423]},{"content":"It is like the <bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](ref.md)</ept> or <bpt id=\"p2\">[</bpt>out<ept id=\"p2\">](out-parameter-modifier.md)</ept> keywords, except that <ph id=\"ph1\">`in`</ph> arguments cannot be modified by the called method.","pos":[424,566],"source":" It is like the [ref](ref.md) or [out](out-parameter-modifier.md) keywords, except that `in` arguments cannot be modified by the called method."},{"content":"Whereas <ph id=\"ph1\">`ref`</ph> arguments may be modified, <ph id=\"ph2\">`out`</ph> arguments must be modified by the called method, and those modifications are observable in the calling context.","pos":[567,725],"source":" Whereas `ref` arguments may be modified, `out` arguments must be modified by the called method, and those modifications are observable in the calling context."},{"content":"The preceding example demonstrates that the <ph id=\"ph1\">`in`</ph> modifier is usually unnecessary at the call site.","pos":[882,980],"source":"The preceding example demonstrates that the `in` modifier is usually unnecessary at the call site."},{"content":"It is only required in the method declaration.","pos":[981,1027]},{"pos":[1031,1367],"content":"[!NOTE] \nThe `in` keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as part of a `foreach` statement, or as part of a `join` clause in a LINQ query. For more information on the use of the `in` keyword in these contexts, see [in](in.md), which provides links to all those uses.","leadings":["","> "],"nodes":[{"content":"The `in` keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as part of a `foreach` statement, or as part of a `join` clause in a LINQ query. For more information on the use of the `in` keyword in these contexts, see [in](in.md), which provides links to all those uses.","pos":[9,334],"nodes":[{"content":"The <ph id=\"ph1\">`in`</ph> keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as part of a <ph id=\"ph2\">`foreach`</ph> statement, or as part of a <ph id=\"ph3\">`join`</ph> clause in a LINQ query.","pos":[0,197],"source":"The `in` keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as part of a `foreach` statement, or as part of a `join` clause in a LINQ query."},{"content":"For more information on the use of the <ph id=\"ph1\">`in`</ph> keyword in these contexts, see <bpt id=\"p1\">[</bpt>in<ept id=\"p1\">](in.md)</ept>, which provides links to all those uses.","pos":[198,325],"source":" For more information on the use of the `in` keyword in these contexts, see [in](in.md), which provides links to all those uses."}]}]},{"content":"Variables passed as <ph id=\"ph1\">`in`</ph> arguments must be initialized before being passed in a method call.","pos":[1371,1463],"source":"Variables passed as `in` arguments must be initialized before being passed in a method call."},{"content":"However, the called method may not assign a value or modify the argument.","pos":[1464,1537]},{"content":"The <ph id=\"ph1\">`in`</ph> parameter modifier is available in C# 7.2 and later.","pos":[1541,1602],"source":"The `in` parameter modifier is available in C# 7.2 and later."},{"content":"Previous versions generate compiler error <ph id=\"ph1\">`CS8107`</ph> (\"Feature 'readonly references' is not available in C# 7.0.","pos":[1603,1713],"source":" Previous versions generate compiler error `CS8107` (\"Feature 'readonly references' is not available in C# 7.0."},{"content":"Please use language version 7.2 or greater.\") To configure the compiler language version, see <bpt id=\"p1\">[</bpt>Select the C# language version<ept id=\"p1\">](../configure-language-version.md)</ept>.","pos":[1714,1875],"source":" Please use language version 7.2 or greater.\") To configure the compiler language version, see [Select the C# language version](../configure-language-version.md)."},{"content":"The <ph id=\"ph1\">`in`</ph>, <ph id=\"ph2\">`ref`</ph>, and <ph id=\"ph3\">`out`</ph> keywords are not considered part of the method signature for the purpose of overload resolution.","pos":[1877,2000],"source":"The `in`, `ref`, and `out` keywords are not considered part of the method signature for the purpose of overload resolution."},{"content":"Therefore, methods cannot be overloaded if the only difference is that one method takes a <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`in`</ph> argument and the other takes an <ph id=\"ph3\">`out`</ph> argument.","pos":[2001,2152],"source":" Therefore, methods cannot be overloaded if the only difference is that one method takes a `ref` or `in` argument and the other takes an `out` argument."},{"content":"The following code, for example, will not compile:","pos":[2153,2203]},{"pos":[2448,2501],"content":"Overloading based on the presence of <ph id=\"ph1\">`in`</ph> is allowed:","source":"Overloading based on the presence of `in` is allowed:"},{"pos":[2630,2655],"content":"Overload resolution rules","linkify":"Overload resolution rules","nodes":[{"content":"Overload resolution rules","pos":[0,25]}]},{"content":"You can understand the overload resolution rules for methods with by value vs. <ph id=\"ph1\">`in`</ph> arguments by understanding the motivation for <ph id=\"ph2\">`in`</ph> arguments.","pos":[2657,2802],"source":"You can understand the overload resolution rules for methods with by value vs. `in` arguments by understanding the motivation for `in` arguments."},{"content":"Defining methods using <ph id=\"ph1\">`in`</ph> parameters is a potential performance optimization.","pos":[2803,2882],"source":" Defining methods using `in` parameters is a potential performance optimization."},{"content":"Some <ph id=\"ph1\">`struct`</ph> type arguments may be large in size, and when methods are called in tight loops or critical code paths, the cost of copying those structures is critical.","pos":[2883,3050],"source":" Some `struct` type arguments may be large in size, and when methods are called in tight loops or critical code paths, the cost of copying those structures is critical."},{"content":"Methods declare <ph id=\"ph1\">`in`</ph> parameters to specify that arguments may be passed by reference safely because the called method does not modify the state of that argument.","pos":[3051,3212],"source":" Methods declare `in` parameters to specify that arguments may be passed by reference safely because the called method does not modify the state of that argument."},{"content":"Passing those arguments by reference avoids the (potentially) expensive copy.","pos":[3213,3290]},{"content":"Specifying <ph id=\"ph1\">`in`</ph> for arguments at the call site is typically optional.","pos":[3293,3362],"source":"Specifying `in` for arguments at the call site is typically optional."},{"content":"There is no semantic difference between passing arguments by value and passing them by reference using the <ph id=\"ph1\">`in`</ph> modifier.","pos":[3363,3484],"source":" There is no semantic difference between passing arguments by value and passing them by reference using the `in` modifier."},{"content":"The <ph id=\"ph1\">`in`</ph> modifier at the call site is optional because you don't need to indicate that the argument's value might be changed.","pos":[3485,3610],"source":" The `in` modifier at the call site is optional because you don't need to indicate that the argument's value might be changed."},{"content":"You explicitly add the <ph id=\"ph1\">`in`</ph> modifier at the call site to ensure the argument is passed by reference, not by value.","pos":[3611,3725],"source":" You explicitly add the `in` modifier at the call site to ensure the argument is passed by reference, not by value."},{"content":"Explicitly using <ph id=\"ph1\">`in`</ph> has the following two effects:","pos":[3726,3778],"source":" Explicitly using `in` has the following two effects:"},{"content":"First, specifying <ph id=\"ph1\">`in`</ph> at the call site forces the compiler to select a method defined with a matching <ph id=\"ph2\">`in`</ph> parameter.","pos":[3780,3898],"source":"First, specifying `in` at the call site forces the compiler to select a method defined with a matching `in` parameter."},{"content":"Otherwise, when two methods differ only in the presence of <ph id=\"ph1\">`in`</ph>, the by value overload is a better match.","pos":[3899,4004],"source":" Otherwise, when two methods differ only in the presence of `in`, the by value overload is a better match."},{"content":"Second, specifying <ph id=\"ph1\">`in`</ph> declares your intent to pass an argument by reference.","pos":[4006,4084],"source":"Second, specifying `in` declares your intent to pass an argument by reference."},{"content":"The argument used with <ph id=\"ph1\">`in`</ph> must represent a location that can be directly referred to.","pos":[4085,4172],"source":" The argument used with `in` must represent a location that can be directly referred to."},{"content":"The same general rules for <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> arguments apply: You cannot use constants, ordinary properties, or other expressions that produce values.","pos":[4173,4321],"source":" The same general rules for `out` and `ref` arguments apply: You cannot use constants, ordinary properties, or other expressions that produce values."},{"content":"Otherwise, omitting <ph id=\"ph1\">`in`</ph> at the call site informs the compiler that you will allow it to create a temporary variable to pass by read-only reference to the method.","pos":[4322,4484],"source":" Otherwise, omitting `in` at the call site informs the compiler that you will allow it to create a temporary variable to pass by read-only reference to the method."},{"content":"The compiler creates a temporary variable to overcome several restrictions with <ph id=\"ph1\">`in`</ph> arguments:","pos":[4485,4580],"source":" The compiler creates a temporary variable to overcome several restrictions with `in` arguments:"},{"pos":[4584,4654],"content":"A temporary variable allows compile-time constants as <ph id=\"ph1\">`in`</ph> parameters.","source":"A temporary variable allows compile-time constants as `in` parameters."},{"pos":[4657,4738],"content":"A temporary variable allows properties, or other expressions for <ph id=\"ph1\">`in`</ph> parameters.","source":"A temporary variable allows properties, or other expressions for `in` parameters."},{"content":"A temporary variable allows arguments where there is an implicit conversion from the argument type to the parameter type.","pos":[4741,4862]},{"content":"In all the preceding instances, the compiler creates a temporary variable that stores the value of the constant, property, or other expression.","pos":[4864,5007]},{"content":"The following code illustrates these rules:","pos":[5009,5052]},{"content":"Now, suppose another method using by value arguments was available.","pos":[5507,5574]},{"content":"The results change as shown in the following code:","pos":[5575,5625]},{"content":"The only method call where the argument is passed by reference is the final one.","pos":[6138,6218]},{"pos":[6222,6438],"content":"[!NOTE]\nThe preceding code uses `int` as the argument type for simplicity. Because `int` is no larger than a reference in most modern machines, there is no benefit to passing a single `int` as a readonly reference.","leadings":["","> "],"nodes":[{"content":"The preceding code uses `int` as the argument type for simplicity. Because `int` is no larger than a reference in most modern machines, there is no benefit to passing a single `int` as a readonly reference.","pos":[8,214],"nodes":[{"content":"The preceding code uses <ph id=\"ph1\">`int`</ph> as the argument type for simplicity.","pos":[0,66],"source":"The preceding code uses `int` as the argument type for simplicity."},{"content":"Because <ph id=\"ph1\">`int`</ph> is no larger than a reference in most modern machines, there is no benefit to passing a single <ph id=\"ph2\">`int`</ph> as a readonly reference.","pos":[67,206],"source":" Because `int` is no larger than a reference in most modern machines, there is no benefit to passing a single `int` as a readonly reference."}]}]},{"pos":[6444,6474],"content":"Limitations on <ph id=\"ph1\">`in`</ph> parameters","linkify":"Limitations on `in` parameters","source":"Limitations on `in` parameters"},{"pos":[6476,6561],"content":"You can't use the <ph id=\"ph1\">`in`</ph>, <ph id=\"ph2\">`ref`</ph>, and <ph id=\"ph3\">`out`</ph> keywords for the following kinds of methods:","source":"You can't use the `in`, `ref`, and `out` keywords for the following kinds of methods:"},{"pos":[6569,6641],"content":"Async methods, which you define by using the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](async.md)</ept> modifier.","source":"Async methods, which you define by using the [async](async.md) modifier."},{"pos":[6646,6732],"content":"Iterator methods, which include a <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](yield.md)</ept> or <ph id=\"ph1\">`yield break`</ph> statement.","source":"Iterator methods, which include a [yield return](yield.md) or `yield break` statement."},{"pos":[6739,6764],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[6836,6844],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6848,6875],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../index.md)</ept>","source":"[C# Reference](../index.md)"},{"pos":[6878,6934],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../programming-guide/index.md)"},{"pos":[6937,6960],"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](index.md)</ept>","source":"[C# Keywords](index.md)"},{"pos":[6963,7004],"content":"<bpt id=\"p1\">[</bpt>Method Parameters<ept id=\"p1\">](method-parameters.md)</ept>","source":"[Method Parameters](method-parameters.md)"},{"pos":[7007,7070],"content":"<bpt id=\"p1\">[</bpt>Write safe efficient code<ept id=\"p1\">](../../write-safe-efficient-code.md)</ept>","source":"[Write safe efficient code](../../write-safe-efficient-code.md)"}]}