{"content":"---\ntitle: \"Consuming the Task-based Asynchronous Pattern\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords:\n  - \".NET Framework, and TAP\"\n  - \"asynchronous design patterns, .NET Framework\"\n  - \"TAP, .NET Framework support for\"\n  - \"Task-based Asynchronous Pattern, .NET Framework support for\"\n  - \".NET Framework, asynchronous design patterns\"\nms.assetid: 033cf871-ae24-433d-8939-7a3793e547bf\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Consuming the Task-based Asynchronous Pattern\n\nWhen you use the Task-based Asynchronous Pattern (TAP) to work with asynchronous operations, you can use callbacks to achieve waiting without blocking.  For tasks, this is achieved through methods such as <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>. Language-based asynchronous support hides callbacks by allowing asynchronous operations to be awaited within normal control flow, and compiler-generated code provides this same API-level support.\n\n## Suspending Execution with Await\n Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], you can use the [await](~/docs/csharp/language-reference/keywords/await.md) keyword in C# and the [Await Operator](~/docs/visual-basic/language-reference/operators/await-operator.md) in Visual Basic to asynchronously await <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects. When you're awaiting a <xref:System.Threading.Tasks.Task>, the `await` expression is of type `void`. When you're awaiting a <xref:System.Threading.Tasks.Task%601>, the `await` expression is of type `TResult`. An `await` expression must occur inside the body of an asynchronous method. For more information about C# and Visual Basic language support in the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], see the C# and Visual Basic language specifications.\n\n Under the covers, the await functionality installs a callback on the task by using a continuation.  This callback resumes the asynchronous method at the point of suspension. When the asynchronous method is resumed, if the awaited operation completed successfully and was a <xref:System.Threading.Tasks.Task%601>, its `TResult` is returned.  If the <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> that was awaited ended in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, an <xref:System.OperationCanceledException> exception is thrown.  If the <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> that was awaited ended in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, the exception that caused it to fault is thrown. A `Task` can fault as a result of multiple exceptions, but only one of these exceptions is propagated. However, the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property returns an <xref:System.AggregateException> exception that contains all the errors.\n\n If a synchronization context (<xref:System.Threading.SynchronizationContext> object) is associated with the thread that was executing the asynchronous method at the time of suspension (for example, if the <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType> property is not `null`), the asynchronous method resumes on that same synchronization context by using the context’s <xref:System.Threading.SynchronizationContext.Post%2A> method. Otherwise, it relies on the task scheduler (<xref:System.Threading.Tasks.TaskScheduler> object) that was current at the time of suspension. Typically, this is the default task scheduler (<xref:System.Threading.Tasks.TaskScheduler.Default%2A?displayProperty=nameWithType>), which targets the thread pool. This task scheduler determines whether the awaited asynchronous operation should resume where it completed or whether the resumption should be scheduled. The default scheduler typically allows the continuation to run on the thread that the awaited operation completed.\n\n When an asynchronous method is called, it synchronously executes the body of the function up until the first await expression on an awaitable instance that has not yet completed, at which point the invocation returns to the caller. If the asynchronous method does not return `void`, a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object is returned to represent the ongoing computation. In a non-void asynchronous method, if a return statement is encountered or the end of the method body is reached, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> final state. If an unhandled exception causes control to leave the body of the asynchronous method, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state. If that exception is an <xref:System.OperationCanceledException>, the task instead ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state. In this manner, the result or exception is eventually published.\n\n There are several important variations of this behavior.  For performance reasons, if a task has already completed by the time the task is awaited, control is not yielded, and the function continues to execute.  Additionally, returning to the original context isn't always the desired behavior and can be changed; this is described in more detail in the next section.\n\n### Configuring Suspension and Resumption with Yield and ConfigureAwait\n Several methods provide more control over an asynchronous method’s execution. For example, you can use the <xref:System.Threading.Tasks.Task.Yield%2A?displayProperty=nameWithType> method to introduce a yield point into the asynchronous method:\n\n```csharp\npublic class Task : …\n{\n    public static YieldAwaitable Yield();\n    …\n}\n```\n\n This is equivalent to asynchronously posting or scheduling back to the current context.\n\n```csharp\nTask.Run(async delegate\n{\n    for(int i=0; i<1000000; i++)\n    {\n        await Task.Yield(); // fork the continuation into a separate work item\n        ...\n    }\n});\n```\n\n You can also use the <xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType> method for better control over suspension and resumption in an asynchronous method.  As mentioned previously, by default, the current context is captured at the time an asynchronous  method is suspended, and that captured context is used to invoke the asynchronous  method’s continuation upon resumption.  In many cases, this is the exact behavior you want.  In other cases, you may not care about the continuation context, and you can achieve better performance by avoiding such posts back to the original context.  To enable this, use the <xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType> method to inform the await operation not to capture and resume on the context, but to continue execution wherever the asynchronous operation that was being awaited completed:\n\n```csharp\nawait someTask.ConfigureAwait(continueOnCapturedContext:false);\n```\n\n## Canceling an Asynchronous Operation\n Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], TAP methods that support cancellation provide at least one overload that accepts a cancellation token (<xref:System.Threading.CancellationToken> object).\n\n A cancellation token is created through a cancellation token source (<xref:System.Threading.CancellationTokenSource> object).  The source’s <xref:System.Threading.CancellationTokenSource.Token%2A> property returns the cancellation token that will be signaled when the source’s <xref:System.Threading.CancellationTokenSource.Cancel%2A> method is called.  For example, if you want to download a single webpage and you want to be able to cancel the operation, you create a <xref:System.Threading.CancellationTokenSource> object, pass its token to the TAP method, and then call the source’s <xref:System.Threading.CancellationTokenSource.Cancel%2A> method when you're ready to cancel the operation:\n\n```csharp\nvar cts = new CancellationTokenSource();\nstring result = await DownloadStringAsync(url, cts.Token);\n… // at some point later, potentially on another thread\ncts.Cancel();\n```\n\n To cancel multiple asynchronous invocations, you can pass the same token to all invocations:\n\n```csharp\nvar cts = new CancellationTokenSource();\n    IList<string> results = await Task.WhenAll(from url in urls select DownloadStringAsync(url, cts.Token));\n    // at some point later, potentially on another thread\n    …\n    cts.Cancel();\n```\n\n Or, you can pass the same token to a selective subset of operations:\n\n```csharp\nvar cts = new CancellationTokenSource();\n    byte [] data = await DownloadDataAsync(url, cts.Token);\n    await SaveToDiskAsync(outputPath, data, CancellationToken.None);\n    … // at some point later, potentially on another thread\n    cts.Cancel();\n```\n\n Cancellation requests may be initiated from any thread.\n\n You can pass the <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> value to any method that accepts a cancellation token to indicate that cancellation will never be requested.  This causes the <xref:System.Threading.CancellationToken.CanBeCanceled%2A?displayProperty=nameWithType> property to return `false`, and the called method can optimize accordingly.  For testing purposes, you can also pass in a pre-canceled cancellation token that is instantiated by using the constructor that accepts a Boolean value to indicate whether the token should start in an already-canceled or not-cancelable state.\n\n This approach to cancellation has several advantages:\n\n-   You can pass the same cancellation token to any number of asynchronous and synchronous operations.\n\n-   The same cancellation request may be proliferated to any number of listeners.\n\n-   The developer of the asynchronous API is in complete control of whether cancellation may be requested and when it may take effect.\n\n-   The code that consumes the API may selectively determine the asynchronous invocations that cancellation requests will be propagated to.\n\n## Monitoring Progress\n Some asynchronous methods expose progress through a progress interface passed into the asynchronous method.  For example, consider a function which asynchronously downloads a string of text, and along the way raises progress updates that include the percentage of the download that has completed thus far.  Such a method could be consumed in a Windows Presentation Foundation (WPF) application as follows:\n\n```csharp\nprivate async void btnDownload_Click(object sender, RoutedEventArgs e)\n{\n    btnDownload.IsEnabled = false;\n    try\n    {\n        txtResult.Text = await DownloadStringAsync(txtUrl.Text,\n            new Progress<int>(p => pbDownloadProgress.Value = p));\n    }\n    finally { btnDownload.IsEnabled = true; }\n}\n```\n\n<a name=\"combinators\"></a>\n## Using the Built-in Task-based Combinators\n The <xref:System.Threading.Tasks> namespace includes several methods for composing and working with tasks.\n\n### Task.Run\n The <xref:System.Threading.Tasks.Task> class includes several <xref:System.Threading.Tasks.Task.Run%2A> methods that let you easily offload work as a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> to the thread pool, for example:\n\n```csharp\npublic async void button1_Click(object sender, EventArgs e)\n{\n    textBox1.Text = await Task.Run(() =>\n    {\n        // … do compute-bound work here\n        return answer;\n    });\n}\n```\n\n Some of these <xref:System.Threading.Tasks.Task.Run%2A> methods, such as the <xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> overload, exist as shorthand for the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.  Other overloads, such as <xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType>, enable you to use await within the offloaded work, for example:\n\n```csharp\npublic async void button1_Click(object sender, EventArgs e)\n{\n    pictureBox1.Image = await Task.Run(async() =>\n    {\n        using(Bitmap bmp1 = await DownloadFirstImageAsync())\n        using(Bitmap bmp2 = await DownloadSecondImageAsync())\n        return Mashup(bmp1, bmp2);\n    });\n}\n```\n\n Such overloads are logically equivalent to using the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method in conjunction with the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method in the Task Parallel Library.\n\n### Task.FromResult\n Use the <xref:System.Threading.Tasks.Task.FromResult%2A> method in scenarios where data may already be available and just needs to be returned from a task-returning method lifted into a <xref:System.Threading.Tasks.Task%601>:\n\n```csharp\npublic Task<int> GetValueAsync(string key)\n{\n    int cachedValue;\n    return TryGetCachedValue(out cachedValue) ?\n        Task.FromResult(cachedValue) :\n        GetValueAsyncInternal();\n}\n\nprivate async Task<int> GetValueAsyncInternal(string key)\n{\n    …\n}\n```\n\n### Task.WhenAll\n Use the <xref:System.Threading.Tasks.Task.WhenAll%2A> method to asynchronously wait on multiple asynchronous operations that are represented as tasks.  The method has multiple overloads that support a set of non-generic tasks or a non-uniform set of generic tasks (for example, asynchronously waiting for multiple void-returning operations, or asynchronously waiting for multiple value-returning methods where each value may have a different type) and to support a uniform set of generic tasks (such as asynchronously waiting for multiple `TResult`-returning methods).\n\n Let's say you want to send email messages to several customers. You can overlap sending the messages so you're not waiting for one message to complete before sending the next. You can also find out when the send operations have completed and whether any errors have occurred:\n\n```csharp\nIEnumerable<Task> asyncOps = from addr in addrs select SendMailAsync(addr);\nawait Task.WhenAll(asyncOps);\n```\n\n This code doesn't explicitly handle exceptions that may occur, but lets exceptions propagate out of the `await` on the resulting task from <xref:System.Threading.Tasks.Task.WhenAll%2A>.  To handle the exceptions, you can use code such as the following:\n\n```csharp\nIEnumerable<Task> asyncOps = from addr in addrs select SendMailAsync(addr);\ntry\n{\n    await Task.WhenAll(asyncOps);\n}\ncatch(Exception exc)\n{\n    ...\n}\n```\n\n In this case, if any asynchronous operation fails, all the exceptions will be consolidated in an <xref:System.AggregateException> exception, which is stored in the <xref:System.Threading.Tasks.Task> that is returned from the <xref:System.Threading.Tasks.Task.WhenAll%2A> method.  However, only one of those exceptions is propagated by the `await` keyword.  If you want to examine all the exceptions, you can rewrite the previous code as follows:\n\n```csharp\nTask [] asyncOps = (from addr in addrs select SendMailAsync(addr)).ToArray();\ntry\n{\n    await Task.WhenAll(asyncOps);\n}\ncatch(Exception exc)\n{\n    foreach(Task faulted in asyncOps.Where(t => t.IsFaulted))\n    {\n        … // work with faulted and faulted.Exception\n    }\n}\n```\n\n Let's consider an example of downloading multiple files from the web asynchronously.  In this case, all the asynchronous operations have homogeneous result types, and it's easy to access the results:\n\n```csharp\nstring [] pages = await Task.WhenAll(\n    from url in urls select DownloadStringAsync(url));\n```\n\n You can use the same exception-handling techniques we discussed in the previous void-returning scenario:\n\n```csharp\nTask [] asyncOps =\n    (from url in urls select DownloadStringAsync(url)).ToArray();\ntry\n{\n    string [] pages = await Task.WhenAll(asyncOps);\n    ...\n}\ncatch(Exception exc)\n{\n    foreach(Task<string> faulted in asyncOps.Where(t => t.IsFaulted))\n    {\n        … // work with faulted and faulted.Exception\n    }\n}\n```\n\n### Task.WhenAny\n You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to asynchronously wait for just one of multiple asynchronous operations represented as tasks to complete.  This method serves four primary use cases:\n\n-   Redundancy:  Performing an operation multiple times and selecting the one that completes first (for example, contacting multiple stock quote web services that will produce a single result and selecting the one that completes the fastest).\n\n-   Interleaving:  Launching multiple operations and waiting for all of them to complete, but processing them as they complete.\n\n-   Throttling:  Allowing additional operations to begin as others complete.  This is an extension of the interleaving scenario.\n\n-   Early bailout:  For example, an operation represented by task t1 can be grouped in a <xref:System.Threading.Tasks.Task.WhenAny%2A> task with another task t2, and you can wait on the <xref:System.Threading.Tasks.Task.WhenAny%2A> task. Task t2 could represent a time-out, or cancellation, or some other signal that causes the <xref:System.Threading.Tasks.Task.WhenAny%2A> task to complete before t1 completes.\n\n#### Redundancy\n Consider a case where you want to make a decision about whether to buy a stock.  There are several stock recommendation web services that you trust, but depending on daily load, each service can end up being slow at different times.  You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to receive a notification when any operation completes:\n\n```csharp\nvar recommendations = new List<Task<bool>>()\n{\n    GetBuyRecommendation1Async(symbol),\n    GetBuyRecommendation2Async(symbol),\n    GetBuyRecommendation3Async(symbol)\n};\nTask<bool> recommendation = await Task.WhenAny(recommendations);\nif (await recommendation) BuyStock(symbol);\n```\n\n Unlike <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns the unwrapped results of all tasks that completed successfully, <xref:System.Threading.Tasks.Task.WhenAny%2A> returns the task that completed. If a task fails, it’s important to know that it failed, and if a task succeeds, it’s important to know which task the return value is associated with.  Therefore, you need to access the result of the returned task, or further await it, as  this example shows.\n\n As with <xref:System.Threading.Tasks.Task.WhenAll%2A>, you have to be able to accommodate exceptions.  Because you receive the completed task back, you can await the returned task to have errors propagated, and `try/catch` them appropriately; for example:\n\n```csharp\nTask<bool> [] recommendations = …;\nwhile(recommendations.Count > 0)\n{\n    Task<bool> recommendation = await Task.WhenAny(recommendations);\n    try\n    {\n        if (await recommendation) BuyStock(symbol);\n        break;\n    }\n    catch(WebException exc)\n    {\n        recommendations.Remove(recommendation);\n    }\n}\n```\n\n Additionally, even if a first task completes successfully, subsequent tasks may fail.  At this point, you have several options for dealing with exceptions:  You can wait until all the launched tasks have completed, in which case you can use the <xref:System.Threading.Tasks.Task.WhenAll%2A> method, or you can decide that all exceptions are important and must be logged.  For this, you can use continuations to receive a notification when tasks have completed asynchronously:\n\n```csharp\nforeach(Task recommendation in recommendations)\n{\n    var ignored = recommendation.ContinueWith(\n        t => { if (t.IsFaulted) Log(t.Exception); });\n}\n```\n\n or:\n\n```csharp\nforeach(Task recommendation in recommendations)\n{\n    var ignored = recommendation.ContinueWith(\n        t => Log(t.Exception), TaskContinuationOptions.OnlyOnFaulted);\n}\n```\n\n or even:\n\n```csharp\nprivate static async void LogCompletionIfFailed(IEnumerable<Task> tasks)\n{\n    foreach(var task in tasks)\n    {\n        try { await task; }\n        catch(Exception exc) { Log(exc); }\n    }\n}\n…\nLogCompletionIfFailed(recommendations);\n```\n\n Finally, you may want to cancel all the remaining operations:\n\n```csharp\nvar cts = new CancellationTokenSource();\nvar recommendations = new List<Task<bool>>()\n{\n    GetBuyRecommendation1Async(symbol, cts.Token),\n    GetBuyRecommendation2Async(symbol, cts.Token),\n    GetBuyRecommendation3Async(symbol, cts.Token)\n};\n\nTask<bool> recommendation = await Task.WhenAny(recommendations);\ncts.Cancel();\nif (await recommendation) BuyStock(symbol);\n```\n\n#### Interleaving\n Consider a case where you're downloading images from the web and processing each image (for example, adding the image to a UI control).  You have to do the processing sequentially on the UI thread, but you want to download the images as concurrently as possible. Also, you don’t want to hold up adding the images to the UI until they’re all downloaded—you want to add them as they complete:\n\n```csharp\nList<Task<Bitmap>> imageTasks =\n    (from imageUrl in urls select GetBitmapAsync(imageUrl)).ToList();\nwhile(imageTasks.Count > 0)\n{\n    try\n    {\n        Task<Bitmap> imageTask = await Task.WhenAny(imageTasks);\n        imageTasks.Remove(imageTask);\n\n        Bitmap image = await imageTask;\n        panel.AddImage(image);\n    }\n    catch{}\n}\n```\n\n You can also apply interleaving to a scenario that involves computationally intensive processing on the <xref:System.Threading.ThreadPool> of the downloaded images; for example:\n\n```csharp\nList<Task<Bitmap>> imageTasks =\n    (from imageUrl in urls select GetBitmapAsync(imageUrl)\n         .ContinueWith(t => ConvertImage(t.Result)).ToList();\nwhile(imageTasks.Count > 0)\n{\n    try\n    {\n        Task<Bitmap> imageTask = await Task.WhenAny(imageTasks);\n        imageTasks.Remove(imageTask);\n\n        Bitmap image = await imageTask;\n        panel.AddImage(image);\n    }\n    catch{}\n}\n```\n\n#### Throttling\n Consider the interleaving example, except that the user is downloading so many images that the downloads have to be throttled; for example, you want only a specific number of downloads to happen concurrently. To achieve this, you can start a subset of the asynchronous operations.  As operations complete, you can start additional operations to take their place:\n\n```csharp\nconst int CONCURRENCY_LEVEL = 15;\nUri [] urls = …;\nint nextIndex = 0;\nvar imageTasks = new List<Task<Bitmap>>();\nwhile(nextIndex < CONCURRENCY_LEVEL && nextIndex < urls.Length)\n{\n    imageTasks.Add(GetBitmapAsync(urls[nextIndex]));\n    nextIndex++;\n}\n\nwhile(imageTasks.Count > 0)\n{\n    try\n    {\n        Task<Bitmap> imageTask = await Task.WhenAny(imageTasks);\n        imageTasks.Remove(imageTask);\n\n        Bitmap image = await imageTask;\n        panel.AddImage(image);\n    }\n    catch(Exception exc) { Log(exc); }\n\n    if (nextIndex < urls.Length)\n    {\n        imageTasks.Add(GetBitmapAsync(urls[nextIndex]));\n        nextIndex++;\n    }\n}\n```\n\n#### Early Bailout\n Consider that you're waiting asynchronously for an operation to complete while simultaneously responding to a user’s cancellation request (for example, the user clicked a cancel button). The following code illustrates this scenario:\n\n```csharp\nprivate CancellationTokenSource m_cts;\n\npublic void btnCancel_Click(object sender, EventArgs e)\n{\n    if (m_cts != null) m_cts.Cancel();\n}\n\npublic async void btnRun_Click(object sender, EventArgs e)\n{\n    m_cts = new CancellationTokenSource();\n    btnRun.Enabled = false;\n    try\n    {\n        Task<Bitmap> imageDownload = GetBitmapAsync(txtUrl.Text);\n        await UntilCompletionOrCancellation(imageDownload, m_cts.Token);\n        if (imageDownload.IsCompleted)\n        {\n            Bitmap image = await imageDownload;\n            panel.AddImage(image);\n        }\n        else imageDownload.ContinueWith(t => Log(t));\n    }\n    finally { btnRun.Enabled = true; }\n}\n\nprivate static async Task UntilCompletionOrCancellation(\n    Task asyncOp, CancellationToken ct)\n{\n    var tcs = new TaskCompletionSource<bool>();\n    using(ct.Register(() => tcs.TrySetResult(true)))\n        await Task.WhenAny(asyncOp, tcs.Task);\n    return asyncOp;\n}\n```\n\n This implementation re-enables the user interface as soon as you decide to bail out, but doesn't cancel the underlying asynchronous operations.  Another alternative would be to cancel the pending operations when you decide to bail out, but not reestablish the user interface until the operations actually complete, potentially due to ending early due to the cancellation request:\n\n```csharp\nprivate CancellationTokenSource m_cts;\n\npublic async void btnRun_Click(object sender, EventArgs e)\n{\n    m_cts = new CancellationTokenSource();\n\n    btnRun.Enabled = false;\n    try\n    {\n        Task<Bitmap> imageDownload = GetBitmapAsync(txtUrl.Text, m_cts.Token);\n        await UntilCompletionOrCancellation(imageDownload, m_cts.Token);\n        Bitmap image = await imageDownload;\n        panel.AddImage(image);\n    }\n    catch(OperationCanceledException) {}\n    finally { btnRun.Enabled = true; }\n}\n```\n\n Another example of early bailout involves using the <xref:System.Threading.Tasks.Task.WhenAny%2A> method in conjunction with the <xref:System.Threading.Tasks.Task.Delay%2A> method, as discussed in the next section.\n\n### Task.Delay\n You can use the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method to introduce pauses into an asynchronous method’s execution.  This is useful for many kinds of functionality, including building polling loops and delaying the handling of user input for a predetermined period of time.  The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method can also be useful in combination with <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> for implementing time-outs on awaits.\n\n If a task that’s part of a larger asynchronous operation (for example, an ASP.NET web service) takes too long to complete, the overall operation could suffer, especially if it fails to ever complete.  For this reason, it’s important to be able to time out when waiting on an asynchronous operation.  The synchronous <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods accept time-out values, but the corresponding <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType>/<xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> and the previously mentioned <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>/<xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> methods do not.  Instead, you can use <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> in combination to implement a time-out.\n\n For example, in your UI application, let's say that you want to download an image and disable the UI while the image is downloading. However, if the download takes too long, you want to re-enable the UI and discard the download:\n\n```csharp\npublic async void btnDownload_Click(object sender, EventArgs e)\n{\n    btnDownload.Enabled = false;\n    try\n    {\n        Task<Bitmap> download = GetBitmapAsync(url);\n        if (download == await Task.WhenAny(download, Task.Delay(3000)))\n        {\n            Bitmap bmp = await download;\n            pictureBox.Image = bmp;\n            status.Text = \"Downloaded\";\n        }\n        else\n        {\n            pictureBox.Image = null;\n            status.Text = \"Timed out\";\n            var ignored = download.ContinueWith(\n                t => Trace(\"Task finally completed\"));\n        }\n    }\n    finally { btnDownload.Enabled = true; }\n}\n```\n\n The same applies to multiple downloads, because <xref:System.Threading.Tasks.Task.WhenAll%2A> returns a task:\n\n```csharp\npublic async void btnDownload_Click(object sender, RoutedEventArgs e)\n{\n    btnDownload.Enabled = false;\n    try\n    {\n        Task<Bitmap[]> downloads =\n            Task.WhenAll(from url in urls select GetBitmapAsync(url));\n        if (downloads == await Task.WhenAny(downloads, Task.Delay(3000)))\n        {\n            foreach(var bmp in downloads) panel.AddImage(bmp);\n            status.Text = \"Downloaded\";\n        }\n        else\n        {\n            status.Text = \"Timed out\";\n            downloads.ContinueWith(t => Log(t));\n        }\n    }\n    finally { btnDownload.Enabled = true; }\n}\n```\n\n## Building Task-based Combinators\n Because a task is able to completely represent an asynchronous operation and provide synchronous and asynchronous capabilities for joining with the operation, retrieving its results, and so on, you can build useful libraries of combinators that compose tasks to build larger patterns.  As discussed in the previous section, the .NET Framework includes several built-in combinators, but you can also build your own. The following sections provide several examples of potential combinator methods and types.\n\n### RetryOnFault\n In many situations, you may want to retry an operation if a previous attempt fails.  For synchronous code, you might build a helper method such as `RetryOnFault` in the following example to accomplish this:\n\n```csharp\npublic static T RetryOnFault<T>(\n    Func<T> function, int maxTries)\n{\n    for(int i=0; i<maxTries; i++)\n    {\n        try { return function(); }\n        catch { if (i == maxTries-1) throw; }\n    }\n    return default(T);\n}\n```\n\n You can build an almost identical helper method for asynchronous operations that are implemented with TAP and thus return tasks:\n\n```csharp\npublic static async Task<T> RetryOnFault<T>(\n    Func<Task<T>> function, int maxTries)\n{\n    for(int i=0; i<maxTries; i++)\n    {\n        try { return await function().ConfigureAwait(false); }\n        catch { if (i == maxTries-1) throw; }\n    }\n    return default(T);\n}\n```\n\n You can then use this combinator to encode retries into the application’s logic; for example:\n\n```csharp\n// Download the URL, trying up to three times in case of failure\nstring pageContents = await RetryOnFault(\n    () => DownloadStringAsync(url), 3);\n```\n\n You could extend the `RetryOnFault` function further. For example, the function could accept another `Func<Task>` that will be invoked between retries to determine when to try the operation again; for example:\n\n```csharp\npublic static async Task<T> RetryOnFault<T>(\n    Func<Task<T>> function, int maxTries, Func<Task> retryWhen)\n{\n    for(int i=0; i<maxTries; i++)\n    {\n        try { return await function().ConfigureAwait(false); }\n        catch { if (i == maxTries-1) throw; }\n        await retryWhen().ConfigureAwait(false);\n    }\n    return default(T);\n}\n```\n\n You could then use the function as follows to wait for a second before retrying the operation:\n\n```csharp\n// Download the URL, trying up to three times in case of failure,\n// and delaying for a second between retries\nstring pageContents = await RetryOnFault(\n    () => DownloadStringAsync(url), 3, () => Task.Delay(1000));\n```\n\n### NeedOnlyOne\n Sometimes, you can take advantage of redundancy to improve an operation’s latency and chances for success.  Consider multiple web services that provide stock quotes, but at various times of the day, each service may provide different levels of quality and response times.  To deal with these fluctuations, you may issue requests to all the web services, and as soon as you get a response from one, cancel the remaining requests.  You can implement a helper function to make it easier to implement this common pattern of launching multiple operations, waiting for any, and then canceling the rest. The `NeedOnlyOne` function in the following example illustrates this scenario:\n\n```csharp\npublic static async Task<T> NeedOnlyOne(\n    params Func<CancellationToken,Task<T>> [] functions)\n{\n    var cts = new CancellationTokenSource();\n    var tasks = (from function in functions\n                 select function(cts.Token)).ToArray();\n    var completed = await Task.WhenAny(tasks).ConfigureAwait(false);\n    cts.Cancel();\n    foreach(var task in tasks)\n    {\n        var ignored = task.ContinueWith(\n            t => Log(t), TaskContinuationOptions.OnlyOnFaulted);\n    }\n    return completed;\n}\n```\n\n You can then use this function as follows:\n\n```csharp\ndouble currentPrice = await NeedOnlyOne(\n    ct => GetCurrentPriceFromServer1Async(\"msft\", ct),\n    ct => GetCurrentPriceFromServer2Async(\"msft\", ct),\n    ct => GetCurrentPriceFromServer3Async(\"msft\", ct));\n```\n\n### Interleaved Operations\n There is a potential performance problem with using the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to support an interleaving scenario when you're working with very large sets of tasks.  Every call to <xref:System.Threading.Tasks.Task.WhenAny%2A> results in a continuation being registered with each task. For N number of tasks, this results in O(N2) continuations created over the lifetime of the interleaving operation.  If you're working with a large set of tasks, you can use a combinator  (`Interleaved` in the following example) to address the performance issue:\n\n```csharp\nstatic IEnumerable<Task<T>> Interleaved<T>(IEnumerable<Task<T>> tasks)\n{\n    var inputTasks = tasks.ToList();\n    var sources = (from _ in Enumerable.Range(0, inputTasks.Count)\n                   select new TaskCompletionSource<T>()).ToList();\n    int nextTaskIndex = -1;\n    foreach (var inputTask in inputTasks)\n    {\n        inputTask.ContinueWith(completed =>\n        {\n            var source = sources[Interlocked.Increment(ref nextTaskIndex)];\n            if (completed.IsFaulted)\n                source.TrySetException(completed.Exception.InnerExceptions);\n            else if (completed.IsCanceled)\n                source.TrySetCanceled();\n            else\n                source.TrySetResult(completed.Result);\n        }, CancellationToken.None,\n           TaskContinuationOptions.ExecuteSynchronously,\n           TaskScheduler.Default);\n    }\n    return from source in sources\n           select source.Task;\n}\n```\n\n You can then use the combinator to process the results of tasks as they complete; for example:\n\n```csharp\nIEnumerable<Task<int>> tasks = ...;\nforeach(var task in Interleaved(tasks))\n{\n    int result = await task;\n    …\n}\n```\n\n### WhenAllOrFirstException\n In certain scatter/gather scenarios, you might want to wait for all tasks in a set, unless one of them faults, in which case you want to stop waiting as soon as the exception occurs.  You can accomplish that with a combinator method such as `WhenAllOrFirstException` in the following example:\n\n```csharp\npublic static Task<T[]> WhenAllOrFirstException<T>(IEnumerable<Task<T>> tasks)\n{\n    var inputs = tasks.ToList();\n    var ce = new CountdownEvent(inputs.Count);\n    var tcs = new TaskCompletionSource<T[]>();\n\n    Action<Task> onCompleted = (Task completed) =>\n    {\n        if (completed.IsFaulted)\n            tcs.TrySetException(completed.Exception.InnerExceptions);\n        if (ce.Signal() && !tcs.Task.IsCompleted)\n            tcs.TrySetResult(inputs.Select(t => t.Result).ToArray());\n    };\n\n    foreach (var t in inputs) t.ContinueWith(onCompleted);\n    return tcs.Task;\n}\n```\n\n## Building Task-based Data Structures\n In addition to the ability to build custom task-based combinators, having a data structure in <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> that represents both the results of an asynchronous operation and the necessary synchronization to join with it makes it a very powerful type on which to build custom data structures to be used in asynchronous scenarios.\n\n### AsyncCache\n One important aspect of a task is that it may be handed out to multiple consumers, all of whom may await it, register continuations with it, get its result or exceptions (in the case of <xref:System.Threading.Tasks.Task%601>), and so on.  This makes <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> perfectly suited to be used in an asynchronous caching infrastructure.  Here’s an example of a small but powerful asynchronous cache built on top of <xref:System.Threading.Tasks.Task%601>:\n\n```csharp\npublic class AsyncCache<TKey, TValue>\n{\n    private readonly Func<TKey, Task<TValue>> _valueFactory;\n    private readonly ConcurrentDictionary<TKey, Lazy<Task<TValue>>> _map;\n\n    public AsyncCache(Func<TKey, Task<TValue>> valueFactory)\n    {\n        if (valueFactory == null) throw new ArgumentNullException(\"loader\");\n        _valueFactory = valueFactory;\n        _map = new ConcurrentDictionary<TKey, Lazy<Task<TValue>>>();\n    }\n\n    public Task<TValue> this[TKey key]\n    {\n        get\n        {\n            if (key == null) throw new ArgumentNullException(\"key\");\n            return _map.GetOrAdd(key, toAdd =>\n                new Lazy<Task<TValue>>(() => _valueFactory(toAdd))).Value;\n        }\n    }\n}\n```\n\n The [AsyncCache\\<TKey,TValue>](https://blogs.msdn.microsoft.com/pfxteam/2010/04/23/parallelextensionsextras-tour-12-asynccache/) class accepts as a delegate to its constructor a function that takes a `TKey` and returns a <xref:System.Threading.Tasks.Task%601>.  Any previously accessed values from the cache are stored in the internal dictionary, and the `AsyncCache` ensures that only one task is generated per key, even if the cache is accessed concurrently.\n\n For example, you can build a cache for downloaded web pages:\n\n```csharp\nprivate AsyncCache<string,string> m_webPages =\n    new AsyncCache<string,string>(DownloadStringAsync);\n```\n\n You can then use this cache in asynchronous methods whenever you need the contents of a web page. The `AsyncCache` class ensures that you’re downloading as few pages as possible, and caches the results.\n\n```csharp\nprivate async void btnDownload_Click(object sender, RoutedEventArgs e)\n{\n    btnDownload.IsEnabled = false;\n    try\n    {\n        txtContents.Text = await m_webPages[\"https://www.microsoft.com\"];\n    }\n    finally { btnDownload.IsEnabled = true; }\n}\n```\n\n### AsyncProducerConsumerCollection\n You can also use tasks to build data structures for coordinating asynchronous activities.  Consider one of the classic parallel design patterns: producer/consumer.  In this pattern, producers generate data that is consumed by consumers, and the producers and consumers may run in parallel. For example, the consumer processes item 1, which was previously generated by a producer who is now producing item 2.  For the producer/consumer pattern, you invariably need some data structure to store the work created by producers so that the consumers may be notified of new data and find it when available.\n\n Here’s a simple data structure built on top of tasks that enables asynchronous methods to be used as producers and consumers:\n\n```csharp\npublic class AsyncProducerConsumerCollection<T>\n{\n    private readonly Queue<T> m_collection = new Queue<T>();\n    private readonly Queue<TaskCompletionSource<T>> m_waiting =\n        new Queue<TaskCompletionSource<T>>();\n\n    public void Add(T item)\n    {\n        TaskCompletionSource<T> tcs = null;\n        lock (m_collection)\n        {\n            if (m_waiting.Count > 0) tcs = m_waiting.Dequeue();\n            else m_collection.Enqueue(item);\n        }\n        if (tcs != null) tcs.TrySetResult(item);\n    }\n\n    public Task<T> Take()\n    {\n        lock (m_collection)\n        {\n            if (m_collection.Count > 0)\n            {\n                return Task.FromResult(m_collection.Dequeue());\n            }\n            else\n            {\n                var tcs = new TaskCompletionSource<T>();\n                m_waiting.Enqueue(tcs);\n                return tcs.Task;\n            }\n        }\n    }\n}\n```\n\n With that data structure in place, you can write code such as the following:\n\n```csharp\nprivate static AsyncProducerConsumerCollection<int> m_data = …;\n…\nprivate static async Task ConsumerAsync()\n{\n    while(true)\n    {\n        int nextItem = await m_data.Take();\n        ProcessNextItem(nextItem);\n    }\n}\n…\nprivate static void Produce(int data)\n{\n    m_data.Add(data);\n}\n```\n\nThe <xref:System.Threading.Tasks.Dataflow> namespace includes the <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> type, which you can use in a similar manner, but without having to build a custom collection type:\n\n```csharp\nprivate static BufferBlock<int> m_data = …;\n…\nprivate static async Task ConsumerAsync()\n{\n    while(true)\n    {\n        int nextItem = await m_data.ReceiveAsync();\n        ProcessNextItem(nextItem);\n    }\n}\n…\nprivate static void Produce(int data)\n{\n    m_data.Post(data);\n}\n```\n\n> [!NOTE]\n> The <xref:System.Threading.Tasks.Dataflow> namespace is available in the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] through **NuGet**. To install the assembly that contains the <xref:System.Threading.Tasks.Dataflow> namespace, open your project in Visual Studio, choose **Manage NuGet Packages** from the Project menu, and search online for the Microsoft.Tpl.Dataflow package.\n\n## See also\n\n- [Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)\n- [Implementing the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)\n- [Interop with Other Asynchronous Patterns and Types](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)\n","nodes":[{"pos":[4,457],"embed":true,"restype":"x-metadata","content":"title: \"Consuming the Task-based Asynchronous Pattern\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords:\n  - \".NET Framework, and TAP\"\n  - \"asynchronous design patterns, .NET Framework\"\n  - \"TAP, .NET Framework support for\"\n  - \"Task-based Asynchronous Pattern, .NET Framework support for\"\n  - \".NET Framework, asynchronous design patterns\"\nms.assetid: 033cf871-ae24-433d-8939-7a3793e547bf\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Consuming the Task-based Asynchronous Pattern","nodes":[{"pos":[0,45],"content":"Consuming the Task-based Asynchronous Pattern","nodes":[{"content":"Consuming the Task-based Asynchronous Pattern","pos":[0,45]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[464,509],"content":"Consuming the Task-based Asynchronous Pattern","linkify":"Consuming the Task-based Asynchronous Pattern","nodes":[{"content":"Consuming the Task-based Asynchronous Pattern","pos":[0,45]}]},{"content":"When you use the Task-based Asynchronous Pattern (TAP) to work with asynchronous operations, you can use callbacks to achieve waiting without blocking.","pos":[511,662]},{"content":"For tasks, this is achieved through methods such as <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType&gt;</ph>.","pos":[664,796],"source":"  For tasks, this is achieved through methods such as <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>."},{"content":"Language-based asynchronous support hides callbacks by allowing asynchronous operations to be awaited within normal control flow, and compiler-generated code provides this same API-level support.","pos":[797,992]},{"pos":[997,1028],"content":"Suspending Execution with Await","linkify":"Suspending Execution with Await","nodes":[{"content":"Suspending Execution with Await","pos":[0,31]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, you can use the <bpt id=\"p1\">[</bpt>await<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/await.md)</ept> keyword in C# and the <bpt id=\"p2\">[</bpt>Await Operator<ept id=\"p2\">](~/docs/visual-basic/language-reference/operators/await-operator.md)</ept> in Visual Basic to asynchronously await <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects.","pos":[1030,1411],"source":"Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], you can use the [await](~/docs/csharp/language-reference/keywords/await.md) keyword in C# and the [Await Operator](~/docs/visual-basic/language-reference/operators/await-operator.md) in Visual Basic to asynchronously await <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects."},{"content":"When you're awaiting a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, the <ph id=\"ph2\">`await`</ph> expression is of type <ph id=\"ph3\">`void`</ph>.","pos":[1412,1512],"source":" When you're awaiting a <xref:System.Threading.Tasks.Task>, the `await` expression is of type `void`."},{"content":"When you're awaiting a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, the <ph id=\"ph2\">`await`</ph> expression is of type <ph id=\"ph3\">`TResult`</ph>.","pos":[1513,1620],"source":" When you're awaiting a <xref:System.Threading.Tasks.Task%601>, the `await` expression is of type `TResult`."},{"content":"An <ph id=\"ph1\">`await`</ph> expression must occur inside the body of an asynchronous method.","pos":[1621,1696],"source":" An `await` expression must occur inside the body of an asynchronous method."},{"content":"For more information about C# and Visual Basic language support in the <ph id=\"ph1\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, see the C# and Visual Basic language specifications.","pos":[1697,1874],"source":" For more information about C# and Visual Basic language support in the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], see the C# and Visual Basic language specifications."},{"content":"Under the covers, the await functionality installs a callback on the task by using a continuation.","pos":[1877,1975]},{"content":"This callback resumes the asynchronous method at the point of suspension.","pos":[1977,2050]},{"content":"When the asynchronous method is resumed, if the awaited operation completed successfully and was a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, its <ph id=\"ph2\">`TResult`</ph> is returned.","pos":[2051,2216],"source":" When the asynchronous method is resumed, if the awaited operation completed successfully and was a <xref:System.Threading.Tasks.Task%601>, its `TResult` is returned."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> that was awaited ended in the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state, an <ph id=\"ph4\">&lt;xref:System.OperationCanceledException&gt;</ph> exception is thrown.","pos":[2218,2453],"source":"  If the <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> that was awaited ended in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, an <xref:System.OperationCanceledException> exception is thrown."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> that was awaited ended in the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, the exception that caused it to fault is thrown.","pos":[2455,2673],"source":"  If the <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> that was awaited ended in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, the exception that caused it to fault is thrown."},{"content":"A <ph id=\"ph1\">`Task`</ph> can fault as a result of multiple exceptions, but only one of these exceptions is propagated.","pos":[2674,2776],"source":" A `Task` can fault as a result of multiple exceptions, but only one of these exceptions is propagated."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType&gt;</ph> property returns an <ph id=\"ph2\">&lt;xref:System.AggregateException&gt;</ph> exception that contains all the errors.","pos":[2777,2959],"source":" However, the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property returns an <xref:System.AggregateException> exception that contains all the errors."},{"content":"If a synchronization context (<ph id=\"ph1\">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object) is associated with the thread that was executing the asynchronous method at the time of suspension (for example, if the <ph id=\"ph2\">&lt;xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType&gt;</ph> property is not <ph id=\"ph3\">`null`</ph>), the asynchronous method resumes on that same synchronization context by using the context’s <ph id=\"ph4\">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method.","pos":[2962,3433],"source":"If a synchronization context (<xref:System.Threading.SynchronizationContext> object) is associated with the thread that was executing the asynchronous method at the time of suspension (for example, if the <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType> property is not `null`), the asynchronous method resumes on that same synchronization context by using the context’s <xref:System.Threading.SynchronizationContext.Post%2A> method."},{"content":"Otherwise, it relies on the task scheduler (<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> object) that was current at the time of suspension.","pos":[3434,3573],"source":" Otherwise, it relies on the task scheduler (<xref:System.Threading.Tasks.TaskScheduler> object) that was current at the time of suspension."},{"content":"Typically, this is the default task scheduler (<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A?displayProperty=nameWithType&gt;</ph>), which targets the thread pool.","pos":[3574,3737],"source":" Typically, this is the default task scheduler (<xref:System.Threading.Tasks.TaskScheduler.Default%2A?displayProperty=nameWithType>), which targets the thread pool."},{"content":"This task scheduler determines whether the awaited asynchronous operation should resume where it completed or whether the resumption should be scheduled.","pos":[3738,3891]},{"content":"The default scheduler typically allows the continuation to run on the thread that the awaited operation completed.","pos":[3892,4006]},{"content":"When an asynchronous method is called, it synchronously executes the body of the function up until the first await expression on an awaitable instance that has not yet completed, at which point the invocation returns to the caller.","pos":[4009,4240]},{"content":"If the asynchronous method does not return <ph id=\"ph1\">`void`</ph>, a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object is returned to represent the ongoing computation.","pos":[4241,4427],"source":" If the asynchronous method does not return `void`, a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object is returned to represent the ongoing computation."},{"content":"In a non-void asynchronous method, if a return statement is encountered or the end of the method body is reached, the task is completed in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> final state.","pos":[4428,4640],"source":" In a non-void asynchronous method, if a return statement is encountered or the end of the method body is reached, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> final state."},{"content":"If an unhandled exception causes control to leave the body of the asynchronous method, the task ends in the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state.","pos":[4641,4804],"source":" If an unhandled exception causes control to leave the body of the asynchronous method, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state."},{"content":"If that exception is an <ph id=\"ph1\">&lt;xref:System.OperationCanceledException&gt;</ph>, the task instead ends in the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.","pos":[4805,4956],"source":" If that exception is an <xref:System.OperationCanceledException>, the task instead ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state."},{"content":"In this manner, the result or exception is eventually published.","pos":[4957,5021]},{"content":"There are several important variations of this behavior.","pos":[5024,5080]},{"content":"For performance reasons, if a task has already completed by the time the task is awaited, control is not yielded, and the function continues to execute.","pos":[5082,5234]},{"content":"Additionally, returning to the original context isn't always the desired behavior and can be changed; this is described in more detail in the next section.","pos":[5236,5391]},{"pos":[5397,5464],"content":"Configuring Suspension and Resumption with Yield and ConfigureAwait","linkify":"Configuring Suspension and Resumption with Yield and ConfigureAwait","nodes":[{"content":"Configuring Suspension and Resumption with Yield and ConfigureAwait","pos":[0,67]}]},{"content":"Several methods provide more control over an asynchronous method’s execution.","pos":[5466,5543]},{"content":"For example, you can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Yield%2A?displayProperty=nameWithType&gt;</ph> method to introduce a yield point into the asynchronous method:","pos":[5544,5709],"source":" For example, you can use the <xref:System.Threading.Tasks.Task.Yield%2A?displayProperty=nameWithType> method to introduce a yield point into the asynchronous method:"},{"content":"This is equivalent to asynchronously posting or scheduling back to the current context.","pos":[5801,5888]},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType&gt;</ph> method for better control over suspension and resumption in an asynchronous method.","pos":[6072,6258],"source":"You can also use the <xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType> method for better control over suspension and resumption in an asynchronous method."},{"content":"As mentioned previously, by default, the current context is captured at the time an asynchronous  method is suspended, and that captured context is used to invoke the asynchronous  method’s continuation upon resumption.","pos":[6260,6479]},{"content":"In many cases, this is the exact behavior you want.","pos":[6481,6532]},{"content":"In other cases, you may not care about the continuation context, and you can achieve better performance by avoiding such posts back to the original context.","pos":[6534,6690]},{"content":"To enable this, use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType&gt;</ph> method to inform the await operation not to capture and resume on the context, but to continue execution wherever the asynchronous operation that was being awaited completed:","pos":[6692,6972],"source":"  To enable this, use the <xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType> method to inform the await operation not to capture and resume on the context, but to continue execution wherever the asynchronous operation that was being awaited completed:"},{"pos":[7056,7091],"content":"Canceling an Asynchronous Operation","linkify":"Canceling an Asynchronous Operation","nodes":[{"content":"Canceling an Asynchronous Operation","pos":[0,35]}]},{"pos":[7093,7328],"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, TAP methods that support cancellation provide at least one overload that accepts a cancellation token (<ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken&gt;</ph> object).","source":"Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], TAP methods that support cancellation provide at least one overload that accepts a cancellation token (<xref:System.Threading.CancellationToken> object)."},{"content":"A cancellation token is created through a cancellation token source (<ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object).","pos":[7331,7456],"source":"A cancellation token is created through a cancellation token source (<xref:System.Threading.CancellationTokenSource> object)."},{"content":"The source’s <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property returns the cancellation token that will be signaled when the source’s <ph id=\"ph2\">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A&gt;</ph> method is called.","pos":[7458,7683],"source":"  The source’s <xref:System.Threading.CancellationTokenSource.Token%2A> property returns the cancellation token that will be signaled when the source’s <xref:System.Threading.CancellationTokenSource.Cancel%2A> method is called."},{"content":"For example, if you want to download a single webpage and you want to be able to cancel the operation, you create a <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object, pass its token to the TAP method, and then call the source’s <ph id=\"ph2\">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A&gt;</ph> method when you're ready to cancel the operation:","pos":[7685,8025],"source":"  For example, if you want to download a single webpage and you want to be able to cancel the operation, you create a <xref:System.Threading.CancellationTokenSource> object, pass its token to the TAP method, and then call the source’s <xref:System.Threading.CancellationTokenSource.Cancel%2A> method when you're ready to cancel the operation:"},{"content":"To cancel multiple asynchronous invocations, you can pass the same token to all invocations:","pos":[8213,8305]},{"content":"Or, you can pass the same token to a selective subset of operations:","pos":[8555,8623]},{"content":"Cancellation requests may be initiated from any thread.","pos":[8889,8944]},{"content":"You can pass the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph> value to any method that accepts a cancellation token to indicate that cancellation will never be requested.","pos":[8947,9151],"source":"You can pass the <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> value to any method that accepts a cancellation token to indicate that cancellation will never be requested."},{"content":"This causes the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.CanBeCanceled%2A?displayProperty=nameWithType&gt;</ph> property to return <ph id=\"ph2\">`false`</ph>, and the called method can optimize accordingly.","pos":[9153,9332],"source":"  This causes the <xref:System.Threading.CancellationToken.CanBeCanceled%2A?displayProperty=nameWithType> property to return `false`, and the called method can optimize accordingly."},{"content":"For testing purposes, you can also pass in a pre-canceled cancellation token that is instantiated by using the constructor that accepts a Boolean value to indicate whether the token should start in an already-canceled or not-cancelable state.","pos":[9334,9576]},{"content":"This approach to cancellation has several advantages:","pos":[9579,9632]},{"content":"You can pass the same cancellation token to any number of asynchronous and synchronous operations.","pos":[9638,9736]},{"content":"The same cancellation request may be proliferated to any number of listeners.","pos":[9742,9819]},{"content":"The developer of the asynchronous API is in complete control of whether cancellation may be requested and when it may take effect.","pos":[9825,9955]},{"content":"The code that consumes the API may selectively determine the asynchronous invocations that cancellation requests will be propagated to.","pos":[9961,10096]},{"pos":[10101,10120],"content":"Monitoring Progress","linkify":"Monitoring Progress","nodes":[{"content":"Monitoring Progress","pos":[0,19]}]},{"content":"Some asynchronous methods expose progress through a progress interface passed into the asynchronous method.","pos":[10122,10229]},{"content":"For example, consider a function which asynchronously downloads a string of text, and along the way raises progress updates that include the percentage of the download that has completed thus far.","pos":[10231,10427]},{"content":"Such a method could be consumed in a Windows Presentation Foundation (WPF) application as follows:","pos":[10429,10527]},{"pos":[10881,10922],"content":"Using the Built-in Task-based Combinators","linkify":"Using the Built-in Task-based Combinators","nodes":[{"content":"Using the Built-in Task-based Combinators","pos":[0,41]}]},{"pos":[10924,11030],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks&gt;</ph> namespace includes several methods for composing and working with tasks.","source":"The <xref:System.Threading.Tasks> namespace includes several methods for composing and working with tasks."},{"pos":[11036,11044],"content":"Task.Run","linkify":"Task.Run","nodes":[{"content":"Task.Run","pos":[0,8]}]},{"pos":[11046,11305],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class includes several <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> methods that let you easily offload work as a <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> to the thread pool, for example:","source":"The <xref:System.Threading.Tasks.Task> class includes several <xref:System.Threading.Tasks.Task.Run%2A> methods that let you easily offload work as a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> to the thread pool, for example:"},{"content":"Some of these <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> methods, such as the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType&gt;</ph> overload, exist as shorthand for the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[11505,11827],"source":"Some of these <xref:System.Threading.Tasks.Task.Run%2A> methods, such as the <xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> overload, exist as shorthand for the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method."},{"content":"Other overloads, such as <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType&gt;</ph>, enable you to use await within the offloaded work, for example:","pos":[11829,12036],"source":"  Other overloads, such as <xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType>, enable you to use await within the offloaded work, for example:"},{"pos":[12340,12608],"content":"Such overloads are logically equivalent to using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method in conjunction with the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A&gt;</ph> extension method in the Task Parallel Library.","source":"Such overloads are logically equivalent to using the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method in conjunction with the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method in the Task Parallel Library."},{"pos":[12614,12629],"content":"Task.FromResult","linkify":"Task.FromResult","nodes":[{"content":"Task.FromResult","pos":[0,15]}]},{"pos":[12631,12856],"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method in scenarios where data may already be available and just needs to be returned from a task-returning method lifted into a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>:","source":"Use the <xref:System.Threading.Tasks.Task.FromResult%2A> method in scenarios where data may already be available and just needs to be returned from a task-returning method lifted into a <xref:System.Threading.Tasks.Task%601>:"},{"pos":[13134,13146],"content":"Task.WhenAll","linkify":"Task.WhenAll","nodes":[{"content":"Task.WhenAll","pos":[0,12]}]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method to asynchronously wait on multiple asynchronous operations that are represented as tasks.","pos":[13148,13298],"source":"Use the <xref:System.Threading.Tasks.Task.WhenAll%2A> method to asynchronously wait on multiple asynchronous operations that are represented as tasks."},{"content":"The method has multiple overloads that support a set of non-generic tasks or a non-uniform set of generic tasks (for example, asynchronously waiting for multiple void-returning operations, or asynchronously waiting for multiple value-returning methods where each value may have a different type) and to support a uniform set of generic tasks (such as asynchronously waiting for multiple <ph id=\"ph1\">`TResult`</ph>-returning methods).","pos":[13300,13716],"source":"  The method has multiple overloads that support a set of non-generic tasks or a non-uniform set of generic tasks (for example, asynchronously waiting for multiple void-returning operations, or asynchronously waiting for multiple value-returning methods where each value may have a different type) and to support a uniform set of generic tasks (such as asynchronously waiting for multiple `TResult`-returning methods)."},{"content":"Let's say you want to send email messages to several customers.","pos":[13719,13782]},{"content":"You can overlap sending the messages so you're not waiting for one message to complete before sending the next.","pos":[13783,13894]},{"content":"You can also find out when the send operations have completed and whether any errors have occurred:","pos":[13895,13994]},{"content":"This code doesn't explicitly handle exceptions that may occur, but lets exceptions propagate out of the <ph id=\"ph1\">`await`</ph> on the resulting task from <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>.","pos":[14118,14303],"source":"This code doesn't explicitly handle exceptions that may occur, but lets exceptions propagate out of the `await` on the resulting task from <xref:System.Threading.Tasks.Task.WhenAll%2A>."},{"content":"To handle the exceptions, you can use code such as the following:","pos":[14305,14370]},{"content":"In this case, if any asynchronous operation fails, all the exceptions will be consolidated in an <ph id=\"ph1\">&lt;xref:System.AggregateException&gt;</ph> exception, which is stored in the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> that is returned from the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method.","pos":[14539,14817],"source":"In this case, if any asynchronous operation fails, all the exceptions will be consolidated in an <xref:System.AggregateException> exception, which is stored in the <xref:System.Threading.Tasks.Task> that is returned from the <xref:System.Threading.Tasks.Task.WhenAll%2A> method."},{"content":"However, only one of those exceptions is propagated by the <ph id=\"ph1\">`await`</ph> keyword.","pos":[14819,14894],"source":"  However, only one of those exceptions is propagated by the `await` keyword."},{"content":"If you want to examine all the exceptions, you can rewrite the previous code as follows:","pos":[14896,14984]},{"content":"Let's consider an example of downloading multiple files from the web asynchronously.","pos":[15274,15358]},{"content":"In this case, all the asynchronous operations have homogeneous result types, and it's easy to access the results:","pos":[15360,15473]},{"content":"You can use the same exception-handling techniques we discussed in the previous void-returning scenario:","pos":[15584,15688]},{"pos":[16022,16034],"content":"Task.WhenAny","linkify":"Task.WhenAny","nodes":[{"content":"Task.WhenAny","pos":[0,12]}]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to asynchronously wait for just one of multiple asynchronous operations represented as tasks to complete.","pos":[16036,16210],"source":"You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to asynchronously wait for just one of multiple asynchronous operations represented as tasks to complete."},{"content":"This method serves four primary use cases:","pos":[16212,16254]},{"content":"Redundancy:  Performing an operation multiple times and selecting the one that completes first (for example, contacting multiple stock quote web services that will produce a single result and selecting the one that completes the fastest).","pos":[16260,16498]},{"content":"Interleaving:  Launching multiple operations and waiting for all of them to complete, but processing them as they complete.","pos":[16504,16627]},{"content":"Throttling:  Allowing additional operations to begin as others complete.","pos":[16633,16705]},{"content":"This is an extension of the interleaving scenario.","pos":[16707,16757]},{"content":"Early bailout:  For example, an operation represented by task t1 can be grouped in a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> task with another task t2, and you can wait on the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> task.","pos":[16763,16996],"source":"Early bailout:  For example, an operation represented by task t1 can be grouped in a <xref:System.Threading.Tasks.Task.WhenAny%2A> task with another task t2, and you can wait on the <xref:System.Threading.Tasks.Task.WhenAny%2A> task."},{"content":"Task t2 could represent a time-out, or cancellation, or some other signal that causes the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> task to complete before t1 completes.","pos":[16997,17170],"source":" Task t2 could represent a time-out, or cancellation, or some other signal that causes the <xref:System.Threading.Tasks.Task.WhenAny%2A> task to complete before t1 completes."},{"pos":[17177,17187],"content":"Redundancy","linkify":"Redundancy","nodes":[{"content":"Redundancy","pos":[0,10]}]},{"content":"Consider a case where you want to make a decision about whether to buy a stock.","pos":[17189,17268]},{"content":"There are several stock recommendation web services that you trust, but depending on daily load, each service can end up being slow at different times.","pos":[17270,17421]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to receive a notification when any operation completes:","pos":[17423,17547],"source":"  You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to receive a notification when any operation completes:"},{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>, which returns the unwrapped results of all tasks that completed successfully, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> returns the task that completed.","pos":[17843,18053],"source":"Unlike <xref:System.Threading.Tasks.Task.WhenAll%2A>, which returns the unwrapped results of all tasks that completed successfully, <xref:System.Threading.Tasks.Task.WhenAny%2A> returns the task that completed."},{"content":"If a task fails, it’s important to know that it failed, and if a task succeeds, it’s important to know which task the return value is associated with.","pos":[18054,18204]},{"content":"Therefore, you need to access the result of the returned task, or further await it, as  this example shows.","pos":[18206,18313]},{"content":"As with <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>, you have to be able to accommodate exceptions.","pos":[18316,18417],"source":"As with <xref:System.Threading.Tasks.Task.WhenAll%2A>, you have to be able to accommodate exceptions."},{"content":"Because you receive the completed task back, you can await the returned task to have errors propagated, and <ph id=\"ph1\">`try/catch`</ph> them appropriately; for example:","pos":[18419,18571],"source":"  Because you receive the completed task back, you can await the returned task to have errors propagated, and `try/catch` them appropriately; for example:"},{"content":"Additionally, even if a first task completes successfully, subsequent tasks may fail.","pos":[18905,18990]},{"content":"At this point, you have several options for dealing with exceptions:  You can wait until all the launched tasks have completed, in which case you can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method, or you can decide that all exceptions are important and must be logged.","pos":[18992,19275],"source":"  At this point, you have several options for dealing with exceptions:  You can wait until all the launched tasks have completed, in which case you can use the <xref:System.Threading.Tasks.Task.WhenAll%2A> method, or you can decide that all exceptions are important and must be logged."},{"content":"For this, you can use continuations to receive a notification when tasks have completed asynchronously:","pos":[19277,19380]},{"content":"or:","pos":[19551,19554]},{"content":"or even:","pos":[19742,19750]},{"content":"Finally, you may want to cancel all the remaining operations:","pos":[20001,20062]},{"pos":[20451,20463],"content":"Interleaving","linkify":"Interleaving","nodes":[{"content":"Interleaving","pos":[0,12]}]},{"content":"Consider a case where you're downloading images from the web and processing each image (for example, adding the image to a UI control).","pos":[20465,20600]},{"content":"You have to do the processing sequentially on the UI thread, but you want to download the images as concurrently as possible.","pos":[20602,20727]},{"content":"Also, you don’t want to hold up adding the images to the UI until they’re all downloaded—you want to add them as they complete:","pos":[20728,20855]},{"pos":[21214,21391],"content":"You can also apply interleaving to a scenario that involves computationally intensive processing on the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> of the downloaded images; for example:","source":"You can also apply interleaving to a scenario that involves computationally intensive processing on the <xref:System.Threading.ThreadPool> of the downloaded images; for example:"},{"pos":[21805,21815],"content":"Throttling","linkify":"Throttling","nodes":[{"content":"Throttling","pos":[0,10]}]},{"content":"Consider the interleaving example, except that the user is downloading so many images that the downloads have to be throttled; for example, you want only a specific number of downloads to happen concurrently.","pos":[21817,22025]},{"content":"To achieve this, you can start a subset of the asynchronous operations.","pos":[22026,22097]},{"content":"As operations complete, you can start additional operations to take their place:","pos":[22099,22179]},{"pos":[22843,22856],"content":"Early Bailout","linkify":"Early Bailout","nodes":[{"content":"Early Bailout","pos":[0,13]}]},{"content":"Consider that you're waiting asynchronously for an operation to complete while simultaneously responding to a user’s cancellation request (for example, the user clicked a cancel button).","pos":[22858,23044]},{"content":"The following code illustrates this scenario:","pos":[23045,23090]},{"content":"This implementation re-enables the user interface as soon as you decide to bail out, but doesn't cancel the underlying asynchronous operations.","pos":[24046,24189]},{"content":"Another alternative would be to cancel the pending operations when you decide to bail out, but not reestablish the user interface until the operations actually complete, potentially due to ending early due to the cancellation request:","pos":[24191,24425]},{"pos":[24945,25159],"content":"Another example of early bailout involves using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method in conjunction with the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method, as discussed in the next section.","source":"Another example of early bailout involves using the <xref:System.Threading.Tasks.Task.WhenAny%2A> method in conjunction with the <xref:System.Threading.Tasks.Task.Delay%2A> method, as discussed in the next section."},{"pos":[25165,25175],"content":"Task.Delay","linkify":"Task.Delay","nodes":[{"content":"Task.Delay","pos":[0,10]}]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType&gt;</ph> method to introduce pauses into an asynchronous method’s execution.","pos":[25177,25333],"source":"You can use the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method to introduce pauses into an asynchronous method’s execution."},{"content":"This is useful for many kinds of functionality, including building polling loops and delaying the handling of user input for a predetermined period of time.","pos":[25335,25491]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType&gt;</ph> method can also be useful in combination with <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> for implementing time-outs on awaits.","pos":[25493,25728],"source":"  The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method can also be useful in combination with <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> for implementing time-outs on awaits."},{"content":"If a task that’s part of a larger asynchronous operation (for example, an ASP.NET web service) takes too long to complete, the overall operation could suffer, especially if it fails to ever complete.","pos":[25731,25930]},{"content":"For this reason, it’s important to be able to time out when waiting on an asynchronous operation.","pos":[25932,26029]},{"content":"The synchronous <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods accept time-out values, but the corresponding <ph id=\"ph4\">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType&gt;</ph><ph id=\"ph5\">/</ph><ph id=\"ph6\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> and the previously mentioned <ph id=\"ph7\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType&gt;</ph><ph id=\"ph8\">/</ph><ph id=\"ph9\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> methods do not.","pos":[26031,26688],"source":"  The synchronous <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods accept time-out values, but the corresponding <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType>/<xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> and the previously mentioned <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>/<xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> methods do not."},{"content":"Instead, you can use <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> in combination to implement a time-out.","pos":[26690,26902],"source":"  Instead, you can use <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> in combination to implement a time-out."},{"content":"For example, in your UI application, let's say that you want to download an image and disable the UI while the image is downloading.","pos":[26905,27037]},{"content":"However, if the download takes too long, you want to re-enable the UI and discard the download:","pos":[27038,27133]},{"pos":[27791,27900],"content":"The same applies to multiple downloads, because <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> returns a task:","source":"The same applies to multiple downloads, because <xref:System.Threading.Tasks.Task.WhenAll%2A> returns a task:"},{"pos":[28515,28546],"content":"Building Task-based Combinators","linkify":"Building Task-based Combinators","nodes":[{"content":"Building Task-based Combinators","pos":[0,31]}]},{"content":"Because a task is able to completely represent an asynchronous operation and provide synchronous and asynchronous capabilities for joining with the operation, retrieving its results, and so on, you can build useful libraries of combinators that compose tasks to build larger patterns.","pos":[28548,28832]},{"content":"As discussed in the previous section, the .NET Framework includes several built-in combinators, but you can also build your own.","pos":[28834,28962]},{"content":"The following sections provide several examples of potential combinator methods and types.","pos":[28963,29053]},{"pos":[29059,29071],"content":"RetryOnFault","linkify":"RetryOnFault","nodes":[{"content":"RetryOnFault","pos":[0,12]}]},{"content":"In many situations, you may want to retry an operation if a previous attempt fails.","pos":[29073,29156]},{"content":"For synchronous code, you might build a helper method such as <ph id=\"ph1\">`RetryOnFault`</ph> in the following example to accomplish this:","pos":[29158,29279],"source":"  For synchronous code, you might build a helper method such as `RetryOnFault` in the following example to accomplish this:"},{"content":"You can build an almost identical helper method for asynchronous operations that are implemented with TAP and thus return tasks:","pos":[29520,29648]},{"content":"You can then use this combinator to encode retries into the application’s logic; for example:","pos":[29935,30028]},{"content":"You could extend the <ph id=\"ph1\">`RetryOnFault`</ph> function further.","pos":[30193,30246],"source":"You could extend the `RetryOnFault` function further."},{"content":"For example, the function could accept another <ph id=\"ph1\">`Func&lt;Task&gt;`</ph> that will be invoked between retries to determine when to try the operation again; for example:","pos":[30247,30402],"source":" For example, the function could accept another `Func<Task>` that will be invoked between retries to determine when to try the operation again; for example:"},{"content":"You could then use the function as follows to wait for a second before retrying the operation:","pos":[30760,30854]},{"pos":[31092,31103],"content":"NeedOnlyOne","linkify":"NeedOnlyOne","nodes":[{"content":"NeedOnlyOne","pos":[0,11]}]},{"content":"Sometimes, you can take advantage of redundancy to improve an operation’s latency and chances for success.","pos":[31105,31211]},{"content":"Consider multiple web services that provide stock quotes, but at various times of the day, each service may provide different levels of quality and response times.","pos":[31213,31376]},{"content":"To deal with these fluctuations, you may issue requests to all the web services, and as soon as you get a response from one, cancel the remaining requests.","pos":[31378,31533]},{"content":"You can implement a helper function to make it easier to implement this common pattern of launching multiple operations, waiting for any, and then canceling the rest.","pos":[31535,31701]},{"content":"The <ph id=\"ph1\">`NeedOnlyOne`</ph> function in the following example illustrates this scenario:","pos":[31702,31780],"source":" The `NeedOnlyOne` function in the following example illustrates this scenario:"},{"content":"You can then use this function as follows:","pos":[32303,32345]},{"pos":[32573,32595],"content":"Interleaved Operations","linkify":"Interleaved Operations","nodes":[{"content":"Interleaved Operations","pos":[0,22]}]},{"content":"There is a potential performance problem with using the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to support an interleaving scenario when you're working with very large sets of tasks.","pos":[32597,32792],"source":"There is a potential performance problem with using the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to support an interleaving scenario when you're working with very large sets of tasks."},{"content":"Every call to <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> results in a continuation being registered with each task.","pos":[32794,32912],"source":"  Every call to <xref:System.Threading.Tasks.Task.WhenAny%2A> results in a continuation being registered with each task."},{"content":"For N number of tasks, this results in O(N2) continuations created over the lifetime of the interleaving operation.","pos":[32913,33028]},{"content":"If you're working with a large set of tasks, you can use a combinator  (<ph id=\"ph1\">`Interleaved`</ph> in the following example) to address the performance issue:","pos":[33030,33175],"source":"  If you're working with a large set of tasks, you can use a combinator  (`Interleaved` in the following example) to address the performance issue:"},{"content":"You can then use the combinator to process the results of tasks as they complete; for example:","pos":[34113,34207]},{"pos":[34343,34366],"content":"WhenAllOrFirstException","linkify":"WhenAllOrFirstException","nodes":[{"content":"WhenAllOrFirstException","pos":[0,23]}]},{"content":"In certain scatter/gather scenarios, you might want to wait for all tasks in a set, unless one of them faults, in which case you want to stop waiting as soon as the exception occurs.","pos":[34368,34550]},{"content":"You can accomplish that with a combinator method such as <ph id=\"ph1\">`WhenAllOrFirstException`</ph> in the following example:","pos":[34552,34660],"source":"  You can accomplish that with a combinator method such as `WhenAllOrFirstException` in the following example:"},{"pos":[35259,35294],"content":"Building Task-based Data Structures","linkify":"Building Task-based Data Structures","nodes":[{"content":"Building Task-based Data Structures","pos":[0,35]}]},{"pos":[35296,35688],"content":"In addition to the ability to build custom task-based combinators, having a data structure in <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> that represents both the results of an asynchronous operation and the necessary synchronization to join with it makes it a very powerful type on which to build custom data structures to be used in asynchronous scenarios.","source":"In addition to the ability to build custom task-based combinators, having a data structure in <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> that represents both the results of an asynchronous operation and the necessary synchronization to join with it makes it a very powerful type on which to build custom data structures to be used in asynchronous scenarios."},{"pos":[35694,35704],"content":"AsyncCache","linkify":"AsyncCache","nodes":[{"content":"AsyncCache","pos":[0,10]}]},{"content":"One important aspect of a task is that it may be handed out to multiple consumers, all of whom may await it, register continuations with it, get its result or exceptions (in the case of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>), and so on.","pos":[35706,35943],"source":"One important aspect of a task is that it may be handed out to multiple consumers, all of whom may await it, register continuations with it, get its result or exceptions (in the case of <xref:System.Threading.Tasks.Task%601>), and so on."},{"content":"This makes <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> perfectly suited to be used in an asynchronous caching infrastructure.","pos":[35945,36104],"source":"  This makes <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> perfectly suited to be used in an asynchronous caching infrastructure."},{"content":"Here’s an example of a small but powerful asynchronous cache built on top of <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>:","pos":[36106,36222],"source":"  Here’s an example of a small but powerful asynchronous cache built on top of <xref:System.Threading.Tasks.Task%601>:"},{"content":"The <bpt id=\"p1\">[</bpt>AsyncCache<ph id=\"ph1\">\\&lt;</ph>TKey,TValue&gt;<ept id=\"p1\">](https://blogs.msdn.microsoft.com/pfxteam/2010/04/23/parallelextensionsextras-tour-12-asynccache/)</ept> class accepts as a delegate to its constructor a function that takes a <ph id=\"ph2\">`TKey`</ph> and returns a <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>.","pos":[36950,37210],"source":"The [AsyncCache\\<TKey,TValue>](https://blogs.msdn.microsoft.com/pfxteam/2010/04/23/parallelextensionsextras-tour-12-asynccache/) class accepts as a delegate to its constructor a function that takes a `TKey` and returns a <xref:System.Threading.Tasks.Task%601>."},{"content":"Any previously accessed values from the cache are stored in the internal dictionary, and the <ph id=\"ph1\">`AsyncCache`</ph> ensures that only one task is generated per key, even if the cache is accessed concurrently.","pos":[37212,37410],"source":"  Any previously accessed values from the cache are stored in the internal dictionary, and the `AsyncCache` ensures that only one task is generated per key, even if the cache is accessed concurrently."},{"content":"For example, you can build a cache for downloaded web pages:","pos":[37413,37473]},{"content":"You can then use this cache in asynchronous methods whenever you need the contents of a web page.","pos":[37594,37691]},{"content":"The <ph id=\"ph1\">`AsyncCache`</ph> class ensures that you’re downloading as few pages as possible, and caches the results.","pos":[37692,37796],"source":" The `AsyncCache` class ensures that you’re downloading as few pages as possible, and caches the results."},{"pos":[38067,38098],"content":"AsyncProducerConsumerCollection","linkify":"AsyncProducerConsumerCollection","nodes":[{"content":"AsyncProducerConsumerCollection","pos":[0,31]}]},{"content":"You can also use tasks to build data structures for coordinating asynchronous activities.","pos":[38100,38189]},{"content":"Consider one of the classic parallel design patterns: producer/consumer.","pos":[38191,38263]},{"content":"In this pattern, producers generate data that is consumed by consumers, and the producers and consumers may run in parallel.","pos":[38265,38389]},{"content":"For example, the consumer processes item 1, which was previously generated by a producer who is now producing item 2.","pos":[38390,38507]},{"content":"For the producer/consumer pattern, you invariably need some data structure to store the work created by producers so that the consumers may be notified of new data and find it when available.","pos":[38509,38700]},{"content":"Here’s a simple data structure built on top of tasks that enables asynchronous methods to be used as producers and consumers:","pos":[38703,38828]},{"content":"With that data structure in place, you can write code such as the following:","pos":[39754,39830]},{"pos":[40132,40351],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow&gt;</ph> namespace includes the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> type, which you can use in a similar manner, but without having to build a custom collection type:","source":"The <xref:System.Threading.Tasks.Dataflow> namespace includes the <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> type, which you can use in a similar manner, but without having to build a custom collection type:"},{"pos":[40644,41040],"content":"[!NOTE]\nThe <xref:System.Threading.Tasks.Dataflow> namespace is available in the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] through **NuGet**. To install the assembly that contains the <xref:System.Threading.Tasks.Dataflow> namespace, open your project in Visual Studio, choose **Manage NuGet Packages** from the Project menu, and search online for the Microsoft.Tpl.Dataflow package.","leadings":["","> "],"nodes":[{"content":"The <xref:System.Threading.Tasks.Dataflow> namespace is available in the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] through **NuGet**. To install the assembly that contains the <xref:System.Threading.Tasks.Dataflow> namespace, open your project in Visual Studio, choose **Manage NuGet Packages** from the Project menu, and search online for the Microsoft.Tpl.Dataflow package.","pos":[8,394],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow&gt;</ph> namespace is available in the <ph id=\"ph2\">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> through <bpt id=\"p1\">**</bpt>NuGet<ept id=\"p1\">**</ept>.","pos":[0,144],"source":"The <xref:System.Threading.Tasks.Dataflow> namespace is available in the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] through **NuGet**."},{"content":"To install the assembly that contains the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Dataflow&gt;</ph> namespace, open your project in Visual Studio, choose <bpt id=\"p1\">**</bpt>Manage NuGet Packages<ept id=\"p1\">**</ept> from the Project menu, and search online for the Microsoft.Tpl.Dataflow package.","pos":[145,386],"source":" To install the assembly that contains the <xref:System.Threading.Tasks.Dataflow> namespace, open your project in Visual Studio, choose **Manage NuGet Packages** from the Project menu, and search online for the Microsoft.Tpl.Dataflow package."}]}]},{"pos":[41045,41053],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[41057,41193],"content":"<bpt id=\"p1\">[</bpt>Task-based Asynchronous Pattern (TAP)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>","source":"[Task-based Asynchronous Pattern (TAP)](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)"},{"pos":[41196,41356],"content":"<bpt id=\"p1\">[</bpt>Implementing the Task-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)</ept>","source":"[Implementing the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)"},{"pos":[41359,41523],"content":"<bpt id=\"p1\">[</bpt>Interop with Other Asynchronous Patterns and Types<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)</ept>","source":"[Interop with Other Asynchronous Patterns and Types](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)"}]}