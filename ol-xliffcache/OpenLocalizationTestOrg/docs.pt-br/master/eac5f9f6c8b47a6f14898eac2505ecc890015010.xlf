<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="consuming-the-task-based-asynchronous-pattern.md" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">eac5f9f6c8b47a6f14898eac2505ecc890015010</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\asynchronous-programming-patterns\consuming-the-task-based-asynchronous-pattern.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2dde7034f9c454946defcfbd278f2e3da38fc96d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">92bfbfea9b115521c09805ee8a61f76195988417</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Consuming the Task-based Asynchronous Pattern</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Consuming the Task-based Asynchronous Pattern</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>When you use the Task-based Asynchronous Pattern (TAP) to work with asynchronous operations, you can use callbacks to achieve waiting without blocking.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For tasks, this is achieved through methods such as <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Language-based asynchronous support hides callbacks by allowing asynchronous operations to be awaited within normal control flow, and compiler-generated code provides this same API-level support.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Suspending Execution with Await</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, you can use the <bpt id="p1">[</bpt>await<ept id="p1">](~/docs/csharp/language-reference/keywords/await.md)</ept> keyword in C# and the <bpt id="p2">[</bpt>Await Operator<ept id="p2">](~/docs/visual-basic/language-reference/operators/await-operator.md)</ept> in Visual Basic to asynchronously await <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>When you're awaiting a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, the <ph id="ph2">`await`</ph> expression is of type <ph id="ph3">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When you're awaiting a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, the <ph id="ph2">`await`</ph> expression is of type <ph id="ph3">`TResult`</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`await`</ph> expression must occur inside the body of an asynchronous method.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For more information about C# and Visual Basic language support in the <ph id="ph1">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph>, see the C# and Visual Basic language specifications.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Under the covers, the await functionality installs a callback on the task by using a continuation.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This callback resumes the asynchronous method at the point of suspension.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When the asynchronous method is resumed, if the awaited operation completed successfully and was a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, its <ph id="ph2">`TResult`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> that was awaited ended in the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state, an <ph id="ph4">&lt;xref:System.OperationCanceledException&gt;</ph> exception is thrown.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> that was awaited ended in the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, the exception that caused it to fault is thrown.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Task`</ph> can fault as a result of multiple exceptions, but only one of these exceptions is propagated.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType&gt;</ph> property returns an <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> exception that contains all the errors.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If a synchronization context (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object) is associated with the thread that was executing the asynchronous method at the time of suspension (for example, if the <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType&gt;</ph> property is not <ph id="ph3">`null`</ph>), the asynchronous method resumes on that same synchronization context by using the contextâ€™s <ph id="ph4">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Otherwise, it relies on the task scheduler (<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> object) that was current at the time of suspension.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Typically, this is the default task scheduler (<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A?displayProperty=nameWithType&gt;</ph>), which targets the thread pool.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This task scheduler determines whether the awaited asynchronous operation should resume where it completed or whether the resumption should be scheduled.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The default scheduler typically allows the continuation to run on the thread that the awaited operation completed.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When an asynchronous method is called, it synchronously executes the body of the function up until the first await expression on an awaitable instance that has not yet completed, at which point the invocation returns to the caller.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If the asynchronous method does not return <ph id="ph1">`void`</ph>, a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object is returned to represent the ongoing computation.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In a non-void asynchronous method, if a return statement is encountered or the end of the method body is reached, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> final state.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If an unhandled exception causes control to leave the body of the asynchronous method, the task ends in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If that exception is an <ph id="ph1">&lt;xref:System.OperationCanceledException&gt;</ph>, the task instead ends in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In this manner, the result or exception is eventually published.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There are several important variations of this behavior.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For performance reasons, if a task has already completed by the time the task is awaited, control is not yielded, and the function continues to execute.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Additionally, returning to the original context isn't always the desired behavior and can be changed; this is described in more detail in the next section.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Configuring Suspension and Resumption with Yield and ConfigureAwait</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Several methods provide more control over an asynchronous methodâ€™s execution.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For example, you can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Yield%2A?displayProperty=nameWithType&gt;</ph> method to introduce a yield point into the asynchronous method:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This is equivalent to asynchronously posting or scheduling back to the current context.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType&gt;</ph> method for better control over suspension and resumption in an asynchronous method.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>As mentioned previously, by default, the current context is captured at the time an asynchronous  method is suspended, and that captured context is used to invoke the asynchronous  methodâ€™s continuation upon resumption.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In many cases, this is the exact behavior you want.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In other cases, you may not care about the continuation context, and you can achieve better performance by avoiding such posts back to the original context.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>To enable this, use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ConfigureAwait%2A?displayProperty=nameWithType&gt;</ph> method to inform the await operation not to capture and resume on the context, but to continue execution wherever the asynchronous operation that was being awaited completed:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Canceling an Asynchronous Operation</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, TAP methods that support cancellation provide at least one overload that accepts a cancellation token (<ph id="ph2">&lt;xref:System.Threading.CancellationToken&gt;</ph> object).</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A cancellation token is created through a cancellation token source (<ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object).</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The sourceâ€™s <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property returns the cancellation token that will be signaled when the sourceâ€™s <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example, if you want to download a single webpage and you want to be able to cancel the operation, you create a <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object, pass its token to the TAP method, and then call the sourceâ€™s <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A&gt;</ph> method when you're ready to cancel the operation:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>To cancel multiple asynchronous invocations, you can pass the same token to all invocations:</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Or, you can pass the same token to a selective subset of operations:</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Cancellation requests may be initiated from any thread.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can pass the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph> value to any method that accepts a cancellation token to indicate that cancellation will never be requested.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This causes the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.CanBeCanceled%2A?displayProperty=nameWithType&gt;</ph> property to return <ph id="ph2">`false`</ph>, and the called method can optimize accordingly.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For testing purposes, you can also pass in a pre-canceled cancellation token that is instantiated by using the constructor that accepts a Boolean value to indicate whether the token should start in an already-canceled or not-cancelable state.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This approach to cancellation has several advantages:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can pass the same cancellation token to any number of asynchronous and synchronous operations.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The same cancellation request may be proliferated to any number of listeners.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The developer of the asynchronous API is in complete control of whether cancellation may be requested and when it may take effect.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The code that consumes the API may selectively determine the asynchronous invocations that cancellation requests will be propagated to.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Monitoring Progress</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Some asynchronous methods expose progress through a progress interface passed into the asynchronous method.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, consider a function which asynchronously downloads a string of text, and along the way raises progress updates that include the percentage of the download that has completed thus far.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Such a method could be consumed in a Windows Presentation Foundation (WPF) application as follows:</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Using the Built-in Task-based Combinators</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks&gt;</ph> namespace includes several methods for composing and working with tasks.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Task.Run</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class includes several <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> methods that let you easily offload work as a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> to the thread pool, for example:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Some of these <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> methods, such as the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType&gt;</ph> overload, exist as shorthand for the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Other overloads, such as <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Func%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType&gt;</ph>, enable you to use await within the offloaded work, for example:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Such overloads are logically equivalent to using the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method in conjunction with the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A&gt;</ph> extension method in the Task Parallel Library.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Task.FromResult</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method in scenarios where data may already be available and just needs to be returned from a task-returning method lifted into a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Task.WhenAll</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method to asynchronously wait on multiple asynchronous operations that are represented as tasks.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The method has multiple overloads that support a set of non-generic tasks or a non-uniform set of generic tasks (for example, asynchronously waiting for multiple void-returning operations, or asynchronously waiting for multiple value-returning methods where each value may have a different type) and to support a uniform set of generic tasks (such as asynchronously waiting for multiple <ph id="ph1">`TResult`</ph>-returning methods).</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Let's say you want to send email messages to several customers.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You can overlap sending the messages so you're not waiting for one message to complete before sending the next.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can also find out when the send operations have completed and whether any errors have occurred:</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This code doesn't explicitly handle exceptions that may occur, but lets exceptions propagate out of the <ph id="ph1">`await`</ph> on the resulting task from <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To handle the exceptions, you can use code such as the following:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In this case, if any asynchronous operation fails, all the exceptions will be consolidated in an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception, which is stored in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> that is returned from the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>However, only one of those exceptions is propagated by the <ph id="ph1">`await`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If you want to examine all the exceptions, you can rewrite the previous code as follows:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Let's consider an example of downloading multiple files from the web asynchronously.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In this case, all the asynchronous operations have homogeneous result types, and it's easy to access the results:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You can use the same exception-handling techniques we discussed in the previous void-returning scenario:</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Task.WhenAny</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to asynchronously wait for just one of multiple asynchronous operations represented as tasks to complete.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This method serves four primary use cases:</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Redundancy:  Performing an operation multiple times and selecting the one that completes first (for example, contacting multiple stock quote web services that will produce a single result and selecting the one that completes the fastest).</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Interleaving:  Launching multiple operations and waiting for all of them to complete, but processing them as they complete.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Throttling:  Allowing additional operations to begin as others complete.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This is an extension of the interleaving scenario.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Early bailout:  For example, an operation represented by task t1 can be grouped in a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> task with another task t2, and you can wait on the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> task.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Task t2 could represent a time-out, or cancellation, or some other signal that causes the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> task to complete before t1 completes.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Redundancy</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Consider a case where you want to make a decision about whether to buy a stock.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>There are several stock recommendation web services that you trust, but depending on daily load, each service can end up being slow at different times.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to receive a notification when any operation completes:</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Unlike <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>, which returns the unwrapped results of all tasks that completed successfully, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> returns the task that completed.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If a task fails, itâ€™s important to know that it failed, and if a task succeeds, itâ€™s important to know which task the return value is associated with.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Therefore, you need to access the result of the returned task, or further await it, as  this example shows.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>As with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>, you have to be able to accommodate exceptions.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Because you receive the completed task back, you can await the returned task to have errors propagated, and <ph id="ph1">`try/catch`</ph> them appropriately; for example:</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Additionally, even if a first task completes successfully, subsequent tasks may fail.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>At this point, you have several options for dealing with exceptions:  You can wait until all the launched tasks have completed, in which case you can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method, or you can decide that all exceptions are important and must be logged.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For this, you can use continuations to receive a notification when tasks have completed asynchronously:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>or:</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>or even:</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Finally, you may want to cancel all the remaining operations:</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Interleaving</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Consider a case where you're downloading images from the web and processing each image (for example, adding the image to a UI control).</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>You have to do the processing sequentially on the UI thread, but you want to download the images as concurrently as possible.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Also, you donâ€™t want to hold up adding the images to the UI until theyâ€™re all downloadedâ€”you want to add them as they complete:</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>You can also apply interleaving to a scenario that involves computationally intensive processing on the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> of the downloaded images; for example:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Throttling</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Consider the interleaving example, except that the user is downloading so many images that the downloads have to be throttled; for example, you want only a specific number of downloads to happen concurrently.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>To achieve this, you can start a subset of the asynchronous operations.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>As operations complete, you can start additional operations to take their place:</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Early Bailout</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Consider that you're waiting asynchronously for an operation to complete while simultaneously responding to a userâ€™s cancellation request (for example, the user clicked a cancel button).</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following code illustrates this scenario:</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This implementation re-enables the user interface as soon as you decide to bail out, but doesn't cancel the underlying asynchronous operations.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Another alternative would be to cancel the pending operations when you decide to bail out, but not reestablish the user interface until the operations actually complete, potentially due to ending early due to the cancellation request:</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Another example of early bailout involves using the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method in conjunction with the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method, as discussed in the next section.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Task.Delay</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType&gt;</ph> method to introduce pauses into an asynchronous methodâ€™s execution.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This is useful for many kinds of functionality, including building polling loops and delaying the handling of user input for a predetermined period of time.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType&gt;</ph> method can also be useful in combination with <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> for implementing time-outs on awaits.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If a task thatâ€™s part of a larger asynchronous operation (for example, an ASP.NET web service) takes too long to complete, the overall operation could suffer, especially if it fails to ever complete.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>For this reason, itâ€™s important to be able to time out when waiting on an asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The synchronous <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods accept time-out values, but the corresponding <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType&gt;</ph><ph id="ph5">/</ph><ph id="ph6">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> and the previously mentioned <ph id="ph7">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType&gt;</ph><ph id="ph8">/</ph><ph id="ph9">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> methods do not.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Instead, you can use <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType&gt;</ph> in combination to implement a time-out.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, in your UI application, let's say that you want to download an image and disable the UI while the image is downloading.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>However, if the download takes too long, you want to re-enable the UI and discard the download:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The same applies to multiple downloads, because <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> returns a task:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Building Task-based Combinators</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Because a task is able to completely represent an asynchronous operation and provide synchronous and asynchronous capabilities for joining with the operation, retrieving its results, and so on, you can build useful libraries of combinators that compose tasks to build larger patterns.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>As discussed in the previous section, the .NET Framework includes several built-in combinators, but you can also build your own.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The following sections provide several examples of potential combinator methods and types.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>RetryOnFault</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>In many situations, you may want to retry an operation if a previous attempt fails.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For synchronous code, you might build a helper method such as <ph id="ph1">`RetryOnFault`</ph> in the following example to accomplish this:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You can build an almost identical helper method for asynchronous operations that are implemented with TAP and thus return tasks:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>You can then use this combinator to encode retries into the applicationâ€™s logic; for example:</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>You could extend the <ph id="ph1">`RetryOnFault`</ph> function further.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For example, the function could accept another <ph id="ph1">`Func&lt;Task&gt;`</ph> that will be invoked between retries to determine when to try the operation again; for example:</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You could then use the function as follows to wait for a second before retrying the operation:</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>NeedOnlyOne</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Sometimes, you can take advantage of redundancy to improve an operationâ€™s latency and chances for success.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Consider multiple web services that provide stock quotes, but at various times of the day, each service may provide different levels of quality and response times.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>To deal with these fluctuations, you may issue requests to all the web services, and as soon as you get a response from one, cancel the remaining requests.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>You can implement a helper function to make it easier to implement this common pattern of launching multiple operations, waiting for any, and then canceling the rest.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`NeedOnlyOne`</ph> function in the following example illustrates this scenario:</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>You can then use this function as follows:</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Interleaved Operations</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>There is a potential performance problem with using the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to support an interleaving scenario when you're working with very large sets of tasks.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Every call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> results in a continuation being registered with each task.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For N number of tasks, this results in O(N2) continuations created over the lifetime of the interleaving operation.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>If you're working with a large set of tasks, you can use a combinator  (<ph id="ph1">`Interleaved`</ph> in the following example) to address the performance issue:</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>You can then use the combinator to process the results of tasks as they complete; for example:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>WhenAllOrFirstException</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>In certain scatter/gather scenarios, you might want to wait for all tasks in a set, unless one of them faults, in which case you want to stop waiting as soon as the exception occurs.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>You can accomplish that with a combinator method such as <ph id="ph1">`WhenAllOrFirstException`</ph> in the following example:</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Building Task-based Data Structures</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>In addition to the ability to build custom task-based combinators, having a data structure in <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> that represents both the results of an asynchronous operation and the necessary synchronization to join with it makes it a very powerful type on which to build custom data structures to be used in asynchronous scenarios.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>AsyncCache</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>One important aspect of a task is that it may be handed out to multiple consumers, all of whom may await it, register continuations with it, get its result or exceptions (in the case of <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>), and so on.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This makes <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> perfectly suited to be used in an asynchronous caching infrastructure.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Hereâ€™s an example of a small but powerful asynchronous cache built on top of <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>AsyncCache<ph id="ph1">\&lt;</ph>TKey,TValue&gt;<ept id="p1">](https://blogs.msdn.microsoft.com/pfxteam/2010/04/23/parallelextensionsextras-tour-12-asynccache/)</ept> class accepts as a delegate to its constructor a function that takes a <ph id="ph2">`TKey`</ph> and returns a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Any previously accessed values from the cache are stored in the internal dictionary, and the <ph id="ph1">`AsyncCache`</ph> ensures that only one task is generated per key, even if the cache is accessed concurrently.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For example, you can build a cache for downloaded web pages:</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You can then use this cache in asynchronous methods whenever you need the contents of a web page.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AsyncCache`</ph> class ensures that youâ€™re downloading as few pages as possible, and caches the results.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>AsyncProducerConsumerCollection</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>You can also use tasks to build data structures for coordinating asynchronous activities.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Consider one of the classic parallel design patterns: producer/consumer.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>In this pattern, producers generate data that is consumed by consumers, and the producers and consumers may run in parallel.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For example, the consumer processes item 1, which was previously generated by a producer who is now producing item 2.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>For the producer/consumer pattern, you invariably need some data structure to store the work created by producers so that the consumers may be notified of new data and find it when available.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Hereâ€™s a simple data structure built on top of tasks that enables asynchronous methods to be used as producers and consumers:</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>With that data structure in place, you can write code such as the following:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Dataflow&gt;</ph> namespace includes the <ph id="ph2">&lt;xref:System.Threading.Tasks.Dataflow.BufferBlock%601&gt;</ph> type, which you can use in a similar manner, but without having to build a custom collection type:</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Dataflow&gt;</ph> namespace is available in the <ph id="ph2">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)]</ph> through <bpt id="p1">**</bpt>NuGet<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>To install the assembly that contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.Dataflow&gt;</ph> namespace, open your project in Visual Studio, choose <bpt id="p1">**</bpt>Manage NuGet Packages<ept id="p1">**</ept> from the Project menu, and search online for the Microsoft.Tpl.Dataflow package.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Task-based Asynchronous Pattern (TAP)<ept id="p1">](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept></source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Implementing the Task-based Asynchronous Pattern<ept id="p1">](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)</ept></source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interop with Other Asynchronous Patterns and Types<ept id="p1">](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>