{"content":"---\ntitle: The history of C# - C# Guide\ndescription: What did the language look like in its earliest versions, and how has it evolved since?\nauthor: erikdietrich\nms.date: 09/20/2017\n---\n\n# The history of C\\#\n\nThis article provides a history of each major release of the C# language. The C# team is continuing to innovate and add new features. Detailed language feature status, including features considered for upcoming releases can be found [on the dotnet/roslyn repository](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md) on GitHub.\n\n> [!IMPORTANT]\n> The C# language relies on types and methods in what the C# specification defines as a *standard library* for some of the features. The .NET platform delivers those types and methods in a number of packages. One example is exception processing. Every `throw` statement or expression is checked to ensure the object being thrown is derived from <xref:System.Exception>. Similarly, every `catch` is checked to ensure that the type being caught is derived from <xref:System.Exception>. Each version may add new requirements. To use the latest language features in older environments, you may need to install specific libraries. These dependencies are documented in the page for each specific version. You can learn more about the [relationships between language and library](relationships-between-language-and-library.md) for background on this dependency.\n\nThe C# build tools consider the latest major language release the default language version. There may be point releases between major releases, detailed in other articles in this section. To use the latest features in a point release, you need to [configure the compiler language version](../language-reference/configure-language-version.md) and select the version. There have been three point releases since C# 7.0:\n\n* [C# 7.3](csharp-7-3.md):\n  - C# 7.3 is currently available in [Visual Studio 2017 version 15.7](https://visualstudio.microsoft.com/vs/whatsnew/), and in the [.NET Core 2.1 SDK 2.1.300 RC1](../../core/whats-new/index.md).\n* [C# 7.2](csharp-7-2.md):\n  - C# 7.2 is currently available in [Visual Studio 2017 version 15.5](https://visualstudio.microsoft.com/vs/whatsnew/), and in the [.NET Core 2.0 SDK](../../core/whats-new/index.md).\n* [C# 7.1](csharp-7-1.md):\n  - These features were added in [Visual Studio 2017 version 15.3](https://visualstudio.microsoft.com/vs/whatsnew/), and in the [.NET Core 2.0 SDK](../../core/whats-new/index.md).\n\n## C# version 1.0\n\nWhen you go back and look, C# version 1.0 looked a lot like Java. As [part of its stated design goals for ECMA](https://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html), it sought to be a \"simple, modern, general-purpose object-oriented language.\"  At the time, looking like Java meant it achieved those early design goals.\n\nBut if you look back on C# 1.0 now, you'd find yourself a little dizzy. It lacked the built-in async capabilities and some of the slick functionality around generics you take for granted. As a matter of fact, it lacked generics altogether.  And [LINQ](../linq/index.md)? Not available yet. Those additions would take some years to come out.\n\nC# version 1.0 looked stripped of features, compared to today. You'd find yourself writing some verbose code. But yet, you have to start somewhere. C# version 1.0 was a viable alternative to Java on the Windows platform.\n\nThe major features of C# 1.0 included:\n\n- [Classes](../programming-guide/classes-and-structs/classes.md)\n- [Structs](../programming-guide/classes-and-structs/structs.md)\n- [Interfaces](../programming-guide/interfaces/index.md)\n- [Events](../events-overview.md)\n- [Properties](../properties.md)\n- [Delegates](../delegates-overview.md)\n- [Expressions](../programming-guide/statements-expressions-operators/expressions.md)\n- [Statements](../programming-guide/statements-expressions-operators/statements.md)\n- [Attributes](../programming-guide/concepts/attributes/index.md)\n- [Literals](../language-reference/keywords/literal-keywords.md)\n\n## C# version 1.2\n\nC# version 1.2 shipped with Visual Studio 2003. It contained a few small enhancements to the language. Most notable is that starting with this version, the code generated in a `foreach` loop called <xref:System.IDisposable.Dispose%2A> on an <xref:System.Collections.IEnumerator> when that <xref:System.Collections.IEnumerator> implemented <xref:System.IDisposable>.\n\n## C# version 2.0\n\nNow things start to get interesting. Let's take a look at some major features of C# 2.0, released in 2005, along with Visual Studio 2005:\n\n- [Generics](../programming-guide/generics/index.md)\n- [Partial types](../programming-guide/classes-and-structs/partial-classes-and-methods.md#partial-classes)\n- [Anonymous methods](../programming-guide/statements-expressions-operators/anonymous-methods.md)\n- [Nullable types](../programming-guide/nullable-types/index.md)\n- [Iterators](../programming-guide/concepts/iterators.md)\n- [Covariance and contravariance](../programming-guide/concepts/covariance-contravariance/index.md)\n\nOther C# 2.0 features added capabilities to existing features:\n\n- Getter/setter separate accessibility\n- Method group conversions (delegates)\n- Static classes\n- Delegate inference\n\nWhile C# may have started as a generic Object-Oriented (OO) language, C# version 2.0 changed that in a hurry. Once they had their feet under them, they went after some serious developer pain points. And they went after them in a significant way.\n\nWith generics, types and methods can operate on an arbitrary type while still retaining type safety. For instance, having a <xref:System.Collections.Generic.List%601> lets you have `List<string>` or `List<int>` and perform type-safe operations on those strings or integers while you iterate through them. Using generics is better than create `ListInt` that derives from `ArrayList`  or casting from `Object` for every operation.\n\nC# version 2.0 brought iterators. To put it succinctly, iterators let you examine all the items in a `List` (or other Enumerable types) with a `foreach` loop. Having iterators as a first-class part of the language dramatically enhanced readability of the language and people's ability to reason about the code.\n\nAnd yet, C# continued to play a bit of catch-up with Java. Java had already released versions that included generics and iterators. But that would soon change as the languages continued to evolve apart.\n\n## C# version 3.0\n\nC# version 3.0 came in late 2007, along with Visual Studio 2008, though the full boat of language features would actually come with .NET Framework version 3.5. This version marked a major change in the growth of C#. It established C# as a truly formidable programming language. Let's take a look at some major features in this version:\n\n- [Auto-implemented properties](../programming-guide/classes-and-structs/auto-implemented-properties.md)\n- [Anonymous types](../programming-guide/classes-and-structs/anonymous-types.md)\n- [Query expressions](../linq/query-expression-basics.md)\n- [Lambda expressions](../programming-guide/statements-expressions-operators/lambda-expressions.md)\n- [Expression trees](../expression-trees.md)\n- [Extension methods](../programming-guide/classes-and-structs/extension-methods.md)\n- [Implicitly typed local variables](../language-reference/keywords/var.md)\n- [Partial methods](../language-reference/keywords/partial-method.md)\n- [Object and collection initializers](../programming-guide/classes-and-structs/object-and-collection-initializers.md)\n\nIn retrospect, many of these features seem both inevitable and inseparable. They all fit together strategically. It's generally thought that C# version's killer feature was the query expression, also known as Language-Integrated Query (LINQ).\n\nA more nuanced view examines expression trees, lambda expressions, and anonymous types as the foundation upon which LINQ is constructed. But, in either case, C# 3.0 presented a revolutionary concept. C# 3.0 had begun to lay the groundwork for turning C# into a hybrid Object-Oriented / Functional language.\n\nSpecifically, you could now write SQL-style, declarative queries to perform operations on collections, among other things. Instead of writing a `for` loop to compute the average of a list of integers, you could now do that as simply as `list.Average()`. The combination of query expressions and extension methods made it look as though that list of integers had gotten a whole lot smarter.\n\nIt took time for people to really grasp and integrate the concept, but they gradually did. And now, years later, code is much more concise, simple, and functional.\n\n## C# version 4.0\n\nC# version 4.0 would have had a difficult time living up to the groundbreaking status of version 3.0. With version 3.0, C# had moved the language firmly out from the shadow of Java and into prominence. The language was quickly becoming elegant.\n\nThe next version did introduce some interesting new features:\n\n- [Dynamic binding](../language-reference/keywords/dynamic.md)\n- [Named/optional arguments](../programming-guide/classes-and-structs/named-and-optional-arguments.md)\n- [Generic covariant and contravariant](../../standard/generics/covariance-and-contravariance.md)\n- [Embedded interop types](../../framework/interop/type-equivalence-and-embedded-interop-types.md)\n\nEmbedded interop types alleviated a deployment pain. Generic covariance and contravariance give you more power to use generics, but they're a bit academic and probably most appreciated by framework and library authors. Named and optional parameters let you eliminate many method overloads and provide convenience. But none of those features are exactly paradigm altering.\n\nThe major feature was the introduction of the `dynamic` keyword. The `dynamic` keyword introduced into C# version 4.0 the ability to override the compiler on compile-time typing. By using the dynamic keyword, you can create constructs similar to dynamically typed languages like JavaScript. You can create a `dynamic x = \"a string\"` and then add six to it, leaving it up to the runtime to sort out what should happen next.\n\nDynamic binding gives you the potential for errors but also great power within the language.\n\n## C# version 5.0\n\nC# version 5.0 was a focused version of the language. Nearly all of the effort for that version went into another groundbreaking language concept: the `async` and `await` model for asynchronous programming.  Here is the major features list:\n\n- [Asynchronous members](../async.md)\n- [Caller info attributes](../programming-guide/concepts/caller-information.md)\n\n### See Also\n\n* [Code Project: Caller Info Attributes in C# 5.0](https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp)\n\nThe caller info attribute lets you easily retrieve information about the context in which you're running without resorting to a ton of boilerplate reflection code. It has many uses in diagnostics and logging tasks.\n\nBut `async` and `await` are the real stars of this release. When these features came out in 2012, C# changed the game again by baking asynchrony into the language as a first-class participant. If you've ever dealt with long running operations and the implementation of webs of callbacks, you probably loved this language feature.\n\n## C# version 6.0\n\nWith versions 3.0 and 5.0, C# had added major new features in an object-oriented language. With version 6.0, it would go away from doing a dominant killer feature and instead release many smaller features that made C# programming more productive. Here are some of them:\n\n- [Static imports](./csharp-6.md#using-static)\n- [Exception filters](./csharp-6.md#exception-filters)\n- [Auto-property initializers](./csharp-6.md#auto-property-initializers)\n- [Expression bodied members](./csharp-6.md#expression-bodied-function-members)\n- [Null propagator](./csharp-6.md#null-conditional-operators)\n- [String interpolation](./csharp-6.md#string-interpolation)\n- [nameof operator](./csharp-6.md#the-nameof-expression)\n- [Index initializers](csharp-6.md#extension-add-methods-in-collection-initializers)\n\nOther new features include:\n\n- Await in catch/finally blocks\n- Default values for getter-only properties\n\nEach of these features is interesting in its own right. But if you look at them altogether, you see an interesting pattern. In this version, C# eliminated language boilerplate to make code more terse and readable. So for fans of clean, simple code, this language version was a huge win.\n\nThey did one other thing along with this version, though it's not a traditional language feature in itself. They released [Roslyn the compiler as a service](https://github.com/dotnet/roslyn). The C# compiler is now written in C#, and you can use the compiler as part of your programming efforts.\n\n## C# version 7.0\n\nThe most recent major version is C# version 7.0. This version has some evolutionary and cool stuff in the vein of C# 6.0, but without the compiler as a service. Here are some of the new features:\n\n- [Out variables](./csharp-7.md#out-variables)\n- [Tuples and deconstruction](./csharp-7.md#tuples)\n- [Pattern matching](./csharp-7.md#pattern-matching)\n- [Local functions](./csharp-7.md#local-functions)\n- [Expanded expression bodied members](./csharp-7.md#more-expression-bodied-members)\n- [Ref locals and returns](./csharp-7.md#ref-locals-and-returns)\n\nOther features included:\n\n- [Discards](./csharp-7.md#discards)\n- [Binary Literals and Digit Separators](./csharp-7.md#numeric-literal-syntax-improvements)\n- [Throw expressions](./csharp-7.md#throw-expressions)\n\nAll of these features offer cool new capabilities for developers and the opportunity to write even cleaner code than ever. A highlight is condensing the declaration of variables to use with the `out` keyword and by allowing multiple return values via tuple.\n\nBut C# is being put to ever broader use. .NET Core now targets any operating system and has its eyes firmly on the cloud and on portability.  These new capabilities certainly occupy the language designers' thoughts and time, in addition to coming up with new features.\n\n_Article_ [_originally published on the NDepend blog_](https://blog.ndepend.com/c-versions-look-language-history/)_, courtesy of Erik Dietrich and Patrick Smacchia._\n","nodes":[{"pos":[4,181],"embed":true,"restype":"x-metadata","content":"title: The history of C# - C# Guide\ndescription: What did the language look like in its earliest versions, and how has it evolved since?\nauthor: erikdietrich\nms.date: 09/20/2017","nodes":[{"content":"The history of C# - C# Guide","nodes":[{"pos":[0,28],"content":"The history of C# - C# Guide","nodes":[{"content":"The history of C# - C# Guide","pos":[0,28]}]}],"path":["title"],"nosxs":false},{"content":"What did the language look like in its earliest versions, and how has it evolved since?","nodes":[{"pos":[0,87],"content":"What did the language look like in its earliest versions, and how has it evolved since?","nodes":[{"content":"What did the language look like in its earliest versions, and how has it evolved since?","pos":[0,87]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[189,207],"content":"The history of C\\#","linkify":"The history of C\\#","nodes":[{"content":"The history of C<ph id=\"ph1\">\\#</ph>","pos":[0,18],"source":"The history of C\\#"}]},{"content":"This article provides a history of each major release of the C# language.","pos":[209,282]},{"content":"The C# team is continuing to innovate and add new features.","pos":[283,342]},{"content":"Detailed language feature status, including features considered for upcoming releases can be found <bpt id=\"p1\">[</bpt>on the dotnet/roslyn repository<ept id=\"p1\">](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)</ept> on GitHub.","pos":[343,568],"source":" Detailed language feature status, including features considered for upcoming releases can be found [on the dotnet/roslyn repository](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md) on GitHub."},{"pos":[572,1439],"content":"[!IMPORTANT]\nThe C# language relies on types and methods in what the C# specification defines as a *standard library* for some of the features. The .NET platform delivers those types and methods in a number of packages. One example is exception processing. Every `throw` statement or expression is checked to ensure the object being thrown is derived from <xref:System.Exception>. Similarly, every `catch` is checked to ensure that the type being caught is derived from <xref:System.Exception>. Each version may add new requirements. To use the latest language features in older environments, you may need to install specific libraries. These dependencies are documented in the page for each specific version. You can learn more about the [relationships between language and library](relationships-between-language-and-library.md) for background on this dependency.","leadings":["","> "],"nodes":[{"content":"The C# language relies on types and methods in what the C# specification defines as a *standard library* for some of the features. The .NET platform delivers those types and methods in a number of packages. One example is exception processing. Every `throw` statement or expression is checked to ensure the object being thrown is derived from <xref:System.Exception>. Similarly, every `catch` is checked to ensure that the type being caught is derived from <xref:System.Exception>. Each version may add new requirements. To use the latest language features in older environments, you may need to install specific libraries. These dependencies are documented in the page for each specific version. You can learn more about the [relationships between language and library](relationships-between-language-and-library.md) for background on this dependency.","pos":[13,865],"nodes":[{"content":"The C# language relies on types and methods in what the C# specification defines as a <bpt id=\"p1\">*</bpt>standard library<ept id=\"p1\">*</ept> for some of the features.","pos":[0,130],"source":"The C# language relies on types and methods in what the C# specification defines as a *standard library* for some of the features."},{"content":"The .NET platform delivers those types and methods in a number of packages.","pos":[131,206]},{"content":"One example is exception processing.","pos":[207,243]},{"content":"Every <ph id=\"ph1\">`throw`</ph> statement or expression is checked to ensure the object being thrown is derived from <ph id=\"ph2\">&lt;xref:System.Exception&gt;</ph>.","pos":[244,367],"source":" Every `throw` statement or expression is checked to ensure the object being thrown is derived from <xref:System.Exception>."},{"content":"Similarly, every <ph id=\"ph1\">`catch`</ph> is checked to ensure that the type being caught is derived from <ph id=\"ph2\">&lt;xref:System.Exception&gt;</ph>.","pos":[368,481],"source":" Similarly, every `catch` is checked to ensure that the type being caught is derived from <xref:System.Exception>."},{"content":"Each version may add new requirements.","pos":[482,520]},{"content":"To use the latest language features in older environments, you may need to install specific libraries.","pos":[521,623]},{"content":"These dependencies are documented in the page for each specific version.","pos":[624,696]},{"content":"You can learn more about the <bpt id=\"p1\">[</bpt>relationships between language and library<ept id=\"p1\">](relationships-between-language-and-library.md)</ept> for background on this dependency.","pos":[697,852],"source":" You can learn more about the [relationships between language and library](relationships-between-language-and-library.md) for background on this dependency."}]}]},{"content":"The C# build tools consider the latest major language release the default language version.","pos":[1441,1532]},{"content":"There may be point releases between major releases, detailed in other articles in this section.","pos":[1533,1628]},{"content":"To use the latest features in a point release, you need to <bpt id=\"p1\">[</bpt>configure the compiler language version<ept id=\"p1\">](../language-reference/configure-language-version.md)</ept> and select the version.","pos":[1629,1806],"source":" To use the latest features in a point release, you need to [configure the compiler language version](../language-reference/configure-language-version.md) and select the version."},{"content":"There have been three point releases since C# 7.0:","pos":[1807,1857]},{"pos":[1861,1885],"content":"<bpt id=\"p1\">[</bpt>C# 7.3<ept id=\"p1\">](csharp-7-3.md)</ept>:","source":"[C# 7.3](csharp-7-3.md):"},{"pos":[1890,2081],"content":"C# 7.3 is currently available in <bpt id=\"p1\">[</bpt>Visual Studio 2017 version 15.7<ept id=\"p1\">](https://visualstudio.microsoft.com/vs/whatsnew/)</ept>, and in the <bpt id=\"p2\">[</bpt>.NET Core 2.1 SDK 2.1.300 RC1<ept id=\"p2\">](../../core/whats-new/index.md)</ept>.","source":"C# 7.3 is currently available in [Visual Studio 2017 version 15.7](https://visualstudio.microsoft.com/vs/whatsnew/), and in the [.NET Core 2.1 SDK 2.1.300 RC1](../../core/whats-new/index.md)."},{"pos":[2084,2108],"content":"<bpt id=\"p1\">[</bpt>C# 7.2<ept id=\"p1\">](csharp-7-2.md)</ept>:","source":"[C# 7.2](csharp-7-2.md):"},{"pos":[2113,2292],"content":"C# 7.2 is currently available in <bpt id=\"p1\">[</bpt>Visual Studio 2017 version 15.5<ept id=\"p1\">](https://visualstudio.microsoft.com/vs/whatsnew/)</ept>, and in the <bpt id=\"p2\">[</bpt>.NET Core 2.0 SDK<ept id=\"p2\">](../../core/whats-new/index.md)</ept>.","source":"C# 7.2 is currently available in [Visual Studio 2017 version 15.5](https://visualstudio.microsoft.com/vs/whatsnew/), and in the [.NET Core 2.0 SDK](../../core/whats-new/index.md)."},{"pos":[2295,2319],"content":"<bpt id=\"p1\">[</bpt>C# 7.1<ept id=\"p1\">](csharp-7-1.md)</ept>:","source":"[C# 7.1](csharp-7-1.md):"},{"pos":[2324,2499],"content":"These features were added in <bpt id=\"p1\">[</bpt>Visual Studio 2017 version 15.3<ept id=\"p1\">](https://visualstudio.microsoft.com/vs/whatsnew/)</ept>, and in the <bpt id=\"p2\">[</bpt>.NET Core 2.0 SDK<ept id=\"p2\">](../../core/whats-new/index.md)</ept>.","source":"These features were added in [Visual Studio 2017 version 15.3](https://visualstudio.microsoft.com/vs/whatsnew/), and in the [.NET Core 2.0 SDK](../../core/whats-new/index.md)."},{"pos":[2504,2518],"content":"C# version 1.0","linkify":"C# version 1.0","nodes":[{"content":"C# version 1.0","pos":[0,14]}]},{"content":"When you go back and look, C# version 1.0 looked a lot like Java.","pos":[2520,2585]},{"content":"As <bpt id=\"p1\">[</bpt>part of its stated design goals for ECMA<ept id=\"p1\">](https://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html)</ept>, it sought to be a \"simple, modern, general-purpose object-oriented language.\"","pos":[2586,2775],"source":" As [part of its stated design goals for ECMA](https://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html), it sought to be a \"simple, modern, general-purpose object-oriented language.\""},{"content":"At the time, looking like Java meant it achieved those early design goals.","pos":[2777,2851]},{"content":"But if you look back on C# 1.0 now, you'd find yourself a little dizzy.","pos":[2853,2924]},{"content":"It lacked the built-in async capabilities and some of the slick functionality around generics you take for granted.","pos":[2925,3040]},{"content":"As a matter of fact, it lacked generics altogether.","pos":[3041,3092]},{"content":"And <bpt id=\"p1\">[</bpt>LINQ<ept id=\"p1\">](../linq/index.md)</ept>?","pos":[3094,3123],"source":"  And [LINQ](../linq/index.md)?"},{"content":"Not available yet.","pos":[3124,3142]},{"content":"Those additions would take some years to come out.","pos":[3143,3193]},{"content":"C# version 1.0 looked stripped of features, compared to today.","pos":[3195,3257]},{"content":"You'd find yourself writing some verbose code.","pos":[3258,3304]},{"content":"But yet, you have to start somewhere.","pos":[3305,3342]},{"content":"C# version 1.0 was a viable alternative to Java on the Windows platform.","pos":[3343,3415]},{"content":"The major features of C# 1.0 included:","pos":[3417,3455]},{"pos":[3459,3521],"content":"<bpt id=\"p1\">[</bpt>Classes<ept id=\"p1\">](../programming-guide/classes-and-structs/classes.md)</ept>","source":"[Classes](../programming-guide/classes-and-structs/classes.md)"},{"pos":[3524,3586],"content":"<bpt id=\"p1\">[</bpt>Structs<ept id=\"p1\">](../programming-guide/classes-and-structs/structs.md)</ept>","source":"[Structs](../programming-guide/classes-and-structs/structs.md)"},{"pos":[3589,3643],"content":"<bpt id=\"p1\">[</bpt>Interfaces<ept id=\"p1\">](../programming-guide/interfaces/index.md)</ept>","source":"[Interfaces](../programming-guide/interfaces/index.md)"},{"pos":[3646,3677],"content":"<bpt id=\"p1\">[</bpt>Events<ept id=\"p1\">](../events-overview.md)</ept>","source":"[Events](../events-overview.md)"},{"pos":[3680,3710],"content":"<bpt id=\"p1\">[</bpt>Properties<ept id=\"p1\">](../properties.md)</ept>","source":"[Properties](../properties.md)"},{"pos":[3713,3750],"content":"<bpt id=\"p1\">[</bpt>Delegates<ept id=\"p1\">](../delegates-overview.md)</ept>","source":"[Delegates](../delegates-overview.md)"},{"pos":[3753,3836],"content":"<bpt id=\"p1\">[</bpt>Expressions<ept id=\"p1\">](../programming-guide/statements-expressions-operators/expressions.md)</ept>","source":"[Expressions](../programming-guide/statements-expressions-operators/expressions.md)"},{"pos":[3839,3920],"content":"<bpt id=\"p1\">[</bpt>Statements<ept id=\"p1\">](../programming-guide/statements-expressions-operators/statements.md)</ept>","source":"[Statements](../programming-guide/statements-expressions-operators/statements.md)"},{"pos":[3923,3986],"content":"<bpt id=\"p1\">[</bpt>Attributes<ept id=\"p1\">](../programming-guide/concepts/attributes/index.md)</ept>","source":"[Attributes](../programming-guide/concepts/attributes/index.md)"},{"pos":[3989,4051],"content":"<bpt id=\"p1\">[</bpt>Literals<ept id=\"p1\">](../language-reference/keywords/literal-keywords.md)</ept>","source":"[Literals](../language-reference/keywords/literal-keywords.md)"},{"pos":[4056,4070],"content":"C# version 1.2","linkify":"C# version 1.2","nodes":[{"content":"C# version 1.2","pos":[0,14]}]},{"content":"C# version 1.2 shipped with Visual Studio 2003.","pos":[4072,4119]},{"content":"It contained a few small enhancements to the language.","pos":[4120,4174]},{"content":"Most notable is that starting with this version, the code generated in a <ph id=\"ph1\">`foreach`</ph> loop called <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on an <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerator&gt;</ph> when that <ph id=\"ph4\">&lt;xref:System.Collections.IEnumerator&gt;</ph> implemented <ph id=\"ph5\">&lt;xref:System.IDisposable&gt;</ph>.","pos":[4175,4437],"source":" Most notable is that starting with this version, the code generated in a `foreach` loop called <xref:System.IDisposable.Dispose%2A> on an <xref:System.Collections.IEnumerator> when that <xref:System.Collections.IEnumerator> implemented <xref:System.IDisposable>."},{"pos":[4442,4456],"content":"C# version 2.0","linkify":"C# version 2.0","nodes":[{"content":"C# version 2.0","pos":[0,14]}]},{"content":"Now things start to get interesting.","pos":[4458,4494]},{"content":"Let's take a look at some major features of C# 2.0, released in 2005, along with Visual Studio 2005:","pos":[4495,4595]},{"pos":[4599,4649],"content":"<bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](../programming-guide/generics/index.md)</ept>","source":"[Generics](../programming-guide/generics/index.md)"},{"pos":[4652,4756],"content":"<bpt id=\"p1\">[</bpt>Partial types<ept id=\"p1\">](../programming-guide/classes-and-structs/partial-classes-and-methods.md#partial-classes)</ept>","source":"[Partial types](../programming-guide/classes-and-structs/partial-classes-and-methods.md#partial-classes)"},{"pos":[4759,4854],"content":"<bpt id=\"p1\">[</bpt>Anonymous methods<ept id=\"p1\">](../programming-guide/statements-expressions-operators/anonymous-methods.md)</ept>","source":"[Anonymous methods](../programming-guide/statements-expressions-operators/anonymous-methods.md)"},{"pos":[4857,4919],"content":"<bpt id=\"p1\">[</bpt>Nullable types<ept id=\"p1\">](../programming-guide/nullable-types/index.md)</ept>","source":"[Nullable types](../programming-guide/nullable-types/index.md)"},{"pos":[4922,4977],"content":"<bpt id=\"p1\">[</bpt>Iterators<ept id=\"p1\">](../programming-guide/concepts/iterators.md)</ept>","source":"[Iterators](../programming-guide/concepts/iterators.md)"},{"pos":[4980,5077],"content":"<bpt id=\"p1\">[</bpt>Covariance and contravariance<ept id=\"p1\">](../programming-guide/concepts/covariance-contravariance/index.md)</ept>","source":"[Covariance and contravariance](../programming-guide/concepts/covariance-contravariance/index.md)"},{"content":"Other C# 2.0 features added capabilities to existing features:","pos":[5079,5141]},{"content":"Getter/setter separate accessibility","pos":[5145,5181]},{"content":"Method group conversions (delegates)","pos":[5184,5220]},{"content":"Static classes","pos":[5223,5237]},{"content":"Delegate inference","pos":[5240,5258]},{"content":"While C# may have started as a generic Object-Oriented (OO) language, C# version 2.0 changed that in a hurry.","pos":[5260,5369]},{"content":"Once they had their feet under them, they went after some serious developer pain points.","pos":[5370,5458]},{"content":"And they went after them in a significant way.","pos":[5459,5505]},{"content":"With generics, types and methods can operate on an arbitrary type while still retaining type safety.","pos":[5507,5607]},{"content":"For instance, having a <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> lets you have <ph id=\"ph2\">`List&lt;string&gt;`</ph> or <ph id=\"ph3\">`List&lt;int&gt;`</ph> and perform type-safe operations on those strings or integers while you iterate through them.","pos":[5608,5811],"source":" For instance, having a <xref:System.Collections.Generic.List%601> lets you have `List<string>` or `List<int>` and perform type-safe operations on those strings or integers while you iterate through them."},{"content":"Using generics is better than create <ph id=\"ph1\">`ListInt`</ph> that derives from <ph id=\"ph2\">`ArrayList`</ph>  or casting from <ph id=\"ph3\">`Object`</ph> for every operation.","pos":[5812,5935],"source":" Using generics is better than create `ListInt` that derives from `ArrayList`  or casting from `Object` for every operation."},{"content":"C# version 2.0 brought iterators.","pos":[5937,5970]},{"content":"To put it succinctly, iterators let you examine all the items in a <ph id=\"ph1\">`List`</ph> (or other Enumerable types) with a <ph id=\"ph2\">`foreach`</ph> loop.","pos":[5971,6095],"source":" To put it succinctly, iterators let you examine all the items in a `List` (or other Enumerable types) with a `foreach` loop."},{"content":"Having iterators as a first-class part of the language dramatically enhanced readability of the language and people's ability to reason about the code.","pos":[6096,6247]},{"content":"And yet, C# continued to play a bit of catch-up with Java.","pos":[6249,6307]},{"content":"Java had already released versions that included generics and iterators.","pos":[6308,6380]},{"content":"But that would soon change as the languages continued to evolve apart.","pos":[6381,6451]},{"pos":[6456,6470],"content":"C# version 3.0","linkify":"C# version 3.0","nodes":[{"content":"C# version 3.0","pos":[0,14]}]},{"content":"C# version 3.0 came in late 2007, along with Visual Studio 2008, though the full boat of language features would actually come with .NET Framework version 3.5.","pos":[6472,6631]},{"content":"This version marked a major change in the growth of C#.","pos":[6632,6687]},{"content":"It established C# as a truly formidable programming language.","pos":[6688,6749]},{"content":"Let's take a look at some major features in this version:","pos":[6750,6807]},{"pos":[6811,6913],"content":"<bpt id=\"p1\">[</bpt>Auto-implemented properties<ept id=\"p1\">](../programming-guide/classes-and-structs/auto-implemented-properties.md)</ept>","source":"[Auto-implemented properties](../programming-guide/classes-and-structs/auto-implemented-properties.md)"},{"pos":[6916,6994],"content":"<bpt id=\"p1\">[</bpt>Anonymous types<ept id=\"p1\">](../programming-guide/classes-and-structs/anonymous-types.md)</ept>","source":"[Anonymous types](../programming-guide/classes-and-structs/anonymous-types.md)"},{"pos":[6997,7052],"content":"<bpt id=\"p1\">[</bpt>Query expressions<ept id=\"p1\">](../linq/query-expression-basics.md)</ept>","source":"[Query expressions](../linq/query-expression-basics.md)"},{"pos":[7055,7152],"content":"<bpt id=\"p1\">[</bpt>Lambda expressions<ept id=\"p1\">](../programming-guide/statements-expressions-operators/lambda-expressions.md)</ept>","source":"[Lambda expressions](../programming-guide/statements-expressions-operators/lambda-expressions.md)"},{"pos":[7155,7197],"content":"<bpt id=\"p1\">[</bpt>Expression trees<ept id=\"p1\">](../expression-trees.md)</ept>","source":"[Expression trees](../expression-trees.md)"},{"pos":[7200,7282],"content":"<bpt id=\"p1\">[</bpt>Extension methods<ept id=\"p1\">](../programming-guide/classes-and-structs/extension-methods.md)</ept>","source":"[Extension methods](../programming-guide/classes-and-structs/extension-methods.md)"},{"pos":[7285,7358],"content":"<bpt id=\"p1\">[</bpt>Implicitly typed local variables<ept id=\"p1\">](../language-reference/keywords/var.md)</ept>","source":"[Implicitly typed local variables](../language-reference/keywords/var.md)"},{"pos":[7361,7428],"content":"<bpt id=\"p1\">[</bpt>Partial methods<ept id=\"p1\">](../language-reference/keywords/partial-method.md)</ept>","source":"[Partial methods](../language-reference/keywords/partial-method.md)"},{"pos":[7431,7547],"content":"<bpt id=\"p1\">[</bpt>Object and collection initializers<ept id=\"p1\">](../programming-guide/classes-and-structs/object-and-collection-initializers.md)</ept>","source":"[Object and collection initializers](../programming-guide/classes-and-structs/object-and-collection-initializers.md)"},{"content":"In retrospect, many of these features seem both inevitable and inseparable.","pos":[7549,7624]},{"content":"They all fit together strategically.","pos":[7625,7661]},{"content":"It's generally thought that C# version's killer feature was the query expression, also known as Language-Integrated Query (LINQ).","pos":[7662,7791]},{"content":"A more nuanced view examines expression trees, lambda expressions, and anonymous types as the foundation upon which LINQ is constructed.","pos":[7793,7929]},{"content":"But, in either case, C# 3.0 presented a revolutionary concept.","pos":[7930,7992]},{"content":"C# 3.0 had begun to lay the groundwork for turning C# into a hybrid Object-Oriented / Functional language.","pos":[7993,8099]},{"content":"Specifically, you could now write SQL-style, declarative queries to perform operations on collections, among other things.","pos":[8101,8223]},{"content":"Instead of writing a <ph id=\"ph1\">`for`</ph> loop to compute the average of a list of integers, you could now do that as simply as <ph id=\"ph2\">`list.Average()`</ph>.","pos":[8224,8354],"source":" Instead of writing a `for` loop to compute the average of a list of integers, you could now do that as simply as `list.Average()`."},{"content":"The combination of query expressions and extension methods made it look as though that list of integers had gotten a whole lot smarter.","pos":[8355,8490]},{"content":"It took time for people to really grasp and integrate the concept, but they gradually did.","pos":[8492,8582]},{"content":"And now, years later, code is much more concise, simple, and functional.","pos":[8583,8655]},{"pos":[8660,8674],"content":"C# version 4.0","linkify":"C# version 4.0","nodes":[{"content":"C# version 4.0","pos":[0,14]}]},{"content":"C# version 4.0 would have had a difficult time living up to the groundbreaking status of version 3.0.","pos":[8676,8777]},{"content":"With version 3.0, C# had moved the language firmly out from the shadow of Java and into prominence.","pos":[8778,8877]},{"content":"The language was quickly becoming elegant.","pos":[8878,8920]},{"content":"The next version did introduce some interesting new features:","pos":[8922,8983]},{"pos":[8987,9047],"content":"<bpt id=\"p1\">[</bpt>Dynamic binding<ept id=\"p1\">](../language-reference/keywords/dynamic.md)</ept>","source":"[Dynamic binding](../language-reference/keywords/dynamic.md)"},{"pos":[9050,9150],"content":"<bpt id=\"p1\">[</bpt>Named/optional arguments<ept id=\"p1\">](../programming-guide/classes-and-structs/named-and-optional-arguments.md)</ept>","source":"[Named/optional arguments](../programming-guide/classes-and-structs/named-and-optional-arguments.md)"},{"pos":[9153,9248],"content":"<bpt id=\"p1\">[</bpt>Generic covariant and contravariant<ept id=\"p1\">](../../standard/generics/covariance-and-contravariance.md)</ept>","source":"[Generic covariant and contravariant](../../standard/generics/covariance-and-contravariance.md)"},{"pos":[9251,9347],"content":"<bpt id=\"p1\">[</bpt>Embedded interop types<ept id=\"p1\">](../../framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>","source":"[Embedded interop types](../../framework/interop/type-equivalence-and-embedded-interop-types.md)"},{"content":"Embedded interop types alleviated a deployment pain.","pos":[9349,9401]},{"content":"Generic covariance and contravariance give you more power to use generics, but they're a bit academic and probably most appreciated by framework and library authors.","pos":[9402,9567]},{"content":"Named and optional parameters let you eliminate many method overloads and provide convenience.","pos":[9568,9662]},{"content":"But none of those features are exactly paradigm altering.","pos":[9663,9720]},{"content":"The major feature was the introduction of the <ph id=\"ph1\">`dynamic`</ph> keyword.","pos":[9722,9786],"source":"The major feature was the introduction of the `dynamic` keyword."},{"content":"The <ph id=\"ph1\">`dynamic`</ph> keyword introduced into C# version 4.0 the ability to override the compiler on compile-time typing.","pos":[9787,9900],"source":" The `dynamic` keyword introduced into C# version 4.0 the ability to override the compiler on compile-time typing."},{"content":"By using the dynamic keyword, you can create constructs similar to dynamically typed languages like JavaScript.","pos":[9901,10012]},{"content":"You can create a <ph id=\"ph1\">`dynamic x = \"a string\"`</ph> and then add six to it, leaving it up to the runtime to sort out what should happen next.","pos":[10013,10144],"source":" You can create a `dynamic x = \"a string\"` and then add six to it, leaving it up to the runtime to sort out what should happen next."},{"content":"Dynamic binding gives you the potential for errors but also great power within the language.","pos":[10146,10238]},{"pos":[10243,10257],"content":"C# version 5.0","linkify":"C# version 5.0","nodes":[{"content":"C# version 5.0","pos":[0,14]}]},{"content":"C# version 5.0 was a focused version of the language.","pos":[10259,10312]},{"content":"Nearly all of the effort for that version went into another groundbreaking language concept: the <ph id=\"ph1\">`async`</ph> and <ph id=\"ph2\">`await`</ph> model for asynchronous programming.","pos":[10313,10465],"source":" Nearly all of the effort for that version went into another groundbreaking language concept: the `async` and `await` model for asynchronous programming."},{"content":"Here is the major features list:","pos":[10467,10499]},{"pos":[10503,10538],"content":"<bpt id=\"p1\">[</bpt>Asynchronous members<ept id=\"p1\">](../async.md)</ept>","source":"[Asynchronous members](../async.md)"},{"pos":[10541,10618],"content":"<bpt id=\"p1\">[</bpt>Caller info attributes<ept id=\"p1\">](../programming-guide/concepts/caller-information.md)</ept>","source":"[Caller info attributes](../programming-guide/concepts/caller-information.md)"},{"pos":[10624,10632],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[10636,10758],"content":"<bpt id=\"p1\">[</bpt>Code Project: Caller Info Attributes in C# 5.0<ept id=\"p1\">](https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp)</ept>","source":"[Code Project: Caller Info Attributes in C# 5.0](https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp)"},{"content":"The caller info attribute lets you easily retrieve information about the context in which you're running without resorting to a ton of boilerplate reflection code.","pos":[10760,10923]},{"content":"It has many uses in diagnostics and logging tasks.","pos":[10924,10974]},{"content":"But <ph id=\"ph1\">`async`</ph> and <ph id=\"ph2\">`await`</ph> are the real stars of this release.","pos":[10976,11035],"source":"But `async` and `await` are the real stars of this release."},{"content":"When these features came out in 2012, C# changed the game again by baking asynchrony into the language as a first-class participant.","pos":[11036,11168]},{"content":"If you've ever dealt with long running operations and the implementation of webs of callbacks, you probably loved this language feature.","pos":[11169,11305]},{"pos":[11310,11324],"content":"C# version 6.0","linkify":"C# version 6.0","nodes":[{"content":"C# version 6.0","pos":[0,14]}]},{"content":"With versions 3.0 and 5.0, C# had added major new features in an object-oriented language.","pos":[11326,11416]},{"content":"With version 6.0, it would go away from doing a dominant killer feature and instead release many smaller features that made C# programming more productive.","pos":[11417,11572]},{"content":"Here are some of them:","pos":[11573,11595]},{"pos":[11599,11643],"content":"<bpt id=\"p1\">[</bpt>Static imports<ept id=\"p1\">](./csharp-6.md#using-static)</ept>","source":"[Static imports](./csharp-6.md#using-static)"},{"pos":[11646,11698],"content":"<bpt id=\"p1\">[</bpt>Exception filters<ept id=\"p1\">](./csharp-6.md#exception-filters)</ept>","source":"[Exception filters](./csharp-6.md#exception-filters)"},{"pos":[11701,11771],"content":"<bpt id=\"p1\">[</bpt>Auto-property initializers<ept id=\"p1\">](./csharp-6.md#auto-property-initializers)</ept>","source":"[Auto-property initializers](./csharp-6.md#auto-property-initializers)"},{"pos":[11774,11851],"content":"<bpt id=\"p1\">[</bpt>Expression bodied members<ept id=\"p1\">](./csharp-6.md#expression-bodied-function-members)</ept>","source":"[Expression bodied members](./csharp-6.md#expression-bodied-function-members)"},{"pos":[11854,11913],"content":"<bpt id=\"p1\">[</bpt>Null propagator<ept id=\"p1\">](./csharp-6.md#null-conditional-operators)</ept>","source":"[Null propagator](./csharp-6.md#null-conditional-operators)"},{"pos":[11916,11974],"content":"<bpt id=\"p1\">[</bpt>String interpolation<ept id=\"p1\">](./csharp-6.md#string-interpolation)</ept>","source":"[String interpolation](./csharp-6.md#string-interpolation)"},{"pos":[11977,12031],"content":"<bpt id=\"p1\">[</bpt>nameof operator<ept id=\"p1\">](./csharp-6.md#the-nameof-expression)</ept>","source":"[nameof operator](./csharp-6.md#the-nameof-expression)"},{"pos":[12034,12116],"content":"<bpt id=\"p1\">[</bpt>Index initializers<ept id=\"p1\">](csharp-6.md#extension-add-methods-in-collection-initializers)</ept>","source":"[Index initializers](csharp-6.md#extension-add-methods-in-collection-initializers)"},{"content":"Other new features include:","pos":[12118,12145]},{"content":"Await in catch/finally blocks","pos":[12149,12178]},{"content":"Default values for getter-only properties","pos":[12181,12222]},{"content":"Each of these features is interesting in its own right.","pos":[12224,12279]},{"content":"But if you look at them altogether, you see an interesting pattern.","pos":[12280,12347]},{"content":"In this version, C# eliminated language boilerplate to make code more terse and readable.","pos":[12348,12437]},{"content":"So for fans of clean, simple code, this language version was a huge win.","pos":[12438,12510]},{"content":"They did one other thing along with this version, though it's not a traditional language feature in itself.","pos":[12512,12619]},{"content":"They released <bpt id=\"p1\">[</bpt>Roslyn the compiler as a service<ept id=\"p1\">](https://github.com/dotnet/roslyn)</ept>.","pos":[12620,12703],"source":" They released [Roslyn the compiler as a service](https://github.com/dotnet/roslyn)."},{"content":"The C# compiler is now written in C#, and you can use the compiler as part of your programming efforts.","pos":[12704,12807]},{"pos":[12812,12826],"content":"C# version 7.0","linkify":"C# version 7.0","nodes":[{"content":"C# version 7.0","pos":[0,14]}]},{"content":"The most recent major version is C# version 7.0.","pos":[12828,12876]},{"content":"This version has some evolutionary and cool stuff in the vein of C# 6.0, but without the compiler as a service.","pos":[12877,12988]},{"content":"Here are some of the new features:","pos":[12989,13023]},{"pos":[13027,13071],"content":"<bpt id=\"p1\">[</bpt>Out variables<ept id=\"p1\">](./csharp-7.md#out-variables)</ept>","source":"[Out variables](./csharp-7.md#out-variables)"},{"pos":[13074,13123],"content":"<bpt id=\"p1\">[</bpt>Tuples and deconstruction<ept id=\"p1\">](./csharp-7.md#tuples)</ept>","source":"[Tuples and deconstruction](./csharp-7.md#tuples)"},{"pos":[13126,13176],"content":"<bpt id=\"p1\">[</bpt>Pattern matching<ept id=\"p1\">](./csharp-7.md#pattern-matching)</ept>","source":"[Pattern matching](./csharp-7.md#pattern-matching)"},{"pos":[13179,13227],"content":"<bpt id=\"p1\">[</bpt>Local functions<ept id=\"p1\">](./csharp-7.md#local-functions)</ept>","source":"[Local functions](./csharp-7.md#local-functions)"},{"pos":[13230,13312],"content":"<bpt id=\"p1\">[</bpt>Expanded expression bodied members<ept id=\"p1\">](./csharp-7.md#more-expression-bodied-members)</ept>","source":"[Expanded expression bodied members](./csharp-7.md#more-expression-bodied-members)"},{"pos":[13315,13377],"content":"<bpt id=\"p1\">[</bpt>Ref locals and returns<ept id=\"p1\">](./csharp-7.md#ref-locals-and-returns)</ept>","source":"[Ref locals and returns](./csharp-7.md#ref-locals-and-returns)"},{"content":"Other features included:","pos":[13379,13403]},{"pos":[13407,13441],"content":"<bpt id=\"p1\">[</bpt>Discards<ept id=\"p1\">](./csharp-7.md#discards)</ept>","source":"[Discards](./csharp-7.md#discards)"},{"pos":[13444,13533],"content":"<bpt id=\"p1\">[</bpt>Binary Literals and Digit Separators<ept id=\"p1\">](./csharp-7.md#numeric-literal-syntax-improvements)</ept>","source":"[Binary Literals and Digit Separators](./csharp-7.md#numeric-literal-syntax-improvements)"},{"pos":[13536,13588],"content":"<bpt id=\"p1\">[</bpt>Throw expressions<ept id=\"p1\">](./csharp-7.md#throw-expressions)</ept>","source":"[Throw expressions](./csharp-7.md#throw-expressions)"},{"content":"All of these features offer cool new capabilities for developers and the opportunity to write even cleaner code than ever.","pos":[13590,13712]},{"content":"A highlight is condensing the declaration of variables to use with the <ph id=\"ph1\">`out`</ph> keyword and by allowing multiple return values via tuple.","pos":[13713,13847],"source":" A highlight is condensing the declaration of variables to use with the `out` keyword and by allowing multiple return values via tuple."},{"content":"But C# is being put to ever broader use.","pos":[13849,13889]},{"content":".NET Core now targets any operating system and has its eyes firmly on the cloud and on portability.","pos":[13890,13989]},{"content":"These new capabilities certainly occupy the language designers' thoughts and time, in addition to coming up with new features.","pos":[13991,14117]},{"pos":[14119,14284],"content":"<bpt id=\"p1\">_</bpt>Article<ept id=\"p1\">_</ept> <bpt id=\"p2\">[</bpt><bpt id=\"p3\">_</bpt>originally published on the NDepend blog<ept id=\"p3\">_</ept><ept id=\"p2\">](https://blog.ndepend.com/c-versions-look-language-history/)</ept><bpt id=\"p4\">_</bpt>, courtesy of Erik Dietrich and Patrick Smacchia.<ept id=\"p4\">_</ept>","source":"_Article_ [_originally published on the NDepend blog_](https://blog.ndepend.com/c-versions-look-language-history/)_, courtesy of Erik Dietrich and Patrick Smacchia._"}]}