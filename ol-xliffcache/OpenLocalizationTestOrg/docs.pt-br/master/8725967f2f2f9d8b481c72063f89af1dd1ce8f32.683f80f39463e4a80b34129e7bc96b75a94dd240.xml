{"content":"---\ntitle: \"Threading Model | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"text on buttons, updating\"\n  - \"message processing, nested\"\n  - \"blocking operations\"\n  - \"Dispatcher class\"\n  - \"Common Language Runtime (CLR), locking mechanism\"\n  - \"locking mechanism of Common Language Runtime (CLR)\"\n  - \"threading model\"\n  - \"classes, DependencyObject\"\n  - \"Word, spelling checking\"\n  - \"button text, updating\"\n  - \"spelling checking in Word\"\n  - \"asynchronous behavior, exposing\"\n  - \"DependencyObject class\"\n  - \"nested message processing\"\n  - \"classes, Dispatcher\"\n  - \"reentrancy\"\nms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b\ncaps.latest.revision: 33\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Threading Model\n[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] is designed to save developers from the difficulties of threading. As a result, the majority of              [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread. Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.  \n  \n No matter how well architected, however, no              [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.              [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] comes close, but there are still situations where multiple threads improve              [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance. After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.  \n  \n\n  \n> [!NOTE]\n>  This topic discusses threading by using the                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls. You can also make asynchronous calls by calling the                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter.  The                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, which has a                  <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property. You can use the                  `await` keyword with either the                  <xref:System.Windows.Threading.DispatcherOperation> or the associated                  <xref:System.Threading.Tasks.Task>. If you need to wait synchronously for the                  <xref:System.Threading.Tasks.Task> that is returned by a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, call the                  <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.  Calling                  <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> will result in a deadlock. For more information about using a                  <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.  The                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter.  You can use the                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate,                  <xref:System.Action> or                  <xref:System.Func%601>.  \n  \n<a name=\"threading_overview\"></a>   \n## Overview and the Dispatcher  \n Typically,                  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]. The rendering thread effectively runs hidden in the background while the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code. Most applications use a single                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several. We’ll discuss this with an example later.  \n  \n The                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a                  <xref:System.Windows.Threading.Dispatcher>. The                  <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.  Every                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one                  <xref:System.Windows.Threading.Dispatcher>, and each                  <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.  \n  \n The trick to building responsive, user-friendly applications is to maximize the                  <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small. This way items never get stale sitting in the                  <xref:System.Windows.Threading.Dispatcher> queue waiting for processing. Any perceivable delay between input and response can frustrate a user.  \n  \n How then are                  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations? What if your code involves a large calculation or needs to query a database on some remote server? Usually, the answer is to handle the big operation in a separate thread, leaving the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the                  <xref:System.Windows.Threading.Dispatcher> queue. When the big operation is complete, it can report its result back to the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.  \n  \n Historically,                  [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them. This means that a background thread in charge of some long-running task cannot update a text box when it is finished.                  [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] does this to ensure the integrity of                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components. A list box could look strange if its contents were updated by a background thread during painting.  \n  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a built-in mutual exclusion mechanism that enforces this coordination. Most classes in                  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from                  <xref:System.Windows.Threading.DispatcherObject>. At construction, a                  <xref:System.Windows.Threading.DispatcherObject> stores a reference to the                  <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread. In effect, the                  <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it. During program execution, a                  <xref:System.Windows.Threading.DispatcherObject> can call its public                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the                  <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the                  <xref:System.Windows.Threading.Dispatcher> reference stored during construction. If they don’t match,                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a                  <xref:System.Windows.Threading.DispatcherObject>.  \n  \n If only one thread can modify the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user? A background thread can ask the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf. It does this by registering a work item with the                  <xref:System.Windows.Threading.Dispatcher> of the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. The                  <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items:                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. Both methods schedule a delegate for execution.                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.  \n  \n The                  <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority. There are ten levels that may be specified when adding an element to the                  <xref:System.Windows.Threading.Dispatcher> queue. These priorities are maintained in the                  <xref:System.Windows.Threading.DispatcherPriority> enumeration. Detailed information about                  <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the                  [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.  \n  \n<a name=\"samples\"></a>   \n## Threads in Action: The Samples  \n  \n<a name=\"prime_number\"></a>   \n### A Single-Threaded Application with a Long-Running Calculation  \n Most                          [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions. With careful programming this idle time can be used constructively, without affecting the responsiveness of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]. The                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. This means you must be sure to return to the                          <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.  \n  \n Consider the following example:  \n  \n ![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG \"ThreadingPrimeNumberScreenShot\")  \n  \n This simple application counts upwards from three, searching for prime numbers. When the user clicks the                          **Start** button, the search begins. When the program finds a prime, it updates the user interface with its discovery. At any point, the user can stop the search.  \n  \n Although simple enough, the prime number search could go on forever, which presents some difficulties.  If we handled the entire search inside of the click event handler of the button, we would never give the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events. The                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages. It would never repaint and never respond to button clicks.  \n  \n We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues. With a single-threaded approach, we can directly update the label that lists the largest prime found.  \n  \n If we break up the task of calculation into manageable chunks, we can periodically return to the                          <xref:System.Windows.Threading.Dispatcher> and process events. We can give                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.  \n  \n The best way to split processing time between calculation and event handling is to manage calculation from the                          <xref:System.Windows.Threading.Dispatcher>. By using the                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from. In our example, we schedule only a single prime number check at a time. After the prime number check is complete, we schedule the next check immediately. This check proceeds only after pending                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.  \n  \n ![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG \"ThreadingDispatcherQueue\")  \n  \n [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)] accomplishes spell checking using this mechanism. Spell checking is done in the background using the idle time of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. Let's take a look at the code.  \n  \n The following example shows the XAML that creates the user interface.  \n  \n [!code-xml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  \n  \n The following example shows the code-behind.  \n  \n [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]\n [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  \n  \n The following example shows the event handler for the                          <xref:System.Windows.Controls.Button>.  \n  \n [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]\n [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  \n  \n Besides updating the text on the                          <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the                          <xref:System.Windows.Threading.Dispatcher> queue. Sometime after this event handler has completed its work, the                          <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.  \n  \n As we mentioned earlier,                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the                          <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution. In this case, we choose the                          <xref:System.Windows.Threading.DispatcherPriority> priority. The                          <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking. We also pass a new delegate representing the number-checking routine.  \n  \n [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]\n [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  \n  \n This method checks if the next odd number is prime. If it is prime, the method directly updates the                          `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery. We can do this because the calculation is occurring in the same thread that was used to create the component. Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. We’ll demonstrate this situation next.  \n  \n For the complete source code for this sample, see the                          [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)  \n  \n<a name=\"weather_sim\"></a>   \n### Handling a Blocking Operation with a Background Thread  \n Handling blocking operations in a graphical application can be difficult. We don’t want to call blocking methods from event handlers because the application will appear to freeze up. We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the                          [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread. We can use                          <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the                          <xref:System.Windows.Threading.Dispatcher> of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. Eventually, these delegates will be executed with permission to modify                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.  \n  \n In this example, we mimic a remote procedure call that retrieves a weather forecast. We use a separate worker thread to execute this call, and we schedule an update method in the                          <xref:System.Windows.Threading.Dispatcher> of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.  \n  \n ![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG \"ThreadingWeatherUIScreenShot\")  \n  \n [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]\n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  \n  \n The following are some of the details to be noted.  \n  \n-   Creating the Button Handler  \n  \n     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]\n     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  \n  \n When the button is clicked, we display the clock drawing and start animating it. We disable the button. We invoke the                          `FetchWeatherFromServer` method in a new thread, and then we return, allowing the                          <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.  \n  \n-   Fetching the Weather  \n  \n     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]\n     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  \n  \n To keep things simple, we don’t actually have any networking code in this example. Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds. In this time, the original                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events. To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.  \n  \n When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. We do this by scheduling a call to                          `UpdateUserInterface` in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s                          <xref:System.Windows.Threading.Dispatcher>. We pass a string describing the weather to this scheduled method call.  \n  \n-   Updating the                                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]  \n  \n     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]\n     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  \n  \n When the                          <xref:System.Windows.Threading.Dispatcher> in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to                          `UpdateUserInterface`. This method stops the clock animation and chooses an image to describe the weather. It displays this image and restores the \"fetch forecast\" button.  \n  \n<a name=\"multi_browser\"></a>   \n### Multiple Windows, Multiple Threads  \n Some                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows. It is perfectly acceptable for one Thread/                         <xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job. This is especially true if there is any chance that one of the windows will monopolize the thread.  \n  \n [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] Explorer works in this fashion. Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.  \n  \n By using a                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages. We can easily create a simple                          [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute. We start with an important feature: the ability to open a new explorer window. When the user clicks the \"new window\" button, we launch a copy of our window in a separate thread. This way, long-running or blocking operations in one of the windows won’t lock all the other windows.  \n  \n In reality, the Web browser model has its own complicated threading model. We’ve chosen it because it should be familiar to most readers.  \n  \n The following example shows the code.  \n  \n [!code-xml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  \n  \n [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]\n [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  \n  \n The following threading segments of this code are the most interesting to us in this context:  \n  \n [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]\n [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  \n  \n This method is called when the \"new window\" button is clicked. It creates a new thread and starts it asynchronously.  \n  \n [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]\n [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  \n  \n This method is the starting point for the new thread. We create a new window under the control of this thread.                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] automatically creates a new                          <xref:System.Windows.Threading.Dispatcher> to manage the new thread. All we have to do to make the window functional is to start the                          <xref:System.Windows.Threading.Dispatcher>.  \n  \n<a name=\"stumbling_points\"></a>   \n## Technical Details and Stumbling Points  \n  \n### Writing Components Using Threading  \n The                          [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see                          [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)). For instance, suppose we wanted to package the                          `FetchWeatherFromServer` method into a reusable, nongraphical component. Following the standard                          [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following.  \n  \n [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]\n [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  \n  \n `GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.  \n  \n One of the most important parts of this pattern is calling the                          *MethodName*`Completed` method on the same thread that called the                          *MethodName*`Async` method to begin with. You could do this using                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing                          <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in                          [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or                          [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.  \n  \n The                          <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of                          <xref:System.Windows.Threading.Dispatcher> that works with other                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.  \n  \n [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]\n [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  \n  \n### Nested Pumping  \n Sometimes it is not feasible to completely lock up the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. Let’s consider the                          <xref:System.Windows.MessageBox.Show%2A> method of the                          <xref:System.Windows.MessageBox> class.                          <xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button. It does, however, create a window that must have a message loop in order to be interactive. While we are waiting for the user to click OK, the original application window does not respond to user input. It does, however, continue to process paint messages. The original window redraws itself when covered and revealed.  \n  \n ![MessageBox with an \"OK\" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png \"ThreadingNestedPumping\")  \n  \n Some thread must be in charge of the message box window.                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion). Instead,                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system. The                          <xref:System.Windows.Threading.Dispatcher> class includes a special method called                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop. When the nested message loop finishes, execution resumes after the original                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.  \n  \n In this case,                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to                          <xref:System.Windows.MessageBox>.                         <xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window. When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to                          <xref:System.Windows.MessageBox.Show%2A>.  \n  \n### Stale Routed Events  \n The routed event system in                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.  \n  \n [!code-xml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  \n  \n When the left mouse button is pressed over the ellipse,                          `handler2` is executed. After                          `handler2` finishes, the event is passed along to the                          <xref:System.Windows.Controls.Canvas> object, which uses                          `handler1` to process it. This happens only if                          `handler2` does not explicitly mark the event object as handled.  \n  \n It’s possible that                          `handler2` will take a great deal of time processing this event.                          `handler2` might use                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours. If                          `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.  \n  \n### Reentrancy and Locking  \n The locking mechanism of the                          [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock. In actuality, the thread continues to receive and process high-priority messages. This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.  The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving                          [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.  \n  \n Most interfaces are not built with thread safety in mind because developers work under the assumption that a                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread. In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the                          <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve. Consider the following pseudocode:  \n  \n ![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png \"ThreadingReentrancy\")  \n  \n Most of the time that’s the right thing, but there are times in                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems. So, at certain key times,                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls                          <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.  \n  \n So why did the                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior? It had to do with COM STA objects and the finalization thread. When an object is garbage collected, its                          `Finalize` method is run on the dedicated finalizer thread, not the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. And therein lies the problem, because a COM STA object that was created on the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread. The                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s                          `SendMessage`). But if the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak. So the                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.  \n  \n The task for                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.  \n  \n## See Also  \n [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)","nodes":[{"pos":[4,879],"embed":true,"restype":"x-metadata","content":"title: \"Threading Model | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"text on buttons, updating\"\n  - \"message processing, nested\"\n  - \"blocking operations\"\n  - \"Dispatcher class\"\n  - \"Common Language Runtime (CLR), locking mechanism\"\n  - \"locking mechanism of Common Language Runtime (CLR)\"\n  - \"threading model\"\n  - \"classes, DependencyObject\"\n  - \"Word, spelling checking\"\n  - \"button text, updating\"\n  - \"spelling checking in Word\"\n  - \"asynchronous behavior, exposing\"\n  - \"DependencyObject class\"\n  - \"nested message processing\"\n  - \"classes, Dispatcher\"\n  - \"reentrancy\"\nms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b\ncaps.latest.revision: 33\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","nodes":[{"content":"Threading Model | Microsoft Docs","nodes":[{"pos":[0,32],"content":"Threading Model | Microsoft Docs","nodes":[{"content":"Threading Model | Microsoft Docs","pos":[0,32]}]}],"path":["title"]}],"yml":true},{"pos":[886,901],"content":"Threading Model","linkify":"Threading Model","nodes":[{"content":"Threading Model","pos":[0,15]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> is designed to save developers from the difficulties of threading.","pos":[902,1048],"source":"[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] is designed to save developers from the difficulties of threading."},{"content":"As a result, the majority of              <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> developers won't have to write an interface that uses more than one thread.","pos":[1049,1248],"source":" As a result, the majority of              [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread."},{"content":"Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.","pos":[1249,1376]},{"content":"No matter how well architected, however, no              <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> framework will ever be able to provide a single-threaded solution for every sort of problem.","pos":[1383,1600],"source":"No matter how well architected, however, no              [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> comes close, but there are still situations where multiple threads improve              <ph id=\"ph2\">[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]</ph> responsiveness or application performance.","pos":[1614,1892],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] comes close, but there are still situations where multiple threads improve              [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance."},{"content":"After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.","pos":[1893,2046]},{"pos":[2058,4096],"content":"[!NOTE]\n This topic discusses threading by using the                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls. You can also make asynchronous calls by calling the                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter.  The                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, which has a                  <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property. You can use the                  `await` keyword with either the                  <xref:System.Windows.Threading.DispatcherOperation> or the associated                  <xref:System.Threading.Tasks.Task>. If you need to wait synchronously for the                  <xref:System.Threading.Tasks.Task> that is returned by a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, call the                  <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.  Calling                  <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> will result in a deadlock. For more information about using a                  <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.  The                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter.  You can use the                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate,                  <xref:System.Action> or                  <xref:System.Func%601>.","leadings":["","> "],"nodes":[{"content":"This topic discusses threading by using the                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls. You can also make asynchronous calls by calling the                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter.  The                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, which has a                  <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property. You can use the                  `await` keyword with either the                  <xref:System.Windows.Threading.DispatcherOperation> or the associated                  <xref:System.Threading.Tasks.Task>. If you need to wait synchronously for the                  <xref:System.Threading.Tasks.Task> that is returned by a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, call the                  <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.  Calling                  <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> will result in a deadlock. For more information about using a                  <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.  The                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter.  You can use the                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate,                  <xref:System.Action> or                  <xref:System.Func%601>.","pos":[9,2036],"nodes":[{"content":"This topic discusses threading by using the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph> method for asynchronous calls.","pos":[0,149],"source":"This topic discusses threading by using the                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls."},{"content":"You can also make asynchronous calls by calling the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A&gt;</ph> method, which take an                  <ph id=\"ph2\">&lt;xref:System.Action&gt;</ph> or                  <ph id=\"ph3\">&lt;xref:System.Func%601&gt;</ph> as a parameter.","pos":[150,395],"source":" You can also make asynchronous calls by calling the                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter."},{"content":"The                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A&gt;</ph> method returns a                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherOperation&gt;</ph> or                  <ph id=\"ph3\">&lt;xref:System.Windows.Threading.DispatcherOperation%601&gt;</ph>, which has a                  <ph id=\"ph4\">&lt;xref:System.Windows.Threading.DispatcherOperation.Task%2A&gt;</ph> property.","pos":[397,737],"source":"  The                  <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, which has a                  <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property."},{"content":"You can use the                  <ph id=\"ph1\">`await`</ph> keyword with either the                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherOperation&gt;</ph> or the associated                  <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.Task&gt;</ph>.","pos":[738,942],"source":" You can use the                  `await` keyword with either the                  <xref:System.Windows.Threading.DispatcherOperation> or the associated                  <xref:System.Threading.Tasks.Task>."},{"content":"If you need to wait synchronously for the                  <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> that is returned by a                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherOperation&gt;</ph> or                  <ph id=\"ph3\">&lt;xref:System.Windows.Threading.DispatcherOperation%601&gt;</ph>, call the                  <ph id=\"ph4\">&lt;xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A&gt;</ph> extension method.","pos":[943,1322],"source":" If you need to wait synchronously for the                  <xref:System.Threading.Tasks.Task> that is returned by a                  <xref:System.Windows.Threading.DispatcherOperation> or                  <xref:System.Windows.Threading.DispatcherOperation%601>, call the                  <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method."},{"content":"Calling                  <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> will result in a deadlock.","pos":[1324,1443],"source":"  Calling                  <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> will result in a deadlock."},{"content":"For more information about using a                  <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> to perform asynchronous operations, see Task Parallelism.","pos":[1444,1588],"source":" For more information about using a                  <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism."},{"content":"The                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A&gt;</ph> method also has overloads that take an                  <ph id=\"ph2\">&lt;xref:System.Action&gt;</ph> or                  <ph id=\"ph3\">&lt;xref:System.Func%601&gt;</ph> as a parameter.","pos":[1590,1799],"source":"  The                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an                  <xref:System.Action> or                  <xref:System.Func%601> as a parameter."},{"content":"You can use the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A&gt;</ph> method to make synchronous calls by passing in a delegate,                  <ph id=\"ph2\">&lt;xref:System.Action&gt;</ph> or                  <ph id=\"ph3\">&lt;xref:System.Func%601&gt;</ph>.","pos":[1801,2027],"source":"  You can use the                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate,                  <xref:System.Action> or                  <xref:System.Func%601>."}]}]},{"pos":[4142,4169],"content":"Overview and the Dispatcher","linkify":"Overview and the Dispatcher","nodes":[{"content":"Overview and the Dispatcher","pos":[0,27]}]},{"content":"Typically,                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications start with two threads: one for handling rendering and another for managing the                  <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph>.","pos":[4173,4461],"source":"Typically,                  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]."},{"content":"The rendering thread effectively runs hidden in the background while the                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread receives input, handles events, paints the screen, and runs application code.","pos":[4462,4704],"source":" The rendering thread effectively runs hidden in the background while the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code."},{"content":"Most applications use a single                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread, although in some situations it is best to use several.","pos":[4705,4883],"source":" Most applications use a single                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several."},{"content":"We’ll discuss this with an example later.","pos":[4884,4925]},{"content":"The                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread queues work items inside an object called a                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>.","pos":[4932,5132],"source":"The                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a                  <xref:System.Windows.Threading.Dispatcher>."},{"content":"The                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> selects work items on a priority basis and runs each one to completion.","pos":[5133,5268],"source":" The                  <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion."},{"content":"Every                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread must have at least one                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>, and each                  <ph id=\"ph3\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> can execute work items in exactly one thread.","pos":[5270,5566],"source":"  Every                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one                  <xref:System.Windows.Threading.Dispatcher>, and each                  <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread."},{"content":"The trick to building responsive, user-friendly applications is to maximize the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> throughput by keeping the work items small.","pos":[5573,5756],"source":"The trick to building responsive, user-friendly applications is to maximize the                  <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small."},{"content":"This way items never get stale sitting in the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> queue waiting for processing.","pos":[5757,5892],"source":" This way items never get stale sitting in the                  <xref:System.Windows.Threading.Dispatcher> queue waiting for processing."},{"content":"Any perceivable delay between input and response can frustrate a user.","pos":[5893,5963]},{"content":"How then are                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications supposed to handle big operations?","pos":[5970,6129],"source":"How then are                  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?"},{"content":"What if your code involves a large calculation or needs to query a database on some remote server?","pos":[6130,6228]},{"content":"Usually, the answer is to handle the big operation in a separate thread, leaving the                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread free to tend to items in the                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> queue.","pos":[6229,6501],"source":" Usually, the answer is to handle the big operation in a separate thread, leaving the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the                  <xref:System.Windows.Threading.Dispatcher> queue."},{"content":"When the big operation is complete, it can report its result back to the                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread for display.","pos":[6502,6679],"source":" When the big operation is complete, it can report its result back to the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display."},{"content":"Historically,                  <ph id=\"ph1\">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]</ph> allows                  <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> elements to be accessed only by the thread that created them.","pos":[6686,6942],"source":"Historically,                  [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them."},{"content":"This means that a background thread in charge of some long-running task cannot update a text box when it is finished.","pos":[6943,7060]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]</ph> does this to ensure the integrity of                  <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> components.","pos":[7078,7283],"source":"[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] does this to ensure the integrity of                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components."},{"content":"A list box could look strange if its contents were updated by a background thread during painting.","pos":[7284,7382]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> has a built-in mutual exclusion mechanism that enforces this coordination.","pos":[7389,7545],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a built-in mutual exclusion mechanism that enforces this coordination."},{"content":"Most classes in                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> derive from                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph>.","pos":[7546,7739],"source":" Most classes in                  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from                  <xref:System.Windows.Threading.DispatcherObject>."},{"content":"At construction, a                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph> stores a reference to the                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> linked to the currently running thread.","pos":[7740,7950],"source":" At construction, a                  <xref:System.Windows.Threading.DispatcherObject> stores a reference to the                  <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread."},{"content":"In effect, the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph> associates with the thread that creates it.","pos":[7951,8075],"source":" In effect, the                  <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it."},{"content":"During program execution, a                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph> can call its public                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A&gt;</ph> method.","pos":[8076,8279],"source":" During program execution, a                  <xref:System.Windows.Threading.DispatcherObject> can call its public                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A&gt;</ph> examines the                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> associated with the current thread and compares it to the                  <ph id=\"ph3\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> reference stored during construction.","pos":[8297,8590],"source":"                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the                  <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the                  <xref:System.Windows.Threading.Dispatcher> reference stored during construction."},{"content":"If they don’t match,                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A&gt;</ph> throws an exception.","pos":[8591,8714],"source":" If they don’t match,                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A&gt;</ph> is intended to be called at the beginning of every method belonging to a                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph>.","pos":[8732,8936],"source":"                  <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a                  <xref:System.Windows.Threading.DispatcherObject>."},{"content":"If only one thread can modify the                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph>, how do background threads interact with the user?","pos":[8943,9112],"source":"If only one thread can modify the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?"},{"content":"A background thread can ask the                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread to perform an operation on its behalf.","pos":[9113,9275],"source":" A background thread can ask the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf."},{"content":"It does this by registering a work item with the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> of the                  <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[9276,9484],"source":" It does this by registering a work item with the                  <xref:System.Windows.Threading.Dispatcher> of the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"The                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> class provides two methods for registering work items:                  <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A&gt;</ph> and                  <ph id=\"ph3\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph>.","pos":[9485,9753],"source":" The                  <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items:                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>."},{"content":"Both methods schedule a delegate for execution.","pos":[9754,9801]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A&gt;</ph> is a synchronous call – that is, it doesn’t return until the                  <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread actually finishes executing the delegate.","pos":[9819,10066],"source":"                  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph> is asynchronous and returns immediately.","pos":[10084,10182],"source":"                  <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately."},{"content":"The                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> orders the elements in its queue by priority.","pos":[10189,10298],"source":"The                  <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority."},{"content":"There are ten levels that may be specified when adding an element to the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> queue.","pos":[10299,10438],"source":" There are ten levels that may be specified when adding an element to the                  <xref:System.Windows.Threading.Dispatcher> queue."},{"content":"These priorities are maintained in the                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherPriority&gt;</ph> enumeration.","pos":[10439,10558],"source":" These priorities are maintained in the                  <xref:System.Windows.Threading.DispatcherPriority> enumeration."},{"content":"Detailed information about                  <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherPriority&gt;</ph> levels can be found in the                  <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)]</ph> documentation.","pos":[10559,10792],"source":" Detailed information about                  <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the                  [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation."},{"pos":[10827,10857],"content":"Threads in Action: The Samples","linkify":"Threads in Action: The Samples","nodes":[{"content":"Threads in Action: The Samples","pos":[0,30]}]},{"pos":[10898,10959],"content":"A Single-Threaded Application with a Long-Running Calculation","linkify":"A Single-Threaded Application with a Long-Running Calculation","nodes":[{"content":"A Single-Threaded Application with a Long-Running Calculation","pos":[0,61]}]},{"content":"Most                          <ph id=\"ph1\">[!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)]</ph> spend a large portion of their time idle while waiting for events that are generated in response to user interactions.","pos":[10963,11197],"source":"Most                          [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions."},{"content":"With careful programming this idle time can be used constructively, without affecting the responsiveness of the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph>.","pos":[11198,11403],"source":" With careful programming this idle time can be used constructively, without affecting the responsiveness of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]."},{"content":"The                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> threading model doesn’t allow input to interrupt an operation happening in the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[11404,11694],"source":" The                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"This means you must be sure to return to the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> periodically to process pending input events before they get stale.","pos":[11695,11875],"source":" This means you must be sure to return to the                          <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale."},{"content":"Consider the following example:","pos":[11882,11913]},{"pos":[11920,12063],"content":"<bpt id=\"p1\">![</bpt>Prime numbers screen shot<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG \"</bpt>ThreadingPrimeNumberScreenShot<ept id=\"p2\">\")</ept>","source":"![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG \"ThreadingPrimeNumberScreenShot\")"},{"content":"This simple application counts upwards from three, searching for prime numbers.","pos":[12070,12149]},{"content":"When the user clicks the                          <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept> button, the search begins.","pos":[12150,12236],"source":" When the user clicks the                          **Start** button, the search begins."},{"content":"When the program finds a prime, it updates the user interface with its discovery.","pos":[12237,12318]},{"content":"At any point, the user can stop the search.","pos":[12319,12362]},{"content":"Although simple enough, the prime number search could go on forever, which presents some difficulties.","pos":[12369,12471]},{"content":"If we handled the entire search inside of the click event handler of the button, we would never give the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread a chance to handle other events.","pos":[12473,12710],"source":"  If we handled the entire search inside of the click event handler of the button, we would never give the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events."},{"content":"The                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> would be unable to respond to input or process messages.","pos":[12711,12864],"source":" The                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages."},{"content":"It would never repaint and never respond to button clicks.","pos":[12865,12923]},{"content":"We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.","pos":[12930,13052]},{"content":"With a single-threaded approach, we can directly update the label that lists the largest prime found.","pos":[13053,13154]},{"content":"If we break up the task of calculation into manageable chunks, we can periodically return to the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> and process events.","pos":[13161,13345],"source":"If we break up the task of calculation into manageable chunks, we can periodically return to the                          <xref:System.Windows.Threading.Dispatcher> and process events."},{"content":"We can give                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> an opportunity to repaint and process input.","pos":[13346,13509],"source":" We can give                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input."},{"content":"The best way to split processing time between calculation and event handling is to manage calculation from the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>.","pos":[13516,13695],"source":"The best way to split processing time between calculation and event handling is to manage calculation from the                          <xref:System.Windows.Threading.Dispatcher>."},{"content":"By using the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph> method, we can schedule prime number checks in the same queue that                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> events are drawn from.","pos":[13696,13974],"source":" By using the                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from."},{"content":"In our example, we schedule only a single prime number check at a time.","pos":[13975,14046]},{"content":"After the prime number check is complete, we schedule the next check immediately.","pos":[14047,14128]},{"content":"This check proceeds only after pending                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> events have been handled.","pos":[14129,14286],"source":" This check proceeds only after pending                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled."},{"pos":[14293,14428],"content":"<bpt id=\"p1\">![</bpt>Dispatcher queue illustration<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG \"</bpt>ThreadingDispatcherQueue<ept id=\"p2\">\")</ept>","source":"![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG \"ThreadingDispatcherQueue\")"},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]</ph> accomplishes spell checking using this mechanism.","pos":[14435,14554],"source":"[!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)] accomplishes spell checking using this mechanism."},{"content":"Spell checking is done in the background using the idle time of the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[14555,14723],"source":" Spell checking is done in the background using the idle time of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"Let's take a look at the code.","pos":[14724,14754]},{"content":"The following example shows the XAML that creates the user interface.","pos":[14761,14830]},{"pos":[14837,15016],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberXAML<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]"},{"content":"The following example shows the code-behind.","pos":[15023,15067]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)</ept><ept id=\"p1\">]</ept>","pos":[15074,15271],"source":"[!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)</ept><ept id=\"p1\">]</ept>","pos":[15273,15479],"source":"[!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]"},{"content":"The following example shows the event handler for the                          <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","pos":[15486,15603],"source":"The following example shows the event handler for the                          <xref:System.Windows.Controls.Button>."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)</ept><ept id=\"p1\">]</ept>","pos":[15610,15809],"source":"[!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)</ept><ept id=\"p1\">]</ept>","pos":[15811,16019],"source":"[!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]"},{"content":"Besides updating the text on the                          <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph>, this handler is responsible for scheduling the first prime number check by adding a delegate to the                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> queue.","pos":[16026,16297],"source":"Besides updating the text on the                          <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the                          <xref:System.Windows.Threading.Dispatcher> queue."},{"content":"Sometime after this event handler has completed its work, the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> will select this delegate for execution.","pos":[16298,16468],"source":" Sometime after this event handler has completed its work, the                          <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution."},{"content":"As we mentioned earlier,                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph> is the                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> member used to schedule a delegate for execution.","pos":[16475,16707],"source":"As we mentioned earlier,                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the                          <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution."},{"content":"In this case, we choose the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherPriority&gt;</ph> priority.","pos":[16708,16821],"source":" In this case, we choose the                          <xref:System.Windows.Threading.DispatcherPriority> priority."},{"content":"The                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> will execute this delegate only when there are no important events to process.","pos":[16822,16972],"source":" The                          <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> responsiveness is more important than number checking.","pos":[16998,17120],"source":"[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking."},{"content":"We also pass a new delegate representing the number-checking routine.","pos":[17121,17190]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)</ept><ept id=\"p1\">]</ept>","pos":[17197,17404],"source":"[!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)</ept><ept id=\"p1\">]</ept>","pos":[17406,17622],"source":"[!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]"},{"content":"This method checks if the next odd number is prime.","pos":[17629,17680]},{"content":"If it is prime, the method directly updates the                          <ph id=\"ph1\">`bigPrime`</ph><ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> to reflect its discovery.","pos":[17681,17830],"source":" If it is prime, the method directly updates the                          `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery."},{"content":"We can do this because the calculation is occurring in the same thread that was used to create the component.","pos":[17831,17940]},{"content":"Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[17941,18197],"source":" Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"We’ll demonstrate this situation next.","pos":[18198,18236]},{"pos":[18243,18435],"content":"For the complete source code for this sample, see the                          <bpt id=\"p1\">[</bpt>Single-Threaded Application with Long-Running Calculation Sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=160038)</ept>","source":"For the complete source code for this sample, see the                          [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)"},{"pos":[18475,18529],"content":"Handling a Blocking Operation with a Background Thread","linkify":"Handling a Blocking Operation with a Background Thread","nodes":[{"content":"Handling a Blocking Operation with a Background Thread","pos":[0,54]}]},{"content":"Handling blocking operations in a graphical application can be difficult.","pos":[18533,18606]},{"content":"We don’t want to call blocking methods from event handlers because the application will appear to freeze up.","pos":[18607,18715]},{"content":"We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread because we can’t directly modify the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)]</ph> from our worker thread.","pos":[18716,19081],"source":" We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the                          [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread."},{"content":"We can use                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.Invoke%2A&gt;</ph> or                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph> to insert delegates into the                          <ph id=\"ph3\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> of the                          <ph id=\"ph4\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[19082,19461],"source":" We can use                          <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the                          <xref:System.Windows.Threading.Dispatcher> of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"Eventually, these delegates will be executed with permission to modify                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> elements.","pos":[19462,19635],"source":" Eventually, these delegates will be executed with permission to modify                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements."},{"content":"In this example, we mimic a remote procedure call that retrieves a weather forecast.","pos":[19642,19726]},{"content":"We use a separate worker thread to execute this call, and we schedule an update method in the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> of the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread when we’re finished.","pos":[19727,20016],"source":" We use a separate worker thread to execute this call, and we schedule an update method in the                          <xref:System.Windows.Threading.Dispatcher> of the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished."},{"pos":[20023,20159],"content":"<bpt id=\"p1\">![</bpt>Weather UI screen shot<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG \"</bpt>ThreadingWeatherUIScreenShot<ept id=\"p2\">\")</ept>","source":"![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG \"ThreadingWeatherUIScreenShot\")"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherCodeBehind<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)</ept><ept id=\"p1\">]</ept>","pos":[20166,20361],"source":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherCodeBehind<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)</ept><ept id=\"p1\">]</ept>","pos":[20363,20564],"source":"[!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]"},{"content":"The following are some of the details to be noted.","pos":[20571,20621]},{"content":"Creating the Button Handler","pos":[20631,20658]},{"pos":[20669,21083],"content":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]\n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]","leadings":["","    "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherButtonHandler<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)</ept><ept id=\"p1\">]</ept>","pos":[0,201],"source":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherButtonHandler<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)</ept><ept id=\"p1\">]</ept>","pos":[203,410],"source":"[!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]"}]},{"content":"When the button is clicked, we display the clock drawing and start animating it.","pos":[21090,21170]},{"content":"We disable the button.","pos":[21171,21193]},{"content":"We invoke the                          <ph id=\"ph1\">`FetchWeatherFromServer`</ph> method in a new thread, and then we return, allowing the                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> to process events while we wait to collect the weather forecast.","pos":[21194,21447],"source":" We invoke the                          `FetchWeatherFromServer` method in a new thread, and then we return, allowing the                          <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast."},{"content":"Fetching the Weather","pos":[21457,21477]},{"pos":[21488,21898],"content":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]\n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]","leadings":["","    "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherFetchWeather<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)</ept><ept id=\"p1\">]</ept>","pos":[0,199],"source":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherFetchWeather<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)</ept><ept id=\"p1\">]</ept>","pos":[201,406],"source":"[!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]"}]},{"content":"To keep things simple, we don’t actually have any networking code in this example.","pos":[21905,21987]},{"content":"Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.","pos":[21988,22089]},{"content":"In this time, the original                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread is still running and responding to events.","pos":[22090,22259],"source":" In this time, the original                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events."},{"content":"To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.","pos":[22260,22367]},{"content":"When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[22374,22584],"source":"When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"We do this by scheduling a call to                          <ph id=\"ph1\">`UpdateUserInterface`</ph> in the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread using that thread’s                          <ph id=\"ph3\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>.","pos":[22585,22862],"source":" We do this by scheduling a call to                          `UpdateUserInterface` in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s                          <xref:System.Windows.Threading.Dispatcher>."},{"content":"We pass a string describing the weather to this scheduled method call.","pos":[22863,22933]},{"pos":[22943,23056],"content":"Updating the                                  <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph>","source":"Updating the                                  [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]"},{"pos":[23067,23461],"content":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]\n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]","leadings":["","    "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherUpdateUI<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)</ept><ept id=\"p1\">]</ept>","pos":[0,191],"source":"[!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingWeatherForecast#ThreadingWeatherUpdateUI<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)</ept><ept id=\"p1\">]</ept>","pos":[193,390],"source":"[!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]"}]},{"content":"When the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> in the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread has time, it executes the scheduled call to                          <ph id=\"ph3\">`UpdateUserInterface`</ph>.","pos":[23468,23743],"source":"When the                          <xref:System.Windows.Threading.Dispatcher> in the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to                          `UpdateUserInterface`."},{"content":"This method stops the clock animation and chooses an image to describe the weather.","pos":[23744,23827]},{"content":"It displays this image and restores the \"fetch forecast\" button.","pos":[23828,23892]},{"pos":[23934,23968],"content":"Multiple Windows, Multiple Threads","linkify":"Multiple Windows, Multiple Threads","nodes":[{"content":"Multiple Windows, Multiple Threads","pos":[0,34]}]},{"content":"Some                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications require multiple top-level windows.","pos":[23972,24132],"source":"Some                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows."},{"content":"It is perfectly acceptable for one Thread/                         <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> combination to manage multiple windows, but sometimes several threads do a better job.","pos":[24133,24329],"source":" It is perfectly acceptable for one Thread/                         <xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job."},{"content":"This is especially true if there is any chance that one of the windows will monopolize the thread.","pos":[24330,24428]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]</ph> Explorer works in this fashion.","pos":[24435,24538],"source":"[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] Explorer works in this fashion."},{"content":"Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.","pos":[24539,24658]},{"content":"By using a                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph><ph id=\"ph2\">&lt;xref:System.Windows.Controls.Frame&gt;</ph> control, we can display Web pages.","pos":[24665,24853],"source":"By using a                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages."},{"content":"We can easily create a simple                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)]</ph> substitute.","pos":[24854,24988],"source":" We can easily create a simple                          [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute."},{"content":"We start with an important feature: the ability to open a new explorer window.","pos":[24989,25067]},{"content":"When the user clicks the \"new window\" button, we launch a copy of our window in a separate thread.","pos":[25068,25166]},{"content":"This way, long-running or blocking operations in one of the windows won’t lock all the other windows.","pos":[25167,25268]},{"content":"In reality, the Web browser model has its own complicated threading model.","pos":[25275,25349]},{"content":"We’ve chosen it because it should be familiar to most readers.","pos":[25350,25412]},{"content":"The following example shows the code.","pos":[25419,25456]},{"pos":[25463,25652],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)</ept><ept id=\"p1\">]</ept>","pos":[25659,25866],"source":"[!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)</ept><ept id=\"p1\">]</ept>","pos":[25868,26081],"source":"[!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]"},{"content":"The following threading segments of this code are the most interesting to us in this context:","pos":[26088,26181]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)</ept><ept id=\"p1\">]</ept>","pos":[26188,26393],"source":"[!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)</ept><ept id=\"p1\">]</ept>","pos":[26395,26606],"source":"[!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]"},{"content":"This method is called when the \"new window\" button is clicked.","pos":[26613,26675]},{"content":"It creates a new thread and starts it asynchronously.","pos":[26676,26729]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)</ept><ept id=\"p1\">]</ept>","pos":[26736,26945],"source":"[!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)</ept><ept id=\"p1\">]</ept>","pos":[26947,27162],"source":"[!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]"},{"content":"This method is the starting point for the new thread.","pos":[27169,27222]},{"content":"We create a new window under the control of this thread.","pos":[27223,27279]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> automatically creates a new                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> to manage the new thread.","pos":[27305,27508],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] automatically creates a new                          <xref:System.Windows.Threading.Dispatcher> to manage the new thread."},{"content":"All we have to do to make the window functional is to start the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph>.","pos":[27509,27641],"source":" All we have to do to make the window functional is to start the                          <xref:System.Windows.Threading.Dispatcher>."},{"pos":[27685,27723],"content":"Technical Details and Stumbling Points","linkify":"Technical Details and Stumbling Points","nodes":[{"content":"Technical Details and Stumbling Points","pos":[0,38]}]},{"pos":[27733,27767],"content":"Writing Components Using Threading","linkify":"Writing Components Using Threading","nodes":[{"content":"Writing Components Using Threading","pos":[0,34]}]},{"content":"The                          <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)]</ph> Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see                          <bpt id=\"p1\">[</bpt>Event-based Asynchronous Pattern Overview<ept id=\"p1\">](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)</ept>).","pos":[27771,28169],"source":"The                          [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see                          [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md))."},{"content":"For instance, suppose we wanted to package the                          <ph id=\"ph1\">`FetchWeatherFromServer`</ph> method into a reusable, nongraphical component.","pos":[28170,28314],"source":" For instance, suppose we wanted to package the                          `FetchWeatherFromServer` method into a reusable, nongraphical component."},{"content":"Following the standard                          <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)]</ph> pattern, this would look something like the following.","pos":[28315,28499],"source":" Following the standard                          [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CommandingOverviewSnippets#ThreadingArticleWeatherComponent1<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)</ept><ept id=\"p1\">]</ept>","pos":[28506,28719],"source":"[!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CommandingOverviewSnippets#ThreadingArticleWeatherComponent1<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)</ept><ept id=\"p1\">]</ept>","pos":[28721,28940],"source":"[!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]"},{"pos":[28947,29117],"content":"<ph id=\"ph1\">`GetWeatherAsync`</ph> would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.","source":"`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread."},{"content":"One of the most important parts of this pattern is calling the                          <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Completed`</ph> method on the same thread that called the                          <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Async`</ph> method to begin with.","pos":[29124,29344],"source":"One of the most important parts of this pattern is calling the                          *MethodName*`Completed` method on the same thread that called the                          *MethodName*`Async` method to begin with."},{"content":"You could do this using                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> fairly easily, by storing                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A&gt;</ph>—but then the nongraphical component could only be used in                          <ph id=\"ph3\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications, not in                          <ph id=\"ph4\">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]</ph> or                          <ph id=\"ph5\">[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]</ph> programs.","pos":[29345,29991],"source":" You could do this using                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing                          <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in                          [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or                          [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs."},{"pos":[29998,30359],"content":"The                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherSynchronizationContext&gt;</ph> class addresses this need—think of it as a simplified version of                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> that works with other                          <ph id=\"ph3\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> frameworks as well.","source":"The                          <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of                          <xref:System.Windows.Threading.Dispatcher> that works with other                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CommandingOverviewSnippets#ThreadingArticleWeatherComponent2<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)</ept><ept id=\"p1\">]</ept>","pos":[30366,30579],"source":"[!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CommandingOverviewSnippets#ThreadingArticleWeatherComponent2<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)</ept><ept id=\"p1\">]</ept>","pos":[30581,30800],"source":"[!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]"},{"pos":[30810,30824],"content":"Nested Pumping","linkify":"Nested Pumping","nodes":[{"content":"Nested Pumping","pos":[0,14]}]},{"content":"Sometimes it is not feasible to completely lock up the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[30828,30983],"source":"Sometimes it is not feasible to completely lock up the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"Let’s consider the                          <ph id=\"ph1\">&lt;xref:System.Windows.MessageBox.Show%2A&gt;</ph> method of the                          <ph id=\"ph2\">&lt;xref:System.Windows.MessageBox&gt;</ph> class.","pos":[30984,31147],"source":" Let’s consider the                          <xref:System.Windows.MessageBox.Show%2A> method of the                          <xref:System.Windows.MessageBox> class."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.MessageBox.Show%2A&gt;</ph> doesn’t return until the user clicks the OK button.","pos":[31173,31265],"source":"                          <xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button."},{"content":"It does, however, create a window that must have a message loop in order to be interactive.","pos":[31266,31357]},{"content":"While we are waiting for the user to click OK, the original application window does not respond to user input.","pos":[31358,31468]},{"content":"It does, however, continue to process paint messages.","pos":[31469,31522]},{"content":"The original window redraws itself when covered and revealed.","pos":[31523,31584]},{"pos":[31591,31723],"content":"<bpt id=\"p1\">![</bpt>MessageBox with an \"OK\" button<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png \"</bpt>ThreadingNestedPumping<ept id=\"p2\">\")</ept>","source":"![MessageBox with an \"OK\" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png \"ThreadingNestedPumping\")"},{"content":"Some thread must be in charge of the message box window.","pos":[31730,31786]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).","pos":[31812,32093],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion)."},{"content":"Instead,                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> uses a nested message processing system.","pos":[32094,32250],"source":" Instead,                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system."},{"content":"The                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher&gt;</ph> class includes a special method called                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.PushFrame%2A&gt;</ph>, which stores an application’s current execution point then begins a new message loop.","pos":[32251,32529],"source":" The                          <xref:System.Windows.Threading.Dispatcher> class includes a special method called                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop."},{"content":"When the nested message loop finishes, execution resumes after the original                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.PushFrame%2A&gt;</ph> call.","pos":[32530,32692],"source":" When the nested message loop finishes, execution resumes after the original                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call."},{"content":"In this case,                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.Dispatcher.PushFrame%2A&gt;</ph> maintains the program context at the call to                          <ph id=\"ph2\">&lt;xref:System.Windows.MessageBox&gt;</ph>.","pos":[32699,32897],"source":"In this case,                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to                          <xref:System.Windows.MessageBox>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.MessageBox.Show%2A&gt;</ph>, and it starts a new message loop to repaint the background window and handle input to the message box window.","pos":[32922,33073],"source":"                         <xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window."},{"content":"When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to                          <ph id=\"ph1\">&lt;xref:System.Windows.MessageBox.Show%2A&gt;</ph>.","pos":[33074,33254],"source":" When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to                          <xref:System.Windows.MessageBox.Show%2A>."},{"pos":[33264,33283],"content":"Stale Routed Events","linkify":"Stale Routed Events","nodes":[{"content":"Stale Routed Events","pos":[0,19]}]},{"pos":[33287,33466],"content":"The routed event system in                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> notifies entire trees when events are raised.","source":"The routed event system in                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised."},{"pos":[33473,33642],"content":"<bpt id=\"p1\">[!code-xml</bpt><bpt id=\"p2\">[</bpt>InputOvw#ThreadingArticleStaticRoutedEvent<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)</ept><ept id=\"p1\">]</ept>","source":"[!code-xml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]"},{"content":"When the left mouse button is pressed over the ellipse,                          <ph id=\"ph1\">`handler2`</ph> is executed.","pos":[33649,33753],"source":"When the left mouse button is pressed over the ellipse,                          `handler2` is executed."},{"content":"After                          <ph id=\"ph1\">`handler2`</ph> finishes, the event is passed along to the                          <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> object, which uses                          <ph id=\"ph3\">`handler1`</ph> to process it.","pos":[33754,33971],"source":" After                          `handler2` finishes, the event is passed along to the                          <xref:System.Windows.Controls.Canvas> object, which uses                          `handler1` to process it."},{"content":"This happens only if                          <ph id=\"ph1\">`handler2`</ph> does not explicitly mark the event object as handled.","pos":[33972,34082],"source":" This happens only if                          `handler2` does not explicitly mark the event object as handled."},{"content":"It’s possible that                          <ph id=\"ph1\">`handler2`</ph> will take a great deal of time processing this event.","pos":[34089,34197],"source":"It’s possible that                          `handler2` will take a great deal of time processing this event."},{"content":"<ph id=\"ph1\">`handler2`</ph> might use                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.PushFrame%2A&gt;</ph> to begin a nested message loop that doesn’t return for hours.","pos":[34223,34386],"source":"`handler2` might use                          <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours."},{"content":"If                          <ph id=\"ph1\">`handler2`</ph> does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.","pos":[34387,34556],"source":" If                          `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old."},{"pos":[34566,34588],"content":"Reentrancy and Locking","linkify":"Reentrancy and Locking","nodes":[{"content":"Reentrancy and Locking","pos":[0,22]}]},{"content":"The locking mechanism of the                          <ph id=\"ph1\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.","pos":[34592,34838],"source":"The locking mechanism of the                          [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock."},{"content":"In actuality, the thread continues to receive and process high-priority messages.","pos":[34839,34920]},{"content":"This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.","pos":[34921,35042]},{"content":"The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]</ph> window messages or COM STA components) this can be worth knowing.","pos":[35044,35330],"source":"  The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving                          [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing."},{"content":"Most interfaces are not built with thread safety in mind because developers work under the assumption that a                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> is never accessed by more than one thread.","pos":[35337,35581],"source":"Most interfaces are not built with thread safety in mind because developers work under the assumption that a                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread."},{"content":"In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the                          <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherObject&gt;</ph> mutual exclusion mechanism is supposed to solve.","pos":[35582,35824],"source":" In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the                          <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve."},{"content":"Consider the following pseudocode:","pos":[35825,35859]},{"pos":[35866,35990],"content":"<bpt id=\"p1\">![</bpt>Threading reentrancy diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png \"</bpt>ThreadingReentrancy<ept id=\"p2\">\")</ept>","source":"![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png \"ThreadingReentrancy\")"},{"content":"Most of the time that’s the right thing, but there are times in                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> where such unexpected reentrancy can really cause problems.","pos":[35997,36227],"source":"Most of the time that’s the right thing, but there are times in                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems."},{"content":"So, at certain key times,                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> calls                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A&gt;</ph>, which changes the lock instruction for that thread to use the                          <ph id=\"ph3\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> reentrancy-free lock, instead of the usual                          <ph id=\"ph4\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> lock.","pos":[36228,36769],"source":" So, at certain key times,                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls                          <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock."},{"content":"So why did the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> team choose this behavior?","pos":[36776,36912],"source":"So why did the                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?"},{"content":"It had to do with COM STA objects and the finalization thread.","pos":[36913,36975]},{"content":"When an object is garbage collected, its                          <ph id=\"ph1\">`Finalize`</ph> method is run on the dedicated finalizer thread, not the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[36976,37210],"source":" When an object is garbage collected, its                          `Finalize` method is run on the dedicated finalizer thread, not the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"And therein lies the problem, because a COM STA object that was created on the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread can only be disposed on the                          <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread.","pos":[37211,37518],"source":" And therein lies the problem, because a COM STA object that was created on the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread."},{"content":"The                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> does the equivalent of a                          <ph id=\"ph2\">&lt;xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A&gt;</ph> (in this case using Win32’s                          <ph id=\"ph3\">`SendMessage`</ph>).","pos":[37519,37794],"source":" The                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a                          <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s                          `SendMessage`)."},{"content":"But if the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.","pos":[37795,38025],"source":" But if the                          [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak."},{"content":"So the                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> team made the tough call to make locks work the way they do.","pos":[38026,38188],"source":" So the                          [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do."},{"pos":[38195,38438],"content":"The task for                          <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.","source":"The task for                          [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere."},{"pos":[38447,38455],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[38459,38572],"content":"<bpt id=\"p1\">[</bpt>Single-Threaded Application with Long-Running Calculation Sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=160038)</ept>","source":"[Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)"}]}