{"content":"---\ntitle: What's new in .NET Core 2.1\ndescription: Learn about the new features found in .NET Core 2.1.\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nauthor: rpetrusha\nms.author: ronpet\nms.date: 10/10/2018\n---\n# What's new in .NET Core 2.1\n\n.NET Core 2.1 includes enhancements and new features in the following areas:\n\n- [Tooling](#tooling)\n- [Roll forward](#roll-forward)\n- [Deployment](#deployment)\n- [Windows Compatibility Pack](#windows-compatibility-pack)\n- [JIT compilation improvements](#jit-compiler-improvements)\n- [API changes](#api-changes)\n\n## Tooling\n\nThe .NET Core 2.1 SDK (v 2.1.300), the tooling included with .NET Core 2.1, includes the following changes and enhancements:\n\n### Build performance improvements\n\nA major focus of .NET Core 2.1 is improving build-time performance, particularly for incremental builds. These performance improvements apply to both command-line builds using `dotnet build` and to builds in Visual Studio. Some individual areas of improvement include:\n\n- For package asset resolution, resolving only assets used by a build rather than all assets.\n\n- Caching of assembly references.\n\n- Use of long-running SDK build servers, which are processes that span across individual `dotnet build` invocations. They eliminate the need to JIT-compile large blocks of code every time `dotnet build` is run. Build server processes can be automatically terminated with the following command:\n\n   ```console\n   dotnet buildserver shutdown\n   ```\n\n### New CLI commands\n\nA number of tools that were available only on a per project basis using [`DotnetCliToolReference`](../tools/extensibility.md) are now available as part of the .NET Core SDK. These tools include:\n\n- `dotnet watch` provides a file system watcher that waits for a file to change before executing a designated set of commands. For example, the following command automatically rebuilds the current project and generates verbose output whenever a file in it changes:\n\n   ```console\n   dotnet watch -- --verbose build\n   ```\n\n   Note the `--` option that precedes the `--verbose` option. It delimits the options passed directly to the `dotnet watch` command from the arguments that are passed to the child `dotnet` process. Without it, the `--verbose` option applies to the `dotnet watch` command, not the `dotnet build` command.\n  \n   For more information, see [Develop ASP.NET Core apps using dotnet watch](/aspnet/core/tutorials/dotnet-watch)\n\n- `dotnet dev-certs` generates and manages certificates used during development in ASP.NET Core applications.\n\n- `dotnet user-secrets` manages the secrets in a user secret store in ASP.NET Core applications.\n\n- `dotnet sql-cache` creates a table and indexes in a Microsoft SQL Server database to be used for distributed caching.\n\n- `dotnet ef` is a tool for managing databases, <xref:Microsoft.EntityFrameworkCore.DbContext> objects, and migrations in Entity Framework Core applications. For more information, see [EF Core .NET Command-line Tools](/ef/core/miscellaneous/cli/dotnet).\n\n### Global Tools\n\n.NET Core 2.1 supports *Global Tools* -- that is, custom tools that are available globally from the command line. The extensibility model in previous versions of .NET Core made custom tools available on a per project basis only by using [`DotnetCliToolReference`](../tools/extensibility.md#consuming-per-project-tools).\n\nTo install a Global Tool, you use the [dotnet tool install](../tools/dotnet-tool-install.md) command. For example:\n\n```console\ndotnet tool install -g dotnetsay\n```\n\nOnce installed, the tool can be run from the command line by specifying the tool name. For more information, see [.NET Core Global Tools overview](../tools/global-tools.md).\n\n### Tool management with the `dotnet tool` command\n\nIn .NET Core 2.1 SDK, all tools operations use the `dotnet tool` command. The following options are available:\n\n- [`dotnet tool install`](../tools/dotnet-tool-install.md) to install a tool.\n\n- [`dotnet tool update`](../tools/dotnet-tool-update.md) to uninstall and reinstall a tool, which effectively updates it.\n\n- [`dotnet tool list`](../tools/dotnet-tool-list.md) to list currently installed tools.\n\n- [`dotnet tool uninstall`](../tools/dotnet-tool-uninstall.md) to uninstall currently installed tools.\n\n## Roll forward\n\nAll .NET Core applications starting with .NET Core 2.0 automatically roll forward to the latest *minor version* installed on a system.\n\nStarting with .NET Core 2.0, if the version of .NET Core that an application was built with is not present at runtime, the application automatically runs against the latest installed *minor version* of .NET Core. In other words, if an application is built with .NET Core 2.0, and .NET Core 2.0 is not present on the host system but .NET Core 2.1 is, the application runs with .NET Core 2.1.\n\n> [!IMPORTANT]\n> This roll-forward behavior doesn't apply to preview releases. By default, it also doesn't apply to major releases, but this can be changed with the settings below.\n\nYou can modify this behavior by changing the setting for the roll-forward on no candidate shared framework. The available settings are:\n- `0` - disable minor version roll-forward behavior. With this setting, an application built for .NET Core 2.0.0 will roll forward to .NET Core 2.0.1, but not to .NET Core 2.2.0 or .NET Core 3.0.0.\n- `1` - enable minor version roll-forward behavior. This is the default value for the setting. With this setting, an application built for .NET Core 2.0.0 will roll forward to either .NET Core 2.0.1 or .NET Core 2.2.0, depending on which one is installed, but it will not roll forward to .NET Core 3.0.0.\n- `2` - enable minor and major version roll-forward behavior. If set, even different major versions are considered, so an application built for .NET Core 2.0.0 will roll forward to .NET Core 3.0.0.\n\nYou can modify this setting in any of three ways:\n\n- Set the `DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX` environment variable to the desired value.\n\n- Add the following line with the desired value to the `runtimeconfig.json` file:\n\n   ```json\n   \"rollForwardOnNoCandidateFx\" : 0\n   ```\n\n- When using [.NET Core CLI tools](../tools/index.md), add the following option with the desired value to a .NET Core command such as `run`:\n\n   ```console\n   dotnet run --rollForwardOnNoCandidateFx=0\n   ```\n\nPatch version roll forward is independent of this setting and is done after any potential minor or major version roll forward is applied.\n\n## Deployment\n\n### Self-contained application servicing\n\n`dotnet publish` now publishes self-contained applications with a serviced runtime version. When you publish a self-contained application with the .NET Core 2.1 SDK (v 2.1.300), your application includes the latest serviced runtime version known by that SDK. When you upgrade to the latest SDK, you’ll publish with the latest .NET Core runtime version. This applies for .NET Core 1.0 runtimes and later.\n\nSelf-contained publishing relies on runtime versions on NuGet.org. You do not need to have the serviced runtime on your machine.\n\nUsing the .NET Core 2.0 SDK, self-contained applications are published with the .NET Core 2.0.0 runtime unless a different version is specified via the `RuntimeFrameworkVersion` property. With this new behavior, you’ll no longer need to set this property to select a higher runtime version for a self-contained application. The easiest approach going forward is to always publish with .NET Core 2.1 SDK (v 2.1.300).\n\nFor more information, see [Self-contained deployment runtime roll forward](../deploying/runtime-patch-selection.md).\n## Windows Compatibility Pack\n\nWhen you port existing code from the .NET Framework to .NET Core, you can use the [Windows Compatibility Pack](https://www.nuget.org/packages/Microsoft.Windows.Compatibility). It provides access to 20,000 more APIs than are available in .NET Core. These APIs include types in the <xref:System.Drawing?displayProperty=nameWithType> namespace, the <xref:System.Diagnostics.EventLog> class, WMI, Performance Counters, Windows Services, and the Windows registry types and members.\n\n## JIT compiler improvements\n\n.NET Core incorporates a new JIT compiler technology called *tiered compilation* (also known as *adaptive optimization*) that can significantly improve performance. Tiered compilation is an opt-in setting.\n\nOne of the important tasks performed by the JIT compiler is optimizing code execution. For little-used code paths, however, the compiler may spend more time optimizing code than the runtime spends running unoptimized code. Tiered compilation introduces two stages in JIT compilation:\n\n- A **first tier**, which generates code as quickly as possible.\n\n- A **second tier**, which generates optimized code for those methods that are executed frequently. The second tier of compilation is performed in parallel for enhanced performance.\n\nYou can opt into tiered compilation in either of two ways.\n\n- To use tiered compilation in all projects that use the .NET Core 2.1 SDK, set the following environment variable:\n\n  ```console\n  COMPlus_TieredCompilation=\"1\"\n  ```\n\n- To use tiered compilation on a per-project basis, add the `<TieredCompilation>` property to the `<PropertyGroup>` section of the MSBuild project file, as the following example shows:\n\n   ```xml\n   <PropertyGroup>\n      <!-- other property definitions -->\n\n      <TieredCompilation>true</TieredCompilation>\n   </PropertyGroup>\n   ```\n\n## API changes\n\n### `Span<T>` and `Memory<T>`\n\n.NET Core 2.1 includes some new types that make working with arrays and other types of memory much more efficient. The new types include:\n\n- <xref:System.Span%601?displayProperty=nameWithType> and <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.\n\n- <xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType>.\n\nWithout these types, when passing such items as a portion of an array or a section of a memory buffer, you have to make a copy of some portion of the data before passing it to a method. These types provide a virtual view of that data that eliminates the need for the additional memory allocation and copy operations.\n\nThe following example uses a <xref:System.Span%601> and <xref:System.Memory%601> instance to provide a virtual view of 10 elements of an array.\n\n[!CODE-csharp[Span\\<T>](~/samples/core/whats-new/whats-new-in-21/cs/program.cs)]\n\n[!CODE-vb[Memory\\<T>](~/samples/core/whats-new/whats-new-in-21/vb/program.vb)]\n\n### Brotli compression\n\n.NET Core 2.1 adds support for Brotli compression and decompression. Brotli is a general-purpose lossless compression algorithm that is defined in [RFC 7932](https://www.ietf.org/rfc/rfc7932.txt) and is supported by most web browsers and major web servers. You can use the stream-based <xref:System.IO.Compression.BrotliStream?displayProperty=nameWithType> class or the high-performance span-based <xref:System.IO.Compression.BrotliEncoder?displayProperty=nameWithType> and <xref:System.IO.Compression.BrotliDecoder?displayProperty=nameWithType> classes. The following example illustrates compression with the <xref:System.IO.Compression.BrotliStream> class:\n\n[!CODE-csharp[Brotli compression](~/samples/core/whats-new/whats-new-in-21/cs/brotli.cs#1)]\n\nThe <xref:System.IO.Compression.BrotliStream> behavior is the same as <xref:System.IO.Compression.DeflateStream> and <xref:System.IO.Compression.GZipStream>, which makes it easy to convert code that calls these APIs to <xref:System.IO.Compression.BrotliStream>.\n\n### New cryptography APIs and cryptography improvements\n\n.NET Core 2.1 includes numerous enhancements to the cryptography APIs:\n\n- <xref:System.Security.Cryptography.Pkcs.SignedCms?displayProperty=nameWithType> is available in the System.Security.Cryptography.Pkcs package. The implementation is the same as the <xref:System.Security.Cryptography.Pkcs.SignedCms> class in the .NET Framework.\n\n- New overloads of the <xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHash%2A?displayProperty=nameWithType> and <xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHashString%2A?displayProperty=nameWithType> methods accept a hash algorithm identifier to enable callers to get certificate thumbprint values using algorithms other than SHA-1.\n\n- New <xref:System.Span%601>-based cryptography APIs are available for hashing, HMAC, cryptographic random number generation, asymmetric signature generation, asymmetric signature processing, and RSA encryption.\n\n- The performance of <xref:System.Security.Cryptography.Rfc2898DeriveBytes?displayProperty=nameWithType> has improved by about 15% by using a <xref:System.Span%601>-based implementation.\n\n- The new <xref:System.Security.Cryptography.CryptographicOperations?displayProperty=nameWithType> class includes two new methods:\n\n  - <xref:System.Security.Cryptography.CryptographicOperations.FixedTimeEquals%2A> takes a fixed amount of time to return for any two inputs of the same length, which makes it suitable for use in cryptographic verification to avoid contributing to timing side-channel information.\n\n  - <xref:System.Security.Cryptography.CryptographicOperations.ZeroMemory%2A> is a memory-clearing routine that cannot be optimized.\n\n- The static <xref:System.Security.Cryptography.RandomNumberGenerator.Fill%2A?displayProperty=nameWithType> method fills a <xref:System.Span%601> with random values.\n\n- The <xref:System.Security.Cryptography.Pkcs.EnvelopedCms?displayProperty=nameWithType> is now supported on Linux and maxOS.\n\n- Elliptic-Curve Diffie-Hellman (ECDH) is now available in the <xref:System.Security.Cryptography.ECDiffieHellman?displayProperty=nameWithType> class family. The surface area is the same as in the .NET Framework.\n\n- The instance returned by <xref:System.Security.Cryptography.RSA.Create%2A?displayProperty=nameWithType> can encrypt or decrypt with OAEP using a SHA-2 digest, as well as generate or validate signatures using RSA-PSS.\n\n### Sockets improvements\n\n.NET Core includes a new type, <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType>, and a rewritten <xref:System.Net.Http.HttpMessageHandler?displayProperty=nameWithType>, that form the basis of higher-level networking APIs.  <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType>, for example, is the basis of the <xref:System.Net.Http.HttpClient> implementation. In previous versions of .NET Core, higher-level APIs were based on native networking implementations.\n\nThe sockets implementation introduced in .NET Core 2.1 has a number of advantages:\n\n- A significant performance improvement when compared with the previous implementation.\n\n- Elimination of platform dependencies, which simplifies deployment and servicing.\n\n- Consistent behavior across all .NET Core platforms.\n\n<xref:System.Net.Http.SocketsHttpHandler> is the default implementation in .NET Core 2.1. However, you can configure your application to use the older <xref:System.Net.Http.HttpClientHandler> class by calling the <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> method:\n\n```csharp\nAppContext.SetSwitch(\"System.Net.Http.UseSocketsHttpHandler\", false);\n```\n\n```vb\nAppContext.SetSwitch(\"System.Net.Http.UseSocketsHttpHandler\", False)\n```\n\nYou can also use an environment variable to opt out of using sockets implementations based on <xref:System.Net.Http.SocketsHttpHandler>. To do this, set the `DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER` to either `false` or 0.\n\nOn Windows, you can also choose to use <xref:System.Net.Http.WinHttpHandler?displayProperty=nameWithType>, which relies on a native implementation, or the <xref:System.Net.Http.SocketsHttpHandler> class by passing an instance of the class to the <xref:System.Net.Http.HttpClient> constructor.\n\nOn Linux and macOS, you can only configure <xref:System.Net.Http.HttpClient> on a per-process basis. On Linux, you need to deploy [libcurl](https://curl.haxx.se/libcurl/) if you want to use the old <xref:System.Net.Http.HttpClient> implementation. (It is installed with .NET Core 2.0.)\n\n## See also\n\n- [What's new in .NET Core](index.md)\n- [New features in EF Core 2.1](/ef/core/what-is-new/ef-core-2.1)\n- [What's new in ASP.NET Core 2.1](/aspnet/core/aspnetcore-2.1)\n","nodes":[{"pos":[4,194],"embed":true,"restype":"x-metadata","content":"title: What's new in .NET Core 2.1\ndescription: Learn about the new features found in .NET Core 2.1.\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nauthor: rpetrusha\nms.author: ronpet\nms.date: 10/10/2018","nodes":[{"content":"What's new in .NET Core 2.1","nodes":[{"pos":[0,27],"content":"What's new in .NET Core 2.1","nodes":[{"content":"What's new in .NET Core 2.1","pos":[0,27]}]}],"path":["title"],"nosxs":false},{"content":"Learn about the new features found in .NET Core 2.1.","nodes":[{"pos":[0,52],"content":"Learn about the new features found in .NET Core 2.1.","nodes":[{"content":"Learn about the new features found in .NET Core 2.1.","pos":[0,52]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[201,228],"content":"What's new in .NET Core 2.1","linkify":"What's new in .NET Core 2.1","nodes":[{"content":"What's new in .NET Core 2.1","pos":[0,27]}]},{"content":".NET Core 2.1 includes enhancements and new features in the following areas:","pos":[230,306]},{"pos":[310,329],"content":"<bpt id=\"p1\">[</bpt>Tooling<ept id=\"p1\">](#tooling)</ept>","source":"[Tooling](#tooling)"},{"pos":[332,361],"content":"<bpt id=\"p1\">[</bpt>Roll forward<ept id=\"p1\">](#roll-forward)</ept>","source":"[Roll forward](#roll-forward)"},{"pos":[364,389],"content":"<bpt id=\"p1\">[</bpt>Deployment<ept id=\"p1\">](#deployment)</ept>","source":"[Deployment](#deployment)"},{"pos":[392,449],"content":"<bpt id=\"p1\">[</bpt>Windows Compatibility Pack<ept id=\"p1\">](#windows-compatibility-pack)</ept>","source":"[Windows Compatibility Pack](#windows-compatibility-pack)"},{"pos":[452,510],"content":"<bpt id=\"p1\">[</bpt>JIT compilation improvements<ept id=\"p1\">](#jit-compiler-improvements)</ept>","source":"[JIT compilation improvements](#jit-compiler-improvements)"},{"pos":[513,540],"content":"<bpt id=\"p1\">[</bpt>API changes<ept id=\"p1\">](#api-changes)</ept>","source":"[API changes](#api-changes)"},{"pos":[545,552],"content":"Tooling","linkify":"Tooling","nodes":[{"content":"Tooling","pos":[0,7]}]},{"content":"The .NET Core 2.1 SDK (v 2.1.300), the tooling included with .NET Core 2.1, includes the following changes and enhancements:","pos":[554,678]},{"pos":[684,714],"content":"Build performance improvements","linkify":"Build performance improvements","nodes":[{"content":"Build performance improvements","pos":[0,30]}]},{"content":"A major focus of .NET Core 2.1 is improving build-time performance, particularly for incremental builds.","pos":[716,820]},{"content":"These performance improvements apply to both command-line builds using <ph id=\"ph1\">`dotnet build`</ph> and to builds in Visual Studio.","pos":[821,938],"source":" These performance improvements apply to both command-line builds using `dotnet build` and to builds in Visual Studio."},{"content":"Some individual areas of improvement include:","pos":[939,984]},{"content":"For package asset resolution, resolving only assets used by a build rather than all assets.","pos":[988,1079]},{"content":"Caching of assembly references.","pos":[1083,1114]},{"content":"Use of long-running SDK build servers, which are processes that span across individual <ph id=\"ph1\">`dotnet build`</ph> invocations.","pos":[1118,1232],"source":"Use of long-running SDK build servers, which are processes that span across individual `dotnet build` invocations."},{"content":"They eliminate the need to JIT-compile large blocks of code every time <ph id=\"ph1\">`dotnet build`</ph> is run.","pos":[1233,1326],"source":" They eliminate the need to JIT-compile large blocks of code every time `dotnet build` is run."},{"content":"Build server processes can be automatically terminated with the following command:","pos":[1327,1409]},{"pos":[1468,1484],"content":"New CLI commands","linkify":"New CLI commands","nodes":[{"content":"New CLI commands","pos":[0,16]}]},{"content":"A number of tools that were available only on a per project basis using <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`DotnetCliToolReference`</ph><ept id=\"p1\">](../tools/extensibility.md)</ept> are now available as part of the .NET Core SDK.","pos":[1486,1659],"source":"A number of tools that were available only on a per project basis using [`DotnetCliToolReference`](../tools/extensibility.md) are now available as part of the .NET Core SDK."},{"content":"These tools include:","pos":[1660,1680]},{"content":"<ph id=\"ph1\">`dotnet watch`</ph> provides a file system watcher that waits for a file to change before executing a designated set of commands.","pos":[1684,1808],"source":"`dotnet watch` provides a file system watcher that waits for a file to change before executing a designated set of commands."},{"content":"For example, the following command automatically rebuilds the current project and generates verbose output whenever a file in it changes:","pos":[1809,1946]},{"content":"Note the <ph id=\"ph1\">`--`</ph> option that precedes the <ph id=\"ph2\">`--verbose`</ph> option.","pos":[2008,2066],"source":"Note the `--` option that precedes the `--verbose` option."},{"content":"It delimits the options passed directly to the <ph id=\"ph1\">`dotnet watch`</ph> command from the arguments that are passed to the child <ph id=\"ph2\">`dotnet`</ph> process.","pos":[2067,2202],"source":" It delimits the options passed directly to the `dotnet watch` command from the arguments that are passed to the child `dotnet` process."},{"content":"Without it, the <ph id=\"ph1\">`--verbose`</ph> option applies to the <ph id=\"ph2\">`dotnet watch`</ph> command, not the <ph id=\"ph3\">`dotnet build`</ph> command.","pos":[2203,2308],"source":" Without it, the `--verbose` option applies to the `dotnet watch` command, not the `dotnet build` command."},{"pos":[2315,2424],"content":"For more information, see <bpt id=\"p1\">[</bpt>Develop ASP.NET Core apps using dotnet watch<ept id=\"p1\">](/aspnet/core/tutorials/dotnet-watch)</ept>","source":"For more information, see [Develop ASP.NET Core apps using dotnet watch](/aspnet/core/tutorials/dotnet-watch)"},{"pos":[2428,2535],"content":"<ph id=\"ph1\">`dotnet dev-certs`</ph> generates and manages certificates used during development in ASP.NET Core applications.","source":"`dotnet dev-certs` generates and manages certificates used during development in ASP.NET Core applications."},{"pos":[2539,2633],"content":"<ph id=\"ph1\">`dotnet user-secrets`</ph> manages the secrets in a user secret store in ASP.NET Core applications.","source":"`dotnet user-secrets` manages the secrets in a user secret store in ASP.NET Core applications."},{"pos":[2637,2754],"content":"<ph id=\"ph1\">`dotnet sql-cache`</ph> creates a table and indexes in a Microsoft SQL Server database to be used for distributed caching.","source":"`dotnet sql-cache` creates a table and indexes in a Microsoft SQL Server database to be used for distributed caching."},{"content":"<ph id=\"ph1\">`dotnet ef`</ph> is a tool for managing databases, <ph id=\"ph2\">&lt;xref:Microsoft.EntityFrameworkCore.DbContext&gt;</ph> objects, and migrations in Entity Framework Core applications.","pos":[2758,2913],"source":"`dotnet ef` is a tool for managing databases, <xref:Microsoft.EntityFrameworkCore.DbContext> objects, and migrations in Entity Framework Core applications."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>EF Core .NET Command-line Tools<ept id=\"p1\">](/ef/core/miscellaneous/cli/dotnet)</ept>.","pos":[2914,3009],"source":" For more information, see [EF Core .NET Command-line Tools](/ef/core/miscellaneous/cli/dotnet)."},{"pos":[3015,3027],"content":"Global Tools","linkify":"Global Tools","nodes":[{"content":"Global Tools","pos":[0,12]}]},{"content":".NET Core 2.1 supports <bpt id=\"p1\">*</bpt>Global Tools<ept id=\"p1\">*</ept> -- that is, custom tools that are available globally from the command line.","pos":[3029,3142],"source":".NET Core 2.1 supports *Global Tools* -- that is, custom tools that are available globally from the command line."},{"content":"The extensibility model in previous versions of .NET Core made custom tools available on a per project basis only by using <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`DotnetCliToolReference`</ph><ept id=\"p1\">](../tools/extensibility.md#consuming-per-project-tools)</ept>.","pos":[3143,3348],"source":" The extensibility model in previous versions of .NET Core made custom tools available on a per project basis only by using [`DotnetCliToolReference`](../tools/extensibility.md#consuming-per-project-tools)."},{"content":"To install a Global Tool, you use the <bpt id=\"p1\">[</bpt>dotnet tool install<ept id=\"p1\">](../tools/dotnet-tool-install.md)</ept> command.","pos":[3350,3451],"source":"To install a Global Tool, you use the [dotnet tool install](../tools/dotnet-tool-install.md) command."},{"content":"For example:","pos":[3452,3464]},{"content":"Once installed, the tool can be run from the command line by specifying the tool name.","pos":[3515,3601]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>.NET Core Global Tools overview<ept id=\"p1\">](../tools/global-tools.md)</ept>.","pos":[3602,3688],"source":" For more information, see [.NET Core Global Tools overview](../tools/global-tools.md)."},{"pos":[3694,3740],"content":"Tool management with the <ph id=\"ph1\">`dotnet tool`</ph> command","linkify":"Tool management with the `dotnet tool` command","source":"Tool management with the `dotnet tool` command"},{"content":"In .NET Core 2.1 SDK, all tools operations use the <ph id=\"ph1\">`dotnet tool`</ph> command.","pos":[3742,3815],"source":"In .NET Core 2.1 SDK, all tools operations use the `dotnet tool` command."},{"content":"The following options are available:","pos":[3816,3852]},{"pos":[3856,3931],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet tool install`</ph><ept id=\"p1\">](../tools/dotnet-tool-install.md)</ept> to install a tool.","source":"[`dotnet tool install`](../tools/dotnet-tool-install.md) to install a tool."},{"pos":[3935,4054],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet tool update`</ph><ept id=\"p1\">](../tools/dotnet-tool-update.md)</ept> to uninstall and reinstall a tool, which effectively updates it.","source":"[`dotnet tool update`](../tools/dotnet-tool-update.md) to uninstall and reinstall a tool, which effectively updates it."},{"pos":[4058,4143],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet tool list`</ph><ept id=\"p1\">](../tools/dotnet-tool-list.md)</ept> to list currently installed tools.","source":"[`dotnet tool list`](../tools/dotnet-tool-list.md) to list currently installed tools."},{"pos":[4147,4247],"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">`dotnet tool uninstall`</ph><ept id=\"p1\">](../tools/dotnet-tool-uninstall.md)</ept> to uninstall currently installed tools.","source":"[`dotnet tool uninstall`](../tools/dotnet-tool-uninstall.md) to uninstall currently installed tools."},{"pos":[4252,4264],"content":"Roll forward","linkify":"Roll forward","nodes":[{"content":"Roll forward","pos":[0,12]}]},{"pos":[4266,4400],"content":"All .NET Core applications starting with .NET Core 2.0 automatically roll forward to the latest <bpt id=\"p1\">*</bpt>minor version<ept id=\"p1\">*</ept> installed on a system.","source":"All .NET Core applications starting with .NET Core 2.0 automatically roll forward to the latest *minor version* installed on a system."},{"content":"Starting with .NET Core 2.0, if the version of .NET Core that an application was built with is not present at runtime, the application automatically runs against the latest installed <bpt id=\"p1\">*</bpt>minor version<ept id=\"p1\">*</ept> of .NET Core.","pos":[4402,4614],"source":"Starting with .NET Core 2.0, if the version of .NET Core that an application was built with is not present at runtime, the application automatically runs against the latest installed *minor version* of .NET Core."},{"content":"In other words, if an application is built with .NET Core 2.0, and .NET Core 2.0 is not present on the host system but .NET Core 2.1 is, the application runs with .NET Core 2.1.","pos":[4615,4792]},{"pos":[4796,4974],"content":"[!IMPORTANT]\nThis roll-forward behavior doesn't apply to preview releases. By default, it also doesn't apply to major releases, but this can be changed with the settings below.","leadings":["","> "],"nodes":[{"content":"This roll-forward behavior doesn't apply to preview releases. By default, it also doesn't apply to major releases, but this can be changed with the settings below.","pos":[13,176],"nodes":[{"content":"This roll-forward behavior doesn't apply to preview releases.","pos":[0,61]},{"content":"By default, it also doesn't apply to major releases, but this can be changed with the settings below.","pos":[62,163]}]}]},{"content":"You can modify this behavior by changing the setting for the roll-forward on no candidate shared framework.","pos":[4976,5083]},{"content":"The available settings are:","pos":[5084,5111]},{"content":"<ph id=\"ph1\">`0`</ph> - disable minor version roll-forward behavior.","pos":[5114,5164],"source":"`0` - disable minor version roll-forward behavior."},{"content":"With this setting, an application built for .NET Core 2.0.0 will roll forward to .NET Core 2.0.1, but not to .NET Core 2.2.0 or .NET Core 3.0.0.","pos":[5165,5309]},{"content":"<ph id=\"ph1\">`1`</ph> - enable minor version roll-forward behavior.","pos":[5312,5361],"source":"`1` - enable minor version roll-forward behavior."},{"content":"This is the default value for the setting.","pos":[5362,5404]},{"content":"With this setting, an application built for .NET Core 2.0.0 will roll forward to either .NET Core 2.0.1 or .NET Core 2.2.0, depending on which one is installed, but it will not roll forward to .NET Core 3.0.0.","pos":[5405,5614]},{"content":"<ph id=\"ph1\">`2`</ph> - enable minor and major version roll-forward behavior.","pos":[5617,5676],"source":"`2` - enable minor and major version roll-forward behavior."},{"content":"If set, even different major versions are considered, so an application built for .NET Core 2.0.0 will roll forward to .NET Core 3.0.0.","pos":[5677,5812]},{"content":"You can modify this setting in any of three ways:","pos":[5814,5863]},{"pos":[5867,5958],"content":"Set the <ph id=\"ph1\">`DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX`</ph> environment variable to the desired value.","source":"Set the `DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX` environment variable to the desired value."},{"pos":[5962,6041],"content":"Add the following line with the desired value to the <ph id=\"ph1\">`runtimeconfig.json`</ph> file:","source":"Add the following line with the desired value to the `runtimeconfig.json` file:"},{"pos":[6100,6238],"content":"When using <bpt id=\"p1\">[</bpt>.NET Core CLI tools<ept id=\"p1\">](../tools/index.md)</ept>, add the following option with the desired value to a .NET Core command such as <ph id=\"ph1\">`run`</ph>:","source":"When using [.NET Core CLI tools](../tools/index.md), add the following option with the desired value to a .NET Core command such as `run`:"},{"content":"Patch version roll forward is independent of this setting and is done after any potential minor or major version roll forward is applied.","pos":[6307,6444]},{"pos":[6449,6459],"content":"Deployment","linkify":"Deployment","nodes":[{"content":"Deployment","pos":[0,10]}]},{"pos":[6465,6501],"content":"Self-contained application servicing","linkify":"Self-contained application servicing","nodes":[{"content":"Self-contained application servicing","pos":[0,36]}]},{"content":"<ph id=\"ph1\">`dotnet publish`</ph> now publishes self-contained applications with a serviced runtime version.","pos":[6503,6594],"source":"`dotnet publish` now publishes self-contained applications with a serviced runtime version."},{"content":"When you publish a self-contained application with the .NET Core 2.1 SDK (v 2.1.300), your application includes the latest serviced runtime version known by that SDK.","pos":[6595,6761]},{"content":"When you upgrade to the latest SDK, you’ll publish with the latest .NET Core runtime version.","pos":[6762,6855]},{"content":"This applies for .NET Core 1.0 runtimes and later.","pos":[6856,6906]},{"content":"Self-contained publishing relies on runtime versions on NuGet.org. You do not need to have the serviced runtime on your machine.","pos":[6908,7036]},{"content":"Using the .NET Core 2.0 SDK, self-contained applications are published with the .NET Core 2.0.0 runtime unless a different version is specified via the <ph id=\"ph1\">`RuntimeFrameworkVersion`</ph> property.","pos":[7038,7225],"source":"Using the .NET Core 2.0 SDK, self-contained applications are published with the .NET Core 2.0.0 runtime unless a different version is specified via the `RuntimeFrameworkVersion` property."},{"content":"With this new behavior, you’ll no longer need to set this property to select a higher runtime version for a self-contained application.","pos":[7226,7361]},{"content":"The easiest approach going forward is to always publish with .NET Core 2.1 SDK (v 2.1.300).","pos":[7362,7453]},{"pos":[7455,7571],"content":"For more information, see <bpt id=\"p1\">[</bpt>Self-contained deployment runtime roll forward<ept id=\"p1\">](../deploying/runtime-patch-selection.md)</ept>.","source":"For more information, see [Self-contained deployment runtime roll forward](../deploying/runtime-patch-selection.md)."},{"pos":[7575,7601],"content":"Windows Compatibility Pack","linkify":"Windows Compatibility Pack","nodes":[{"content":"Windows Compatibility Pack","pos":[0,26]}]},{"content":"When you port existing code from the .NET Framework to .NET Core, you can use the <bpt id=\"p1\">[</bpt>Windows Compatibility Pack<ept id=\"p1\">](https://www.nuget.org/packages/Microsoft.Windows.Compatibility)</ept>.","pos":[7603,7778],"source":"When you port existing code from the .NET Framework to .NET Core, you can use the [Windows Compatibility Pack](https://www.nuget.org/packages/Microsoft.Windows.Compatibility)."},{"content":"It provides access to 20,000 more APIs than are available in .NET Core.","pos":[7779,7850]},{"content":"These APIs include types in the <ph id=\"ph1\">&lt;xref:System.Drawing?displayProperty=nameWithType&gt;</ph> namespace, the <ph id=\"ph2\">&lt;xref:System.Diagnostics.EventLog&gt;</ph> class, WMI, Performance Counters, Windows Services, and the Windows registry types and members.","pos":[7851,8079],"source":" These APIs include types in the <xref:System.Drawing?displayProperty=nameWithType> namespace, the <xref:System.Diagnostics.EventLog> class, WMI, Performance Counters, Windows Services, and the Windows registry types and members."},{"pos":[8084,8109],"content":"JIT compiler improvements","linkify":"JIT compiler improvements","nodes":[{"content":"JIT compiler improvements","pos":[0,25]}]},{"content":".NET Core incorporates a new JIT compiler technology called <bpt id=\"p1\">*</bpt>tiered compilation<ept id=\"p1\">*</ept> (also known as <bpt id=\"p2\">*</bpt>adaptive optimization<ept id=\"p2\">*</ept>) that can significantly improve performance.","pos":[8111,8275],"source":".NET Core incorporates a new JIT compiler technology called *tiered compilation* (also known as *adaptive optimization*) that can significantly improve performance."},{"content":"Tiered compilation is an opt-in setting.","pos":[8276,8316]},{"content":"One of the important tasks performed by the JIT compiler is optimizing code execution.","pos":[8318,8404]},{"content":"For little-used code paths, however, the compiler may spend more time optimizing code than the runtime spends running unoptimized code.","pos":[8405,8540]},{"content":"Tiered compilation introduces two stages in JIT compilation:","pos":[8541,8601]},{"pos":[8605,8667],"content":"A <bpt id=\"p1\">**</bpt>first tier<ept id=\"p1\">**</ept>, which generates code as quickly as possible.","source":"A **first tier**, which generates code as quickly as possible."},{"content":"A <bpt id=\"p1\">**</bpt>second tier<ept id=\"p1\">**</ept>, which generates optimized code for those methods that are executed frequently.","pos":[8671,8768],"source":"A **second tier**, which generates optimized code for those methods that are executed frequently."},{"content":"The second tier of compilation is performed in parallel for enhanced performance.","pos":[8769,8850]},{"content":"You can opt into tiered compilation in either of two ways.","pos":[8852,8910]},{"content":"To use tiered compilation in all projects that use the .NET Core 2.1 SDK, set the following environment variable:","pos":[8914,9027]},{"pos":[9083,9265],"content":"To use tiered compilation on a per-project basis, add the <ph id=\"ph1\">`&lt;TieredCompilation&gt;`</ph> property to the <ph id=\"ph2\">`&lt;PropertyGroup&gt;`</ph> section of the MSBuild project file, as the following example shows:","source":"To use tiered compilation on a per-project basis, add the `<TieredCompilation>` property to the `<PropertyGroup>` section of the MSBuild project file, as the following example shows:"},{"pos":[9420,9431],"content":"API changes","linkify":"API changes","nodes":[{"content":"API changes","pos":[0,11]}]},{"pos":[9437,9462],"content":"<ph id=\"ph1\">`Span&lt;T&gt;`</ph> and <ph id=\"ph2\">`Memory&lt;T&gt;`</ph>","linkify":"`Span<T>` and `Memory<T>`","source":"`Span<T>` and `Memory<T>`"},{"content":".NET Core 2.1 includes some new types that make working with arrays and other types of memory much more efficient.","pos":[9464,9578]},{"content":"The new types include:","pos":[9579,9601]},{"pos":[9605,9721],"content":"<ph id=\"ph1\">&lt;xref:System.Span%601?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ReadOnlySpan%601?displayProperty=nameWithType&gt;</ph>.","source":"<xref:System.Span%601?displayProperty=nameWithType> and <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>."},{"pos":[9725,9845],"content":"<ph id=\"ph1\">&lt;xref:System.Memory%601?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ReadOnlyMemory%601?displayProperty=nameWithType&gt;</ph>.","source":"<xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType>."},{"content":"Without these types, when passing such items as a portion of an array or a section of a memory buffer, you have to make a copy of some portion of the data before passing it to a method.","pos":[9847,10032]},{"content":"These types provide a virtual view of that data that eliminates the need for the additional memory allocation and copy operations.","pos":[10033,10163]},{"pos":[10165,10308],"content":"The following example uses a <ph id=\"ph1\">&lt;xref:System.Span%601&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Memory%601&gt;</ph> instance to provide a virtual view of 10 elements of an array.","source":"The following example uses a <xref:System.Span%601> and <xref:System.Memory%601> instance to provide a virtual view of 10 elements of an array."},{"pos":[10476,10494],"content":"Brotli compression","linkify":"Brotli compression","nodes":[{"content":"Brotli compression","pos":[0,18]}]},{"content":".NET Core 2.1 adds support for Brotli compression and decompression.","pos":[10496,10564]},{"content":"Brotli is a general-purpose lossless compression algorithm that is defined in <bpt id=\"p1\">[</bpt>RFC 7932<ept id=\"p1\">](https://www.ietf.org/rfc/rfc7932.txt)</ept> and is supported by most web browsers and major web servers.","pos":[10565,10752],"source":" Brotli is a general-purpose lossless compression algorithm that is defined in [RFC 7932](https://www.ietf.org/rfc/rfc7932.txt) and is supported by most web browsers and major web servers."},{"content":"You can use the stream-based <ph id=\"ph1\">&lt;xref:System.IO.Compression.BrotliStream?displayProperty=nameWithType&gt;</ph> class or the high-performance span-based <ph id=\"ph2\">&lt;xref:System.IO.Compression.BrotliEncoder?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.IO.Compression.BrotliDecoder?displayProperty=nameWithType&gt;</ph> classes.","pos":[10753,11050],"source":" You can use the stream-based <xref:System.IO.Compression.BrotliStream?displayProperty=nameWithType> class or the high-performance span-based <xref:System.IO.Compression.BrotliEncoder?displayProperty=nameWithType> and <xref:System.IO.Compression.BrotliDecoder?displayProperty=nameWithType> classes."},{"content":"The following example illustrates compression with the <ph id=\"ph1\">&lt;xref:System.IO.Compression.BrotliStream&gt;</ph> class:","pos":[11051,11154],"source":" The following example illustrates compression with the <xref:System.IO.Compression.BrotliStream> class:"},{"pos":[11249,11510],"content":"The <ph id=\"ph1\">&lt;xref:System.IO.Compression.BrotliStream&gt;</ph> behavior is the same as <ph id=\"ph2\">&lt;xref:System.IO.Compression.DeflateStream&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.IO.Compression.GZipStream&gt;</ph>, which makes it easy to convert code that calls these APIs to <ph id=\"ph4\">&lt;xref:System.IO.Compression.BrotliStream&gt;</ph>.","source":"The <xref:System.IO.Compression.BrotliStream> behavior is the same as <xref:System.IO.Compression.DeflateStream> and <xref:System.IO.Compression.GZipStream>, which makes it easy to convert code that calls these APIs to <xref:System.IO.Compression.BrotliStream>."},{"pos":[11516,11567],"content":"New cryptography APIs and cryptography improvements","linkify":"New cryptography APIs and cryptography improvements","nodes":[{"content":"New cryptography APIs and cryptography improvements","pos":[0,51]}]},{"content":".NET Core 2.1 includes numerous enhancements to the cryptography APIs:","pos":[11569,11639]},{"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.Pkcs.SignedCms?displayProperty=nameWithType&gt;</ph> is available in the System.Security.Cryptography.Pkcs package.","pos":[11643,11785],"source":"<xref:System.Security.Cryptography.Pkcs.SignedCms?displayProperty=nameWithType> is available in the System.Security.Cryptography.Pkcs package."},{"content":"The implementation is the same as the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.Pkcs.SignedCms&gt;</ph> class in the .NET Framework.","pos":[11786,11903],"source":" The implementation is the same as the <xref:System.Security.Cryptography.Pkcs.SignedCms> class in the .NET Framework."},{"pos":[11907,12296],"content":"New overloads of the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHash%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHashString%2A?displayProperty=nameWithType&gt;</ph> methods accept a hash algorithm identifier to enable callers to get certificate thumbprint values using algorithms other than SHA-1.","source":"New overloads of the <xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHash%2A?displayProperty=nameWithType> and <xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHashString%2A?displayProperty=nameWithType> methods accept a hash algorithm identifier to enable callers to get certificate thumbprint values using algorithms other than SHA-1."},{"pos":[12300,12509],"content":"New <ph id=\"ph1\">&lt;xref:System.Span%601&gt;</ph>-based cryptography APIs are available for hashing, HMAC, cryptographic random number generation, asymmetric signature generation, asymmetric signature processing, and RSA encryption.","source":"New <xref:System.Span%601>-based cryptography APIs are available for hashing, HMAC, cryptographic random number generation, asymmetric signature generation, asymmetric signature processing, and RSA encryption."},{"pos":[12513,12697],"content":"The performance of <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes?displayProperty=nameWithType&gt;</ph> has improved by about 15% by using a <ph id=\"ph2\">&lt;xref:System.Span%601&gt;</ph>-based implementation.","source":"The performance of <xref:System.Security.Cryptography.Rfc2898DeriveBytes?displayProperty=nameWithType> has improved by about 15% by using a <xref:System.Span%601>-based implementation."},{"pos":[12701,12829],"content":"The new <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CryptographicOperations?displayProperty=nameWithType&gt;</ph> class includes two new methods:","source":"The new <xref:System.Security.Cryptography.CryptographicOperations?displayProperty=nameWithType> class includes two new methods:"},{"pos":[12835,13111],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CryptographicOperations.FixedTimeEquals%2A&gt;</ph> takes a fixed amount of time to return for any two inputs of the same length, which makes it suitable for use in cryptographic verification to avoid contributing to timing side-channel information.","source":"<xref:System.Security.Cryptography.CryptographicOperations.FixedTimeEquals%2A> takes a fixed amount of time to return for any two inputs of the same length, which makes it suitable for use in cryptographic verification to avoid contributing to timing side-channel information."},{"pos":[13117,13245],"content":"<ph id=\"ph1\">&lt;xref:System.Security.Cryptography.CryptographicOperations.ZeroMemory%2A&gt;</ph> is a memory-clearing routine that cannot be optimized.","source":"<xref:System.Security.Cryptography.CryptographicOperations.ZeroMemory%2A> is a memory-clearing routine that cannot be optimized."},{"pos":[13249,13412],"content":"The static <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RandomNumberGenerator.Fill%2A?displayProperty=nameWithType&gt;</ph> method fills a <ph id=\"ph2\">&lt;xref:System.Span%601&gt;</ph> with random values.","source":"The static <xref:System.Security.Cryptography.RandomNumberGenerator.Fill%2A?displayProperty=nameWithType> method fills a <xref:System.Span%601> with random values."},{"pos":[13416,13539],"content":"The <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.Pkcs.EnvelopedCms?displayProperty=nameWithType&gt;</ph> is now supported on Linux and maxOS.","source":"The <xref:System.Security.Cryptography.Pkcs.EnvelopedCms?displayProperty=nameWithType> is now supported on Linux and maxOS."},{"content":"Elliptic-Curve Diffie-Hellman (ECDH) is now available in the <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.ECDiffieHellman?displayProperty=nameWithType&gt;</ph> class family.","pos":[13543,13698],"source":"Elliptic-Curve Diffie-Hellman (ECDH) is now available in the <xref:System.Security.Cryptography.ECDiffieHellman?displayProperty=nameWithType> class family."},{"content":"The surface area is the same as in the .NET Framework.","pos":[13699,13753]},{"pos":[13757,13973],"content":"The instance returned by <ph id=\"ph1\">&lt;xref:System.Security.Cryptography.RSA.Create%2A?displayProperty=nameWithType&gt;</ph> can encrypt or decrypt with OAEP using a SHA-2 digest, as well as generate or validate signatures using RSA-PSS.","source":"The instance returned by <xref:System.Security.Cryptography.RSA.Create%2A?displayProperty=nameWithType> can encrypt or decrypt with OAEP using a SHA-2 digest, as well as generate or validate signatures using RSA-PSS."},{"pos":[13979,13999],"content":"Sockets improvements","linkify":"Sockets improvements","nodes":[{"content":"Sockets improvements","pos":[0,20]}]},{"content":".NET Core includes a new type, <ph id=\"ph1\">&lt;xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType&gt;</ph>, and a rewritten <ph id=\"ph2\">&lt;xref:System.Net.Http.HttpMessageHandler?displayProperty=nameWithType&gt;</ph>, that form the basis of higher-level networking APIs.","pos":[14001,14244],"source":".NET Core includes a new type, <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType>, and a rewritten <xref:System.Net.Http.HttpMessageHandler?displayProperty=nameWithType>, that form the basis of higher-level networking APIs."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType&gt;</ph>, for example, is the basis of the <ph id=\"ph2\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> implementation.","pos":[14246,14400],"source":"<xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType>, for example, is the basis of the <xref:System.Net.Http.HttpClient> implementation."},{"content":"In previous versions of .NET Core, higher-level APIs were based on native networking implementations.","pos":[14401,14502]},{"content":"The sockets implementation introduced in .NET Core 2.1 has a number of advantages:","pos":[14504,14586]},{"content":"A significant performance improvement when compared with the previous implementation.","pos":[14590,14675]},{"content":"Elimination of platform dependencies, which simplifies deployment and servicing.","pos":[14679,14759]},{"content":"Consistent behavior across all .NET Core platforms.","pos":[14763,14814]},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Http.SocketsHttpHandler&gt;</ph> is the default implementation in .NET Core 2.1.","pos":[14816,14905],"source":"<xref:System.Net.Http.SocketsHttpHandler> is the default implementation in .NET Core 2.1."},{"content":"However, you can configure your application to use the older <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClientHandler&gt;</ph> class by calling the <ph id=\"ph2\">&lt;xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType&gt;</ph> method:","pos":[14906,15103],"source":" However, you can configure your application to use the older <xref:System.Net.Http.HttpClientHandler> class by calling the <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> method:"},{"content":"You can also use an environment variable to opt out of using sockets implementations based on <ph id=\"ph1\">&lt;xref:System.Net.Http.SocketsHttpHandler&gt;</ph>.","pos":[15270,15406],"source":"You can also use an environment variable to opt out of using sockets implementations based on <xref:System.Net.Http.SocketsHttpHandler>."},{"content":"To do this, set the <ph id=\"ph1\">`DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER`</ph> to either <ph id=\"ph2\">`false`</ph> or 0.","pos":[15407,15497],"source":" To do this, set the `DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER` to either `false` or 0."},{"pos":[15499,15791],"content":"On Windows, you can also choose to use <ph id=\"ph1\">&lt;xref:System.Net.Http.WinHttpHandler?displayProperty=nameWithType&gt;</ph>, which relies on a native implementation, or the <ph id=\"ph2\">&lt;xref:System.Net.Http.SocketsHttpHandler&gt;</ph> class by passing an instance of the class to the <ph id=\"ph3\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> constructor.","source":"On Windows, you can also choose to use <xref:System.Net.Http.WinHttpHandler?displayProperty=nameWithType>, which relies on a native implementation, or the <xref:System.Net.Http.SocketsHttpHandler> class by passing an instance of the class to the <xref:System.Net.Http.HttpClient> constructor."},{"content":"On Linux and macOS, you can only configure <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> on a per-process basis.","pos":[15793,15893],"source":"On Linux and macOS, you can only configure <xref:System.Net.Http.HttpClient> on a per-process basis."},{"content":"On Linux, you need to deploy <bpt id=\"p1\">[</bpt>libcurl<ept id=\"p1\">](https://curl.haxx.se/libcurl/)</ept> if you want to use the old <ph id=\"ph1\">&lt;xref:System.Net.Http.HttpClient&gt;</ph> implementation.","pos":[15894,16040],"source":" On Linux, you need to deploy [libcurl](https://curl.haxx.se/libcurl/) if you want to use the old <xref:System.Net.Http.HttpClient> implementation."},{"content":"(It is installed with .NET Core 2.0.)","pos":[16041,16078]},{"pos":[16083,16091],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[16095,16130],"content":"<bpt id=\"p1\">[</bpt>What's new in .NET Core<ept id=\"p1\">](index.md)</ept>","source":"[What's new in .NET Core](index.md)"},{"pos":[16133,16196],"content":"<bpt id=\"p1\">[</bpt>New features in EF Core 2.1<ept id=\"p1\">](/ef/core/what-is-new/ef-core-2.1)</ept>","source":"[New features in EF Core 2.1](/ef/core/what-is-new/ef-core-2.1)"},{"pos":[16199,16260],"content":"<bpt id=\"p1\">[</bpt>What's new in ASP.NET Core 2.1<ept id=\"p1\">](/aspnet/core/aspnetcore-2.1)</ept>","source":"[What's new in ASP.NET Core 2.1](/aspnet/core/aspnetcore-2.1)"}]}