{"content":"---\ntitle: \"Functional Programming vs. Imperative Programming (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\n---\n# Functional Programming vs. Imperative Programming (C#)\nThis topic compares and contrasts functional programming with more traditional imperative (procedural) programming.  \n  \n## Functional Programming vs. Imperative Programming  \n The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving. Functional programming is a form of *declarative programming*. In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.  \n  \n With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal. This is sometimes referred to as *algorithmic* programming. In contrast, a functional approach involves composing the problem as a set of functions to be executed. You define carefully the input to each function, and what each function returns. The following table describes some of the general differences between these two approaches.  \n  \n|Characteristic|Imperative approach|Functional approach|  \n|--------------------|-------------------------|-------------------------|  \n|Programmer focus|How to perform tasks (algorithms) and how to track changes in state.|What information is desired and what transformations are required.|  \n|State changes|Important.|Non-existent.|  \n|Order of execution|Important.|Low importance.|  \n|Primary flow control|Loops, conditionals, and function (method) calls.|Function calls, including recursion.|  \n|Primary manipulation unit|Instances of structures or classes.|Functions as first-class objects and data collections.|  \n  \n Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms. For example, most languages that contain function pointers can be used to credibly support functional programming. Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference. LINQ technology is a form of declarative, functional programming.  \n  \n## Functional Programming Using XSLT  \n Many XSLT developers are familiar with the pure functional approach. The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation. The order of execution is completely de-emphasized. XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity). However, although XSLT is an effective tool, some of its characteristics are not optimal. For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain. Also, the heavy reliance on recursion for flow control can result in code that is hard to read. For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).  \n  \n However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another. Pure functional programming with LINQ to XML is similar in many ways to XSLT. However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.  \n  \n## Advantages of Pure Functions  \n The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless. These characteristics bring a number of benefits, including the following:  \n  \n-   Increased readability and maintainability. This is because each function is designed to accomplish a specific task given its arguments. The function does not rely on any external state.  \n  \n-   Easier reiterative development. Because the code is easier to refactor, changes to design are often easier to implement. For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation. If you refactor through a pure method, you can call your pure method at will without worrying about side effects.  \n  \n-   Easier testing and debugging. Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.  \n  \n## Transitioning for OOP Developers  \n In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style. To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.  \n  \n To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts. The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.  \n  \n In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections. Functional programming avoids state and mutable data, and instead emphasizes the application of functions.  \n  \n Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches. A developer can choose which approach is most appropriate for a particular scenario. In fact, programs often combine both approaches.  \n  \n## See Also  \n [Introduction to Pure Functional Transformations (C#)](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)   \n [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md)   \n [Refactoring Into Pure Functions (C#)](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)","nodes":[{"pos":[4,361],"nodes":[{"content":"Functional Programming vs. Imperative Programming (C#) | Microsoft Docs","nodes":[{"pos":[0,71],"content":"Functional Programming vs. Imperative Programming (C#) | Microsoft Docs","nodes":[{"content":"Functional Programming vs. Imperative Programming (C#) | Microsoft Docs","pos":[0,71]}]}],"pos":[6,80],"yaml":true}],"content":"title: \"Functional Programming vs. Imperative Programming (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n","yamlblock":true},{"pos":[368,422],"content":"Functional Programming vs. Imperative Programming (C#)","linkify":"Functional Programming vs. Imperative Programming (C#)","nodes":[{"content":"Functional Programming vs. Imperative Programming (C#)","pos":[0,54]}]},{"content":"This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.","pos":[423,538]},{"pos":[547,596],"content":"Functional Programming vs. Imperative Programming","linkify":"Functional Programming vs. Imperative Programming","nodes":[{"content":"Functional Programming vs. Imperative Programming","pos":[0,49]}]},{"content":"The <bpt id=\"p1\">*</bpt>functional programming<ept id=\"p1\">*</ept> paradigm was explicitly created to support a pure functional approach to problem solving.","pos":[600,718],"source":"The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving."},{"content":"Functional programming is a form of <bpt id=\"p1\">*</bpt>declarative programming<ept id=\"p1\">*</ept>.","pos":[719,781],"source":" Functional programming is a form of *declarative programming*."},{"content":"In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support <bpt id=\"p1\">*</bpt>imperative<ept id=\"p1\">*</ept> (procedural) programming.","pos":[782,990],"source":" In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming."},{"content":"With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.","pos":[997,1145]},{"content":"This is sometimes referred to as <bpt id=\"p1\">*</bpt>algorithmic<ept id=\"p1\">*</ept> programming.","pos":[1146,1205],"source":" This is sometimes referred to as *algorithmic* programming."},{"content":"In contrast, a functional approach involves composing the problem as a set of functions to be executed.","pos":[1206,1309]},{"content":"You define carefully the input to each function, and what each function returns.","pos":[1310,1390]},{"content":"The following table describes some of the general differences between these two approaches.","pos":[1391,1482]},{"content":"Characteristic","pos":[1489,1503]},{"content":"Imperative approach","pos":[1504,1523]},{"content":"Functional approach","pos":[1524,1543]},{"content":"Programmer focus","pos":[1625,1641]},{"content":"How to perform tasks (algorithms) and how to track changes in state.","pos":[1642,1710]},{"content":"What information is desired and what transformations are required.","pos":[1711,1777]},{"content":"State changes","pos":[1782,1795]},{"content":"Important.","pos":[1796,1806]},{"content":"Non-existent.","pos":[1807,1820]},{"content":"Order of execution","pos":[1825,1843]},{"content":"Important.","pos":[1844,1854]},{"content":"Low importance.","pos":[1855,1870]},{"content":"Primary flow control","pos":[1875,1895]},{"content":"Loops, conditionals, and function (method) calls.","pos":[1896,1945]},{"content":"Function calls, including recursion.","pos":[1946,1982]},{"content":"Primary manipulation unit","pos":[1987,2012]},{"content":"Instances of structures or classes.","pos":[2013,2048]},{"content":"Functions as first-class objects and data collections.","pos":[2049,2103]},{"content":"Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.","pos":[2111,2266]},{"content":"For example, most languages that contain function pointers can be used to credibly support functional programming.","pos":[2267,2381]},{"content":"Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.","pos":[2382,2519]},{"content":"LINQ technology is a form of declarative, functional programming.","pos":[2520,2585]},{"pos":[2594,2627],"content":"Functional Programming Using XSLT","linkify":"Functional Programming Using XSLT","nodes":[{"content":"Functional Programming Using XSLT","pos":[0,33]}]},{"content":"Many XSLT developers are familiar with the pure functional approach.","pos":[2631,2699]},{"content":"The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.","pos":[2700,2822]},{"content":"The order of execution is completely de-emphasized.","pos":[2823,2874]},{"content":"XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).","pos":[2875,3046]},{"content":"However, although XSLT is an effective tool, some of its characteristics are not optimal.","pos":[3047,3136]},{"content":"For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.","pos":[3137,3258]},{"content":"Also, the heavy reliance on recursion for flow control can result in code that is hard to read.","pos":[3259,3354]},{"content":"For more information about XSLT, see <bpt id=\"p1\">[</bpt>XSLT Transformations<ept id=\"p1\">](../../../../standard/data/xml/xslt-transformations.md)</ept>.","pos":[3355,3470],"source":" For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md)."},{"content":"However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.","pos":[3477,3595]},{"content":"Pure functional programming with LINQ to XML is similar in many ways to XSLT.","pos":[3596,3673]},{"content":"However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.","pos":[3674,3845]},{"pos":[3854,3882],"content":"Advantages of Pure Functions","linkify":"Advantages of Pure Functions","nodes":[{"content":"Advantages of Pure Functions","pos":[0,28]}]},{"content":"The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.","pos":[3886,4040]},{"content":"These characteristics bring a number of benefits, including the following:","pos":[4041,4115]},{"content":"Increased readability and maintainability.","pos":[4125,4167]},{"content":"This is because each function is designed to accomplish a specific task given its arguments.","pos":[4168,4260]},{"content":"The function does not rely on any external state.","pos":[4261,4310]},{"content":"Easier reiterative development.","pos":[4320,4351]},{"content":"Because the code is easier to refactor, changes to design are often easier to implement.","pos":[4352,4440]},{"content":"For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.","pos":[4441,4582]},{"content":"If you refactor through a pure method, you can call your pure method at will without worrying about side effects.","pos":[4583,4696]},{"content":"Easier testing and debugging.","pos":[4706,4735]},{"content":"Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.","pos":[4736,4914]},{"pos":[4923,4955],"content":"Transitioning for OOP Developers","linkify":"Transitioning for OOP Developers","nodes":[{"content":"Transitioning for OOP Developers","pos":[0,32]}]},{"content":"In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.","pos":[4959,5090]},{"content":"To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.","pos":[5091,5226]},{"content":"To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.","pos":[5233,5362]},{"content":"The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.","pos":[5363,5539]},{"content":"In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.","pos":[5546,5704]},{"content":"Functional programming avoids state and mutable data, and instead emphasizes the application of functions.","pos":[5705,5811]},{"content":"Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.","pos":[5818,5965]},{"content":"A developer can choose which approach is most appropriate for a particular scenario.","pos":[5966,6050]},{"content":"In fact, programs often combine both approaches.","pos":[6051,6099]},{"pos":[6108,6116],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Introduction to Pure Functional Transformations (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)</ept><ph id=\"ph1\"> </ph>","pos":[6120,6278],"source":"[Introduction to Pure Functional Transformations (C#)](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md) "},{"content":"<bpt id=\"p1\">[</bpt>XSLT Transformations<ept id=\"p1\">](../../../../standard/data/xml/xslt-transformations.md)</ept><ph id=\"ph1\"> </ph>","pos":[6282,6360],"source":"[XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md) "},{"content":"<bpt id=\"p1\">[</bpt>Refactoring Into Pure Functions (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)</ept>","pos":[6364,6489],"source":"[Refactoring Into Pure Functions (C#)](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)"}]}