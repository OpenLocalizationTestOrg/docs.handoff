<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="xml-and-ado-net-types-in-data-contracts.md" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1053a543a23ed36a5c06c45044c8fdbe25a60538</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\xml-and-ado-net-types-in-data-contracts.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e626bf04989dc3ccd984d3a1d19ba9501fa9b97a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fef3b11299439dc85c938f50d96f5a0d5bb58666</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>XML and ADO.NET Types in Data Contracts</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>XML and ADO.NET Types in Data Contracts</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Supported types are <ph id="ph1">&lt;xref:System.Xml.XmlElement&gt;</ph>, arrays of <ph id="ph2">&lt;xref:System.Xml.XmlNode&gt;</ph> (but not the <ph id="ph3">`XmlNode`</ph> type itself), as well as types that implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> type, as well as typed datasets, are commonly used in database programming.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>These types implement the <ph id="ph1">`IXmlSerializable`</ph> interface and are therefore serializable in the data contract model.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Some special considerations for these types are listed at the end of this topic.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>XML Types</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Xml Element</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`XmlElement`</ph> type is serialized using its XML contents.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example, using the following type.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This is serialized to XML as follows:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Notice that a wrapper data member element <ph id="ph1">`&lt;myDataMember&gt;`</ph> is still present.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>There is no way of removing this element in the data contract model.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The serializers that handle this model (the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>) may emit special attributes into this wrapper element.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>These attributes include the standard XML Schema Instance "nil" attribute (allowing the <ph id="ph1">`XmlElement`</ph> to be <ph id="ph2">`null`</ph>) and the "type" attribute (allowing <ph id="ph3">`XmlElement`</ph> to be used polymorphically).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>These attributes may be emitted to support using the <ph id="ph1">`XmlElement`</ph> with the object graph preservation mode enabled, or with the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>(For more information about the object graph preservation mode, see <bpt id="p1">[</bpt>Serialization and Deserialization<ept id="p1">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Arrays or collections of <ph id="ph1">`XmlElement`</ph> are allowed and are handled as any other array or collection.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to <ph id="ph1">`&lt;myDataMember&gt;`</ph> in the preceding example) for each <ph id="ph2">`XmlElement`</ph> in the array.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>On deserialization, an <ph id="ph1">`XmlElement`</ph> is created by the deserializer from the incoming XML.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A valid parent <ph id="ph1">&lt;xref:System.Xml.XmlDocument&gt;</ph> is provided by the deserializer.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Make sure that the XML fragment that is deserialized to an <ph id="ph1">`XmlElement`</ph> defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This is a concern only when using the <ph id="ph1">`DataContractSerializer`</ph> to access XML from a different (non-<ph id="ph2">`DataContractSerializer`</ph>) source.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When used with the <ph id="ph1">`DataContractSerializer`</ph>, the <ph id="ph2">`XmlElement`</ph> may be assigned polymorphically, but only to a data member of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Even though it implements <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph>, an <ph id="ph2">`XmlElement`</ph> cannot be used as a collection type and cannot be assigned to an <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> data member.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>As with all polymorphic assignments, the <ph id="ph1">`DataContractSerializer`</ph> emits the data contract name in the resulting XML â€“ in this case, it is "XmlElement" in the "<ph id="ph2">http://schemas.datacontract.org/2004/07/System.Xml</ph>" namespace.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>With the <ph id="ph1">`NetDataContractSerializer`</ph>, any valid polymorphic assignment of <ph id="ph2">`XmlElement`</ph> (to <ph id="ph3">`Object`</ph> or <ph id="ph4">`IEnumerable`</ph>) is supported.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Do not attempt to use either of the serializers with types derived from <ph id="ph1">`XmlElement`</ph>, whether they are assigned polymorphically or not.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Array of XmlNode</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Using arrays of <ph id="ph1">&lt;xref:System.Xml.XmlNode&gt;</ph> is very similar to using <ph id="ph2">`XmlElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Using arrays of <ph id="ph1">`XmlNode`</ph> gives you more flexibility than using <ph id="ph2">`XmlElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can write multiple elements inside the data member wrapping element.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Finally, you can put attributes into the wrapping data member element.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>All this can be achieved by populating the array of <ph id="ph1">`XmlNode`</ph> with specific derived classes of <ph id="ph2">`XmlNode`</ph> such as <ph id="ph3">&lt;xref:System.Xml.XmlAttribute&gt;</ph>, <ph id="ph4">`XmlElement`</ph> or <ph id="ph5">&lt;xref:System.Xml.XmlComment&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For example, using the following type.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When serialized, the resulting XML is similar to the following code.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note that the data member wrapper element <ph id="ph1">`&lt;myDataMember&gt;`</ph> contains an attribute, a comment, and two elements.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>These are the four <ph id="ph1">`XmlNode`</ph> instances that were serialized.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">`XmlNode`</ph> that results in invalid XML cannot be serialized.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, an array of two <ph id="ph1">`XmlNode`</ph> instances where the first one is an <ph id="ph2">`XmlElement`</ph> and the second one is an <ph id="ph3">&lt;xref:System.Xml.XmlAttribute&gt;</ph> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>On deserialization of an array of <ph id="ph1">`XmlNode`</ph>, nodes are created and populated with information from the incoming XML.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>A valid parent <ph id="ph1">&lt;xref:System.Xml.XmlDocument&gt;</ph> is provided by the deserializer.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of <ph id="ph1">`XmlNode`</ph> just like it does to deserializing <ph id="ph2">`XmlElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When using the serializers with object graph preservation turned on, object equality is only preserved on the level of <ph id="ph1">`XmlNode`</ph> arrays, not individual <ph id="ph2">`XmlNode`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Do not attempt to serialize an array of <ph id="ph1">`XmlNode`</ph> where one or more of the nodes is set to <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>It is permitted for the entire array member to be <ph id="ph1">`null`</ph>, but not for any individual <ph id="ph2">`XmlNode`</ph> contained in the array.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>On deserialization, the entire array member also becomes null.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Only regular arrays of <ph id="ph1">`XmlNode`</ph> are treated specially by the serializer.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Data members declared as other collection types that contain <ph id="ph1">`XmlNode`</ph>, or data members declared as arrays of types derived from <ph id="ph2">`XmlNode`</ph>, are not treated specially.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Arrays or collections of arrays of <ph id="ph1">`XmlNode`</ph> are allowed.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>There is a wrapper element for the entire collection, and a separate wrapper element (similar to <ph id="ph1">`&lt;myDataMember&gt;`</ph> in the preceding example) for each array of <ph id="ph2">`XmlNode`</ph> in the outer array or collection.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Populating a data member of type <ph id="ph1">&lt;xref:System.Array&gt;</ph> of <ph id="ph2">`Object`</ph> or <ph id="ph3">`Array`</ph> of <ph id="ph4">`IEnumerable`</ph> with <ph id="ph5">`XmlNode`</ph> instances does not result in the data member being treated as an <ph id="ph6">`Array`</ph> of <ph id="ph7">`XmlNode`</ph> instances.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Each array member is serialized separately.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When used with the <ph id="ph1">`DataContractSerializer`</ph>, arrays of <ph id="ph2">`XmlNode`</ph> can be assigned polymorphically, but only to a data member of type <ph id="ph3">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Even though it implements <ph id="ph1">`IEnumerable`</ph>, an array of <ph id="ph2">`XmlNode`</ph> cannot be used as a collection type and be assigned to an <ph id="ph3">`IEnumerable`</ph> data member.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>As with all polymorphic assignments, the <ph id="ph1">`DataContractSerializer`</ph> emits the data contract name in the resulting XML â€“ in this case, it is "ArrayOfXmlNode" in the "<ph id="ph2">http://schemas.datacontract.org/2004/07/System.Xml</ph>" namespace.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When used with the <ph id="ph1">`NetDataContractSerializer`</ph>, any valid assignment of an <ph id="ph2">`XmlNode`</ph> array is supported.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Schema Considerations</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For details about the schema mapping of XML types, see <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>This section provides a summary of the important points.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>A data member of type <ph id="ph1">`XmlElement`</ph> is mapped to an element defined using the following anonymous type.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A data member of type Array of <ph id="ph1">`XmlNode`</ph> is mapped to an element defined using the following anonymous type.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Types Implementing the IXmlSerializable Interface</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Types that implement the <ph id="ph1">`IXmlSerializable`</ph> interface are fully supported by the <ph id="ph2">`DataContractSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute should always be applied to these types to control their schema.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>There are three varieties of types that implement <ph id="ph1">`IXmlSerializable`</ph>: types that represent arbitrary content, types that represent a single element, and legacy <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> types.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Content types use a schema provider method specified by the <ph id="ph1">`XmlSchemaProviderAttribute`</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The method does not return <ph id="ph1">`null`</ph>, and the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the attribute is left at its default value of <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This is the most common usage of <ph id="ph1">`IXmlSerializable`</ph> types.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Element types are used when an <ph id="ph1">`IXmlSerializable`</ph> type must control its own root element name.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>To mark a type as an element type, either set the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute to <ph id="ph3">`true`</ph> or return null from the schema provider method.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Having a schema provider method is optional for element types â€“ you may specify null instead of the method name in the <ph id="ph1">`XmlSchemaProviderAttribute`</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>However, if <ph id="ph1">`IsAny`</ph> is <ph id="ph2">`true`</ph> and a schema provider method is specified, the method must return null.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Legacy <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> types are <ph id="ph2">`IXmlSerializable`</ph> types that are not marked with the <ph id="ph3">`XmlSchemaProviderAttribute`</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Instead, they rely on the <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A&gt;</ph> method for schema generation.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This pattern is used for the <ph id="ph1">`DataSet`</ph> type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Do not rely on this pattern and always apply the <ph id="ph1">`XmlSchemaProviderAttribute`</ph> to your <ph id="ph2">`IXmlSerializable`</ph> types.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>IXmlSerializable Content Types</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When serializing a data member of a type that implements <ph id="ph1">`IXmlSerializable`</ph> and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> implementation can write any XML, including adding attributes to the wrapper element.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>After <ph id="ph1">`WriteXml`</ph> is done, the serializer closes the element.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When deserializing a data member of a type that implements <ph id="ph1">`IXmlSerializable`</ph> and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The method must read the entire element, including the start and end tags.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Make sure your <ph id="ph1">`ReadXml`</ph> code handles the case where the element is empty.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Additionally, your <ph id="ph1">`ReadXml`</ph> implementation should not rely on the wrapper element being named a particular way.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The name is chosen by the serializer can vary.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It is permitted to assign <ph id="ph1">`IXmlSerializable`</ph> content types polymorphically, for example, to data members of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It is also permitted for the type instances to be null.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to use <ph id="ph1">`IXmlSerializable`</ph> types with object graph preservation enabled and with the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Attributes to Ignore when Implementing ReadXml</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Before passing control to your <ph id="ph1">`ReadXml`</ph> code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if "nil" is <ph id="ph1">`true`</ph>, a null value is deserialized and <ph id="ph2">`ReadXml`</ph> is not called.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The polymorphically assigned typeâ€™s implementation of <ph id="ph1">`ReadXml`</ph> is called.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In any case, a <ph id="ph1">`ReadXml`</ph> implementation should ignore these special attributes because they are handled by the deserializer.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Schema Considerations for IXmlSerializable Content Types</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>When exporting schema an <ph id="ph1">`IXmlSerializable`</ph> content type, the schema provider method is called.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> is passed to the schema provider method.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The method can add any valid schema to the schema set.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The schema set contains the schema that is already known at the time when schema export occurs.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>When the schema provider method must add an item to the schema set, it must determine if an <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchema&gt;</ph> with the appropriate namespace already exists in the set.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If it does, the schema provider method must add the new item to the existing <ph id="ph1">`XmlSchema`</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Otherwise, it must create a new <ph id="ph1">`XmlSchema`</ph> instance.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This is important if arrays of <ph id="ph1">`IXmlSerializable`</ph> types are being used.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, if you have an <ph id="ph1">`IXmlSerializable`</ph> type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>In addition to adding types to the <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph>, the schema provider method for content types must return a non-null value.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>It can return an <ph id="ph1">&lt;xref:System.Xml.XmlQualifiedName&gt;</ph> that specifies the name of the schema type to use for the given <ph id="ph2">`IXmlSerializable`</ph> type.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This qualified name also serves as the data contract name and namespace for the type.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>However, it is expected that by the time all related types are exported (the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A&gt;</ph> method is called for all relevant types on the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter&gt;</ph> and the <ph id="ph3">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A&gt;</ph> property is accessed), the type exists in the schema set.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Accessing the <ph id="ph1">`Schemas`</ph> property before all relevant <ph id="ph2">`Export`</ph> calls have been made can result in an <ph id="ph3">&lt;xref:System.Xml.Schema.XmlSchemaException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For more information about the export process, see <bpt id="p1">[</bpt>Exporting Schemas from Classes<ept id="p1">](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The schema provider method can also return the <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaType&gt;</ph> to use.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The type may or may not be anonymous.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If it is anonymous, the schema for the <ph id="ph1">`IXmlSerializable`</ph> type is exported as an anonymous type every time the <ph id="ph2">`IXmlSerializable`</ph> type is used as a data member.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IXmlSerializable`</ph> type still has a data contract name and namespace.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>(This is determined as described in <bpt id="p1">[</bpt>Data Contract Names<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept> except that the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the <ph id="ph2">`XmlSchemaSet`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This case is equivalent to returning the <ph id="ph1">`XmlQualifiedName`</ph> of the type.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Additionally, a global element declaration is exported for the type.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the type does not have the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlRootAttribute&gt;</ph> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The only exception to this is the schema namespace ("<ph id="ph1">http://www.w3.org/2001/XMLSchema</ph>") â€“ if the typeâ€™s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>If the type has the <ph id="ph1">`XmlRootAttribute`</ph> attribute applied to it, the global element declaration is exported using the following: <ph id="ph2">&lt;xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The defaults with <ph id="ph1">`XmlRootAttribute`</ph> applied are the data contract name, a blank namespace and "nillable" being true.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The same global element declaration rules apply to legacy dataset types.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`XmlRootAttribute`</ph> cannot override global element declarations added through custom code, either added to the <ph id="ph2">`XmlSchemaSet`</ph> using the schema provider method or through <ph id="ph3">`GetSchema`</ph> for legacy dataset types.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>IXmlSerializable Element Types</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`IXmlSerializable`</ph> element types have either the <ph id="ph2">`IsAny`</ph> property set to <ph id="ph3">`true`</ph> or have their schema provider method return <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>However, there are some important differences:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`WriteXml`</ph> implementation is expected to write exactly one element (which could of course contain multiple child elements).</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The element may be empty.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ReadXml`</ph> implementation should not read the wrapper element.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>It is expected to read the one element that <ph id="ph1">`WriteXml`</ph> produces.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling <ph id="ph1">`WriteXml`</ph>, as with content types.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that <ph id="ph1">`WriteXml`</ph> writes, unless a root name and namespace were explicitly specified when constructing the serializer in the <ph id="ph2">`DataContractSerializer`</ph> or <ph id="ph3">`NetDataContractSerializer`</ph> constructors.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Serialization and Deserialization<ept id="p1">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>When serializing an element type at the top level without specifying the root name and namespace at construction time, <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A&gt;</ph> essentially does nothing and <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A&gt;</ph> calls <ph id="ph4">`WriteXml`</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Also, object graph preservation cannot enabled and the <ph id="ph1">`NetDataContractSerializer`</ph> cannot be used.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>When deserializing an element type at the top level without specifying the root name and namespace at construction time, <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A&gt;</ph> returns <ph id="ph2">`true`</ph> if it can find the start of any element.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> with the <ph id="ph2">`verifyObjectName`</ph> parameter set to <ph id="ph3">`true`</ph> behaves in the same way as <ph id="ph4">`IsStartObject`</ph> before actually reading the object.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ReadObject`</ph> then passes control to <ph id="ph2">`ReadXml`</ph> method.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The schema exported for element types is the same as for the <ph id="ph1">`XmlElement`</ph> type as described in an earlier section, except that the schema provider method can add any additional schema to the <ph id="ph2">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> as with content types.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`XmlRootAttribute`</ph> attribute with element types is not allowed, and global element declarations are never emitted for these types.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Differences from the XmlSerializer</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`IXmlSerializable`</ph> interface and the <ph id="ph2">`XmlSchemaProviderAttribute`</ph> and <ph id="ph3">`XmlRootAttribute`</ph> attributes are also understood by the <ph id="ph4">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> .</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>However, there are some differences in how these are treated in the data contract model.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The important differences are summarized in the following:</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The schema provider method must be public to be usable in the <ph id="ph1">`XmlSerializer`</ph>, but does not have to be public to be usable in the data contract model.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The schema provider method is called when <ph id="ph1">`IsAny`</ph> is true in the data contract model but not with the <ph id="ph2">`XmlSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`XmlRootAttribute`</ph> attribute is not present for content or legacy dataset types, the <ph id="ph2">`XmlSerializer`</ph> exports a global element declaration in the blank namespace.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>In the data contract model, the namespace used is normally the data contract namespace as described earlier.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Be aware of these differences when creating types that are used with both serialization technologies.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Importing IXmlSerializable Schema</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>When importing a schema generated from <ph id="ph1">`IXmlSerializable`</ph> types, there are a few possibilities:</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The generated schema may be a valid data contract schema as described in <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>In this case, schema can be imported as usual and regular data contract types are generated.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The generated schema may not be a valid data contract schema.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>In this case, you can import the schema as <ph id="ph1">`IXmlSerializable`</ph> types.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>This import mode is not on by default but can easily be enabled â€“ for example, with the <ph id="ph1">`/importXmlTypes`</ph> command-line switch to the <bpt id="p1">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id="p1">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>This is described in detail in the <bpt id="p1">[</bpt>Importing Schema to Generate Classes<ept id="p1">](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Note that you must work directly with the XML for your type instances.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You may also consider using a different serialization technology that supports a wider range of schema â€“ see the topic on using the <ph id="ph1">`XmlSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>You may want to reuse your existing <ph id="ph1">`IXmlSerializable`</ph> types in the proxy instead of generating new ones.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>This corresponds to using the <ph id="ph1">`/reference`</ph> switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Representing Arbitrary XML in Data Contracts</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`XmlElement`</ph>, Array of <ph id="ph2">`XmlNode`</ph> and <ph id="ph3">`IXmlSerializable`</ph> types allow you to inject arbitrary XML into the data contract model.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`DataContractSerializer`</ph> and <ph id="ph2">`NetDataContractSerializer`</ph> pass this XML content on to the XML writer in use, without interfering in the process.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>However, the XML writers may enforce certain restrictions on the XML that they write.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Specifically, here are some important examples:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The XML writers do not typically allow an XML document declaration (for example, <ph id="ph1">\&lt;</ph>?xml version=â€™1.0â€™ ?&gt;) in the middle of writing another document.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You cannot take a full XML document and serialize it as an <ph id="ph1">`Array`</ph> of <ph id="ph2">`XmlNode`</ph> data member.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>All of the XML writers supplied with WCF reject XML processing instructions (<ph id="ph1">\&lt;</ph>?</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>â€¦</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>?&gt;) and document type definitions (<ph id="ph1">\&lt;</ph>!</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>â€¦</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>&gt;), because they are not allowed in SOAP messages.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Again, you can use your own encoding mechanism to get around this restriction.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>When implementing <ph id="ph1">`WriteXml`</ph>, avoid calling <ph id="ph2">&lt;xref:System.Xml.XmlWriter.WriteRaw%2A&gt;</ph> method on the XML writer.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use <ph id="ph1">`WriteRaw`</ph> such that the result is usable in any encoding.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>When implementing <ph id="ph1">`WriteXml`</ph>, avoid using the <ph id="ph2">&lt;xref:System.Xml.XmlWriter.WriteEntityRef%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Xml.XmlWriter.WriteNmToken%2A&gt;</ph> methods that are unsupported on the XML writers supplied with WCF.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Using DataSet, Typed DataSet and DataTable</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Using these types is fully supported in the data contract model.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>When using these types, consider the following points:</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The schema for these types (especially <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Additionally, using the <ph id="ph1">`DataSet`</ph> type may have performance implications.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Finally, it may make it more difficult for you to version your application in the future.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Consider using explicitly defined data contract types instead of <ph id="ph1">`DataSet`</ph> types in your contracts.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>When importing <ph id="ph1">`DataSet`</ph> or <ph id="ph2">`DataTable`</ph> schema, it is important to reference these types.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the <ph id="ph1">`/reference`</ph> switch.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If importing typed dataset schema, you must reference the typed datasetâ€™s type.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>With Svcutil.exe, pass the location of the typed datasetâ€™s assembly to the <ph id="ph1">`/reference`</ph> switch.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>For more information about referencing types, see the <bpt id="p1">[</bpt>Importing Schema to Generate Classes<ept id="p1">](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Support for typed DataSets in the data contract model is limited.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Typed DataSets can be serialized and deserialized and can export their schema.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>You can point to an existing typed DataSet by using the <ph id="ph1">`/r`</ph> switch on Svcutil.exe.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>If you attempt to use a Svcutil.exe without the <ph id="ph1">`/r`</ph> switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the <ph id="ph1">`/d`</ph> switch on the service), compile the types, and then point to them using the <ph id="ph2">`/r`</ph> switch on Svcutil.exe.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept></source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types Supported by the Data Contract Serializer<ept id="p1">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>