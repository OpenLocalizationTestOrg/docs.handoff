<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-ffc129d" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">08aae2410404c92e0aa934f8c4b904c2b8f42bfc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\importing-schema-to-generate-classes.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">986e593398c2bb9c50c6fd337711b076fc8fef17</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d0195738bf55bae4c658c89aca8422ca7d33db8b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Importing Schema to Generate Classes | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Importing Schema to Generate Classes</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>To generate classes from schemas that are usable with <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph>, use the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic describes the process and variations.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The Import Process</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The schema import process starts with an <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> and produces a <ph id="ph2">&lt;xref:System.CodeDom.CodeCompileUnit&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`XmlSchemaSet`</ph> is a part of the <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph>’s Schema Object Model (SOM) that represents a set of XML Schema definition language (XSD) schema documents.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>To create an <ph id="ph1">`XmlSchemaSet`</ph> object from a set of XSD documents, deserialize each document into an <ph id="ph2">&lt;xref:System.Xml.Schema.XmlSchema&gt;</ph> object (using the <ph id="ph3">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>) and add these objects to a new <ph id="ph4">`XmlSchemaSet`</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CodeCompileUnit`</ph> is part of the <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph>’s Code Document Object Model (CodeDOM) that represents <ph id="ph3">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> code in an abstract way.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To generate the actual code from a <ph id="ph1">`CodeCompileUnit`</ph>, use a subclass of the <ph id="ph2">&lt;xref:System.CodeDom.Compiler.CodeDomProvider&gt;</ph> class, such as the <ph id="ph3">&lt;xref:Microsoft.CSharp.CSharpCodeProvider&gt;</ph> or <ph id="ph4">&lt;xref:Microsoft.VisualBasic.VBCodeProvider&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>To import a schema</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Create an instance of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Optional.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Pass a <ph id="ph1">`CodeCompileUnit`</ph> in the constructor.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The types generated during schema import are added to this <ph id="ph1">`CodeCompileUnit`</ph> instance instead of starting with a blank <ph id="ph2">`CodeCompileUnit`</ph>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Optional.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Call one of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The method determines whether the given schema is a valid data contract schema and can be imported.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`CanImport`</ph> method has the same overloads as <ph id="ph2">`Import`</ph> (the next step).</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Call one of the overloaded <ph id="ph1">`Import`</ph> methods, for example, the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The simplest overload takes an <ph id="ph1">`XmlSchemaSet`</ph> and imports all types, including anonymous types, found in that schema set.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Other overloads allow you to specify the XSD type or a list of types to import (in the form of an <ph id="ph1">&lt;xref:System.Xml.XmlQualifiedName&gt;</ph> or a collection of <ph id="ph2">`XmlQualifiedName`</ph> objects).</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this case, only the specified types are imported.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>An overload takes an <ph id="ph1">&lt;xref:System.Xml.Schema.XmlSchemaElement&gt;</ph> that imports a particular element out of the <ph id="ph2">`XmlSchemaSet`</ph>, as well as its associated type (whether it is anonymous or not).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This overload returns an <ph id="ph1">`XmlQualifiedName`</ph>, which represents the data contract name of the type generated for this element.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Multiple calls of the <ph id="ph1">`Import`</ph> method result in multiple items being added to the same <ph id="ph2">`CodeCompileUnit`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A type is not generated into the <ph id="ph1">`CodeCompileUnit`</ph> if it already exists there.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">`Import`</ph> multiple times on the same <ph id="ph2">`XsdDataContractImporter`</ph> instead of using multiple <ph id="ph3">`XsdDataContractImporter`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This is the recommended way to avoid duplicate types being generated.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If there is a failure during import, the <ph id="ph1">`CodeCompileUnit`</ph> will be in an unpredictable state.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Using a <ph id="ph1">`CodeCompileUnit`</ph> resulting from a failed import could expose you to security vulnerabilities.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Access the <ph id="ph1">`CodeCompileUnit`</ph> through the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Import Options: Customizing the Generated Types</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can set the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph> to an instance of the <ph id="ph3">&lt;xref:System.Runtime.Serialization.ImportOptions&gt;</ph> class to control various aspects of the import process.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A number of options directly influence the types that are generated.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Controlling the Access Level (GenerateInternal or the /internal switch)</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This corresponds to the <bpt id="p1">**</bpt>/internal<ept id="p1">**</ept> switch on the <bpt id="p2">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id="p2">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Normally, public types are generated from schema, with private fields and matching public data member properties.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To generate internal types instead, set the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following example shows a schema transformed into an internal class when the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A&gt;</ph> property is set to <ph id="ph2">`true.`</ph></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_SchemaImportExport#2<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_SchemaImportExport#2<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Controlling Namespaces (Namespaces or the /namespace switch)</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This corresponds to the <bpt id="p1">**</bpt>/namespace<ept id="p1">**</ept> switch on the <ph id="ph1">`Svcutil.exe`</ph> tool.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Normally, types generated from schema are generated into <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> namespaces, with each XSD namespace corresponding to a particular <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> namespace according to a mapping described in <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can customize this mapping by the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A&gt;</ph> property to a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If a given XSD namespace is found in the dictionary, the matching <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> namespace is also taken from your dictionary.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, consider the following schema.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>c_SchemaImportExport#10<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The following example uses the <ph id="ph1">`Namespaces`</ph> property to map the "http://schemas.contoso.com/carSchema" namespace to "Contoso.Cars".</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_SchemaImportExport#8<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#8)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_SchemaImportExport#8<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Adding the SerializableAttribute (GenerateSerializable or the /serializable switch)</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This corresponds to the <bpt id="p1">**</bpt>/serializable<ept id="p1">**</ept> switch on the <ph id="ph1">`Svcutil.exe`</ph> tool.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Sometimes it is important for the types generated from the schema to be usable with <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> runtime serialization engines (for example, the <ph id="ph2">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=fullName&gt;</ph> and the <ph id="ph3">&lt;xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter&gt;</ph> classes).</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This is useful when using types for <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> remoting.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>To enable this, you must apply the <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph> attribute to the generated types in addition to the regular <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The attribute is generated automatically if the <ph id="ph1">`GenerateSerializable`</ph> import option is set to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The following example shows the <ph id="ph1">`Vehicle`</ph> class generated with the <ph id="ph2">`GenerateSerializable`</ph> import option set to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_SchemaImportExport#4<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_SchemaImportExport#4<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Adding Data Binding Support (EnableDataBinding or the /enableDataBinding switch)</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This corresponds to the <bpt id="p1">**</bpt>/enableDataBinding<ept id="p1">**</ept> switch on the Svcutil.exe tool.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Sometimes, you may want to bind the types generated from the schema to graphical user interface components so that any update to instances of these types will automatically update the UI.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`XsdDataContractImporter`</ph> can generate types that implement the <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph> interface in such a way that any property change triggers an event.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If you are generating types for use with a client UI programming environment that supports this interface (such as <ph id="ph1">[!INCLUDE[avalon1](../../../../includes/avalon1-md.md)]</ph>), set the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A&gt;</ph> property to <ph id="ph3">`true`</ph> to enable this feature.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example shows the <ph id="ph1">`Vehicle`</ph> class generated with the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A&gt;</ph> set to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>C_SchemaImportExport#5<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>C_SchemaImportExport#5<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Import Options: Choosing Collection Types</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Two special patterns in XML represent collections of items: lists of items and associations between one item and another.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following is an example of a list of strings.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>C_SchemaImportExport#11<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#11)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following is an example of an association between a string and an integer (<ph id="ph1">`city name`</ph> and <ph id="ph2">`population`</ph>).</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>C_SchemaImportExport#12<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#12)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Any association could also be considered a list.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For example, you can view the preceding association as a list of complex <ph id="ph1">`city`</ph> objects that happen to have two fields (a string field and an integer field).</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Both patterns have a representation in the XSD Schema.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>There is no way to differentiate between a list and an association, so such patterns are always treated as lists unless a special annotation specific to <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> is present in the schema.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The annotation indicates that a given pattern represents an association.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Normally, a list is imported as a collection data contract that derives from a Generic List or as a <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> array, depending on whether or not the schema follows the standard naming pattern for collections.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This is described in more detail in <bpt id="p1">[</bpt>Collection Types in Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Associations are normally imported as either a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> or a collection data contract that derives from the dictionary object.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, consider the following schema.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>c_SchemaImportExport#13<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#13)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This would be imported as follows (fields are shown instead of properties for readability).</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>c_SchemaImportExport#6<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>c_SchemaImportExport#6<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>It is possible to customize the collection types that are generated for such schema patterns.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For example, you may want to generate collections deriving from the <ph id="ph1">&lt;xref:System.ComponentModel.BindingList%601&gt;</ph> instead of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class in order to bind the type to a list box and have it be automatically updated when the contents of the collection change.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>To do this, set the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ImportOptions&gt;</ph> class to a list of collection types to be used (hereafter known as the referenced types).</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>When importing any collection, this list of referenced collection types is scanned and the best-matching collection is used if one is found.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Associations are matched only against types that implement either the generic or the nongeneric <ph id="ph1">&lt;xref:System.Collections.IDictionary&gt;</ph> interface, while lists are matched against any supported collection type.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A&gt;</ph> property is set to a <ph id="ph2">&lt;xref:System.ComponentModel.BindingList%601&gt;</ph>, the <ph id="ph3">`people`</ph> type in the preceding example is generated as follows.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>C_SchemaImportExport#7<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#7)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>C_SchemaImportExport#7<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#7)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A closed generic is considered the best match.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, if the types <ph id="ph1">`BindingList(Of Integer)`</ph> and <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> are passed to the collection of referenced types, any lists of integers found in schema are imported as a <ph id="ph3">`BindingList(Of Integer)`</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Any other lists, for example, a <ph id="ph1">`List(Of String)`</ph>, are imported as an <ph id="ph2">`ArrayList`</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If a type that implements the generic <ph id="ph1">`IDictionary`</ph> interface is added to the collection of referenced types, its type parameters must either be fully open or fully closed.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Duplicates are not allowed.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For example, you cannot add both a <ph id="ph1">`List(Of Integer)`</ph> and a <ph id="ph2">`Collection(Of Integer)`</ph> to the referenced types.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>That would make it impossible to determine which should be used when a list of integers is found in schema.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Duplicates will be detected only if there is a type in schema that exposes the duplicates problem.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if the imported schema does not contain lists of integers, it is allowed to have both the <ph id="ph1">`List(Of Integer)`</ph> and the <ph id="ph2">`Collection(Of Integer)`</ph> in the referenced types collection, but neither will have any effect.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The referenced collection types mechanism works equally well for collections of complex types (including collections of other collections), and not just for collections of primitives.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ReferencedCollectionTypes`</ph> property corresponds to the <bpt id="p1">**</bpt>/collectionType<ept id="p1">**</ept> switch on the SvcUtil.exe tool.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Note that to reference multiple collection types, the <bpt id="p1">**</bpt>/collectionType<ept id="p1">**</ept> switch must be specified multiple times.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If the type is not in the MsCorLib.dll, its assembly must also be referenced using the <bpt id="p1">**</bpt>/reference<ept id="p1">**</ept> switch.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Import Options: Referencing Existing Types</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Occasionally, types in schema correspond to existing <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types, and there is no need to generate these types from scratch.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>(This section applies only to noncollection types.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>For collection types, see the preceding section.)</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>For example, you may have a standard company-wide "Person" data contract type that you always want used when representing a person.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Whenever some service makes use of this type, and its schema appears in the service metadata, you may want to reuse the existing <ph id="ph1">`Person`</ph> type when importing this schema instead of generating a new one for every service.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>To do this, pass a list of <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types that you want to reuse into the collection the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A&gt;</ph> property returns on the <ph id="ph3">&lt;xref:System.Runtime.Serialization.ImportOptions&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If any of these types have a data contract name and namespace that matches the name and namespace of a schema type, a structural comparison is performed.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If it is determined that the types have both matching names and matching structures, the existing <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> type is reused instead of generating a new one.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>If only the name matches but not the structure, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Note that there is no allowance for versioning when referencing types (for example, adding new optional data members).</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The structures must match exactly.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>It is legal to add multiple types with the same data contract name and namespace to the referenced types collection, as long as no schema types are imported with that name and namespace.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This allows you to easily add all the types in an assembly to the collection without worrying about duplicates for types that do not actually occur in schema.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`ReferencedTypes`</ph> property corresponds to the <bpt id="p1">**</bpt>/reference<ept id="p1">**</ept> switch in certain modes of operation of the Svcutil.exe tool.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When using the Svcutil.exe or (in <ph id="ph1">[!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)]</ph>) the <bpt id="p1">**</bpt>Add Service Reference<ept id="p1">**</ept> tools, all of the types in MsCorLib.dll are automatically referenced.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Import Options: Importing Non-DataContract Schema as IXmlSerializable types</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph> supports a limited subset of the schema.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If unsupported schema constructs are present (for example, XML attributes), the import attempt fails with an exception.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>However, setting the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A&gt;</ph> property to <ph id="ph2">`true`</ph> extends the range of schema supported.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>When set to <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph> generates types that implement the <ph id="ph3">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>This enables direct access to the XML representation of these types.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Design Considerations</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>It may be difficult to work with the weakly typed XML representation directly.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Consider using an alternative serialization engine, such as the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>, to work with schema not compatible with data contracts in a strongly typed way.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Using the XmlSerializer Class<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Some schema constructs cannot be imported by the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph> even when the <ph id="ph2">&lt;xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A&gt;</ph> property is set to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Again, consider using the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> for such cases.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The exact schema constructs that are supported both when <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A&gt;</ph> is <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph> are described in <bpt id="p1">[</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Schema for generated <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> types do not retain fidelity when imported and exported.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>That is, exporting the schema from the generated types and importing as classes does not return the original schema.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>It is possible to combine the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A&gt;</ph> option with the <ph id="ph2">&lt;xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A&gt;</ph> option previously described.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For types that have to be generated as <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> implementations, the structural check is skipped when using the <ph id="ph2">&lt;xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A&gt;</ph> feature.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A&gt;</ph> option corresponds to the <bpt id="p1">**</bpt>/importXmlTypes<ept id="p1">**</ept> switch on the Svcutil.exe tool.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Working with Generated IXmlSerializable Types</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The generated <ph id="ph1">`IXmlSerializable`</ph> types contain a private field, named "nodesField," that returns an array of <ph id="ph2">&lt;xref:System.Xml.XmlNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When deserializing an instance of such a type, you can access the XML data directly through this field by using the XML Document Object Model.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>When serializing an instance of this type, you can set this field to the desired XML data and it will be serialized.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This is accomplished through the <ph id="ph1">`IXmlSerializable`</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>In the generated <ph id="ph1">`IXmlSerializable`</ph> type, the <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A&gt;</ph> implementation calls the <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A&gt;</ph> method of the <ph id="ph4">&lt;xref:System.Runtime.Serialization.XmlSerializableServices&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The method is a helper method that converts XML provided through an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> to an array of <ph id="ph2">&lt;xref:System.Xml.XmlNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> implementation does the opposite and converts the array of <ph id="ph2">`XmlNode`</ph> objects to a sequence of <ph id="ph3">&lt;xref:System.Xml.XmlWriter&gt;</ph> calls.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>This is accomplished using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>It is possible to run the schema export process on the generated <ph id="ph1">`IXmlSerializable`</ph> classes.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>As previously stated, you will not get the original schema back.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Instead, you will get the "anyType" standard XSD type, which is a wildcard for any XSD type.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This is accomplished by applying the <ph id="ph1">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute to the generated <ph id="ph2">`IXmlSerializable`</ph> classes and specifying a method that calls the <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A&gt;</ph> method to generate the "anyType" type.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlSerializableServices&gt;</ph> type exists solely to support this particular feature.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It is not recommended for use for any other purpose.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Import Options: Advanced Options</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The following are advanced import options:</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Specify the <ph id="ph1">&lt;xref:System.CodeDom.Compiler.CodeDomProvider&gt;</ph> to use to generate the code for the generated classes.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The import mechanism attempts to avoid features that the <ph id="ph1">&lt;xref:System.CodeDom.Compiler.CodeDomProvider&gt;</ph> does not support.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For example, the J# language does not support generics.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If you specify the J# code provider in this property, no generic types is generated in the importer’s <ph id="ph1">&lt;xref:System.CodeDom.CodeCompileUnit&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A&gt;</ph> is not set, the full set of <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> features is used with no restrictions.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Runtime.Serialization.IDataContractSurrogate&gt;</ph> implementation can be specified with this property.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.IDataContractSurrogate&gt;</ph> customizes the import process.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Data Contract Surrogates<ept id="p1">](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>By default, no surrogate is used.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph></source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractImporter&gt;</ph></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter&gt;</ph></source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.ImportOptions&gt;</ph></source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Data Contract Surrogates<ept id="p1">](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Schema Import and Export<ept id="p1">](../../../../docs/framework/wcf/feature-details/schema-import-and-export.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Exporting Schemas from Classes<ept id="p1">](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Data Contract Schema Reference<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>