{"content":"---\ntitle: \"HttpCookieSession | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 101cb624-8303-448a-a3af-933247c1e109\ncaps.latest.revision: 31\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# HttpCookieSession\nThis sample demonstrates how to build a custom protocol channel to use HTTP cookies for session management. This channel enables communication between [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] services and ASMX clients or between [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients and ASMX services.  \n  \n When a client calls a Web method in an ASMX Web service that is session-based, the [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] engine does the following:  \n  \n-   Generates a unique ID (session ID).  \n  \n-   Generates the session object and associates it with the unique ID.  \n  \n-   Adds the unique ID to a Set-Cookie HTTP response header and sends it to the client.  \n  \n-   Identifies the client on subsequent calls based on the session ID it sends to it.  \n  \n The client includes this session ID in its subsequent requests to the server. The server uses the session ID from the client to load the appropriate session object for the current HTTP context.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](http://go.microsoft.com/fwlink/?LinkId=150780) to download all [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Channels\\HttpCookieSession`  \n  \n## HttpCookieSession Channel Message Exchange Pattern  \n This sample enables sessions for ASMX-like scenarios. At the bottom of our channel stack, we have the HTTP transport that supports <xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>. It is the job of the channel to provide sessions to the higher levels of the channel stack. The sample implements two channels, (<xref:System.ServiceModel.Channels.IRequestSessionChannel> and <xref:System.ServiceModel.Channels.IReplySessionChannel>) that support sessions.  \n  \n## Service Channel  \n The sample provides a service channel in the `HttpCookieReplySessionChannelListener` class. This class implements the <xref:System.ServiceModel.Channels.IChannelListener> interface and converts the <xref:System.ServiceModel.Channels.IReplyChannel> channel from lower in the channel stack to a <xref:System.ServiceModel.Channels.IReplySessionChannel>. This process can be divided into the following parts:  \n  \n-   When the channel listener is opened, it accepts an inner channel from its inner listener. Because the inner listener is a datagram listener and the lifetime of an accepted channel is decoupled from the lifetime of the listener, we can close the inner listener and only hold on to the inner channel  \n  \n    ```  \n                this.innerChannelListener.Open(timeoutHelper.RemainingTime());  \n    this.innerChannel = this.innerChannelListener.AcceptChannel(timeoutHelper.RemainingTime());  \n    this.innerChannel.Open(timeoutHelper.RemainingTime());  \n    this.innerChannelListener.Close(timeoutHelper.RemainingTime());  \n    ```  \n  \n-   When the open process completes, we set up a message loop to receive messages from the inner channel.  \n  \n    ```  \n    IAsyncResult result = BeginInnerReceiveRequest();  \n    if (result != null && result.CompletedSynchronously)  \n    {  \n       // do not block the user thread  \n       if (this.completeReceiveCallback == null)  \n       {  \n          this.completeReceiveCallback = new WaitCallback(CompleteReceiveCallback);  \n       }  \n       ThreadPool.QueueUserWorkItem(this.completeReceiveCallback, result);  \n    }  \n    ```  \n  \n-   When a message arrives, the service channel examines the session identifier and de-multiplexes to the appropriate session channel. The channel listener maintains a dictionary that maps the session identifiers to the session channel instances.  \n  \n    ```  \n    Dictionary<string, IReplySessionChannel> channelMapping;  \n    ```  \n  \n The `HttpCookieReplySessionChannel` class implements <xref:System.ServiceModel.Channels.IReplySessionChannel>. Higher levels of the channel stack call the <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method to read requests for this session. Each session channel has a private message queue that is populated by the service channel.  \n  \n```  \nInputQueue<RequestContext> requestQueue;  \n```  \n  \n In the case when someone calls the <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method and there are no messages in the message queue, the channel waits for a specified amount of time before shutting itself down. This cleans up the session channels created for non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients.  \n  \n We use the `channelMapping` to track the `ReplySessionChannels`, and we do not close our underlying `innerChannel` until all the accepted channels have been closed. This way `HttpCookieReplySessionChannel` can exist beyond the lifetime of `HttpCookieReplySessionChannelListener`. We also do not have to worry about the listener getting garbage collected underneath us because the accepted channels keep a reference to their listener through the `OnClosed` callback.  \n  \n## Client channel  \n The corresponding client channel is in the `HttpCookieSessionChannelFactory` class. During channel creation, the channel factory wraps the inner request channel with an `HttpCookieRequestSessionChannel`. The `HttpCookieRequestSessionChannel` class forwards the calls to the underlying request channel. When the client closes the proxy, `HttpCookieRequestSessionChannel` sends a message to the service that indicates that the channel is being closed. Thus, the service channel stack can gracefully shutdown the session channel that is in use.  \n  \n## Binding and Binding Element  \n After creating the service and client channels, the next step is to integrate them into the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime. Channels are exposed to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] through bindings and binding elements. A binding consists of one or many binding elements. [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] offers several system-defined bindings; for example, BasicHttpBinding or WSHttpBinding. The `HttpCookieSessionBindingElement` class contains the implementation for the binding element. It overrides the channel listener and channel factory creation methods to do the necessary channel listener or channel factory instantiations.  \n  \n The sample uses policy assertions for the service description. This allows the sample to publish its channel requirements to other clients that can consume the service. For example, this binding element publishes policy assertions to let potential clients know that it supports sessions. Because the sample enables the `ExchangeTerminateMessage` property in the binding element configuration, it adds the necessary assertions to show that the service supports an extra message exchange action to terminate the session conversation. Clients can then use this action. The following WSDL code shows the policy assertions created from the `HttpCookieSessionBindingElement`.  \n  \n```  \n<wsp:Policy wsu:Id=\"HttpCookieSessionBinding_IWcfCookieSessionService_policy\" xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">  \n<wsp:ExactlyOne>  \n<wsp:All>  \n<wspe:Utf816FFFECharacterEncoding xmlns:wspe=\"http://schemas.xmlsoap.org/ws/2004/09/policy/encoding\"/>  \n<mhsc:httpSessionCookie xmlns:mhsc=\"http://samples.microsoft.com/wcf/mhsc/policy\"/>  \n</wsp:All>  \n</wsp:ExactlyOne>  \n</wsp:Policy>  \n```  \n  \n The `HttpCookieSessionBinding` class is a system-provided binding that uses the binding element described previously.  \n  \n## Adding the Channel to the Configuration System  \n The sample provides two classes that expose the sample channel through configuration. The first is a <xref:System.ServiceModel.Configuration.BindingElementExtensionElement> for the `HttpCookieSessionBindingElement`. The bulk of the implementation is delegated to the `HttpCookieSessionBindingConfigurationElement`, which derives from <xref:System.ServiceModel.Configuration.StandardBindingElement>. The `HttpCookieSessionBindingConfigurationElement` has properties that correspond to the properties on `HttpCookieSessionBindingElement`.  \n  \n### Binding Element Extension Section  \n The section `HttpCookieSessionBindingElementSection` is a <xref:System.ServiceModel.Configuration.BindingElementExtensionElement> that exposes `HttpCookieSessionBindingElement` to the configuration system. With a few overrides the configuration section name, the type of the binding element and how to create the binding element are defined. We can then register the extension section in a configuration file as follows:  \n  \n```  \n<configuration>        \n    <system.serviceModel>        \n      <extensions>          \n        <bindingElementExtensions>            \n          <add name=\"httpCookieSession\"   \n               type=  \n\"Microsoft.ServiceModel.Samples.HttpCookieSessionBindingElementElement,   \n                    HttpCookieSessionExtension, Version=1.0.0.0,   \n                    Culture=neutral, PublicKeyToken=null\"/>  \n        </bindingElementExtensions >  \n      </extensions>  \n  \n      <bindings>  \n      <customBinding>  \n        <binding name=\"allowCookiesBinding\">  \n          <textMessageEncoding messageVersion=\"Soap11WSAddressing10\" />  \n          <httpCookieSession sessionTimeout=\"10\" exchangeTerminateMessage=\"true\" />  \n          <httpTransport allowCookies=\"true\" />  \n        </binding>  \n      </customBinding>  \n      </bindings>        \n    </system.serviceModel>    \n</configuration>  \n```  \n  \n## Test Code  \n Test code for using this sample transport is available in the Client and Service directories. It consists of two tests—one test uses a binding with `allowCookies` set to `true` on the client. The second test enables explicit shutdown (using the terminate message exchange) on the binding.  \n  \n When you run the sample, you should see the following output:  \n  \n```  \nSimple binding:  \nAddItem(10000,2): ItemCount=2  \nAddItem(10550,5): ItemCount=7  \nRemoveItem(10550,2): ItemCount=5  \nItems  \n10000, 2  \n10550, 3  \nSmart binding:  \nAddItem(10000,2): ItemCount=2  \nAddItem(10550,5): ItemCount=7  \nRemoveItem(10550,2): ItemCount=5  \nItems  \n10000, 2  \n10550, 3  \n  \nPress <ENTER> to terminate client.  \n```  \n  \n#### To set up, build, and run the sample  \n  \n1.  Install [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 4.0 using the following command.  \n  \n    ```  \n    %windir%\\Microsoft.NET\\Framework\\v4.0.XXXXX\\aspnet_regiis.exe /i /enable  \n  \n    ```  \n  \n2.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n3.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n4.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n## See Also","nodes":[{"pos":[12,46],"content":"HttpCookieSession | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"HttpCookieSession | Microsoft Docs","pos":[0,34]}]},{"pos":[345,362],"content":"HttpCookieSession","linkify":"HttpCookieSession","nodes":[{"content":"HttpCookieSession","pos":[0,17]}]},{"content":"This sample demonstrates how to build a custom protocol channel to use HTTP cookies for session management.","pos":[363,470]},{"content":"This channel enables communication between <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> services and ASMX clients or between <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> clients and ASMX services.","pos":[471,689],"source":" This channel enables communication between [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] services and ASMX clients or between [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients and ASMX services."},{"pos":[696,863],"content":"When a client calls a Web method in an ASMX Web service that is session-based, the <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> engine does the following:","source":"When a client calls a Web method in an ASMX Web service that is session-based, the [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] engine does the following:"},{"content":"Generates a unique ID (session ID).","pos":[873,908]},{"content":"Generates the session object and associates it with the unique ID.","pos":[918,984]},{"content":"Adds the unique ID to a Set-Cookie HTTP response header and sends it to the client.","pos":[994,1077]},{"content":"Identifies the client on subsequent calls based on the session ID it sends to it.","pos":[1087,1168]},{"content":"The client includes this session ID in its subsequent requests to the server.","pos":[1175,1252]},{"content":"The server uses the session ID from the client to load the appropriate session object for the current HTTP context.","pos":[1253,1368]},{"pos":[1376,1508],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":" The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[13,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[1,54]},{"content":"Check for the following (default) directory before continuing.","pos":[55,117]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[1562,1888],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](http://go.microsoft.com/fwlink/?LinkId=150780) to download all [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[1889,1939]},{"pos":[2036,2086],"content":"HttpCookieSession Channel Message Exchange Pattern","linkify":"HttpCookieSession Channel Message Exchange Pattern","nodes":[{"content":"HttpCookieSession Channel Message Exchange Pattern","pos":[0,50]}]},{"content":"This sample enables sessions for ASMX-like scenarios.","pos":[2090,2143]},{"content":"At the bottom of our channel stack, we have the HTTP transport that supports <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IRequestChannel&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph>.","pos":[2144,2327],"source":" At the bottom of our channel stack, we have the HTTP transport that supports <xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>."},{"content":"It is the job of the channel to provide sessions to the higher levels of the channel stack.","pos":[2328,2419]},{"content":"The sample implements two channels, (<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IRequestSessionChannel&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplySessionChannel&gt;</ph>) that support sessions.","pos":[2420,2600],"source":" The sample implements two channels, (<xref:System.ServiceModel.Channels.IRequestSessionChannel> and <xref:System.ServiceModel.Channels.IReplySessionChannel>) that support sessions."},{"pos":[2609,2624],"content":"Service Channel","linkify":"Service Channel","nodes":[{"content":"Service Channel","pos":[0,15]}]},{"content":"The sample provides a service channel in the <ph id=\"ph1\">`HttpCookieReplySessionChannelListener`</ph> class.","pos":[2628,2719],"source":"The sample provides a service channel in the `HttpCookieReplySessionChannelListener` class."},{"content":"This class implements the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph> interface and converts the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph> channel from lower in the channel stack to a <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IReplySessionChannel&gt;</ph>.","pos":[2720,2978],"source":" This class implements the <xref:System.ServiceModel.Channels.IChannelListener> interface and converts the <xref:System.ServiceModel.Channels.IReplyChannel> channel from lower in the channel stack to a <xref:System.ServiceModel.Channels.IReplySessionChannel>."},{"content":"This process can be divided into the following parts:","pos":[2979,3032]},{"content":"When the channel listener is opened, it accepts an inner channel from its inner listener.","pos":[3042,3131]},{"content":"Because the inner listener is a datagram listener and the lifetime of an accepted channel is decoupled from the lifetime of the listener, we can close the inner listener and only hold on to the inner channel","pos":[3132,3339]},{"content":"When the open process completes, we set up a message loop to receive messages from the inner channel.","pos":[3682,3783]},{"content":"When a message arrives, the service channel examines the session identifier and de-multiplexes to the appropriate session channel.","pos":[4224,4354]},{"content":"The channel listener maintains a dictionary that maps the session identifiers to the session channel instances.","pos":[4355,4466]},{"content":"The <ph id=\"ph1\">`HttpCookieReplySessionChannel`</ph> class implements <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplySessionChannel&gt;</ph>.","pos":[4559,4669],"source":"The `HttpCookieReplySessionChannel` class implements <xref:System.ServiceModel.Channels.IReplySessionChannel>."},{"content":"Higher levels of the channel stack call the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> method to read requests for this session.","pos":[4670,4823],"source":" Higher levels of the channel stack call the <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method to read requests for this session."},{"content":"Each session channel has a private message queue that is populated by the service channel.","pos":[4824,4914]},{"content":"In the case when someone calls the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> method and there are no messages in the message queue, the channel waits for a specified amount of time before shutting itself down.","pos":[4979,5214],"source":"In the case when someone calls the <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> method and there are no messages in the message queue, the channel waits for a specified amount of time before shutting itself down."},{"content":"This cleans up the session channels created for non-<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> clients.","pos":[5215,5331],"source":" This cleans up the session channels created for non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients."},{"content":"We use the <ph id=\"ph1\">`channelMapping`</ph> to track the <ph id=\"ph2\">`ReplySessionChannels`</ph>, and we do not close our underlying <ph id=\"ph3\">`innerChannel`</ph> until all the accepted channels have been closed.","pos":[5338,5502],"source":"We use the `channelMapping` to track the `ReplySessionChannels`, and we do not close our underlying `innerChannel` until all the accepted channels have been closed."},{"content":"This way <ph id=\"ph1\">`HttpCookieReplySessionChannel`</ph> can exist beyond the lifetime of <ph id=\"ph2\">`HttpCookieReplySessionChannelListener`</ph>.","pos":[5503,5617],"source":" This way `HttpCookieReplySessionChannel` can exist beyond the lifetime of `HttpCookieReplySessionChannelListener`."},{"content":"We also do not have to worry about the listener getting garbage collected underneath us because the accepted channels keep a reference to their listener through the <ph id=\"ph1\">`OnClosed`</ph> callback.","pos":[5618,5803],"source":" We also do not have to worry about the listener getting garbage collected underneath us because the accepted channels keep a reference to their listener through the `OnClosed` callback."},{"pos":[5812,5826],"content":"Client channel","linkify":"Client channel","nodes":[{"content":"Client channel","pos":[0,14]}]},{"content":"The corresponding client channel is in the <ph id=\"ph1\">`HttpCookieSessionChannelFactory`</ph> class.","pos":[5830,5913],"source":"The corresponding client channel is in the `HttpCookieSessionChannelFactory` class."},{"content":"During channel creation, the channel factory wraps the inner request channel with an <ph id=\"ph1\">`HttpCookieRequestSessionChannel`</ph>.","pos":[5914,6033],"source":" During channel creation, the channel factory wraps the inner request channel with an `HttpCookieRequestSessionChannel`."},{"content":"The <ph id=\"ph1\">`HttpCookieRequestSessionChannel`</ph> class forwards the calls to the underlying request channel.","pos":[6034,6131],"source":" The `HttpCookieRequestSessionChannel` class forwards the calls to the underlying request channel."},{"content":"When the client closes the proxy, <ph id=\"ph1\">`HttpCookieRequestSessionChannel`</ph> sends a message to the service that indicates that the channel is being closed.","pos":[6132,6279],"source":" When the client closes the proxy, `HttpCookieRequestSessionChannel` sends a message to the service that indicates that the channel is being closed."},{"content":"Thus, the service channel stack can gracefully shutdown the session channel that is in use.","pos":[6280,6371]},{"pos":[6380,6407],"content":"Binding and Binding Element","linkify":"Binding and Binding Element","nodes":[{"content":"Binding and Binding Element","pos":[0,27]}]},{"content":"After creating the service and client channels, the next step is to integrate them into the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime.","pos":[6411,6567],"source":"After creating the service and client channels, the next step is to integrate them into the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime."},{"content":"Channels are exposed to <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> through bindings and binding elements.","pos":[6568,6686],"source":" Channels are exposed to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] through bindings and binding elements."},{"content":"A binding consists of one or many binding elements.","pos":[6687,6738]},{"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> offers several system-defined bindings; for example, BasicHttpBinding or WSHttpBinding.","pos":[6739,6882],"source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] offers several system-defined bindings; for example, BasicHttpBinding or WSHttpBinding."},{"content":"The <ph id=\"ph1\">`HttpCookieSessionBindingElement`</ph> class contains the implementation for the binding element.","pos":[6883,6979],"source":" The `HttpCookieSessionBindingElement` class contains the implementation for the binding element."},{"content":"It overrides the channel listener and channel factory creation methods to do the necessary channel listener or channel factory instantiations.","pos":[6980,7122]},{"content":"The sample uses policy assertions for the service description.","pos":[7129,7191]},{"content":"This allows the sample to publish its channel requirements to other clients that can consume the service.","pos":[7192,7297]},{"content":"For example, this binding element publishes policy assertions to let potential clients know that it supports sessions.","pos":[7298,7416]},{"content":"Because the sample enables the <ph id=\"ph1\">`ExchangeTerminateMessage`</ph> property in the binding element configuration, it adds the necessary assertions to show that the service supports an extra message exchange action to terminate the session conversation.","pos":[7417,7660],"source":" Because the sample enables the `ExchangeTerminateMessage` property in the binding element configuration, it adds the necessary assertions to show that the service supports an extra message exchange action to terminate the session conversation."},{"content":"Clients can then use this action.","pos":[7661,7694]},{"content":"The following WSDL code shows the policy assertions created from the <ph id=\"ph1\">`HttpCookieSessionBindingElement`</ph>.","pos":[7695,7798],"source":" The following WSDL code shows the policy assertions created from the `HttpCookieSessionBindingElement`."},{"pos":[8324,8441],"content":"The <ph id=\"ph1\">`HttpCookieSessionBinding`</ph> class is a system-provided binding that uses the binding element described previously.","source":"The `HttpCookieSessionBinding` class is a system-provided binding that uses the binding element described previously."},{"pos":[8450,8496],"content":"Adding the Channel to the Configuration System","linkify":"Adding the Channel to the Configuration System","nodes":[{"content":"Adding the Channel to the Configuration System","pos":[0,46]}]},{"content":"The sample provides two classes that expose the sample channel through configuration.","pos":[8500,8585]},{"content":"The first is a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> for the <ph id=\"ph2\">`HttpCookieSessionBindingElement`</ph>.","pos":[8586,8715],"source":" The first is a <xref:System.ServiceModel.Configuration.BindingElementExtensionElement> for the `HttpCookieSessionBindingElement`."},{"content":"The bulk of the implementation is delegated to the <ph id=\"ph1\">`HttpCookieSessionBindingConfigurationElement`</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Configuration.StandardBindingElement&gt;</ph>.","pos":[8716,8898],"source":" The bulk of the implementation is delegated to the `HttpCookieSessionBindingConfigurationElement`, which derives from <xref:System.ServiceModel.Configuration.StandardBindingElement>."},{"content":"The <ph id=\"ph1\">`HttpCookieSessionBindingConfigurationElement`</ph> has properties that correspond to the properties on <ph id=\"ph2\">`HttpCookieSessionBindingElement`</ph>.","pos":[8899,9036],"source":" The `HttpCookieSessionBindingConfigurationElement` has properties that correspond to the properties on `HttpCookieSessionBindingElement`."},{"pos":[9046,9079],"content":"Binding Element Extension Section","linkify":"Binding Element Extension Section","nodes":[{"content":"Binding Element Extension Section","pos":[0,33]}]},{"content":"The section <ph id=\"ph1\">`HttpCookieSessionBindingElementSection`</ph> is a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> that exposes <ph id=\"ph3\">`HttpCookieSessionBindingElement`</ph> to the configuration system.","pos":[9083,9288],"source":"The section `HttpCookieSessionBindingElementSection` is a <xref:System.ServiceModel.Configuration.BindingElementExtensionElement> that exposes `HttpCookieSessionBindingElement` to the configuration system."},{"content":"With a few overrides the configuration section name, the type of the binding element and how to create the binding element are defined.","pos":[9289,9424]},{"content":"We can then register the extension section in a configuration file as follows:","pos":[9425,9503]},{"pos":[10418,10427],"content":"Test Code","linkify":"Test Code","nodes":[{"content":"Test Code","pos":[0,9]}]},{"content":"Test code for using this sample transport is available in the Client and Service directories.","pos":[10431,10524]},{"content":"It consists of two tests—one test uses a binding with <ph id=\"ph1\">`allowCookies`</ph> set to <ph id=\"ph2\">`true`</ph> on the client.","pos":[10525,10622],"source":" It consists of two tests—one test uses a binding with `allowCookies` set to `true` on the client."},{"content":"The second test enables explicit shutdown (using the terminate message exchange) on the binding.","pos":[10623,10719]},{"content":"When you run the sample, you should see the following output:","pos":[10726,10787]},{"pos":[11146,11182],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[11192,11290],"content":"Install <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> 4.0 using the following command.","source":"Install [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 4.0 using the following command."},{"pos":[11405,11604],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[11614,11784],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[11794,12002],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"pos":[12011,12019],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]}]}