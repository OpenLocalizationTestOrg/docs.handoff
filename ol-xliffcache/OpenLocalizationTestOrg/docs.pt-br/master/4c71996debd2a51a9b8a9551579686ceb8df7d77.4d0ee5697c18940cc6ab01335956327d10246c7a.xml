{"content":"---\ntitle: \"How to: Filter on an Optional Element (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: f99e2f93-fca5-403f-8a0c-770761d4905a\ncaps.latest.revision: 4\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\n---\n# How to: Filter on an Optional Element (C#)\nSometimes you want to filter for an element even though you are not sure it exists in your XML document. The search should be executed so that if the particular element does not have the child element, you do not trigger a null reference exception by filtering for it. In the following example, the `Child5` element does not have a `Type` child element, but the query still executes correctly.  \n  \n## Example  \n This example uses the <xref:System.Xml.Linq.Extensions.Elements%2A> extension method.  \n  \n```csharp  \nXElement root = XElement.Parse(@\"<Root>  \n  <Child1>  \n    <Text>Child One Text</Text>  \n    <Type Value=\"\"Yes\"\"/>  \n  </Child1>  \n  <Child2>  \n    <Text>Child Two Text</Text>  \n    <Type Value=\"\"Yes\"\"/>  \n  </Child2>  \n  <Child3>  \n    <Text>Child Three Text</Text>  \n    <Type Value=\"\"No\"\"/>  \n  </Child3>  \n  <Child4>  \n    <Text>Child Four Text</Text>  \n    <Type Value=\"\"Yes\"\"/>  \n  </Child4>  \n  <Child5>  \n    <Text>Child Five Text</Text>  \n  </Child5>  \n</Root>\");  \nvar cList =  \n    from typeElement in root.Elements().Elements(\"Type\")  \n    where (string)typeElement.Attribute(\"Value\") == \"Yes\"  \n    select (string)typeElement.Parent.Element(\"Text\");  \nforeach(string str in cList)  \n    Console.WriteLine(str);  \n```  \n  \n This code produces the following output:  \n  \n```  \nChild One Text  \nChild Two Text  \nChild Four Text  \n```  \n  \n## Example  \n The following example shows the same query for XML that is in a namespace. For more information, see [Working with XML Namespaces (C#)](../../../../csharp/programming-guide/concepts/linq/working-with-xml-namespaces.md).  \n  \n```csharp  \nXElement root = XElement.Parse(@\"<Root xmlns='http://www.adatum.com'>  \n  <Child1>  \n    <Text>Child One Text</Text>  \n    <Type Value=\"\"Yes\"\"/>  \n  </Child1>  \n  <Child2>  \n    <Text>Child Two Text</Text>  \n    <Type Value=\"\"Yes\"\"/>  \n  </Child2>  \n  <Child3>  \n    <Text>Child Three Text</Text>  \n    <Type Value=\"\"No\"\"/>  \n  </Child3>  \n  <Child4>  \n    <Text>Child Four Text</Text>  \n    <Type Value=\"\"Yes\"\"/>  \n  </Child4>  \n  <Child5>  \n    <Text>Child Five Text</Text>  \n  </Child5>  \n</Root>\");  \nXNamespace ad = \"http://www.adatum.com\";  \nvar cList =  \n    from typeElement in root.Elements().Elements(ad + \"Type\")  \n    where (string)typeElement.Attribute(\"Value\") == \"Yes\"  \n    select (string)typeElement.Parent.Element(ad + \"Text\");  \nforeach (string str in cList)  \n    Console.WriteLine(str);  \n```  \n  \n This code produces the following output:  \n  \n```  \nChild One Text  \nChild Two Text  \nChild Four Text  \n```  \n  \n## See Also  \n <xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName>   \n <xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName>   \n <xref:System.Xml.Linq.Extensions.Elements%2A?displayProperty=fullName>   \n [Basic Queries (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/basic-queries-linq-to-xml.md)   \n [Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)   \n [Projection Operations (C#)](../../../../csharp/programming-guide/concepts/linq/projection-operations.md)","nodes":[{"pos":[4,349],"nodes":[{"content":"How to: Filter on an Optional Element (C#) | Microsoft Docs","nodes":[{"pos":[0,59],"content":"How to: Filter on an Optional Element (C#) | Microsoft Docs","nodes":[{"content":"How to: Filter on an Optional Element (C#) | Microsoft Docs","pos":[0,59]}]}],"pos":[6,68],"yaml":true}],"content":"title: \"How to: Filter on an Optional Element (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: f99e2f93-fca5-403f-8a0c-770761d4905a\ncaps.latest.revision: 4\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n","yamlblock":true},{"pos":[356,398],"content":"How to: Filter on an Optional Element (C#)","linkify":"How to: Filter on an Optional Element (C#)","nodes":[{"content":"How to: Filter on an Optional Element (C#)","pos":[0,42]}]},{"content":"Sometimes you want to filter for an element even though you are not sure it exists in your XML document.","pos":[399,503]},{"content":"The search should be executed so that if the particular element does not have the child element, you do not trigger a null reference exception by filtering for it.","pos":[504,667]},{"content":"In the following example, the <ph id=\"ph1\">`Child5`</ph> element does not have a <ph id=\"ph2\">`Type`</ph> child element, but the query still executes correctly.","pos":[668,792],"source":" In the following example, the `Child5` element does not have a `Type` child element, but the query still executes correctly."},{"pos":[801,808],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example uses the <ph id=\"ph1\">&lt;xref:System.Xml.Linq.Extensions.Elements%2A&gt;</ph> extension method.","pos":[812,897],"source":"This example uses the <xref:System.Xml.Linq.Extensions.Elements%2A> extension method."},{"content":"This code produces the following output:","pos":[1651,1691]},{"pos":[1767,1774],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows the same query for XML that is in a namespace.","pos":[1778,1852]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Working with XML Namespaces (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/working-with-xml-namespaces.md)</ept>.","pos":[1853,1997],"source":" For more information, see [Working with XML Namespaces (C#)](../../../../csharp/programming-guide/concepts/linq/working-with-xml-namespaces.md)."},{"content":"This code produces the following output:","pos":[2835,2875]},{"pos":[2951,2959],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName&gt;</ph>","pos":[2963,3032],"source":"<xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName&gt;</ph>","pos":[3037,3107],"source":"<xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Linq.Extensions.Elements%2A?displayProperty=fullName&gt;</ph>","pos":[3112,3182],"source":"<xref:System.Xml.Linq.Extensions.Elements%2A?displayProperty=fullName> "},{"content":"<bpt id=\"p1\">[</bpt>Basic Queries (LINQ to XML) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/basic-queries-linq-to-xml.md)</ept><ph id=\"ph1\"> </ph>","pos":[3187,3303],"source":"[Basic Queries (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/basic-queries-linq-to-xml.md) "},{"content":"<bpt id=\"p1\">[</bpt>Standard Query Operators Overview (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md)</ept><ph id=\"ph1\"> </ph>","pos":[3307,3437],"source":"[Standard Query Operators Overview (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md) "},{"content":"<bpt id=\"p1\">[</bpt>Projection Operations (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/projection-operations.md)</ept>","pos":[3441,3546],"source":"[Projection Operations (C#)](../../../../csharp/programming-guide/concepts/linq/projection-operations.md)"}]}