<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="task-based-asynchronous-programming.md" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">be840e27daa15de8012e38d2e87ff8f60dbe1f59</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\parallel-programming\task-based-asynchronous-programming.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b9677f4f6dfc25006e170995bb138900274955c4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bb7f193316ac943f2475f77d2539df176b5878ea</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Task-based Asynchronous Programming | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Task-based Asynchronous Programming</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The Task Parallel Library (TPL) is based on the concept of a <bpt id="p1">*</bpt>task<ept id="p1">*</ept>, which represents an asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In some ways, a task resembles a thread or <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> work item, but at a higher level of abstraction.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The term <bpt id="p1">*</bpt>task parallelism<ept id="p1">*</ept> refers to one or more independent tasks running concurrently.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Tasks provide two primary benefits:</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>More efficient and more scalable use of system resources.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Behind the scenes, tasks are queued to the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>More programmatic control than is possible with a thread or work item.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For both of these reasons, in the .NET Framework, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Creating and running tasks implicitly</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=fullName&gt;</ph> method provides a convenient way to run any number of arbitrary statements concurrently.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Just pass in an <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate for each item of work.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The easiest way to create these delegates is to use lambda expressions.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The lambda expression can either call a named method or provide the code inline.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following example shows a basic <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.Invoke%2A&gt;</ph> call that creates and starts two tasks that run concurrently.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The first task is represented by a lambda expression that calls a method named <ph id="ph1">`DoSomeWork`</ph>, and the second task is represented by a lambda expression that calls a method named <ph id="ph2">`DoSomeOtherWork`</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This documentation uses lambda expressions to define delegates in TPL.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you are not familiar with lambda expressions in C# or Visual Basic, see <bpt id="p1">[</bpt>Lambda Expressions in PLINQ and TPL<ept id="p1">](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The number of <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances that are created behind the scenes by <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel.Invoke%2A&gt;</ph> is not necessarily equal to the number of delegates that are provided.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The TPL may employ various optimizations, especially with large numbers of delegates.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Use Parallel.Invoke to Execute Parallel Operations<ept id="p1">](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For greater control over task execution or to return a value from the task, you have to work with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects more explicitly.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Creating and running tasks explicitly</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>A task that does not return a value is represented by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task?displayProperty=fullName&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A task that returns a value is represented by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=fullName&gt;</ph> class, which inherits from <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For example, you can access the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The status is represented by a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Lambda expressions can contain a call to a named method, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Note that the example includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> method to ensure that the task completes execution before the console mode application ends.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName&gt;</ph> methods to create and start a task in one operation.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To manage the task, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName&gt;</ph> method to create and start a task in one operation.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task through its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.AsyncState%2A&gt;</ph> property, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> each expose a static <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> property that returns a default instance of <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph>, so that you can call the method as <ph id="ph5">`Task.Factory.StartNew()`</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Also, in the following example, because the tasks are of type <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=fullName&gt;</ph>, they each have a public <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName&gt;</ph> property that contains the result of the computation.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The tasks run asynchronously and may complete in any order.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Return a Value from a Task<ept id="p1">](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>It only captures the final value, not the value as it mutates after each iteration.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The following example illustrates the problem.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It passes a loop counter to a lambda expression that instantiates a <ph id="ph1">`CustomData`</ph> object and uses the loop counter as the object's identifier.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, each <ph id="ph1">`CustomData`</ph> object has an identical identifier.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can access the value on each iteration by providing a state object to a task through its constructor.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The following example modifies the previous example by using the loop counter when creating the <ph id="ph1">`CustomData`</ph> object, which, in turn, is passed to the lambda expression.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, each <ph id="ph1">`CustomData`</ph> object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following example is a variation on the previous example.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.AsyncState%2A&gt;</ph> property to display information about the <ph id="ph2">`CustomData`</ph> objects passed to the lambda expression.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Task ID</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The ID is useful for viewing task information in the Visual Studio debugger <bpt id="p1">**</bpt>Parallel Stacks<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Tasks<ept id="p2">**</ept> windows.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For more information about how to view task IDs in the debugger, see <bpt id="p1">[</bpt>Using the Tasks Window<ept id="p1">](/visualstudio/debugger/using-the-tasks-window)</ept> and <bpt id="p2">[</bpt>Using the Parallel Stacks Window<ept id="p2">](/visualstudio/debugger/using-the-parallel-stacks-window)</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Task Creation Options</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Most APIs that create tasks provide overloads that accept a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>By specifying one of these options, you tell the task scheduler how to schedule the task on the thread pool.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following table lists the various task creation options.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> parameter value</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The default when no option is specified.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The scheduler uses its default heuristics to schedule the task.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Specifies that the task should be scheduled so that tasks created sooner will be more likely to be executed sooner, and tasks created later will be more likely to execute later.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Specifies that the task represents a long-running operation.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Specifies that a task should be created as an attached child of the current task, if one exists.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Specifies that if an inner task specifies the <ph id="ph1">`AttachedToParent`</ph> option, that task will not become an attached child task.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Specifies that the task scheduler for tasks created by calling methods like <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=fullName&gt;</ph> from within a particular task is the default scheduler instead of the scheduler on which this task is running.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The options may be combined by using a bitwise <bpt id="p1">**</bpt>OR<ept id="p1">**</ept> operation.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following example shows a task that has the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Tasks, threads, and culture</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Each thread has an associated culture and UI culture, which is defined by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName&gt;</ph> properties, respectively.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A thread's UI culture is used in resource lookup.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Ordinarily, unless you specify a default culture for all the threads in an application domain by using the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;</ph> properties, the default culture and UI culture of a thread is defined by the system culture.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The task-based programming model for apps that target versions of the .NET Framework prior to <ph id="ph1">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph> adhere to this practice.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Note that the calling thread's culture as part of a task's context applies to apps that <bpt id="p1">*</bpt>target<ept id="p1">*</ept> the <ph id="ph1">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph>, not apps that <bpt id="p2">*</bpt>run under<ept id="p2">*</ept> the <ph id="ph2">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>You can target a particular version of the .NET Framework when you create your project in Visual Studio by selecting that version from the dropdown list at the top of the <bpt id="p1">**</bpt>New Project<ept id="p1">**</ept> dialog box, or outside of Visual Studio you can use the <ph id="ph1">&lt;xref:System.Runtime.Versioning.TargetFrameworkAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For apps that target versions of the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph>, or that do not target a specific version of the .NET Framework, a task's culture continues to be determined by the culture of the thread on which it runs.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Starting with apps that target the <ph id="ph1">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph>, the calling thread's culture is inherited by each task, even if the task runs asynchronously on a thread pool thread.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The following example provides a simple illustration.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>It uses the <ph id="ph1">&lt;xref:System.Runtime.Versioning.TargetFrameworkAttribute&gt;</ph> attribute to target the <ph id="ph2">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph> and changes the app's current culture to either French (France) or, if French (France) is already the current culture, English (United States).</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>It then invokes a delegate named <ph id="ph1">`formatDelegate`</ph> that returns some numbers formatted as currency values in the new culture.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Note that whether the delegate as a task either synchronously or asynchronously, it returns the expected result because the culture of the calling thread is inherited by the asynchronous task.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If you are using Visual Studio, you can omit the <ph id="ph1">&lt;xref:System.Runtime.Versioning.TargetFrameworkAttribute&gt;</ph> attribute and instead select the .NET Framework 4.6 as the target when you create the project in the <bpt id="p1">**</bpt>New Project<ept id="p1">**</ept> dialog.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For output that reflects the behavior of apps the target versions of the .NET Framework prior to <ph id="ph1">[!INCLUDE[net_v46](../../../includes/net-v46-md.md)]</ph>, remove the <ph id="ph2">&lt;xref:System.Runtime.Versioning.TargetFrameworkAttribute&gt;</ph> attribute from the source code.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The output will reflect the formatting conventions of the default system culture, not the culture of the calling thread.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> topic.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Creating task continuations</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=fullName&gt;</ph> methods let you specify a task to start when the <bpt id="p1">*</bpt>antecedent task<ept id="p1">*</ept> finishes.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName&gt;</ph> property, can use the output of the antecedent as input for the continuation.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`getData`</ph> task is started by a call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`processData`</ph> task is started automatically when <ph id="ph2">`getData`</ph> finishes, and <ph id="ph3">`displayData`</ph> is started when <ph id="ph4">`processData`</ph> finishes.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`getData`</ph> produces an integer array, which is accessible to the <ph id="ph2">`processData`</ph> task through the <ph id="ph3">`getData`</ph> task's <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`processData`</ph> task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`displayData`</ph> task executes automatically when <ph id="ph2">`processData`</ph> finishes, and the <ph id="ph3">&lt;xref:System.Tuple%603&gt;</ph> object returned by the <ph id="ph4">`processData`</ph> lambda expression is accessible to the <ph id="ph5">`displayData`</ph> task through the <ph id="ph6">`processData`</ph> task's <ph id="ph7">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`displayData`</ph> task takes the result of the <ph id="ph2">`processData`</ph> task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName&gt;</ph> is an instance method, you can chain method calls together instead of instantiating a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object for each antecedent task.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following example is functionally identical to the previous example, except that it chains together calls to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object returned by the chain of method calls is the final continuation task.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A&gt;</ph> methods enable you to continue from multiple tasks.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Creating detached child tasks</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>When user code that is running in a task creates a new task and does not specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> option, the new task is not synchronized with the parent task in any special way.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This type of non-synchronized task is called a <bpt id="p1">*</bpt>detached nested task<ept id="p1">*</ept> or <bpt id="p2">*</bpt>detached child task<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The following example shows a task that creates one detached child task.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Note that the parent task does not wait for the detached child task to finish.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Creating child tasks</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>When user code that is running in a task creates a task with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> option, the new task is known as a <bpt id="p1">*</bpt>attached child task<ept id="p1">*</ept> of the parent task.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The following example shows a parent task that creates ten attached child tasks.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Note that although the example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A parent task can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option to prevent other tasks from attaching to the parent task.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Waiting for tasks to finish</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=fullName&gt;</ph> types provide several overloads of the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> and        <ph id="ph4">&lt;!--zz &lt;xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=fullName&gt;--&gt;</ph> <ph id="ph5">`System.Threading.Tasks.Task.Wait`</ph> methods that enable you to wait for a task to finish.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In addition, overloads of the static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=fullName&gt;</ph> methods let you wait for any or all of an array of tasks to finish.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Typically, you would wait for a task for one of these reasons:</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The main thread depends on the final result computed by a task.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>You have to handle exceptions that might be thrown from the task.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The application may terminate before all tasks have completed execution.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For example, console applications will terminate as soon as all synchronous code in <ph id="ph1">`Main`</ph> (the application entry point) has executed.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The following example shows the basic pattern that does not involve exception handling.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>For an example that shows exception handling, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Some overloads let you specify a time-out, and others take an additional <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>When you wait for a task, you implicitly wait for all children of that task that were created by using the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> returns immediately if the task has already completed.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Any exceptions raised by a task will be thrown by a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> method, even if the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> method was called after the task completed.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Composing tasks</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, <ph id="ph3">[!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]</ph>, and F#.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>This section describes the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Task.WhenAll</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName&gt;</ph> method asynchronously waits for multiple <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects to finish.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>For example, you can wait for multiple <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects to complete from one method call.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Task.WhenAny</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=fullName&gt;</ph> method asynchronously waits for one of multiple <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects to finish.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>As in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=fullName&gt;</ph> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method is especially useful in the following scenarios.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Redundant operations.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Consider an algorithm or operation that can be performed in many ways.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to select the operation that finishes first and then cancel the remaining operations.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Interleaved operations.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>You can start multiple operations that must all finish and use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to process results as each operation finishes.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>After one operation finishes, you can start one or more additional tasks.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Throttled operations.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to extend the previous scenario by limiting the number of concurrent operations.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Expired operations.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAny%2A&gt;</ph> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method is described in the following section.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Task.Delay</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=fullName&gt;</ph> method produces a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that finishes after the specified time.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Task(T).FromResult</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>By using the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=fullName&gt;</ph> method, you can create a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object that holds a pre-computed result.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>This method is useful when you perform an asynchronous operation that returns a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object, and the result of that <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object is already computed.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>For an example that uses <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> to retrieve the results of asynchronous download operations that are held in a cache, see <bpt id="p1">[</bpt>How to: Create Pre-Computed Tasks<ept id="p1">](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Handling exceptions in tasks</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>When a task throws one or more exceptions, the exceptions are wrapped in an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The calling code can handle the exceptions by using any of the following in a <ph id="ph1">`try`</ph><ph id="ph2">/</ph><ph id="ph3">`catch`</ph> block:</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> method</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The joining thread can also handle exceptions by accessing the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property before the task is garbage-collected.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For more information about exceptions and tasks, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Canceling tasks</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Task`</ph> class supports cooperative cancellation and is fully integrated with the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.CancellationToken?displayProperty=fullName&gt;</ph> classes, which were introduced in the .NET Framework 4.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Many of the constructors in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task?displayProperty=fullName&gt;</ph> class take a <ph id="ph2">&lt;xref:System.Threading.CancellationToken&gt;</ph> object as an input parameter.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Many of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> overloads also include a <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>You can create the token, and issue the cancellation request at some later time, by using the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Pass the token to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Task Cancellation<ept id="p1">](../../../docs/standard/parallel-programming/task-cancellation.md)</ept> and <bpt id="p2">[</bpt>How to: Cancel a Task and Its Children<ept id="p2">](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The TaskFactory class</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The most common pattern is <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph>, which creates and starts a task in one statement.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>When you create continuation tasks from multiple antecedents, use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A&gt;</ph> method or<ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A&gt;</ph> method or their equivalents in the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>To encapsulate Asynchronous Programming Model <ph id="ph1">`BeginX`</ph> and <ph id="ph2">`EndX`</ph> methods in a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> instance, use the <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskFactory.FromAsync%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>TPL and Traditional .NET Framework Asynchronous Programming<ept id="p1">](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The default <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> can be accessed as a static property on the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>You can also instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> directly and specify various options that include a <ph id="ph2">&lt;xref:System.Threading.CancellationToken&gt;</ph>, a <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> option, a <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> option, or a <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is created by using the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions&gt;</ph> enumeration, in which case the task's options override those of the task factory.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Tasks without delegates</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to use a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.FromAsync%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>If that is not the case, you can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCompletionSource%601&gt;</ph> object to wrap the operation in a task and thereby gain some of the benefits of <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> programmability, for example, support for exception propagation and continuations.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCompletionSource%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Custom schedulers</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <ph id="ph1">&lt;xref:System.Threading.ThreadPool?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>They only require that it execute as efficiently as possible on the host computer.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Related data structures</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The TPL has several new public types that are useful in both parallel and sequential scenarios.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>These include several thread-safe, fast and scalable collection classes in the <ph id="ph1">&lt;xref:System.Collections.Concurrent?displayProperty=fullName&gt;</ph> namespace, and several new synchronization types, for example, <ph id="ph2">&lt;xref:System.Threading.Semaphore?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.ManualResetEventSlim?displayProperty=fullName&gt;</ph>, which are more efficient than their predecessors for specific kinds of workloads.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Other new types in the .NET Framework 4, for example, <ph id="ph1">&lt;xref:System.Threading.Barrier?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.SpinLock?displayProperty=fullName&gt;</ph>, provide functionality that was not available in earlier releases.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Data Structures for Parallel Programming<ept id="p1">](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Custom task types</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>We recommend that you do not inherit from <ph id="ph1">&lt;xref:System.Threading.Tasks.Task?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Instead, we recommend that you use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.AsyncState%2A&gt;</ph> property to associate additional data or state with a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>You can also use extension methods to extend the functionality of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>For more information about extension methods, see <bpt id="p1">[</bpt>Extension Methods<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/extension-methods.md)</ept> and <bpt id="p2">[</bpt>Extension Methods<ept id="p2">](~/docs/visual-basic/programming-guide/language-features/procedures/extension-methods.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>If you must inherit from <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, you cannot use <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph>, or the <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskFactory?displayProperty=fullName&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.Tasks.TaskFactory%601?displayProperty=fullName&gt;</ph>, or <ph id="ph7">&lt;xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=fullName&gt;</ph> classes to create instances of your custom task type because these mechanisms create only <ph id="ph8">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph9">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>In addition, you cannot use the task continuation mechanisms that are provided by <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph>, and  <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskFactory%601&gt;</ph> to create instances of your custom task type because these mechanisms also create only <ph id="ph5">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and  <ph id="ph6">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Related topics</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Title</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept></source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Describes how continuations work.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept></source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Describes the difference between attached and detached child tasks.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Task Cancellation<ept id="p1">](../../../docs/standard/parallel-programming/task-cancellation.md)</ept></source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Describes the cancellation support that is built into the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept></source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Describes how exceptions on concurrent threads are handled.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Use Parallel.Invoke to Execute Parallel Operations<ept id="p1">](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)</ept></source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Describes how to use <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.Invoke%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Return a Value from a Task<ept id="p1">](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)</ept></source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Describes how to return values from tasks.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Cancel a Task and Its Children<ept id="p1">](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept></source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Describes how to cancel tasks.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Create Pre-Computed Tasks<ept id="p1">](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md)</ept></source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Describes how to use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=fullName&gt;</ph> method to retrieve the results of asynchronous download operations that are held in a cache.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Traverse a Binary Tree with Parallel Tasks<ept id="p1">](../../../docs/standard/parallel-programming/how-to-traverse-a-binary-tree-with-parallel-tasks.md)</ept></source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Describes how to use tasks to traverse a binary tree.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>How to: Unwrap a Nested Task<ept id="p1">](../../../docs/standard/parallel-programming/how-to-unwrap-a-nested-task.md)</ept></source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Demonstrates how to use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A&gt;</ph> extension method.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Parallelism<ept id="p1">](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)</ept></source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Describes how to use <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A&gt;</ph> to create parallel loops over data.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Parallel Programming<ept id="p1">](../../../docs/standard/parallel-programming/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Top level node for .NET Framework parallel programming.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Parallel Programming<ept id="p1">](../../../docs/standard/parallel-programming/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework<ept id="p1">](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>