{"content":"---\ntitle: \"Generic Classes - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"C# language, generic classes\"\n  - \"generics [C#], classes\"\nms.assetid: 27d6f256-cd61-41e3-bc6e-b990a53b0224\n---\n# Generic Classes (C# Programming Guide)\nGeneric classes encapsulate operations that are not specific to a particular data type. The most common use for generic classes is with collections like linked lists, hash tables, stacks, queues, trees, and so on. Operations such as adding and removing items from the collection are performed in basically the same way regardless of the type of data being stored.  \n  \n For most scenarios that require collection classes, the recommended approach is to use the ones provided in the .NET class library. For more information about using these classes, see [Generic Collections in .NET](../../../standard/generics/collections.md).  \n  \n Typically, you create generic classes by starting with an existing concrete class, and changing types into type parameters one at a time until you reach the optimal balance of generalization and usability. When creating your own generic classes, important considerations include the following:  \n  \n-   Which types to generalize into type parameters.  \n  \n     As a rule, the more types you can parameterize, the more flexible and reusable your code becomes. However, too much generalization can create code that is difficult for other developers to read or understand.  \n  \n-   What constraints, if any, to apply to the type parameters (See [Constraints on Type Parameters](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md)).  \n  \n     A good rule is to apply the maximum constraints possible that will still let you handle the types you must handle. For example, if you know that your generic class is intended for use only with reference types, apply the class constraint. That will prevent unintended use of your class with value types, and will enable you to use the `as` operator on `T`, and check for null values.  \n  \n-   Whether to factor generic behavior into base classes and subclasses.  \n  \n     Because generic classes can serve as base classes, the same design considerations apply here as with non-generic classes. See the rules about inheriting from generic base classes later in this topic.  \n  \n-   Whether to implement one or more generic interfaces.  \n  \n     For example, if you are designing a class that will be used to create items in a generics-based collection, you may have to implement an interface such as <xref:System.IComparable%601> where `T` is the type of your class.  \n  \n For an example of a simple generic class, see [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md).  \n  \n The rules for type parameters and constraints have several implications for generic class behavior, especially regarding inheritance and member accessibility. Before proceeding, you should understand some terms. For a generic class `Node<T>,` client code can reference the class either by specifying a type argument, to create a closed constructed type (`Node<int>`). Alternatively, it can leave the type parameter unspecified, for example when you specify a generic base class, to create an open constructed type (`Node<T>`). Generic classes can inherit from concrete, closed constructed, or open constructed base classes:  \n  \n [!code-csharp[csProgGuideGenerics#16](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#16)]  \n  \n Non-generic, in other words, concrete, classes can inherit from closed constructed base classes, but not from open constructed classes or from type parameters because there is no way at run time for client code to supply the type argument required to instantiate the base class.  \n  \n [!code-csharp[csProgGuideGenerics#17](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#17)]  \n  \n Generic classes that inherit from open constructed types must supply type arguments for any base class type parameters that are not shared by the inheriting class, as demonstrated in the following code:  \n  \n [!code-csharp[csProgGuideGenerics#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#18)]  \n  \n Generic classes that inherit from open constructed types must specify constraints that are a superset of, or imply, the constraints on the base type:  \n  \n [!code-csharp[csProgGuideGenerics#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#19)]  \n  \n Generic types can use multiple type parameters and constraints, as follows:  \n  \n [!code-csharp[csProgGuideGenerics#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#20)]  \n  \n Open constructed and closed constructed types can be used as method parameters:  \n  \n [!code-csharp[csProgGuideGenerics#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#21)]  \n  \n If a generic class implements an interface, all instances of that class can be cast to that interface.  \n  \n Generic classes are invariant. In other words, if an input parameter specifies a `List<BaseClass>`, you will get a compile-time error if you try to provide a `List<DerivedClass>`.  \n  \n## See also\n\n- <xref:System.Collections.Generic>\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [Generics](../../../csharp/programming-guide/generics/index.md)\n- [Saving the State of Enumerators](https://blogs.msdn.microsoft.com/wesdyer/2006/01/13/saving-the-state-of-enumerators/)\n- [An Inheritance Puzzle, Part One](https://blogs.msdn.microsoft.com/ericlippert/2007/07/27/an-inheritance-puzzle-part-one/)\n","nodes":[{"pos":[4,226],"embed":true,"restype":"x-metadata","content":"title: \"Generic Classes - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"C# language, generic classes\"\n  - \"generics [C#], classes\"\nms.assetid: 27d6f256-cd61-41e3-bc6e-b990a53b0224","nodes":[{"content":"Generic Classes - C# Programming Guide","nodes":[{"pos":[0,38],"content":"Generic Classes - C# Programming Guide","nodes":[{"content":"Generic Classes - C# Programming Guide","pos":[0,38]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[233,271],"content":"Generic Classes (C# Programming Guide)","linkify":"Generic Classes (C# Programming Guide)","nodes":[{"content":"Generic Classes (C# Programming Guide)","pos":[0,38]}]},{"content":"Generic classes encapsulate operations that are not specific to a particular data type.","pos":[272,359]},{"content":"The most common use for generic classes is with collections like linked lists, hash tables, stacks, queues, trees, and so on.","pos":[360,485]},{"content":"Operations such as adding and removing items from the collection are performed in basically the same way regardless of the type of data being stored.","pos":[486,635]},{"content":"For most scenarios that require collection classes, the recommended approach is to use the ones provided in the .NET class library.","pos":[642,773]},{"content":"For more information about using these classes, see <bpt id=\"p1\">[</bpt>Generic Collections in .NET<ept id=\"p1\">](../../../standard/generics/collections.md)</ept>.","pos":[774,899],"source":" For more information about using these classes, see [Generic Collections in .NET](../../../standard/generics/collections.md)."},{"content":"Typically, you create generic classes by starting with an existing concrete class, and changing types into type parameters one at a time until you reach the optimal balance of generalization and usability.","pos":[906,1111]},{"content":"When creating your own generic classes, important considerations include the following:","pos":[1112,1199]},{"content":"Which types to generalize into type parameters.","pos":[1209,1256]},{"content":"As a rule, the more types you can parameterize, the more flexible and reusable your code becomes.","pos":[1267,1364]},{"content":"However, too much generalization can create code that is difficult for other developers to read or understand.","pos":[1365,1475]},{"pos":[1485,1660],"content":"What constraints, if any, to apply to the type parameters (See <bpt id=\"p1\">[</bpt>Constraints on Type Parameters<ept id=\"p1\">](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md)</ept>).","source":"What constraints, if any, to apply to the type parameters (See [Constraints on Type Parameters](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md))."},{"content":"A good rule is to apply the maximum constraints possible that will still let you handle the types you must handle.","pos":[1671,1785]},{"content":"For example, if you know that your generic class is intended for use only with reference types, apply the class constraint.","pos":[1786,1909]},{"content":"That will prevent unintended use of your class with value types, and will enable you to use the <ph id=\"ph1\">`as`</ph> operator on <ph id=\"ph2\">`T`</ph>, and check for null values.","pos":[1910,2054],"source":" That will prevent unintended use of your class with value types, and will enable you to use the `as` operator on `T`, and check for null values."},{"content":"Whether to factor generic behavior into base classes and subclasses.","pos":[2064,2132]},{"content":"Because generic classes can serve as base classes, the same design considerations apply here as with non-generic classes.","pos":[2143,2264]},{"content":"See the rules about inheriting from generic base classes later in this topic.","pos":[2265,2342]},{"content":"Whether to implement one or more generic interfaces.","pos":[2352,2404]},{"pos":[2415,2636],"content":"For example, if you are designing a class that will be used to create items in a generics-based collection, you may have to implement an interface such as <ph id=\"ph1\">&lt;xref:System.IComparable%601&gt;</ph> where <ph id=\"ph2\">`T`</ph> is the type of your class.","source":"For example, if you are designing a class that will be used to create items in a generics-based collection, you may have to implement an interface such as <xref:System.IComparable%601> where `T` is the type of your class."},{"pos":[2643,2788],"content":"For an example of a simple generic class, see <bpt id=\"p1\">[</bpt>Introduction to Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept>.","source":"For an example of a simple generic class, see [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)."},{"content":"The rules for type parameters and constraints have several implications for generic class behavior, especially regarding inheritance and member accessibility.","pos":[2795,2953]},{"content":"Before proceeding, you should understand some terms.","pos":[2954,3006]},{"content":"For a generic class <ph id=\"ph1\">`Node&lt;T&gt;,`</ph> client code can reference the class either by specifying a type argument, to create a closed constructed type (<ph id=\"ph2\">`Node&lt;int&gt;`</ph>).","pos":[3007,3162],"source":" For a generic class `Node<T>,` client code can reference the class either by specifying a type argument, to create a closed constructed type (`Node<int>`)."},{"content":"Alternatively, it can leave the type parameter unspecified, for example when you specify a generic base class, to create an open constructed type (<ph id=\"ph1\">`Node&lt;T&gt;`</ph>).","pos":[3163,3321],"source":" Alternatively, it can leave the type parameter unspecified, for example when you specify a generic base class, to create an open constructed type (`Node<T>`)."},{"content":"Generic classes can inherit from concrete, closed constructed, or open constructed base classes:","pos":[3322,3418]},{"content":"Non-generic, in other words, concrete, classes can inherit from closed constructed base classes, but not from open constructed classes or from type parameters because there is no way at run time for client code to supply the type argument required to instantiate the base class.","pos":[3556,3834]},{"content":"Generic classes that inherit from open constructed types must supply type arguments for any base class type parameters that are not shared by the inheriting class, as demonstrated in the following code:","pos":[3972,4174]},{"content":"Generic classes that inherit from open constructed types must specify constraints that are a superset of, or imply, the constraints on the base type:","pos":[4312,4461]},{"content":"Generic types can use multiple type parameters and constraints, as follows:","pos":[4599,4674]},{"content":"Open constructed and closed constructed types can be used as method parameters:","pos":[4812,4891]},{"content":"If a generic class implements an interface, all instances of that class can be cast to that interface.","pos":[5029,5131]},{"content":"Generic classes are invariant.","pos":[5138,5168]},{"content":"In other words, if an input parameter specifies a <ph id=\"ph1\">`List&lt;BaseClass&gt;`</ph>, you will get a compile-time error if you try to provide a <ph id=\"ph2\">`List&lt;DerivedClass&gt;`</ph>.","pos":[5169,5317],"source":" In other words, if an input parameter specifies a `List<BaseClass>`, you will get a compile-time error if you try to provide a `List<DerivedClass>`."},{"pos":[5326,5334],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5374,5440],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[5443,5506],"content":"<bpt id=\"p1\">[</bpt>Generics<ept id=\"p1\">](../../../csharp/programming-guide/generics/index.md)</ept>","source":"[Generics](../../../csharp/programming-guide/generics/index.md)"},{"pos":[5509,5628],"content":"<bpt id=\"p1\">[</bpt>Saving the State of Enumerators<ept id=\"p1\">](https://blogs.msdn.microsoft.com/wesdyer/2006/01/13/saving-the-state-of-enumerators/)</ept>","source":"[Saving the State of Enumerators](https://blogs.msdn.microsoft.com/wesdyer/2006/01/13/saving-the-state-of-enumerators/)"},{"pos":[5631,5753],"content":"<bpt id=\"p1\">[</bpt>An Inheritance Puzzle, Part One<ept id=\"p1\">](https://blogs.msdn.microsoft.com/ericlippert/2007/07/27/an-inheritance-puzzle-part-one/)</ept>","source":"[An Inheritance Puzzle, Part One](https://blogs.msdn.microsoft.com/ericlippert/2007/07/27/an-inheritance-puzzle-part-one/)"}]}