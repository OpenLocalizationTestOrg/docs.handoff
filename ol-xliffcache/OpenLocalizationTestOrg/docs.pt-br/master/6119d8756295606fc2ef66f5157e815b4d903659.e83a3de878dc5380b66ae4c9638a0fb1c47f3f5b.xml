{"content":"---\ntitle: \"Using Variance in Interfaces for Generic Collections (C#)\"\nms.date: 07/20/2015\nms.assetid: a44f0708-10fa-4c76-82cd-daa6e6b31e8e\n---\n# Using Variance in Interfaces for Generic Collections (C#)\nA covariant interface allows its methods to return more derived types than those specified in the interface. A contravariant interface allows its methods to accept parameters of less derived types than those specified in the interface.  \n  \n In .NET Framework 4, several existing interfaces became covariant and contravariant. These include <xref:System.Collections.Generic.IEnumerable%601> and <xref:System.IComparable%601>. This enables you to reuse methods that operate with generic collections of base types for collections of derived types.  \n  \n For a list of variant interfaces in the .NET Framework, see [Variance in Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).  \n  \n## Converting Generic Collections  \n The following example illustrates the benefits of covariance support in the <xref:System.Collections.Generic.IEnumerable%601> interface. The `PrintFullName` method accepts a collection of the `IEnumerable<Person>` type as a parameter. However, you can reuse it for a collection of the `IEnumerable<Employee>` type because `Employee` inherits `Person`.  \n  \n```csharp  \n// Simple hierarchy of classes.  \npublic class Person  \n{  \n    public string FirstName { get; set; }  \n    public string LastName { get; set; }  \n}  \n  \npublic class Employee : Person { }  \n  \nclass Program  \n{  \n    // The method has a parameter of the IEnumerable<Person> type.  \n    public static void PrintFullName(IEnumerable<Person> persons)  \n    {  \n        foreach (Person person in persons)  \n        {  \n            Console.WriteLine(\"Name: {0} {1}\",  \n            person.FirstName, person.LastName);  \n        }  \n    }  \n  \n    public static void Test()  \n    {  \n        IEnumerable<Employee> employees = new List<Employee>();  \n  \n        // You can pass IEnumerable<Employee>,   \n        // although the method expects IEnumerable<Person>.  \n  \n        PrintFullName(employees);  \n  \n    }  \n}  \n```  \n  \n## Comparing Generic Collections  \n The following example illustrates the benefits of contravariance support in the <xref:System.Collections.Generic.IComparer%601> interface. The `PersonComparer` class implements the `IComparer<Person>` interface. However, you can reuse this class to compare a sequence of objects of the `Employee` type because `Employee` inherits `Person`.  \n  \n```csharp  \n// Simple hierarchy of classes.  \npublic class Person  \n{  \n    public string FirstName { get; set; }  \n    public string LastName { get; set; }  \n}  \n  \npublic class Employee : Person { }  \n  \n// The custom comparer for the Person type  \n// with standard implementations of Equals()  \n// and GetHashCode() methods.  \nclass PersonComparer : IEqualityComparer<Person>  \n{  \n    public bool Equals(Person x, Person y)  \n    {              \n        if (Object.ReferenceEquals(x, y)) return true;  \n        if (Object.ReferenceEquals(x, null) ||  \n            Object.ReferenceEquals(y, null))  \n            return false;              \n        return x.FirstName == y.FirstName && x.LastName == y.LastName;  \n    }  \n    public int GetHashCode(Person person)  \n    {  \n        if (Object.ReferenceEquals(person, null)) return 0;  \n        int hashFirstName = person.FirstName == null  \n            ? 0 : person.FirstName.GetHashCode();  \n        int hashLastName = person.LastName.GetHashCode();  \n        return hashFirstName ^ hashLastName;  \n    }  \n}  \n  \nclass Program  \n{  \n  \n    public static void Test()  \n    {  \n        List<Employee> employees = new List<Employee> {  \n               new Employee() {FirstName = \"Michael\", LastName = \"Alexander\"},  \n               new Employee() {FirstName = \"Jeff\", LastName = \"Price\"}  \n            };  \n  \n        // You can pass PersonComparer,   \n        // which implements IEqualityComparer<Person>,  \n        // although the method expects IEqualityComparer<Employee>.  \n  \n        IEnumerable<Employee> noduplicates =  \n            employees.Distinct<Employee>(new PersonComparer());  \n  \n        foreach (var employee in noduplicates)  \n            Console.WriteLine(employee.FirstName + \" \" + employee.LastName);  \n    }  \n}  \n```  \n  \n## See also\n\n- [Variance in Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)\n","nodes":[{"pos":[4,139],"embed":true,"restype":"x-metadata","content":"title: \"Using Variance in Interfaces for Generic Collections (C#)\"\nms.date: 07/20/2015\nms.assetid: a44f0708-10fa-4c76-82cd-daa6e6b31e8e","nodes":[{"content":"Using Variance in Interfaces for Generic Collections (C#)","nodes":[{"pos":[0,57],"content":"Using Variance in Interfaces for Generic Collections (C#)","nodes":[{"content":"Using Variance in Interfaces for Generic Collections (C#)","pos":[0,57]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[146,203],"content":"Using Variance in Interfaces for Generic Collections (C#)","linkify":"Using Variance in Interfaces for Generic Collections (C#)","nodes":[{"content":"Using Variance in Interfaces for Generic Collections (C#)","pos":[0,57]}]},{"content":"A covariant interface allows its methods to return more derived types than those specified in the interface.","pos":[204,312]},{"content":"A contravariant interface allows its methods to accept parameters of less derived types than those specified in the interface.","pos":[313,439]},{"content":"In .NET Framework 4, several existing interfaces became covariant and contravariant.","pos":[446,530]},{"content":"These include <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IComparable%601&gt;</ph>.","pos":[531,629],"source":" These include <xref:System.Collections.Generic.IEnumerable%601> and <xref:System.IComparable%601>."},{"content":"This enables you to reuse methods that operate with generic collections of base types for collections of derived types.","pos":[630,749]},{"pos":[756,961],"content":"For a list of variant interfaces in the .NET Framework, see <bpt id=\"p1\">[</bpt>Variance in Generic Interfaces (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)</ept>.","source":"For a list of variant interfaces in the .NET Framework, see [Variance in Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)."},{"pos":[970,1000],"content":"Converting Generic Collections","linkify":"Converting Generic Collections","nodes":[{"content":"Converting Generic Collections","pos":[0,30]}]},{"content":"The following example illustrates the benefits of covariance support in the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.","pos":[1004,1140],"source":"The following example illustrates the benefits of covariance support in the <xref:System.Collections.Generic.IEnumerable%601> interface."},{"content":"The <ph id=\"ph1\">`PrintFullName`</ph> method accepts a collection of the <ph id=\"ph2\">`IEnumerable&lt;Person&gt;`</ph> type as a parameter.","pos":[1141,1238],"source":" The `PrintFullName` method accepts a collection of the `IEnumerable<Person>` type as a parameter."},{"content":"However, you can reuse it for a collection of the <ph id=\"ph1\">`IEnumerable&lt;Employee&gt;`</ph> type because <ph id=\"ph2\">`Employee`</ph> inherits <ph id=\"ph3\">`Person`</ph>.","pos":[1239,1355],"source":" However, you can reuse it for a collection of the `IEnumerable<Employee>` type because `Employee` inherits `Person`."},{"pos":[2198,2227],"content":"Comparing Generic Collections","linkify":"Comparing Generic Collections","nodes":[{"content":"Comparing Generic Collections","pos":[0,29]}]},{"content":"The following example illustrates the benefits of contravariance support in the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> interface.","pos":[2231,2369],"source":"The following example illustrates the benefits of contravariance support in the <xref:System.Collections.Generic.IComparer%601> interface."},{"content":"The <ph id=\"ph1\">`PersonComparer`</ph> class implements the <ph id=\"ph2\">`IComparer&lt;Person&gt;`</ph> interface.","pos":[2370,2442],"source":" The `PersonComparer` class implements the `IComparer<Person>` interface."},{"content":"However, you can reuse this class to compare a sequence of objects of the <ph id=\"ph1\">`Employee`</ph> type because <ph id=\"ph2\">`Employee`</ph> inherits <ph id=\"ph3\">`Person`</ph>.","pos":[2443,2570],"source":" However, you can reuse this class to compare a sequence of objects of the `Employee` type because `Employee` inherits `Person`."},{"pos":[4379,4387],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4391,4535],"content":"<bpt id=\"p1\">[</bpt>Variance in Generic Interfaces (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)</ept>","source":"[Variance in Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)"}]}