{"content":"---\ntitle: \"Transport: WSE 3.0 TCP Interoperability\"\nms.date: \"03/30/2017\"\nms.assetid: 5f7c3708-acad-4eb3-acb9-d232c77d1486\n---\n# Transport: WSE 3.0 TCP Interoperability\nThe WSE 3.0 TCP Interoperability Transport sample demonstrates how to implement a TCP duplex session as a custom Windows Communication Foundation (WCF) transport. It also demonstrates how you can use the extensibility of the channel layer to interface over the wire with existing deployed systems. The following steps show how to build this custom WCF transport:  \n  \n1.  Starting with a TCP socket, create client and server implementations of <xref:System.ServiceModel.Channels.IDuplexSessionChannel> that use DIME Framing to delineate message boundaries.  \n  \n2.  Create a channel factory that connects to a WSE TCP service and sends framed messages over the client <xref:System.ServiceModel.Channels.IDuplexSessionChannel>s.  \n  \n3.  Create a channel listener to accept incoming TCP connections and produce corresponding channels.  \n  \n4.  Ensure that any network-specific exceptions are normalized to the appropriate derived class of <xref:System.ServiceModel.CommunicationException>.  \n  \n5.  Add a binding element that adds the custom transport to a channel stack. For more information, see [Adding a Binding Element].  \n  \n## Creating IDuplexSessionChannel  \n The first step in writing the WSE 3.0 TCP Interoperability Transport is to create an implementation of <xref:System.ServiceModel.Channels.IDuplexSessionChannel> on top of a <xref:System.Net.Sockets.Socket>. `WseTcpDuplexSessionChannel` derives from <xref:System.ServiceModel.Channels.ChannelBase>. The logic of sending a message consists of two main pieces: (1) Encoding the message into bytes, and (2) framing those bytes and sending them on the wire.  \n  \n `ArraySegment<byte> encodedBytes = EncodeMessage(message);`  \n  \n `WriteData(encodedBytes);`  \n  \n In addition, a lock is taken so that the Send() calls preserve the IDuplexSessionChannel in-order guarantee, and so that calls to the underlying socket are synchronized correctly.  \n  \n `WseTcpDuplexSessionChannel` uses a <xref:System.ServiceModel.Channels.MessageEncoder> for translating a <xref:System.ServiceModel.Channels.Message> to and from byte[]. Because it is a transport, `WseTcpDuplexSessionChannel` is also responsible for applying the remote address that the channel was configured with. `EncodeMessage` encapsulates the logic for this conversion.  \n  \n `this.RemoteAddress.ApplyTo(message);`  \n  \n `return encoder.WriteMessage(message, maxBufferSize, bufferManager);`  \n  \n Once the <xref:System.ServiceModel.Channels.Message> is encoded into bytes, it must be transmitted on the wire. This requires a system for defining message boundaries. WSE 3.0 uses a version of [DIME](https://go.microsoft.com/fwlink/?LinkId=94999) as its framing protocol. `WriteData` encapsulates the framing logic to wrap a byte[] into a set of DIME records.  \n  \n The logic for receiving messages is very similar. The main complexity is handling the fact that a socket read can return less bytes than were requested. To receive a message, `WseTcpDuplexSessionChannel` reads bytes off the wire, decodes the DIME framing, and then uses the <xref:System.ServiceModel.Channels.MessageEncoder> for turning the byte[] into a <xref:System.ServiceModel.Channels.Message>.  \n  \n The base `WseTcpDuplexSessionChannel` assumes that it receives a connected socket. The base class handles socket shutdown. There are three places that interface with socket closure:  \n  \n-   OnAbort -- close the socket ungracefully (hard close).  \n  \n-   On[Begin]Close -- close the socket gracefully (soft close).  \n  \n-   session.CloseOutputSession -- shutdown the outbound data stream (half close).  \n  \n## Channel Factory  \n The next step in writing the TCP transport is to create an implementation of <xref:System.ServiceModel.Channels.IChannelFactory> for client channels.  \n  \n-   `WseTcpChannelFactory` derives from <xref:System.ServiceModel.Channels.ChannelFactoryBase>\\<IDuplexSessionChannel>. It is a factory that overrides `OnCreateChannel` to produce client channels.  \n  \n `protected override IDuplexSessionChannel OnCreateChannel(EndpointAddress remoteAddress, Uri via)`  \n  \n `{`  \n  \n `return new ClientWseTcpDuplexSessionChannel(encoderFactory, bufferManager, remoteAddress, via, this);`  \n  \n `}`  \n  \n-   `ClientWseTcpDuplexSessionChannel` adds logic to the base `WseTcpDuplexSessionChannel` to connect to a TCP server at `channel.Open` time. First the hostname is resolved to an IP address, as shown in the following code.  \n  \n `hostEntry = Dns.GetHostEntry(Via.Host);`  \n  \n-   Then the hostname is connected to the first available IP address in a loop, as shown in the following code.  \n  \n `IPAddress address = hostEntry.AddressList[i];`  \n  \n `socket = new Socket(address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);`  \n  \n `socket.Connect(new IPEndPoint(address, port));`  \n  \n-   As part of the channel contract, any domain-specific exceptions are wrapped, such as `SocketException` in <xref:System.ServiceModel.CommunicationException>.  \n  \n## Channel Listener  \n The next step in writing the TCP transport is to create an implementation of <xref:System.ServiceModel.Channels.IChannelListener> for accepting server channels.  \n  \n-   `WseTcpChannelListener` derives from <xref:System.ServiceModel.Channels.ChannelListenerBase>\\<IDuplexSessionChannel> and overrides On[Begin]Open and On[Begin]Close to control the lifetime of its listen socket. In OnOpen, a socket is created to listen on IP_ANY. More advanced implementations can create a second socket to listen on IPv6 as well. They can also allow the IP address to be specified in the hostname.  \n  \n `IPEndPoint localEndpoint = new IPEndPoint(IPAddress.Any, uri.Port);`  \n  \n `this.listenSocket = new Socket(localEndpoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);`  \n  \n `this.listenSocket.Bind(localEndpoint);`  \n  \n `this.listenSocket.Listen(10);`  \n  \n When a new socket is accepted, a server channel is initialized with this socket. All the input and output is already implemented in the base class, so this channel is responsible for initializing the socket.  \n  \n## Adding a Binding Element  \n Now that the factories and channels are built, they must be exposed to the ServiceModel runtime through a binding. A binding is a collection of binding elements that represents the communication stack associated with a service address. Each element in the stack is represented by a binding element.  \n  \n In the sample, the binding element is `WseTcpTransportBindingElement`, which derives from <xref:System.ServiceModel.Channels.TransportBindingElement>. It supports <xref:System.ServiceModel.Channels.IDuplexSessionChannel> and overrides the following methods to build the factories associated with our binding.  \n  \n `public IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context)`  \n  \n `{`  \n  \n `return (IChannelFactory<TChannel>)(object)new WseTcpChannelFactory(this, context);`  \n  \n `}`  \n  \n `public IChannelListener<TChannel> BuildChannelListener<TChannel>(BindingContext context)`  \n  \n `{`  \n  \n `return (IChannelListener<TChannel>)(object)new WseTcpChannelListener(this, context);`  \n  \n `}`  \n  \n It also contains members for cloning the `BindingElement` and returning our scheme (wse.tcp).  \n  \n## The WSE TCP Test Console  \n Test code for using this sample transport is available in TestCode.cs. The following instructions show how to set up the WSE `TcpSyncStockService` sample.  \n  \n The test code creates a custom binding that uses MTOM as the encoding and `WseTcpTransport` as the transport. It also sets up the AddressingVersion to be conformant with WSE 3.0, as shown in the following code.  \n  \n `CustomBinding binding = new CustomBinding();`  \n  \n `MtomMessageEncodingBindingElement mtomBindingElement = new MtomMessageEncodingBindingElement();`  \n  \n `mtomBindingElement.MessageVersion = MessageVersion.Soap11WSAddressingAugust2004;`  \n  \n `binding.Elements.Add(mtomBindingElement);`  \n  \n `binding.Elements.Add(new WseTcpTransportBindingElement());`  \n  \n It consists of two tests—one test sets up a typed client using code generated from the WSE 3.0 WSDL. The second test uses WCF as both the client and the server by sending messages directly on top of the channel APIs.  \n  \n When running the sample, the following output is expected.  \n  \n Client:  \n  \n```  \nCalling soap://stockservice.contoso.com/wse/samples/2003/06/TcpSyncStockService  \n  \nSymbol: FABRIKAM  \n        Name: Fabrikam, Inc.  \n        Last Price: 120  \n  \nSymbol: CONTOSO  \n        Name: Contoso Corp.  \n        Last Price: 50.07  \nPress enter.  \n  \nReceived Action: http://SayHello  \nReceived Body: to you.  \nHello to you.  \nPress enter.  \n  \nReceived Action: http://NotHello  \nReceived Body: to me.  \nPress enter.  \n```  \n  \n Server:  \n  \n```  \nListening for messages at soap://stockservice.contoso.com/wse/samples/2003/06/TcpSyncStockService  \n  \nPress any key to exit when done...  \n  \nRequest received.  \nSymbols:  \n        FABRIKAM  \n        CONTOSO  \n```  \n  \n#### To set up, build, and run the sample  \n  \n1.  To run this sample, you must have WSE 3.0 and the WSE `TcpSyncStockService` sample installed. You can download [WSE 3.0 from MSDN](https://go.microsoft.com/fwlink/?LinkId=95000).  \n  \n> [!NOTE]\n>  Because WSE 3.0 is not supported on [!INCLUDE[lserver](../../../../includes/lserver-md.md)], you cannot install or run the `TcpSyncStockService` sample on that operating system.  \n  \n1.  Once you install the `TcpSyncStockService` sample, do the following:  \n  \n    1.  Open the `TcpSyncStockService` in Visual Studio (Note that the TcpSyncStockService sample is installed with WSE 3.0. It is not part of this sample's code).  \n  \n    2.  Set the StockService project as the start up project.  \n  \n    3.  Open StockService.cs in the StockService project and comment out the [Policy] attribute on the `StockService` class. This disables security from the sample. While WCF can interoperate with WSE 3.0 secure endpoints, security is disabled to keep this sample focused on the custom TCP transport.  \n  \n    4.  Press F5 to start the `TcpSyncStockService`. The service starts in a new console window.  \n  \n    5.  Open this TCP transport sample in Visual Studio.  \n  \n    6.  Update the \"hostname\" variable in TestCode.cs to match the machine name running the `TcpSyncStockService`.  \n  \n    7.  Press F5 to start the TCP transport sample.  \n  \n    8.  The TCP transport test client starts in a new console. The client requests stock quotes from the service and then displays the results in its console window.  \n","nodes":[{"pos":[4,123],"embed":true,"restype":"x-metadata","content":"title: \"Transport: WSE 3.0 TCP Interoperability\"\nms.date: \"03/30/2017\"\nms.assetid: 5f7c3708-acad-4eb3-acb9-d232c77d1486","nodes":[{"content":"Transport: WSE 3.0 TCP Interoperability","nodes":[{"pos":[0,39],"content":"Transport: WSE 3.0 TCP Interoperability","nodes":[{"content":"Transport: WSE 3.0 TCP Interoperability","pos":[0,39]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[130,169],"content":"Transport: WSE 3.0 TCP Interoperability","linkify":"Transport: WSE 3.0 TCP Interoperability","nodes":[{"content":"Transport: WSE 3.0 TCP Interoperability","pos":[0,39]}]},{"content":"The WSE 3.0 TCP Interoperability Transport sample demonstrates how to implement a TCP duplex session as a custom Windows Communication Foundation (WCF) transport.","pos":[170,332]},{"content":"It also demonstrates how you can use the extensibility of the channel layer to interface over the wire with existing deployed systems.","pos":[333,467]},{"content":"The following steps show how to build this custom WCF transport:","pos":[468,532]},{"pos":[542,726],"content":"Starting with a TCP socket, create client and server implementations of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> that use DIME Framing to delineate message boundaries.","source":"Starting with a TCP socket, create client and server implementations of <xref:System.ServiceModel.Channels.IDuplexSessionChannel> that use DIME Framing to delineate message boundaries."},{"pos":[736,897],"content":"Create a channel factory that connects to a WSE TCP service and sends framed messages over the client <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph>s.","source":"Create a channel factory that connects to a WSE TCP service and sends framed messages over the client <xref:System.ServiceModel.Channels.IDuplexSessionChannel>s."},{"content":"Create a channel listener to accept incoming TCP connections and produce corresponding channels.","pos":[907,1003]},{"pos":[1013,1158],"content":"Ensure that any network-specific exceptions are normalized to the appropriate derived class of <ph id=\"ph1\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>.","source":"Ensure that any network-specific exceptions are normalized to the appropriate derived class of <xref:System.ServiceModel.CommunicationException>."},{"content":"Add a binding element that adds the custom transport to a channel stack.","pos":[1168,1240]},{"content":"For more information, see [Adding a Binding Element].","pos":[1241,1294]},{"pos":[1303,1333],"content":"Creating IDuplexSessionChannel","linkify":"Creating IDuplexSessionChannel","nodes":[{"content":"Creating IDuplexSessionChannel","pos":[0,30]}]},{"content":"The first step in writing the WSE 3.0 TCP Interoperability Transport is to create an implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> on top of a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[1337,1543],"source":"The first step in writing the WSE 3.0 TCP Interoperability Transport is to create an implementation of <xref:System.ServiceModel.Channels.IDuplexSessionChannel> on top of a <xref:System.Net.Sockets.Socket>."},{"content":"<ph id=\"ph1\">`WseTcpDuplexSessionChannel`</ph> derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelBase&gt;</ph>.","pos":[1544,1634],"source":"`WseTcpDuplexSessionChannel` derives from <xref:System.ServiceModel.Channels.ChannelBase>."},{"content":"The logic of sending a message consists of two main pieces: (1) Encoding the message into bytes, and (2) framing those bytes and sending them on the wire.","pos":[1635,1789]},{"content":"In addition, a lock is taken so that the Send() calls preserve the IDuplexSessionChannel in-order guarantee, and so that calls to the underlying socket are synchronized correctly.","pos":[1895,2074]},{"content":"<ph id=\"ph1\">`WseTcpDuplexSessionChannel`</ph> uses a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph> for translating a <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> to and from byte[].","pos":[2081,2249],"source":"`WseTcpDuplexSessionChannel` uses a <xref:System.ServiceModel.Channels.MessageEncoder> for translating a <xref:System.ServiceModel.Channels.Message> to and from byte[]."},{"content":"Because it is a transport, <ph id=\"ph1\">`WseTcpDuplexSessionChannel`</ph> is also responsible for applying the remote address that the channel was configured with.","pos":[2250,2395],"source":" Because it is a transport, `WseTcpDuplexSessionChannel` is also responsible for applying the remote address that the channel was configured with."},{"content":"<ph id=\"ph1\">`EncodeMessage`</ph> encapsulates the logic for this conversion.","pos":[2396,2455],"source":"`EncodeMessage` encapsulates the logic for this conversion."},{"content":"Once the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> is encoded into bytes, it must be transmitted on the wire.","pos":[2583,2694],"source":"Once the <xref:System.ServiceModel.Channels.Message> is encoded into bytes, it must be transmitted on the wire."},{"content":"This requires a system for defining message boundaries.","pos":[2695,2750]},{"content":"WSE 3.0 uses a version of <bpt id=\"p1\">[</bpt>DIME<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=94999)</ept> as its framing protocol.","pos":[2751,2855],"source":" WSE 3.0 uses a version of [DIME](https://go.microsoft.com/fwlink/?LinkId=94999) as its framing protocol."},{"content":"<ph id=\"ph1\">`WriteData`</ph> encapsulates the framing logic to wrap a byte[] into a set of DIME records.","pos":[2856,2943],"source":"`WriteData` encapsulates the framing logic to wrap a byte[] into a set of DIME records."},{"content":"The logic for receiving messages is very similar.","pos":[2950,2999]},{"content":"The main complexity is handling the fact that a socket read can return less bytes than were requested.","pos":[3000,3102]},{"content":"To receive a message, <ph id=\"ph1\">`WseTcpDuplexSessionChannel`</ph> reads bytes off the wire, decodes the DIME framing, and then uses the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph> for turning the byte[] into a <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph>.","pos":[3103,3349],"source":" To receive a message, `WseTcpDuplexSessionChannel` reads bytes off the wire, decodes the DIME framing, and then uses the <xref:System.ServiceModel.Channels.MessageEncoder> for turning the byte[] into a <xref:System.ServiceModel.Channels.Message>."},{"content":"The base <ph id=\"ph1\">`WseTcpDuplexSessionChannel`</ph> assumes that it receives a connected socket.","pos":[3356,3438],"source":"The base `WseTcpDuplexSessionChannel` assumes that it receives a connected socket."},{"content":"The base class handles socket shutdown.","pos":[3439,3478]},{"content":"There are three places that interface with socket closure:","pos":[3479,3537]},{"content":"OnAbort -- close the socket ungracefully (hard close).","pos":[3547,3601]},{"content":"On[Begin]Close -- close the socket gracefully (soft close).","pos":[3611,3670]},{"content":"session.CloseOutputSession -- shutdown the outbound data stream (half close).","pos":[3680,3757]},{"pos":[3766,3781],"content":"Channel Factory","linkify":"Channel Factory","nodes":[{"content":"Channel Factory","pos":[0,15]}]},{"pos":[3785,3934],"content":"The next step in writing the TCP transport is to create an implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelFactory&gt;</ph> for client channels.","source":"The next step in writing the TCP transport is to create an implementation of <xref:System.ServiceModel.Channels.IChannelFactory> for client channels."},{"content":"<ph id=\"ph1\">`WseTcpChannelFactory`</ph> derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelFactoryBase&gt;</ph><ph id=\"ph3\">\\&lt;</ph>IDuplexSessionChannel&gt;.","pos":[3944,4059],"source":"`WseTcpChannelFactory` derives from <xref:System.ServiceModel.Channels.ChannelFactoryBase>\\<IDuplexSessionChannel>."},{"content":"It is a factory that overrides <ph id=\"ph1\">`OnCreateChannel`</ph> to produce client channels.","pos":[4060,4136],"source":" It is a factory that overrides `OnCreateChannel` to produce client channels."},{"content":"<ph id=\"ph1\">`ClientWseTcpDuplexSessionChannel`</ph> adds logic to the base <ph id=\"ph2\">`WseTcpDuplexSessionChannel`</ph> to connect to a TCP server at <ph id=\"ph3\">`channel.Open`</ph> time.","pos":[4381,4518],"source":"`ClientWseTcpDuplexSessionChannel` adds logic to the base `WseTcpDuplexSessionChannel` to connect to a TCP server at `channel.Open` time."},{"content":"First the hostname is resolved to an IP address, as shown in the following code.","pos":[4519,4599]},{"content":"Then the hostname is connected to the first available IP address in a loop, as shown in the following code.","pos":[4657,4764]},{"pos":[4972,5128],"content":"As part of the channel contract, any domain-specific exceptions are wrapped, such as <ph id=\"ph1\">`SocketException`</ph> in <ph id=\"ph2\">&lt;xref:System.ServiceModel.CommunicationException&gt;</ph>.","source":"As part of the channel contract, any domain-specific exceptions are wrapped, such as `SocketException` in <xref:System.ServiceModel.CommunicationException>."},{"pos":[5137,5153],"content":"Channel Listener","linkify":"Channel Listener","nodes":[{"content":"Channel Listener","pos":[0,16]}]},{"pos":[5157,5317],"content":"The next step in writing the TCP transport is to create an implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph> for accepting server channels.","source":"The next step in writing the TCP transport is to create an implementation of <xref:System.ServiceModel.Channels.IChannelListener> for accepting server channels."},{"content":"<ph id=\"ph1\">`WseTcpChannelListener`</ph> derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ChannelListenerBase&gt;</ph><ph id=\"ph3\">\\&lt;</ph>IDuplexSessionChannel&gt; and overrides On[Begin]Open and On[Begin]Close to control the lifetime of its listen socket.","pos":[5327,5536],"source":"`WseTcpChannelListener` derives from <xref:System.ServiceModel.Channels.ChannelListenerBase>\\<IDuplexSessionChannel> and overrides On[Begin]Open and On[Begin]Close to control the lifetime of its listen socket."},{"content":"In OnOpen, a socket is created to listen on IP_ANY.","pos":[5537,5588]},{"content":"More advanced implementations can create a second socket to listen on IPv6 as well.","pos":[5589,5672]},{"content":"They can also allow the IP address to be specified in the hostname.","pos":[5673,5740]},{"content":"When a new socket is accepted, a server channel is initialized with this socket.","pos":[6014,6094]},{"content":"All the input and output is already implemented in the base class, so this channel is responsible for initializing the socket.","pos":[6095,6221]},{"pos":[6230,6254],"content":"Adding a Binding Element","linkify":"Adding a Binding Element","nodes":[{"content":"Adding a Binding Element","pos":[0,24]}]},{"content":"Now that the factories and channels are built, they must be exposed to the ServiceModel runtime through a binding.","pos":[6258,6372]},{"content":"A binding is a collection of binding elements that represents the communication stack associated with a service address.","pos":[6373,6493]},{"content":"Each element in the stack is represented by a binding element.","pos":[6494,6556]},{"content":"In the sample, the binding element is <ph id=\"ph1\">`WseTcpTransportBindingElement`</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.TransportBindingElement&gt;</ph>.","pos":[6563,6713],"source":"In the sample, the binding element is `WseTcpTransportBindingElement`, which derives from <xref:System.ServiceModel.Channels.TransportBindingElement>."},{"content":"It supports <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> and overrides the following methods to build the factories associated with our binding.","pos":[6714,6871],"source":" It supports <xref:System.ServiceModel.Channels.IDuplexSessionChannel> and overrides the following methods to build the factories associated with our binding."},{"pos":[7294,7387],"content":"It also contains members for cloning the <ph id=\"ph1\">`BindingElement`</ph> and returning our scheme (wse.tcp).","source":"It also contains members for cloning the `BindingElement` and returning our scheme (wse.tcp)."},{"pos":[7396,7420],"content":"The WSE TCP Test Console","linkify":"The WSE TCP Test Console","nodes":[{"content":"The WSE TCP Test Console","pos":[0,24]}]},{"content":"Test code for using this sample transport is available in TestCode.cs.","pos":[7424,7494]},{"content":"The following instructions show how to set up the WSE <ph id=\"ph1\">`TcpSyncStockService`</ph> sample.","pos":[7495,7578],"source":" The following instructions show how to set up the WSE `TcpSyncStockService` sample."},{"content":"The test code creates a custom binding that uses MTOM as the encoding and <ph id=\"ph1\">`WseTcpTransport`</ph> as the transport.","pos":[7585,7694],"source":"The test code creates a custom binding that uses MTOM as the encoding and `WseTcpTransport` as the transport."},{"content":"It also sets up the AddressingVersion to be conformant with WSE 3.0, as shown in the following code.","pos":[7695,7795]},{"content":"It consists of two tests—one test sets up a typed client using code generated from the WSE 3.0 WSDL.","pos":[8165,8265]},{"content":"The second test uses WCF as both the client and the server by sending messages directly on top of the channel APIs.","pos":[8266,8381]},{"content":"When running the sample, the following output is expected.","pos":[8388,8446]},{"content":"Client:","pos":[8453,8460]},{"content":"Server:","pos":[8908,8915]},{"pos":[9152,9188],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"content":"To run this sample, you must have WSE 3.0 and the WSE <ph id=\"ph1\">`TcpSyncStockService`</ph> sample installed.","pos":[9198,9291],"source":"To run this sample, you must have WSE 3.0 and the WSE `TcpSyncStockService` sample installed."},{"content":"You can download <bpt id=\"p1\">[</bpt>WSE 3.0 from MSDN<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=95000)</ept>.","pos":[9292,9376],"source":" You can download [WSE 3.0 from MSDN](https://go.microsoft.com/fwlink/?LinkId=95000)."},{"pos":[9384,9572],"content":"[!NOTE]\n Because WSE 3.0 is not supported on [!INCLUDE[lserver](../../../../includes/lserver-md.md)], you cannot install or run the `TcpSyncStockService` sample on that operating system.","leadings":["","> "],"nodes":[{"content":"Because WSE 3.0 is not supported on <ph id=\"ph1\">[!INCLUDE[lserver](../../../../includes/lserver-md.md)]</ph>, you cannot install or run the <ph id=\"ph2\">`TcpSyncStockService`</ph> sample on that operating system.","pos":[9,186],"source":"Because WSE 3.0 is not supported on [!INCLUDE[lserver](../../../../includes/lserver-md.md)], you cannot install or run the `TcpSyncStockService` sample on that operating system."}]},{"pos":[9582,9650],"content":"Once you install the <ph id=\"ph1\">`TcpSyncStockService`</ph> sample, do the following:","source":"Once you install the `TcpSyncStockService` sample, do the following:"},{"content":"Open the <ph id=\"ph1\">`TcpSyncStockService`</ph> in Visual Studio (Note that the TcpSyncStockService sample is installed with WSE 3.0.","pos":[9664,9780],"source":"Open the `TcpSyncStockService` in Visual Studio (Note that the TcpSyncStockService sample is installed with WSE 3.0."},{"content":"It is not part of this sample's code).","pos":[9781,9819]},{"content":"Set the StockService project as the start up project.","pos":[9833,9886]},{"content":"Open StockService.cs in the StockService project and comment out the [Policy] attribute on the <ph id=\"ph1\">`StockService`</ph> class.","pos":[9900,10016],"source":"Open StockService.cs in the StockService project and comment out the [Policy] attribute on the `StockService` class."},{"content":"This disables security from the sample.","pos":[10017,10056]},{"content":"While WCF can interoperate with WSE 3.0 secure endpoints, security is disabled to keep this sample focused on the custom TCP transport.","pos":[10057,10192]},{"content":"Press F5 to start the <ph id=\"ph1\">`TcpSyncStockService`</ph>.","pos":[10206,10250],"source":"Press F5 to start the `TcpSyncStockService`."},{"content":"The service starts in a new console window.","pos":[10251,10294]},{"content":"Open this TCP transport sample in Visual Studio.","pos":[10308,10356]},{"pos":[10370,10476],"content":"Update the \"hostname\" variable in TestCode.cs to match the machine name running the <ph id=\"ph1\">`TcpSyncStockService`</ph>.","source":"Update the \"hostname\" variable in TestCode.cs to match the machine name running the `TcpSyncStockService`."},{"content":"Press F5 to start the TCP transport sample.","pos":[10490,10533]},{"content":"The TCP transport test client starts in a new console.","pos":[10547,10601]},{"content":"The client requests stock quotes from the service and then displays the results in its console window.","pos":[10602,10704]}]}