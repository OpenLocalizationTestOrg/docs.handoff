<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">42ded63bacfb6ff2ceadde6fa37c7bddb413a933</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\methods.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e301c32b50601d66aaf77331b19733c8ee7235eb</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">01286edc130080cc9a04b14e25c2b6580019c00c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Methods | C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Overview of methods, method parameters, and method return values</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>.NET, .NET Core, C#</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Methods</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A method is a code block that contains a series of statements.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>A program causes the statements to be executed by calling the method and specifying any required method arguments.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In C#, every executed instruction is performed in the context of a method.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Main`</ph> method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic discusses named methods.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For information about anonymous functions, see <bpt id="p1">[</bpt>Anonymous Functions<ept id="p1">](https://msdn.microsoft.com/library/bb882516.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This topic contains the following sections:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Method signatures<ept id="p1">](#signatures)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Method invocation<ept id="p1">](#invocation)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Inherited and overridden methods<ept id="p1">](#inherited)</ept></source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Passing parameters<ept id="p1">](#passing)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Passing parameters by value<ept id="p1">](#byval)</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Passing parameters by reference<ept id="p1">](#byref)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Parameter arrays<ept id="p1">](#paramarray)</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Optional parameters and arguments<ept id="p1">](#optional)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Return values<ept id="p1">](#return)</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Extension methods<ept id="p1">](#extension)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Async Methods<ept id="p1">](#async)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Expression-bodied members<ept id="p1">](#expr)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Iterators<ept id="p1">](#iterators)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Method signatures</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Methods are declared in a <ph id="ph1">`class`</ph> or <ph id="ph2">`struct`</ph> by specifying:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An optional access level, such as <ph id="ph1">`public`</ph> or <ph id="ph2">`private`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`private`</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Optional modifiers such as <ph id="ph1">`abstract`</ph> or <ph id="ph2">`sealed`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The return value, or <ph id="ph1">`void`</ph> if the method has none.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The method name.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Any method parameters.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Method parameters are enclosed in parentheses and are separated by commas.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Empty parentheses indicate that the method requires no parameters.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>These parts together form the method signature.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A return type of a method is not part of the signature of the method for the purposes of method overloading.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following example defines a class named <ph id="ph1">`Motorcycle`</ph> that contains five methods:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#40<ept id="p2">](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`Motorcycle`</ph> class includes an overloaded method, <ph id="ph2">`Drive`</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Two methods have the same name, but must be differentiated by their parameter types.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Method invocation</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Methods can be either <bpt id="p1">*</bpt>instance<ept id="p1">*</ept> or <bpt id="p2">*</bpt>static<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You invoke a static method by referencing the name of the type to which the method belongs; static methods operate do not operate on instance data.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Attempting to call a static method through an object instance generates a compiler error.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Calling a method is like accessing a field.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>After the object name (if you are calling an instance method) or the type name (if you are calling a <ph id="ph1">`static`</ph> method), add a period, the name of the method, and parentheses.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Arguments are listed within the parentheses, and are separated by commas.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The method definition specifies the names and types of any parameters that are required.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In the following example, the <ph id="ph1">`Square`</ph> method includes a single parameter of type <ph id="ph2">`int`</ph> named <bpt id="p1">*</bpt>i<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The first method call passes the <ph id="ph1">`Square`</ph> method a variable of type <ph id="ph2">`int`</ph> named <bpt id="p1">*</bpt>num<ept id="p1">*</ept>; the second, a numeric constant; and the third, an expression.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#74<ept id="p2">](../../samples/snippets/csharp/concepts/methods/params74.cs#74)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The methods of the <ph id="ph1">`Motorcycle`</ph> class can therefore be called as in the following example.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The call to the <ph id="ph1">`Drive`</ph> method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The first becomes the value of the <ph id="ph1">`miles`</ph> parameter, the second the value of the <ph id="ph2">`speed`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#41<ept id="p2">](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can also used <bpt id="p1">*</bpt>named arguments<ept id="p1">*</ept> instead of positional arguments when invoking a method.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Arguments to the method can appear in any order, as long as all required arguments are present.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example uses named arguments to invoke the <ph id="ph1">`TestMotorcycle.Drive`</ph> method.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In this example, the named arguments are passed in the opposite order from the method's parameter list.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#45<ept id="p2">](../../samples/snippets/csharp/concepts/methods/named1.cs#45)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can invoke a method using both positional arguments and named arguments.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, a positional argument cannot follow a named argument.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The following example invokes the <ph id="ph1">`TestMotorcycle.Drive`</ph> method from the previous example using one positional argument and one named argument.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#46<ept id="p2">](../../samples/snippets/csharp/concepts/methods/named2.cs#46)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Inherited and overridden methods</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Since all types in the managed type system inherit directly or indirectly from the <ph id="ph1">@System.Object</ph> class, all types inherit its members, such as <ph id="ph2">@System.Object.Equals</ph>(System.Object), <ph id="ph3">@System.Object.GetType</ph>, and <ph id="ph4">@System.Object.ToString</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`Person`</ph> class, instantiates two <ph id="ph2">`Person`</ph> objects, and calls the <ph id="ph3">`Person.Equals`</ph> method to determine whether the two objects are equal.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Equals`</ph> method, however, is not defined in the <ph id="ph2">`Person`</ph> class; it is inherited from <ph id="ph3">@System.Object</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#104<ept id="p2">](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Types can override inherited members by using the <ph id="ph1">`override`</ph> keyword and providing an implementation for the overridden method.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The method signature must be the same as that of the overriden method.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The following example is like the previous one, except that it overrides the <ph id="ph1">@Object.Equals</ph>(System.Object) method.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>(It also overrides the <ph id="ph1">@Object.GetHashCode</ph> method, since the two methods are intended to provide consistent results.)</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#105<ept id="p2">](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Passing parameters</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Types in C# are either <bpt id="p1">*</bpt>value types<ept id="p1">*</ept> or <bpt id="p2">*</bpt>reference types<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For a list of built-in value types, see <bpt id="p1">[</bpt>Types and variables<ept id="p1">](./tour-of-csharp/types-and-variables.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>By default, both value types and reference types are passed to a method by value.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Passing parameters by value</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>It defines a variable of type <ph id="ph1">`int`</ph>, which is a value type, initializes its value to 20, and passes it to a method named <ph id="ph2">`ModifyValue`</ph> that changes the variable's value to 30.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>When the method returns, however, the variable's value remains unchanged.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#10<ept id="p2">](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>That is, the method receives not the object itself, but an argument that indicates the location of the object.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example defines a class (which is a reference type) named <ph id="ph1">`SampleRefType`</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>It instantiates a <ph id="ph1">`SampleRefType`</ph> object, assigns 44 to its <ph id="ph2">`value`</ph> field, and passes the object to the <ph id="ph3">`ModifyObject`</ph> method.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>But because a reference type is used, the result is different.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The modification that is made in <ph id="ph1">`ModifyObject`</ph> to the <ph id="ph2">`obj.value`</ph> field also changes the <ph id="ph3">`value`</ph> field of the argument, <ph id="ph4">`rt`</ph>, in the <ph id="ph5">`Main`</ph> method to 33, as the output from the example shows.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#42<ept id="p2">](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Passing parameters by reference</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>You pass a parameter by reference when you want to change the value of an argument in a method and want to refect that change when control returns to the calling method.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>To pass a parameter by reference, you use the <ph id="ph1">`ref`</ph> or <ph id="ph2">`out`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The following example is identical to the previous one, except the value is passed by reference to the <ph id="ph1">`ModifyValue`</ph> method.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>When the value of the parameter is modified in the <ph id="ph1">`ModifyValue`</ph> method, the change in value is reflected when control returns to the caller.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#106<ept id="p2">](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>A common pattern that uses by ref parameters involves swapping the values of variables.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You pass two variables to a method by reference, and the method swaps their contents.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The following example swaps integer values.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#106<ept id="p2">](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Parameter arrays</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>By using the <ph id="ph1">`params`</ph> keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The parameter tagged with the <ph id="ph1">`params`</ph> keyword must must be an array type, and it must be the last parameter in the method's parameter list.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A caller can then invoke the method in either of three ways:</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>By passing an array of the appropriate type that contains the desired number of elements.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>By passing a comma-separated list of individual arguments of the appropriate type to the method.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>By not providing an argument to the parameter array.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The following example defines a method named <ph id="ph1">`DoStringOperation`</ph> that performs the string operation specified by its first parameter, a <ph id="ph2">`StringOperation`</ph> enumeration member.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The strings upon which it is to perform the operation are defined by a parameter array.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Main`</ph> method illustrates all three ways of invoking the method.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Note that the method tagged with the <ph id="ph1">`params`</ph> keyword must be prepared to handle the case in which no argument is supplied for the parameter array, so that its value is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#106<ept id="p2">](../../samples/snippets/csharp/concepts/methods/byref108.cs#108)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Optional parameters and arguments</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>A method definition can specify that its parameters are required or that they are optional.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>By default, parameters are required.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Optional parameters are specified by including the parameter's default value in the method definition.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The parameter's default value must be assigned by one of the following kinds of expressions:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>A constant, such as a literal string or number.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>An expression of the form <ph id="ph1">`new ValType`</ph>, where <ph id="ph2">`ValType`</ph> is a value type.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Note that this invokes the value type's implicit default constructor, which is not an actual member of the type.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>An expression of the form <ph id="ph1">`default(ValType)`</ph>, where <ph id="ph2">`ValType`</ph> is a value type.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The following example defines a method, <ph id="ph1">`ExampleMethod`</ph>, that has one required and two optional parameters.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#21<ept id="p2">](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>In the case of the  <ph id="ph1">`ExampleMethod`</ph> method, for example, if the caller supplies an argument for the <ph id="ph2">`description`</ph> parameter, it must also supply one for the <ph id="ph3">`optionalInt`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");`</ph> is a valid method call; <ph id="ph2">`opt.ExampleMethod(2, , "Addition of 2 and 0);`</ph> generates an "Argument missing" compiler error.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The following example calls the <ph id="ph1">`ExampleMethod`</ph> method three times.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The first two method calls use positional arguments.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The first omits both optional arguments, while the second omits the last argument.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the <ph id="ph1">`description`</ph> parameter while omitting the <ph id="ph2">`optionalInt`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#22<ept id="p2">](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The use of optional parameters affects <bpt id="p1">*</bpt>overload resolution<ept id="p1">*</ept>, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Omitted arguments for optional parameters are ignored.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Return values</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Methods can return a value to the caller.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If the return type (the type listed before the method name) is not <ph id="ph1">`void`</ph>, the method can return the value by using the <ph id="ph2">`return`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>A statement with the <ph id="ph1">`return`</ph> keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Methods with a non-void return type are required to use the <ph id="ph1">`return`</ph> keyword to return a value.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`return`</ph> keyword also stops the execution of the method.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>If the return type is <ph id="ph1">`void`</ph>, a <ph id="ph2">`return`</ph> statement without a value is still useful to stop the execution of the method.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Without the <ph id="ph1">`return`</ph> keyword, the method will stop executing when it reaches the end of the code block.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>For example, these two methods use the <ph id="ph1">`return`</ph> keyword to return integers:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#44<ept id="p2">](../../samples/snippets/csharp/concepts/methods/return44.cs#44)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>You can also assign the return value to a variable.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>For example, the following two code examples accomplish the same goal:</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#45<ept id="p2">](../../samples/snippets/csharp/concepts/methods/return44.cs#45)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#46<ept id="p2">](../../samples/snippets/csharp/concepts/methods/return44.cs#46)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Using a local variable, in this case, <ph id="ph1">`result`</ph>, to store a value is optional.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Sometimes, you want your method to return more than a single value.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Starting with C# 7.0, you can do this easily by using <bpt id="p1">*</bpt>tuple types<ept id="p1">*</ept> and <bpt id="p2">*</bpt>tuple literals<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The tuple type defines the data types of the tuple's elements.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Tuple literals provide the actual values of the returned tuple.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>In teh following example, <ph id="ph1">`(string, string, string, int)`</ph> defines the tuple type that is returned by the <ph id="ph2">`GetPersonalInfo`</ph> method.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The expression <ph id="ph1">`(per.FirstName, per.MiddleName, per.LastName, per.Age)`</ph> is the tuple literal; the method returns the first, middle, and last name, along with the age, of a <ph id="ph2">`PersonInfo`</ph> object.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The caller can then consume the returned tuple with code like the following:</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Names can also be assigned to the tuple elements in the tuple type definition.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The following example shows an alternate version of the <ph id="ph1">`GetPersonalInfo`</ph> method that uses named elements:</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The previous call to the <ph id="ph1">`GetPersonInfo`</ph> method can then be modified as follows:</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>In the following example, changes to the contents of the <ph id="ph1">`values`</ph> array that are made in the <ph id="ph2">`DoubleValues`</ph> method are observable by any code that has a reference to the array.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#101<ept id="p2">](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Ordinarily, there are two ways to add a method to an existing type:</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Modify the source code for that type.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You cannot do this, of course, if you do not own the type's source code.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>And this becomes a breaking change if you also add any private data fields to support the method.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Define the new method in a derived class.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Nor can it be used to "add" a method to a sealed class.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The extension method also does not have to reside in the same assembly as the type it extends.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>You call an extension method as if it were a defined member of a type.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Extension Methods<ept id="p1">](https://msdn.microsoft.com/library/bb383977.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Async Methods</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>If you mark a method with the <bpt id="p1">[</bpt>async<ept id="p1">](https://msdn.microsoft.com/library/hh156513.aspx)</ept> modifier, you can use the <bpt id="p2">[</bpt>await<ept id="p2">](https://msdn.microsoft.com/library/hh156528.aspx)</ept> operator in the method.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>When control reaches an <ph id="ph1">`await`</ph> expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the <ph id="ph2">`await`</ph> keyword is suspended until the awaited task completes.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>When the task is complete, execution can resume in the method.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>An async method returns to the caller when either it encounters the first awaited object that’s not yet complete or it gets to the end of the async method, whichever occurs first.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>An async method can have a return type of <ph id="ph1">@System.Threading.Tasks.Task</ph><ph id="ph2">&lt;TResult&gt;</ph>, <ph id="ph3">@System.Threading.Tasks.Task</ph>, or <ph id="ph4">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`void`</ph> return type is used primarily to define event handlers, where a <ph id="ph2">`void`</ph> return type is required.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>An async method that returns <ph id="ph1">`void`</ph> can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>C# 7, when it is released, will ease this restriction to allow an async method <bpt id="p1">[</bpt>to return any task-like type<ept id="p1">](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`DelayAsync`</ph> is an async method that has a return statement that returns an integer.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Because it is an async method, its method declaration must have a return type of <ph id="ph1">`Task&lt;int&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Because the return type is <ph id="ph1">`Task&lt;int&gt;`</ph>, the evaluation of the <ph id="ph2">`await`</ph> expression in <ph id="ph3">`DoSomethingAsync`</ph> produces an integer, as the following <ph id="ph4">`int result = await delayTask`</ph> statement demonstrates.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>csSnippets.Methods#102<ept id="p2">](../../samples/snippets/csharp/concepts/methods/async1.cs#102)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>An async method can't declare any <bpt id="p1">[</bpt>ref<ept id="p1">](https://msdn.microsoft.com/library/14akc2c7.aspx)</ept> or <bpt id="p2">[</bpt>out<ept id="p2">](https://msdn.microsoft.com/library/t3c3bfhx.aspx)</ept> parameters, but it can call methods that have such parameters.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>For more information about async methods, see <bpt id="p1">[</bpt>Asynchronous Programming with Async and Await<ept id="p1">](https://msdn.microsoft.com/library/mt674882.aspx)</ept>, <bpt id="p2">[</bpt>Control Flow in Async Programs<ept id="p2">](https://msdn.microsoft.com/library/mt674892.aspx)</ept>, and <bpt id="p3">[</bpt>Async Return Types<ept id="p3">](https://msdn.microsoft.com/library/mt674893.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Expression-bodied members</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>There is a syntax shortcut for defining such methods using <ph id="ph1">`=&gt;`</ph>:</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>If the method returns <ph id="ph1">`void`</ph> or is an async method, the body of the method must be a statement expression (same as with lambdas).</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>For properties and indexers, they must be read-only, and you do not use the <ph id="ph1">`get`</ph> accessor keyword.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Iterators</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>An iterator performs a custom iteration over a collection, such as a list or an array.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>An iterator uses the <bpt id="p1">[</bpt>yield return<ept id="p1">](https://msdn.microsoft.com/library/9k7k7cf0.aspx)</ept> statement to return each element one at a time.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>When a <ph id="ph1">`yield return`</ph> statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The return type of an iterator can be <ph id="ph1">@System.Collections.IEnumerable</ph>, <ph id="ph2">@System.Collections.Generic.IEnumerable</ph>%601, <ph id="ph3">@System.Collections.IEnumerator</ph>, or <ph id="ph4">@System.Collections.Generic.IEnumerator</ph>%601.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Iterators<ept id="p1">](https://msdn.microsoft.com/library/mt639331.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Access Modifiers<ept id="p1">](https://msdn.microsoft.com/library/wxh6fsc7.aspx)</ept><ph id="ph1">
</ph><bpt id="p2">[</bpt>Static Classes and Static Class Members<ept id="p2">](https://msdn.microsoft.com/library/79b3xss3.aspx)</ept><ph id="ph2">
</ph><bpt id="p3">[</bpt>Inheritance<ept id="p3">](https://msdn.microsoft.com/library/ms173149.aspx)</ept><ph id="ph3">
</ph><bpt id="p4">[</bpt>Abstract and Sealed Classes and Class Members<ept id="p4">](https://msdn.microsoft.com/library/ms173150.aspx)</ept><ph id="ph4">
</ph><bpt id="p5">[</bpt>params<ept id="p5">](https://msdn.microsoft.com/library/w5zay9db.aspx)</ept><ph id="ph5">
</ph><bpt id="p6">[</bpt>out<ept id="p6">](https://msdn.microsoft.com/library/t3c3bfhx.aspx)</ept><ph id="ph6">
</ph><bpt id="p7">[</bpt>ref<ept id="p7">](https://msdn.microsoft.com/library/14akc2c7.aspx)</ept><ph id="ph7">
</ph><bpt id="p8">[</bpt>Passing Parameters<ept id="p8">](https://msdn.microsoft.com/library/0f66670z.aspx)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>