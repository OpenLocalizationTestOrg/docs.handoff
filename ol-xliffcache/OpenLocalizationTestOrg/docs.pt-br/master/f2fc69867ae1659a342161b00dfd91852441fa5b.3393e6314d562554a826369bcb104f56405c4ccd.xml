{"content":"---\ntitle: \"Optimistic Concurrency\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: e380edac-da67-4276-80a5-b64decae4947\n---\n# Optimistic Concurrency\nIn a multiuser environment, there are two models for updating data in a database: optimistic concurrency and pessimistic concurrency. The <xref:System.Data.DataSet> object is designed to encourage the use of optimistic concurrency for long-running activities, such as remoting data and interacting with data.  \n  \n Pessimistic concurrency involves locking rows at the data source to prevent other users from modifying data in a way that affects the current user. In a pessimistic model, when a user performs an action that causes a lock to be applied, other users cannot perform actions that would conflict with the lock until the lock owner releases it. This model is primarily used in environments where there is heavy contention for data, so that the cost of protecting data with locks is less than the cost of rolling back transactions if concurrency conflicts occur.  \n  \n Therefore, in a pessimistic concurrency model, a user who updates a row establishes a lock. Until the user has finished the update and released the lock, no one else can change that row. For this reason, pessimistic concurrency is best implemented when lock times will be short, as in programmatic processing of records. Pessimistic concurrency is not a scalable option when users are interacting with data and causing records to be locked for relatively large periods of time.  \n  \n> [!NOTE]\n>  If you need to update multiple rows in the same operation, then creating a transaction is a more scalable option than using pessimistic locking.  \n  \n By contrast, users who use optimistic concurrency do not lock a row when reading it. When a user wants to update a row, the application must determine whether another user has changed the row since it was read. Optimistic concurrency is generally used in environments with a low contention for data. Optimistic concurrency improves performance because no locking of records is required, and locking of records requires additional server resources. Also, in order to maintain record locks, a persistent connection to the database server is required. Because this is not the case in an optimistic concurrency model, connections to the server are free to serve a larger number of clients in less time.  \n  \n In an optimistic concurrency model, a violation is considered to have occurred if, after a user receives a value from the database, another user modifies the value before the first user has attempted to modify it. How the server resolves a concurrency violation is best shown by first describing the following example.  \n  \n The following tables follow an example of optimistic concurrency.  \n  \n At 1:00 p.m., User1 reads a row from the database with the following values:  \n  \n **CustID     LastName     FirstName**  \n  \n 101          Smith             Bob  \n  \n|Column name|Original value|Current value|Value in database|  \n|-----------------|--------------------|-------------------|-----------------------|  \n|CustID|101|101|101|  \n|LastName|Smith|Smith|Smith|  \n|FirstName|Bob|Bob|Bob|  \n  \n At 1:01 p.m., User2 reads the same row.  \n  \n At 1:03 p.m., User2 changes **FirstName** from \"Bob\" to \"Robert\" and updates the database.  \n  \n|Column name|Original value|Current value|Value in database|  \n|-----------------|--------------------|-------------------|-----------------------|  \n|CustID|101|101|101|  \n|LastName|Smith|Smith|Smith|  \n|FirstName|Bob|Robert|Bob|  \n  \n The update succeeds because the values in the database at the time of update match the original values that User2 has.  \n  \n At 1:05 p.m., User1 changes \"Bob\"'s first name to \"James\" and tries to update the row.  \n  \n|Column name|Original value|Current value|Value in database|  \n|-----------------|--------------------|-------------------|-----------------------|  \n|CustID|101|101|101|  \n|LastName|Smith|Smith|Smith|  \n|FirstName|Bob|James|Robert|  \n  \n At this point, User1 encounters an optimistic concurrency violation because the value in the database (\"Robert\") no longer matches the original value that User1 was expecting (\"Bob\"). The concurrency violation simply lets you know that the update failed. The decision now needs to be made whether to overwrite the changes supplied by User2 with the changes supplied by User1, or to cancel the changes by User1.  \n  \n## Testing for Optimistic Concurrency Violations  \n There are several techniques for testing for an optimistic concurrency violation. One involves including a timestamp column in the table. Databases commonly provide timestamp functionality that can be used to identify the date and time when the record was last updated. Using this technique, a timestamp column is included in the table definition. Whenever the record is updated, the timestamp is updated to reflect the current date and time. In a test for optimistic concurrency violations, the timestamp column is returned with any query of the contents of the table. When an update is attempted, the timestamp value in the database is compared to the original timestamp value contained in the modified row. If they match, the update is performed and the timestamp column is updated with the current time to reflect the update. If they do not match, an optimistic concurrency violation has occurred.  \n  \n Another technique for testing for an optimistic concurrency violation is to verify that all the original column values in a row still match those found in the database. For example, consider the following query:  \n  \n```  \nSELECT Col1, Col2, Col3 FROM Table1  \n```  \n  \n To test for an optimistic concurrency violation when updating a row in **Table1**, you would issue the following UPDATE statement:  \n  \n```  \nUPDATE Table1 Set Col1 = @NewCol1Value,  \n              Set Col2 = @NewCol2Value,  \n              Set Col3 = @NewCol3Value  \nWHERE Col1 = @OldCol1Value AND  \n      Col2 = @OldCol2Value AND  \n      Col3 = @OldCol3Value  \n```  \n  \n As long as the original values match the values in the database, the update is performed. If a value has been modified, the update will not modify the row because the WHERE clause will not find a match.  \n  \n Note that it is recommended to always return a unique primary key value in your query. Otherwise, the preceding UPDATE statement may update more than one row, which might not be your intent.  \n  \n If a column at your data source allows nulls, you may need to extend your WHERE clause to check for a matching null reference in your local table and at the data source. For example, the following UPDATE statement verifies that a null reference in the local row still matches a null reference at the data source, or that the value in the local row still matches the value at the data source.  \n  \n```  \nUPDATE Table1 Set Col1 = @NewVal1  \n  WHERE (@OldVal1 IS NULL AND Col1 IS NULL) OR Col1 = @OldVal1  \n```  \n  \n You may also choose to apply less restrictive criteria when using an optimistic concurrency model. For example, using only the primary key columns in the WHERE clause causes the data to be overwritten regardless of whether the other columns have been updated since the last query. You can also apply a WHERE clause only to specific columns, resulting in data being overwritten unless particular fields have been updated since they were last queried.  \n  \n### The DataAdapter.RowUpdated Event  \n The **RowUpdated** event of the <xref:System.Data.Common.DataAdapter> object can be used in conjunction with the techniques described earlier, to provide notification to your application of optimistic concurrency violations. **RowUpdated** occurs after each attempt to update a **Modified** row from a **DataSet**. This enables you to add special handling code, including processing when an exception occurs, adding custom error information, adding retry logic, and so on. The <xref:System.Data.Common.RowUpdatedEventArgs> object returns a **RecordsAffected** property containing the number of rows affected by a particular update command for a modified row in a table. By setting the update command to test for optimistic concurrency, the **RecordsAffected** property will, as a result, return a value of 0 when an optimistic concurrency violation has occurred, because no records were updated. If this is the case, an exception is thrown. The **RowUpdated** event enables you to handle this occurrence and avoid the exception by setting an appropriate **RowUpdatedEventArgs.Status** value, such as **UpdateStatus.SkipCurrentRow**. For more information about the **RowUpdated** event, see [Handling DataAdapter Events](../../../../docs/framework/data/adonet/handling-dataadapter-events.md).  \n  \n Optionally, you can set **DataAdapter.ContinueUpdateOnError** to **true**, before calling **Update**, and respond to the error information stored in the **RowError** property of a particular row when the **Update** is completed. For more information, see [Row Error Information](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-error-information.md).  \n  \n## Optimistic Concurrency Example  \n The following is a simple example that sets the **UpdateCommand** of a **DataAdapter** to test for optimistic concurrency, and then uses the **RowUpdated** event to test for optimistic concurrency violations. When an optimistic concurrency violation is encountered, the application sets the **RowError** of the row that the update was issued for to reflect an optimistic concurrency violation.  \n  \n Note that the parameter values passed to the WHERE clause of the UPDATE command are mapped to the **Original** values of their respective columns.  \n  \n```vb  \n' Assumes connection is a valid SqlConnection.  \nDim adapter As SqlDataAdapter = New SqlDataAdapter( _  \n  \"SELECT CustomerID, CompanyName FROM Customers ORDER BY CustomerID\", _  \n  connection)  \n  \n' The Update command checks for optimistic concurrency violations  \n' in the WHERE clause.  \nadapter.UpdateCommand = New SqlCommand(\"UPDATE Customers \" &  \n  \"(CustomerID, CompanyName) VALUES(@CustomerID, @CompanyName) \" & _  \n  \"WHERE CustomerID = @oldCustomerID AND CompanyName = \" &  \n  \"@oldCompanyName\", connection)  \nadapter.UpdateCommand.Parameters.Add( _  \n  \"@CustomerID\", SqlDbType.NChar, 5, \"CustomerID\")  \nadapter.UpdateCommand.Parameters.Add( _  \n  \"@CompanyName\", SqlDbType.NVarChar, 30, \"CompanyName\")  \n  \n' Pass the original values to the WHERE clause parameters.  \nDim parameter As SqlParameter = adapter.UpdateCommand.Parameters.Add( _  \n  \"@oldCustomerID\", SqlDbType.NChar, 5, \"CustomerID\")  \nparameter.SourceVersion = DataRowVersion.Original  \nparameter = adapter.UpdateCommand.Parameters.Add( _  \n  \"@oldCompanyName\", SqlDbType.NVarChar, 30, \"CompanyName\")  \nparameter.SourceVersion = DataRowVersion.Original  \n  \n' Add the RowUpdated event handler.  \nAddHandler adapter.RowUpdated, New SqlRowUpdatedEventHandler( _  \n  AddressOf OnRowUpdated)  \n  \nDim dataSet As DataSet = New DataSet()  \nadapter.Fill(dataSet, \"Customers\")  \n  \n' Modify the DataSet contents.  \nadapter.Update(dataSet, \"Customers\")  \n  \nDim dataRow As DataRow  \n  \nFor Each dataRow In dataSet.Tables(\"Customers\").Rows  \n    If dataRow.HasErrors Then   \n       Console.WriteLine(dataRow (0) & vbCrLf & dataRow.RowError)  \n    End If  \nNext  \n  \nPrivate Shared Sub OnRowUpdated( _  \n  sender As object, args As SqlRowUpdatedEventArgs)  \n   If args.RecordsAffected = 0  \n      args.Row.RowError = \"Optimistic Concurrency Violation!\"  \n      args.Status = UpdateStatus.SkipCurrentRow  \n   End If  \nEnd Sub  \n```  \n  \n```csharp  \n// Assumes connection is a valid SqlConnection.  \nSqlDataAdapter adapter = new SqlDataAdapter(  \n  \"SELECT CustomerID, CompanyName FROM Customers ORDER BY CustomerID\",  \n  connection);  \n  \n// The Update command checks for optimistic concurrency violations  \n// in the WHERE clause.  \nadapter.UpdateCommand = new SqlCommand(\"UPDATE Customers Set CustomerID = @CustomerID, CompanyName = @CompanyName \" +  \n   \"WHERE CustomerID = @oldCustomerID AND CompanyName = @oldCompanyName\", connection);  \nadapter.UpdateCommand.Parameters.Add(  \n  \"@CustomerID\", SqlDbType.NChar, 5, \"CustomerID\");  \nadapter.UpdateCommand.Parameters.Add(  \n  \"@CompanyName\", SqlDbType.NVarChar, 30, \"CompanyName\");  \n  \n// Pass the original values to the WHERE clause parameters.  \nSqlParameter parameter = adapter.UpdateCommand.Parameters.Add(  \n  \"@oldCustomerID\", SqlDbType.NChar, 5, \"CustomerID\");  \nparameter.SourceVersion = DataRowVersion.Original;  \nparameter = adapter.UpdateCommand.Parameters.Add(  \n  \"@oldCompanyName\", SqlDbType.NVarChar, 30, \"CompanyName\");  \nparameter.SourceVersion = DataRowVersion.Original;  \n  \n// Add the RowUpdated event handler.  \nadapter.RowUpdated += new SqlRowUpdatedEventHandler(OnRowUpdated);  \n  \nDataSet dataSet = new DataSet();  \nadapter.Fill(dataSet, \"Customers\");  \n  \n// Modify the DataSet contents.  \n  \nadapter.Update(dataSet, \"Customers\");  \n  \nforeach (DataRow dataRow in dataSet.Tables[\"Customers\"].Rows)  \n{  \n    if (dataRow.HasErrors)  \n       Console.WriteLine(dataRow [0] + \"\\n\" + dataRow.RowError);  \n}  \n  \nprotected static void OnRowUpdated(object sender, SqlRowUpdatedEventArgs args)  \n{  \n  if (args.RecordsAffected == 0)   \n  {  \n    args.Row.RowError = \"Optimistic Concurrency Violation Encountered\";  \n    args.Status = UpdateStatus.SkipCurrentRow;  \n  }  \n}  \n```  \n  \n## See also\n\n- [Retrieving and Modifying Data in ADO.NET](../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)\n- [Updating Data Sources with DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)\n- [Row Error Information](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-error-information.md)\n- [Transactions and Concurrency](../../../../docs/framework/data/adonet/transactions-and-concurrency.md)\n- [ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)\n","nodes":[{"pos":[4,140],"embed":true,"restype":"x-metadata","content":"title: \"Optimistic Concurrency\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: e380edac-da67-4276-80a5-b64decae4947","nodes":[{"content":"Optimistic Concurrency","nodes":[{"pos":[0,22],"content":"Optimistic Concurrency","nodes":[{"content":"Optimistic Concurrency","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[147,169],"content":"Optimistic Concurrency","linkify":"Optimistic Concurrency","nodes":[{"content":"Optimistic Concurrency","pos":[0,22]}]},{"content":"In a multiuser environment, there are two models for updating data in a database: optimistic concurrency and pessimistic concurrency.","pos":[170,303]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Data.DataSet&gt;</ph> object is designed to encourage the use of optimistic concurrency for long-running activities, such as remoting data and interacting with data.","pos":[304,478],"source":" The <xref:System.Data.DataSet> object is designed to encourage the use of optimistic concurrency for long-running activities, such as remoting data and interacting with data."},{"content":"Pessimistic concurrency involves locking rows at the data source to prevent other users from modifying data in a way that affects the current user.","pos":[485,632]},{"content":"In a pessimistic model, when a user performs an action that causes a lock to be applied, other users cannot perform actions that would conflict with the lock until the lock owner releases it.","pos":[633,824]},{"content":"This model is primarily used in environments where there is heavy contention for data, so that the cost of protecting data with locks is less than the cost of rolling back transactions if concurrency conflicts occur.","pos":[825,1041]},{"content":"Therefore, in a pessimistic concurrency model, a user who updates a row establishes a lock.","pos":[1048,1139]},{"content":"Until the user has finished the update and released the lock, no one else can change that row.","pos":[1140,1234]},{"content":"For this reason, pessimistic concurrency is best implemented when lock times will be short, as in programmatic processing of records.","pos":[1235,1368]},{"content":"Pessimistic concurrency is not a scalable option when users are interacting with data and causing records to be locked for relatively large periods of time.","pos":[1369,1525]},{"pos":[1533,1688],"content":"[!NOTE]\n If you need to update multiple rows in the same operation, then creating a transaction is a more scalable option than using pessimistic locking.","leadings":["","> "],"nodes":[{"content":"If you need to update multiple rows in the same operation, then creating a transaction is a more scalable option than using pessimistic locking.","pos":[9,153]}]},{"content":"By contrast, users who use optimistic concurrency do not lock a row when reading it.","pos":[1695,1779]},{"content":"When a user wants to update a row, the application must determine whether another user has changed the row since it was read.","pos":[1780,1905]},{"content":"Optimistic concurrency is generally used in environments with a low contention for data.","pos":[1906,1994]},{"content":"Optimistic concurrency improves performance because no locking of records is required, and locking of records requires additional server resources.","pos":[1995,2142]},{"content":"Also, in order to maintain record locks, a persistent connection to the database server is required.","pos":[2143,2243]},{"content":"Because this is not the case in an optimistic concurrency model, connections to the server are free to serve a larger number of clients in less time.","pos":[2244,2393]},{"content":"In an optimistic concurrency model, a violation is considered to have occurred if, after a user receives a value from the database, another user modifies the value before the first user has attempted to modify it.","pos":[2400,2613]},{"content":"How the server resolves a concurrency violation is best shown by first describing the following example.","pos":[2614,2718]},{"content":"The following tables follow an example of optimistic concurrency.","pos":[2725,2790]},{"content":"At 1:00 p.m., User1 reads a row from the database with the following values:","pos":[2797,2873]},{"pos":[2880,2917],"content":"<bpt id=\"p1\">**</bpt>CustID     LastName     FirstName<ept id=\"p1\">**</ept>","source":"**CustID     LastName     FirstName**"},{"content":"101          Smith             Bob","pos":[2924,2958]},{"content":"Column name","pos":[2965,2976]},{"content":"Original value","pos":[2977,2991]},{"content":"Current value","pos":[2992,3005]},{"content":"Value in database","pos":[3006,3023]},{"content":"CustID","pos":[3115,3121]},{"content":"101","pos":[3122,3125]},{"content":"101","pos":[3126,3129]},{"content":"101","pos":[3130,3133]},{"content":"LastName","pos":[3138,3146]},{"content":"Smith","pos":[3147,3152]},{"content":"Smith","pos":[3153,3158]},{"content":"Smith","pos":[3159,3164]},{"content":"FirstName","pos":[3169,3178]},{"content":"Bob","pos":[3179,3182]},{"content":"Bob","pos":[3183,3186]},{"content":"Bob","pos":[3187,3190]},{"content":"At 1:01 p.m., User2 reads the same row.","pos":[3198,3237]},{"pos":[3244,3334],"content":"At 1:03 p.m., User2 changes <bpt id=\"p1\">**</bpt>FirstName<ept id=\"p1\">**</ept> from \"Bob\" to \"Robert\" and updates the database.","source":"At 1:03 p.m., User2 changes **FirstName** from \"Bob\" to \"Robert\" and updates the database."},{"content":"Column name","pos":[3341,3352]},{"content":"Original value","pos":[3353,3367]},{"content":"Current value","pos":[3368,3381]},{"content":"Value in database","pos":[3382,3399]},{"content":"CustID","pos":[3491,3497]},{"content":"101","pos":[3498,3501]},{"content":"101","pos":[3502,3505]},{"content":"101","pos":[3506,3509]},{"content":"LastName","pos":[3514,3522]},{"content":"Smith","pos":[3523,3528]},{"content":"Smith","pos":[3529,3534]},{"content":"Smith","pos":[3535,3540]},{"content":"FirstName","pos":[3545,3554]},{"content":"Bob","pos":[3555,3558]},{"content":"Robert","pos":[3559,3565]},{"content":"Bob","pos":[3566,3569]},{"content":"The update succeeds because the values in the database at the time of update match the original values that User2 has.","pos":[3577,3695]},{"content":"At 1:05 p.m., User1 changes \"Bob\"'s first name to \"James\" and tries to update the row.","pos":[3702,3788]},{"content":"Column name","pos":[3795,3806]},{"content":"Original value","pos":[3807,3821]},{"content":"Current value","pos":[3822,3835]},{"content":"Value in database","pos":[3836,3853]},{"content":"CustID","pos":[3945,3951]},{"content":"101","pos":[3952,3955]},{"content":"101","pos":[3956,3959]},{"content":"101","pos":[3960,3963]},{"content":"LastName","pos":[3968,3976]},{"content":"Smith","pos":[3977,3982]},{"content":"Smith","pos":[3983,3988]},{"content":"Smith","pos":[3989,3994]},{"content":"FirstName","pos":[3999,4008]},{"content":"Bob","pos":[4009,4012]},{"content":"James","pos":[4013,4018]},{"content":"Robert","pos":[4019,4025]},{"content":"At this point, User1 encounters an optimistic concurrency violation because the value in the database (\"Robert\") no longer matches the original value that User1 was expecting (\"Bob\").","pos":[4033,4216]},{"content":"The concurrency violation simply lets you know that the update failed.","pos":[4217,4287]},{"content":"The decision now needs to be made whether to overwrite the changes supplied by User2 with the changes supplied by User1, or to cancel the changes by User1.","pos":[4288,4443]},{"pos":[4452,4497],"content":"Testing for Optimistic Concurrency Violations","linkify":"Testing for Optimistic Concurrency Violations","nodes":[{"content":"Testing for Optimistic Concurrency Violations","pos":[0,45]}]},{"content":"There are several techniques for testing for an optimistic concurrency violation.","pos":[4501,4582]},{"content":"One involves including a timestamp column in the table.","pos":[4583,4638]},{"content":"Databases commonly provide timestamp functionality that can be used to identify the date and time when the record was last updated.","pos":[4639,4770]},{"content":"Using this technique, a timestamp column is included in the table definition.","pos":[4771,4848]},{"content":"Whenever the record is updated, the timestamp is updated to reflect the current date and time.","pos":[4849,4943]},{"content":"In a test for optimistic concurrency violations, the timestamp column is returned with any query of the contents of the table.","pos":[4944,5070]},{"content":"When an update is attempted, the timestamp value in the database is compared to the original timestamp value contained in the modified row.","pos":[5071,5210]},{"content":"If they match, the update is performed and the timestamp column is updated with the current time to reflect the update.","pos":[5211,5330]},{"content":"If they do not match, an optimistic concurrency violation has occurred.","pos":[5331,5402]},{"content":"Another technique for testing for an optimistic concurrency violation is to verify that all the original column values in a row still match those found in the database.","pos":[5409,5577]},{"content":"For example, consider the following query:","pos":[5578,5620]},{"pos":[5680,5810],"content":"To test for an optimistic concurrency violation when updating a row in <bpt id=\"p1\">**</bpt>Table1<ept id=\"p1\">**</ept>, you would issue the following UPDATE statement:","source":"To test for an optimistic concurrency violation when updating a row in **Table1**, you would issue the following UPDATE statement:"},{"content":"As long as the original values match the values in the database, the update is performed.","pos":[6052,6141]},{"content":"If a value has been modified, the update will not modify the row because the WHERE clause will not find a match.","pos":[6142,6254]},{"content":"Note that it is recommended to always return a unique primary key value in your query.","pos":[6261,6347]},{"content":"Otherwise, the preceding UPDATE statement may update more than one row, which might not be your intent.","pos":[6348,6451]},{"content":"If a column at your data source allows nulls, you may need to extend your WHERE clause to check for a matching null reference in your local table and at the data source.","pos":[6458,6627]},{"content":"For example, the following UPDATE statement verifies that a null reference in the local row still matches a null reference at the data source, or that the value in the local row still matches the value at the data source.","pos":[6628,6849]},{"content":"You may also choose to apply less restrictive criteria when using an optimistic concurrency model.","pos":[6972,7070]},{"content":"For example, using only the primary key columns in the WHERE clause causes the data to be overwritten regardless of whether the other columns have been updated since the last query.","pos":[7071,7252]},{"content":"You can also apply a WHERE clause only to specific columns, resulting in data being overwritten unless particular fields have been updated since they were last queried.","pos":[7253,7421]},{"pos":[7431,7463],"content":"The DataAdapter.RowUpdated Event","linkify":"The DataAdapter.RowUpdated Event","nodes":[{"content":"The DataAdapter.RowUpdated Event","pos":[0,32]}]},{"content":"The <bpt id=\"p1\">**</bpt>RowUpdated<ept id=\"p1\">**</ept> event of the <ph id=\"ph1\">&lt;xref:System.Data.Common.DataAdapter&gt;</ph> object can be used in conjunction with the techniques described earlier, to provide notification to your application of optimistic concurrency violations.","pos":[7467,7691],"source":"The **RowUpdated** event of the <xref:System.Data.Common.DataAdapter> object can be used in conjunction with the techniques described earlier, to provide notification to your application of optimistic concurrency violations."},{"content":"<bpt id=\"p1\">**</bpt>RowUpdated<ept id=\"p1\">**</ept> occurs after each attempt to update a <bpt id=\"p2\">**</bpt>Modified<ept id=\"p2\">**</ept> row from a <bpt id=\"p3\">**</bpt>DataSet<ept id=\"p3\">**</ept>.","pos":[7692,7781],"source":"**RowUpdated** occurs after each attempt to update a **Modified** row from a **DataSet**."},{"content":"This enables you to add special handling code, including processing when an exception occurs, adding custom error information, adding retry logic, and so on.","pos":[7782,7939]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Data.Common.RowUpdatedEventArgs&gt;</ph> object returns a <bpt id=\"p1\">**</bpt>RecordsAffected<ept id=\"p1\">**</ept> property containing the number of rows affected by a particular update command for a modified row in a table.","pos":[7940,8136],"source":" The <xref:System.Data.Common.RowUpdatedEventArgs> object returns a **RecordsAffected** property containing the number of rows affected by a particular update command for a modified row in a table."},{"content":"By setting the update command to test for optimistic concurrency, the <bpt id=\"p1\">**</bpt>RecordsAffected<ept id=\"p1\">**</ept> property will, as a result, return a value of 0 when an optimistic concurrency violation has occurred, because no records were updated.","pos":[8137,8362],"source":" By setting the update command to test for optimistic concurrency, the **RecordsAffected** property will, as a result, return a value of 0 when an optimistic concurrency violation has occurred, because no records were updated."},{"content":"If this is the case, an exception is thrown.","pos":[8363,8407]},{"content":"The <bpt id=\"p1\">**</bpt>RowUpdated<ept id=\"p1\">**</ept> event enables you to handle this occurrence and avoid the exception by setting an appropriate <bpt id=\"p2\">**</bpt>RowUpdatedEventArgs.Status<ept id=\"p2\">**</ept> value, such as <bpt id=\"p3\">**</bpt>UpdateStatus.SkipCurrentRow<ept id=\"p3\">**</ept>.","pos":[8408,8599],"source":" The **RowUpdated** event enables you to handle this occurrence and avoid the exception by setting an appropriate **RowUpdatedEventArgs.Status** value, such as **UpdateStatus.SkipCurrentRow**."},{"content":"For more information about the <bpt id=\"p1\">**</bpt>RowUpdated<ept id=\"p1\">**</ept> event, see <bpt id=\"p2\">[</bpt>Handling DataAdapter Events<ept id=\"p2\">](../../../../docs/framework/data/adonet/handling-dataadapter-events.md)</ept>.","pos":[8600,8758],"source":" For more information about the **RowUpdated** event, see [Handling DataAdapter Events](../../../../docs/framework/data/adonet/handling-dataadapter-events.md)."},{"content":"Optionally, you can set <bpt id=\"p1\">**</bpt>DataAdapter.ContinueUpdateOnError<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>, before calling <bpt id=\"p3\">**</bpt>Update<ept id=\"p3\">**</ept>, and respond to the error information stored in the <bpt id=\"p4\">**</bpt>RowError<ept id=\"p4\">**</ept> property of a particular row when the <bpt id=\"p5\">**</bpt>Update<ept id=\"p5\">**</ept> is completed.","pos":[8765,8993],"source":"Optionally, you can set **DataAdapter.ContinueUpdateOnError** to **true**, before calling **Update**, and respond to the error information stored in the **RowError** property of a particular row when the **Update** is completed."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Row Error Information<ept id=\"p1\">](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-error-information.md)</ept>.","pos":[8994,9136],"source":" For more information, see [Row Error Information](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-error-information.md)."},{"pos":[9145,9175],"content":"Optimistic Concurrency Example","linkify":"Optimistic Concurrency Example","nodes":[{"content":"Optimistic Concurrency Example","pos":[0,30]}]},{"content":"The following is a simple example that sets the <bpt id=\"p1\">**</bpt>UpdateCommand<ept id=\"p1\">**</ept> of a <bpt id=\"p2\">**</bpt>DataAdapter<ept id=\"p2\">**</ept> to test for optimistic concurrency, and then uses the <bpt id=\"p3\">**</bpt>RowUpdated<ept id=\"p3\">**</ept> event to test for optimistic concurrency violations.","pos":[9179,9387],"source":"The following is a simple example that sets the **UpdateCommand** of a **DataAdapter** to test for optimistic concurrency, and then uses the **RowUpdated** event to test for optimistic concurrency violations."},{"content":"When an optimistic concurrency violation is encountered, the application sets the <bpt id=\"p1\">**</bpt>RowError<ept id=\"p1\">**</ept> of the row that the update was issued for to reflect an optimistic concurrency violation.","pos":[9388,9572],"source":" When an optimistic concurrency violation is encountered, the application sets the **RowError** of the row that the update was issued for to reflect an optimistic concurrency violation."},{"pos":[9579,9725],"content":"Note that the parameter values passed to the WHERE clause of the UPDATE command are mapped to the <bpt id=\"p1\">**</bpt>Original<ept id=\"p1\">**</ept> values of their respective columns.","source":"Note that the parameter values passed to the WHERE clause of the UPDATE command are mapped to the **Original** values of their respective columns."},{"pos":[13462,13470],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13474,13589],"content":"<bpt id=\"p1\">[</bpt>Retrieving and Modifying Data in ADO.NET<ept id=\"p1\">](../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)</ept>","source":"[Retrieving and Modifying Data in ADO.NET](../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)"},{"pos":[13592,13716],"content":"<bpt id=\"p1\">[</bpt>Updating Data Sources with DataAdapters<ept id=\"p1\">](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)</ept>","source":"[Updating Data Sources with DataAdapters](../../../../docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)"},{"pos":[13719,13834],"content":"<bpt id=\"p1\">[</bpt>Row Error Information<ept id=\"p1\">](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-error-information.md)</ept>","source":"[Row Error Information](../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-error-information.md)"},{"pos":[13837,13939],"content":"<bpt id=\"p1\">[</bpt>Transactions and Concurrency<ept id=\"p1\">](../../../../docs/framework/data/adonet/transactions-and-concurrency.md)</ept>","source":"[Transactions and Concurrency](../../../../docs/framework/data/adonet/transactions-and-concurrency.md)"},{"pos":[13942,14046],"content":"<bpt id=\"p1\">[</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=217917)</ept>","source":"[ADO.NET Managed Providers and DataSet Developer Center](https://go.microsoft.com/fwlink/?LinkId=217917)"}]}