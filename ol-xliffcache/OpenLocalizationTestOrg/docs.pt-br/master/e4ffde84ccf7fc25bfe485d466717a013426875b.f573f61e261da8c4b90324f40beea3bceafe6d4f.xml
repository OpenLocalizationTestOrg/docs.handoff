{"content":"---\ntitle: \"How to: Add Custom Methods for LINQ Queries (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nms.assetid: 099b2e2a-83cd-45c6-aa4d-01b398b5faaf\ncaps.latest.revision: 3\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# How to: Add Custom Methods for LINQ Queries (Visual Basic)\nYou can extend the set of methods that you can use for LINQ queries by adding extension methods to the <xref:System.Collections.Generic.IEnumerable%601> interface. For example, in addition to the standard average or maximum operations, you can create a custom aggregate method to compute a single value from a sequence of values. You can also create a method that works as a custom filter or a specific data transform for a sequence of values and returns a new sequence. Examples of such methods are <xref:System.Linq.Enumerable.Distinct%2A>, <xref:System.Linq.Enumerable.Skip%2A>, and <xref:System.Linq.Enumerable.Reverse%2A>.  \n  \n When you extend the <xref:System.Collections.Generic.IEnumerable%601> interface, you can apply your custom methods to any enumerable collection. For more information, see [Extension Methods](../../../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).  \n  \n## Adding an Aggregate Method  \n An aggregate method computes a single value from a set of values. LINQ provides several aggregate methods, including <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Min%2A>, and <xref:System.Linq.Enumerable.Max%2A>. You can create your own aggregate method by adding an extension method to the <xref:System.Collections.Generic.IEnumerable%601> interface.  \n  \n The following code example shows how to create an extension method called `Median` to compute a median for a sequence of numbers of type `double`.  \n  \n```vb  \nImports System.Runtime.CompilerServices  \n  \nModule LINQExtension  \n  \n    ' Extension method for the IEnumerable(of T) interface.   \n    ' The method accepts only values of the Double type.  \n    <Extension()>   \n    Function Median(ByVal source As IEnumerable(Of Double)) As Double  \n        If source.Count = 0 Then  \n            Throw New InvalidOperationException(\"Cannot compute median for an empty set.\")  \n        End If  \n  \n        Dim sortedSource = From number In source   \n                           Order By number  \n  \n        Dim itemIndex = sortedSource.Count \\ 2  \n  \n        If sortedSource.Count Mod 2 = 0 Then  \n            ' Even number of items in list.  \n            Return (sortedSource(itemIndex) + sortedSource(itemIndex - 1)) / 2  \n        Else  \n            ' Odd number of items in list.  \n            Return sortedSource(itemIndex)  \n        End If  \n    End Function  \nEnd Module  \n```  \n  \n You call this extension method for any enumerable collection in the same way you call other aggregate methods from the <xref:System.Collections.Generic.IEnumerable%601> interface.  \n  \n> [!NOTE]\n>  In Visual Basic, you can either use a method call or standard query syntax for the `Aggregate` or `Group By` clause. For more information, see [Aggregate Clause](../../../../visual-basic/language-reference/queries/aggregate-clause.md) and [Group By Clause](../../../../visual-basic/language-reference/queries/group-by-clause.md).  \n  \n The following code example shows how to use the `Median` method for an array of type `double`.  \n  \n```vb  \nDim numbers1() As Double = {1.9, 2, 8, 4, 5.7, 6, 7.2, 0}  \n  \nDim query1 = Aggregate num In numbers1 Into Median()  \n  \nConsole.WriteLine(\"Double: Median = \" & query1)  \n```  \n  \n```vb  \n' This code produces the following output:  \n'  \n' Double: Median = 4.85  \n```  \n  \n\n### Overloading an Aggregate Method to Accept Various Types  \n You can overload your aggregate method so that it accepts sequences of various types. The standard approach is to create an overload for each type. Another approach is to create an overload that will take a generic type and convert it to a specific type by using a delegate. You can also combine both approaches.  \n  \n#### To create an overload for each type  \n You can create a specific overload for each type that you want to support. The following code example shows an overload of the `Median` method for the `integer` type.  \n  \n```vb  \n' Integer overload  \n  \n<Extension()>   \nFunction Median(ByVal source As IEnumerable(Of Integer)) As Double  \n    Return Aggregate num In source Select CDbl(num) Into med = Median()  \nEnd Function  \n```  \n You can now call the `Median` overloads for both `integer` and `double` types, as shown in the following code:  \n  \n```vb  \nDim numbers1() As Double = {1.9, 2, 8, 4, 5.7, 6, 7.2, 0}  \n  \nDim query1 = Aggregate num In numbers1 Into Median()  \n  \nConsole.WriteLine(\"Double: Median = \" & query1)  \n```  \n  \n```vb  \nDim numbers2() As Integer = {1, 2, 3, 4, 5}  \n  \nDim query2 = Aggregate num In numbers2 Into Median()  \n  \nConsole.WriteLine(\"Integer: Median = \" & query2)  \n```  \n  \n```vb  \n' This code produces the following output:  \n'  \n' Double: Median = 4.85  \n' Integer: Median = 3  \n```  \n  \n \n#### To create a generic overload  \n You can also create an overload that accepts a sequence of generic objects. This overload takes a delegate as a parameter and uses it to convert a sequence of objects of a generic type to a specific type.  \n  \n The following code shows an overload of the `Median` method that takes the <xref:System.Func%602> delegate as a parameter. This delegate takes an object of generic type T and returns an object of type `double`.  \n  \n```vb  \n' Generic overload.  \n  \n<Extension()>   \nFunction Median(Of T)(ByVal source As IEnumerable(Of T),   \n                      ByVal selector As Func(Of T, Double)) As Double  \n    Return Aggregate num In source Select selector(num) Into med = Median()  \nEnd Function  \n```  \n  \n You can now call the `Median` method for a sequence of objects of any type. If the type does not have its own method overload, you have to pass a delegate parameter. In Visual Basic, you can use a lambda expression for this purpose. Also, if you use the `Aggregate` or `Group By` clause instead of the method call, you can pass any value or expression that is in the scope this clause.  \n  \n The following example code shows how to call the `Median` method for an array of integers and an array of strings. For strings, the median for the lengths of strings in the array is calculated. The example shows how to pass the <xref:System.Func%602> delegate parameter to the `Median` method for each case.  \n  \n```vb  \nDim numbers3() As Integer = {1, 2, 3, 4, 5}  \n  \n' You can use num as a parameter for the Median method   \n' so that the compiler will implicitly convert its value to double.  \n' If there is no implicit conversion, the compiler will  \n' display an error message.  \n  \nDim query3 = Aggregate num In numbers3 Into Median(num)  \n  \nConsole.WriteLine(\"Integer: Median = \" & query3)  \n  \nDim numbers4() As String = {\"one\", \"two\", \"three\", \"four\", \"five\"}  \n  \n' With the generic overload, you can also use numeric properties of objects.  \n  \nDim query4 = Aggregate str In numbers4 Into Median(str.Length)  \n  \nConsole.WriteLine(\"String: Median = \" & query4)  \n  \n' This code produces the following output:  \n'  \n' Integer: Median = 3  \n' String: Median = 4  \n```  \n## Adding a Method That Returns a Collection  \n You can extend the <xref:System.Collections.Generic.IEnumerable%601> interface with a custom query method that returns a sequence of values. In this case, the method must return a collection of type <xref:System.Collections.Generic.IEnumerable%601>. Such methods can be used to apply filters or data transforms to a sequence of values.  \n  \n The following example shows how to create an extension method named `AlternateElements` that returns every other element in a collection, starting from the first element.  \n  \n```vb  \n' Extension method for the IEnumerable(of T) interface.   \n' The method returns every other element of a sequence.  \n  \n<Extension()>   \nFunction AlternateElements(Of T)(  \n    ByVal source As IEnumerable(Of T)  \n    ) As IEnumerable(Of T)  \n  \n    Dim list As New List(Of T)  \n    Dim i = 0  \n    For Each element In source  \n        If (i Mod 2 = 0) Then  \n            list.Add(element)  \n        End If  \n        i = i + 1  \n    Next  \n    Return list  \nEnd Function  \n```  \n You can call this extension method for any enumerable collection just as you would call other methods from the <xref:System.Collections.Generic.IEnumerable%601> interface, as shown in the following code:  \n  \n```vb  \nDim strings() As String = {\"a\", \"b\", \"c\", \"d\", \"e\"}  \n  \nDim query = strings.AlternateElements()  \n  \nFor Each element In query  \n    Console.WriteLine(element)  \nNext  \n  \n' This code produces the following output:  \n'  \n' a  \n' c  \n' e  \n```  \n  \n## See Also  \n <xref:System.Collections.Generic.IEnumerable%601>   \n [Extension Methods](../../../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)","nodes":[{"pos":[12,87],"content":"How to: Add Custom Methods for LINQ Queries (Visual Basic) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"How to: Add Custom Methods for LINQ Queries (Visual Basic) | Microsoft Docs","pos":[0,75]}]},{"pos":[468,526],"content":"How to: Add Custom Methods for LINQ Queries (Visual Basic)","linkify":"How to: Add Custom Methods for LINQ Queries (Visual Basic)","nodes":[{"content":"How to: Add Custom Methods for LINQ Queries (Visual Basic)","pos":[0,58]}]},{"content":"You can extend the set of methods that you can use for LINQ queries by adding extension methods to the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.","pos":[527,690],"source":"You can extend the set of methods that you can use for LINQ queries by adding extension methods to the <xref:System.Collections.Generic.IEnumerable%601> interface."},{"content":"For example, in addition to the standard average or maximum operations, you can create a custom aggregate method to compute a single value from a sequence of values.","pos":[691,856]},{"content":"You can also create a method that works as a custom filter or a specific data transform for a sequence of values and returns a new sequence.","pos":[857,997]},{"content":"Examples of such methods are <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Distinct%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Skip%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.Reverse%2A&gt;</ph>.","pos":[998,1154],"source":" Examples of such methods are <xref:System.Linq.Enumerable.Distinct%2A>, <xref:System.Linq.Enumerable.Skip%2A>, and <xref:System.Linq.Enumerable.Reverse%2A>."},{"content":"When you extend the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface, you can apply your custom methods to any enumerable collection.","pos":[1161,1305],"source":"When you extend the <xref:System.Collections.Generic.IEnumerable%601> interface, you can apply your custom methods to any enumerable collection."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Extension Methods<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)</ept>.","pos":[1306,1446],"source":" For more information, see [Extension Methods](../../../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)."},{"pos":[1455,1481],"content":"Adding an Aggregate Method","linkify":"Adding an Aggregate Method","nodes":[{"content":"Adding an Aggregate Method","pos":[0,26]}]},{"content":"An aggregate method computes a single value from a set of values.","pos":[1485,1550]},{"content":"LINQ provides several aggregate methods, including <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Average%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Min%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.Max%2A&gt;</ph>.","pos":[1551,1723],"source":" LINQ provides several aggregate methods, including <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Min%2A>, and <xref:System.Linq.Enumerable.Max%2A>."},{"content":"You can create your own aggregate method by adding an extension method to the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.","pos":[1724,1862],"source":" You can create your own aggregate method by adding an extension method to the <xref:System.Collections.Generic.IEnumerable%601> interface."},{"pos":[1869,2015],"content":"The following code example shows how to create an extension method called <ph id=\"ph1\">`Median`</ph> to compute a median for a sequence of numbers of type <ph id=\"ph2\">`double`</ph>.","source":"The following code example shows how to create an extension method called `Median` to compute a median for a sequence of numbers of type `double`."},{"content":"You call this extension method for any enumerable collection in the same way you call other aggregate methods from the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.","pos":[2953,3132],"source":"You call this extension method for any enumerable collection in the same way you call other aggregate methods from the <xref:System.Collections.Generic.IEnumerable%601> interface."},{"pos":[3140,3480],"content":"[!NOTE]\n In Visual Basic, you can either use a method call or standard query syntax for the `Aggregate` or `Group By` clause. For more information, see [Aggregate Clause](../../../../visual-basic/language-reference/queries/aggregate-clause.md) and [Group By Clause](../../../../visual-basic/language-reference/queries/group-by-clause.md).","leadings":["","> "],"nodes":[{"content":" In Visual Basic, you can either use a method call or standard query syntax for the `Aggregate` or `Group By` clause. For more information, see [Aggregate Clause](../../../../visual-basic/language-reference/queries/aggregate-clause.md) and [Group By Clause](../../../../visual-basic/language-reference/queries/group-by-clause.md).","pos":[8,338],"nodes":[{"content":"In Visual Basic, you can either use a method call or standard query syntax for the <ph id=\"ph1\">`Aggregate`</ph> or <ph id=\"ph2\">`Group By`</ph> clause.","pos":[1,117],"source":" In Visual Basic, you can either use a method call or standard query syntax for the `Aggregate` or `Group By` clause."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Aggregate Clause<ept id=\"p1\">](../../../../visual-basic/language-reference/queries/aggregate-clause.md)</ept> and <bpt id=\"p2\">[</bpt>Group By Clause<ept id=\"p2\">](../../../../visual-basic/language-reference/queries/group-by-clause.md)</ept>.","pos":[118,330],"source":" For more information, see [Aggregate Clause](../../../../visual-basic/language-reference/queries/aggregate-clause.md) and [Group By Clause](../../../../visual-basic/language-reference/queries/group-by-clause.md)."}]}]},{"pos":[3487,3581],"content":"The following code example shows how to use the <ph id=\"ph1\">`Median`</ph> method for an array of type <ph id=\"ph2\">`double`</ph>.","source":"The following code example shows how to use the `Median` method for an array of type `double`."},{"pos":[3872,3927],"content":"Overloading an Aggregate Method to Accept Various Types","linkify":"Overloading an Aggregate Method to Accept Various Types","nodes":[{"content":"Overloading an Aggregate Method to Accept Various Types","pos":[0,55]}]},{"content":"You can overload your aggregate method so that it accepts sequences of various types.","pos":[3931,4016]},{"content":"The standard approach is to create an overload for each type.","pos":[4017,4078]},{"content":"Another approach is to create an overload that will take a generic type and convert it to a specific type by using a delegate.","pos":[4079,4205]},{"content":"You can also combine both approaches.","pos":[4206,4243]},{"pos":[4254,4289],"content":"To create an overload for each type","linkify":"To create an overload for each type","nodes":[{"content":"To create an overload for each type","pos":[0,35]}]},{"content":"You can create a specific overload for each type that you want to support.","pos":[4293,4367]},{"content":"The following code example shows an overload of the <ph id=\"ph1\">`Median`</ph> method for the <ph id=\"ph2\">`integer`</ph> type.","pos":[4368,4459],"source":" The following code example shows an overload of the `Median` method for the `integer` type."},{"pos":[4679,4789],"content":"You can now call the <ph id=\"ph1\">`Median`</ph> overloads for both <ph id=\"ph2\">`integer`</ph> and <ph id=\"ph3\">`double`</ph> types, as shown in the following code:","source":"You can now call the `Median` overloads for both `integer` and `double` types, as shown in the following code:"},{"pos":[5281,5309],"content":"To create a generic overload","linkify":"To create a generic overload","nodes":[{"content":"To create a generic overload","pos":[0,28]}]},{"content":"You can also create an overload that accepts a sequence of generic objects.","pos":[5313,5388]},{"content":"This overload takes a delegate as a parameter and uses it to convert a sequence of objects of a generic type to a specific type.","pos":[5389,5517]},{"content":"The following code shows an overload of the <ph id=\"ph1\">`Median`</ph> method that takes the <ph id=\"ph2\">&lt;xref:System.Func%602&gt;</ph> delegate as a parameter.","pos":[5524,5646],"source":"The following code shows an overload of the `Median` method that takes the <xref:System.Func%602> delegate as a parameter."},{"content":"This delegate takes an object of generic type T and returns an object of type <ph id=\"ph1\">`double`</ph>.","pos":[5647,5734],"source":" This delegate takes an object of generic type T and returns an object of type `double`."},{"content":"You can now call the <ph id=\"ph1\">`Median`</ph> method for a sequence of objects of any type.","pos":[6025,6100],"source":"You can now call the `Median` method for a sequence of objects of any type."},{"content":"If the type does not have its own method overload, you have to pass a delegate parameter.","pos":[6101,6190]},{"content":"In Visual Basic, you can use a lambda expression for this purpose.","pos":[6191,6257]},{"content":"Also, if you use the <ph id=\"ph1\">`Aggregate`</ph> or <ph id=\"ph2\">`Group By`</ph> clause instead of the method call, you can pass any value or expression that is in the scope this clause.","pos":[6258,6410],"source":" Also, if you use the `Aggregate` or `Group By` clause instead of the method call, you can pass any value or expression that is in the scope this clause."},{"content":"The following example code shows how to call the <ph id=\"ph1\">`Median`</ph> method for an array of integers and an array of strings.","pos":[6417,6531],"source":"The following example code shows how to call the `Median` method for an array of integers and an array of strings."},{"content":"For strings, the median for the lengths of strings in the array is calculated.","pos":[6532,6610]},{"content":"The example shows how to pass the <ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph> delegate parameter to the <ph id=\"ph2\">`Median`</ph> method for each case.","pos":[6611,6724],"source":" The example shows how to pass the <xref:System.Func%602> delegate parameter to the `Median` method for each case."},{"pos":[7501,7542],"content":"Adding a Method That Returns a Collection","linkify":"Adding a Method That Returns a Collection","nodes":[{"content":"Adding a Method That Returns a Collection","pos":[0,41]}]},{"content":"You can extend the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface with a custom query method that returns a sequence of values.","pos":[7546,7686],"source":"You can extend the <xref:System.Collections.Generic.IEnumerable%601> interface with a custom query method that returns a sequence of values."},{"content":"In this case, the method must return a collection of type <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[7687,7795],"source":" In this case, the method must return a collection of type <xref:System.Collections.Generic.IEnumerable%601>."},{"content":"Such methods can be used to apply filters or data transforms to a sequence of values.","pos":[7796,7881]},{"pos":[7888,8058],"content":"The following example shows how to create an extension method named <ph id=\"ph1\">`AlternateElements`</ph> that returns every other element in a collection, starting from the first element.","source":"The following example shows how to create an extension method named `AlternateElements` that returns every other element in a collection, starting from the first element."},{"content":"You can call this extension method for any enumerable collection just as you would call other methods from the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface, as shown in the following code:","pos":[8551,8754],"source":"You can call this extension method for any enumerable collection just as you would call other methods from the <xref:System.Collections.Generic.IEnumerable%601> interface, as shown in the following code:"},{"pos":[9020,9028],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>","pos":[9032,9081],"source":"<xref:System.Collections.Generic.IEnumerable%601> "},{"content":"<bpt id=\"p1\"> [</bpt>Extension Methods<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)</ept>","pos":[9085,9199],"source":" [Extension Methods](../../../../visual-basic/programming-guide/language-features/procedures/extension-methods.md)"}]}