{"content":"---\ntitle: Properties\ndescription: Learn about C# properties, which include features for validation, computed values, lazy evaluation, and property changed notifications.\nms.date: 04/25/2018\n---\n# Properties\n\nProperties are first class citizens in C#. The language\ndefines syntax that enables developers to write code\nthat accurately expresses their design intent.\n\nProperties behave like fields when they are accessed.\nHowever, unlike fields, properties are implemented\nwith accessors that define the statements executed\nwhen a property is accessed or assigned.\n\n## Property syntax\n\nThe syntax for properties is a natural extension to\nfields. A field defines a storage location:\n\n[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]\n\nA property definition contains declarations for a `get` and\n`set` accessor that retrieves and assigns the value of that\nproperty:\n\n[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]\n\nThe syntax shown above is the *auto property* syntax. The compiler\ngenerates the storage location for the field that backs up the\nproperty. The compiler also implements the body of the `get` and `set` accessors.\n\nSometimes, you need to initialize a property to\na value other than the default for its type.  C# enables\nthat by setting a value after the closing brace for the\nproperty. You may prefer the initial value for the `FirstName`\nproperty to be the empty string rather than `null`. You would\nspecify that as shown below:\n\n[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]\n\nSpecific initialization is most useful for read-only properties, as you'll see later\nin this article.\n\nYou can also define the storage yourself, as shown below:\n\n[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]\n\nWhen a property implementation is a single expression, you can\nuse *expression-bodied members* for the getter or setter:\n\n[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]\n\nThis simplified syntax will be used where applicable throughout this\narticle.\n\nThe property definition shown above is a read-write property. Notice\nthe keyword `value` in the set accessor. The `set` accessor always has\na single parameter named `value`. The `get` accessor must return a value\nthat is convertible to the type of the property (`string` in this example).\n\nThat's the basics of the syntax. There are many different variations that support\na variety of different design idioms. Let's explore, and learn the syntax\noptions for each.\n\n## Scenarios\n\nThe examples above showed one of the simplest cases of property definition:\na read-write property with no validation. By writing the code you want in the\n`get` and `set` accessors, you can create many different scenarios.\n\n### Validation\n\nYou can write code in the `set` accessor to ensure that the values represented\nby a property are always valid. For example, suppose one rule for the `Person`\nclass is that the name cannot be blank or white space. You would write that as\nfollows:\n\n[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]\n\nThe preceding example can be simplified by using a`throw` expression as part\nof the property setter validation:\n\n[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]\n\nThe example above enforces the rule that the first name must not be blank\nor white space. If a developer writes\n\n```csharp\nhero.FirstName = \"\";\n```\n\nThat assignment throws an `ArgumentException`. Because a property set accessor\nmust have a void return type, you report errors in the set accessor by throwing an exception.\n\nYou can extend this same syntax to anything needed\nin your scenario. You can check the relationships between different properties, or validate\nagainst any external conditions. Any valid C# statements are valid in a property accessor.\n\n### Read-only\n\nUp to this point, all the property definitions you have seen are read/write properties\nwith public accessors. That's not the only valid accessibility for properties.\nYou can create read-only properties, or give different accessibility to the set and get\naccessors. Suppose that your `Person` class should only enable changing the value of the\n`FirstName` property from other methods in that class. You could give the set accessor\n`private` accessibility instead of `public`:\n\n[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]\n\nNow, the `FirstName` property can be accessed from any code, but it can only be assigned\nfrom other code in the `Person` class.\n\nYou can add any restrictive access modifier to either the set or get accessors. Any access modifier\nyou place on the individual accessor must be more limited than the access modifier on the property\ndefinition. The above is legal because the `FirstName` property is `public`, but the set accessor is\n`private`. You could not declare a `private` property with a `public` accessor. Property declarations\ncan also be declared `protected`, `internal`, `protected internal`, or, even `private`.\n\nIt is also legal to place the more restrictive modifier on the `get` accessor. For example, you could\nhave a `public` property, but restrict the `get` accessor to `private`. That scenario is rarely done\nin practice.\n\nYou can also restrict modifications to a property so that it can only be set in a constructor\nor a property initializer. You can modify the `Person` class so as follows:\n\n[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]\n\nThis feature is most commonly used for initializing collections that are exposed as\nread-only properties:\n\n```csharp\npublic class Measurements\n{\n    public ICollection<DataPoint> points { get; } = new List<DataPoint>();\n}\n```\n\n### Computed properties\n\nA property does not need to simply return the value of a member field. You can create properties\nthat return a computed value. Let's expand the `Person` object to return the full name, computed\nby concatenating the first and last names:\n\n[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]\n\nThe example above uses the [string interpolation](../csharp/language-reference/tokens/interpolated.md) feature to create\nthe formatted string for the full name.\n\nYou can also use an *expression-bodied member*, which provides a more\nsuccinct way to create the computed `FullName` property:\n\n[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]\n\n*Expression-bodied members* use the *lambda expression* syntax to\ndefine methods that contain a single expression. Here, that\nexpression returns the full name for the person object.\n\n### Cached evaluated properties\n\nYou can mix the concept of a computed property with storage and create\na *cached evaluated property*.  For example, you could update the `FullName`\nproperty so that the string formatting only happened the first time it\nwas accessed:\n\n[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]\n\nThe above code contains a bug though. If code updates the value of\neither the `FirstName` or `LastName` property, the previously evaluated\n`fullName` field is invalid. You modify the `set` accessors of the\n`FirstName` and `LastName` property so that the `fullName` field is calculated\nagain:\n\n[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]\n\nThis final version evaluates the `FullName` property only when needed.\nIf the previously calculated version is valid, it's used. If another\nstate change invalidates the previously calculated version, it will be\nrecalculated. Developers that use this class do not need to know the\ndetails of the implementation. None of these internal changes affect the\nuse of the Person object. That's the key reason for using Properties to\nexpose data members of an object.\n\n### Attaching attributes to auto-implemented properties\n\nBeginning with C# 7.3, field attributes can be attached to the compiler\ngenerated backing field in auto-implemented properties. For example, consider\na revision to the `Person` class that adds a unique integer `Id` property.\nYou write the`Id` property using an auto-implemented property, but your design does\nnot call for persisting the `Id` property. The <xref:System.NonSerializedAttribute>\ncan only be attached to fields, not properties. You can attach the\n<xref:System.NonSerializedAttribute> to the backing field for the `Id` property\nby using the `field:` specifier on the attribute, as shown in the following example:\n\n[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]\n\nThis technique works for any attribute you attach to the backing field on the\nauto-implemented property.\n\n### Implementing INotifyPropertyChanged\n\nA final scenario where you need to write code in a property accessor is to\nsupport the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding\nclients that a value has changed. When the value of a property changes, the object\nraises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType>\nevent to indicate the change. The data binding libraries, in turn, update display elements\nbased on that change. The code below shows how you would implement `INotifyPropertyChanged`\nfor the `FirstName` property of this person class.\n\n[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]\n\nThe `?.` operator is called\nthe *null conditional operator*. It checks for a null reference before evaluating\nthe right side of the operator. The end result is that if there are no subscribers\nto the `PropertyChanged` event, the code to raise the event doesn't execute. It would\nthrow a `NullReferenceException` without this check in that case. For more information,\nsee [`events`](delegates-events.md). This example also uses the new\n`nameof` operator to convert from the property name symbol to its text representation.\nUsing `nameof` can reduce errors where you have mistyped the name of the property.\n\nAgain, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an\nexample of a case where you can write code in your accessors to support the scenarios you need.\n\n## Summing up\n\nProperties are a form of smart fields in a class or object. From\noutside the object, they appear like fields in the object. However,\nproperties can be implemented using the full palette of C# functionality.\nYou can provide validation, different accessibility, lazy evaluation,\nor any requirements your scenarios need.\n","nodes":[{"pos":[4,190],"embed":true,"restype":"x-metadata","content":"title: Properties\ndescription: Learn about C# properties, which include features for validation, computed values, lazy evaluation, and property changed notifications.\nms.date: 04/25/2018","nodes":[{"content":"Properties","nodes":[{"pos":[0,10],"content":"Properties","nodes":[{"content":"Properties","pos":[0,10]}]}],"path":["title"],"nosxs":false},{"content":"Learn about C# properties, which include features for validation, computed values, lazy evaluation, and property changed notifications.","nodes":[{"pos":[0,135],"content":"Learn about C# properties, which include features for validation, computed values, lazy evaluation, and property changed notifications.","nodes":[{"content":"Learn about C# properties, which include features for validation, computed values, lazy evaluation, and property changed notifications.","pos":[0,135]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[197,207],"content":"Properties","linkify":"Properties","nodes":[{"content":"Properties","pos":[0,10]}]},{"content":"Properties are first class citizens in C#.","pos":[209,251]},{"content":"The language defines syntax that enables developers to write code that accurately expresses their design intent.","pos":[252,364],"source":" The language\ndefines syntax that enables developers to write code\nthat accurately expresses their design intent."},{"content":"Properties behave like fields when they are accessed.","pos":[366,419]},{"content":"However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.","pos":[420,562],"source":"\nHowever, unlike fields, properties are implemented\nwith accessors that define the statements executed\nwhen a property is accessed or assigned."},{"pos":[567,582],"content":"Property syntax","linkify":"Property syntax","nodes":[{"content":"Property syntax","pos":[0,15]}]},{"content":"The syntax for properties is a natural extension to fields.","pos":[584,643],"source":"The syntax for properties is a natural extension to\nfields."},{"content":"A field defines a storage location:","pos":[644,679]},{"pos":[784,913],"content":"A property definition contains declarations for a <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessor that retrieves and assigns the value of that property:","source":"A property definition contains declarations for a `get` and\n`set` accessor that retrieves and assigns the value of that\nproperty:"},{"content":"The syntax shown above is the <bpt id=\"p1\">*</bpt>auto property<ept id=\"p1\">*</ept> syntax.","pos":[1022,1075],"source":"The syntax shown above is the *auto property* syntax."},{"content":"The compiler generates the storage location for the field that backs up the property.","pos":[1076,1161],"source":" The compiler\ngenerates the storage location for the field that backs up the\nproperty."},{"content":"The compiler also implements the body of the <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessors.","pos":[1162,1233],"source":" The compiler also implements the body of the `get` and `set` accessors."},{"content":"Sometimes, you need to initialize a property to a value other than the default for its type.","pos":[1235,1327],"source":"Sometimes, you need to initialize a property to\na value other than the default for its type."},{"content":"C# enables that by setting a value after the closing brace for the property.","pos":[1329,1405],"source":"  C# enables\nthat by setting a value after the closing brace for the\nproperty."},{"content":"You may prefer the initial value for the <ph id=\"ph1\">`FirstName`</ph> property to be the empty string rather than <ph id=\"ph2\">`null`</ph>.","pos":[1406,1510],"source":" You may prefer the initial value for the `FirstName`\nproperty to be the empty string rather than `null`."},{"content":"You would specify that as shown below:","pos":[1511,1549],"source":" You would\nspecify that as shown below:"},{"pos":[1667,1768],"content":"Specific initialization is most useful for read-only properties, as you'll see later in this article.","source":"Specific initialization is most useful for read-only properties, as you'll see later\nin this article."},{"content":"You can also define the storage yourself, as shown below:","pos":[1770,1827]},{"pos":[1947,2067],"content":"When a property implementation is a single expression, you can use <bpt id=\"p1\">*</bpt>expression-bodied members<ept id=\"p1\">*</ept> for the getter or setter:","source":"When a property implementation is a single expression, you can\nuse *expression-bodied members* for the getter or setter:"},{"pos":[2211,2288],"content":"This simplified syntax will be used where applicable throughout this article.","source":"This simplified syntax will be used where applicable throughout this\narticle."},{"content":"The property definition shown above is a read-write property.","pos":[2290,2351]},{"content":"Notice the keyword <ph id=\"ph1\">`value`</ph> in the set accessor.","pos":[2352,2399],"source":" Notice\nthe keyword `value` in the set accessor."},{"content":"The <ph id=\"ph1\">`set`</ph> accessor always has a single parameter named <ph id=\"ph2\">`value`</ph>.","pos":[2400,2463],"source":" The `set` accessor always has\na single parameter named `value`."},{"content":"The <ph id=\"ph1\">`get`</ph> accessor must return a value that is convertible to the type of the property (<ph id=\"ph2\">`string`</ph> in this example).","pos":[2464,2578],"source":" The `get` accessor must return a value\nthat is convertible to the type of the property (`string` in this example)."},{"content":"That's the basics of the syntax.","pos":[2580,2612]},{"content":"There are many different variations that support a variety of different design idioms.","pos":[2613,2699],"source":" There are many different variations that support\na variety of different design idioms."},{"content":"Let's explore, and learn the syntax options for each.","pos":[2700,2753],"source":" Let's explore, and learn the syntax\noptions for each."},{"pos":[2758,2767],"content":"Scenarios","linkify":"Scenarios","nodes":[{"content":"Scenarios","pos":[0,9]}]},{"content":"The examples above showed one of the simplest cases of property definition: a read-write property with no validation.","pos":[2769,2886],"source":"The examples above showed one of the simplest cases of property definition:\na read-write property with no validation."},{"content":"By writing the code you want in the <ph id=\"ph1\">`get`</ph> and <ph id=\"ph2\">`set`</ph> accessors, you can create many different scenarios.","pos":[2887,2990],"source":" By writing the code you want in the\n`get` and `set` accessors, you can create many different scenarios."},{"pos":[2996,3006],"content":"Validation","linkify":"Validation","nodes":[{"content":"Validation","pos":[0,10]}]},{"content":"You can write code in the <ph id=\"ph1\">`set`</ph> accessor to ensure that the values represented by a property are always valid.","pos":[3008,3118],"source":"You can write code in the `set` accessor to ensure that the values represented\nby a property are always valid."},{"content":"For example, suppose one rule for the <ph id=\"ph1\">`Person`</ph> class is that the name cannot be blank or white space.","pos":[3119,3220],"source":" For example, suppose one rule for the `Person`\nclass is that the name cannot be blank or white space."},{"content":"You would write that as follows:","pos":[3221,3253],"source":" You would write that as\nfollows:"},{"pos":[3354,3465],"content":"The preceding example can be simplified by using a<ph id=\"ph1\">`throw`</ph> expression as part of the property setter validation:","source":"The preceding example can be simplified by using a`throw` expression as part\nof the property setter validation:"},{"content":"The example above enforces the rule that the first name must not be blank or white space.","pos":[3566,3655],"source":"The example above enforces the rule that the first name must not be blank\nor white space."},{"content":"If a developer writes","pos":[3656,3677]},{"content":"That assignment throws an <ph id=\"ph1\">`ArgumentException`</ph>.","pos":[3715,3761],"source":"That assignment throws an `ArgumentException`."},{"content":"Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.","pos":[3762,3887],"source":" Because a property set accessor\nmust have a void return type, you report errors in the set accessor by throwing an exception."},{"content":"You can extend this same syntax to anything needed in your scenario.","pos":[3889,3957],"source":"You can extend this same syntax to anything needed\nin your scenario."},{"content":"You can check the relationships between different properties, or validate against any external conditions.","pos":[3958,4064],"source":" You can check the relationships between different properties, or validate\nagainst any external conditions."},{"content":"Any valid C# statements are valid in a property accessor.","pos":[4065,4122]},{"pos":[4128,4137],"content":"Read-only","linkify":"Read-only","nodes":[{"content":"Read-only","pos":[0,9]}]},{"content":"Up to this point, all the property definitions you have seen are read/write properties with public accessors.","pos":[4139,4248],"source":"Up to this point, all the property definitions you have seen are read/write properties\nwith public accessors."},{"content":"That's not the only valid accessibility for properties.","pos":[4249,4304]},{"content":"You can create read-only properties, or give different accessibility to the set and get accessors.","pos":[4305,4403],"source":"\nYou can create read-only properties, or give different accessibility to the set and get\naccessors."},{"content":"Suppose that your <ph id=\"ph1\">`Person`</ph> class should only enable changing the value of the <ph id=\"ph2\">`FirstName`</ph> property from other methods in that class.","pos":[4404,4536],"source":" Suppose that your `Person` class should only enable changing the value of the\n`FirstName` property from other methods in that class."},{"content":"You could give the set accessor <ph id=\"ph1\">`private`</ph> accessibility instead of <ph id=\"ph2\">`public`</ph>:","pos":[4537,4613],"source":" You could give the set accessor\n`private` accessibility instead of `public`:"},{"pos":[4742,4869],"content":"Now, the <ph id=\"ph1\">`FirstName`</ph> property can be accessed from any code, but it can only be assigned from other code in the <ph id=\"ph2\">`Person`</ph> class.","source":"Now, the `FirstName` property can be accessed from any code, but it can only be assigned\nfrom other code in the `Person` class."},{"content":"You can add any restrictive access modifier to either the set or get accessors.","pos":[4871,4950]},{"content":"Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.","pos":[4951,5081],"source":" Any access modifier\nyou place on the individual accessor must be more limited than the access modifier on the property\ndefinition."},{"content":"The above is legal because the <ph id=\"ph1\">`FirstName`</ph> property is <ph id=\"ph2\">`public`</ph>, but the set accessor is <ph id=\"ph3\">`private`</ph>.","pos":[5082,5181],"source":" The above is legal because the `FirstName` property is `public`, but the set accessor is\n`private`."},{"content":"You could not declare a <ph id=\"ph1\">`private`</ph> property with a <ph id=\"ph2\">`public`</ph> accessor.","pos":[5182,5250],"source":" You could not declare a `private` property with a `public` accessor."},{"content":"Property declarations can also be declared <ph id=\"ph1\">`protected`</ph>, <ph id=\"ph2\">`internal`</ph>, <ph id=\"ph3\">`protected internal`</ph>, or, even <ph id=\"ph4\">`private`</ph>.","pos":[5251,5360],"source":" Property declarations\ncan also be declared `protected`, `internal`, `protected internal`, or, even `private`."},{"content":"It is also legal to place the more restrictive modifier on the <ph id=\"ph1\">`get`</ph> accessor.","pos":[5362,5440],"source":"It is also legal to place the more restrictive modifier on the `get` accessor."},{"content":"For example, you could have a <ph id=\"ph1\">`public`</ph> property, but restrict the <ph id=\"ph2\">`get`</ph> accessor to <ph id=\"ph3\">`private`</ph>.","pos":[5441,5535],"source":" For example, you could\nhave a `public` property, but restrict the `get` accessor to `private`."},{"content":"That scenario is rarely done in practice.","pos":[5536,5577],"source":" That scenario is rarely done\nin practice."},{"content":"You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.","pos":[5579,5699],"source":"You can also restrict modifications to a property so that it can only be set in a constructor\nor a property initializer."},{"content":"You can modify the <ph id=\"ph1\">`Person`</ph> class so as follows:","pos":[5700,5748],"source":" You can modify the `Person` class so as follows:"},{"pos":[5858,5963],"content":"This feature is most commonly used for initializing collections that are exposed as read-only properties:","source":"This feature is most commonly used for initializing collections that are exposed as\nread-only properties:"},{"pos":[6089,6108],"content":"Computed properties","linkify":"Computed properties","nodes":[{"content":"Computed properties","pos":[0,19]}]},{"content":"A property does not need to simply return the value of a member field.","pos":[6110,6180]},{"content":"You can create properties that return a computed value.","pos":[6181,6236],"source":" You can create properties\nthat return a computed value."},{"content":"Let's expand the <ph id=\"ph1\">`Person`</ph> object to return the full name, computed by concatenating the first and last names:","pos":[6237,6346],"source":" Let's expand the `Person` object to return the full name, computed\nby concatenating the first and last names:"},{"pos":[6440,6600],"content":"The example above uses the <bpt id=\"p1\">[</bpt>string interpolation<ept id=\"p1\">](../csharp/language-reference/tokens/interpolated.md)</ept> feature to create the formatted string for the full name.","source":"The example above uses the [string interpolation](../csharp/language-reference/tokens/interpolated.md) feature to create\nthe formatted string for the full name."},{"pos":[6602,6728],"content":"You can also use an <bpt id=\"p1\">*</bpt>expression-bodied member<ept id=\"p1\">*</ept>, which provides a more succinct way to create the computed <ph id=\"ph1\">`FullName`</ph> property:","source":"You can also use an *expression-bodied member*, which provides a more\nsuccinct way to create the computed `FullName` property:"},{"content":"<bpt id=\"p1\">*</bpt>Expression-bodied members<ept id=\"p1\">*</ept> use the <bpt id=\"p2\">*</bpt>lambda expression<ept id=\"p2\">*</ept> syntax to define methods that contain a single expression.","pos":[6856,6970],"source":"*Expression-bodied members* use the *lambda expression* syntax to\ndefine methods that contain a single expression."},{"content":"Here, that expression returns the full name for the person object.","pos":[6971,7037],"source":" Here, that\nexpression returns the full name for the person object."},{"pos":[7043,7070],"content":"Cached evaluated properties","linkify":"Cached evaluated properties","nodes":[{"content":"Cached evaluated properties","pos":[0,27]}]},{"content":"You can mix the concept of a computed property with storage and create a <bpt id=\"p1\">*</bpt>cached evaluated property<ept id=\"p1\">*</ept>.","pos":[7072,7173],"source":"You can mix the concept of a computed property with storage and create\na *cached evaluated property*."},{"content":"For example, you could update the <ph id=\"ph1\">`FullName`</ph> property so that the string formatting only happened the first time it was accessed:","pos":[7175,7304],"source":"  For example, you could update the `FullName`\nproperty so that the string formatting only happened the first time it\nwas accessed:"},{"content":"The above code contains a bug though.","pos":[7419,7456]},{"content":"If code updates the value of either the <ph id=\"ph1\">`FirstName`</ph> or <ph id=\"ph2\">`LastName`</ph> property, the previously evaluated <ph id=\"ph3\">`fullName`</ph> field is invalid.","pos":[7457,7586],"source":" If code updates the value of\neither the `FirstName` or `LastName` property, the previously evaluated\n`fullName` field is invalid."},{"content":"You modify the <ph id=\"ph1\">`set`</ph> accessors of the <ph id=\"ph2\">`FirstName`</ph> and <ph id=\"ph3\">`LastName`</ph> property so that the <ph id=\"ph4\">`fullName`</ph> field is calculated again:","pos":[7587,7710],"source":" You modify the `set` accessors of the\n`FirstName` and `LastName` property so that the `fullName` field is calculated\nagain:"},{"content":"This final version evaluates the <ph id=\"ph1\">`FullName`</ph> property only when needed.","pos":[7817,7887],"source":"This final version evaluates the `FullName` property only when needed."},{"content":"If the previously calculated version is valid, it's used.","pos":[7888,7945],"source":"\nIf the previously calculated version is valid, it's used."},{"content":"If another state change invalidates the previously calculated version, it will be recalculated.","pos":[7946,8041],"source":" If another\nstate change invalidates the previously calculated version, it will be\nrecalculated."},{"content":"Developers that use this class do not need to know the details of the implementation.","pos":[8042,8127],"source":" Developers that use this class do not need to know the\ndetails of the implementation."},{"content":"None of these internal changes affect the use of the Person object.","pos":[8128,8195],"source":" None of these internal changes affect the\nuse of the Person object."},{"content":"That's the key reason for using Properties to expose data members of an object.","pos":[8196,8275],"source":" That's the key reason for using Properties to\nexpose data members of an object."},{"pos":[8281,8332],"content":"Attaching attributes to auto-implemented properties","linkify":"Attaching attributes to auto-implemented properties","nodes":[{"content":"Attaching attributes to auto-implemented properties","pos":[0,51]}]},{"content":"Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.","pos":[8334,8461],"source":"Beginning with C# 7.3, field attributes can be attached to the compiler\ngenerated backing field in auto-implemented properties."},{"content":"For example, consider a revision to the <ph id=\"ph1\">`Person`</ph> class that adds a unique integer <ph id=\"ph2\">`Id`</ph> property.","pos":[8462,8558],"source":" For example, consider\na revision to the `Person` class that adds a unique integer `Id` property."},{"content":"You write the<ph id=\"ph1\">`Id`</ph> property using an auto-implemented property, but your design does not call for persisting the <ph id=\"ph2\">`Id`</ph> property.","pos":[8559,8685],"source":"\nYou write the`Id` property using an auto-implemented property, but your design does\nnot call for persisting the `Id` property."},{"content":"The <ph id=\"ph1\">&lt;xref:System.NonSerializedAttribute&gt;</ph> can only be attached to fields, not properties.","pos":[8686,8774],"source":" The <xref:System.NonSerializedAttribute>\ncan only be attached to fields, not properties."},{"content":"You can attach the <ph id=\"ph1\">&lt;xref:System.NonSerializedAttribute&gt;</ph> to the backing field for the <ph id=\"ph2\">`Id`</ph> property by using the <ph id=\"ph3\">`field:`</ph> specifier on the attribute, as shown in the following example:","pos":[8775,8958],"source":" You can attach the\n<xref:System.NonSerializedAttribute> to the backing field for the `Id` property\nby using the `field:` specifier on the attribute, as shown in the following example:"},{"pos":[9072,9176],"content":"This technique works for any attribute you attach to the backing field on the auto-implemented property.","source":"This technique works for any attribute you attach to the backing field on the\nauto-implemented property."},{"pos":[9182,9217],"content":"Implementing INotifyPropertyChanged","linkify":"Implementing INotifyPropertyChanged","nodes":[{"content":"Implementing INotifyPropertyChanged","pos":[0,35]}]},{"content":"A final scenario where you need to write code in a property accessor is to support the <ph id=\"ph1\">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph> interface used to notify data binding clients that a value has changed.","pos":[9219,9429],"source":"A final scenario where you need to write code in a property accessor is to\nsupport the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding\nclients that a value has changed."},{"content":"When the value of a property changes, the object raises the <ph id=\"ph1\">&lt;xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType&gt;</ph> event to indicate the change.","pos":[9430,9616],"source":" When the value of a property changes, the object\nraises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType>\nevent to indicate the change."},{"content":"The data binding libraries, in turn, update display elements based on that change.","pos":[9617,9699],"source":" The data binding libraries, in turn, update display elements\nbased on that change."},{"content":"The code below shows how you would implement <ph id=\"ph1\">`INotifyPropertyChanged`</ph> for the <ph id=\"ph2\">`FirstName`</ph> property of this person class.","pos":[9700,9820],"source":" The code below shows how you would implement `INotifyPropertyChanged`\nfor the `FirstName` property of this person class."},{"content":"The <ph id=\"ph1\">`?.`</ph> operator is called the <bpt id=\"p1\">*</bpt>null conditional operator<ept id=\"p1\">*</ept>.","pos":[9927,9987],"source":"The `?.` operator is called\nthe *null conditional operator*."},{"content":"It checks for a null reference before evaluating the right side of the operator.","pos":[9988,10068],"source":" It checks for a null reference before evaluating\nthe right side of the operator."},{"content":"The end result is that if there are no subscribers to the <ph id=\"ph1\">`PropertyChanged`</ph> event, the code to raise the event doesn't execute.","pos":[10069,10196],"source":" The end result is that if there are no subscribers\nto the `PropertyChanged` event, the code to raise the event doesn't execute."},{"content":"It would throw a <ph id=\"ph1\">`NullReferenceException`</ph> without this check in that case.","pos":[10197,10271],"source":" It would\nthrow a `NullReferenceException` without this check in that case."},{"content":"For more information, see <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`events`</ph><ept id=\"p1\">](delegates-events.md)</ept>.","pos":[10272,10330],"source":" For more information,\nsee [`events`](delegates-events.md)."},{"content":"This example also uses the new <ph id=\"ph1\">`nameof`</ph> operator to convert from the property name symbol to its text representation.","pos":[10331,10448],"source":" This example also uses the new\n`nameof` operator to convert from the property name symbol to its text representation."},{"content":"Using <ph id=\"ph1\">`nameof`</ph> can reduce errors where you have mistyped the name of the property.","pos":[10449,10531],"source":"\nUsing `nameof` can reduce errors where you have mistyped the name of the property."},{"pos":[10533,10706],"content":"Again, implementing <ph id=\"ph1\">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph> is an example of a case where you can write code in your accessors to support the scenarios you need.","source":"Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an\nexample of a case where you can write code in your accessors to support the scenarios you need."},{"pos":[10711,10721],"content":"Summing up","linkify":"Summing up","nodes":[{"content":"Summing up","pos":[0,10]}]},{"content":"Properties are a form of smart fields in a class or object.","pos":[10723,10782]},{"content":"From outside the object, they appear like fields in the object.","pos":[10783,10846],"source":" From\noutside the object, they appear like fields in the object."},{"content":"However, properties can be implemented using the full palette of C# functionality.","pos":[10847,10929],"source":" However,\nproperties can be implemented using the full palette of C# functionality."},{"content":"You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.","pos":[10930,11040],"source":"\nYou can provide validation, different accessibility, lazy evaluation,\nor any requirements your scenarios need."}]}