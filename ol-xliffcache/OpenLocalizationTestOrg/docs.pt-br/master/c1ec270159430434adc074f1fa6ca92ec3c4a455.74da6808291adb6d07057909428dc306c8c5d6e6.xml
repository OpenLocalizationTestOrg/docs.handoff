{"content":"---\ntitle: \"How to: Iterate File Directories with the Parallel Class\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"parallel loops, how to iterate directories\"\nms.assetid: 555e9f48-f53d-4774-9bcf-3e965c732ec5\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# How to: Iterate File Directories with the Parallel Class\nIn many cases, file iteration is an operation that can be easily parallelized. The topic [How to: Iterate File Directories with PLINQ](../../../docs/standard/parallel-programming/how-to-iterate-file-directories-with-plinq.md) shows the easiest way to perform this task for many scenarios. However, complications can arise when your code has to deal with the many types of exceptions that can arise when accessing the file system. The following example shows one approach to the problem. It uses a stack-based iteration to traverse all files and folders under a specified directory, and it enables your code to catch and handle various exceptions. Of course, the way that you handle the exceptions is up to you.  \n  \n## Example  \n The following example iterates the directories sequentially, but processes the files in parallel. This is probably the best approach when you have a large file-to-directory ratio. It is also possible to parallelize the directory iteration, and access each file sequentially. It is probably not efficient to parallelize both loops unless you are specifically targeting a machine with a large number of processors. However, as in all cases, you should test your application thoroughly to determine the best approach.  \n  \n [!code-csharp[TPL_Parallel#08](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_parallel/cs/parallel_file.cs#08)]\n [!code-vb[TPL_Parallel#08](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_parallel/vb/fileiteration08.vb#08)]  \n  \n In this example, the file I/O is performed synchronously. When dealing with large files or slow network connections, it might be preferable to access the files asynchronously. You can combine asynchronous I/O techniques with parallel iteration. For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).  \n  \n The example uses the local `fileCount` variable to maintain a count of the total number of files processed. Because the variable might be accessed concurrently by multiple tasks, access to it is synchronized by calling the <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method.  \n  \n Note that if an exception is thrown on the main thread, the threads that are started by the <xref:System.Threading.Tasks.Parallel.ForEach%2A> method might continue to run. To stop these threads, you can set a Boolean variable in your exception handlers, and check its value on each iteration of the parallel loop. If the value indicates that an exception has been thrown, use the <xref:System.Threading.Tasks.ParallelLoopState> variable to stop or break from the loop. For more information, see [How to: Stop or Break from a Parallel.For Loop](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd460721(v=vs.100)).  \n  \n## See also\n\n- [Data Parallelism](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)\n","nodes":[{"pos":[4,316],"embed":true,"restype":"x-metadata","content":"title: \"How to: Iterate File Directories with the Parallel Class\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"parallel loops, how to iterate directories\"\nms.assetid: 555e9f48-f53d-4774-9bcf-3e965c732ec5\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"How to: Iterate File Directories with the Parallel Class","nodes":[{"pos":[0,56],"content":"How to: Iterate File Directories with the Parallel Class","nodes":[{"content":"How to: Iterate File Directories with the Parallel Class","pos":[0,56]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[323,379],"content":"How to: Iterate File Directories with the Parallel Class","linkify":"How to: Iterate File Directories with the Parallel Class","nodes":[{"content":"How to: Iterate File Directories with the Parallel Class","pos":[0,56]}]},{"content":"In many cases, file iteration is an operation that can be easily parallelized.","pos":[380,458]},{"content":"The topic <bpt id=\"p1\">[</bpt>How to: Iterate File Directories with PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-iterate-file-directories-with-plinq.md)</ept> shows the easiest way to perform this task for many scenarios.","pos":[459,668],"source":" The topic [How to: Iterate File Directories with PLINQ](../../../docs/standard/parallel-programming/how-to-iterate-file-directories-with-plinq.md) shows the easiest way to perform this task for many scenarios."},{"content":"However, complications can arise when your code has to deal with the many types of exceptions that can arise when accessing the file system.","pos":[669,809]},{"content":"The following example shows one approach to the problem.","pos":[810,866]},{"content":"It uses a stack-based iteration to traverse all files and folders under a specified directory, and it enables your code to catch and handle various exceptions.","pos":[867,1026]},{"content":"Of course, the way that you handle the exceptions is up to you.","pos":[1027,1090]},{"pos":[1099,1106],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example iterates the directories sequentially, but processes the files in parallel.","pos":[1110,1207]},{"content":"This is probably the best approach when you have a large file-to-directory ratio.","pos":[1208,1289]},{"content":"It is also possible to parallelize the directory iteration, and access each file sequentially.","pos":[1290,1384]},{"content":"It is probably not efficient to parallelize both loops unless you are specifically targeting a machine with a large number of processors.","pos":[1385,1522]},{"content":"However, as in all cases, you should test your application thoroughly to determine the best approach.","pos":[1523,1624]},{"content":"In this example, the file I/O is performed synchronously.","pos":[1879,1936]},{"content":"When dealing with large files or slow network connections, it might be preferable to access the files asynchronously.","pos":[1937,2054]},{"content":"You can combine asynchronous I/O techniques with parallel iteration.","pos":[2055,2123]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>TPL and Traditional .NET Framework Asynchronous Programming<ept id=\"p1\">](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md)</ept>.","pos":[2124,2298],"source":" For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md)."},{"content":"The example uses the local <ph id=\"ph1\">`fileCount`</ph> variable to maintain a count of the total number of files processed.","pos":[2305,2412],"source":"The example uses the local `fileCount` variable to maintain a count of the total number of files processed."},{"content":"Because the variable might be accessed concurrently by multiple tasks, access to it is synchronized by calling the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[2413,2607],"source":" Because the variable might be accessed concurrently by multiple tasks, access to it is synchronized by calling the <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method."},{"content":"Note that if an exception is thrown on the main thread, the threads that are started by the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A&gt;</ph> method might continue to run.","pos":[2614,2785],"source":"Note that if an exception is thrown on the main thread, the threads that are started by the <xref:System.Threading.Tasks.Parallel.ForEach%2A> method might continue to run."},{"content":"To stop these threads, you can set a Boolean variable in your exception handlers, and check its value on each iteration of the parallel loop.","pos":[2786,2927]},{"content":"If the value indicates that an exception has been thrown, use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.ParallelLoopState&gt;</ph> variable to stop or break from the loop.","pos":[2928,3082],"source":" If the value indicates that an exception has been thrown, use the <xref:System.Threading.Tasks.ParallelLoopState> variable to stop or break from the loop."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Stop or Break from a Parallel.For Loop<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd460721(v=vs.100))</ept>.","pos":[3083,3247],"source":" For more information, see [How to: Stop or Break from a Parallel.For Loop](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd460721(v=vs.100))."},{"pos":[3256,3264],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3268,3373],"content":"<bpt id=\"p1\">[</bpt>Data Parallelism<ept id=\"p1\">](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)</ept>","source":"[Data Parallelism](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)"}]}