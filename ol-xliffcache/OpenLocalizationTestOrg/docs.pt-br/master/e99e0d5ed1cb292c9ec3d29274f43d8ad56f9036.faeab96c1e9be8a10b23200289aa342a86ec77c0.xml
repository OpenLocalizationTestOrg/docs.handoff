{"content":"---\ntitle: \"Performance of Chained Queries (LINQ to XML) (C#) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: b2f1d715-8946-4dc0-8d56-fb3d1bba54a6\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\n---\n# Performance of Chained Queries (LINQ to XML) (C#)\nOne of the most important benefits of LINQ (and LINQ to XML) is that chained queries can perform as well as a single larger, more complicated query.  \n  \n A chained query is a query that uses another query as its source. For example, in the following simple code, `query2` has `query1` as its source:  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"Child\", 1),  \n    new XElement(\"Child\", 2),  \n    new XElement(\"Child\", 3),  \n    new XElement(\"Child\", 4)  \n);  \n  \nvar query1 = from x in root.Elements(\"Child\")  \n             where (int)x >= 3  \n             select x;  \n  \nvar query2 = from e in query1  \n             where (int)e % 2 == 0  \n             select e;  \n  \nforeach (var i in query2)  \n    Console.WriteLine(\"{0}\", (int)i);  \n```  \n  \n This example produces the following output:  \n  \n```  \n4  \n```  \n  \n This chained query provides the same performance profile as iterating through a linked list.  \n  \n-   The <xref:System.Xml.Linq.XContainer.Elements%2A> axis has essentially the same performance as iterating through a linked list. <xref:System.Xml.Linq.XContainer.Elements%2A> is implemented as an iterator with deferred execution. This means that it does some work in addition to iterating through the linked list, such as allocating the iterator object and keeping track of execution state. This work can be divided into two categories: the work that is done at the time the iterator is set up, and the work that is done during each iteration. The setup work is a small, fixed amount of work and the work done during each iteration is proportional to the number of items in the source collection.  \n  \n-   In `query1`, the `where` clause causes the query to call the <xref:System.Linq.Enumerable.Where%2A> method. This method is also implemented as an iterator. The setup work consists of instantiating the delegate that will reference the lambda expression, plus the normal setup for an iterator. With each iteration, the delegate is called to execute the predicate. The setup work and the work done during each iteration is the similar to the work done while iterating through the axis.  \n  \n-   In `query1`, the select clause causes the query to call the <xref:System.Linq.Enumerable.Select%2A> method. This method has the same performance profile as the <xref:System.Linq.Enumerable.Where%2A> method.  \n  \n-   In `query2`, both the `where` clause and the `select` clause have the same performance profile as in `query1`.  \n  \n The iteration through `query2` is therefore directly proportional to the number of items in the source of the first query, in other words, linear time. A corresponding Visual Basic example would have the same performance profile.  \n  \n For more information on iterators, see [yield](../../../../csharp/language-reference/keywords/yield.md).  \n  \n For a more detailed tutorial on chaining queries together, see [Tutorial: Chaining Queries Together](http://msdn.microsoft.com/library/c08d228a-f07a-4c98-810f-1bf0e8f2257c).  \n  \n## See Also  \n [Performance (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)","nodes":[{"pos":[12,78],"content":"Performance of Chained Queries (LINQ to XML) (C#) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Performance of Chained Queries (LINQ to XML) (C#) | Microsoft Docs","pos":[0,66]}]},{"pos":[363,412],"content":"Performance of Chained Queries (LINQ to XML) (C#)","linkify":"Performance of Chained Queries (LINQ to XML) (C#)","nodes":[{"content":"Performance of Chained Queries (LINQ to XML) (C#)","pos":[0,49]}]},{"content":"One of the most important benefits of LINQ (and LINQ to XML) is that chained queries can perform as well as a single larger, more complicated query.","pos":[413,561]},{"content":"A chained query is a query that uses another query as its source.","pos":[568,633]},{"content":"For example, in the following simple code, <ph id=\"ph1\">`query2`</ph> has <ph id=\"ph2\">`query1`</ph> as its source:","pos":[634,713],"source":" For example, in the following simple code, `query2` has `query1` as its source:"},{"content":"This example produces the following output:","pos":[1189,1232]},{"content":"This chained query provides the same performance profile as iterating through a linked list.","pos":[1258,1350]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XContainer.Elements%2A&gt;</ph> axis has essentially the same performance as iterating through a linked list.","pos":[1360,1487],"source":"The <xref:System.Xml.Linq.XContainer.Elements%2A> axis has essentially the same performance as iterating through a linked list."},{"content":"<ph id=\"ph1\">&lt;xref:System.Xml.Linq.XContainer.Elements%2A&gt;</ph> is implemented as an iterator with deferred execution.","pos":[1488,1588],"source":"<xref:System.Xml.Linq.XContainer.Elements%2A> is implemented as an iterator with deferred execution."},{"content":"This means that it does some work in addition to iterating through the linked list, such as allocating the iterator object and keeping track of execution state.","pos":[1589,1749]},{"content":"This work can be divided into two categories: the work that is done at the time the iterator is set up, and the work that is done during each iteration.","pos":[1750,1902]},{"content":"The setup work is a small, fixed amount of work and the work done during each iteration is proportional to the number of items in the source collection.","pos":[1903,2055]},{"content":"In <ph id=\"ph1\">`query1`</ph>, the <ph id=\"ph2\">`where`</ph> clause causes the query to call the <ph id=\"ph3\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method.","pos":[2065,2172],"source":"In `query1`, the `where` clause causes the query to call the <xref:System.Linq.Enumerable.Where%2A> method."},{"content":"This method is also implemented as an iterator.","pos":[2173,2220]},{"content":"The setup work consists of instantiating the delegate that will reference the lambda expression, plus the normal setup for an iterator.","pos":[2221,2356]},{"content":"With each iteration, the delegate is called to execute the predicate.","pos":[2357,2426]},{"content":"The setup work and the work done during each iteration is the similar to the work done while iterating through the axis.","pos":[2427,2547]},{"content":"In <ph id=\"ph1\">`query1`</ph>, the select clause causes the query to call the <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.Select%2A&gt;</ph> method.","pos":[2557,2664],"source":"In `query1`, the select clause causes the query to call the <xref:System.Linq.Enumerable.Select%2A> method."},{"content":"This method has the same performance profile as the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method.","pos":[2665,2763],"source":" This method has the same performance profile as the <xref:System.Linq.Enumerable.Where%2A> method."},{"pos":[2773,2883],"content":"In <ph id=\"ph1\">`query2`</ph>, both the <ph id=\"ph2\">`where`</ph> clause and the <ph id=\"ph3\">`select`</ph> clause have the same performance profile as in <ph id=\"ph4\">`query1`</ph>.","source":"In `query2`, both the `where` clause and the `select` clause have the same performance profile as in `query1`."},{"content":"The iteration through <ph id=\"ph1\">`query2`</ph> is therefore directly proportional to the number of items in the source of the first query, in other words, linear time.","pos":[2890,3041],"source":"The iteration through `query2` is therefore directly proportional to the number of items in the source of the first query, in other words, linear time."},{"content":"A corresponding Visual Basic example would have the same performance profile.","pos":[3042,3119]},{"pos":[3126,3230],"content":"For more information on iterators, see <bpt id=\"p1\">[</bpt>yield<ept id=\"p1\">](../../../../csharp/language-reference/keywords/yield.md)</ept>.","source":"For more information on iterators, see [yield](../../../../csharp/language-reference/keywords/yield.md)."},{"pos":[3237,3410],"content":"For a more detailed tutorial on chaining queries together, see <bpt id=\"p1\">[</bpt>Tutorial: Chaining Queries Together<ept id=\"p1\">](http://msdn.microsoft.com/library/c08d228a-f07a-4c98-810f-1bf0e8f2257c)</ept>.","source":"For a more detailed tutorial on chaining queries together, see [Tutorial: Chaining Queries Together](http://msdn.microsoft.com/library/c08d228a-f07a-4c98-810f-1bf0e8f2257c)."},{"pos":[3419,3427],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[3431,3542],"content":"<bpt id=\"p1\">[</bpt>Performance (LINQ to XML) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)</ept>","source":"[Performance (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)"}]}