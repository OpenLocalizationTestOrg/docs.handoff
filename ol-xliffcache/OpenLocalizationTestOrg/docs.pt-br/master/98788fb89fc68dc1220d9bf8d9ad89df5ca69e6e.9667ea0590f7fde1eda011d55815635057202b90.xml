{"content":"---\ntitle: \"Choosing a Message Exchange Pattern\"\nms.date: \"03/30/2017\"\nms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146\n---\n# Choosing a Message Exchange Pattern\nThe first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing. This topic describes the options available and discusses the various requirements. This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md).  \n  \n## Six Message Exchange Patterns  \n There are three MEPs to choose from:  \n  \n-   Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)  \n  \n     When using a datagram MEP, a client sends a message using a *fire and forget* exchange. A fire and forget exchange is one that requires out-of-band confirmation of successful delivery. The message might be lost in transit and never reach the service. If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message. The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols. Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.  \n  \n-   Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)  \n  \n     In this MEP, a message is sent, and a reply is received. The pattern consists of request-response pairs. Examples of request-response calls are remote procedure calls (RPC) and browser GET requests. This pattern is also known as half-duplex. In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.  \n  \n-   Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)  \n  \n     The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order. The duplex MEP is like a phone conversation, where each word being spoken is a message. Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.  \n  \n ![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif \"wcfc_BasicThreeMEPsc\")  \nThe three basic message exchange patterns. Top to bottom: datagram, request-response, and duplex.  \n  \n Each of these MEPs can also support *sessions*. A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel. The request-response pattern is a stand-alone two-message session, as the request and reply are correlated. In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other. This gives you a total of six MEPs to choose from:  \n  \n-   Datagram  \n  \n-   Request-response  \n  \n-   Duplex  \n  \n-   Datagram with sessions  \n  \n-   Request-response with sessions  \n  \n-   Duplex with sessions  \n  \n> [!NOTE]\n>  For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.  \n  \n## Sessions and Sessionful Channels  \n In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP). WCF uses the term session to mean a connection-like logical abstraction. Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.  \n  \n In the channel object model, each logical session manifests as an instance of a sessionful channel. Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side. The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.  \n  \n ![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif \"wcfc_SessionAndSessionlessChannelsc\")  \n  \n A client creates a new sessionful channel and sends a message. On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener). The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.  \n  \n Another client (or the same client) creates a new sessionful and sends a message. The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.  \n  \n Without sessions, there is no correlation between channels and sessions. Therefore a channel listener creates only one channel through which all received messages are delivered to the application. There is also no message ordering because there is no session within which to maintain message order. The top portion of the preceding graphic illustrates a sessionless message exchange.  \n  \n## Starting and Terminating Sessions  \n Sessions are started on the client by simply creating a new sessionful channel. They are started on the service when the service receives a message that was sent in a new session. Likewise, sessions are terminated by closing or aborting a sessionful channel.  \n  \n The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern. It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.  \n  \n In general, sessions are closed on the outgoing side and not on the incoming side. That is, sessionful output channels can be closed, thereby cleanly terminating the session. Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.  \n  \n However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed. If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing. If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.  \n  \n## Writing Sessionful Channels  \n As a sessionful channel author, there are a few things your channel must do to provide sessions. On the send side, your channel needs to:  \n  \n-   For each new channel, create a new session and associate it with a new session id which is a unique string. Or obtain a new session from the sessionful channel below you in the stack.  \n  \n-   For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session. For protocol channels, this is typically done by adding a SOAP header. For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.  \n  \n-   For each message sent using this channel, you need to provide the delivery guarantees mentioned above. If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees. If you’re providing the session yourself, you need to implement those guarantees as part of your protocol. In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.  \n  \n-   When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one. This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.  \n  \n-   When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O. This may mean doing nothing or may involve aborting a network connection or some other resource.  \n  \n On the receive side, your channel needs to:  \n  \n-   For each incoming message, the channel listener must detect the session it belongs to. If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>. Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.  \n  \n-   If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.  \n  \n-   When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one. This could result in exceptions if the channel receives a message while waiting for the close timeout to expire. That’s because the channel will be in the Closing state when it receives a message so it would throw.  \n  \n-   When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O. Again, this may mean doing nothing or may involve aborting a network connection or some other resource.  \n  \n## See also\n\n- [Channel Model Overview](../../../../docs/framework/wcf/extending/channel-model-overview.md)\n","nodes":[{"pos":[4,119],"embed":true,"restype":"x-metadata","content":"title: \"Choosing a Message Exchange Pattern\"\nms.date: \"03/30/2017\"\nms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146","nodes":[{"content":"Choosing a Message Exchange Pattern","nodes":[{"pos":[0,35],"content":"Choosing a Message Exchange Pattern","nodes":[{"content":"Choosing a Message Exchange Pattern","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[126,161],"content":"Choosing a Message Exchange Pattern","linkify":"Choosing a Message Exchange Pattern","nodes":[{"content":"Choosing a Message Exchange Pattern","pos":[0,35]}]},{"content":"The first step in writing a custom transport is to decide which <bpt id=\"p1\">*</bpt>message exchange patterns<ept id=\"p1\">*</ept> (or MEPs) are required for the channel you are developing.","pos":[162,312],"source":"The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing."},{"content":"This topic describes the options available and discusses the various requirements.","pos":[313,395]},{"content":"This is the first task in the channel development task list described in <bpt id=\"p1\">[</bpt>Developing Channels<ept id=\"p1\">](../../../../docs/framework/wcf/extending/developing-channels.md)</ept>.","pos":[396,556],"source":" This is the first task in the channel development task list described in [Developing Channels](../../../../docs/framework/wcf/extending/developing-channels.md)."},{"pos":[565,594],"content":"Six Message Exchange Patterns","linkify":"Six Message Exchange Patterns","nodes":[{"content":"Six Message Exchange Patterns","pos":[0,29]}]},{"content":"There are three MEPs to choose from:","pos":[598,634]},{"pos":[644,759],"content":"Datagram (<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IOutputChannel&gt;</ph>)","source":"Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)"},{"content":"When using a datagram MEP, a client sends a message using a <bpt id=\"p1\">*</bpt>fire and forget<ept id=\"p1\">*</ept> exchange.","pos":[770,857],"source":"When using a datagram MEP, a client sends a message using a *fire and forget* exchange."},{"content":"A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.","pos":[858,954]},{"content":"The message might be lost in transit and never reach the service.","pos":[955,1020]},{"content":"If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.","pos":[1021,1157]},{"content":"The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.","pos":[1158,1317]},{"content":"Client datagram channels implement the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IOutputChannel&gt;</ph> interface and service datagram channels implement the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> interface.","pos":[1318,1522],"source":" Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface."},{"pos":[1532,1656],"content":"Request-Response (<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IRequestChannel&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph>)","source":"Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)"},{"content":"In this MEP, a message is sent, and a reply is received.","pos":[1667,1723]},{"content":"The pattern consists of request-response pairs.","pos":[1724,1771]},{"content":"Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.","pos":[1772,1865]},{"content":"This pattern is also known as half-duplex.","pos":[1866,1908]},{"content":"In this MEP, client channels implement <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IRequestChannel&gt;</ph> and service channels implement <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph>.","pos":[1909,2081],"source":" In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>."},{"pos":[2091,2150],"content":"Duplex (<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexChannel&gt;</ph>)","source":"Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)"},{"content":"The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.","pos":[2161,2264]},{"content":"The duplex MEP is like a phone conversation, where each word being spoken is a message.","pos":[2265,2352]},{"content":"Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexChannel&gt;</ph>.","pos":[2353,2521],"source":" Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>."},{"content":"<bpt id=\"p1\">![</bpt>Choosing a message exchange pattern<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif \"</bpt>wcfc_BasicThreeMEPsc<ept id=\"p2\">\")</ept>","pos":[2528,2662],"source":"![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-basicthreemepsc.gif \"wcfc_BasicThreeMEPsc\")"},{"content":"The three basic message exchange patterns.","pos":[2665,2707]},{"content":"Top to bottom: datagram, request-response, and duplex.","pos":[2708,2762]},{"content":"Each of these MEPs can also support <bpt id=\"p1\">*</bpt>sessions<ept id=\"p1\">*</ept>.","pos":[2769,2816],"source":"Each of these MEPs can also support *sessions*."},{"content":"A session (and implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType&gt;</ph> of type <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType&gt;</ph>) correlates all messages sent and received on a channel.","pos":[2817,3073],"source":" A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel."},{"content":"The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.","pos":[3074,3181]},{"content":"In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.","pos":[3182,3334]},{"content":"This gives you a total of six MEPs to choose from:","pos":[3335,3385]},{"content":"Datagram","pos":[3395,3403]},{"content":"Request-response","pos":[3413,3429]},{"content":"Duplex","pos":[3439,3445]},{"content":"Datagram with sessions","pos":[3455,3477]},{"content":"Request-response with sessions","pos":[3487,3517]},{"content":"Duplex with sessions","pos":[3527,3547]},{"pos":[3555,3686],"content":"[!NOTE]\n For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.","leadings":["","> "],"nodes":[{"content":"For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.","pos":[9,129]}]},{"pos":[3695,3727],"content":"Sessions and Sessionful Channels","linkify":"Sessions and Sessionful Channels","nodes":[{"content":"Sessions and Sessionful Channels","pos":[0,32]}]},{"content":"In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).","pos":[3731,3864]},{"content":"WCF uses the term session to mean a connection-like logical abstraction.","pos":[3865,3937]},{"content":"Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.","pos":[3938,4095]},{"content":"In the channel object model, each logical session manifests as an instance of a sessionful channel.","pos":[4102,4201]},{"content":"Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.","pos":[4202,4335]},{"content":"The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.","pos":[4336,4472]},{"pos":[4479,4643],"content":"<bpt id=\"p1\">![</bpt>Choosing a message exchange pattern<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif \"</bpt>wcfc_SessionAndSessionlessChannelsc<ept id=\"p2\">\")</ept>","source":"![Choosing a message exchange pattern](../../../../docs/framework/wcf/extending/media/wcfc-sessionandsessionlesschannelsc.gif \"wcfc_SessionAndSessionlessChannelsc\")"},{"content":"A client creates a new sessionful channel and sends a message.","pos":[4650,4712]},{"content":"On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).","pos":[4713,4972]},{"content":"The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.","pos":[4973,5105]},{"content":"Another client (or the same client) creates a new sessionful and sends a message.","pos":[5112,5193]},{"content":"The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.","pos":[5194,5317]},{"content":"Without sessions, there is no correlation between channels and sessions.","pos":[5324,5396]},{"content":"Therefore a channel listener creates only one channel through which all received messages are delivered to the application.","pos":[5397,5520]},{"content":"There is also no message ordering because there is no session within which to maintain message order.","pos":[5521,5622]},{"content":"The top portion of the preceding graphic illustrates a sessionless message exchange.","pos":[5623,5707]},{"pos":[5716,5749],"content":"Starting and Terminating Sessions","linkify":"Starting and Terminating Sessions","nodes":[{"content":"Starting and Terminating Sessions","pos":[0,33]}]},{"content":"Sessions are started on the client by simply creating a new sessionful channel.","pos":[5753,5832]},{"content":"They are started on the service when the service receives a message that was sent in a new session.","pos":[5833,5932]},{"content":"Likewise, sessions are terminated by closing or aborting a sessionful channel.","pos":[5933,6011]},{"content":"The exception to this is <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.","pos":[6018,6201],"source":"The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern."},{"content":"It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.","pos":[6202,6564],"source":" It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages."},{"content":"In general, sessions are closed on the outgoing side and not on the incoming side.","pos":[6571,6653]},{"content":"That is, sessionful output channels can be closed, thereby cleanly terminating the session.","pos":[6654,6745]},{"content":"Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType&gt;</ph> on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph>.","pos":[6746,7029],"source":" Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>."},{"content":"However sessionful input channels should not be closed unless <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType&gt;</ph> on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> returns null, indicating that the session is already closed.","pos":[7036,7313],"source":"However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed."},{"content":"If <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType&gt;</ph> on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IDuplexSessionChannel&gt;</ph> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.","pos":[7314,7610],"source":" If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing."},{"content":"If a receiver wishes to terminate a session before the sender does, it should call <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> on the input channel, which abruptly terminates the session.","pos":[7611,7811],"source":" If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session."},{"pos":[7820,7847],"content":"Writing Sessionful Channels","linkify":"Writing Sessionful Channels","nodes":[{"content":"Writing Sessionful Channels","pos":[0,27]}]},{"content":"As a sessionful channel author, there are a few things your channel must do to provide sessions.","pos":[7851,7947]},{"content":"On the send side, your channel needs to:","pos":[7948,7988]},{"content":"For each new channel, create a new session and associate it with a new session id which is a unique string.","pos":[7998,8105]},{"content":"Or obtain a new session from the sessionful channel below you in the stack.","pos":[8106,8181]},{"content":"For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.","pos":[8191,8375]},{"content":"For protocol channels, this is typically done by adding a SOAP header.","pos":[8376,8446]},{"content":"For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.","pos":[8447,8587]},{"content":"For each message sent using this channel, you need to provide the delivery guarantees mentioned above.","pos":[8597,8699]},{"content":"If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.","pos":[8700,8823]},{"content":"If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.","pos":[8824,8930]},{"content":"In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.","pos":[8931,9124]},{"content":"When <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType&gt;</ph> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.","pos":[9134,9354],"source":"When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one."},{"content":"This can be as simple as calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Close%2A&gt;</ph> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.","pos":[9355,9581],"source":" This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection."},{"content":"When <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> is called on your channel, terminate the session abruptly without performing I/O.","pos":[9591,9734],"source":"When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O."},{"content":"This may mean doing nothing or may involve aborting a network connection or some other resource.","pos":[9735,9831]},{"content":"On the receive side, your channel needs to:","pos":[9838,9881]},{"content":"For each incoming message, the channel listener must detect the session it belongs to.","pos":[9891,9977]},{"content":"If this is the first message in the session, the channel listener must create a new channel and return it from the call to <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType&gt;</ph>.","pos":[9978,10204],"source":" If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>."},{"content":"Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.","pos":[10205,10344]},{"content":"If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.","pos":[10354,10549]},{"content":"When <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Close%2A&gt;</ph> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.","pos":[10559,10744],"source":"When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one."},{"content":"This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.","pos":[10745,10857]},{"content":"That’s because the channel will be in the Closing state when it receives a message so it would throw.","pos":[10858,10959]},{"content":"When <ph id=\"ph1\">&lt;xref:System.ServiceModel.ICommunicationObject.Abort%2A&gt;</ph> is called on your channel, terminate the session abruptly without performing I/O.","pos":[10969,11112],"source":"When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O."},{"content":"Again, this may mean doing nothing or may involve aborting a network connection or some other resource.","pos":[11113,11216]},{"pos":[11225,11233],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11237,11329],"content":"<bpt id=\"p1\">[</bpt>Channel Model Overview<ept id=\"p1\">](../../../../docs/framework/wcf/extending/channel-model-overview.md)</ept>","source":"[Channel Model Overview](../../../../docs/framework/wcf/extending/channel-model-overview.md)"}]}