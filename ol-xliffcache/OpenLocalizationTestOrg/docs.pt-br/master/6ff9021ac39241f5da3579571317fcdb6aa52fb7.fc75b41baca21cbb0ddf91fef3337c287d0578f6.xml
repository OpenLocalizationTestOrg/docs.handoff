{"content":"---\ntitle: \"Best Practices for Queued Communication | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"queues [WCF], best practices\"\n  - \"best practices [WCF], queued communication\"\nms.assetid: 446a6383-cae3-4338-b193-a33c14a49948\ncaps.latest.revision: 14\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Best Practices for Queued Communication\nThis topic provides recommended practices for queued communication in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]. The following sections discuss recommended practices from a scenario perspective.  \n  \n## Fast, Best-Effort Queued Messaging  \n For scenarios that require separation that queued messaging provides and fast, high-performance messaging with best-effort assurances, use a non-transactional queue and set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `false`.  \n  \n In addition, you can choose not to incur the cost of disk writes by setting the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property to `false`.  \n  \n Security has implications on performance. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Performance Considerations](../../../../docs/framework/wcf/feature-details/performance-considerations.md).  \n  \n## Reliable End-to-End Queued Messaging  \n The following sections describe recommended practices for scenarios that require end-to-end reliable messaging.  \n  \n### Basic Reliable Transfer  \n For end-to-end reliability, set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `true` to ensure transfer. The <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property can be set to `true` or `false` depending on your requirements (the default is `true`). Generally, the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property is set to `true` as part of end-to-end reliability. The compromise is a performance cost, but makes the message durable so that the message is not lost if a queue manager crashes.  \n  \n### Use of Transactions  \n You must use transactions to ensure end-to-end reliability. `ExactlyOnce` assurances only ensure that messages are delivered to the target queue. To ensure that the message is received, use transactions. Without transactions, if the service crashes, you lose the message that is being delivered but is actually delivered to the application.  \n  \n### Use of Dead-letter Queues  \n Dead-letter queues ensure that you are notified if a message fails to be delivered to the target queue. You can use the system-provided dead-letter queue or a custom dead-letter queue. In general, using a custom dead-letter queue is best because it enables you to send dead-letter messages from one application into a single dead-letter queue. Otherwise, all dead-letter messages that occur for all applications running on the system are delivered to a single queue. Each application must then search though the dead-letter queue to find the dead-letter messages that are relevant to that application. Sometimes, using a custom dead-letter queue is not feasible, such as when using MSMQ 3.0.  \n  \n Turning off dead-letter queues for end-to-end reliable communication is not recommended.  \n  \n [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Using Dead-Letter Queues to Handle Message Transfer Failures](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md).  \n  \n### Use of Poison-Message Handling  \n Poison-message handling provides the ability to recover from the failure to process messages.  \n  \n When using the poison-message handling feature, ensure that the <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> property is set to the appropriate value. Setting it to <xref:System.ServiceModel.ReceiveErrorHandling> means the data is lost. On the other hand, setting it to <xref:System.ServiceModel.ReceiveErrorHandling> faults the service host when it detects a poison message. Using MSMQ 3.0, <xref:System.ServiceModel.ReceiveErrorHandling> is the best option to avoid data loss and move the poison message out of the way. Using MSMQ 4.0, <xref:System.ServiceModel.ReceiveErrorHandling> is the recommended approach. <xref:System.ServiceModel.ReceiveErrorHandling> moves a poisoned message out of the queue so the service can continue to process new messages. The poison-message service can then process the poison message separately.  \n  \n [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md).  \n  \n## Achieving High Throughput  \n To achieve high throughput on a single endpoint, use the following:  \n  \n-   Transacted batching. Transacted batching ensures that many messages can be read in a single transaction. This optimizes transaction commits, increasing overall performance. The cost of batching is that if a failure occurs in a single message within a batch, then the entire batch is rolled back and the messages must be processed one at a time until it is safe to batch again. In most cases, poison messages are rare, so batching is the preferred way to increase system performance, particularly when you have other resource managers that participate in the transaction. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md).  \n  \n-   Concurrency. Concurrency increases throughput, but concurrency also affects contention to shared resources. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Concurrency](../../../../docs/framework/wcf/samples/concurrency.md).  \n  \n-   Throttling. For optimal performance, throttle the number of messages in the dispatcher pipeline. For an example of how to do this, see [Throttling](../../../../docs/framework/wcf/samples/throttling.md).  \n  \n When using batching, be aware that concurrency and throttling translate to concurrent batches.  \n  \n To achieve higher throughput and availability, use a farm of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services that read from the queue. This requires that all of these services expose the same contract on the same endpoint. The farm approach works best for applications that have high production rates of messages because it enables a number of services to all read from the same queue.  \n  \n When using farms, be aware that MSMQ 3.0 does not support remote transacted reads. MSMQ 4.0 does support remote transacted reads.  \n  \n [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md) and [Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md).  \n  \n## Queuing with Unit of Work Semantics  \n In some scenarios a group of messages in a queue may be related and, therefore, the ordering of these messages is significant. In such scenarios, process a group of related messages together as a single unit: either all of the messages are processed successfully or none are. To implement such behavior, use sessions with queues.  \n  \n [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Grouping Queued Messages in a Session](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md).  \n  \n## Correlating Request-Reply Messages  \n Though queues are typically one-way, in some scenarios you may want to correlate a reply received to a request sent earlier. If you require such correlation, it is recommended that you apply your own SOAP message header that contains correlation information with the message. Typically, the sender attaches this header with the message, and the receiver, upon processing the message and replying back with a new message on a reply queue, attaches the sender's message header that contains the correlation information so that the sender can identify the reply message with the request message.  \n  \n## Integrating with Non-WCF Applications  \n Use `MsmqIntegrationBinding` when integrating [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services or clients with non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services or clients. The non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] application can be an MSMQ application written using System.Messaging, COM+, [!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)], or C++.  \n  \n When using `MsmqIntegrationBinding`, be aware of the following:  \n  \n-   A [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message body is not the same as a MSMQ message body. When sending a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message using a queued binding, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message body is placed inside of a MSMQ message. The MSMQ infrastructure is oblivious to this extra information; it sees only the MSMQ message.  \n  \n-   `MsmqIntegrationBinding` supports popular serialization types. Based on the serialization type, the body type of the generic message, <xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>, takes different type parameters. For example, <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat> requires `MsmqMessage\\<byte[]>` and <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat> requires `MsmqMessage<Stream>`.  \n  \n-   With XML serialization, you can specify the known type using the `KnownTypes` attribute on the [\\<behavior>](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) element that is then used to determine how to deserialize the XML message.  \n  \n## See Also  \n [Queuing in WCF](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)   \n [How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)   \n [How to: Exchange Messages with WCF Endpoints and Message Queuing Applications](../../../../docs/framework/wcf/feature-details/how-to-exchange-messages-with-wcf-endpoints-and-message-queuing-applications.md)   \n [Grouping Queued Messages in a Session](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md)   \n [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)   \n [Using Dead-Letter Queues to Handle Message Transfer Failures](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)   \n [Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)   \n [Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)   \n [Securing Messages Using Transport Security](../../../../docs/framework/wcf/feature-details/securing-messages-using-transport-security.md)   \n [Securing Messages Using Message Security](../../../../docs/framework/wcf/feature-details/securing-messages-using-message-security.md)   \n [Troubleshooting Queued Messaging](../../../../docs/framework/wcf/feature-details/troubleshooting-queued-messaging.md)","nodes":[{"pos":[4,466],"embed":true,"restype":"x-metadata","content":"title: \"Best Practices for Queued Communication | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"queues [WCF], best practices\"\n  - \"best practices [WCF], queued communication\"\nms.assetid: 446a6383-cae3-4338-b193-a33c14a49948\ncaps.latest.revision: 14\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"","nodes":[{"content":"Best Practices for Queued Communication | Microsoft Docs","nodes":[{"pos":[0,56],"content":"Best Practices for Queued Communication | Microsoft Docs","nodes":[{"content":"Best Practices for Queued Communication | Microsoft Docs","pos":[0,56]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[473,512],"content":"Best Practices for Queued Communication","linkify":"Best Practices for Queued Communication","nodes":[{"content":"Best Practices for Queued Communication","pos":[0,39]}]},{"content":"This topic provides recommended practices for queued communication in <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph>.","pos":[513,639],"source":"This topic provides recommended practices for queued communication in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]."},{"content":"The following sections discuss recommended practices from a scenario perspective.","pos":[640,721]},{"pos":[730,764],"content":"Fast, Best-Effort Queued Messaging","linkify":"Fast, Best-Effort Queued Messaging","nodes":[{"content":"Fast, Best-Effort Queued Messaging","pos":[0,34]}]},{"pos":[768,1023],"content":"For scenarios that require separation that queued messaging provides and fast, high-performance messaging with best-effort assurances, use a non-transactional queue and set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","source":"For scenarios that require separation that queued messaging provides and fast, high-performance messaging with best-effort assurances, use a non-transactional queue and set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `false`."},{"pos":[1030,1184],"content":"In addition, you can choose not to incur the cost of disk writes by setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqBindingBase.Durable%2A&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","source":"In addition, you can choose not to incur the cost of disk writes by setting the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property to `false`."},{"content":"Security has implications on performance.","pos":[1191,1232]},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Performance Considerations<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/performance-considerations.md)</ept>.","pos":[1233,1399],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Performance Considerations](../../../../docs/framework/wcf/feature-details/performance-considerations.md)."},{"pos":[1408,1444],"content":"Reliable End-to-End Queued Messaging","linkify":"Reliable End-to-End Queued Messaging","nodes":[{"content":"Reliable End-to-End Queued Messaging","pos":[0,36]}]},{"content":"The following sections describe recommended practices for scenarios that require end-to-end reliable messaging.","pos":[1448,1559]},{"pos":[1569,1592],"content":"Basic Reliable Transfer","linkify":"Basic Reliable Transfer","nodes":[{"content":"Basic Reliable Transfer","pos":[0,23]}]},{"content":"For end-to-end reliability, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A&gt;</ph> property to <ph id=\"ph2\">`true`</ph> to ensure transfer.","pos":[1596,1728],"source":"For end-to-end reliability, set the <xref:System.ServiceModel.MsmqBindingBase.ExactlyOnce%2A> property to `true` to ensure transfer."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqBindingBase.Durable%2A&gt;</ph> property can be set to <ph id=\"ph2\">`true`</ph> or <ph id=\"ph3\">`false`</ph> depending on your requirements (the default is <ph id=\"ph4\">`true`</ph>).","pos":[1729,1883],"source":" The <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property can be set to `true` or `false` depending on your requirements (the default is `true`)."},{"content":"Generally, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqBindingBase.Durable%2A&gt;</ph> property is set to <ph id=\"ph2\">`true`</ph> as part of end-to-end reliability.","pos":[1884,2013],"source":" Generally, the <xref:System.ServiceModel.MsmqBindingBase.Durable%2A> property is set to `true` as part of end-to-end reliability."},{"content":"The compromise is a performance cost, but makes the message durable so that the message is not lost if a queue manager crashes.","pos":[2014,2141]},{"pos":[2151,2170],"content":"Use of Transactions","linkify":"Use of Transactions","nodes":[{"content":"Use of Transactions","pos":[0,19]}]},{"content":"You must use transactions to ensure end-to-end reliability.","pos":[2174,2233]},{"content":"<ph id=\"ph1\">`ExactlyOnce`</ph> assurances only ensure that messages are delivered to the target queue.","pos":[2234,2319],"source":"`ExactlyOnce` assurances only ensure that messages are delivered to the target queue."},{"content":"To ensure that the message is received, use transactions.","pos":[2320,2377]},{"content":"Without transactions, if the service crashes, you lose the message that is being delivered but is actually delivered to the application.","pos":[2378,2514]},{"pos":[2524,2549],"content":"Use of Dead-letter Queues","linkify":"Use of Dead-letter Queues","nodes":[{"content":"Use of Dead-letter Queues","pos":[0,25]}]},{"content":"Dead-letter queues ensure that you are notified if a message fails to be delivered to the target queue.","pos":[2553,2656]},{"content":"You can use the system-provided dead-letter queue or a custom dead-letter queue.","pos":[2657,2737]},{"content":"In general, using a custom dead-letter queue is best because it enables you to send dead-letter messages from one application into a single dead-letter queue.","pos":[2738,2896]},{"content":"Otherwise, all dead-letter messages that occur for all applications running on the system are delivered to a single queue.","pos":[2897,3019]},{"content":"Each application must then search though the dead-letter queue to find the dead-letter messages that are relevant to that application.","pos":[3020,3154]},{"content":"Sometimes, using a custom dead-letter queue is not feasible, such as when using MSMQ 3.0.","pos":[3155,3244]},{"content":"Turning off dead-letter queues for end-to-end reliable communication is not recommended.","pos":[3251,3339]},{"pos":[3406,3581],"content":"<bpt id=\"p1\">[</bpt>Using Dead-Letter Queues to Handle Message Transfer Failures<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)</ept>.","source":"[Using Dead-Letter Queues to Handle Message Transfer Failures](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)."},{"pos":[3591,3621],"content":"Use of Poison-Message Handling","linkify":"Use of Poison-Message Handling","nodes":[{"content":"Use of Poison-Message Handling","pos":[0,30]}]},{"content":"Poison-message handling provides the ability to recover from the failure to process messages.","pos":[3625,3718]},{"content":"When using the poison-message handling feature, ensure that the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A&gt;</ph> property is set to the appropriate value.","pos":[3725,3897],"source":"When using the poison-message handling feature, ensure that the <xref:System.ServiceModel.MsmqBindingBase.ReceiveErrorHandling%2A> property is set to the appropriate value."},{"content":"Setting it to <ph id=\"ph1\">&lt;xref:System.ServiceModel.ReceiveErrorHandling&gt;</ph> means the data is lost.","pos":[3898,3983],"source":" Setting it to <xref:System.ServiceModel.ReceiveErrorHandling> means the data is lost."},{"content":"On the other hand, setting it to <ph id=\"ph1\">&lt;xref:System.ServiceModel.ReceiveErrorHandling&gt;</ph> faults the service host when it detects a poison message.","pos":[3984,4122],"source":" On the other hand, setting it to <xref:System.ServiceModel.ReceiveErrorHandling> faults the service host when it detects a poison message."},{"content":"Using MSMQ 3.0, <ph id=\"ph1\">&lt;xref:System.ServiceModel.ReceiveErrorHandling&gt;</ph> is the best option to avoid data loss and move the poison message out of the way.","pos":[4123,4268],"source":" Using MSMQ 3.0, <xref:System.ServiceModel.ReceiveErrorHandling> is the best option to avoid data loss and move the poison message out of the way."},{"content":"Using MSMQ 4.0, <ph id=\"ph1\">&lt;xref:System.ServiceModel.ReceiveErrorHandling&gt;</ph> is the recommended approach.","pos":[4269,4361],"source":" Using MSMQ 4.0, <xref:System.ServiceModel.ReceiveErrorHandling> is the recommended approach."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.ReceiveErrorHandling&gt;</ph> moves a poisoned message out of the queue so the service can continue to process new messages.","pos":[4362,4504],"source":" <xref:System.ServiceModel.ReceiveErrorHandling> moves a poisoned message out of the queue so the service can continue to process new messages."},{"content":"The poison-message service can then process the poison message separately.","pos":[4505,4579]},{"pos":[4646,4747],"content":"<bpt id=\"p1\">[</bpt>Poison Message Handling<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)</ept>.","source":"[Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)."},{"pos":[4756,4781],"content":"Achieving High Throughput","linkify":"Achieving High Throughput","nodes":[{"content":"Achieving High Throughput","pos":[0,25]}]},{"content":"To achieve high throughput on a single endpoint, use the following:","pos":[4785,4852]},{"content":"Transacted batching.","pos":[4862,4882]},{"content":"Transacted batching ensures that many messages can be read in a single transaction.","pos":[4883,4966]},{"content":"This optimizes transaction commits, increasing overall performance.","pos":[4967,5034]},{"content":"The cost of batching is that if a failure occurs in a single message within a batch, then the entire batch is rolled back and the messages must be processed one at a time until it is safe to batch again.","pos":[5035,5238]},{"content":"In most cases, poison messages are rare, so batching is the preferred way to increase system performance, particularly when you have other resource managers that participate in the transaction.","pos":[5239,5432]},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Batching Messages in a Transaction<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</ept>.","pos":[5433,5615],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)."},{"content":"Concurrency.","pos":[5625,5637]},{"content":"Concurrency increases throughput, but concurrency also affects contention to shared resources.","pos":[5638,5732]},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Concurrency<ept id=\"p1\">](../../../../docs/framework/wcf/samples/concurrency.md)</ept>.","pos":[5733,5861],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Concurrency](../../../../docs/framework/wcf/samples/concurrency.md)."},{"content":"Throttling.","pos":[5871,5882]},{"content":"For optimal performance, throttle the number of messages in the dispatcher pipeline.","pos":[5883,5967]},{"content":"For an example of how to do this, see <bpt id=\"p1\">[</bpt>Throttling<ept id=\"p1\">](../../../../docs/framework/wcf/samples/throttling.md)</ept>.","pos":[5968,6073],"source":" For an example of how to do this, see [Throttling](../../../../docs/framework/wcf/samples/throttling.md)."},{"content":"When using batching, be aware that concurrency and throttling translate to concurrent batches.","pos":[6080,6174]},{"content":"To achieve higher throughput and availability, use a farm of <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services that read from the queue.","pos":[6181,6332],"source":"To achieve higher throughput and availability, use a farm of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services that read from the queue."},{"content":"This requires that all of these services expose the same contract on the same endpoint.","pos":[6333,6420]},{"content":"The farm approach works best for applications that have high production rates of messages because it enables a number of services to all read from the same queue.","pos":[6421,6583]},{"content":"When using farms, be aware that MSMQ 3.0 does not support remote transacted reads.","pos":[6590,6672]},{"content":"MSMQ 4.0 does support remote transacted reads.","pos":[6673,6719]},{"pos":[6786,7098],"content":"<bpt id=\"p1\">[</bpt>Batching Messages in a Transaction<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</ept> and <bpt id=\"p2\">[</bpt>Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP<ept id=\"p2\">](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)</ept>.","source":"[Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md) and [Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)."},{"pos":[7107,7142],"content":"Queuing with Unit of Work Semantics","linkify":"Queuing with Unit of Work Semantics","nodes":[{"content":"Queuing with Unit of Work Semantics","pos":[0,35]}]},{"content":"In some scenarios a group of messages in a queue may be related and, therefore, the ordering of these messages is significant.","pos":[7146,7272]},{"content":"In such scenarios, process a group of related messages together as a single unit: either all of the messages are processed successfully or none are.","pos":[7273,7421]},{"content":"To implement such behavior, use sessions with queues.","pos":[7422,7475]},{"pos":[7542,7671],"content":"<bpt id=\"p1\">[</bpt>Grouping Queued Messages in a Session<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md)</ept>.","source":"[Grouping Queued Messages in a Session](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md)."},{"pos":[7680,7714],"content":"Correlating Request-Reply Messages","linkify":"Correlating Request-Reply Messages","nodes":[{"content":"Correlating Request-Reply Messages","pos":[0,34]}]},{"content":"Though queues are typically one-way, in some scenarios you may want to correlate a reply received to a request sent earlier.","pos":[7718,7842]},{"content":"If you require such correlation, it is recommended that you apply your own SOAP message header that contains correlation information with the message.","pos":[7843,7993]},{"content":"Typically, the sender attaches this header with the message, and the receiver, upon processing the message and replying back with a new message on a reply queue, attaches the sender's message header that contains the correlation information so that the sender can identify the reply message with the request message.","pos":[7994,8310]},{"pos":[8319,8356],"content":"Integrating with Non-WCF Applications","linkify":"Integrating with Non-WCF Applications","nodes":[{"content":"Integrating with Non-WCF Applications","pos":[0,37]}]},{"content":"Use <ph id=\"ph1\">`MsmqIntegrationBinding`</ph> when integrating <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services or clients with non-<ph id=\"ph3\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> services or clients.","pos":[8360,8567],"source":"Use `MsmqIntegrationBinding` when integrating [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services or clients with non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services or clients."},{"content":"The non-<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> application can be an MSMQ application written using System.Messaging, COM+, <ph id=\"ph2\">[!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)]</ph>, or C++.","pos":[8568,8771],"source":" The non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] application can be an MSMQ application written using System.Messaging, COM+, [!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)], or C++."},{"pos":[8778,8841],"content":"When using <ph id=\"ph1\">`MsmqIntegrationBinding`</ph>, be aware of the following:","source":"When using `MsmqIntegrationBinding`, be aware of the following:"},{"content":"A <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> message body is not the same as a MSMQ message body.","pos":[8851,8961],"source":"A [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message body is not the same as a MSMQ message body."},{"content":"When sending a <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> message using a queued binding, the <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> message body is placed inside of a MSMQ message.","pos":[8962,9173],"source":" When sending a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message using a queued binding, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message body is placed inside of a MSMQ message."},{"content":"The MSMQ infrastructure is oblivious to this extra information; it sees only the MSMQ message.","pos":[9174,9268]},{"content":"<ph id=\"ph1\">`MsmqIntegrationBinding`</ph> supports popular serialization types.","pos":[9278,9340],"source":"`MsmqIntegrationBinding` supports popular serialization types."},{"content":"Based on the serialization type, the body type of the generic message, <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601&gt;</ph>, takes different type parameters.","pos":[9341,9504],"source":" Based on the serialization type, the body type of the generic message, <xref:System.ServiceModel.MsmqIntegration.MsmqMessage%601>, takes different type parameters."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat&gt;</ph> requires <ph id=\"ph2\">`MsmqMessage\\&lt;byte[]&gt;`</ph> and <ph id=\"ph3\">&lt;xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat&gt;</ph> requires <ph id=\"ph4\">`MsmqMessage&lt;Stream&gt;`</ph>.","pos":[9505,9733],"source":" For example, <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat> requires `MsmqMessage\\<byte[]>` and <xref:System.ServiceModel.MsmqIntegration.MsmqMessageSerializationFormat> requires `MsmqMessage<Stream>`."},{"pos":[9743,10017],"content":"With XML serialization, you can specify the known type using the <ph id=\"ph1\">`KnownTypes`</ph> attribute on the <bpt id=\"p1\">[</bpt><ph id=\"ph2\">\\&lt;</ph>behavior&gt;<ept id=\"p1\">](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md)</ept> element that is then used to determine how to deserialize the XML message.","source":"With XML serialization, you can specify the known type using the `KnownTypes` attribute on the [\\<behavior>](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-servicebehaviors.md) element that is then used to determine how to deserialize the XML message."},{"pos":[10026,10034],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Queuing in WCF<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)</ept><ph id=\"ph1\"> </ph>","pos":[10038,10121],"source":"[Queuing in WCF](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Exchange Queued Messages with WCF Endpoints<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md)</ept><ph id=\"ph1\"> </ph>","pos":[10125,10281],"source":"[How to: Exchange Queued Messages with WCF Endpoints](../../../../docs/framework/wcf/feature-details/how-to-exchange-queued-messages-with-wcf-endpoints.md) "},{"content":"<bpt id=\"p1\">[</bpt>How to: Exchange Messages with WCF Endpoints and Message Queuing Applications<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/how-to-exchange-messages-with-wcf-endpoints-and-message-queuing-applications.md)</ept><ph id=\"ph1\"> </ph>","pos":[10285,10493],"source":"[How to: Exchange Messages with WCF Endpoints and Message Queuing Applications](../../../../docs/framework/wcf/feature-details/how-to-exchange-messages-with-wcf-endpoints-and-message-queuing-applications.md) "},{"content":"<bpt id=\"p1\">[</bpt>Grouping Queued Messages in a Session<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md)</ept><ph id=\"ph1\"> </ph>","pos":[10497,10626],"source":"[Grouping Queued Messages in a Session](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md) "},{"content":"<bpt id=\"p1\">[</bpt>Batching Messages in a Transaction<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</ept><ph id=\"ph1\"> </ph>","pos":[10630,10753],"source":"[Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md) "},{"content":"<bpt id=\"p1\">[</bpt>Using Dead-Letter Queues to Handle Message Transfer Failures<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)</ept><ph id=\"ph1\"> </ph>","pos":[10757,10932],"source":"[Using Dead-Letter Queues to Handle Message Transfer Failures](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md) "},{"content":"<bpt id=\"p1\">[</bpt>Poison Message Handling<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)</ept><ph id=\"ph1\"> </ph>","pos":[10936,11037],"source":"[Poison Message Handling](../../../../docs/framework/wcf/feature-details/poison-message-handling.md) "},{"content":"<bpt id=\"p1\">[</bpt>Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)</ept><ph id=\"ph1\"> </ph>","pos":[11041,11226],"source":"[Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md) "},{"content":"<bpt id=\"p1\">[</bpt>Securing Messages Using Transport Security<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/securing-messages-using-transport-security.md)</ept><ph id=\"ph1\"> </ph>","pos":[11230,11369],"source":"[Securing Messages Using Transport Security](../../../../docs/framework/wcf/feature-details/securing-messages-using-transport-security.md) "},{"content":"<bpt id=\"p1\">[</bpt>Securing Messages Using Message Security<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/securing-messages-using-message-security.md)</ept><ph id=\"ph1\"> </ph>","pos":[11373,11508],"source":"[Securing Messages Using Message Security](../../../../docs/framework/wcf/feature-details/securing-messages-using-message-security.md) "},{"content":"<bpt id=\"p1\">[</bpt>Troubleshooting Queued Messaging<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/troubleshooting-queued-messaging.md)</ept>","pos":[11512,11630],"source":"[Troubleshooting Queued Messaging](../../../../docs/framework/wcf/feature-details/troubleshooting-queued-messaging.md)"}]}