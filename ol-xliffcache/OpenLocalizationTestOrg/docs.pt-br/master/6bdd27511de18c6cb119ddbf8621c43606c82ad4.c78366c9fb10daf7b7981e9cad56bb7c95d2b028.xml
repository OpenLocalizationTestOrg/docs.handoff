{"content":"---\ntitle: \"Assembly Names\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"names [.NET Framework], assemblies\"\n  - \"assemblies [.NET Framework], names\"\nms.assetid: 8f8c2c90-f15d-400e-87e7-a757e4f04d0e\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Assembly Names\nAn assembly's name is stored in metadata and has a significant impact on the assembly's scope and use by an application. A strong-named assembly has a fully qualified name that includes the assembly's name, culture, public key, and version number. This is frequently referred to as the display name, and for loaded assemblies can be obtained by using the <xref:System.Reflection.Assembly.FullName%2A> property.  \n  \n The runtime uses this information to locate the assembly and differentiate it from other assemblies with the same name. For example, a strong-named assembly called `myTypes` could have the following fully qualified name:  \n  \n```  \nmyTypes, Version=1.0.1234.0, Culture=en-US, PublicKeyToken=b77a5c561934e089c, ProcessorArchitecture=msil  \n```  \n  \n> [!NOTE]\n>  Processor architecture is added to the assembly identity in the .NET Framework version 2.0, to allow processor-specific versions of assemblies. You can create versions of an assembly whose identity differs only by processor architecture, for example 32-bit and 64-bit processor-specific versions. Processor architecture is not required for strong names. For more information, see <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  \n  \n In this example, the fully qualified name indicates that the `myTypes` assembly has a strong name with a public key token, has the culture value for US English, and has a version number of 1.0.1234.0. Its processor architecture is \"msil\", which means that it will be just-in-time (JIT)-compiled to 32-bit code or 64-bit code depending on the operating system and processor.  \n  \n Code that requests types in an assembly must use a fully qualified assembly name. This is called fully qualified binding. Partial binding, which specifies only an assembly name, is not permitted when referencing assemblies in the .NET Framework.  \n  \n All assembly references to assemblies that make up the .NET Framework also must contain a fully qualified name of the assembly. For example, to reference the System.Data .NET Framework assembly for version 1.0 would include:  \n  \n```  \nSystem.data, version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089  \n```  \n  \n Note that the version corresponds to the version number of all .NET Framework assemblies that shipped with .NET Framework version 1.0. For .NET Framework assemblies, the culture value is always neutral, and the public key is the same as shown in the above example.  \n  \n For example, to add an assembly reference in a configuration file to set up a trace listener, you would include the fully qualified name of the system .NET Framework assembly:  \n  \n```xml  \n<add name=\"myListener\" type=\"System.Diagnostics.TextWriterTraceListener, System, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\" initializeData=\"c:\\myListener.log\" />  \n```  \n  \n> [!NOTE]\n>  The runtime treats assembly names as case-insensitive when binding to an assembly, but preserves whatever case is used in an assembly name. Several tools in the [!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)] handle assembly names as case-sensitive. For best results, manage assembly names as though they were case-sensitive.  \n  \n## Naming Application Components  \n The runtime does not consider the file name when determining an assembly's identity. The assembly identity, which consists of the assembly name, version, culture, and strong name, must be clear to the runtime.  \n  \n For example, if you have an assembly called myAssembly.exe that references an assembly called myAssembly.dll, binding occurs correctly if you execute myAssembly.exe. However, if another application executes myAssembly.exe using the method <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType>, the runtime determines that \"myAssembly\" is already loaded when myAssembly.exe requests binding to \"myAssembly.\" In this case, myAssembly.dll is never loaded. Because myAssembly.exe does not contain the requested type, a <xref:System.TypeLoadException> occurs.  \n  \n To avoid this problem, make sure the assemblies that make up your application do not have the same assembly name or place assemblies with the same name in different directories.  \n  \n> [!NOTE]\n>  If you put a strong-named assembly in the global assembly cache, the assembly's file name must match the assembly name (not including the file name extension, such as .exe or .dll). For example, if the file name of an assembly is myAssembly.dll, the assembly name must be myAssembly. Private assemblies deployed only in the root application directory can have an assembly name that is different from the file name.  \n  \n## See also\n\n- [How to: Determine an Assembly's Fully Qualified Name](../../../docs/framework/app-domains/how-to-determine-assembly-fully-qualified-name.md)\n- [Creating Assemblies](../../../docs/framework/app-domains/create-assemblies.md)\n- [Strong-Named Assemblies](../../../docs/framework/app-domains/strong-named-assemblies.md)\n- [Global Assembly Cache](../../../docs/framework/app-domains/gac.md)\n- [How the Runtime Locates Assemblies](../../../docs/framework/deployment/how-the-runtime-locates-assemblies.md)\n- [Programming with Assemblies](../../../docs/framework/app-domains/programming-with-assemblies.md)\n","nodes":[{"pos":[4,242],"embed":true,"restype":"x-metadata","content":"title: \"Assembly Names\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"names [.NET Framework], assemblies\"\n  - \"assemblies [.NET Framework], names\"\nms.assetid: 8f8c2c90-f15d-400e-87e7-a757e4f04d0e\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Assembly Names","nodes":[{"pos":[0,14],"content":"Assembly Names","nodes":[{"content":"Assembly Names","pos":[0,14]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[249,263],"content":"Assembly Names","linkify":"Assembly Names","nodes":[{"content":"Assembly Names","pos":[0,14]}]},{"content":"An assembly's name is stored in metadata and has a significant impact on the assembly's scope and use by an application.","pos":[264,384]},{"content":"A strong-named assembly has a fully qualified name that includes the assembly's name, culture, public key, and version number.","pos":[385,511]},{"content":"This is frequently referred to as the display name, and for loaded assemblies can be obtained by using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.FullName%2A&gt;</ph> property.","pos":[512,674],"source":" This is frequently referred to as the display name, and for loaded assemblies can be obtained by using the <xref:System.Reflection.Assembly.FullName%2A> property."},{"content":"The runtime uses this information to locate the assembly and differentiate it from other assemblies with the same name.","pos":[681,800]},{"content":"For example, a strong-named assembly called <ph id=\"ph1\">`myTypes`</ph> could have the following fully qualified name:","pos":[801,901],"source":" For example, a strong-named assembly called `myTypes` could have the following fully qualified name:"},{"pos":[1031,1514],"content":"[!NOTE]\n Processor architecture is added to the assembly identity in the .NET Framework version 2.0, to allow processor-specific versions of assemblies. You can create versions of an assembly whose identity differs only by processor architecture, for example 32-bit and 64-bit processor-specific versions. Processor architecture is not required for strong names. For more information, see <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.","leadings":["","> "],"nodes":[{"content":"Processor architecture is added to the assembly identity in the .NET Framework version 2.0, to allow processor-specific versions of assemblies. You can create versions of an assembly whose identity differs only by processor architecture, for example 32-bit and 64-bit processor-specific versions. Processor architecture is not required for strong names. For more information, see <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.","pos":[9,481],"nodes":[{"content":"Processor architecture is added to the assembly identity in the .NET Framework version 2.0, to allow processor-specific versions of assemblies.","pos":[0,143]},{"content":"You can create versions of an assembly whose identity differs only by processor architecture, for example 32-bit and 64-bit processor-specific versions.","pos":[144,296]},{"content":"Processor architecture is not required for strong names.","pos":[297,353]},{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.","pos":[354,472],"source":" For more information, see <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>."}]}]},{"content":"In this example, the fully qualified name indicates that the <ph id=\"ph1\">`myTypes`</ph> assembly has a strong name with a public key token, has the culture value for US English, and has a version number of 1.0.1234.0.","pos":[1521,1721],"source":"In this example, the fully qualified name indicates that the `myTypes` assembly has a strong name with a public key token, has the culture value for US English, and has a version number of 1.0.1234.0."},{"content":"Its processor architecture is \"msil\", which means that it will be just-in-time (JIT)-compiled to 32-bit code or 64-bit code depending on the operating system and processor.","pos":[1722,1894]},{"content":"Code that requests types in an assembly must use a fully qualified assembly name.","pos":[1901,1982]},{"content":"This is called fully qualified binding.","pos":[1983,2022]},{"content":"Partial binding, which specifies only an assembly name, is not permitted when referencing assemblies in the .NET Framework.","pos":[2023,2146]},{"content":"All assembly references to assemblies that make up the .NET Framework also must contain a fully qualified name of the assembly.","pos":[2153,2280]},{"content":"For example, to reference the System.Data .NET Framework assembly for version 1.0 would include:","pos":[2281,2377]},{"content":"Note that the version corresponds to the version number of all .NET Framework assemblies that shipped with .NET Framework version 1.0.","pos":[2483,2617]},{"content":"For .NET Framework assemblies, the culture value is always neutral, and the public key is the same as shown in the above example.","pos":[2618,2747]},{"content":"For example, to add an assembly reference in a configuration file to set up a trace listener, you would include the fully qualified name of the system .NET Framework assembly:","pos":[2754,2929]},{"pos":[3146,3493],"content":"[!NOTE]\n The runtime treats assembly names as case-insensitive when binding to an assembly, but preserves whatever case is used in an assembly name. Several tools in the [!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)] handle assembly names as case-sensitive. For best results, manage assembly names as though they were case-sensitive.","leadings":["","> "],"nodes":[{"content":"The runtime treats assembly names as case-insensitive when binding to an assembly, but preserves whatever case is used in an assembly name. Several tools in the [!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)] handle assembly names as case-sensitive. For best results, manage assembly names as though they were case-sensitive.","pos":[9,345],"nodes":[{"content":"The runtime treats assembly names as case-insensitive when binding to an assembly, but preserves whatever case is used in an assembly name.","pos":[0,139]},{"content":"Several tools in the <ph id=\"ph1\">[!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)]</ph> handle assembly names as case-sensitive.","pos":[140,260],"source":" Several tools in the [!INCLUDE[winsdklong](../../../includes/winsdklong-md.md)] handle assembly names as case-sensitive."},{"content":"For best results, manage assembly names as though they were case-sensitive.","pos":[261,336]}]}]},{"pos":[3502,3531],"content":"Naming Application Components","linkify":"Naming Application Components","nodes":[{"content":"Naming Application Components","pos":[0,29]}]},{"content":"The runtime does not consider the file name when determining an assembly's identity.","pos":[3535,3619]},{"content":"The assembly identity, which consists of the assembly name, version, culture, and strong name, must be clear to the runtime.","pos":[3620,3744]},{"content":"For example, if you have an assembly called myAssembly.exe that references an assembly called myAssembly.dll, binding occurs correctly if you execute myAssembly.exe.","pos":[3751,3916]},{"content":"However, if another application executes myAssembly.exe using the method <ph id=\"ph1\">&lt;xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType&gt;</ph>, the runtime determines that \"myAssembly\" is already loaded when myAssembly.exe requests binding to \"myAssembly.\"","pos":[3917,4175],"source":" However, if another application executes myAssembly.exe using the method <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType>, the runtime determines that \"myAssembly\" is already loaded when myAssembly.exe requests binding to \"myAssembly.\""},{"content":"In this case, myAssembly.dll is never loaded.","pos":[4176,4221]},{"content":"Because myAssembly.exe does not contain the requested type, a <ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> occurs.","pos":[4222,4323],"source":" Because myAssembly.exe does not contain the requested type, a <xref:System.TypeLoadException> occurs."},{"content":"To avoid this problem, make sure the assemblies that make up your application do not have the same assembly name or place assemblies with the same name in different directories.","pos":[4330,4507]},{"pos":[4515,4940],"content":"[!NOTE]\n If you put a strong-named assembly in the global assembly cache, the assembly's file name must match the assembly name (not including the file name extension, such as .exe or .dll). For example, if the file name of an assembly is myAssembly.dll, the assembly name must be myAssembly. Private assemblies deployed only in the root application directory can have an assembly name that is different from the file name.","leadings":["","> "],"nodes":[{"content":"If you put a strong-named assembly in the global assembly cache, the assembly's file name must match the assembly name (not including the file name extension, such as .exe or .dll). For example, if the file name of an assembly is myAssembly.dll, the assembly name must be myAssembly. Private assemblies deployed only in the root application directory can have an assembly name that is different from the file name.","pos":[9,423],"nodes":[{"content":"If you put a strong-named assembly in the global assembly cache, the assembly's file name must match the assembly name (not including the file name extension, such as .exe or .dll).","pos":[0,181]},{"content":"For example, if the file name of an assembly is myAssembly.dll, the assembly name must be myAssembly.","pos":[182,283]},{"content":"Private assemblies deployed only in the root application directory can have an assembly name that is different from the file name.","pos":[284,414]}]}]},{"pos":[4949,4957],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4961,5102],"content":"<bpt id=\"p1\">[</bpt>How to: Determine an Assembly's Fully Qualified Name<ept id=\"p1\">](../../../docs/framework/app-domains/how-to-determine-assembly-fully-qualified-name.md)</ept>","source":"[How to: Determine an Assembly's Fully Qualified Name](../../../docs/framework/app-domains/how-to-determine-assembly-fully-qualified-name.md)"},{"pos":[5105,5184],"content":"<bpt id=\"p1\">[</bpt>Creating Assemblies<ept id=\"p1\">](../../../docs/framework/app-domains/create-assemblies.md)</ept>","source":"[Creating Assemblies](../../../docs/framework/app-domains/create-assemblies.md)"},{"pos":[5187,5276],"content":"<bpt id=\"p1\">[</bpt>Strong-Named Assemblies<ept id=\"p1\">](../../../docs/framework/app-domains/strong-named-assemblies.md)</ept>","source":"[Strong-Named Assemblies](../../../docs/framework/app-domains/strong-named-assemblies.md)"},{"pos":[5279,5346],"content":"<bpt id=\"p1\">[</bpt>Global Assembly Cache<ept id=\"p1\">](../../../docs/framework/app-domains/gac.md)</ept>","source":"[Global Assembly Cache](../../../docs/framework/app-domains/gac.md)"},{"pos":[5349,5459],"content":"<bpt id=\"p1\">[</bpt>How the Runtime Locates Assemblies<ept id=\"p1\">](../../../docs/framework/deployment/how-the-runtime-locates-assemblies.md)</ept>","source":"[How the Runtime Locates Assemblies](../../../docs/framework/deployment/how-the-runtime-locates-assemblies.md)"},{"pos":[5462,5559],"content":"<bpt id=\"p1\">[</bpt>Programming with Assemblies<ept id=\"p1\">](../../../docs/framework/app-domains/programming-with-assemblies.md)</ept>","source":"[Programming with Assemblies](../../../docs/framework/app-domains/programming-with-assemblies.md)"}]}