{"content":"---\ntitle: \"WIF Session Management\"\nms.date: \"03/30/2017\"\nms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a\nauthor: \"BrucePerlerMS\"\n---\n# WIF Session Management\nWhen a client first tries to access a protected resource that is hosted by a relying party, the client must first authenticate itself to a security token service (STS) that is trusted by the relying party. The STS then issues a security token to the client. The client presents this token to the relying party, which then grants the client access to the protected resource. However, you don’t want the client to have to re-authenticate to the STS for each request, especially because it might not even be on the same computer or in the same domain as the relying party. Instead, Windows Identity Foundation (WIF) has the client and relying party establish a session in which the client uses a session security token to authenticate itself to the relying party for all requests after the first request. The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>.  \n  \n The STS defines what authentication the client must provide. However, the client might have multiple credentials with which it can authenticate itself to the STS. For example, it might have a token from Windows Live, a user name and password, a certificate, and a smartkey. In that case, the STS grants the client several identities, with each identity corresponding to one of the credentials that the client presents. The relying party can use one or more of these identities when it decides what level of access to grant the client.  \n  \n The <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> is used to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>, which contains all of the client’s identities in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>. Each <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> in the collection contains the bootstrap tokens that are associated with that identity.  \n  \n If a new session token is issued with the session ID of the original session token, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> does not update the session token in the token cache. You should always instantiate a session token with a unique session ID.  \n  \n> [!NOTE]\n>  Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted. We recommend that you catch this exception and provide application-specific behavior.  \n  \n If a protected Web page contains lots of resources (such as small graphics) that are also in the protected domain, the client must re-authenticate itself to the relying party to download each of those resources. Use of a session authentication token avoids the need to authenticate to the STS for each request, but it still means that many cookies are being sent over. You might want to set up the Web page so that the important data and resources are stored in the protected domain while minor items are stored in an unprotected domain and linked to from the main Web page. Also, set the cookie path to reference only the protected domain.  \n  \n To operate in reference mode, Microsoft recommends providing a handler for the <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> event in the **global.asax.cs** file and setting the **IsReferenceMode** property on the token passed in the <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> property. These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> property on the Session Authentication Module.  \n  \n## Extensibility  \n You can extend the session management mechanism. One reason for this would be to improve the performance. For example, you could create a custom cookie handler that transforms or optimizes the session security token between its in-memory state and what goes into the cookie. To do so, you can configure the <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> property of the <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> to use a custom cookie handler that derives from <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>. <xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking.  \n  \n For more information, see [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) sample. This sample shows a farm ready session cache (as opposed to a tokenreplycache) so that you can use sessions by reference instead of exchanging big cookies; this sample also demonstrates an easier way of securing cookies in a farm. The session cache is WCF-based. With regard to session securing, the sample demonstrates a new capability in WIF 4.5 of a cookie transform based on MachineKey, which can be activated by simply pasting the appropriate snippet in the web.config. The sample itself is not \"farmed\", but it demonstrates what you need for making your app farm-ready.\n","nodes":[{"pos":[4,130],"embed":true,"restype":"x-metadata","content":"title: \"WIF Session Management\"\nms.date: \"03/30/2017\"\nms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a\nauthor: \"BrucePerlerMS\"","nodes":[{"content":"WIF Session Management","nodes":[{"pos":[0,22],"content":"WIF Session Management","nodes":[{"content":"WIF Session Management","pos":[0,22]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[137,159],"content":"WIF Session Management","linkify":"WIF Session Management","nodes":[{"content":"WIF Session Management","pos":[0,22]}]},{"content":"When a client first tries to access a protected resource that is hosted by a relying party, the client must first authenticate itself to a security token service (STS) that is trusted by the relying party.","pos":[160,365]},{"content":"The STS then issues a security token to the client.","pos":[366,417]},{"content":"The client presents this token to the relying party, which then grants the client access to the protected resource.","pos":[418,533]},{"content":"However, you don’t want the client to have to re-authenticate to the STS for each request, especially because it might not even be on the same computer or in the same domain as the relying party.","pos":[534,729]},{"content":"Instead, Windows Identity Foundation (WIF) has the client and relying party establish a session in which the client uses a session security token to authenticate itself to the relying party for all requests after the first request.","pos":[730,961]},{"content":"The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <ph id=\"ph1\">&lt;xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType&gt;</ph>.","pos":[962,1153],"source":" The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>."},{"content":"The STS defines what authentication the client must provide.","pos":[1160,1220]},{"content":"However, the client might have multiple credentials with which it can authenticate itself to the STS.","pos":[1221,1322]},{"content":"For example, it might have a token from Windows Live, a user name and password, a certificate, and a smartkey.","pos":[1323,1433]},{"content":"In that case, the STS grants the client several identities, with each identity corresponding to one of the credentials that the client presents.","pos":[1434,1578]},{"content":"The relying party can use one or more of these identities when it decides what level of access to grant the client.","pos":[1579,1694]},{"content":"The <ph id=\"ph1\">&lt;xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType&gt;</ph> is used to reconstruct the client’s <ph id=\"ph2\">&lt;xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType&gt;</ph>, which contains all of the client’s identities in <ph id=\"ph3\">&lt;xref:System.Security.Claims.ClaimsPrincipal.Identities%2A&gt;</ph>.","pos":[1701,2011],"source":"The <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> is used to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>, which contains all of the client’s identities in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType&gt;</ph> in the collection contains the bootstrap tokens that are associated with that identity.","pos":[2012,2178],"source":" Each <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> in the collection contains the bootstrap tokens that are associated with that identity."},{"content":"If a new session token is issued with the session ID of the original session token, <ph id=\"ph1\">&lt;xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType&gt;</ph> does not update the session token in the token cache.","pos":[2185,2414],"source":"If a new session token is issued with the session ID of the original session token, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> does not update the session token in the token cache."},{"content":"You should always instantiate a session token with a unique session ID.","pos":[2415,2486]},{"pos":[2494,2782],"content":"[!NOTE]\n Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted. We recommend that you catch this exception and provide application-specific behavior.","leadings":["","> "],"nodes":[{"content":"Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted. We recommend that you catch this exception and provide application-specific behavior.","pos":[9,286],"nodes":[{"content":"Session.SecurityTokenHandler.ReadToken throws a <ph id=\"ph1\">&lt;xref:System.Xml.XmlException&gt;</ph> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted.","pos":[0,191],"source":"Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted."},{"content":"We recommend that you catch this exception and provide application-specific behavior.","pos":[192,277]}]}]},{"content":"If a protected Web page contains lots of resources (such as small graphics) that are also in the protected domain, the client must re-authenticate itself to the relying party to download each of those resources.","pos":[2789,3000]},{"content":"Use of a session authentication token avoids the need to authenticate to the STS for each request, but it still means that many cookies are being sent over.","pos":[3001,3157]},{"content":"You might want to set up the Web page so that the important data and resources are stored in the protected domain while minor items are stored in an unprotected domain and linked to from the main Web page.","pos":[3158,3363]},{"content":"Also, set the cookie path to reference only the protected domain.","pos":[3364,3429]},{"content":"To operate in reference mode, Microsoft recommends providing a handler for the <ph id=\"ph1\">&lt;xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated&gt;</ph> event in the <bpt id=\"p1\">**</bpt>global.asax.cs<ept id=\"p1\">**</ept> file and setting the <bpt id=\"p2\">**</bpt>IsReferenceMode<ept id=\"p2\">**</ept> property on the token passed in the <ph id=\"ph2\">&lt;xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A&gt;</ph> property.","pos":[3436,3821],"source":"To operate in reference mode, Microsoft recommends providing a handler for the <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> event in the **global.asax.cs** file and setting the **IsReferenceMode** property on the token passed in the <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> property."},{"content":"These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <ph id=\"ph1\">&lt;xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A&gt;</ph> property on the Session Authentication Module.","pos":[3822,4086],"source":" These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> property on the Session Authentication Module."},{"pos":[4095,4108],"content":"Extensibility","linkify":"Extensibility","nodes":[{"content":"Extensibility","pos":[0,13]}]},{"content":"You can extend the session management mechanism.","pos":[4112,4160]},{"content":"One reason for this would be to improve the performance.","pos":[4161,4217]},{"content":"For example, you could create a custom cookie handler that transforms or optimizes the session security token between its in-memory state and what goes into the cookie.","pos":[4218,4386]},{"content":"To do so, you can configure the <ph id=\"ph1\">&lt;xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType&gt;</ph> to use a custom cookie handler that derives from <ph id=\"ph3\">&lt;xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType&gt;</ph>.","pos":[4387,4769],"source":" To do so, you can configure the <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> property of the <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> to use a custom cookie handler that derives from <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>."},{"content":"<ph id=\"ph1\">&lt;xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType&gt;</ph> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking.","pos":[4770,5045],"source":"<xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>ClaimsAwareWebFarm<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkID=248408)</ept> sample.","pos":[5052,5154],"source":"For more information, see [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) sample."},{"content":"This sample shows a farm ready session cache (as opposed to a tokenreplycache) so that you can use sessions by reference instead of exchanging big cookies; this sample also demonstrates an easier way of securing cookies in a farm.","pos":[5155,5385]},{"content":"The session cache is WCF-based.","pos":[5386,5417]},{"content":"With regard to session securing, the sample demonstrates a new capability in WIF 4.5 of a cookie transform based on MachineKey, which can be activated by simply pasting the appropriate snippet in the web.config. The sample itself is not \"farmed\", but it demonstrates what you need for making your app farm-ready.","pos":[5418,5730]}]}