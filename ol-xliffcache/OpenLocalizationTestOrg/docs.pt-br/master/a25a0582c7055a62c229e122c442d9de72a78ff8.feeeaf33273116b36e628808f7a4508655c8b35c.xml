{"content":"---\ntitle: \"invalidCERCall MDA | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"invalid CER calls\"\n  - \"InvalidCERCall MDA\"\n  - \"MDAs (managed debugging assistants), CER calls\"\n  - \"constrained execution regions\"\n  - \"CER calls\"\n  - \"managed debugging assistants (MDAs), CER calls\"\nms.assetid: c4577410-602e-44e5-9dab-fea7c55bcdfe\ncaps.latest.revision: 14\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# invalidCERCall MDA\nThe `invalidCERCall` managed debugging assistant (MDA) is activated when there is a call within the constrained execution region (CER) graph to a method that has no reliability contract or an excessively weak contract. A weak contract is a contract that declares that the worst case state corruption is of greater scope than the instance passed to the call, that is, the <xref:System.AppDomain> or process state may become corrupted or that its result is not always deterministically computable when called within a CER.  \n  \n## Symptoms  \n Unexpected results when executing code in a CER. The symptoms are not specific. They could be an unexpected <xref:System.OutOfMemoryException>, a <xref:System.Threading.ThreadAbortException>, or other exceptions at the call into the unreliable method because the runtime did not prepare it ahead of time or protect it from <xref:System.Threading.ThreadAbortException> exceptions at run time. A greater threat is that any exception resulting from the method at run time could leave the <xref:System.AppDomain> or process in an unstable state, which is contrary to the objective of a CER. The reason a CER is created is to avoid state corruptions such as this. The symptoms of corrupt state are application specific because the definition of consistent state is different between applications.  \n  \n## Cause  \n Code within a CER is calling a function with no <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> or with a weak <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> that is not compatible with running in a CER.  \n  \n In terms of reliability contract syntax, a weak contract is a contract that does not specify a <xref:System.Runtime.ConstrainedExecution.Consistency> enumeration value or specifies a <xref:System.Runtime.ConstrainedExecution.Consistency> value of <xref:System.Runtime.ConstrainedExecution.Consistency>, <xref:System.Runtime.ConstrainedExecution.Consistency>, or <xref:System.Runtime.ConstrainedExecution.Cer>. Any of these conditions indicates that the code called may impede the efforts of the other code in the CER to maintain consistent state.  CERs allow code to treat errors in a very deterministic manner, maintaining internal invariants that are important to the application and allowing it to continue running in the face of transient errors such as out-of-memory exceptions.  \n  \n The activation of this MDA indicates a possibility the method being called in the CER can fail in a way that the caller did not expect or that leaves the <xref:System.AppDomain> or process state corrupted or unrecoverable. Of course, the called code might execute correctly and the problem is simply a missing contract. However, the issues involved in writing reliable code are subtle and the absence of a contract is a good indicator the code might not execute correctly. The contracts are indicators that the programmer has coded reliably and also promises that these guarantees will not change in future revisions of the code.  That is, the contracts are declarations of intent and not just implementation details.  \n  \n Because any method with a weak or nonexistent contract can potentially fail in many unpredictable ways, the runtime does not attempt to remove any of its own unpredictable failures from the method  that are introduced by lazy JIT-compiling, generics dictionary population, or thread aborts, for example. That is, when this MDA is activated, it indicates that the runtime did not include the called method in the CER being defined; the call graph was terminated at this node because continuing to prepare this subtree would help mask the potential error.  \n  \n## Resolution  \n Add a valid reliability contract to the function or avoid using that function call.  \n  \n## Effect on the Runtime  \n The effect of calling a weak contract from a CER could be the CER failure to complete its operations. This could lead to corruption of the <xref:System.AppDomain> process state.  \n  \n## Output  \n The following is sample output from this MDA.  \n  \n `Method 'MethodWithCer', while executing within a constrained execution region, makes a call at IL offset 0x000C to 'MethodWithWeakContract', which does not have a sufficiently strong reliability contract and might cause non-deterministic results.`  \n  \n## Configuration  \n  \n```  \n<mdaConfig>  \n  <assistants>  \n    <invalidCERCall />  \n  </assistants>  \n</mdaConfig>  \n```  \n  \n## See Also  \n <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A>   \n <xref:System.Runtime.ConstrainedExecution>   \n [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)","nodes":[{"pos":[4,627],"embed":true,"restype":"x-metadata","content":"title: \"invalidCERCall MDA | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"invalid CER calls\"\n  - \"InvalidCERCall MDA\"\n  - \"MDAs (managed debugging assistants), CER calls\"\n  - \"constrained execution regions\"\n  - \"CER calls\"\n  - \"managed debugging assistants (MDAs), CER calls\"\nms.assetid: c4577410-602e-44e5-9dab-fea7c55bcdfe\ncaps.latest.revision: 14\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","nodes":[{"content":"invalidCERCall MDA | Microsoft Docs","nodes":[{"pos":[0,35],"content":"invalidCERCall MDA | Microsoft Docs","nodes":[{"content":"invalidCERCall MDA | Microsoft Docs","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[634,652],"content":"invalidCERCall MDA","linkify":"invalidCERCall MDA","nodes":[{"content":"invalidCERCall MDA","pos":[0,18]}]},{"content":"The <ph id=\"ph1\">`invalidCERCall`</ph> managed debugging assistant (MDA) is activated when there is a call within the constrained execution region (CER) graph to a method that has no reliability contract or an excessively weak contract.","pos":[653,871],"source":"The `invalidCERCall` managed debugging assistant (MDA) is activated when there is a call within the constrained execution region (CER) graph to a method that has no reliability contract or an excessively weak contract."},{"content":"A weak contract is a contract that declares that the worst case state corruption is of greater scope than the instance passed to the call, that is, the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> or process state may become corrupted or that its result is not always deterministically computable when called within a CER.","pos":[872,1173],"source":" A weak contract is a contract that declares that the worst case state corruption is of greater scope than the instance passed to the call, that is, the <xref:System.AppDomain> or process state may become corrupted or that its result is not always deterministically computable when called within a CER."},{"pos":[1182,1190],"content":"Symptoms","linkify":"Symptoms","nodes":[{"content":"Symptoms","pos":[0,8]}]},{"content":"Unexpected results when executing code in a CER.","pos":[1194,1242]},{"content":"The symptoms are not specific.","pos":[1243,1273]},{"content":"They could be an unexpected <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph>, a <ph id=\"ph2\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>, or other exceptions at the call into the unreliable method because the runtime did not prepare it ahead of time or protect it from <ph id=\"ph3\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> exceptions at run time.","pos":[1274,1585],"source":" They could be an unexpected <xref:System.OutOfMemoryException>, a <xref:System.Threading.ThreadAbortException>, or other exceptions at the call into the unreliable method because the runtime did not prepare it ahead of time or protect it from <xref:System.Threading.ThreadAbortException> exceptions at run time."},{"content":"A greater threat is that any exception resulting from the method at run time could leave the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> or process in an unstable state, which is contrary to the objective of a CER.","pos":[1586,1780],"source":" A greater threat is that any exception resulting from the method at run time could leave the <xref:System.AppDomain> or process in an unstable state, which is contrary to the objective of a CER."},{"content":"The reason a CER is created is to avoid state corruptions such as this.","pos":[1781,1852]},{"content":"The symptoms of corrupt state are application specific because the definition of consistent state is different between applications.","pos":[1853,1985]},{"pos":[1994,1999],"content":"Cause","linkify":"Cause","nodes":[{"content":"Cause","pos":[0,5]}]},{"pos":[2003,2255],"content":"Code within a CER is calling a function with no <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> or with a weak <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> that is not compatible with running in a CER.","source":"Code within a CER is calling a function with no <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> or with a weak <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> that is not compatible with running in a CER."},{"content":"In terms of reliability contract syntax, a weak contract is a contract that does not specify a <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency&gt;</ph> enumeration value or specifies a <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency&gt;</ph> value of <ph id=\"ph3\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>.","pos":[2262,2671],"source":"In terms of reliability contract syntax, a weak contract is a contract that does not specify a <xref:System.Runtime.ConstrainedExecution.Consistency> enumeration value or specifies a <xref:System.Runtime.ConstrainedExecution.Consistency> value of <xref:System.Runtime.ConstrainedExecution.Consistency>, <xref:System.Runtime.ConstrainedExecution.Consistency>, or <xref:System.Runtime.ConstrainedExecution.Cer>."},{"content":"Any of these conditions indicates that the code called may impede the efforts of the other code in the CER to maintain consistent state.","pos":[2672,2808]},{"content":"CERs allow code to treat errors in a very deterministic manner, maintaining internal invariants that are important to the application and allowing it to continue running in the face of transient errors such as out-of-memory exceptions.","pos":[2810,3045]},{"content":"The activation of this MDA indicates a possibility the method being called in the CER can fail in a way that the caller did not expect or that leaves the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> or process state corrupted or unrecoverable.","pos":[3052,3274],"source":"The activation of this MDA indicates a possibility the method being called in the CER can fail in a way that the caller did not expect or that leaves the <xref:System.AppDomain> or process state corrupted or unrecoverable."},{"content":"Of course, the called code might execute correctly and the problem is simply a missing contract.","pos":[3275,3371]},{"content":"However, the issues involved in writing reliable code are subtle and the absence of a contract is a good indicator the code might not execute correctly.","pos":[3372,3524]},{"content":"The contracts are indicators that the programmer has coded reliably and also promises that these guarantees will not change in future revisions of the code.","pos":[3525,3681]},{"content":"That is, the contracts are declarations of intent and not just implementation details.","pos":[3683,3769]},{"content":"Because any method with a weak or nonexistent contract can potentially fail in many unpredictable ways, the runtime does not attempt to remove any of its own unpredictable failures from the method  that are introduced by lazy JIT-compiling, generics dictionary population, or thread aborts, for example.","pos":[3776,4079]},{"content":"That is, when this MDA is activated, it indicates that the runtime did not include the called method in the CER being defined; the call graph was terminated at this node because continuing to prepare this subtree would help mask the potential error.","pos":[4080,4329]},{"pos":[4338,4348],"content":"Resolution","linkify":"Resolution","nodes":[{"content":"Resolution","pos":[0,10]}]},{"content":"Add a valid reliability contract to the function or avoid using that function call.","pos":[4352,4435]},{"pos":[4444,4465],"content":"Effect on the Runtime","linkify":"Effect on the Runtime","nodes":[{"content":"Effect on the Runtime","pos":[0,21]}]},{"content":"The effect of calling a weak contract from a CER could be the CER failure to complete its operations.","pos":[4469,4570]},{"content":"This could lead to corruption of the <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> process state.","pos":[4571,4646],"source":" This could lead to corruption of the <xref:System.AppDomain> process state."},{"pos":[4655,4661],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The following is sample output from this MDA.","pos":[4665,4710]},{"pos":[4974,4987],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"pos":[5100,5108],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Diagnosing Errors with Managed Debugging Assistants<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)</ept>","pos":[5234,5387],"source":"[Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)"}]}