{"content":"---\ntitle: \"Best Practices for Implementing the Event-based Asynchronous Pattern\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"Event-based Asynchronous Pattern\"\n  - \"ProgressChangedEventArgs class\"\n  - \"BackgroundWorker component\"\n  - \"events [.NET Framework], asynchronous\"\n  - \"AsyncOperationManager class\"\n  - \"threading [.NET Framework], asynchronous features\"\n  - \"AsyncOperation class\"\n  - \"AsyncCompletedEventArgs class\"\nms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db\n---\n# Best Practices for Implementing the Event-based Asynchronous Pattern\nThe Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics. To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements. The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.  \n  \n For an overview, see [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).  \n  \n## Required Behavioral Guarantees  \n If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.  \n  \n### Completion  \n Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation. Applications should never encounter a situation where they remain idle and completion never occurs. One exception to this rule is if the asynchronous operation itself is designed so that it never completes.  \n  \n### Completed Event and EventArgs  \n For each separate <em>MethodName</em>**Async** method, apply the following design requirements:  \n  \n-   Define a <em>MethodName</em>**Completed** event on the same class as the method.  \n  \n-   Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class. The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.  \n  \n-   Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method. When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.  \n  \n     The following code example shows good and bad implementation of this design requirement respectively.  \n  \n```csharp  \n// Good design  \nprivate void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)   \n{   \n    DemoType result = e.Result;  \n}  \n  \n// Bad design  \nprivate void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)   \n{   \n    DemoType result = (DemoType)(e.Result);  \n}  \n```  \n  \n-   Do not define an <xref:System.EventArgs> class for returning methods that return `void`. Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.  \n  \n-   Ensure that you always raise the <em>MethodName</em>**Completed** event. This event should be raised on successful completion, on an error, or on cancellation. Applications should never encounter a situation where they remain idle and completion never occurs.  \n  \n-   Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.  \n  \n-   If there was an error completing the task, the results should not be accessible. When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception. Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.  \n  \n-   Model a time out as an error. When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.  \n  \n-   If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.  \n  \n-   Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle. For more information, see the Threading and Contexts section.  \n  \n### Simultaneously Executing Operations  \n  \n-   If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`. This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.  \n  \n-   If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler. There are helper classes available to assist. For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).  \n  \n-   If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.  \n  \n-   In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations. You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks  \n  \n### Accessing Results  \n  \n-   If there was an error during execution of the asynchronous operation, the results should not be accessible. Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>. The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.  \n  \n-   Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled. Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.  \n  \n### Progress Reporting  \n  \n-   Support progress reporting, if possible. This enables developers to provide a better application user experience when they use your class.  \n  \n-   If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.  \n  \n-   If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage. The percentage does not need to be accurate, but it should represent a percentage. If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0. Avoid using a reporting metric other than a percentage.  \n  \n-   Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle. For more information, see the Threading and Contexts section.  \n  \n### IsBusy Implementation  \n  \n-   Do not expose an `IsBusy` property if your class supports multiple concurrent invocations. For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.  \n  \n-   The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised. Otherwise it should return `false`. The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.  \n  \n### Cancellation  \n  \n-   Support cancellation, if possible. This enables developers to provide a better application user experience when they use your class.  \n  \n-   In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.  \n  \n-   Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled. Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.  \n  \n-   Ensure that calls to a cancellation method always return successfully, and never raise an exception. In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded. However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.  \n  \n-   Raise the <em>MethodName</em>**Completed** event when the operation is canceled.  \n  \n### Errors and Exceptions  \n  \n-   Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.  \n  \n### Threading and Contexts  \n For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] and Windows Forms applications. Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.  \n  \n <xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>. Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.  \n  \n To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>. <xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.  \n  \n> [!NOTE]\n>  You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern. For example, you may want a class operating in Windows Forms to be free threaded. You can create a free threaded class, as long as developers understand the implied restrictions. Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls. This can cause `ProgressChanged` events to be raised out of order. If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.  \n  \n For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).  \n  \n## Guidelines  \n  \n-   Ideally, each method invocation should be independent of others. You should avoid coupling invocations with shared resources. If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.  \n  \n-   Designs that require the client to implement synchronization are discouraged. For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.  \n  \n-   If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations. This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.  \n  \n-   Consider reusing `CompletedEventArgs` classes where feasible and appropriate. In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method. However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.  \n  \n-   If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class. Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.  \n  \n-   When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs. Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).  \n  \n## See also\n\n- <xref:System.ComponentModel.AsyncOperation>\n- <xref:System.ComponentModel.AsyncOperationManager>\n- <xref:System.ComponentModel.AsyncCompletedEventArgs>\n- <xref:System.ComponentModel.ProgressChangedEventArgs>\n- <xref:System.ComponentModel.BackgroundWorker>\n- [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)\n- [Event-based Asynchronous Pattern (EAP)](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)\n- [Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)\n- [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)\n- [How to: Use Components That Support the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)\n- [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)\n","nodes":[{"pos":[4,511],"embed":true,"restype":"x-metadata","content":"title: \"Best Practices for Implementing the Event-based Asynchronous Pattern\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"Event-based Asynchronous Pattern\"\n  - \"ProgressChangedEventArgs class\"\n  - \"BackgroundWorker component\"\n  - \"events [.NET Framework], asynchronous\"\n  - \"AsyncOperationManager class\"\n  - \"threading [.NET Framework], asynchronous features\"\n  - \"AsyncOperation class\"\n  - \"AsyncCompletedEventArgs class\"\nms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db","nodes":[{"content":"Best Practices for Implementing the Event-based Asynchronous Pattern","nodes":[{"pos":[0,68],"content":"Best Practices for Implementing the Event-based Asynchronous Pattern","nodes":[{"content":"Best Practices for Implementing the Event-based Asynchronous Pattern","pos":[0,68]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[518,586],"content":"Best Practices for Implementing the Event-based Asynchronous Pattern","linkify":"Best Practices for Implementing the Event-based Asynchronous Pattern","nodes":[{"content":"Best Practices for Implementing the Event-based Asynchronous Pattern","pos":[0,68]}]},{"content":"The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.","pos":[587,746]},{"content":"To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.","pos":[747,851]},{"content":"The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.","pos":[852,1009]},{"pos":[1016,1200],"content":"For an overview, see <bpt id=\"p1\">[</bpt>Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)</ept>.","source":"For an overview, see [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)."},{"pos":[1209,1239],"content":"Required Behavioral Guarantees","linkify":"Required Behavioral Guarantees","nodes":[{"content":"Required Behavioral Guarantees","pos":[0,30]}]},{"content":"If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.","pos":[1243,1437]},{"pos":[1447,1457],"content":"Completion","linkify":"Completion","nodes":[{"content":"Completion","pos":[0,10]}]},{"content":"Always invoke the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event handler when you have successful completion, an error, or a cancellation.","pos":[1461,1591],"source":"Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation."},{"content":"Applications should never encounter a situation where they remain idle and completion never occurs.","pos":[1592,1691]},{"content":"One exception to this rule is if the asynchronous operation itself is designed so that it never completes.","pos":[1692,1798]},{"pos":[1808,1837],"content":"Completed Event and EventArgs","linkify":"Completed Event and EventArgs","nodes":[{"content":"Completed Event and EventArgs","pos":[0,29]}]},{"pos":[1841,1936],"content":"For each separate <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> method, apply the following design requirements:","source":"For each separate <em>MethodName</em>**Async** method, apply the following design requirements:"},{"pos":[1946,2026],"content":"Define a <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event on the same class as the method.","source":"Define a <em>MethodName</em>**Completed** event on the same class as the method."},{"content":"Define an <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> class and accompanying delegate for the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event that derives from the <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> class.","pos":[2036,2230],"source":"Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class."},{"content":"The default class name should be of the form <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>CompletedEventArgs<ept id=\"p2\">**</ept>.","pos":[2231,2318],"source":" The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**."},{"content":"Ensure that the <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> class is specific to the return values of the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept> method.","pos":[2328,2441],"source":"Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method."},{"content":"When you use the <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> class, you should never require developers to cast the result.","pos":[2442,2545],"source":" When you use the <xref:System.EventArgs> class, you should never require developers to cast the result."},{"content":"The following code example shows good and bad implementation of this design requirement respectively.","pos":[2556,2657]},{"content":"Do not define an <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> class for returning methods that return <ph id=\"ph2\">`void`</ph>.","pos":[2993,3081],"source":"Do not define an <xref:System.EventArgs> class for returning methods that return `void`."},{"content":"Instead, use an instance of the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> class.","pos":[3082,3173],"source":" Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class."},{"content":"Ensure that you always raise the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event.","pos":[3183,3255],"source":"Ensure that you always raise the <em>MethodName</em>**Completed** event."},{"content":"This event should be raised on successful completion, on an error, or on cancellation.","pos":[3256,3342]},{"content":"Applications should never encounter a situation where they remain idle and completion never occurs.","pos":[3343,3442]},{"pos":[3452,3640],"content":"Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A&gt;</ph> property.","source":"Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property."},{"content":"If there was an error completing the task, the results should not be accessible.","pos":[3650,3730]},{"content":"When the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A&gt;</ph> property is not <ph id=\"ph2\">`null`</ph>, ensure that accessing any property in the <ph id=\"ph3\">&lt;xref:System.EventArgs&gt;</ph> structure raises an exception.","pos":[3731,3922],"source":" When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A&gt;</ph> method to perform this verification.","pos":[3923,4049],"source":" Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification."},{"content":"Model a time out as an error.","pos":[4059,4088]},{"content":"When a time out occurs, raise the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event and assign a <ph id=\"ph1\">&lt;xref:System.TimeoutException&gt;</ph> to the <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A&gt;</ph> property.","pos":[4089,4284],"source":" When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property."},{"pos":[4294,4457],"content":"If your class supports multiple concurrent invocations, ensure that the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event contains the appropriate <ph id=\"ph1\">`userSuppliedState`</ph> object.","source":"If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object."},{"content":"Ensure that the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event is raised on the appropriate thread and at the appropriate time in the application lifecycle.","pos":[4467,4615],"source":"Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle."},{"content":"For more information, see the Threading and Contexts section.","pos":[4616,4677]},{"pos":[4687,4722],"content":"Simultaneously Executing Operations","linkify":"Simultaneously Executing Operations","nodes":[{"content":"Simultaneously Executing Operations","pos":[0,35]}]},{"content":"If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> overload that takes an object-valued state parameter, or task ID, called <ph id=\"ph1\">`userSuppliedState`</ph>.","pos":[4732,4983],"source":"If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`."},{"content":"This parameter should always be the last parameter in the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> method's signature.","pos":[4984,5090],"source":" This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature."},{"content":"If your class defines the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.","pos":[5100,5346],"source":"If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler."},{"content":"There are helper classes available to assist.","pos":[5347,5392]},{"content":"For more information on concurrency management, see <bpt id=\"p1\">[</bpt>How to: Implement a Component That Supports the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)</ept>.","pos":[5393,5650],"source":" For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)."},{"pos":[5660,5992],"content":"If your class defines the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <bpt id=\"p3\">&lt;em&gt;</bpt>MethodName<ept id=\"p3\">&lt;/em&gt;</ept><bpt id=\"p4\">**</bpt>Async<ept id=\"p4\">**</ept> before the prior <bpt id=\"p5\">&lt;em&gt;</bpt>MethodName<ept id=\"p5\">&lt;/em&gt;</ept><bpt id=\"p6\">**</bpt>Async<ept id=\"p6\">**</ept> invocation has completed raises an <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph>.","source":"If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>."},{"content":"In general, do not raise an exception if the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> method without the <ph id=\"ph1\">`userSuppliedState`</ph> parameter is invoked multiple times so that there are multiple outstanding operations.","pos":[6002,6201],"source":"In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations."},{"content":"You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks","pos":[6202,6366]},{"pos":[6376,6393],"content":"Accessing Results","linkify":"Accessing Results","nodes":[{"content":"Accessing Results","pos":[0,17]}]},{"content":"If there was an error during execution of the asynchronous operation, the results should not be accessible.","pos":[6403,6510]},{"content":"Ensure that accessing any property in the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> when <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A&gt;</ph> is not <ph id=\"ph3\">`null`</ph> raises the exception referenced by <ph id=\"ph4\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A&gt;</ph>.","pos":[6511,6784],"source":" Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> class provides the <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A&gt;</ph> method for this purpose.","pos":[6785,6967],"source":" The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose."},{"content":"Ensure that any attempt to access the result raises an <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> stating that the operation was canceled.","pos":[6977,7112],"source":"Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType&gt;</ph> method to perform this verification.","pos":[7113,7268],"source":" Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification."},{"pos":[7278,7296],"content":"Progress Reporting","linkify":"Progress Reporting","nodes":[{"content":"Progress Reporting","pos":[0,18]}]},{"content":"Support progress reporting, if possible.","pos":[7306,7346]},{"content":"This enables developers to provide a better application user experience when they use your class.","pos":[7347,7444]},{"pos":[7454,7704],"content":"If you implement a <bpt id=\"p1\">**</bpt>ProgressChanged<ept id=\"p1\">**</ept> or <bpt id=\"p2\">&lt;em&gt;</bpt>MethodName<ept id=\"p2\">&lt;/em&gt;</ept><bpt id=\"p3\">**</bpt>ProgressChanged<ept id=\"p3\">**</ept> event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <bpt id=\"p4\">&lt;em&gt;</bpt>MethodName<ept id=\"p4\">&lt;/em&gt;</ept><bpt id=\"p5\">**</bpt>Completed<ept id=\"p5\">**</ept> event has been raised.","source":"If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised."},{"content":"If the standard <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> is being populated, ensure that the <ph id=\"ph2\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A&gt;</ph> can always be interpreted as a percentage.","pos":[7714,7938],"source":"If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage."},{"content":"The percentage does not need to be accurate, but it should represent a percentage.","pos":[7939,8021]},{"content":"If your progress reporting metric must be something other than a percentage, derive a class from the <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> class and leave <ph id=\"ph2\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A&gt;</ph> at 0.","pos":[8022,8274],"source":" If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0."},{"content":"Avoid using a reporting metric other than a percentage.","pos":[8275,8330]},{"content":"Ensure that the <ph id=\"ph1\">`ProgressChanged`</ph> event is raised on the appropriate thread and at the appropriate time in the application lifecycle.","pos":[8340,8473],"source":"Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle."},{"content":"For more information, see the Threading and Contexts section.","pos":[8474,8535]},{"pos":[8545,8566],"content":"IsBusy Implementation","linkify":"IsBusy Implementation","nodes":[{"content":"IsBusy Implementation","pos":[0,21]}]},{"content":"Do not expose an <ph id=\"ph1\">`IsBusy`</ph> property if your class supports multiple concurrent invocations.","pos":[8576,8666],"source":"Do not expose an `IsBusy` property if your class supports multiple concurrent invocations."},{"content":"For example, XML Web service proxies do not expose an <ph id=\"ph1\">`IsBusy`</ph> property because they support multiple concurrent invocations of asynchronous methods.","pos":[8667,8816],"source":" For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods."},{"content":"The <ph id=\"ph1\">`IsBusy`</ph> property should return <ph id=\"ph2\">`true`</ph> after the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> method has been called and before the <bpt id=\"p3\">&lt;em&gt;</bpt>MethodName<ept id=\"p3\">&lt;/em&gt;</ept><bpt id=\"p4\">**</bpt>Completed<ept id=\"p4\">**</ept> event has been raised.","pos":[8826,9001],"source":"The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised."},{"content":"Otherwise it should return <ph id=\"ph1\">`false`</ph>.","pos":[9002,9037],"source":" Otherwise it should return `false`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.WebClient&gt;</ph> components are examples of classes that expose an <ph id=\"ph3\">`IsBusy`</ph> property.","pos":[9038,9188],"source":" The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property."},{"pos":[9198,9210],"content":"Cancellation","linkify":"Cancellation","nodes":[{"content":"Cancellation","pos":[0,12]}]},{"content":"Support cancellation, if possible.","pos":[9220,9254]},{"content":"This enables developers to provide a better application user experience when they use your class.","pos":[9255,9352]},{"pos":[9362,9537],"content":"In the case of cancellation, set the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A&gt;</ph> flag in the <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> object.","source":"In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object."},{"content":"Ensure that any attempt to access the result raises an <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> stating that the operation was canceled.","pos":[9547,9682],"source":"Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType&gt;</ph> method to perform this verification.","pos":[9683,9838],"source":" Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification."},{"content":"Ensure that calls to a cancellation method always return successfully, and never raise an exception.","pos":[9848,9948]},{"content":"In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.","pos":[9949,10133]},{"content":"However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.","pos":[10134,10284]},{"pos":[10294,10374],"content":"Raise the <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Completed<ept id=\"p2\">**</ept> event when the operation is canceled.","source":"Raise the <em>MethodName</em>**Completed** event when the operation is canceled."},{"pos":[10384,10405],"content":"Errors and Exceptions","linkify":"Errors and Exceptions","nodes":[{"content":"Errors and Exceptions","pos":[0,21]}]},{"pos":[10415,10620],"content":"Catch any exceptions that occur in the asynchronous operation and set the value of the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType&gt;</ph> property to that exception.","source":"Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception."},{"pos":[10630,10652],"content":"Threading and Contexts","linkify":"Threading and Contexts","nodes":[{"content":"Threading and Contexts","pos":[0,22]}]},{"content":"For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]</ph> and Windows Forms applications.","pos":[10656,10914],"source":"For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] and Windows Forms applications."},{"content":"Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperation&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncOperationManager&gt;</ph>.","pos":[10915,11142],"source":" Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>."},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperationManager&gt;</ph> provides one method, <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A&gt;</ph>, which returns an <ph id=\"ph3\">&lt;xref:System.ComponentModel.AsyncOperation&gt;</ph>.","pos":[11149,11353],"source":"<xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>."},{"content":"Your <bpt id=\"p1\">&lt;em&gt;</bpt>MethodName<ept id=\"p1\">&lt;/em&gt;</ept><bpt id=\"p2\">**</bpt>Async<ept id=\"p2\">**</ept> method calls <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A&gt;</ph> and your class uses the returned <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncOperation&gt;</ph> to track the lifetime of the asynchronous task.","pos":[11354,11595],"source":" Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task."},{"content":"To report progress, incremental results, and completion to the client, call the <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperation.Post%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A&gt;</ph> methods on the <ph id=\"ph3\">&lt;xref:System.ComponentModel.AsyncOperation&gt;</ph>.","pos":[11602,11863],"source":"To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>."},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperation&gt;</ph> is responsible for marshaling calls to the client's event handlers to the proper thread or context.","pos":[11864,12007],"source":"<xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context."},{"pos":[12015,12793],"content":"[!NOTE]\n You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern. For example, you may want a class operating in Windows Forms to be free threaded. You can create a free threaded class, as long as developers understand the implied restrictions. Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls. This can cause `ProgressChanged` events to be raised out of order. If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.","leadings":["","> "],"nodes":[{"content":"You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern. For example, you may want a class operating in Windows Forms to be free threaded. You can create a free threaded class, as long as developers understand the implied restrictions. Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls. This can cause `ProgressChanged` events to be raised out of order. If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.","pos":[9,776],"nodes":[{"content":"You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.","pos":[0,195]},{"content":"For example, you may want a class operating in Windows Forms to be free threaded.","pos":[196,277]},{"content":"You can create a free threaded class, as long as developers understand the implied restrictions.","pos":[278,374]},{"content":"Console applications do not synchronize the execution of <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperation.Post%2A&gt;</ph> calls.","pos":[375,490],"source":" Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls."},{"content":"This can cause <ph id=\"ph1\">`ProgressChanged`</ph> events to be raised out of order.","pos":[491,557],"source":" This can cause `ProgressChanged` events to be raised out of order."},{"content":"If you wish to have serialized execution of <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperation.Post%2A&gt;</ph> calls, implement and install a <ph id=\"ph2\">&lt;xref:System.Threading.SynchronizationContext?displayProperty=nameWithType&gt;</ph> class.","pos":[558,767],"source":" If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class."}]}]},{"pos":[12800,13181],"content":"For more information about using <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperation&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.AsyncOperationManager&gt;</ph> to enable your asynchronous operations, see <bpt id=\"p1\">[</bpt>How to: Implement a Component That Supports the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)</ept>.","source":"For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)."},{"pos":[13190,13200],"content":"Guidelines","linkify":"Guidelines","nodes":[{"content":"Guidelines","pos":[0,10]}]},{"content":"Ideally, each method invocation should be independent of others.","pos":[13210,13274]},{"content":"You should avoid coupling invocations with shared resources.","pos":[13275,13335]},{"content":"If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.","pos":[13336,13468]},{"content":"Designs that require the client to implement synchronization are discouraged.","pos":[13478,13555]},{"content":"For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.","pos":[13556,13754]},{"content":"If you implement a method with the multiple-invocation overload (<ph id=\"ph1\">`userState`</ph> in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.","pos":[13764,13976],"source":"If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations."},{"content":"This collection should be protected with <ph id=\"ph1\">`lock`</ph> regions, because the various invocations add and remove <ph id=\"ph2\">`userState`</ph> objects in the collection.","pos":[13977,14119],"source":" This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection."},{"content":"Consider reusing <ph id=\"ph1\">`CompletedEventArgs`</ph> classes where feasible and appropriate.","pos":[14129,14206],"source":"Consider reusing `CompletedEventArgs` classes where feasible and appropriate."},{"content":"In this case, the naming is not consistent with the method name, because a given delegate and <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> type are not tied to a single method.","pos":[14207,14362],"source":" In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method."},{"content":"However, forcing developers to cast the value retrieved from a property on the <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> is never acceptable.","pos":[14363,14486],"source":" However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable."},{"content":"If you are authoring a class that derives from <ph id=\"ph1\">&lt;xref:System.ComponentModel.Component&gt;</ph>, do not implement and install your own <ph id=\"ph2\">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> class.","pos":[14496,14674],"source":"If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class."},{"content":"Application models, not components, control the <ph id=\"ph1\">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> that is used.","pos":[14675,14783],"source":" Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used."},{"content":"When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.","pos":[14793,14899]},{"content":"Before implementing any solution that uses multithreading, see <bpt id=\"p1\">[</bpt>Managed Threading Best Practices<ept id=\"p1\">](../../../docs/standard/threading/managed-threading-best-practices.md)</ept>.","pos":[14900,15068],"source":" Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md)."},{"pos":[15077,15085],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[15347,15509],"content":"<bpt id=\"p1\">[</bpt>Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)</ept>","source":"[Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)"},{"pos":[15512,15650],"content":"<bpt id=\"p1\">[</bpt>Event-based Asynchronous Pattern (EAP)<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)</ept>","source":"[Event-based Asynchronous Pattern (EAP)](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)"},{"pos":[15653,15843],"content":"<bpt id=\"p1\">[</bpt>Deciding When to Implement the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)</ept>","source":"[Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)"},{"pos":[15846,16046],"content":"<bpt id=\"p1\">[</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept>","source":"[Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)"},{"pos":[16049,16256],"content":"<bpt id=\"p1\">[</bpt>How to: Use Components That Support the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)</ept>","source":"[How to: Use Components That Support the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)"},{"pos":[16259,16463],"content":"<bpt id=\"p1\">[</bpt>How to: Implement a Component That Supports the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)</ept>","source":"[How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)"}]}