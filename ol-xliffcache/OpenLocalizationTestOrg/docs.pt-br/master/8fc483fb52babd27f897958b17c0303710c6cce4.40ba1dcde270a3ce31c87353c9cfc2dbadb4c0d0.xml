{"content":"---\ntitle: The Updated .NET Core Event Pattern\ndescription: The Updated .NET Core Event Pattern\nkeywords: .NET, .NET Core\nauthor: BillWagner\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 9aa627c3-3222-4094-9ca8-7e88e1071e06\n---\n\n# The Updated .NET Core Event Pattern\n\n[Previous](event-pattern.md)\n\nThe previous article discussed the most common event patterns. .NET\nCore has a more relaxed pattern. In this version, the \n`EventHandler<TEventArgs>` definition no longer has the constraint that\n`TEventArgs` must be a class derived from `System.EventArgs`.\n\nThis increases flexibility for you, and is backwards compatible. Let's\nstart with the flexibility. The class System.EventArgs introduces one\nmethod: `MemberwiseClone()`, which creates a shallow copy of the object.\nThat method must use reflection in order to implement\nits functionality for any class derived from `EventArgs`. That\nfunctionality is easier to create in a specific derived class. That\neffectively means that deriving from System.EventArgs is a constraint\nthat limits your designs, but does not provide any additional benefit.\nIn fact, you can changes the definitions of `FileFoundArgs` and\n`SearchDirectoryArgs` so that they do not derive from `EventArgs`.\nThe program will work exactly the same.\n\nYou could also change the `SearchDirectoryArgs` to a struct, if you\nalso make one more change:\n\n```csharp  \ninternal struct SearchDirectoryArgs  \n{  \n    internal string CurrentSearchDirectory { get; }  \n    internal int TotalDirs { get; }  \n    internal int CompletedDirs { get; }  \n    \n    internal SearchDirectoryArgs(string dir, int totalDirs, \n        int completedDirs) : this()  \n    {  \n        CurrentSearchDirectory = dir;  \n        TotalDirs = totalDirs;  \n        CompletedDirs = completedDirs;  \n    }  \n}  \n```   \n\nThe additional change is to call the default constructor before\nentering the constructor that initializes all the fields. Without\nthat addition, the rules of C# would report that the properties are\nbeing accessed before they have been assigned.\n\nYou should not change the `FileFoundArgs` from a class (reference\ntype) to a struct (value type). That's because the protocol for\nhandling cancel requires that the event arguments are passed by reference. If you made the same change, the file search class could\nnever observe any changes made by any of the event subscribers. A new\ncopy of the structure would be used for each subscriber, and that\ncopy would be a different copy than the one seen by the file search\nobject.\n\nNext, let's consider how this change can be backwards compatible.\nThe removal of the constraint does not affect any existing code. Any\nexisting event argument types do still derive from `System.EventArgs`.\nBackwards compatibility is one major reason why they will continue\nto derive from `System.EventArgs`. Any existing event subscribers will\nbe subscribers to an event that followed the classic pattern.\n\nFollowing similar logic, any event argument type created now would\nnot have any subscribers in any existing codebases. New event types\nthat do not derive from `System.EventArgs` will not break those\ncodebases.\n\n## Events with Async subscribers\n\nYou have one final pattern to learn: How to correctly write event\nsubscribers that call async code. The challenge is described in\nthe article on [async and await](async.md). Async methods can\nhave a void return type, but that is strongly discouraged. When your\nevent subscriber code calls an async method, you have no choice but\nto create an `async void` method. The event handler signature requires\nit.\n\nYou need to reconcile this opposing guidance. Somehow, you must\ncreate a safe `async void` method. The basics of the pattern you need\nto implement are below:\n\n```csharp\nworker.StartWorking += async (sender, eventArgs) =>\n{\n    try \n    {\n        await DoWorkAsync();\n    }\n    catch (Exception e)\n    {\n        //Some form of logging.\n        Console.WriteLine($\"Async task failure: {e.ToString()}\");\n        // Consider gracefully, and quickly exiting.\n    }\n};\n```\n\nFirst, notice that the handler is marked as an async handler. Because\nit is being assigned to an event handler delegate type, it will have\na void return type. That means you must follow the pattern shown in the\nhandler, and not allow any exceptions to be thrown out of the context\nof the async handler. Because it does not return a task, there is no\ntask that can report the error by entering the faulted state. Because\nthe method is async, the method can't simply throw the exception. (The\ncalling method has continued execution because it is `async`.) The\nactual runtime behavior will be defined differently for different\nenvironments. It may terminate the thread, it may terminate the program,\nor it may leave the program in an undetermined state. None of those\nare good outcomes.\n\nThat's why you should wrap the await statement for the async Task\nin your own try block. If it does cause a faulted task, you can\nlog the error. If it is an error from which your application cannot\nrecover, you can exit the program quickly and gracefully\n\nThose are the major updates to the .NET event pattern. You will see many\nexamples of the earlier versions in the libraries you work with. However,\nyou should understand what the latest patterns are as well.\n\nThe next article in this series helps you distinguish between using\n`delegates` and `events` in your designs. They are similar concepts,\nand that article will help you make the best decision for your\nprograms.\n\n[Next](distinguish-delegates-events.md)\n","nodes":[{"pos":[11,46],"content":"The Updated .NET Core Event Pattern","needQuote":true,"needEscape":true,"nodes":[{"content":"The Updated .NET Core Event Pattern","pos":[0,35]}]},{"pos":[60,95],"content":"The Updated .NET Core Event Pattern","needQuote":true,"needEscape":true,"nodes":[{"content":"The Updated .NET Core Event Pattern","pos":[0,35]}]},{"pos":[106,121],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[316,351],"content":"The Updated .NET Core Event Pattern","linkify":"The Updated .NET Core Event Pattern","nodes":[{"content":"The Updated .NET Core Event Pattern","pos":[0,35]}]},{"pos":[353,381],"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](event-pattern.md)</ept>","source":"[Previous](event-pattern.md)"},{"content":"The previous article discussed the most common event patterns.","pos":[383,445]},{"content":".NET Core has a more relaxed pattern.","pos":[446,483],"source":" .NET\nCore has a more relaxed pattern."},{"content":"In this version, the <ph id=\"ph1\">`EventHandler&lt;TEventArgs&gt;`</ph> definition no longer has the constraint that <ph id=\"ph2\">`TEventArgs`</ph> must be a class derived from <ph id=\"ph3\">`System.EventArgs`</ph>.","pos":[484,639],"source":" In this version, the \n`EventHandler<TEventArgs>` definition no longer has the constraint that\n`TEventArgs` must be a class derived from `System.EventArgs`."},{"content":"This increases flexibility for you, and is backwards compatible.","pos":[641,705]},{"content":"Let's start with the flexibility.","pos":[706,739],"source":" Let's\nstart with the flexibility."},{"content":"The class System.EventArgs introduces one method: <ph id=\"ph1\">`MemberwiseClone()`</ph>, which creates a shallow copy of the object.","pos":[740,854],"source":" The class System.EventArgs introduces one\nmethod: `MemberwiseClone()`, which creates a shallow copy of the object."},{"content":"That method must use reflection in order to implement its functionality for any class derived from <ph id=\"ph1\">`EventArgs`</ph>.","pos":[855,966],"source":"\nThat method must use reflection in order to implement\nits functionality for any class derived from `EventArgs`."},{"content":"That functionality is easier to create in a specific derived class.","pos":[967,1034],"source":" That\nfunctionality is easier to create in a specific derived class."},{"content":"That effectively means that deriving from System.EventArgs is a constraint that limits your designs, but does not provide any additional benefit.","pos":[1035,1180],"source":" That\neffectively means that deriving from System.EventArgs is a constraint\nthat limits your designs, but does not provide any additional benefit."},{"content":"In fact, you can changes the definitions of <ph id=\"ph1\">`FileFoundArgs`</ph> and <ph id=\"ph2\">`SearchDirectoryArgs`</ph> so that they do not derive from <ph id=\"ph3\">`EventArgs`</ph>.","pos":[1181,1311],"source":"\nIn fact, you can changes the definitions of `FileFoundArgs` and\n`SearchDirectoryArgs` so that they do not derive from `EventArgs`."},{"content":"The program will work exactly the same.","pos":[1312,1351],"source":"\nThe program will work exactly the same."},{"pos":[1353,1447],"content":"You could also change the <ph id=\"ph1\">`SearchDirectoryArgs`</ph> to a struct, if you also make one more change:","source":"You could also change the `SearchDirectoryArgs` to a struct, if you\nalso make one more change:"},{"content":"The additional change is to call the default constructor before entering the constructor that initializes all the fields.","pos":[1883,2004],"source":"The additional change is to call the default constructor before\nentering the constructor that initializes all the fields."},{"content":"Without that addition, the rules of C# would report that the properties are being accessed before they have been assigned.","pos":[2005,2127],"source":" Without\nthat addition, the rules of C# would report that the properties are\nbeing accessed before they have been assigned."},{"content":"You should not change the <ph id=\"ph1\">`FileFoundArgs`</ph> from a class (reference type) to a struct (value type).","pos":[2129,2226],"source":"You should not change the `FileFoundArgs` from a class (reference\ntype) to a struct (value type)."},{"content":"That's because the protocol for handling cancel requires that the event arguments are passed by reference.","pos":[2227,2333],"source":" That's because the protocol for\nhandling cancel requires that the event arguments are passed by reference."},{"content":"If you made the same change, the file search class could never observe any changes made by any of the event subscribers.","pos":[2334,2454],"source":" If you made the same change, the file search class could\nnever observe any changes made by any of the event subscribers."},{"content":"A new copy of the structure would be used for each subscriber, and that copy would be a different copy than the one seen by the file search object.","pos":[2455,2602],"source":" A new\ncopy of the structure would be used for each subscriber, and that\ncopy would be a different copy than the one seen by the file search\nobject."},{"content":"Next, let's consider how this change can be backwards compatible.","pos":[2604,2669]},{"content":"The removal of the constraint does not affect any existing code.","pos":[2670,2734],"source":"\nThe removal of the constraint does not affect any existing code."},{"content":"Any existing event argument types do still derive from <ph id=\"ph1\">`System.EventArgs`</ph>.","pos":[2735,2809],"source":" Any\nexisting event argument types do still derive from `System.EventArgs`."},{"content":"Backwards compatibility is one major reason why they will continue to derive from <ph id=\"ph1\">`System.EventArgs`</ph>.","pos":[2810,2911],"source":"\nBackwards compatibility is one major reason why they will continue\nto derive from `System.EventArgs`."},{"content":"Any existing event subscribers will be subscribers to an event that followed the classic pattern.","pos":[2912,3009],"source":" Any existing event subscribers will\nbe subscribers to an event that followed the classic pattern."},{"content":"Following similar logic, any event argument type created now would not have any subscribers in any existing codebases.","pos":[3011,3129],"source":"Following similar logic, any event argument type created now would\nnot have any subscribers in any existing codebases."},{"content":"New event types that do not derive from <ph id=\"ph1\">`System.EventArgs`</ph> will not break those codebases.","pos":[3130,3220],"source":" New event types\nthat do not derive from `System.EventArgs` will not break those\ncodebases."},{"pos":[3225,3254],"content":"Events with Async subscribers","linkify":"Events with Async subscribers","nodes":[{"content":"Events with Async subscribers","pos":[0,29]}]},{"content":"You have one final pattern to learn: How to correctly write event subscribers that call async code.","pos":[3256,3355],"source":"You have one final pattern to learn: How to correctly write event\nsubscribers that call async code."},{"content":"The challenge is described in the article on <bpt id=\"p1\">[</bpt>async and await<ept id=\"p1\">](async.md)</ept>.","pos":[3356,3429],"source":" The challenge is described in\nthe article on [async and await](async.md)."},{"content":"Async methods can have a void return type, but that is strongly discouraged.","pos":[3430,3506],"source":" Async methods can\nhave a void return type, but that is strongly discouraged."},{"content":"When your event subscriber code calls an async method, you have no choice but to create an <ph id=\"ph1\">`async void`</ph> method.","pos":[3507,3618],"source":" When your\nevent subscriber code calls an async method, you have no choice but\nto create an `async void` method."},{"content":"The event handler signature requires it.","pos":[3619,3659],"source":" The event handler signature requires\nit."},{"content":"You need to reconcile this opposing guidance.","pos":[3661,3706]},{"content":"Somehow, you must create a safe <ph id=\"ph1\">`async void`</ph> method.","pos":[3707,3759],"source":" Somehow, you must\ncreate a safe `async void` method."},{"content":"The basics of the pattern you need to implement are below:","pos":[3760,3818],"source":" The basics of the pattern you need\nto implement are below:"},{"content":"First, notice that the handler is marked as an async handler.","pos":[4129,4190]},{"content":"Because it is being assigned to an event handler delegate type, it will have a void return type.","pos":[4191,4287],"source":" Because\nit is being assigned to an event handler delegate type, it will have\na void return type."},{"content":"That means you must follow the pattern shown in the handler, and not allow any exceptions to be thrown out of the context of the async handler.","pos":[4288,4431],"source":" That means you must follow the pattern shown in the\nhandler, and not allow any exceptions to be thrown out of the context\nof the async handler."},{"content":"Because it does not return a task, there is no task that can report the error by entering the faulted state.","pos":[4432,4540],"source":" Because it does not return a task, there is no\ntask that can report the error by entering the faulted state."},{"content":"Because the method is async, the method can't simply throw the exception.","pos":[4541,4614],"source":" Because\nthe method is async, the method can't simply throw the exception."},{"content":"(The calling method has continued execution because it is <ph id=\"ph1\">`async`</ph>.) The actual runtime behavior will be defined differently for different environments.","pos":[4615,4766],"source":" (The\ncalling method has continued execution because it is `async`.) The\nactual runtime behavior will be defined differently for different\nenvironments."},{"content":"It may terminate the thread, it may terminate the program, or it may leave the program in an undetermined state.","pos":[4767,4879],"source":" It may terminate the thread, it may terminate the program,\nor it may leave the program in an undetermined state."},{"content":"None of those are good outcomes.","pos":[4880,4912],"source":" None of those\nare good outcomes."},{"content":"That's why you should wrap the await statement for the async Task in your own try block.","pos":[4914,5002],"source":"That's why you should wrap the await statement for the async Task\nin your own try block."},{"content":"If it does cause a faulted task, you can log the error.","pos":[5003,5058],"source":" If it does cause a faulted task, you can\nlog the error."},{"content":"If it is an error from which your application cannot recover, you can exit the program quickly and gracefully","pos":[5059,5168],"source":" If it is an error from which your application cannot\nrecover, you can exit the program quickly and gracefully"},{"content":"Those are the major updates to the .NET event pattern.","pos":[5170,5224]},{"content":"You will see many examples of the earlier versions in the libraries you work with.","pos":[5225,5307],"source":" You will see many\nexamples of the earlier versions in the libraries you work with."},{"content":"However, you should understand what the latest patterns are as well.","pos":[5308,5376],"source":" However,\nyou should understand what the latest patterns are as well."},{"content":"The next article in this series helps you distinguish between using <ph id=\"ph1\">`delegates`</ph> and <ph id=\"ph2\">`events`</ph> in your designs.","pos":[5378,5487],"source":"The next article in this series helps you distinguish between using\n`delegates` and `events` in your designs."},{"content":"They are similar concepts, and that article will help you make the best decision for your programs.","pos":[5488,5587],"source":" They are similar concepts,\nand that article will help you make the best decision for your\nprograms."},{"pos":[5589,5628],"content":"<bpt id=\"p1\">[</bpt>Next<ept id=\"p1\">](distinguish-delegates-events.md)</ept>","source":"[Next](distinguish-delegates-events.md)"}]}