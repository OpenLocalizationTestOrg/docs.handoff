<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d5e1d6a4e656af58290b2c801a14d0f39190d849</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\unmanaged-api\profiling\profiling-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c1f7b578cc73883bd710cceda9e1e36a703abb7d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">796b11e24347520a9db0c3547e28733fc569f215</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Profiling Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Profiling Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;a name="top"&gt;</bpt><ept id="p1">&lt;/a&gt;</ept> A profiler is a tool that monitors the execution of another application.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The profiler DLL is loaded by the CLR at run time.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Traditional profiling tools focus on measuring the execution of the application.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>That is, they measure the time that is spent in each function or the memory usage of the application over time.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>These uses are all diagnostic in nature.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The profiling API not only measures but also monitors the execution of an application.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For this reason, the profiling API should never be used by the application itself, and the applicationâ€™s execution should not depend on (or be affected by) the profiler.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Profiling a CLR application requires more support than profiling conventionally compiled machine code.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Conventional profiling mechanisms cannot identify or provide useful information about these features.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>JIT compilation at run time provides good opportunities for profiling.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This overview consists of the following sections:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The Profiling API<ept id="p1">](#profiling_api)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Supported Features<ept id="p1">](#support)</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Notification Threads<ept id="p1">](#notification_threads)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Security<ept id="p1">](#security)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Combining Managed and Unmanaged Code in a Code Profiler<ept id="p1">](#combining_managed_unmanaged)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Profiling Unmanaged Code<ept id="p1">](#unmanaged)</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using COM<ept id="p1">](#com)</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Call stacks<ept id="p1">](#call_stacks)</ept></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Callbacks and Stack Depth<ept id="p1">](#callbacks)</ept></source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Related Topics<ept id="p1">](#related_topics)</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The Profiling API</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Typically, the profiling API is used to write a <bpt id="p1">*</bpt>code profiler<ept id="p1">*</ept>, which is a program that monitors the execution of a managed application.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The profiler DLL implements a callback interface (<bpt id="p1">[</bpt>ICorProfilerCallback<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> in the .NET Framework version 1.0 and 1.1, <bpt id="p2">[</bpt>ICorProfilerCallback2<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept> in version 2.0 and later).</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The profiler can call back into the runtime by using the methods in the <bpt id="p1">[</bpt>ICorProfilerInfo<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)</ept> and <bpt id="p2">[</bpt>ICorProfilerInfo2<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)</ept> interfaces to obtain information about the state of the profiled application.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>All user interface and data analysis should be performed in a separate process.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Profiling Architecture<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/media/profilingarch.png "ProfilingArch")</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Profiling architecture</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The Notification Interfaces</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>ICorProfilerCallback<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)</ept> and <bpt id="p2">[</bpt>ICorProfilerCallback2<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept> can be considered notification interfaces.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>These interfaces consist of methods such as <bpt id="p1">[</bpt>ClassLoadStarted<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md)</ept>, <bpt id="p2">[</bpt>ClassLoadFinished<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md)</ept>, and <bpt id="p3">[</bpt>JITCompilationStarted<ept id="p3">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's <ph id="ph1">`ICorProfilerCallback`</ph> or <ph id="ph2">`ICorProfilerCallback2`</ph> interface.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example, a profiler could measure code performance through two notification functions: <bpt id="p1">[</bpt>FunctionEnter2<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md)</ept> and <bpt id="p2">[</bpt>FunctionLeave2<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Information Retrieval Interfaces</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The other main interfaces involved in profiling are <bpt id="p1">[</bpt>ICorProfilerInfo<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)</ept> and <bpt id="p2">[</bpt>ICorProfilerInfo2<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The profiler calls these interfaces as required to obtain more information to help its analysis.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, whenever the CLR calls the <bpt id="p1">[</bpt>FunctionEnter2<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md)</ept> function, it supplies a function identifier.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The profiler can get more information about that function by calling the <bpt id="p1">[</bpt>ICorProfilerInfo2::GetFunctionInfo2<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md)</ept> method to discover the function's parent class, its name, and so on.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Supported Features</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The profiling API provides information about a variety of events and actions that occur in the common language runtime.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The profiling API retrieves information about the following actions and events that occur in the CLR:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>CLR startup and shutdown events.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Application domain creation and shutdown events.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Assembly loading and unloading events.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Module loading and unloading events.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>COM vtable creation and destruction events.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Just-in-time (JIT) compilation and code-pitching events.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Class loading and unloading events.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Thread creation and destruction events.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Function entry and exit events.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Exceptions.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Transitions between managed and unmanaged code execution.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Transitions between different runtime contexts.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Information about runtime suspensions.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Information about the runtime memory heap and garbage collection activity.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The profiling API can be called from any (non-managed) COM-compatible language.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The API is efficient with regard to CPU and memory consumption.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The profiling API is useful to both sampling and non-sampling profilers.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>sampling profiler<ept id="p1">*</ept> inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>non-sampling profiler<ept id="p1">*</ept> is informed of an event synchronously with the thread that causes the event.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Unsupported Functionality</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The profiling API does not support the following functionality:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Unmanaged code, which must be profiled using conventional Win32 methods.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Bounds checking, because the profiling API does not provide this information.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The CLR provides intrinsic support for bounds checking of all managed code.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Remote profiling, which is not supported for the following reasons:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Remote profiling extends execution time.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This is especially true when execution performance is being monitored.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This limits the ability to create a remote code profiler.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Profiling in production environments with high-availability requirements.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The profiling API was created to support development-time diagnostics.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It has not undergone the rigorous testing required to support production environments.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Notification Threads</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In most cases, the thread that generates an event also executes notifications.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Such notifications (for example, <bpt id="p1">[</bpt>FunctionEnter<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md)</ept> and <bpt id="p2">[</bpt>FunctionLeave<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)</ept>) do not need to supply the explicit <ph id="ph1">`ThreadID`</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the <ph id="ph1">`ThreadID`</ph> of the affected thread.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Note that these callbacks are not serialized.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Therefore, in certain cases you can receive an unusual sequence of callbacks.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example, assume that a managed application is spawning two threads that are executing identical code.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In this case, it is possible to receive a <bpt id="p1">[</bpt>ICorProfilerCallback::JITCompilationStarted<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md)</ept> event for some function from one thread and a <ph id="ph1">`FunctionEnter`</ph> callback from the other thread before receiving the <bpt id="p2">[</bpt>ICorProfilerCallback::JITCompilationFinished<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md)</ept> callback.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>In this case, the user will receive a <ph id="ph1">`FunctionEnter`</ph> callback for a function that may not have been fully just-in-time (JIT) compiled yet.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Security</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Profiler authors should take appropriate precautions to avoid security-related issues.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Combining Managed and Unmanaged Code in a Code Profiler</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Although this is possible from a design perspective, the profiling API does not support managed components.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A CLR profiler must be completely unmanaged.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the <bpt id="p1">[</bpt>ICorProfilerCallback4<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md)</ept> interface.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>It is also possible to use the older instrumentation methods to modify MSIL.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the <bpt id="p1">[</bpt>ICorProfilerInfo::GetILFunctionBody<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md)</ept> method).</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This technique can be used for instrumentation and coverage.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Profiling Unmanaged Code</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following functionality is provided:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Enumeration of stack chains.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Determination whether a stack chain corresponds to managed code or native code.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>They are defined in the CorDebug.idl file.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>In the .NET Framework 2.0 and later, you can use the <bpt id="p1">[</bpt>ICorProfilerInfo2::DoStackSnapshot<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md)</ept> method for this functionality.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Using COM</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The reason is to avoid having to set the threading model by using the <bpt id="p1">[</bpt>CoInitialize<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms678543\(v=vs.85\).aspx)</ept> function before the managed application has had a chance to specify its desired threading model.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Similarly, the profiler itself should not call <ph id="ph1">`CoInitialize`</ph>, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Call Stacks</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Stack Snapshot</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>A stack snapshot is a trace of the stack of a thread at an instant in time.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For more information about how to program the profiler to walk managed stacks, see the <bpt id="p1">[</bpt>ICorProfilerInfo2::DoStackSnapshot<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md)</ept> method in this documentation set, and <bpt id="p2">[</bpt>Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=73638)</ept> in the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Shadow Stack</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Using the snapshot method too frequently can quickly create a performance issue.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the <bpt id="p1">[</bpt>FunctionEnter2<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md)</ept>, <bpt id="p2">[</bpt>FunctionLeave2<ept id="p2">](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md)</ept>, <bpt id="p3">[</bpt>FunctionTailcall2<ept id="p3">](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md)</ept>, and <bpt id="p4">[</bpt>ICorProfilerCallback2<ept id="p4">](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)</ept> exception callbacks.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>A shadow stack may obtain function arguments, return values, and information about generic instantiations.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>This information is available only through the shadow stack and may be obtained when control is handed to a function.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>However, this information may not be available later during the run of the function.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Callbacks and Stack Depth</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>A profiler should make sure to use as little stack as possible in response to callbacks.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Back to top<ept id="p1">](#top)</ept></source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Title</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Setting Up a Profiling Environment<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)</ept></source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Profiling Interfaces<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)</ept></source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Describes the unmanaged interfaces that the profiling API uses.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Profiling Global Static Functions<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)</ept></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Describes the unmanaged global static functions that the profiling API uses.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Profiling Enumerations<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)</ept></source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Describes the unmanaged enumerations that the profiling API uses.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Profiling Structures<ept id="p1">](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)</ept></source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Describes the unmanaged structures that the profiling API uses.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>