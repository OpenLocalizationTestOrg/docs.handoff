{"content":"---\ntitle: \"How To: Service Data Partitioning\"\nms.date: \"03/30/2017\"\nms.assetid: 1ccff72e-d76b-4e36-93a2-e51f7b32dc83\n---\n# How To: Service Data Partitioning\nThis topic outlines the basic steps required to partition messages across multiple instances of the same destination service. Service data partitioning is typically used when you need to scale a service in order to provide better quality of service, or when you need to handle requests from different customers in a specific way. For example, messages from high value or \"Gold\" customers may need to be processed at a higher priority than messages from a standard customer.  \n  \n In this example, messages are routed to one of two instances of the regularCalc service. Both instances of the service are identical; however the service represented by the calculator1 endpoint processes messages received from high value customers, the calculator 2 endpoint processes messages from other customers  \n  \n The message sent from the client does not have any unique data that can be used to identify which service instance the message should be routed to. To allow each client to route data to a specific destination service we will implement two service endpoints that will be used to receive messages.  \n  \n> [!NOTE]\n>  While this example uses specific endpoints to partition data, this could also be accomplished using information contained within the message itself such as header or body data.  \n  \n### Implement Service Data Partitioning  \n  \n1.  Create the basic Routing Service configuration by specifying the service endpoints exposed by the service. The following example defines two endpoints, which will be used to receive messages. It also defines the client endpoints, which are used to send messages to the regularCalc service instances.  \n  \n    ```xml  \n    <services>  \n      <service behaviorConfiguration=\"routingConfiguration\"  \n               name=\"System.ServiceModel.Routing.RoutingService\">  \n        <host>  \n          <baseAddresses>  \n            <add baseAddress=\"http://localhost/routingservice/router\" />  \n          </baseAddresses>  \n        </host>  \n        <!--Set up the inbound endpoints for the Routing Service-->  \n        <!--create the endpoints for the calculator service-->  \n        <endpoint address=\"calculator1\"  \n                  binding=\"wsHttpBinding\"  \n                  name=\"calculator1Endpoint\"  \n                  contract=\"System.ServiceModel.Routing.IRequestReplyRouter\" />  \n        <endpoint address=\"calculator2\"  \n                  binding=\"wsHttpBinding\"  \n                  name=\"calculator2Endpoint\"  \n                  contract=\"System.ServiceModel.Routing.IRequestReplyRouter\" />  \n       </service>  \n    </services>  \n    <client>  \n    <!--set up the destination endpoints-->  \n        <endpoint name=\"CalcEndpoint1\"  \n                  address=\"net.tcp://localhost:9090/servicemodelsamples/service/\"  \n                  binding=\"netTcpBinding\"  \n                  contract=\"*\" />  \n  \n        <endpoint name=\"CalcEndpoint2\"  \n                  address=\"net.tcp://localhost:8080/servicemodelsamples/service/\"  \n                  binding=\"netTcpBinding\"  \n                  contract=\"*\" />  \n     </client>  \n    ```  \n  \n2.  Define the filters used to route messages to the destination endpoints.  For this example, the EndpointName filter is used to determine which service endpoint received the message. The following example defines the necessary routing section and filters.  \n  \n    ```xml  \n    <filters>  \n      <!--define the different message filters-->  \n      <!--define endpoint name filters looking for messages that show up on the virtual endpoints-->  \n      <filter name=\"HighPriority\" filterType=\"EndpointName\"  \n              filterData=\"calculator1Endpoint\"/>  \n      <filter name=\"NormalPriority\" filterType=\"EndpointName\"  \n              filterData=\"calculator2Endpoint\"/>  \n    </filters>  \n    ```  \n  \n3.  Define the filter table, which associates each filter with a client endpoint. In this example, the message will be routed based on the specific endpoint it was received over. Since the message can only match one of the two possible filters, there is no need for using filter priority to control to the order in which filters are evaluated.  \n  \n     The following defines the filter table and adds the filters defined earlier.  \n  \n    ```xml  \n    <filterTables>  \n       <filterTable name=\"filterTable1\">  \n         <!--add the filters to the message filter table-->  \n         <add filterName=\"HighPriority\" endpointName=\"CalcEndpoint1\"/>  \n         <add filterName=\"NormalPriority\" endpointName=\"CalcEndpoint2\"/>  \n       </filterTable>  \n    </filterTables>  \n    ```  \n  \n4.  To evaluate incoming messages against the filters contained in the table, you must associate the filter table with the service endpoints by using the routing behavior. The following example demonstrates associating \"filterTable1\" with the service endpoints:  \n  \n    ```xml  \n    <behaviors>  \n      <!--default routing service behavior definition-->  \n      <serviceBehaviors>  \n        <behavior name=\"routingConfiguration\">  \n          <routing filterTableName=\"filterTable1\" />  \n        </behavior>  \n      </serviceBehaviors>  \n    </behaviors>  \n    ```  \n  \n## Example  \n The following is a complete listing of the configuration file.  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\" ?>  \n<!-- Copyright (c) Microsoft Corporation. All rights reserved -->  \n<configuration>  \n  <system.serviceModel>  \n    <services>  \n      <service behaviorConfiguration=\"routingConfiguration\"  \n               name=\"System.ServiceModel.Routing.RoutingService\">  \n        <host>  \n          <baseAddresses>  \n            <add baseAddress=\"http://localhost/routingservice/router\" />  \n          </baseAddresses>  \n        </host>  \n        <!--Set up the inbound endpoints for the Routing Service-->  \n        <!--create the endpoints for the calculator service-->  \n        <endpoint address=\"calculator1\"  \n                  binding=\"wsHttpBinding\"  \n                  name=\"calculator1Endpoint\"  \n                  contract=\"System.ServiceModel.Routing.IRequestReplyRouter\" />  \n        <endpoint address=\"calculator2\"  \n                  binding=\"wsHttpBinding\"  \n                  name=\"calculator2Endpoint\"  \n                  contract=\"System.ServiceModel.Routing.IRequestReplyRouter\" />  \n  \n      </service>  \n    </services>  \n    <behaviors>  \n      <!--default routing service behavior definition-->  \n      <serviceBehaviors>  \n        <behavior name=\"routingConfiguration\">  \n          <routing filterTableName=\"filterTable1\" />  \n        </behavior>  \n      </serviceBehaviors>  \n    </behaviors>  \n  \n    <client>  \n<!--set up the destination endpoints-->  \n      <endpoint name=\"CalcEndpoint1\"  \n                address=\"net.tcp://localhost:9090/servicemodelsamples/service/\"  \n                binding=\"netTcpBinding\"  \n                contract=\"*\" />  \n  \n      <endpoint name=\"CalcEndpoint2\"  \n                address=\"net.tcp://localhost:8080/servicemodelsamples/service/\"  \n                binding=\"netTcpBinding\"  \n                contract=\"*\" />  \n    </client>  \n    <routing>  \n      <!-- use the namespace table element to define a prefix for our custom namespace-->  \n  \n      <filters>  \n        <!--define the different message filters-->  \n        <!--define endpoint name filters looking for messages that show up on the virtual endpoints-->  \n        <filter name=\"HighPriority\" filterType=\"EndpointName\"  \n                filterData=\"calculator1Endpoint\"/>  \n        <filter name=\"NormalPriority\" filterType=\"EndpointName\"  \n                filterData=\"calculator2Endpoint\"/>  \n      </filters>  \n  \n      <filterTables>  \n        <filterTable name=\"filterTable1\">  \n          <!--add the filters to the message filter table-->  \n          <add filterName=\"HighPriority\" endpointName=\"CalcEndpoint1\"/>  \n          <add filterName=\"NormalPriority\" endpointName=\"CalcEndpoint2\"/>  \n        </filterTable>  \n      </filterTables>  \n  \n    </routing>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n## See also\n\n- [Routing Services](../../../../docs/framework/wcf/samples/routing-services.md)\n","nodes":[{"pos":[4,117],"embed":true,"restype":"x-metadata","content":"title: \"How To: Service Data Partitioning\"\nms.date: \"03/30/2017\"\nms.assetid: 1ccff72e-d76b-4e36-93a2-e51f7b32dc83","nodes":[{"content":"How To: Service Data Partitioning","nodes":[{"pos":[0,33],"content":"How To: Service Data Partitioning","nodes":[{"content":"How To: Service Data Partitioning","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[124,157],"content":"How To: Service Data Partitioning","linkify":"How To: Service Data Partitioning","nodes":[{"content":"How To: Service Data Partitioning","pos":[0,33]}]},{"content":"This topic outlines the basic steps required to partition messages across multiple instances of the same destination service.","pos":[158,283]},{"content":"Service data partitioning is typically used when you need to scale a service in order to provide better quality of service, or when you need to handle requests from different customers in a specific way.","pos":[284,487]},{"content":"For example, messages from high value or \"Gold\" customers may need to be processed at a higher priority than messages from a standard customer.","pos":[488,631]},{"content":"In this example, messages are routed to one of two instances of the regularCalc service.","pos":[638,726]},{"content":"Both instances of the service are identical; however the service represented by the calculator1 endpoint processes messages received from high value customers, the calculator 2 endpoint processes messages from other customers","pos":[727,952]},{"content":"The message sent from the client does not have any unique data that can be used to identify which service instance the message should be routed to.","pos":[959,1106]},{"content":"To allow each client to route data to a specific destination service we will implement two service endpoints that will be used to receive messages.","pos":[1107,1254]},{"pos":[1262,1449],"content":"[!NOTE]\n While this example uses specific endpoints to partition data, this could also be accomplished using information contained within the message itself such as header or body data.","leadings":["","> "],"nodes":[{"content":"While this example uses specific endpoints to partition data, this could also be accomplished using information contained within the message itself such as header or body data.","pos":[9,185]}]},{"pos":[1459,1494],"content":"Implement Service Data Partitioning","linkify":"Implement Service Data Partitioning","nodes":[{"content":"Implement Service Data Partitioning","pos":[0,35]}]},{"content":"Create the basic Routing Service configuration by specifying the service endpoints exposed by the service.","pos":[1504,1610]},{"content":"The following example defines two endpoints, which will be used to receive messages.","pos":[1611,1695]},{"content":"It also defines the client endpoints, which are used to send messages to the regularCalc service instances.","pos":[1696,1803]},{"content":"Define the filters used to route messages to the destination endpoints.","pos":[3247,3318]},{"content":"For this example, the EndpointName filter is used to determine which service endpoint received the message.","pos":[3320,3427]},{"content":"The following example defines the necessary routing section and filters.","pos":[3428,3500]},{"content":"Define the filter table, which associates each filter with a client endpoint.","pos":[3952,4029]},{"content":"In this example, the message will be routed based on the specific endpoint it was received over.","pos":[4030,4126]},{"content":"Since the message can only match one of the two possible filters, there is no need for using filter priority to control to the order in which filters are evaluated.","pos":[4127,4291]},{"content":"The following defines the filter table and adds the filters defined earlier.","pos":[4302,4378]},{"content":"To evaluate incoming messages against the filters contained in the table, you must associate the filter table with the service endpoints by using the routing behavior.","pos":[4734,4901]},{"content":"The following example demonstrates associating \"filterTable1\" with the service endpoints:","pos":[4902,4991]},{"pos":[5303,5310],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following is a complete listing of the configuration file.","pos":[5314,5376]},{"pos":[8167,8175],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8179,8257],"content":"<bpt id=\"p1\">[</bpt>Routing Services<ept id=\"p1\">](../../../../docs/framework/wcf/samples/routing-services.md)</ept>","source":"[Routing Services](../../../../docs/framework/wcf/samples/routing-services.md)"}]}