<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="boolean-expressions.md" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">61f0e2910d7c0e157900a2c93cb025245f87881b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\language-features\operators-and-expressions\boolean-expressions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">058183345773156b544a3cf55a07622c7913f2d5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">511c54910be255fd392f3f26c9ca2df9cfdf811f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Boolean Expressions (Visual Basic) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Boolean Expressions (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>Boolean expression<ept id="p1">*</ept> is an expression that evaluates to a value of the <bpt id="p2">[</bpt>Boolean Data Type<ept id="p2">](../../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept>: <ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Boolean`</ph> expressions can take several forms.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The simplest is the direct comparison of the value of a <ph id="ph1">`Boolean`</ph> variable to a <ph id="ph2">`Boolean`</ph> literal, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Two Meanings of the = Operator</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Notice that the assignment statement <ph id="ph1">`newCustomer = True`</ph> looks the same as the expression in the preceding example, but it performs a different function and is used differently.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In the preceding example, the expression <ph id="ph1">`newCustomer = True`</ph> represents a Boolean value, and the <ph id="ph2">`=`</ph> sign is interpreted as a comparison operator.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In a stand-alone statement, the <ph id="ph1">`=`</ph> sign is interpreted as an assignment operator and assigns the value on the right to the variable on the left.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For further information, see <bpt id="p1">[</bpt>Value Comparisons<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/value-comparisons.md)</ept> and <bpt id="p2">[</bpt>Statements<ept id="p2">](../../../../visual-basic/language-reference/statements/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Comparison Operators</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Comparison operators such as <ph id="ph1">`=`</ph>, <ph id="ph2">`&lt;`</ph>, <ph id="ph3">`&gt;`</ph>, <ph id="ph4">`&lt;&gt;`</ph>, <ph id="ph5">`&lt;=`</ph>, and <ph id="ph6">`&gt;=`</ph> produce Boolean expressions by comparing the expression on the left side of the operator to the expression on the right side of the operator and evaluating the result as <ph id="ph7">`True`</ph> or <ph id="ph8">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Because 42 is less than 81, the Boolean expression in the preceding example evaluates to <ph id="ph1">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more information on this kind of expression, see <bpt id="p1">[</bpt>Value Comparisons<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/value-comparisons.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Comparison Operators Combined with Logical Operators</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Comparison expressions can be combined using logical operators to produce more complex Boolean expressions.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of comparison operators in conjunction with a logical operator.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In the preceding example, the value of the overall expression depends on the values of the expressions on each side of the <ph id="ph1">`And`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If both expressions are <ph id="ph1">`True`</ph>, then the overall expression evaluates to <ph id="ph2">`True`</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If either expression is <ph id="ph1">`False`</ph>, then the entire expression evaluates to <ph id="ph2">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Short-Circuiting Operators</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The logical operators <ph id="ph1">`AndAlso`</ph> and <ph id="ph2">`OrElse`</ph> exhibit behavior known as <bpt id="p1">*</bpt>short-circuiting<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A short-circuiting operator evaluates the left operand first.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the left operand determines the value of the entire expression, then program execution proceeds without evaluating the right expression.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In the preceding example, the operator evaluates the left expression, <ph id="ph1">`45 &lt; 12`</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because the left expression evaluates to <ph id="ph1">`False`</ph>, the entire logical expression must evaluate to <ph id="ph2">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Program execution thus skips execution of the code within the <ph id="ph1">`If`</ph> block without evaluating the right expression, <ph id="ph2">`testFunction(3)`</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This example does not call <ph id="ph1">`testFunction()`</ph> because the left expression falsifies the entire expression.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Similarly, if the left expression in a logical expression using <ph id="ph1">`OrElse`</ph> evaluates to <ph id="ph2">`True`</ph>, execution proceeds to the next line of code without evaluating the right expression, because the left expression has already validated the entire expression.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Comparison with Non-Short-Circuiting Operators</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>By contrast, both sides of the logical operator are evaluated when the logical operators <ph id="ph1">`And`</ph> and <ph id="ph2">`Or`</ph> are used.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The preceding example calls <ph id="ph1">`testFunction()`</ph> even though the left expression evaluates to <ph id="ph2">`False`</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Parenthetical Expressions</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You can use parentheses to control the order of evaluation of Boolean expressions.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Expressions enclosed by parentheses evaluate first.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For multiple levels of nesting, precedence is granted to the most deeply nested expressions.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Within parentheses, evaluation proceeds according to the rules of operator precedence.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Operator Precedence in Visual Basic<ept id="p1">](../../../../visual-basic/language-reference/operators/operator-precedence.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Logical and Bitwise Operators in Visual Basic<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Value Comparisons<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/value-comparisons.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Statements<ept id="p1">](../../../../visual-basic/programming-guide/language-features/statements.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Comparison Operators<ept id="p1">](../../../../visual-basic/language-reference/operators/comparison-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Efficient Combination of Operators<ept id="p1">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Operator Precedence in Visual Basic<ept id="p1">](../../../../visual-basic/language-reference/operators/operator-precedence.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Boolean Data Type<ept id="p1">](../../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>