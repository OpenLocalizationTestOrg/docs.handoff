{"content":"---\ntitle: What's new in .NET Core 2.2\ndescription: Learn about the new features found in .NET Core 2.2.\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nauthor: rpetrusha\nms.author: ronpet\nms.date: 12/04/2018\n---\n\n# What's new in .NET Core 2.2\n\n.NET Core 2.2 includes enhancements in application deployment, event handling for runtime services, authentication to Azure SQL databases, JIT compiler performance, and code injection prior to the execution of the `Main` method.\n\n## New deployment mode\n\nStarting with .NET Core 2.2, you can deploy [framework-dependent executables](../deploying/index.md#framework-dependent-executables-fde), which are **.exe** files instead of **.dll** files. Functionally similar to framework-dependent deployments, framework-dependent executables (FDE) still rely on the presence of a shared system-wide version of .NET Core to run. Your app contains only your code and any third-party dependencies. Unlike framework-dependent deployments, FDEs are platform-specific.\n\nThis new deployment mode has the distinct advantage of building an executable instead of a library, which means you can run your app directly without invoking `dotnet` first.\n\n## Core\n\n**Handling events in runtime services**\n\nYou may often want to monitor your application's use of runtime services, such as the GC, JIT, and ThreadPool, to understand how they impact your application. On Windows systems, this is commonly done by monitoring the ETW events of the current process. While this continues to work well, it's not always possible to use ETW if you're running in a low-privilege environment or on Linux or macOS. \n\nStarting with .NET Core 2.2, CoreCLR events can now be consumed using the <xref:System.Diagnostics.Tracing.EventListener?displayProperty=nameWithType> class. These events describe the behavior of such runtime services as GC, JIT, ThreadPool, and interop. These are the same events that are exposed as part of the CoreCLR ETW provider.  This allows for applications to consume these events or use a transport mechanism to send them to a telemetry aggregation service. You can see how to subscribe to events in the following code sample:\n\n```csharp\ninternal sealed class SimpleEventListener : EventListener\n{\n    // Called whenever an EventSource is created.\n    protected override void OnEventSourceCreated(EventSource eventSource)\n    {\n        // Watch for the .NET runtime EventSource and enable all of its events.\n        if (eventSource.Name.Equals(\"Microsoft-Windows-DotNETRuntime\"))\n        {\n            EnableEvents(eventSource, EventLevel.Verbose, (EventKeywords)(-1));\n        }\n    }\n\n    // Called whenever an event is written.\n    protected override void OnEventWritten(EventWrittenEventArgs eventData)\n    {\n        // Write the contents of the event to the console.\n        Console.WriteLine($\"ThreadID = {eventData.OSThreadId} ID = {eventData.EventId} Name = {eventData.EventName}\");\n        for (int i = 0; i < eventData.Payload.Count; i++)\n        {\n            string payloadString = eventData.Payload[i]?.ToString() ?? string.Empty;\n            Console.WriteLine($\"\\tName = \\\"{eventData.PayloadNames[i]}\\\" Value = \\\"{payloadString}\\\"\");\n        }\n        Console.WriteLine(\"\\n\");\n    }\n}\n```\n\nIn addition, .NET Core 2.2 adds the following two properties to the <xref:System.Diagnostics.Tracing.EventWrittenEventArgs> class to provide additional information about ETW events:\n\n- <xref:System.Diagnostics.Tracing.EventWrittenEventArgs.OSThreadId?displayProperty=nameWithType>\n\n- <xref:System.Diagnostics.Tracing.EventWrittenEventArgs.TimeStamp?displayProperty=nameWithType>\n\n## Data\n\n**AAD authentication to Azure SQL databases with the SqlConnection.AccessToken property**\n\nStarting with .NET Core 2.2, an access token issued by Azure Active Directory can be used to authenticate to an Azure SQL database. To support access tokens, the <xref:System.Data.SqlClient.SqlConnection.AccessToken> property has been added to the <xref:System.Data.SqlClient.SqlConnection> class. To take advantage of AAD authentication, download version 4.6 of the System.Data.SqlClient NuGet package. In order to use the feature, you can obtain the access token value using the [Active Directory Authentication Library for .NET](https://github.com/AzureAD/azure-activedirectory-library-for-dotnet) contained in the [`Microsoft.IdentityModel.Clients.ActiveDirectory`](https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/) NuGet package.\n\n## JIT compiler improvements\n\n**Tiered compilation remains an opt-in feature**\n\nIn .NET Core 2.1, the JIT compiler implemented a new compiler technology, *tiered compilation*, as an opt-in feature. The goal of tiered compilation is improved performance. One of the important tasks performed by the JIT compiler is optimizing code execution. For little-used code paths, however, the compiler may spend more time optimizing code than the runtime spends executing unoptimized code. Tiered compilation introduces two stages in JIT compilation:\n\n- A **first tier**, which generates code as quickly as possible.\n\n- A **second tier**, which generates optimized code for those methods that are executed frequently. The second tier of compilation is performed in parallel for enhanced performance.\n\nFor information on the performance improvement that can result from tiered compilation, see [Announcing .NET Core 2.2 Preview 2](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/).\n\nIn .NET Core 2.2 Preview 2, tiered compilation was enabled by default. However, we've decided that we are still not ready to enable tiered compilation by default. So in .NET Core 2.2, tiered compilation continues to be an opt-in feature. For information on opting in to tiered compilation, see [Jit compiler improvements](dotnet-core-2-1.md#jit-compiler-improvements) in [What's new in .NET Core 2.1](dotnet-core-2-1.md).\n\n## Runtime\n\n**Injecting code prior to executing the Main method**\n\nStarting with .NET Core 2.2, you can use a startup hook to inject code prior to running an application's Main method. Startup hooks make it possible for a host to customize the behavior of applications after they have been deployed without needing to recompile or change the application.\n\nWe expect hosting providers to define custom configuration and policy, including settings that potentially influence the load behavior of the main entry point, such as the <xref:System.Runtime.Loader.AssemblyLoadContext?displayProperty=nameWithType> behavior. The hook can be used to set up tracing or telemetry injection, to set up callbacks for handling, or to define other environment-dependent behavior. The hook is separate from the entry point, so that user code doesn't need to be modified.\n\nSee [Host startup hook](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md) for more information.\n\n## See also\n\n- [What's new in .NET Core](index.md)\n- [What's new in ASP.NET Core 2.2](/aspnet/core/release-notes/aspnetcore-2.2)\n- [New features in EF Core 2.2](/ef/core/what-is-new/ef-core-2.2)\n","nodes":[{"pos":[4,193],"embed":true,"restype":"x-metadata","content":"title: What's new in .NET Core 2.2\ndescription: Learn about the new features found in .NET Core 2.2.\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nauthor: rpetrusha\nms.author: ronpet\nms.date: 12/04/2018","nodes":[{"content":"What's new in .NET Core 2.2","nodes":[{"pos":[0,27],"content":"What's new in .NET Core 2.2","nodes":[{"content":"What's new in .NET Core 2.2","pos":[0,27]}]}],"path":["title"],"nosxs":false},{"content":"Learn about the new features found in .NET Core 2.2.","nodes":[{"pos":[0,52],"content":"Learn about the new features found in .NET Core 2.2.","nodes":[{"content":"Learn about the new features found in .NET Core 2.2.","pos":[0,52]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[201,228],"content":"What's new in .NET Core 2.2","linkify":"What's new in .NET Core 2.2","nodes":[{"content":"What's new in .NET Core 2.2","pos":[0,27]}]},{"pos":[230,458],"content":".NET Core 2.2 includes enhancements in application deployment, event handling for runtime services, authentication to Azure SQL databases, JIT compiler performance, and code injection prior to the execution of the <ph id=\"ph1\">`Main`</ph> method.","source":".NET Core 2.2 includes enhancements in application deployment, event handling for runtime services, authentication to Azure SQL databases, JIT compiler performance, and code injection prior to the execution of the `Main` method."},{"pos":[463,482],"content":"New deployment mode","linkify":"New deployment mode","nodes":[{"content":"New deployment mode","pos":[0,19]}]},{"content":"Starting with .NET Core 2.2, you can deploy <bpt id=\"p1\">[</bpt>framework-dependent executables<ept id=\"p1\">](../deploying/index.md#framework-dependent-executables-fde)</ept>, which are <bpt id=\"p2\">**</bpt>.exe<ept id=\"p2\">**</ept> files instead of <bpt id=\"p3\">**</bpt>.dll<ept id=\"p3\">**</ept> files.","pos":[484,673],"source":"Starting with .NET Core 2.2, you can deploy [framework-dependent executables](../deploying/index.md#framework-dependent-executables-fde), which are **.exe** files instead of **.dll** files."},{"content":"Functionally similar to framework-dependent deployments, framework-dependent executables (FDE) still rely on the presence of a shared system-wide version of .NET Core to run.","pos":[674,848]},{"content":"Your app contains only your code and any third-party dependencies.","pos":[849,915]},{"content":"Unlike framework-dependent deployments, FDEs are platform-specific.","pos":[916,983]},{"pos":[985,1159],"content":"This new deployment mode has the distinct advantage of building an executable instead of a library, which means you can run your app directly without invoking <ph id=\"ph1\">`dotnet`</ph> first.","source":"This new deployment mode has the distinct advantage of building an executable instead of a library, which means you can run your app directly without invoking `dotnet` first."},{"pos":[1164,1168],"content":"Core","linkify":"Core","nodes":[{"content":"Core","pos":[0,4]}]},{"pos":[1170,1209],"content":"<bpt id=\"p1\">**</bpt>Handling events in runtime services<ept id=\"p1\">**</ept>","source":"**Handling events in runtime services**"},{"content":"You may often want to monitor your application's use of runtime services, such as the GC, JIT, and ThreadPool, to understand how they impact your application.","pos":[1211,1369]},{"content":" On Windows systems, this is commonly done by monitoring the ETW events of the current process.","pos":[1369,1464]},{"content":" While this continues to work well, it's not always possible to use ETW if you're running in a low-privilege environment or on Linux or macOS.","pos":[1464,1606]},{"content":"Starting with .NET Core 2.2, CoreCLR events can now be consumed using the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Tracing.EventListener?displayProperty=nameWithType&gt;</ph> class.","pos":[1609,1766],"source":"Starting with .NET Core 2.2, CoreCLR events can now be consumed using the <xref:System.Diagnostics.Tracing.EventListener?displayProperty=nameWithType> class."},{"content":"These events describe the behavior of such runtime services as GC, JIT, ThreadPool, and interop.","pos":[1767,1863]},{"content":"These are the same events that are exposed as part of the CoreCLR ETW provider.","pos":[1864,1943]},{"content":"  This allows for applications to consume these events or use a transport mechanism to send them to a telemetry aggregation service.","pos":[1943,2075]},{"content":"You can see how to subscribe to events in the following code sample:","pos":[2076,2144]},{"pos":[3222,3403],"content":"In addition, .NET Core 2.2 adds the following two properties to the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Tracing.EventWrittenEventArgs&gt;</ph> class to provide additional information about ETW events:","source":"In addition, .NET Core 2.2 adds the following two properties to the <xref:System.Diagnostics.Tracing.EventWrittenEventArgs> class to provide additional information about ETW events:"},{"pos":[3605,3609],"content":"Data","linkify":"Data","nodes":[{"content":"Data","pos":[0,4]}]},{"pos":[3611,3700],"content":"<bpt id=\"p1\">**</bpt>AAD authentication to Azure SQL databases with the SqlConnection.AccessToken property<ept id=\"p1\">**</ept>","source":"**AAD authentication to Azure SQL databases with the SqlConnection.AccessToken property**"},{"content":"Starting with .NET Core 2.2, an access token issued by Azure Active Directory can be used to authenticate to an Azure SQL database.","pos":[3702,3833]},{"content":"To support access tokens, the <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlConnection.AccessToken&gt;</ph> property has been added to the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlConnection&gt;</ph> class.","pos":[3834,3999],"source":" To support access tokens, the <xref:System.Data.SqlClient.SqlConnection.AccessToken> property has been added to the <xref:System.Data.SqlClient.SqlConnection> class."},{"content":"To take advantage of AAD authentication, download version 4.6 of the System.Data.SqlClient NuGet package.","pos":[4000,4105]},{"content":"In order to use the feature, you can obtain the access token value using the <bpt id=\"p1\">[</bpt>Active Directory Authentication Library for .NET<ept id=\"p1\">](https://github.com/AzureAD/azure-activedirectory-library-for-dotnet)</ept> contained in the <bpt id=\"p2\">[</bpt><ph id=\"ph1\">`Microsoft.IdentityModel.Clients.ActiveDirectory`</ph><ept id=\"p2\">](https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/)</ept> NuGet package.","pos":[4106,4467],"source":" In order to use the feature, you can obtain the access token value using the [Active Directory Authentication Library for .NET](https://github.com/AzureAD/azure-activedirectory-library-for-dotnet) contained in the [`Microsoft.IdentityModel.Clients.ActiveDirectory`](https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/) NuGet package."},{"pos":[4472,4497],"content":"JIT compiler improvements","linkify":"JIT compiler improvements","nodes":[{"content":"JIT compiler improvements","pos":[0,25]}]},{"pos":[4499,4547],"content":"<bpt id=\"p1\">**</bpt>Tiered compilation remains an opt-in feature<ept id=\"p1\">**</ept>","source":"**Tiered compilation remains an opt-in feature**"},{"content":"In .NET Core 2.1, the JIT compiler implemented a new compiler technology, <bpt id=\"p1\">*</bpt>tiered compilation<ept id=\"p1\">*</ept>, as an opt-in feature.","pos":[4549,4666],"source":"In .NET Core 2.1, the JIT compiler implemented a new compiler technology, *tiered compilation*, as an opt-in feature."},{"content":"The goal of tiered compilation is improved performance.","pos":[4667,4722]},{"content":"One of the important tasks performed by the JIT compiler is optimizing code execution.","pos":[4723,4809]},{"content":"For little-used code paths, however, the compiler may spend more time optimizing code than the runtime spends executing unoptimized code.","pos":[4810,4947]},{"content":"Tiered compilation introduces two stages in JIT compilation:","pos":[4948,5008]},{"pos":[5012,5074],"content":"A <bpt id=\"p1\">**</bpt>first tier<ept id=\"p1\">**</ept>, which generates code as quickly as possible.","source":"A **first tier**, which generates code as quickly as possible."},{"content":"A <bpt id=\"p1\">**</bpt>second tier<ept id=\"p1\">**</ept>, which generates optimized code for those methods that are executed frequently.","pos":[5078,5175],"source":"A **second tier**, which generates optimized code for those methods that are executed frequently."},{"content":"The second tier of compilation is performed in parallel for enhanced performance.","pos":[5176,5257]},{"pos":[5259,5462],"content":"For information on the performance improvement that can result from tiered compilation, see <bpt id=\"p1\">[</bpt>Announcing .NET Core 2.2 Preview 2<ept id=\"p1\">](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/)</ept>.","source":"For information on the performance improvement that can result from tiered compilation, see [Announcing .NET Core 2.2 Preview 2](https://devblogs.microsoft.com/dotnet/announcing-net-core-2-2-preview-2/)."},{"content":"In .NET Core 2.2 Preview 2, tiered compilation was enabled by default.","pos":[5464,5534]},{"content":"However, we've decided that we are still not ready to enable tiered compilation by default.","pos":[5535,5626]},{"content":"So in .NET Core 2.2, tiered compilation continues to be an opt-in feature.","pos":[5627,5701]},{"content":"For information on opting in to tiered compilation, see <bpt id=\"p1\">[</bpt>Jit compiler improvements<ept id=\"p1\">](dotnet-core-2-1.md#jit-compiler-improvements)</ept> in <bpt id=\"p2\">[</bpt>What's new in .NET Core 2.1<ept id=\"p2\">](dotnet-core-2-1.md)</ept>.","pos":[5702,5885],"source":" For information on opting in to tiered compilation, see [Jit compiler improvements](dotnet-core-2-1.md#jit-compiler-improvements) in [What's new in .NET Core 2.1](dotnet-core-2-1.md)."},{"pos":[5890,5897],"content":"Runtime","linkify":"Runtime","nodes":[{"content":"Runtime","pos":[0,7]}]},{"pos":[5899,5952],"content":"<bpt id=\"p1\">**</bpt>Injecting code prior to executing the Main method<ept id=\"p1\">**</ept>","source":"**Injecting code prior to executing the Main method**"},{"content":"Starting with .NET Core 2.2, you can use a startup hook to inject code prior to running an application's Main method.","pos":[5954,6071]},{"content":"Startup hooks make it possible for a host to customize the behavior of applications after they have been deployed without needing to recompile or change the application.","pos":[6072,6241]},{"content":"We expect hosting providers to define custom configuration and policy, including settings that potentially influence the load behavior of the main entry point, such as the<ph id=\"ph1\"> &lt;xref:System.Runtime.Loader.AssemblyLoadContext?displayProperty=nameWithType&gt;</ph><ph id=\"ph2\"> </ph>behavior.","pos":[6243,6502],"source":"We expect hosting providers to define custom configuration and policy, including settings that potentially influence the load behavior of the main entry point, such as the <xref:System.Runtime.Loader.AssemblyLoadContext?displayProperty=nameWithType> behavior."},{"content":"The hook can be used to set up tracing or telemetry injection, to set up callbacks for handling, or to define other environment-dependent behavior.","pos":[6503,6650]},{"content":"The hook is separate from the entry point, so that user code doesn't need to be modified.","pos":[6651,6740]},{"pos":[6742,6884],"content":"See <bpt id=\"p1\">[</bpt>Host startup hook<ept id=\"p1\">](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md)</ept> for more information.","source":"See [Host startup hook](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md) for more information."},{"pos":[6889,6897],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6901,6936],"content":"<bpt id=\"p1\">[</bpt>What's new in .NET Core<ept id=\"p1\">](index.md)</ept>","source":"[What's new in .NET Core](index.md)"},{"pos":[6939,7014],"content":"<bpt id=\"p1\">[</bpt>What's new in ASP.NET Core 2.2<ept id=\"p1\">](/aspnet/core/release-notes/aspnetcore-2.2)</ept>","source":"[What's new in ASP.NET Core 2.2](/aspnet/core/release-notes/aspnetcore-2.2)"},{"pos":[7017,7080],"content":"<bpt id=\"p1\">[</bpt>New features in EF Core 2.2<ept id=\"p1\">](/ef/core/what-is-new/ef-core-2.2)</ept>","source":"[New features in EF Core 2.2](/ef/core/what-is-new/ef-core-2.2)"}]}