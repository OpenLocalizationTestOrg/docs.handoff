{"content":"---\ntitle: \"Overview of synchronization primitives\"\ndescription: \"Learn about .NET thread synchronization primitives used to synchronize access to a shared resource or control thread interaction\"\nms.date: \"10/01/2018\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"synchronization, threads\"\n  - \"threading [.NET],synchronizing threads\"\n  - \"managed threading\"\nms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Overview of synchronization primitives\n\n.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.\n\n> [!IMPORTANT]\n> Use the same synchronization primitive instance to protect every access to a shared resource. Multiple threads can access a resource concurrently if you use different synchronization primitive instances to protect access to a resource or some parts of code access a resource directly.\n\n## WaitHandle class and lightweight synchronization types\n\nMultiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction. Those classes include:\n\n- <xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource. The state of a mutex is signaled if no thread owns it.\n- <xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently. The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.\n- <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.\n- <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.\n- <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.\n\nIn the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.\n\nIn the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:\n\n- <xref:System.Threading.Mutex> (.NET Framework and .NET Core),\n- <xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),\n- <xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).\n\nFor more information, see the <xref:System.Threading.WaitHandle> API reference.\n\nLightweight synchronization types don't rely on underlying operating system handles and typically provide better performance. However, they cannot be used for the inter-process synchronization. Use those types for thread synchronization within one application.\n\nSome of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>. For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.\n\n## Synchronization of access to a shared resource\n\n.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.\n\n### Monitor class\n\nThe <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released. The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock. You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock. Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.\n\nYou can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.\n\nFor more information, see the <xref:System.Threading.Monitor> API reference.\n\n> [!NOTE]\n> Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly. Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `tryâ€¦finally` block to ensure that the acquired lock is always released.\n\n### Mutex class\n\nThe <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource. Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex. Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.\n\nUnlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization. To do that, use a named mutex, which is visible throughout the operating system. To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name. You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.\n  \nFor more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.\n\n### SpinLock structure\n\nThe <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock. When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.\n\nFor more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.\n\n### ReaderWriterLockSlim class\n\nThe <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading. You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation. When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.\n  \nFor more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.\n\n### Semaphore and SemaphoreSlim classes\n\nThe <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently. Additional threads that request the resource wait until any thread releases the semaphore. Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.\n\n<xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.\n\nOn Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization. To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method. <xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.\n\nFor more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.\n\n## Thread interaction, or signaling\n\nThread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed. For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes. The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.\n\nThis section describes additional signaling constructs provided by .NET.\n\n### EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes\n\nThe <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.\n\nA synchronization event can be either in an unsignaled or signaled state. When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled. The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.\n\nThe behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:\n\n- An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread. It's like a turnstile that allows only one thread through each time it's signaled. The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.\n- An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called. It's like a gate that is closed until signaled and then stays open until someone closes it. The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior. The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.\n\nOn Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization. To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.\n\nFor more information, see the [EventWaitHandle](eventwaithandle.md) article. For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.\n\n### CountdownEvent class\n\nThe <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero. While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked. Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.\n\nIn contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.\n\nFor more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.\n\n### Barrier class\n\nThe <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier. A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier. When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.\n\nYou might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.\n\nFor more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.\n\n## Interlocked class\n\nThe <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable. Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.\n\nFor more information, see the <xref:System.Threading.Interlocked> API reference.\n\n## SpinWait structure\n\nThe <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting. You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread. By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.\n\nFor more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.\n\n## See also\n\n- <xref:System.Collections.Concurrent?displayProperty=nameWithType>\n- [Thread-safe collections](../collections/thread-safe/index.md)\n- [Threading objects and features](threading-objects-and-features.md)\n","nodes":[{"pos":[4,459],"embed":true,"restype":"x-metadata","content":"title: \"Overview of synchronization primitives\"\ndescription: \"Learn about .NET thread synchronization primitives used to synchronize access to a shared resource or control thread interaction\"\nms.date: \"10/01/2018\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"synchronization, threads\"\n  - \"threading [.NET],synchronizing threads\"\n  - \"managed threading\"\nms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Overview of synchronization primitives","nodes":[{"pos":[0,38],"content":"Overview of synchronization primitives","nodes":[{"content":"Overview of synchronization primitives","pos":[0,38]}]}],"path":["title"],"nosxs":false},{"content":"Learn about .NET thread synchronization primitives used to synchronize access to a shared resource or control thread interaction","nodes":[{"pos":[0,128],"content":"Learn about .NET thread synchronization primitives used to synchronize access to a shared resource or control thread interaction","nodes":[{"content":"Learn about .NET thread synchronization primitives used to synchronize access to a shared resource or control thread interaction","pos":[0,128]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[466,504],"content":"Overview of synchronization primitives","linkify":"Overview of synchronization primitives","nodes":[{"content":"Overview of synchronization primitives","pos":[0,38]}]},{"content":".NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.","pos":[506,630]},{"pos":[634,933],"content":"[!IMPORTANT]\nUse the same synchronization primitive instance to protect every access to a shared resource. Multiple threads can access a resource concurrently if you use different synchronization primitive instances to protect access to a resource or some parts of code access a resource directly.","leadings":["","> "],"nodes":[{"content":"Use the same synchronization primitive instance to protect every access to a shared resource. Multiple threads can access a resource concurrently if you use different synchronization primitive instances to protect access to a resource or some parts of code access a resource directly.","pos":[13,297],"nodes":[{"content":"Use the same synchronization primitive instance to protect every access to a shared resource.","pos":[0,93]},{"content":"Multiple threads can access a resource concurrently if you use different synchronization primitive instances to protect access to a resource or some parts of code access a resource directly.","pos":[94,284]}]}]},{"pos":[938,992],"content":"WaitHandle class and lightweight synchronization types","linkify":"WaitHandle class and lightweight synchronization types","nodes":[{"content":"WaitHandle class and lightweight synchronization types","pos":[0,54]}]},{"content":"Multiple .NET synchronization primitives derive from the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle?displayProperty=nameWithType&gt;</ph> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.","pos":[994,1244],"source":"Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction."},{"content":"Those classes include:","pos":[1245,1267]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Mutex?displayProperty=nameWithType&gt;</ph>, which grants exclusive access to a shared resource.","pos":[1271,1382],"source":"<xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource."},{"content":"The state of a mutex is signaled if no thread owns it.","pos":[1383,1437]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Semaphore?displayProperty=nameWithType&gt;</ph>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.","pos":[1440,1609],"source":"<xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently."},{"content":"The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.","pos":[1610,1730]},{"pos":[1733,1903],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle?displayProperty=nameWithType&gt;</ph>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.","source":"<xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state."},{"pos":[1906,2138],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent?displayProperty=nameWithType&gt;</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.","source":"<xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread."},{"pos":[2141,2393],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent?displayProperty=nameWithType&gt;</ph>, which derives from <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and, when signaled, stays in a signaled state until the <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","source":"<xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."},{"pos":[2395,2639],"content":"In the .NET Framework, because <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> derives from <ph id=\"ph2\">&lt;xref:System.MarshalByRefObject?displayProperty=nameWithType&gt;</ph>, these types can be used to synchronize the activities of threads across application domain boundaries.","source":"In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries."},{"content":"In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:","pos":[2641,2854]},{"pos":[2858,2919],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> (.NET Framework and .NET Core),","source":"<xref:System.Threading.Mutex> (.NET Framework and .NET Core),"},{"pos":[2922,2998],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> (.NET Framework and .NET Core on Windows),","source":"<xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),"},{"pos":[3001,3083],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> (.NET Framework and .NET Core on Windows).","source":"<xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows)."},{"pos":[3085,3164],"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> API reference.","source":"For more information, see the <xref:System.Threading.WaitHandle> API reference."},{"content":"Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.","pos":[3166,3291]},{"content":"However, they cannot be used for the inter-process synchronization.","pos":[3292,3359]},{"content":"Use those types for thread synchronization within one application.","pos":[3360,3426]},{"content":"Some of those types are alternatives to the types derived from <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph>.","pos":[3428,3526],"source":"Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>."},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> is a lightweight alternative to <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph>.","pos":[3527,3644],"source":" For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>."},{"pos":[3649,3695],"content":"Synchronization of access to a shared resource","linkify":"Synchronization of access to a shared resource","nodes":[{"content":"Synchronization of access to a shared resource","pos":[0,46]}]},{"content":".NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.","pos":[3697,3808]},{"pos":[3814,3827],"content":"Monitor class","linkify":"Monitor class","nodes":[{"content":"Monitor class","pos":[0,13]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor?displayProperty=nameWithType&gt;</ph> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.","pos":[3829,4030],"source":"The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource."},{"content":"While a lock is held, the thread that holds the lock can again acquire and release the lock.","pos":[4031,4123]},{"content":"Any other thread is blocked from acquiring the lock and the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method waits until the lock is released.","pos":[4124,4294],"source":" Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method acquires a released lock.","pos":[4295,4372],"source":" The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock."},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph> method to specify the amount of time during which a thread attempts to acquire a lock.","pos":[4373,4553],"source":" You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock."},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class has thread affinity, the thread that acquired a lock must release the lock by calling the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[4554,4770],"source":" Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method."},{"pos":[4772,5096],"content":"You can coordinate the interaction of threads that acquire a lock on the same object by using the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> methods.","source":"You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods."},{"pos":[5098,5174],"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> API reference.","source":"For more information, see the <xref:System.Threading.Monitor> API reference."},{"pos":[5178,5725],"content":"[!NOTE]\nUse the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly. Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `tryâ€¦finally` block to ensure that the acquired lock is always released.","leadings":["","> "],"nodes":[{"content":"Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly. Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `tryâ€¦finally` block to ensure that the acquired lock is always released.","pos":[8,545],"nodes":[{"content":"Use the <bpt id=\"p1\">[</bpt>lock<ept id=\"p1\">](../../csharp/language-reference/keywords/lock-statement.md)</ept> statement in C# and the <bpt id=\"p2\">[</bpt>SyncLock<ept id=\"p2\">](../../visual-basic/language-reference/statements/synclock-statement.md)</ept> statement in Visual Basic to synchronize access to a shared resource instead of using the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class directly.","pos":[0,319],"source":"Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly."},{"content":"Those statements are implemented by using the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods and a <ph id=\"ph3\">`tryâ€¦finally`</ph> block to ensure that the acquired lock is always released.","pos":[320,537],"source":" Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `tryâ€¦finally` block to ensure that the acquired lock is always released."}]}]},{"pos":[5731,5742],"content":"Mutex class","linkify":"Mutex class","nodes":[{"content":"Mutex class","pos":[0,11]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Mutex?displayProperty=nameWithType&gt;</ph> class, like <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph>, grants exclusive access to a shared resource.","pos":[5744,5897],"source":"The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource."},{"content":"Use one of the <bpt id=\"p1\">[</bpt>Mutex.WaitOne<ept id=\"p1\">](&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;)</ept> method overloads to request the ownership of a mutex.","pos":[5898,6058],"source":" Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex."},{"content":"Like <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> has thread affinity and the thread that acquired a mutex must release it by calling the <ph id=\"ph3\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[6059,6297],"source":" Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method."},{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> class can be used for inter-process synchronization.","pos":[6299,6425],"source":"Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization."},{"content":"To do that, use a named mutex, which is visible throughout the operating system.","pos":[6426,6506]},{"content":"To create a named mutex instance, use a <bpt id=\"p1\">[</bpt>Mutex constructor<ept id=\"p1\">](&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;)</ept> that specifies a name.","pos":[6507,6631],"source":" To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name."},{"content":"You also can call the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType&gt;</ph> method to open an existing named system mutex.","pos":[6632,6775],"source":" You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex."},{"pos":[6779,6891],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Mutexes<ept id=\"p1\">](mutexes.md)</ept> article and the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> API reference.","source":"For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference."},{"pos":[6897,6915],"content":"SpinLock structure","linkify":"SpinLock structure","nodes":[{"content":"SpinLock structure","pos":[0,18]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock?displayProperty=nameWithType&gt;</ph> structure, like <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph>, grants exclusive access to a shared resource based on the availability of a lock.","pos":[6917,7113],"source":"The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.","pos":[7114,7273],"source":" When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available."},{"pos":[7275,7444],"content":"For more information about the benefits and drawbacks of using spin lock, see the <bpt id=\"p1\">[</bpt>SpinLock<ept id=\"p1\">](spinlock.md)</ept> article and the <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> API reference.","source":"For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference."},{"pos":[7450,7476],"content":"ReaderWriterLockSlim class","linkify":"ReaderWriterLockSlim class","nodes":[{"content":"ReaderWriterLockSlim class","pos":[0,26]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType&gt;</ph> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.","pos":[7478,7697],"source":"The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading."},{"content":"You might want to use <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.","pos":[7698,7914],"source":" You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation."},{"content":"When a thread requests exclusive access (for example, by calling the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType&gt;</ph> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.","pos":[7915,8225],"source":" When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock."},{"pos":[8229,8318],"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> API reference.","source":"For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference."},{"pos":[8324,8359],"content":"Semaphore and SemaphoreSlim classes","linkify":"Semaphore and SemaphoreSlim classes","nodes":[{"content":"Semaphore and SemaphoreSlim classes","pos":[0,35]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType&gt;</ph> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.","pos":[8361,8605],"source":"The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently."},{"content":"Additional threads that request the resource wait until any thread releases the semaphore.","pos":[8606,8696]},{"content":"Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.","pos":[8697,8815]},{"pos":[8817,8995],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> is a lightweight alternative to <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> and can be used only for synchronization within a single process boundary.","source":"<xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary."},{"content":"On Windows, you can use <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> for the inter-process synchronization.","pos":[8997,9093],"source":"On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization."},{"content":"To do that, create a <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> instance that represents a named system semaphore by using one of the <bpt id=\"p1\">[</bpt>Semaphore constructors<ept id=\"p1\">](&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;)</ept> that specifies a name or the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[9094,9405],"source":" To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> doesn't support named system semaphores.","pos":[9406,9484],"source":"<xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores."},{"pos":[9486,9683],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Semaphore and SemaphoreSlim<ept id=\"p1\">](semaphore-and-semaphoreslim.md)</ept> article and the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreSlim&gt;</ph> API reference.","source":"For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference."},{"pos":[9688,9720],"content":"Thread interaction, or signaling","linkify":"Thread interaction, or signaling","nodes":[{"content":"Thread interaction, or signaling","pos":[0,32]}]},{"content":"Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.","pos":[9722,9869]},{"content":"For example, if thread A calls the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType&gt;</ph> method of thread B, thread A is blocked until thread B completes.","pos":[9870,10038],"source":" For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes."},{"content":"The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.","pos":[10039,10246]},{"content":"This section describes additional signaling constructs provided by .NET.","pos":[10248,10320]},{"pos":[10326,10409],"content":"EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes","linkify":"EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes","nodes":[{"content":"EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes","pos":[0,83]}]},{"pos":[10411,10532],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle?displayProperty=nameWithType&gt;</ph> class represents a thread synchronization event.","source":"The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event."},{"content":"A synchronization event can be either in an unsignaled or signaled state.","pos":[10534,10607]},{"content":"When the state of an event is unsignaled, a thread that calls the event's <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?&gt;</ph> overload is blocked until an event is signaled.","pos":[10608,10776],"source":" When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method sets the state of an event to signaled.","pos":[10777,10903],"source":" The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled."},{"pos":[10905,11013],"content":"The behavior of an <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode:","source":"The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:"},{"content":"An <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag resets automatically after releasing a single waiting thread.","pos":[11017,11221],"source":"An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread."},{"content":"It's like a turnstile that allows only one thread through each time it's signaled.","pos":[11222,11304]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent?displayProperty=nameWithType&gt;</ph> class, which derives from <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, represents that behavior.","pos":[11305,11469],"source":" The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id=\"ph2\">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag remains signaled until its <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","pos":[11472,11710],"source":"An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."},{"content":"It's like a gate that is closed until signaled and then stays open until someone closes it.","pos":[11711,11802]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent?displayProperty=nameWithType&gt;</ph> class, which derives from <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, represents that behavior.","pos":[11803,11969],"source":" The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType&gt;</ph> class is a lightweight alternative to <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>.","pos":[11970,12127],"source":" The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>."},{"content":"On Windows, you can use <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> for the inter-process synchronization.","pos":[12129,12231],"source":"On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization."},{"content":"To do that, create a <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> instance that represents a named system synchronization event by using one of the <bpt id=\"p1\">[</bpt>EventWaitHandle constructors<ept id=\"p1\">](&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;)</ept> that specifies a name or the <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[12232,12579],"source":" To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method."},{"content":"For more information, see the <bpt id=\"p1\">[</bpt>EventWaitHandle<ept id=\"p1\">](eventwaithandle.md)</ept> article.","pos":[12581,12657],"source":"For more information, see the [EventWaitHandle](eventwaithandle.md) article."},{"content":"For the API reference, see <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.ManualResetEventSlim&gt;</ph>.","pos":[12658,12857],"source":" For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>."},{"pos":[12863,12883],"content":"CountdownEvent class","linkify":"CountdownEvent class","nodes":[{"content":"CountdownEvent class","pos":[0,20]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent?displayProperty=nameWithType&gt;</ph> class represents an event that becomes set when its count is zero.","pos":[12885,13023],"source":"The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero."},{"content":"While <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType&gt;</ph> is greater than zero, a thread that calls <ph id=\"ph2\">&lt;xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType&gt;</ph> is blocked.","pos":[13024,13240],"source":" While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked."},{"content":"Call <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType&gt;</ph> to decrement an event's count.","pos":[13241,13354],"source":" Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count."},{"pos":[13356,13655],"content":"In contrast to <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEventSlim&gt;</ph>, which you can use to unblock multiple threads with a signal from one thread, you can use <ph id=\"ph3\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> to unblock one or more threads with signals from multiple threads.","source":"In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads."},{"pos":[13657,13792],"content":"For more information, see the <bpt id=\"p1\">[</bpt>CountdownEvent<ept id=\"p1\">](countdownevent.md)</ept> article and the <ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent&gt;</ph> API reference.","source":"For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference."},{"pos":[13798,13811],"content":"Barrier class","linkify":"Barrier class","nodes":[{"content":"Barrier class","pos":[0,13]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Barrier?displayProperty=nameWithType&gt;</ph> class represents a thread execution barrier.","pos":[13813,13922],"source":"The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier."},{"content":"A thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> method signals that it reached the barrier and waits until other participant threads reach the barrier.","pos":[13923,14128],"source":" A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier."},{"content":"When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.","pos":[14129,14237]},{"pos":[14239,14395],"content":"You might use <ph id=\"ph1\">&lt;xref:System.Threading.Barrier&gt;</ph> when one or more threads require the results of other threads before proceeding to the next computation phase.","source":"You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase."},{"pos":[14397,14511],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Barrier<ept id=\"p1\">](barrier.md)</ept> article and the <ph id=\"ph1\">&lt;xref:System.Threading.Barrier&gt;</ph> API reference.","source":"For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference."},{"pos":[14516,14533],"content":"Interlocked class","linkify":"Interlocked class","nodes":[{"content":"Interlocked class","pos":[0,17]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked?displayProperty=nameWithType&gt;</ph> class provides static methods that perform simple atomic operations on a variable.","pos":[14535,14686],"source":"The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable."},{"content":"Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.","pos":[14687,14863]},{"pos":[14865,14945],"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> API reference.","source":"For more information, see the <xref:System.Threading.Interlocked> API reference."},{"pos":[14950,14968],"content":"SpinWait structure","linkify":"SpinWait structure","nodes":[{"content":"SpinWait structure","pos":[0,18]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.SpinWait?displayProperty=nameWithType&gt;</ph> structure provides support for spin-based waiting.","pos":[14970,15086],"source":"The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting."},{"content":"You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.","pos":[15087,15335]},{"content":"By using <ph id=\"ph1\">&lt;xref:System.Threading.SpinWait&gt;</ph>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.","pos":[15336,15550],"source":" By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time."},{"pos":[15552,15669],"content":"For more information, see the <bpt id=\"p1\">[</bpt>SpinWait<ept id=\"p1\">](spinwait.md)</ept> article and the <ph id=\"ph1\">&lt;xref:System.Threading.SpinWait&gt;</ph> API reference.","source":"For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference."},{"pos":[15674,15682],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[15754,15816],"content":"<bpt id=\"p1\">[</bpt>Thread-safe collections<ept id=\"p1\">](../collections/thread-safe/index.md)</ept>","source":"[Thread-safe collections](../collections/thread-safe/index.md)"},{"pos":[15819,15886],"content":"<bpt id=\"p1\">[</bpt>Threading objects and features<ept id=\"p1\">](threading-objects-and-features.md)</ept>","source":"[Threading objects and features](threading-objects-and-features.md)"}]}