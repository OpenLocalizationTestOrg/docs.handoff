{"content":"---\ntitle: \"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: b933dfe6-7833-40cb-aad8-40842dc3034f\ncaps.latest.revision: 6\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method\n[Supported in the .NET Framework 4.6 and later versions]  \n  \n Returns an enumerator to all the methods that          are defined in  a given NGen module and          inline a given method.  \n  \n## Syntax  \n  \n```  \n  \nHRESULT EnumNgenModuleMethodsInliningThisMethod(  \n        [in] ModuleID inlinersModuleId,  \n        [in] ModuleID inlineeModuleId,  \n        [in] mdMethodDef inlineeMethodId,  \n        [out] BOOL *incompleteData,  \n        [out] ICorProfilerMethodEnum** ppEnum  \n);  \n  \n```  \n  \n#### Parameters  \n `inlinersModuleId`  \n [in] The identifier of an NGen module.  \n  \n `inlineeModuleId`  \n [in] The identifier of a module that defines `inlineeMethodId`. See the Remarks section for more information.  \n  \n `inlineeMethodId`  \n [in] The identifier of an inlined method. See the Remarks section for more information.  \n  \n `incompleteData`  \n [out] A flag that indicates whether `ppEnum` contains all methods inlining a given method.  See the Remarks section for more information.  \n  \n `ppEnum`  \n [out] A pointer to the address of an enumerator  \n  \n## Remarks  \n `inlineeModuleId` and `inlineeMethodId` together form the full identifier for the method that might be inlined. For example, assume module `A` defines a method `Simple.Add`:  \n  \n```csharp  \n  \nSimple.Add(int a, int b)   \n{ return a + b; }  \n  \n```  \n  \n and module Bdefines `Fancy.AddTwice`:  \n  \n```csharp  \n  \nFancy.AddTwice(int a, int b)   \n{ return Simple.Add(a,b) + Simple.Add(a,b); }  \n  \n```  \n  \n Lets also assume that `Fancy.AddTwice` inlines the call to `SimpleAdd`. A profiler could use this enumerator to find all methods defined in module B which inline `Simple.Add`, and the result would enumerate `AddTwice`.  `inlineeModuleId` is the identifier of module `A`,   and `inlineeeMethodId` is the identifier of `Simple.Add(int a, int b)`.  \n  \n If `incompleteData` is true after the function returns, the enumerator does not contain all methods inlining a given method. This can happen when one or more direct or indirect dependencies of inliners module haven't been loaded yet. If a profiler needs accurate data, it should retry later when more modules are loaded, preferably on each module load.  \n  \n The `EnumNgenModuleMethodsInliningThisMethod` method can be used to work around limitations on inlining for ReJIT. ReJIT lets a profiler change the implementation of a method and then create new code for it on the fly. For example, we could change `Simple.Add` as follows:  \n  \n```csharp  \n  \nSimple.Add(int a, int b)   \n{ return 42; }  \n  \n```  \n  \n However because `Fancy.AddTwice` has already inlined `Simple.Add`, it continues to have the same behavior as before. To work around that limitation, the caller has to search for all methods in all modules that inline `Simple.Add` and use `ICorProfilerInfo5::RequestRejit` on each of those methods. When the methods are re-compiled, they will have the new behavior of `Simple.Add` instead of the old behavior.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorProf.idl, CorProf.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v46plus](../../../../includes/net-current-v46plus-md.md)]  \n  \n## See Also  \n [ICorProfilerInfo6 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo6-interface.md)","nodes":[{"pos":[4,412],"embed":true,"restype":"x-metadata","content":"title: \"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"C++\"\nms.assetid: b933dfe6-7833-40cb-aad8-40842dc3034f\ncaps.latest.revision: 6\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"","nodes":[{"content":"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method | Microsoft Docs","nodes":[{"pos":[0,82],"content":"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method | Microsoft Docs","nodes":[{"content":"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method | Microsoft Docs","pos":[0,82]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[419,484],"content":"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method","linkify":"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method","nodes":[{"content":"ICorProfilerInfo6::EnumNgenModuleMethodsInliningThisMethod Method","pos":[0,65]}]},{"content":"[Supported in the .NET Framework 4.6 and later versions]","pos":[485,541]},{"content":"Returns an enumerator to all the methods that          are defined in  a given NGen module and          inline a given method.","pos":[548,674]},{"pos":[683,689],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[990,1000],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] The identifier of an NGen module.","pos":[1026,1064]},{"content":"[in] The identifier of a module that defines <ph id=\"ph1\">`inlineeMethodId`</ph>.","pos":[1092,1155],"source":"[in] The identifier of a module that defines `inlineeMethodId`."},{"content":"See the Remarks section for more information.","pos":[1156,1201]},{"content":"[in] The identifier of an inlined method.","pos":[1229,1270]},{"content":"See the Remarks section for more information.","pos":[1271,1316]},{"content":"[out] A flag that indicates whether <ph id=\"ph1\">`ppEnum`</ph> contains all methods inlining a given method.","pos":[1343,1433],"source":"[out] A flag that indicates whether `ppEnum` contains all methods inlining a given method."},{"content":"See the Remarks section for more information.","pos":[1435,1480]},{"content":"[out] A pointer to the address of an enumerator","pos":[1499,1546]},{"pos":[1555,1562],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`inlineeModuleId`</ph> and <ph id=\"ph2\">`inlineeMethodId`</ph> together form the full identifier for the method that might be inlined.","pos":[1566,1677],"source":"`inlineeModuleId` and `inlineeMethodId` together form the full identifier for the method that might be inlined."},{"content":"For example, assume module <ph id=\"ph1\">`A`</ph> defines a method <ph id=\"ph2\">`Simple.Add`</ph>:","pos":[1678,1739],"source":" For example, assume module `A` defines a method `Simple.Add`:"},{"pos":[1821,1858],"content":"and module Bdefines <ph id=\"ph1\">`Fancy.AddTwice`</ph>:","source":"and module Bdefines `Fancy.AddTwice`:"},{"content":"Lets also assume that <ph id=\"ph1\">`Fancy.AddTwice`</ph> inlines the call to <ph id=\"ph2\">`SimpleAdd`</ph>.","pos":[1972,2043],"source":"Lets also assume that `Fancy.AddTwice` inlines the call to `SimpleAdd`."},{"content":"A profiler could use this enumerator to find all methods defined in module B which inline <ph id=\"ph1\">`Simple.Add`</ph>, and the result would enumerate <ph id=\"ph2\">`AddTwice`</ph>.","pos":[2044,2190],"source":" A profiler could use this enumerator to find all methods defined in module B which inline `Simple.Add`, and the result would enumerate `AddTwice`."},{"content":"<ph id=\"ph1\">`inlineeModuleId`</ph> is the identifier of module <ph id=\"ph2\">`A`</ph>,   and <ph id=\"ph3\">`inlineeeMethodId`</ph> is the identifier of <ph id=\"ph4\">`Simple.Add(int a, int b)`</ph>.","pos":[2192,2316],"source":"`inlineeModuleId` is the identifier of module `A`,   and `inlineeeMethodId` is the identifier of `Simple.Add(int a, int b)`."},{"content":"If <ph id=\"ph1\">`incompleteData`</ph> is true after the function returns, the enumerator does not contain all methods inlining a given method.","pos":[2323,2447],"source":"If `incompleteData` is true after the function returns, the enumerator does not contain all methods inlining a given method."},{"content":"This can happen when one or more direct or indirect dependencies of inliners module haven't been loaded yet.","pos":[2448,2556]},{"content":"If a profiler needs accurate data, it should retry later when more modules are loaded, preferably on each module load.","pos":[2557,2675]},{"content":"The <ph id=\"ph1\">`EnumNgenModuleMethodsInliningThisMethod`</ph> method can be used to work around limitations on inlining for ReJIT.","pos":[2682,2796],"source":"The `EnumNgenModuleMethodsInliningThisMethod` method can be used to work around limitations on inlining for ReJIT."},{"content":"ReJIT lets a profiler change the implementation of a method and then create new code for it on the fly.","pos":[2797,2900]},{"content":"For example, we could change <ph id=\"ph1\">`Simple.Add`</ph> as follows:","pos":[2901,2954],"source":" For example, we could change `Simple.Add` as follows:"},{"content":"However because <ph id=\"ph1\">`Fancy.AddTwice`</ph> has already inlined <ph id=\"ph2\">`Simple.Add`</ph>, it continues to have the same behavior as before.","pos":[3033,3149],"source":"However because `Fancy.AddTwice` has already inlined `Simple.Add`, it continues to have the same behavior as before."},{"content":"To work around that limitation, the caller has to search for all methods in all modules that inline <ph id=\"ph1\">`Simple.Add`</ph> and use <ph id=\"ph2\">`ICorProfilerInfo5::RequestRejit`</ph> on each of those methods.","pos":[3150,3330],"source":" To work around that limitation, the caller has to search for all methods in all modules that inline `Simple.Add` and use `ICorProfilerInfo5::RequestRejit` on each of those methods."},{"content":"When the methods are re-compiled, they will have the new behavior of <ph id=\"ph1\">`Simple.Add`</ph> instead of the old behavior.","pos":[3331,3441],"source":" When the methods are re-compiled, they will have the new behavior of `Simple.Add` instead of the old behavior."},{"pos":[3450,3462],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[3466,3570],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[3577,3611],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorProf.idl, CorProf.h","source":"**Header:** CorProf.idl, CorProf.h"},{"pos":[3618,3643],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[3650,3758],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept> <ph id=\"ph1\">[!INCLUDE[net_current_v46plus](../../../../includes/net-current-v46plus-md.md)]</ph>","source":"**.NET Framework Versions:** [!INCLUDE[net_current_v46plus](../../../../includes/net-current-v46plus-md.md)]"},{"pos":[3767,3775],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[3779,3891],"content":"<bpt id=\"p1\">[</bpt>ICorProfilerInfo6 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo6-interface.md)</ept>","source":"[ICorProfilerInfo6 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo6-interface.md)"}]}