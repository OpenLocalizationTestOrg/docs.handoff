{"content":"---\ntitle: Tuples | C# Guide\ndescription: Learn about unnamed and named tuple types in C#\nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nms-author: wiwagn\nms.date: 11/23/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa\n---\n\n# C# Tuple types #\n\nC# Tuples are types that you define using a lightweight syntax. The advantages\ninclude a simpler syntax, rules for conversions based on number (referred to as \"arity\")\nand types of fields, and\nconsistent rules for copies and assignments. As a tradeoff, Tuples do not\nsupport some of the object oriented idioms associated with inheritance. You\ncan get an overview in the section on [Tuples in the What's new in C# 7](whats-new/csharp-7.md#tuples) topic.\n\nIn this topic, you'll learn the language rules governing Tuples in C# 7,\ndifferent ways to use them, and initial guidance on working with Tuples.\n\n> [!NOTE]\n> The new tuples features require the `System.ValueTuple` type. For Visual Studio 2017,\n> you must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery.\n> Without this package you may get a compilation error similar to `error CS8179: Predefined type 'System.ValueTuple``2' is not defined or imported`\n> or `error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found.`\n\nLet's start with the reasons for adding new Tuple support. Methods return\na single object. Tuples enable you to package multiple values in that single\nobject more easily. \n\nThe .NET Framework already has generic `Tuple` classes. These classes,\nhowever, had two major limitations. For one, the `Tuple` classes named\ntheir fields `Item1`, `Item2`, and so on. Those names carry no semantic\ninformation. Using these `Tuple` types does not enable communicating the\nmeaning of each of the fields. Another concern is that the `Tuple` classes are\nreference types. Using one of the `Tuple` types means allocating objects. On hot\npaths, this can have a measurable impact on your application's performance.\n\nTo avoid those deficiencies, you could create a `class` or a `struct`\nto carry multiple fields. Unfortunately, that's more work for you,\nand it obscures your design intent. Making a `struct` or `class` implies\nthat you are defining a type with both data and behavior. Many times, you\nsimply want to store multiple values in a single object.\n\nThe new language features for tuples, combined with a new set of\nclasses in the framework, address these deficiencies. These new tuples\nuse the new `ValueTuple` generic structs. As the name implies, this type is a `struct`\ninstead of a `class`. There are different versions of this struct to support\ntuples with different numbers of fields. New language support provides semantic\nnames for the fields of the tuple type, along with features to make constructing\nor accessing tuple fields easy.\n\nThe language features and the `ValueTuple` generic structs enforce the rule that\nyou cannot add any behavior (methods) to these tuple types.\nAll the `ValueTuple` types are *mutable structs*. Each member field is a\npublic field. That makes them very lightweight. However, that means tuples\nshould not be used where immutability is important.\n\nTuples are both simpler and more flexible data containers than `class` and\n`struct` types. Let's explore those differences.\n\n## Named and unnamed tuples\n\nThe `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3` and so on,\nsimiler to the properties defined in the existing `Tuple` types.\nThese names are the only names you can use for *unnamed tuples*. When you\ndo not provide any alternative field names to a tuple, you've created an\nunnamed tuple:\n\n[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple \"Unnamed tuple\")]\n\nHowever, when you initialize a tuple, you can use new language features\nthat give better names to each field. Doing so creates a *named tuple*.\nNamed tuples still have fields named `Item1`, `Item2`, `Item3` and so on.\nBut they also have synonyms for any of those fields that you have named.\nYou create a named tuple by specifying the names for each field. One way\nis to specify the names as part of the tuple initialization:\n\n[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple \"Named tuple\")]\n\nThese synonyms are handled by the compiler and the language so that you\ncan use named tuples effectively. IDEs and editors can read these semantic names\nusing the Roslyn APIs. This enables you to reference the fields of a named\ntuple by those semantic names anywhere in the same assembly. The compiler\nreplaces the names you've defined with `Item*` equivalents when generating\nthe compiled output. The compiled Microsoft Intermediate Language (MSIL)\ndoes not include the names you've given these fields. \n\nThe compiler must communicate those names you created for tuples that\nare returned from public methods or properties. In those cases, the compiler\nadds a `TupleElementNames` attribute on the method. This attribute contains\na `TransformNames` list property that contains the names given to each of\nthe fields in the Tuple. \n\n> [!NOTE]\n> Development Tools, such as Visual Studio, also read that metadata,\n> and provide IntelliSense and other features using the metadata\n> field names.\n\nIt is important to understand these underlying fundamentals of\nthe new tuples and the `ValueTuple` type in order to understand\nthe rules for assigning named tuples to each other.\n\n## Assignment and tuples\n\nThe language supports assignment between tuple types that have\nthe same number of fields and implicit conversions for the types for each of those\nfields. Other\nconversions are not considered for assignments. Let's look at the kinds\nof assignments that are allowed between tuple types.\n\nConsider these variables used in the following examples:\n\n[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation \"Variable creation\")]\n\nThe first two variables, `unnamed` and `anonymous` do not have semantic\nnames provided for the fields. The field names are `Item1` and `Item2`.\nThe last two variables, `named` and `differentName` have semantic names\ngiven for the fields. Note that these two tuples have different names\nfor the fields.\n\nAll four of these tuples have the same number of fields (referred to as 'arity')\nand the types of those fields are identical. Therefore, all of these\nassignments work:\n\n[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment \"Variable assignment\")]\n\nNotice that the names of the tuples are not assigned. The values of the\nfields are assigned following the order of the fields in the tuple.\n\nTuples of different types or numbers of fields are not assignable:\n\n```csharp\n// Does not compile.\n// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)\nvar differentShape = (1, 2, 3);\nnamed = differentShape;\n```\n\n## Tuples as method return values\n\nOne of the most common uses for Tuples is as a method return\nvalue. Let's walk through one example. Consider this method\nthat computes the standard deviation for a sequence of numbers:\n\n[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation \"Compute Standard Deviation\")]\n\n> [!NOTE]\n> These examples compute the uncorrected sample standard deviation.\n> The corrected sample standard deviation formula would divide\n> the sum of the squared differences from the mean by (N-1) instead\n> of N, as the `Average` extension method does. Consult a statistics\n> text for more details on the differences between these formulas\n> for standard deviation.\n\nThis follows the textbook formula for the standard deviation. It produces\nthe correct answer, but it's a very inefficient implementation. This\nmethod enumerates the sequence twice: Once to produce the average, and\nonce to produce the average of the square of the difference of the average.\n(Remember that LINQ queries are evaluated lazily, so the computation of\nthe differences from the mean and the average of those differences makes\nonly one enumeration.)\n\nThere is an alternative formula that computes standard deviation using\nonly one enumeration of the sequence.  This computation produces two\nvalues as it enumerates the sequence: the sum of all items in the sequence,\nand the sum of the each value squared:\n\n[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula \"Compute Standard Deviation using the sum of squares\")]\n\nThs version enumerates the sequence exactly once. But, it's not very\nreusable code. As you keep working, you'll find that many different\nstatistical computations use the number of items in the sequence,\nthe sum of the sequence, and the sum \nof the squares of the sequence. Let's refactor this method and write\na utility method that produces all three of those values.\n\nThis is where tuples come in very useful. \n\nLet's update this method so the three values computed during the enumeration\nare stored in a tuple. That creates this version:\n\n[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion \"Refactor to use tuples\")]\n\nVisual Studio's Refactoring suport makes it easy to extract the functionality\nfor the core statistics into a private method. That gives you a `private static`\nmethod that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:\n\n[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion \"After extracting utility method\")]\n \nThe language enables a couple more options that you can use, if you want\nto make a few quick edits by hand. First, you can use the `var`\ndeclaration to initialize the tuple result from the `ComputeSumAndSumOfSquares`\nmethod call. You can also create three discrete variables inside the\n`ComputeSumAndSumOfSquares` method. The final version is below:\n\n[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion \"After final cleanup\")]\n\nThis final version can be used for any method that needs those three\nvalues, or any subset of them.\n\nThe language supports other options in managing the names of the fields\nin these tuple-returning methods.\n\nYou can remove the field names from the return value declaration and\nreturn an unnamed tuple:\n\n```csharp\nprivate static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)\n{\n    double sum = 0;\n    double sumOfSquares = 0;\n    int count = 0;\n\n    foreach (var item in sequence)\n    {\n        count++;\n        sum += item;\n        sumOfSquares += item * item;\n    }\n\n    return (sum, sumOfSquares, count);\n}\n```\n\nYou must address the fields of this tuple as `Item1`, `Item2`, and `Item3`.\nIt's recommended that you provide semantic names to the fields of tuples\nreturned from methods.\n\nAnother idiom where tuples can be very useful is when you are authoring\nLINQ queries where the final result is a projection that contains some, but not\nall, of the properties of the objects being selected.\n\nYou would traditionally project the results of the query into a sequence\nof objects that were an anonymous type. That presented many limitations,\nprimarily because anonymous types could not conveniently be named in the\nreturn type for a method. Alternatives using `object` or `dynamic` as the\ntype of the result came with significant performance costs.\n\nReturning a sequence of a tuple type is easy, and the names and types\nof the fields are available at compile time and through IDE tools.\nFor example, consider a ToDo application. You might define a\nclass similar to the following to represent a single entry in the ToDo list:\n\n[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem \"To Do Item\")]\n\nYour mobile applications may support a compact form of the current ToDo items\nthat only displays the title. That LINQ query would make a projection that\nincludes only the ID and the title. A method that returns a sequence of tuples\nexpresses that design very well:\n\n[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple \"Query returning a tuple\")]\n\nThe named tuple can be part of the signature. It lets the compiler and IDE\ntools provide static checking that you are using the result correctly. The\nnamed tuple also carries the static type information so there is no need\nto use expensive run time features like reflection or dynamic binding to\nwork with the results.\n\n## Deconstruction\n\nYou can unpackage all the items in a tuple by *deconstructng* the tuple\nreturned by a method. There are two different approaches to deconstructing\ntuples.  First, you can explicitly declare the type of each field inside\nparentheses to create discrete variables for each of the fields in the tuple:\n\n[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct \"Deconstruct\")]\n\nYou can also declare implicitly typed variables for each field in a tuple\nby using the `var` keyword outside the parentheses:\n\n[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar \"Deconstruct to Var\")]\n\nIt is also legal to use the `var` keyword with any, or all of the variable\ndeclarations inside the parentheses. \n\n```csharp\n(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);\n```\nNote that you cannot use a specific\ntype outside the parentheses, even if every field in the tuple has the\nsame type.\n\n### Deconstructing user defined types\n\nAny tuple type can be deconstructed as shown above. It's also easy\nto enable deconstruction on any user defined type (classes, structs, or \neven interfaces).\n\nThe type author can define one or more `Deconstruct` methods that\nassign values to any number of `out` variables representing the\ndata elements that make up the type. For example, the following\n`Person` type defines a `Deconstruct` method that deconstructs\na person object into the fields representing the first name\nand last name:\n\n[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod \"Type with a deconstruct method\")]\n\nThe deconstruct method enables assignment from a `Person` to two strings, \nrepresenting the `FirstName` and `LastName` properties:\n\n[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType \"Deconstruct a class type\")]\n\nYou can enable deconstruction even for types you did not author.\nThe `Deconstruct` method can be an extension method that unpackages\nthe accessible data members of an object. The example below shows\na `Student` type, derived from the `Person` type, and an extension\nmethod that deconstructs a `Student` into three variables, representing\nthe `FirstName`, the `LastName` and the `GPA`:\n\n[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod \"Type with a deconstruct extension method\")]\n\nA `Student` object now has two accessible `Deconstruct` methods: the extension method\ndeclared for `Student` types, and the member of the `Person` type. Both are in scope,\nand that enables a `Student` to be deconstructed into either two variables or three.\nIf you assign a student to three variabless, the first name, last name, and GPA are\nall returned. If you assign a student to two variables, only the first name and \nthe last name are returned.\n\n[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension \"Deconstruct a class type using an extension method\")]\n\nYou should be very careful defining multiple `Deconstruct` methods in a \nclass or a class hierarchy. Multiple `Deconstruct` methods that have the\nsame number of `out` parameters can quickly cause ambiguities. Callers may\nnot be able to easily call the desired `Deconstruct` method.\n\nIn this example, there is minimal chance for an ambiguious call because the \n`Deconstruct` method for `Person` has two output parameters, and the `Deconstruct`\nmethod for `Student` has three.\n\n## Conclusion \n\nThe new language and library support for named tuples makes it much easier\nto work with designs that use data structures that store multiple fields\nbut do not define behavior, as classes and structs do. It's\neasy and concise to use tuples for those types. You get all the benefits of\nstatic type checking, without needing to author types using the more\nverbose `class` or `struct` syntax. Even so, they are most useful for utility methods\nthat are `private`, or `internal`. Create user defined types, either\n`class` or `struct` types when your public methods return a value\nthat has multiple fields.\n","nodes":[{"pos":[11,28],"content":"Tuples | C# Guide","needQuote":true,"needEscape":true,"nodes":[{"content":"Tuples | C# Guide","pos":[0,17]}]},{"pos":[42,89],"content":"Learn about unnamed and named tuple types in C#","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn about unnamed and named tuple types in C#","pos":[0,47]}]},{"pos":[100,119],"content":".NET, .NET Core, C#","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core, C#","pos":[0,19]}]},{"pos":[314,328],"content":"C# Tuple types","linkify":"C# Tuple types","nodes":[{"content":"C# Tuple types","pos":[0,14]}]},{"content":"C# Tuples are types that you define using a lightweight syntax.","pos":[332,395]},{"content":"The advantages include a simpler syntax, rules for conversions based on number (referred to as \"arity\") and types of fields, and consistent rules for copies and assignments.","pos":[396,569],"source":" The advantages\ninclude a simpler syntax, rules for conversions based on number (referred to as \"arity\")\nand types of fields, and\nconsistent rules for copies and assignments."},{"content":"As a tradeoff, Tuples do not support some of the object oriented idioms associated with inheritance.","pos":[570,670],"source":" As a tradeoff, Tuples do not\nsupport some of the object oriented idioms associated with inheritance."},{"content":"You can get an overview in the section on <bpt id=\"p1\">[</bpt>Tuples in the What's new in C# 7<ept id=\"p1\">](whats-new/csharp-7.md#tuples)</ept> topic.","pos":[671,784],"source":" You\ncan get an overview in the section on [Tuples in the What's new in C# 7](whats-new/csharp-7.md#tuples) topic."},{"pos":[786,931],"content":"In this topic, you'll learn the language rules governing Tuples in C# 7, different ways to use them, and initial guidance on working with Tuples.","source":"In this topic, you'll learn the language rules governing Tuples in C# 7,\ndifferent ways to use them, and initial guidance on working with Tuples."},{"pos":[935,1502],"content":"[!NOTE]\nThe new tuples features require the `System.ValueTuple` type. For Visual Studio 2017,\nyou must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery.\nWithout this package you may get a compilation error similar to `error CS8179: Predefined type 'System.ValueTuple``2' is not defined or imported`\nor `error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found.`","leadings":["","> ","> ","> ","> "],"nodes":[{"content":"The new tuples features require the `System.ValueTuple` type. For Visual Studio 2017,\nyou must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery.\nWithout this package you may get a compilation error similar to `error CS8179: Predefined type 'System.ValueTuple``2' is not defined or imported`\nor `error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found.`","pos":[8,559],"nodes":[{"content":"The new tuples features require the <ph id=\"ph1\">`System.ValueTuple`</ph> type.","pos":[0,61],"source":"The new tuples features require the `System.ValueTuple` type."},{"content":"For Visual Studio 2017, you must add the NuGet package <bpt id=\"p1\">[</bpt>System.ValueTuple<ept id=\"p1\">](https://www.nuget.org/packages/System.ValueTuple/)</ept>, available on the NuGet Gallery.","pos":[62,220],"source":" For Visual Studio 2017,\nyou must add the NuGet package [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/), available on the NuGet Gallery."},{"content":"Without this package you may get a compilation error similar to <ph id=\"ph1\">`error CS8179: Predefined type 'System.ValueTuple``2' is not defined or imported`</ph> or <ph id=\"ph2\">`error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found.`</ph>","pos":[221,551],"source":"\nWithout this package you may get a compilation error similar to `error CS8179: Predefined type 'System.ValueTuple``2' is not defined or imported`\nor `error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found.`"}]}]},{"content":"Let's start with the reasons for adding new Tuple support.","pos":[1504,1562]},{"content":"Methods return a single object.","pos":[1563,1594],"source":" Methods return\na single object."},{"content":"Tuples enable you to package multiple values in that single object more easily.","pos":[1595,1674],"source":" Tuples enable you to package multiple values in that single\nobject more easily."},{"content":"The .NET Framework already has generic <ph id=\"ph1\">`Tuple`</ph> classes.","pos":[1677,1732],"source":"The .NET Framework already has generic `Tuple` classes."},{"content":"These classes, however, had two major limitations.","pos":[1733,1783],"source":" These classes,\nhowever, had two major limitations."},{"content":"For one, the <ph id=\"ph1\">`Tuple`</ph> classes named their fields <ph id=\"ph2\">`Item1`</ph>, <ph id=\"ph3\">`Item2`</ph>, and so on.","pos":[1784,1860],"source":" For one, the `Tuple` classes named\ntheir fields `Item1`, `Item2`, and so on."},{"content":"Those names carry no semantic information.","pos":[1861,1903],"source":" Those names carry no semantic\ninformation."},{"content":"Using these <ph id=\"ph1\">`Tuple`</ph> types does not enable communicating the meaning of each of the fields.","pos":[1904,1994],"source":" Using these `Tuple` types does not enable communicating the\nmeaning of each of the fields."},{"content":"Another concern is that the <ph id=\"ph1\">`Tuple`</ph> classes are reference types.","pos":[1995,2059],"source":" Another concern is that the `Tuple` classes are\nreference types."},{"content":"Using one of the <ph id=\"ph1\">`Tuple`</ph> types means allocating objects.","pos":[2060,2116],"source":" Using one of the `Tuple` types means allocating objects."},{"content":"On hot paths, this can have a measurable impact on your application's performance.","pos":[2117,2199],"source":" On hot\npaths, this can have a measurable impact on your application's performance."},{"content":"To avoid those deficiencies, you could create a <ph id=\"ph1\">`class`</ph> or a <ph id=\"ph2\">`struct`</ph> to carry multiple fields.","pos":[2201,2296],"source":"To avoid those deficiencies, you could create a `class` or a `struct`\nto carry multiple fields."},{"content":"Unfortunately, that's more work for you, and it obscures your design intent.","pos":[2297,2373],"source":" Unfortunately, that's more work for you,\nand it obscures your design intent."},{"content":"Making a <ph id=\"ph1\">`struct`</ph> or <ph id=\"ph2\">`class`</ph> implies that you are defining a type with both data and behavior.","pos":[2374,2468],"source":" Making a `struct` or `class` implies\nthat you are defining a type with both data and behavior."},{"content":"Many times, you simply want to store multiple values in a single object.","pos":[2469,2541],"source":" Many times, you\nsimply want to store multiple values in a single object."},{"content":"The new language features for tuples, combined with a new set of classes in the framework, address these deficiencies.","pos":[2543,2661],"source":"The new language features for tuples, combined with a new set of\nclasses in the framework, address these deficiencies."},{"content":"These new tuples use the new <ph id=\"ph1\">`ValueTuple`</ph> generic structs.","pos":[2662,2720],"source":" These new tuples\nuse the new `ValueTuple` generic structs."},{"content":"As the name implies, this type is a <ph id=\"ph1\">`struct`</ph> instead of a <ph id=\"ph2\">`class`</ph>.","pos":[2721,2787],"source":" As the name implies, this type is a `struct`\ninstead of a `class`."},{"content":"There are different versions of this struct to support tuples with different numbers of fields.","pos":[2788,2883],"source":" There are different versions of this struct to support\ntuples with different numbers of fields."},{"content":"New language support provides semantic names for the fields of the tuple type, along with features to make constructing or accessing tuple fields easy.","pos":[2884,3035],"source":" New language support provides semantic\nnames for the fields of the tuple type, along with features to make constructing\nor accessing tuple fields easy."},{"content":"The language features and the <ph id=\"ph1\">`ValueTuple`</ph> generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.","pos":[3037,3177],"source":"The language features and the `ValueTuple` generic structs enforce the rule that\nyou cannot add any behavior (methods) to these tuple types."},{"content":"All the <ph id=\"ph1\">`ValueTuple`</ph> types are <bpt id=\"p1\">*</bpt>mutable structs<ept id=\"p1\">*</ept>.","pos":[3178,3227],"source":"\nAll the `ValueTuple` types are *mutable structs*."},{"content":"Each member field is a public field.","pos":[3228,3264],"source":" Each member field is a\npublic field."},{"content":"That makes them very lightweight.","pos":[3265,3298]},{"content":"However, that means tuples should not be used where immutability is important.","pos":[3299,3377],"source":" However, that means tuples\nshould not be used where immutability is important."},{"content":"Tuples are both simpler and more flexible data containers than <ph id=\"ph1\">`class`</ph> and <ph id=\"ph2\">`struct`</ph> types.","pos":[3379,3469],"source":"Tuples are both simpler and more flexible data containers than `class` and\n`struct` types."},{"content":"Let's explore those differences.","pos":[3470,3502]},{"pos":[3507,3531],"content":"Named and unnamed tuples","linkify":"Named and unnamed tuples","nodes":[{"content":"Named and unnamed tuples","pos":[0,24]}]},{"content":"The <ph id=\"ph1\">`ValueTuple`</ph> struct has fields named <ph id=\"ph2\">`Item1`</ph>, <ph id=\"ph3\">`Item2`</ph>, <ph id=\"ph4\">`Item3`</ph> and so on, similer to the properties defined in the existing <ph id=\"ph5\">`Tuple`</ph> types.","pos":[3533,3675],"source":"The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3` and so on,\nsimiler to the properties defined in the existing `Tuple` types."},{"content":"These names are the only names you can use for <bpt id=\"p1\">*</bpt>unnamed tuples<ept id=\"p1\">*</ept>.","pos":[3676,3740],"source":"\nThese names are the only names you can use for *unnamed tuples*."},{"content":"When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:","pos":[3741,3837],"source":" When you\ndo not provide any alternative field names to a tuple, you've created an\nunnamed tuple:"},{"pos":[3839,3955],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UnnamedTuple<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple \"</bpt>Unnamed tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple \"Unnamed tuple\")]"},{"content":"However, when you initialize a tuple, you can use new language features that give better names to each field.","pos":[3957,4066],"source":"However, when you initialize a tuple, you can use new language features\nthat give better names to each field."},{"content":"Doing so creates a <bpt id=\"p1\">*</bpt>named tuple<ept id=\"p1\">*</ept>.","pos":[4067,4100],"source":" Doing so creates a *named tuple*."},{"content":"Named tuples still have fields named <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, <ph id=\"ph3\">`Item3`</ph> and so on.","pos":[4101,4174],"source":"\nNamed tuples still have fields named `Item1`, `Item2`, `Item3` and so on."},{"content":"But they also have synonyms for any of those fields that you have named.","pos":[4175,4247],"source":"\nBut they also have synonyms for any of those fields that you have named."},{"content":"You create a named tuple by specifying the names for each field.","pos":[4248,4312],"source":"\nYou create a named tuple by specifying the names for each field."},{"content":"One way is to specify the names as part of the tuple initialization:","pos":[4313,4381],"source":" One way\nis to specify the names as part of the tuple initialization:"},{"pos":[4383,4493],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>NamedTuple<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple \"</bpt>Named tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple \"Named tuple\")]"},{"content":"These synonyms are handled by the compiler and the language so that you can use named tuples effectively.","pos":[4495,4600],"source":"These synonyms are handled by the compiler and the language so that you\ncan use named tuples effectively."},{"content":"IDEs and editors can read these semantic names using the Roslyn APIs.","pos":[4601,4670],"source":" IDEs and editors can read these semantic names\nusing the Roslyn APIs."},{"content":"This enables you to reference the fields of a named tuple by those semantic names anywhere in the same assembly.","pos":[4671,4783],"source":" This enables you to reference the fields of a named\ntuple by those semantic names anywhere in the same assembly."},{"content":"The compiler replaces the names you've defined with <ph id=\"ph1\">`Item*`</ph> equivalents when generating the compiled output.","pos":[4784,4892],"source":" The compiler\nreplaces the names you've defined with `Item*` equivalents when generating\nthe compiled output."},{"content":"The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these fields.","pos":[4893,4998],"source":" The compiled Microsoft Intermediate Language (MSIL)\ndoes not include the names you've given these fields."},{"content":"The compiler must communicate those names you created for tuples that are returned from public methods or properties.","pos":[5001,5118],"source":"The compiler must communicate those names you created for tuples that\nare returned from public methods or properties."},{"content":"In those cases, the compiler adds a <ph id=\"ph1\">`TupleElementNames`</ph> attribute on the method.","pos":[5119,5199],"source":" In those cases, the compiler\nadds a `TupleElementNames` attribute on the method."},{"content":"This attribute contains a <ph id=\"ph1\">`TransformNames`</ph> list property that contains the names given to each of the fields in the Tuple.","pos":[5200,5322],"source":" This attribute contains\na `TransformNames` list property that contains the names given to each of\nthe fields in the Tuple."},{"pos":[5327,5483],"content":"[!NOTE]\nDevelopment Tools, such as Visual Studio, also read that metadata,\nand provide IntelliSense and other features using the metadata\nfield names.","leadings":["","> ","> ","> "],"nodes":[{"content":"Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.","pos":[8,150],"source":"Development Tools, such as Visual Studio, also read that metadata,\nand provide IntelliSense and other features using the metadata\nfield names."}]},{"pos":[5485,5663],"content":"It is important to understand these underlying fundamentals of the new tuples and the <ph id=\"ph1\">`ValueTuple`</ph> type in order to understand the rules for assigning named tuples to each other.","source":"It is important to understand these underlying fundamentals of\nthe new tuples and the `ValueTuple` type in order to understand\nthe rules for assigning named tuples to each other."},{"pos":[5668,5689],"content":"Assignment and tuples","linkify":"Assignment and tuples","nodes":[{"content":"Assignment and tuples","pos":[0,21]}]},{"content":"The language supports assignment between tuple types that have the same number of fields and implicit conversions for the types for each of those fields.","pos":[5691,5844],"source":"The language supports assignment between tuple types that have\nthe same number of fields and implicit conversions for the types for each of those\nfields."},{"content":"Other conversions are not considered for assignments.","pos":[5845,5898],"source":" Other\nconversions are not considered for assignments."},{"content":"Let's look at the kinds of assignments that are allowed between tuple types.","pos":[5899,5975],"source":" Let's look at the kinds\nof assignments that are allowed between tuple types."},{"content":"Consider these variables used in the following examples:","pos":[5977,6033]},{"pos":[6035,6163],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>VariableCreation<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation \"</bpt>Variable creation<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation \"Variable creation\")]"},{"content":"The first two variables, <ph id=\"ph1\">`unnamed`</ph> and <ph id=\"ph2\">`anonymous`</ph> do not have semantic names provided for the fields.","pos":[6165,6267],"source":"The first two variables, `unnamed` and `anonymous` do not have semantic\nnames provided for the fields."},{"content":"The field names are <ph id=\"ph1\">`Item1`</ph> and <ph id=\"ph2\">`Item2`</ph>.","pos":[6268,6308],"source":" The field names are `Item1` and `Item2`."},{"content":"The last two variables, <ph id=\"ph1\">`named`</ph> and <ph id=\"ph2\">`differentName`</ph> have semantic names given for the fields.","pos":[6309,6402],"source":"\nThe last two variables, `named` and `differentName` have semantic names\ngiven for the fields."},{"content":"Note that these two tuples have different names for the fields.","pos":[6403,6466],"source":" Note that these two tuples have different names\nfor the fields."},{"content":"All four of these tuples have the same number of fields (referred to as 'arity') and the types of those fields are identical.","pos":[6468,6593],"source":"All four of these tuples have the same number of fields (referred to as 'arity')\nand the types of those fields are identical."},{"content":"Therefore, all of these assignments work:","pos":[6594,6635],"source":" Therefore, all of these\nassignments work:"},{"pos":[6637,6771],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>VariableAssignment<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment \"</bpt>Variable assignment<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment \"Variable assignment\")]"},{"content":"Notice that the names of the tuples are not assigned.","pos":[6773,6826]},{"content":"The values of the fields are assigned following the order of the fields in the tuple.","pos":[6827,6912],"source":" The values of the\nfields are assigned following the order of the fields in the tuple."},{"content":"Tuples of different types or numbers of fields are not assignable:","pos":[6914,6980]},{"pos":[7143,7173],"content":"Tuples as method return values","linkify":"Tuples as method return values","nodes":[{"content":"Tuples as method return values","pos":[0,30]}]},{"content":"One of the most common uses for Tuples is as a method return value.","pos":[7175,7242],"source":"One of the most common uses for Tuples is as a method return\nvalue."},{"content":"Let's walk through one example.","pos":[7243,7274]},{"content":"Consider this method that computes the standard deviation for a sequence of numbers:","pos":[7275,7359],"source":" Consider this method\nthat computes the standard deviation for a sequence of numbers:"},{"pos":[7361,7503],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>StandardDeviation<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation \"</bpt>Compute Standard Deviation<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation \"Compute Standard Deviation\")]"},{"pos":[7507,7874],"content":"[!NOTE]\nThese examples compute the uncorrected sample standard deviation.\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the `Average` extension method does. Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation.","leadings":["","> ","> ","> ","> ","> ","> "],"nodes":[{"content":"These examples compute the uncorrected sample standard deviation.\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the `Average` extension method does. Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation.","pos":[8,355],"nodes":[{"content":"These examples compute the uncorrected sample standard deviation.","pos":[0,65]},{"content":"The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the <ph id=\"ph1\">`Average`</ph> extension method does.","pos":[66,238],"source":"\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the `Average` extension method does."},{"content":"Consult a statistics text for more details on the differences between these formulas for standard deviation.","pos":[239,347],"source":" Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation."}]}]},{"content":"This follows the textbook formula for the standard deviation.","pos":[7876,7937]},{"content":"It produces the correct answer, but it's a very inefficient implementation.","pos":[7938,8013],"source":" It produces\nthe correct answer, but it's a very inefficient implementation."},{"content":"This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.","pos":[8014,8165],"source":" This\nmethod enumerates the sequence twice: Once to produce the average, and\nonce to produce the average of the square of the difference of the average."},{"content":"(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)","pos":[8166,8333],"source":"\n(Remember that LINQ queries are evaluated lazily, so the computation of\nthe differences from the mean and the average of those differences makes\nonly one enumeration.)"},{"content":"There is an alternative formula that computes standard deviation using only one enumeration of the sequence.","pos":[8335,8443],"source":"There is an alternative formula that computes standard deviation using\nonly one enumeration of the sequence."},{"content":"This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:","pos":[8445,8589],"source":"  This computation produces two\nvalues as it enumerates the sequence: the sum of all items in the sequence,\nand the sum of the each value squared:"},{"pos":[8591,8762],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>SumOfSquaresFormula<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula \"</bpt>Compute Standard Deviation using the sum of squares<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula \"Compute Standard Deviation using the sum of squares\")]"},{"content":"Ths version enumerates the sequence exactly once.","pos":[8764,8813]},{"content":"But, it's not very reusable code.","pos":[8814,8847],"source":" But, it's not very\nreusable code."},{"content":"As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.","pos":[8848,9036],"source":" As you keep working, you'll find that many different\nstatistical computations use the number of items in the sequence,\nthe sum of the sequence, and the sum \nof the squares of the sequence."},{"content":"Let's refactor this method and write a utility method that produces all three of those values.","pos":[9037,9131],"source":" Let's refactor this method and write\na utility method that produces all three of those values."},{"content":"This is where tuples come in very useful.","pos":[9133,9174]},{"content":"Let's update this method so the three values computed during the enumeration are stored in a tuple.","pos":[9177,9276],"source":"Let's update this method so the three values computed during the enumeration\nare stored in a tuple."},{"content":"That creates this version:","pos":[9277,9303]},{"pos":[9305,9433],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TupleVersion<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion \"</bpt>Refactor to use tuples<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion \"Refactor to use tuples\")]"},{"content":"Visual Studio's Refactoring suport makes it easy to extract the functionality for the core statistics into a private method.","pos":[9435,9559],"source":"Visual Studio's Refactoring suport makes it easy to extract the functionality\nfor the core statistics into a private method."},{"content":"That gives you a <ph id=\"ph1\">`private static`</ph> method that returns the tuple type with the three values of <ph id=\"ph2\">`Sum`</ph>, <ph id=\"ph3\">`SumOfSquares`</ph>, and <ph id=\"ph4\">`Count`</ph>:","pos":[9560,9689],"source":" That gives you a `private static`\nmethod that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:"},{"pos":[9691,9840],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TupleMethodVersion<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion \"</bpt>After extracting utility method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion \"After extracting utility method\")]"},{"content":"The language enables a couple more options that you can use, if you want to make a few quick edits by hand.","pos":[9843,9950],"source":"The language enables a couple more options that you can use, if you want\nto make a few quick edits by hand."},{"content":"First, you can use the <ph id=\"ph1\">`var`</ph> declaration to initialize the tuple result from the <ph id=\"ph2\">`ComputeSumAndSumOfSquares`</ph> method call.","pos":[9951,10072],"source":" First, you can use the `var`\ndeclaration to initialize the tuple result from the `ComputeSumAndSumOfSquares`\nmethod call."},{"content":"You can also create three discrete variables inside the <ph id=\"ph1\">`ComputeSumAndSumOfSquares`</ph> method.","pos":[10073,10164],"source":" You can also create three discrete variables inside the\n`ComputeSumAndSumOfSquares` method."},{"content":"The final version is below:","pos":[10165,10192]},{"pos":[10194,10333],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CleanedTupleVersion<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion \"</bpt>After final cleanup<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion \"After final cleanup\")]"},{"pos":[10335,10434],"content":"This final version can be used for any method that needs those three values, or any subset of them.","source":"This final version can be used for any method that needs those three\nvalues, or any subset of them."},{"pos":[10436,10541],"content":"The language supports other options in managing the names of the fields in these tuple-returning methods.","source":"The language supports other options in managing the names of the fields\nin these tuple-returning methods."},{"pos":[10543,10636],"content":"You can remove the field names from the return value declaration and return an unnamed tuple:","source":"You can remove the field names from the return value declaration and\nreturn an unnamed tuple:"},{"content":"You must address the fields of this tuple as <ph id=\"ph1\">`Item1`</ph>, <ph id=\"ph2\">`Item2`</ph>, and <ph id=\"ph3\">`Item3`</ph>.","pos":[10981,11056],"source":"You must address the fields of this tuple as `Item1`, `Item2`, and `Item3`."},{"content":"It's recommended that you provide semantic names to the fields of tuples returned from methods.","pos":[11057,11152],"source":"\nIt's recommended that you provide semantic names to the fields of tuples\nreturned from methods."},{"pos":[11154,11359],"content":"Another idiom where tuples can be very useful is when you are authoring LINQ queries where the final result is a projection that contains some, but not all, of the properties of the objects being selected.","source":"Another idiom where tuples can be very useful is when you are authoring\nLINQ queries where the final result is a projection that contains some, but not\nall, of the properties of the objects being selected."},{"content":"You would traditionally project the results of the query into a sequence of objects that were an anonymous type.","pos":[11361,11473],"source":"You would traditionally project the results of the query into a sequence\nof objects that were an anonymous type."},{"content":"That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.","pos":[11474,11605],"source":" That presented many limitations,\nprimarily because anonymous types could not conveniently be named in the\nreturn type for a method."},{"content":"Alternatives using <ph id=\"ph1\">`object`</ph> or <ph id=\"ph2\">`dynamic`</ph> as the type of the result came with significant performance costs.","pos":[11606,11713],"source":" Alternatives using `object` or `dynamic` as the\ntype of the result came with significant performance costs."},{"content":"Returning a sequence of a tuple type is easy, and the names and types of the fields are available at compile time and through IDE tools.","pos":[11715,11851],"source":"Returning a sequence of a tuple type is easy, and the names and types\nof the fields are available at compile time and through IDE tools."},{"content":"For example, consider a ToDo application.","pos":[11852,11893],"source":"\nFor example, consider a ToDo application."},{"content":"You might define a class similar to the following to represent a single entry in the ToDo list:","pos":[11894,11989],"source":" You might define a\nclass similar to the following to represent a single entry in the ToDo list:"},{"pos":[11991,12105],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ToDoItem<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem \"</bpt>To Do Item<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem \"To Do Item\")]"},{"content":"Your mobile applications may support a compact form of the current ToDo items that only displays the title.","pos":[12107,12214],"source":"Your mobile applications may support a compact form of the current ToDo items\nthat only displays the title."},{"content":"That LINQ query would make a projection that includes only the ID and the title.","pos":[12215,12295],"source":" That LINQ query would make a projection that\nincludes only the ID and the title."},{"content":"A method that returns a sequence of tuples expresses that design very well:","pos":[12296,12371],"source":" A method that returns a sequence of tuples\nexpresses that design very well:"},{"pos":[12373,12522],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>QueryReturningTuple<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple \"</bpt>Query returning a tuple<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple \"Query returning a tuple\")]"},{"content":"The named tuple can be part of the signature.","pos":[12524,12569]},{"content":"It lets the compiler and IDE tools provide static checking that you are using the result correctly.","pos":[12570,12669],"source":" It lets the compiler and IDE\ntools provide static checking that you are using the result correctly."},{"content":"The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.","pos":[12670,12842],"source":" The\nnamed tuple also carries the static type information so there is no need\nto use expensive run time features like reflection or dynamic binding to\nwork with the results."},{"pos":[12847,12861],"content":"Deconstruction","linkify":"Deconstruction","nodes":[{"content":"Deconstruction","pos":[0,14]}]},{"content":"You can unpackage all the items in a tuple by <bpt id=\"p1\">*</bpt>deconstructng<ept id=\"p1\">*</ept> the tuple returned by a method.","pos":[12863,12956],"source":"You can unpackage all the items in a tuple by *deconstructng* the tuple\nreturned by a method."},{"content":"There are two different approaches to deconstructing tuples.","pos":[12957,13017],"source":" There are two different approaches to deconstructing\ntuples."},{"content":"First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the fields in the tuple:","pos":[13019,13160],"source":"  First, you can explicitly declare the type of each field inside\nparentheses to create discrete variables for each of the fields in the tuple:"},{"pos":[13162,13277],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Deconstruct<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct \"</bpt>Deconstruct<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct \"Deconstruct\")]"},{"pos":[13279,13404],"content":"You can also declare implicitly typed variables for each field in a tuple by using the <ph id=\"ph1\">`var`</ph> keyword outside the parentheses:","source":"You can also declare implicitly typed variables for each field in a tuple\nby using the `var` keyword outside the parentheses:"},{"pos":[13406,13538],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DeconstructToVar<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar \"</bpt>Deconstruct to Var<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar \"Deconstruct to Var\")]"},{"pos":[13540,13651],"content":"It is also legal to use the <ph id=\"ph1\">`var`</ph> keyword with any, or all of the variable declarations inside the parentheses.","source":"It is also legal to use the `var` keyword with any, or all of the variable\ndeclarations inside the parentheses."},{"pos":[13749,13866],"content":"Note that you cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.","source":"Note that you cannot use a specific\ntype outside the parentheses, even if every field in the tuple has the\nsame type."},{"pos":[13872,13905],"content":"Deconstructing user defined types","linkify":"Deconstructing user defined types","nodes":[{"content":"Deconstructing user defined types","pos":[0,33]}]},{"content":"Any tuple type can be deconstructed as shown above.","pos":[13907,13958]},{"content":"It's also easy to enable deconstruction on any user defined type (classes, structs, or even interfaces).","pos":[13959,14064],"source":" It's also easy\nto enable deconstruction on any user defined type (classes, structs, or \neven interfaces)."},{"content":"The type author can define one or more <ph id=\"ph1\">`Deconstruct`</ph> methods that assign values to any number of <ph id=\"ph2\">`out`</ph> variables representing the data elements that make up the type.","pos":[14066,14232],"source":"The type author can define one or more `Deconstruct` methods that\nassign values to any number of `out` variables representing the\ndata elements that make up the type."},{"content":"For example, the following <ph id=\"ph1\">`Person`</ph> type defines a <ph id=\"ph2\">`Deconstruct`</ph> method that deconstructs a person object into the fields representing the first name and last name:","pos":[14233,14397],"source":" For example, the following\n`Person` type defines a `Deconstruct` method that deconstructs\na person object into the fields representing the first name\nand last name:"},{"pos":[14399,14557],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TypeWithDeconstructMethod<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod \"</bpt>Type with a deconstruct method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod \"Type with a deconstruct method\")]"},{"pos":[14559,14689],"content":"The deconstruct method enables assignment from a <ph id=\"ph1\">`Person`</ph> to two strings, representing the <ph id=\"ph2\">`FirstName`</ph> and <ph id=\"ph3\">`LastName`</ph> properties:","source":"The deconstruct method enables assignment from a `Person` to two strings, \nrepresenting the `FirstName` and `LastName` properties:"},{"pos":[14691,14826],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Deconstruct Type<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType \"</bpt>Deconstruct a class type<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType \"Deconstruct a class type\")]"},{"content":"You can enable deconstruction even for types you did not author.","pos":[14828,14892]},{"content":"The <ph id=\"ph1\">`Deconstruct`</ph> method can be an extension method that unpackages the accessible data members of an object.","pos":[14893,15002],"source":"\nThe `Deconstruct` method can be an extension method that unpackages\nthe accessible data members of an object."},{"content":"The example below shows a <ph id=\"ph1\">`Student`</ph> type, derived from the <ph id=\"ph2\">`Person`</ph> type, and an extension method that deconstructs a <ph id=\"ph3\">`Student`</ph> into three variables, representing the <ph id=\"ph4\">`FirstName`</ph>, the <ph id=\"ph5\">`LastName`</ph> and the <ph id=\"ph6\">`GPA`</ph>:","pos":[15003,15212],"source":" The example below shows\na `Student` type, derived from the `Person` type, and an extension\nmethod that deconstructs a `Student` into three variables, representing\nthe `FirstName`, the `LastName` and the `GPA`:"},{"pos":[15214,15384],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExtensionDeconstructMethod<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod \"</bpt>Type with a deconstruct extension method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod \"Type with a deconstruct extension method\")]"},{"content":"A <ph id=\"ph1\">`Student`</ph> object now has two accessible <ph id=\"ph2\">`Deconstruct`</ph> methods: the extension method declared for <ph id=\"ph3\">`Student`</ph> types, and the member of the <ph id=\"ph4\">`Person`</ph> type.","pos":[15386,15538],"source":"A `Student` object now has two accessible `Deconstruct` methods: the extension method\ndeclared for `Student` types, and the member of the `Person` type."},{"content":"Both are in scope, and that enables a <ph id=\"ph1\">`Student`</ph> to be deconstructed into either two variables or three.","pos":[15539,15642],"source":" Both are in scope,\nand that enables a `Student` to be deconstructed into either two variables or three."},{"content":"If you assign a student to three variabless, the first name, last name, and GPA are all returned.","pos":[15643,15740],"source":"\nIf you assign a student to three variabless, the first name, last name, and GPA are\nall returned."},{"content":"If you assign a student to two variables, only the first name and the last name are returned.","pos":[15741,15835],"source":" If you assign a student to two variables, only the first name and \nthe last name are returned."},{"pos":[15837,16015],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Deconstruct extension method<ept id=\"p2\">]</ept><bpt id=\"p3\">(../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension \"</bpt>Deconstruct a class type using an extension method<ept id=\"p3\">\")</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension \"Deconstruct a class type using an extension method\")]"},{"content":"You should be very careful defining multiple <ph id=\"ph1\">`Deconstruct`</ph> methods in a class or a class hierarchy.","pos":[16017,16117],"source":"You should be very careful defining multiple `Deconstruct` methods in a \nclass or a class hierarchy."},{"content":"Multiple <ph id=\"ph1\">`Deconstruct`</ph> methods that have the same number of <ph id=\"ph2\">`out`</ph> parameters can quickly cause ambiguities.","pos":[16118,16225],"source":" Multiple `Deconstruct` methods that have the\nsame number of `out` parameters can quickly cause ambiguities."},{"content":"Callers may not be able to easily call the desired <ph id=\"ph1\">`Deconstruct`</ph> method.","pos":[16226,16298],"source":" Callers may\nnot be able to easily call the desired `Deconstruct` method."},{"pos":[16300,16491],"content":"In this example, there is minimal chance for an ambiguious call because the <ph id=\"ph1\">`Deconstruct`</ph> method for <ph id=\"ph2\">`Person`</ph> has two output parameters, and the <ph id=\"ph3\">`Deconstruct`</ph> method for <ph id=\"ph4\">`Student`</ph> has three.","source":"In this example, there is minimal chance for an ambiguious call because the \n`Deconstruct` method for `Person` has two output parameters, and the `Deconstruct`\nmethod for `Student` has three."},{"pos":[16496,16506],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple fields but do not define behavior, as classes and structs do.","pos":[16509,16711],"source":"The new language and library support for named tuples makes it much easier\nto work with designs that use data structures that store multiple fields\nbut do not define behavior, as classes and structs do."},{"content":"It's easy and concise to use tuples for those types.","pos":[16712,16764],"source":" It's\neasy and concise to use tuples for those types."},{"content":"You get all the benefits of static type checking, without needing to author types using the more verbose <ph id=\"ph1\">`class`</ph> or <ph id=\"ph2\">`struct`</ph> syntax.","pos":[16765,16897],"source":" You get all the benefits of\nstatic type checking, without needing to author types using the more\nverbose `class` or `struct` syntax."},{"content":"Even so, they are most useful for utility methods that are <ph id=\"ph1\">`private`</ph>, or <ph id=\"ph2\">`internal`</ph>.","pos":[16898,16982],"source":" Even so, they are most useful for utility methods\nthat are `private`, or `internal`."},{"content":"Create user defined types, either <ph id=\"ph1\">`class`</ph> or <ph id=\"ph2\">`struct`</ph> types when your public methods return a value that has multiple fields.","pos":[16983,17108],"source":" Create user defined types, either\n`class` or `struct` types when your public methods return a value\nthat has multiple fields."}]}