{"content":"---\ntitle: \"Specifying Fully Qualified Type Names\"\nms.date: \"02/21/2019\"\nhelpviewer_keywords:\n  - \"names [.NET Framework], fully qualified type names\"\n  - \"reflection, fully qualified type names\"\n  - \"names [.NET Framework], assemblies\"\n  - \"tokens\"\n  - \"BNF\"\n  - \"assemblies [.NET Framework], names\"\n  - \"languages, grammar\"\n  - \"fully qualified type names\"\n  - \"type names\"\n  - \"special characters\"\n  - \"IDENTIFIER\"\nms.assetid: d90b1e39-9115-4f2a-81c0-05e7e74e5580\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n\n# Specifying fully qualified type names\n\nYou must specify type names to have valid input to various reflection operations. A fully qualified type name consists of an assembly name specification, a namespace specification, and a type name. Type name specifications are used by methods such as <xref:System.Type.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.\n\n## Grammar for type names\n\n The grammar defines the syntax of formal languages. The following table lists lexical rules that describe how to recognize a valid input. Terminals (those elements that are not further reducible) are shown in all uppercase letters. Nonterminals (those elements that are further reducible) are shown in mixed-case or singly quoted strings, but the single quote (') is not a part of the syntax itself. The pipe character (&#124;) denotes rules that have subrules.\n\n<!-- markdownlint-disable MD010 -->\n```antlr\nTypeSpec\n    : ReferenceTypeSpec\n    | SimpleTypeSpec\n    ;\n\nReferenceTypeSpec\n    : SimpleTypeSpec '&'\n    ;\n\nSimpleTypeSpec\n    : PointerTypeSpec\n    | GenericTypeSpec\n    | TypeName\n    ;\n\nGenericTypeSpec\n   : SimpleTypeSpec ` NUMBER\n\nPointerTypeSpec\n    : SimpleTypeSpec '*'\n    ;\n\nArrayTypeSpec\n    : SimpleTypeSpec '[ReflectionDimension]'\n    | SimpleTypeSpec '[ReflectionEmitDimension]'\n    ;\n\nReflectionDimension\n    : '*'\n    | ReflectionDimension ',' ReflectionDimension\n    | NOTOKEN\n    ;\n\nReflectionEmitDimension\n    : '*'\n    | Number '..' Number\n    | Number '…'\n    | ReflectionDimension ',' ReflectionDimension\n    | NOTOKEN\n    ;\n\nNumber\n    : [0-9]+\n    ;\n\nTypeName\n    : NamespaceTypeName\n    | NamespaceTypeName ',' AssemblyNameSpec\n    ;\n\nNamespaceTypeName\n    : NestedTypeName\n    | NamespaceSpec '.' NestedTypeName\n    ;\n\nNestedTypeName\n    : IDENTIFIER\n    | NestedTypeName '+' IDENTIFIER\n    ;\n\nNamespaceSpec\n    : IDENTIFIER\n    | NamespaceSpec '.' IDENTIFIER\n    ;\n\nAssemblyNameSpec\n    : IDENTIFIER\n    | IDENTIFIER ',' AssemblyProperties\n    ;\n\nAssemblyProperties\n    : AssemblyProperty\n    | AssemblyProperties ',' AssemblyProperty\n    ;\n\nAssemblyProperty\n    : AssemblyPropertyName '=' AssemblyPropertyValue\n    ;\n```\n<!-- markdownlint-enable MD010 -->\n\n## Specifying special characters\n\nIn a type name, IDENTIFIER is any valid name determined by the rules of a language.\n\nUse the backslash (\\\\) as an escape character to separate the following tokens when used as part of IDENTIFIER.\n\n|Token|Meaning|\n|-----------|-------------|\n|\\\\,|Assembly separator.|\n|\\\\+|Nested type separator.|\n|\\\\&|Reference type.|\n|\\\\*|Pointer type.|\n|\\\\[|Array dimension delimiter.|\n|\\\\]|Array dimension delimiter.|\n|\\\\.|Use the backslash before a period only if the period is used in an array specification. Periods in NamespaceSpec do not take the backslash.|\n|\\\\\\|Backslash when needed as a string literal.|\n\nNote that in all TypeSpec components except AssemblyNameSpec, spaces are relevant. In the AssemblyNameSpec, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.\n\nReflection classes, such as <xref:System.Type.FullName%2A?displayProperty=nameWithType>, return the mangled name so that the returned name can be used in a call to <xref:System.Type.GetType%2A>, as in `MyType.GetType(myType.FullName)`.\n\nFor example, the fully qualified name for a type might be `Ozzy.OutBack.Kangaroo+Wallaby,MyAssembly`.\n\nIf the namespace were `Ozzy.Out+Back`, then the plus sign must be preceded by a backslash. Otherwise, the parser would interpret it as a nesting separator. Reflection emits this string as `Ozzy.Out\\+Back.Kangaroo+Wallaby,MyAssembly`.\n\n## Specifying assembly names\n\nThe minimum information required in an assembly name specification is the textual name (IDENTIFIER) of the assembly. You can follow the IDENTIFIER by a comma-separated list of property/value pairs as described in the following table. IDENTIFIER naming should follow the rules for file naming. The IDENTIFIER is case-insensitive.\n\n|Property name|Description|Allowable values|\n|-------------------|-----------------|----------------------|\n|**Version**|Assembly version number|*Major.Minor.Build.Revision*, where *Major*, *Minor*, *Build*, and *Revision* are integers between 0 and 65535 inclusive.|\n|**PublicKey**|Full public key|String value of full public key in hexadecimal format. Specify a null reference (**Nothing** in Visual Basic) to explicitly indicate a private assembly.|\n|**PublicKeyToken**|Public key token (8-byte hash of the full public key)|String value of public key token in hexadecimal format. Specify a null reference (**Nothing** in Visual Basic) to explicitly indicate a private assembly.|\n|**Culture**|Assembly culture|Culture of the assembly in RFC-1766 format, or \"neutral\" for language-independent (nonsatellite) assemblies.|\n|**Custom**|Custom binary large object (BLOB). This is currently used only in assemblies generated by the [Native Image Generator (Ngen)](../../../docs/framework/tools/ngen-exe-native-image-generator.md).|Custom string used by the Native Image Generator tool to notify the assembly cache that the assembly being installed is a native image, and is therefore to be installed in the native image cache. Also called a zap string.|\n\nThe following example shows an **AssemblyName** for a simply named assembly with default culture.\n\n```csharp\ncom.microsoft.crypto, Culture=\"\"\n```\n\nThe following example shows a fully specified reference for a strongly named assembly with culture \"en\".\n\n```csharp\ncom.microsoft.crypto, Culture=en, PublicKeyToken=a5d015c7d5a0b012,\n    Version=1.0.0.0\n```\n\nThe following examples each show a partially specified **AssemblyName**, which can be satisfied by either a strong or a simply named assembly.\n\n```csharp\ncom.microsoft.crypto\ncom.microsoft.crypto, Culture=\"\"\ncom.microsoft.crypto, Culture=en\n```\n\nThe following examples each show a partially specified **AssemblyName**, which must be satisfied by a simply named assembly.\n\n```csharp\ncom.microsoft.crypto, Culture=\"\", PublicKeyToken=null\ncom.microsoft.crypto, Culture=en, PublicKeyToken=null\n```\n\nThe following examples each show a partially specified **AssemblyName**, which must be satisfied by a strongly named assembly.\n\n```csharp\ncom.microsoft.crypto, Culture=\"\", PublicKeyToken=a5d015c7d5a0b012\ncom.microsoft.crypto, Culture=en, PublicKeyToken=a5d015c7d5a0b012,\n    Version=1.0.0.0\n```\n## Specifying generic types\n\nSimpleTypeSpec\\`NUMBER represents an open generic type with from 1 to *n* generic type parameters. For example, to get reference to the open generic type List\\<T> or the closed generic type List\\<String>, use ``Type.GetType(\"System.Collections.Generic.List`1\")`` To get a reference to the generic type Dictionary\\<TKey,TValue>, use ``Type.GetType(\"System.Collections.Generic.Dictionary`2\")``.\n\n## Specifying pointers\n\nSimpleTypeSpec* represents an unmanaged pointer. For example, to get a pointer to type MyType, use `Type.GetType(\"MyType*\")`. To get a pointer to a pointer to type MyType, use `Type.GetType(\"MyType**\")`.\n\n## Specifying references\n\nSimpleTypeSpec & represents a managed pointer or reference. For example, to get a reference to type MyType, use `Type.GetType(\"MyType &\")`. Note that unlike pointers, references are limited to one level.\n\n## Specifying arrays\n\nIn the BNF Grammar, ReflectionEmitDimension only applies to incomplete type definitions retrieved using <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>. Incomplete type definitions are <xref:System.Reflection.Emit.TypeBuilder> objects constructed using <xref:System.Reflection.Emit?displayProperty=nameWithType> but on which <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> has not been called. ReflectionDimension can be used to retrieve any type definition that has been completed, that is, a type that has been loaded.\n\nArrays are accessed in reflection by specifying the rank of the array:\n\n- `Type.GetType(\"MyArray[]\")` gets a single-dimension array with 0 lower bound.\n\n- `Type.GetType(\"MyArray[*]\")` gets a single-dimension array with unknown lower bound.\n- `Type.GetType(\"MyArray[][]\")` gets a two-dimensional array's array.\n\n- `Type.GetType(\"MyArray[*,*]\")` and `Type.GetType(\"MyArray[,]\")` gets a rectangular two-dimensional array with unknown lower bounds.\n\nNote that from a runtime point of view, `MyArray[] != MyArray[*]`, but for multidimensional arrays, the two notations are equivalent. That is, `Type.GetType(\"MyArray [,]\") == Type.GetType(\"MyArray[*,*]\")` evaluates to **true**.\n\nFor **ModuleBuilder.GetType**, `MyArray[0..5]` indicates a single-dimension array with size 6, lower bound 0. `MyArray[4…]` indicates a single-dimension array of unknown size and lower bound 4.\n\n## See also\n\n- <xref:System.Reflection.AssemblyName>\n- <xref:System.Reflection.Emit.ModuleBuilder>\n- <xref:System.Reflection.Emit.TypeBuilder>\n- <xref:System.Type.FullName%2A?displayProperty=nameWithType>\n- <xref:System.Type.GetType%2A?displayProperty=nameWithType>\n- <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>\n- [Viewing Type Information](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)\n","nodes":[{"pos":[4,506],"embed":true,"restype":"x-metadata","content":"title: \"Specifying Fully Qualified Type Names\"\nms.date: \"02/21/2019\"\nhelpviewer_keywords:\n  - \"names [.NET Framework], fully qualified type names\"\n  - \"reflection, fully qualified type names\"\n  - \"names [.NET Framework], assemblies\"\n  - \"tokens\"\n  - \"BNF\"\n  - \"assemblies [.NET Framework], names\"\n  - \"languages, grammar\"\n  - \"fully qualified type names\"\n  - \"type names\"\n  - \"special characters\"\n  - \"IDENTIFIER\"\nms.assetid: d90b1e39-9115-4f2a-81c0-05e7e74e5580\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Specifying Fully Qualified Type Names","nodes":[{"pos":[0,37],"content":"Specifying Fully Qualified Type Names","nodes":[{"content":"Specifying Fully Qualified Type Names","pos":[0,37]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[514,551],"content":"Specifying fully qualified type names","linkify":"Specifying fully qualified type names","nodes":[{"content":"Specifying fully qualified type names","pos":[0,37]}]},{"content":"You must specify type names to have valid input to various reflection operations.","pos":[553,634]},{"content":"A fully qualified type name consists of an assembly name specification, a namespace specification, and a type name.","pos":[635,750]},{"content":"Type name specifications are used by methods such as <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>.","pos":[751,1100],"source":" Type name specifications are used by methods such as <xref:System.Type.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>."},{"pos":[1105,1127],"content":"Grammar for type names","linkify":"Grammar for type names","nodes":[{"content":"Grammar for type names","pos":[0,22]}]},{"content":"The grammar defines the syntax of formal languages.","pos":[1130,1181]},{"content":"The following table lists lexical rules that describe how to recognize a valid input.","pos":[1182,1267]},{"content":"Terminals (those elements that are not further reducible) are shown in all uppercase letters.","pos":[1268,1361]},{"content":"Nonterminals (those elements that are further reducible) are shown in mixed-case or singly quoted strings, but the single quote (') is not a part of the syntax itself.","pos":[1362,1529]},{"content":"The pipe character (&amp;#124;) denotes rules that have subrules.","pos":[1530,1591],"source":" The pipe character (&#124;) denotes rules that have subrules."},{"pos":[2927,2956],"content":"Specifying special characters","linkify":"Specifying special characters","nodes":[{"content":"Specifying special characters","pos":[0,29]}]},{"content":"In a type name, IDENTIFIER is any valid name determined by the rules of a language.","pos":[2958,3041]},{"content":"Use the backslash (<ph id=\"ph1\">\\\\</ph>) as an escape character to separate the following tokens when used as part of IDENTIFIER.","pos":[3043,3154],"source":"Use the backslash (\\\\) as an escape character to separate the following tokens when used as part of IDENTIFIER."},{"content":"Token","pos":[3157,3162]},{"content":"Meaning","pos":[3163,3170]},{"content":"<ph id=\"ph1\">\\\\</ph>,","pos":[3201,3204],"source":"\\\\,"},{"content":"Assembly separator.","pos":[3205,3224]},{"content":"Nested type separator.","pos":[3231,3253]},{"content":"Reference type.","pos":[3260,3275]},{"content":"Pointer type.","pos":[3282,3295]},{"content":"<ph id=\"ph1\">\\\\</ph>[","pos":[3298,3301],"source":"\\\\["},{"content":"Array dimension delimiter.","pos":[3302,3328]},{"content":"<ph id=\"ph1\">\\\\</ph>]","pos":[3331,3334],"source":"\\\\]"},{"content":"Array dimension delimiter.","pos":[3335,3361]},{"content":"<ph id=\"ph1\">\\\\</ph>.","pos":[3364,3367],"source":"\\\\."},{"content":"Use the backslash before a period only if the period is used in an array specification.","pos":[3368,3455]},{"content":"Periods in NamespaceSpec do not take the backslash.","pos":[3456,3507]},{"content":"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">\\|</ph>Backslash when needed as a string literal.","pos":[3510,3556],"source":"\\\\\\|Backslash when needed as a string literal."},{"content":"Note that in all TypeSpec components except AssemblyNameSpec, spaces are relevant.","pos":[3559,3641]},{"content":"In the AssemblyNameSpec, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[3642,3760]},{"pos":[3762,3997],"content":"Reflection classes, such as <ph id=\"ph1\">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph>, return the mangled name so that the returned name can be used in a call to <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph>, as in <ph id=\"ph3\">`MyType.GetType(myType.FullName)`</ph>.","source":"Reflection classes, such as <xref:System.Type.FullName%2A?displayProperty=nameWithType>, return the mangled name so that the returned name can be used in a call to <xref:System.Type.GetType%2A>, as in `MyType.GetType(myType.FullName)`."},{"pos":[3999,4100],"content":"For example, the fully qualified name for a type might be <ph id=\"ph1\">`Ozzy.OutBack.Kangaroo+Wallaby,MyAssembly`</ph>.","source":"For example, the fully qualified name for a type might be `Ozzy.OutBack.Kangaroo+Wallaby,MyAssembly`."},{"content":"If the namespace were <ph id=\"ph1\">`Ozzy.Out+Back`</ph>, then the plus sign must be preceded by a backslash.","pos":[4102,4192],"source":"If the namespace were `Ozzy.Out+Back`, then the plus sign must be preceded by a backslash."},{"content":"Otherwise, the parser would interpret it as a nesting separator.","pos":[4193,4257]},{"content":"Reflection emits this string as <ph id=\"ph1\">`Ozzy.Out\\+Back.Kangaroo+Wallaby,MyAssembly`</ph>.","pos":[4258,4335],"source":" Reflection emits this string as `Ozzy.Out\\+Back.Kangaroo+Wallaby,MyAssembly`."},{"pos":[4340,4365],"content":"Specifying assembly names","linkify":"Specifying assembly names","nodes":[{"content":"Specifying assembly names","pos":[0,25]}]},{"content":"The minimum information required in an assembly name specification is the textual name (IDENTIFIER) of the assembly.","pos":[4367,4483]},{"content":"You can follow the IDENTIFIER by a comma-separated list of property/value pairs as described in the following table.","pos":[4484,4600]},{"content":"IDENTIFIER naming should follow the rules for file naming.","pos":[4601,4659]},{"content":"The IDENTIFIER is case-insensitive.","pos":[4660,4695]},{"content":"Property name","pos":[4698,4711]},{"content":"Description","pos":[4712,4723]},{"content":"Allowable values","pos":[4724,4740]},{"pos":[4806,4817],"content":"<bpt id=\"p1\">**</bpt>Version<ept id=\"p1\">**</ept>","source":"**Version**"},{"content":"Assembly version number","pos":[4818,4841]},{"pos":[4842,4963],"content":"<bpt id=\"p1\">*</bpt>Major.Minor.Build.Revision<ept id=\"p1\">*</ept>, where <bpt id=\"p2\">*</bpt>Major<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>Minor<ept id=\"p3\">*</ept>, <bpt id=\"p4\">*</bpt>Build<ept id=\"p4\">*</ept>, and <bpt id=\"p5\">*</bpt>Revision<ept id=\"p5\">*</ept> are integers between 0 and 65535 inclusive.","source":"*Major.Minor.Build.Revision*, where *Major*, *Minor*, *Build*, and *Revision* are integers between 0 and 65535 inclusive."},{"pos":[4966,4979],"content":"<bpt id=\"p1\">**</bpt>PublicKey<ept id=\"p1\">**</ept>","source":"**PublicKey**"},{"content":"Full public key","pos":[4980,4995]},{"content":"String value of full public key in hexadecimal format.","pos":[4996,5050]},{"content":"Specify a null reference (<bpt id=\"p1\">**</bpt>Nothing<ept id=\"p1\">**</ept> in Visual Basic) to explicitly indicate a private assembly.","pos":[5051,5148],"source":" Specify a null reference (**Nothing** in Visual Basic) to explicitly indicate a private assembly."},{"pos":[5151,5169],"content":"<bpt id=\"p1\">**</bpt>PublicKeyToken<ept id=\"p1\">**</ept>","source":"**PublicKeyToken**"},{"content":"Public key token (8-byte hash of the full public key)","pos":[5170,5223]},{"content":"String value of public key token in hexadecimal format.","pos":[5224,5279]},{"content":"Specify a null reference (<bpt id=\"p1\">**</bpt>Nothing<ept id=\"p1\">**</ept> in Visual Basic) to explicitly indicate a private assembly.","pos":[5280,5377],"source":" Specify a null reference (**Nothing** in Visual Basic) to explicitly indicate a private assembly."},{"pos":[5380,5391],"content":"<bpt id=\"p1\">**</bpt>Culture<ept id=\"p1\">**</ept>","source":"**Culture**"},{"content":"Assembly culture","pos":[5392,5408]},{"content":"Culture of the assembly in RFC-1766 format, or \"neutral\" for language-independent (nonsatellite) assemblies.","pos":[5409,5517]},{"pos":[5520,5530],"content":"<bpt id=\"p1\">**</bpt>Custom<ept id=\"p1\">**</ept>","source":"**Custom**"},{"content":"Custom binary large object (BLOB).","pos":[5531,5565]},{"content":"This is currently used only in assemblies generated by the <bpt id=\"p1\">[</bpt>Native Image Generator (Ngen)<ept id=\"p1\">](../../../docs/framework/tools/ngen-exe-native-image-generator.md)</ept>.","pos":[5566,5723],"source":" This is currently used only in assemblies generated by the [Native Image Generator (Ngen)](../../../docs/framework/tools/ngen-exe-native-image-generator.md)."},{"content":"Custom string used by the Native Image Generator tool to notify the assembly cache that the assembly being installed is a native image, and is therefore to be installed in the native image cache.","pos":[5724,5919]},{"content":"Also called a zap string.","pos":[5920,5945]},{"pos":[5948,6045],"content":"The following example shows an <bpt id=\"p1\">**</bpt>AssemblyName<ept id=\"p1\">**</ept> for a simply named assembly with default culture.","source":"The following example shows an **AssemblyName** for a simply named assembly with default culture."},{"content":"The following example shows a fully specified reference for a strongly named assembly with culture \"en\".","pos":[6095,6199]},{"pos":[6303,6445],"content":"The following examples each show a partially specified <bpt id=\"p1\">**</bpt>AssemblyName<ept id=\"p1\">**</ept>, which can be satisfied by either a strong or a simply named assembly.","source":"The following examples each show a partially specified **AssemblyName**, which can be satisfied by either a strong or a simply named assembly."},{"pos":[6549,6673],"content":"The following examples each show a partially specified <bpt id=\"p1\">**</bpt>AssemblyName<ept id=\"p1\">**</ept>, which must be satisfied by a simply named assembly.","source":"The following examples each show a partially specified **AssemblyName**, which must be satisfied by a simply named assembly."},{"pos":[6798,6924],"content":"The following examples each show a partially specified <bpt id=\"p1\">**</bpt>AssemblyName<ept id=\"p1\">**</ept>, which must be satisfied by a strongly named assembly.","source":"The following examples each show a partially specified **AssemblyName**, which must be satisfied by a strongly named assembly."},{"pos":[7096,7120],"content":"Specifying generic types","linkify":"Specifying generic types","nodes":[{"content":"Specifying generic types","pos":[0,24]}]},{"content":"SimpleTypeSpec<ph id=\"ph1\">\\`</ph>NUMBER represents an open generic type with from 1 to <bpt id=\"p1\">*</bpt>n<ept id=\"p1\">*</ept> generic type parameters.","pos":[7122,7220],"source":"SimpleTypeSpec\\`NUMBER represents an open generic type with from 1 to *n* generic type parameters."},{"content":"For example, to get reference to the open generic type List<ph id=\"ph1\">\\&lt;</ph>T&gt; or the closed generic type List<ph id=\"ph2\">\\&lt;</ph>String&gt;, use <ph id=\"ph3\">``Type.GetType(\"System.Collections.Generic.List`1\")``</ph> To get a reference to the generic type Dictionary<ph id=\"ph4\">\\&lt;</ph>TKey,TValue&gt;, use <ph id=\"ph5\">``Type.GetType(\"System.Collections.Generic.Dictionary`2\")``</ph>.","pos":[7221,7514],"source":" For example, to get reference to the open generic type List\\<T> or the closed generic type List\\<String>, use ``Type.GetType(\"System.Collections.Generic.List`1\")`` To get a reference to the generic type Dictionary\\<TKey,TValue>, use ``Type.GetType(\"System.Collections.Generic.Dictionary`2\")``."},{"pos":[7519,7538],"content":"Specifying pointers","linkify":"Specifying pointers","nodes":[{"content":"Specifying pointers","pos":[0,19]}]},{"content":"SimpleTypeSpec* represents an unmanaged pointer.","pos":[7540,7588]},{"content":"For example, to get a pointer to type MyType, use <ph id=\"ph1\">`Type.GetType(\"MyType*\")`</ph>.","pos":[7589,7665],"source":" For example, to get a pointer to type MyType, use `Type.GetType(\"MyType*\")`."},{"content":"To get a pointer to a pointer to type MyType, use <ph id=\"ph1\">`Type.GetType(\"MyType**\")`</ph>.","pos":[7666,7743],"source":" To get a pointer to a pointer to type MyType, use `Type.GetType(\"MyType**\")`."},{"pos":[7748,7769],"content":"Specifying references","linkify":"Specifying references","nodes":[{"content":"Specifying references","pos":[0,21]}]},{"content":"SimpleTypeSpec &amp; represents a managed pointer or reference.","pos":[7771,7830],"source":"SimpleTypeSpec & represents a managed pointer or reference."},{"content":"For example, to get a reference to type MyType, use <ph id=\"ph1\">`Type.GetType(\"MyType &amp;\")`</ph>.","pos":[7831,7910],"source":" For example, to get a reference to type MyType, use `Type.GetType(\"MyType &\")`."},{"content":"Note that unlike pointers, references are limited to one level.","pos":[7911,7974]},{"pos":[7979,7996],"content":"Specifying arrays","linkify":"Specifying arrays","nodes":[{"content":"Specifying arrays","pos":[0,17]}]},{"content":"In the BNF Grammar, ReflectionEmitDimension only applies to incomplete type definitions retrieved using <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType&gt;</ph>.","pos":[7998,8186],"source":"In the BNF Grammar, ReflectionEmitDimension only applies to incomplete type definitions retrieved using <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>."},{"content":"Incomplete type definitions are <ph id=\"ph1\">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> objects constructed using <ph id=\"ph2\">&lt;xref:System.Reflection.Emit?displayProperty=nameWithType&gt;</ph> but on which <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> has not been called.","pos":[8187,8464],"source":" Incomplete type definitions are <xref:System.Reflection.Emit.TypeBuilder> objects constructed using <xref:System.Reflection.Emit?displayProperty=nameWithType> but on which <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> has not been called."},{"content":"ReflectionDimension can be used to retrieve any type definition that has been completed, that is, a type that has been loaded.","pos":[8465,8591]},{"content":"Arrays are accessed in reflection by specifying the rank of the array:","pos":[8593,8663]},{"pos":[8667,8744],"content":"<ph id=\"ph1\">`Type.GetType(\"MyArray[]\")`</ph> gets a single-dimension array with 0 lower bound.","source":"`Type.GetType(\"MyArray[]\")` gets a single-dimension array with 0 lower bound."},{"pos":[8748,8832],"content":"<ph id=\"ph1\">`Type.GetType(\"MyArray[*]\")`</ph> gets a single-dimension array with unknown lower bound.","source":"`Type.GetType(\"MyArray[*]\")` gets a single-dimension array with unknown lower bound."},{"pos":[8835,8902],"content":"<ph id=\"ph1\">`Type.GetType(\"MyArray[][]\")`</ph> gets a two-dimensional array's array.","source":"`Type.GetType(\"MyArray[][]\")` gets a two-dimensional array's array."},{"pos":[8906,9037],"content":"<ph id=\"ph1\">`Type.GetType(\"MyArray[*,*]\")`</ph> and <ph id=\"ph2\">`Type.GetType(\"MyArray[,]\")`</ph> gets a rectangular two-dimensional array with unknown lower bounds.","source":"`Type.GetType(\"MyArray[*,*]\")` and `Type.GetType(\"MyArray[,]\")` gets a rectangular two-dimensional array with unknown lower bounds."},{"content":"Note that from a runtime point of view, <ph id=\"ph1\">`MyArray[] != MyArray[*]`</ph>, but for multidimensional arrays, the two notations are equivalent.","pos":[9039,9172],"source":"Note that from a runtime point of view, `MyArray[] != MyArray[*]`, but for multidimensional arrays, the two notations are equivalent."},{"content":"That is, <ph id=\"ph1\">`Type.GetType(\"MyArray [,]\") == Type.GetType(\"MyArray[*,*]\")`</ph> evaluates to <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept>.","pos":[9173,9266],"source":" That is, `Type.GetType(\"MyArray [,]\") == Type.GetType(\"MyArray[*,*]\")` evaluates to **true**."},{"content":"For <bpt id=\"p1\">**</bpt>ModuleBuilder.GetType<ept id=\"p1\">**</ept>, <ph id=\"ph1\">`MyArray[0..5]`</ph> indicates a single-dimension array with size 6, lower bound 0.","pos":[9268,9377],"source":"For **ModuleBuilder.GetType**, `MyArray[0..5]` indicates a single-dimension array with size 6, lower bound 0."},{"content":"<ph id=\"ph1\">`MyArray[4…]`</ph> indicates a single-dimension array of unknown size and lower bound 4.","pos":[9378,9461],"source":"`MyArray[4…]` indicates a single-dimension array of unknown size and lower bound 4."},{"pos":[9466,9474],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9806,9908],"content":"<bpt id=\"p1\">[</bpt>Viewing Type Information<ept id=\"p1\">](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)</ept>","source":"[Viewing Type Information](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)"}]}