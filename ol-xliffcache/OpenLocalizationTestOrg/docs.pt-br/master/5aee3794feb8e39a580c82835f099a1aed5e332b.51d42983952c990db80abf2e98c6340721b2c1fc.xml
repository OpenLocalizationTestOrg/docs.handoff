{"content":"---\ntitle: \"Covariance and Contravariance in Generics | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"generics, covariance and contravariance\"\n  - \"generics, variance\"\n  - \"covariance and contravariance in generics\"\n  - \"generic type parameters\"\nms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e\ncaps.latest.revision: 24\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"\n---\n# Covariance and Contravariance in Generics\n<a name=\"top\"></a> Covariance and contravariance are terms that refer to the ability to use a less derived (less specific) or more derived type (more specific) than originally specified. Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types. When you are referring to a type system, covariance, contravariance, and invariance have the following definitions. The examples assume a base class named `Base` and a derived class named `Derived`.  \n  \n-   `Covariance`  \n  \n     Enables you to use a more derived type than originally specified.  \n  \n     You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.  \n  \n-   `Contravariance`  \n  \n     Enables you to use a more generic (less derived) type than originally specified.  \n  \n     You can assign an instance of `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) to a variable of type `IEnumerable<Derived>`.  \n  \n-   `Invariance`  \n  \n     Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.  \n  \n     You cannot assign an instance of `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) to a variable of type `IEnumerable<Derived>` or vice versa.  \n  \n Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.  \n  \n [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]\n [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  \n  \n The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`. The covariant type parameter does the rest.  \n  \n Contravariance, on the other hand, seems counterintuitive. The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.  \n  \n [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]\n [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  \n  \n This seems backward, but it is type-safe code that compiles and runs. The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value. The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant. The code is type-safe because `T` specifies a parameter type. When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`. This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.  \n  \n In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types. For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.  \n  \n Covariance and contravariance are collectively referred to as *variance*. A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*. A brief summary of facts about variance in the common language runtime:  \n  \n-   In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], variant type parameters are restricted to generic interface and generic delegate types.  \n  \n-   A generic interface or generic delegate type can have both covariant and contravariant type parameters.  \n  \n-   Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.  \n  \n-   Variance does not apply to delegate combination. That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe. Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.  \n  \n The following subsections describe covariant and contravariant type parameters in detail:  \n  \n-   [Generic Interfaces with Covariant Type Parameters](#InterfaceCovariantTypeParameters)  \n  \n-   [Generic Interfaces with Contravariant Generic Type Parameters](#InterfaceCovariantTypeParameters)  \n  \n-   [Generic Delegates with Variant Type Parameters](#DelegateVariantTypeParameters)  \n  \n-   [Defining Variant Generic Interfaces and Delegates](#DefiningVariantTypeParameters)  \n  \n-   [List of Variant Generic Interface and Delegate Types](#VariantList)  \n  \n<a name=\"InterfaceCovariantTypeParameters\"></a>   \n## Generic Interfaces with Covariant Type Parameters  \n Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>. All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.  \n  \n The following example illustrates covariant type parameters. The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements. `Derived` inherits from `Base`. The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting. <xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter. The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.  \n  \n [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]\n [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  \n  \n [Back to top](#top)  \n  \n<a name=\"InterfaceContravariantTypeParameters\"></a>   \n## Generic Interfaces with Contravariant Generic Type Parameters  \n Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>. These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.  \n  \n The following example illustrates contravariant type parameters. The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property. The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic). The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=fullName> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.  \n  \n The `Circle` class inherits `Shape` and overrides `Area`. The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic). However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`. The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.  \n  \n When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element. The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe. Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.  \n  \n [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]\n [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  \n  \n [Back to top](#top)  \n  \n<a name=\"DelegateVariantTypeParameters\"></a>   \n## Generic Delegates with Variant Type Parameters  \n In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types. The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types. This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.  \n  \n> [!NOTE]\n>  The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature. It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).  \n  \n The following code illustrates this. The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`. The method takes an instance of `Base` and returns an instance of `Derived`. (If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.  \n  \n [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]\n [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  \n  \n The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.  \n  \n [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]\n [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  \n  \n The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.  \n  \n [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]\n [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  \n  \n The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.  \n  \n [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]\n [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  \n  \n### Variance in Generic and Non-Generic Delegates  \n In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic). The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.  \n  \n This is an important point. The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates](http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)). However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters. Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.  \n  \n The following example shows the combined effects of variance in delegate binding and variance in generic type parameters. The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`). Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`. The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters. The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.  \n  \n [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]\n [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  \n  \n [Back to top](#top)  \n  \n<a name=\"DefiningVariantTypeParameters\"></a>   \n## Defining Variant Generic Interfaces and Delegates  \n Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.  \n  \n> [!NOTE]\n>  Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters. Prior to the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.  \n  \n A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)). You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate. You cannot use a covariant type parameter as a generic type constraint for interface methods.  \n  \n> [!NOTE]\n>  If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.  \n  \n A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)). You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate. You can use a contravariant type parameter as a generic type constraint for an interface method.  \n  \n Only interface types and delegate types can have variant type parameters. An interface or delegate type can have both covariant and contravariant type parameters.  \n  \n Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates. The [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.  \n  \n For information and example code, see [Variance in Generic Interfaces](http://msdn.microsoft.com/library/e14322da-1db3-42f2-9a67-397daddd6b6a).  \n  \n [Back to top](#top)  \n  \n<a name=\"VariantList\"></a>   \n## List of Variant Generic Interface and Delegate Types  \n In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the following interface and delegate types have covariant and/or contravariant type parameters.  \n  \n|Type|Covariant type parameters|Contravariant type parameters|  \n|----------|-------------------------------|-----------------------------------|  \n|<xref:System.Action%601> to <xref:System.Action%6016>||Yes|  \n|<xref:System.Comparison%601>||Yes|  \n|<xref:System.Converter%602>|Yes|Yes|  \n|<xref:System.Func%601>|Yes||  \n|<xref:System.Func%602> to <xref:System.Func%6017>|Yes|Yes|  \n|<xref:System.IComparable%601>||Yes|  \n|<xref:System.Predicate%601>||Yes|  \n|<xref:System.Collections.Generic.IComparer%601>||Yes|  \n|<xref:System.Collections.Generic.IEnumerable%601>|Yes||  \n|<xref:System.Collections.Generic.IEnumerator%601>|Yes||  \n|<xref:System.Collections.Generic.IEqualityComparer%601>||Yes|  \n|<xref:System.Linq.IGrouping%602>|Yes||  \n|<xref:System.Linq.IOrderedEnumerable%601>|Yes||  \n|<xref:System.Linq.IOrderedQueryable%601>|Yes||  \n|<xref:System.Linq.IQueryable%601>|Yes||  \n  \n## See Also  \n [Covariance and Contravariance](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8)   \n [Variance in Delegates](http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)","nodes":[{"pos":[4,523],"embed":true,"restype":"x-metadata","content":"title: \"Covariance and Contravariance in Generics | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"generics, covariance and contravariance\"\n  - \"generics, variance\"\n  - \"covariance and contravariance in generics\"\n  - \"generic type parameters\"\nms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e\ncaps.latest.revision: 24\nauthor: \"mairaw\"\nms.author: \"mairaw\"\nmanager: \"wpickett\"","nodes":[{"content":"Covariance and Contravariance in Generics | Microsoft Docs","nodes":[{"pos":[0,58],"content":"Covariance and Contravariance in Generics | Microsoft Docs","nodes":[{"content":"Covariance and Contravariance in Generics | Microsoft Docs","pos":[0,58]}]}],"path":["title"]}],"yml":true},{"pos":[530,571],"content":"Covariance and Contravariance in Generics","linkify":"Covariance and Contravariance in Generics","nodes":[{"content":"Covariance and Contravariance in Generics","pos":[0,41]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> Covariance and contravariance are terms that refer to the ability to use a less derived (less specific) or more derived type (more specific) than originally specified.","pos":[572,758],"source":"<a name=\"top\"></a> Covariance and contravariance are terms that refer to the ability to use a less derived (less specific) or more derived type (more specific) than originally specified."},{"content":"Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.","pos":[759,889]},{"content":"When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.","pos":[890,1005]},{"content":"The examples assume a base class named <ph id=\"ph1\">`Base`</ph> and a derived class named <ph id=\"ph2\">`Derived`</ph>.","pos":[1006,1088],"source":" The examples assume a base class named `Base` and a derived class named `Derived`."},{"content":"Enables you to use a more derived type than originally specified.","pos":[1121,1186]},{"pos":[1197,1336],"content":"You can assign an instance of <ph id=\"ph1\">`IEnumerable&lt;Derived&gt;`</ph> (<ph id=\"ph2\">`IEnumerable(Of Derived)`</ph> in Visual Basic) to a variable of type <ph id=\"ph3\">`IEnumerable&lt;Base&gt;`</ph>.","source":"You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`."},{"content":"Enables you to use a more generic (less derived) type than originally specified.","pos":[1373,1453]},{"pos":[1464,1600],"content":"You can assign an instance of <ph id=\"ph1\">`IEnumerable&lt;Base&gt;`</ph> (<ph id=\"ph2\">`IEnumerable(Of Base)`</ph> in Visual Basic) to a variable of type <ph id=\"ph3\">`IEnumerable&lt;Derived&gt;`</ph>.","source":"You can assign an instance of `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) to a variable of type `IEnumerable<Derived>`."},{"content":"Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.","pos":[1633,1770]},{"pos":[1781,1934],"content":"You cannot assign an instance of <ph id=\"ph1\">`IEnumerable&lt;Base&gt;`</ph> (<ph id=\"ph2\">`IEnumerable(Of Base)`</ph> in Visual Basic) to a variable of type <ph id=\"ph3\">`IEnumerable&lt;Derived&gt;`</ph> or vice versa.","source":"You cannot assign an instance of `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) to a variable of type `IEnumerable<Derived>` or vice versa."},{"pos":[1941,2143],"content":"Covariant type parameters enable you to make assignments that look much like ordinary <bpt id=\"p1\">[</bpt>Polymorphism<ept id=\"p1\">](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md)</ept>, as shown in the following code.","source":"Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](~/docs/csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code."},{"pos":[2150,2399],"content":"[!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]\n[!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]","leadings":[""," "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContraSimpleIEnum#1<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[0,123],"source":"[!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContraSimpleIEnum#1<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[124,248],"source":"[!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]"}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class implements the <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface, so <ph id=\"ph3\">`List&lt;Derived&gt;`</ph> (<ph id=\"ph4\">`List(Of Derived)`</ph> in Visual Basic) implements <ph id=\"ph5\">`IEnumerable&lt;Derived&gt;`</ph>.","pos":[2406,2625],"source":"The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`."},{"content":"The covariant type parameter does the rest.","pos":[2626,2669]},{"content":"Contravariance, on the other hand, seems counterintuitive.","pos":[2676,2734]},{"content":"The following example creates a delegate of type <ph id=\"ph1\">`Action&lt;Base&gt;`</ph> (<ph id=\"ph2\">`Action(Of Base)`</ph> in Visual Basic), and then assigns that delegate to a variable of type <ph id=\"ph3\">`Action&lt;Derived&gt;`</ph>.","pos":[2735,2907],"source":" The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`."},{"pos":[2914,3167],"content":"[!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]\n[!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]","leadings":[""," "],"nodes":[{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContraSimpleAction#1<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[0,125],"source":"[!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContraSimpleAction#1<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[126,252],"source":"[!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]"}]},{"content":"This seems backward, but it is type-safe code that compiles and runs.","pos":[3174,3243]},{"content":"The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type <ph id=\"ph1\">`Base`</ph> and that has no return value.","pos":[3244,3398],"source":" The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value."},{"content":"The resulting delegate can be assigned to a variable of type <ph id=\"ph1\">`Action&lt;Derived&gt;`</ph> because the type parameter <ph id=\"ph2\">`T`</ph> of the <ph id=\"ph3\">&lt;xref:System.Action%601&gt;</ph> delegate is contravariant.","pos":[3399,3567],"source":" The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant."},{"content":"The code is type-safe because <ph id=\"ph1\">`T`</ph> specifies a parameter type.","pos":[3568,3629],"source":" The code is type-safe because `T` specifies a parameter type."},{"content":"When the delegate of type <ph id=\"ph1\">`Action&lt;Base&gt;`</ph> is invoked as if it were a delegate of type <ph id=\"ph2\">`Action&lt;Derived&gt;`</ph>, its argument must be of type <ph id=\"ph3\">`Derived`</ph>.","pos":[3630,3773],"source":" When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`."},{"content":"This argument can always be passed safely to the underlying method, because the method's parameter is of type <ph id=\"ph1\">`Base`</ph>.","pos":[3774,3891],"source":" This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`."},{"content":"In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.","pos":[3898,4048]},{"content":"For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.","pos":[4049,4249]},{"content":"Covariance and contravariance are collectively referred to as <bpt id=\"p1\">*</bpt>variance<ept id=\"p1\">*</ept>.","pos":[4256,4329],"source":"Covariance and contravariance are collectively referred to as *variance*."},{"content":"A generic type parameter that is not marked covariant or contravariant is referred to as <bpt id=\"p1\">*</bpt>invariant<ept id=\"p1\">*</ept>.","pos":[4330,4431],"source":" A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*."},{"content":"A brief summary of facts about variance in the common language runtime:","pos":[4432,4503]},{"pos":[4513,4671],"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, variant type parameters are restricted to generic interface and generic delegate types.","source":"In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], variant type parameters are restricted to generic interface and generic delegate types."},{"content":"A generic interface or generic delegate type can have both covariant and contravariant type parameters.","pos":[4681,4784]},{"content":"Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.","pos":[4794,4962]},{"content":"Variance does not apply to delegate combination.","pos":[4972,5020]},{"content":"That is, given two delegates of types <ph id=\"ph1\">`Action&lt;Derived&gt;`</ph> and <ph id=\"ph2\">`Action&lt;Base&gt;`</ph> (<ph id=\"ph3\">`Action(Of Derived)`</ph> and <ph id=\"ph4\">`Action(Of Base)`</ph> in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.","pos":[5021,5251],"source":" That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe."},{"content":"Variance allows the second delegate to be assigned to a variable of type <ph id=\"ph1\">`Action&lt;Derived&gt;`</ph>, but delegates can combine only if their types match exactly.","pos":[5252,5404],"source":" Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly."},{"content":"The following subsections describe covariant and contravariant type parameters in detail:","pos":[5411,5500]},{"pos":[5510,5596],"content":"<bpt id=\"p1\">[</bpt>Generic Interfaces with Covariant Type Parameters<ept id=\"p1\">](#InterfaceCovariantTypeParameters)</ept>","source":"[Generic Interfaces with Covariant Type Parameters](#InterfaceCovariantTypeParameters)"},{"pos":[5606,5704],"content":"<bpt id=\"p1\">[</bpt>Generic Interfaces with Contravariant Generic Type Parameters<ept id=\"p1\">](#InterfaceCovariantTypeParameters)</ept>","source":"[Generic Interfaces with Contravariant Generic Type Parameters](#InterfaceCovariantTypeParameters)"},{"pos":[5714,5794],"content":"<bpt id=\"p1\">[</bpt>Generic Delegates with Variant Type Parameters<ept id=\"p1\">](#DelegateVariantTypeParameters)</ept>","source":"[Generic Delegates with Variant Type Parameters](#DelegateVariantTypeParameters)"},{"pos":[5804,5887],"content":"<bpt id=\"p1\">[</bpt>Defining Variant Generic Interfaces and Delegates<ept id=\"p1\">](#DefiningVariantTypeParameters)</ept>","source":"[Defining Variant Generic Interfaces and Delegates](#DefiningVariantTypeParameters)"},{"pos":[5897,5965],"content":"<bpt id=\"p1\">[</bpt>List of Variant Generic Interface and Delegate Types<ept id=\"p1\">](#VariantList)</ept>","source":"[List of Variant Generic Interface and Delegate Types](#VariantList)"},{"pos":[6025,6074],"content":"Generic Interfaces with Covariant Type Parameters","linkify":"Generic Interfaces with Covariant Type Parameters","nodes":[{"content":"Generic Interfaces with Covariant Type Parameters","pos":[0,49]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, several generic interfaces have covariant type parameters; for example: <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Linq.IQueryable%601&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.Linq.IGrouping%602&gt;</ph>.","pos":[6078,6408],"source":"Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>."},{"content":"All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.","pos":[6409,6541]},{"content":"The following example illustrates covariant type parameters.","pos":[6548,6608]},{"content":"The example defines two types: <ph id=\"ph1\">`Base`</ph> has a static method named <ph id=\"ph2\">`PrintBases`</ph> that takes an <ph id=\"ph3\">`IEnumerable&lt;Base&gt;`</ph> (<ph id=\"ph4\">`IEnumerable(Of Base)`</ph> in Visual Basic) and prints the elements.","pos":[6609,6785],"source":" The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements."},{"content":"<ph id=\"ph1\">`Derived`</ph> inherits from <ph id=\"ph2\">`Base`</ph>.","pos":[6786,6817],"source":"`Derived` inherits from `Base`."},{"content":"The example creates an empty <ph id=\"ph1\">`List&lt;Derived&gt;`</ph> (<ph id=\"ph2\">`List(Of Derived)`</ph> in Visual Basic) and demonstrates that this type can be passed to <ph id=\"ph3\">`PrintBases`</ph> and assigned to a variable of type <ph id=\"ph4\">`IEnumerable&lt;Base&gt;`</ph> without casting.","pos":[6818,7033],"source":" The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting."},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, which has a single covariant type parameter.","pos":[7034,7183],"source":" <xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter."},{"content":"The covariant type parameter is the reason why an instance of <ph id=\"ph1\">`IEnumerable&lt;Derived&gt;`</ph> can be used instead of <ph id=\"ph2\">`IEnumerable&lt;Base&gt;`</ph>.","pos":[7184,7312],"source":" The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceInClrGenericI#1<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[7319,7462],"source":"[!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceInClrGenericI#1<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[7464,7608],"source":"[!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]"},{"pos":[7615,7634],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[7698,7759],"content":"Generic Interfaces with Contravariant Generic Type Parameters","linkify":"Generic Interfaces with Contravariant Generic Type Parameters","nodes":[{"content":"Generic Interfaces with Contravariant Generic Type Parameters","pos":[0,61]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, several generic interfaces have contravariant type parameters; for example: <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.IComparable%601&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph>.","pos":[7763,8063],"source":"Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>."},{"content":"These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.","pos":[8064,8211]},{"content":"The following example illustrates contravariant type parameters.","pos":[8218,8282]},{"content":"The example defines an abstract (<ph id=\"ph1\">`MustInherit`</ph> in Visual Basic) <ph id=\"ph2\">`Shape`</ph> class with an <ph id=\"ph3\">`Area`</ph> property.","pos":[8283,8385],"source":" The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property."},{"content":"The example also defines a <ph id=\"ph1\">`ShapeAreaComparer`</ph> class that implements <ph id=\"ph2\">`IComparer&lt;Shape&gt;`</ph> (<ph id=\"ph3\">`IComparer(Of Shape)`</ph> in Visual Basic).","pos":[8386,8514],"source":" The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic)."},{"content":"The implementation of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=fullName&gt;</ph> method is based on the value of the <ph id=\"ph2\">`Area`</ph> property, so <ph id=\"ph3\">`ShapeAreaComparer`</ph> can be used to sort <ph id=\"ph4\">`Shape`</ph> objects by area.","pos":[8515,8745],"source":" The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=fullName> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area."},{"content":"The <ph id=\"ph1\">`Circle`</ph> class inherits <ph id=\"ph2\">`Shape`</ph> and overrides <ph id=\"ph3\">`Area`</ph>.","pos":[8752,8809],"source":"The `Circle` class inherits `Shape` and overrides `Area`."},{"content":"The example creates a <ph id=\"ph1\">&lt;xref:System.Collections.Generic.SortedSet%601&gt;</ph> of <ph id=\"ph2\">`Circle`</ph> objects, using a constructor that takes an <ph id=\"ph3\">`IComparer&lt;Circle&gt;`</ph> (<ph id=\"ph4\">`IComparer(Of Circle)`</ph> in Visual Basic).","pos":[8810,8996],"source":" The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic)."},{"content":"However, instead of passing an <ph id=\"ph1\">`IComparer&lt;Circle&gt;`</ph>, the example passes a <ph id=\"ph2\">`ShapeAreaComparer`</ph> object, which implements <ph id=\"ph3\">`IComparer&lt;Shape&gt;`</ph>.","pos":[8997,9134],"source":" However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`."},{"content":"The example can pass a comparer of a less derived type (<ph id=\"ph1\">`Shape`</ph>) when the code calls for a comparer of a more derived type (<ph id=\"ph2\">`Circle`</ph>), because the type parameter of the <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface is contravariant.","pos":[9135,9387],"source":" The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant."},{"content":"When a new <ph id=\"ph1\">`Circle`</ph> object is added to the <ph id=\"ph2\">`SortedSet&lt;Circle&gt;`</ph>, the <ph id=\"ph3\">`IComparer&lt;Shape&gt;.Compare`</ph> method (<ph id=\"ph4\">`IComparer(Of Shape).Compare`</ph> method in Visual Basic) of the <ph id=\"ph5\">`ShapeAreaComparer`</ph> object is called each time the new element is compared to an existing element.","pos":[9394,9656],"source":"When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element."},{"content":"The parameter type of the method (<ph id=\"ph1\">`Shape`</ph>) is less derived than the type that is being passed (<ph id=\"ph2\">`Circle`</ph>), so the call is type safe.","pos":[9657,9788],"source":" The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe."},{"content":"Contravariance enables <ph id=\"ph1\">`ShapeAreaComparer`</ph> to sort a collection of any single type, as well as a mixed collection of types, that derive from <ph id=\"ph2\">`Shape`</ph>.","pos":[9789,9938],"source":" Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceInClrGenericI2#1<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[9945,10090],"source":"[!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceInClrGenericI2#1<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[10092,10238],"source":"[!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]"},{"pos":[10245,10264],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[10321,10367],"content":"Generic Delegates with Variant Type Parameters","linkify":"Generic Delegates with Variant Type Parameters","nodes":[{"content":"Generic Delegates with Variant Type Parameters","pos":[0,46]}]},{"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, the <ph id=\"ph2\">`Func`</ph> generic delegates, such as <ph id=\"ph3\">&lt;xref:System.Func%602&gt;</ph>, have covariant return types and contravariant parameter types.","pos":[10371,10568],"source":"In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types."},{"content":"The <ph id=\"ph1\">`Action`</ph> generic delegates, such as <ph id=\"ph2\">&lt;xref:System.Action%602&gt;</ph>, have contravariant parameter types.","pos":[10569,10670],"source":" The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types."},{"content":"This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the <ph id=\"ph1\">`Func`</ph> generic delegates) less derived return types.","pos":[10671,10845],"source":" This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types."},{"pos":[10853,11102],"content":"[!NOTE]\n The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature. It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).","leadings":["","> "],"nodes":[{"content":"The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature. It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).","pos":[9,247],"nodes":[{"content":"The last generic type parameter of the <ph id=\"ph1\">`Func`</ph> generic delegates specifies the type of the return value in the delegate signature.","pos":[0,129],"source":"The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature."},{"content":"It is covariant (<ph id=\"ph1\">`out`</ph> keyword), whereas the other generic type parameters are contravariant (<ph id=\"ph2\">`in`</ph> keyword).","pos":[130,238],"source":" It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword)."}]}]},{"content":"The following code illustrates this.","pos":[11109,11145]},{"content":"The first piece of code defines a class named <ph id=\"ph1\">`Base`</ph>, a class named <ph id=\"ph2\">`Derived`</ph> that inherits <ph id=\"ph3\">`Base`</ph>, and another class with a <ph id=\"ph4\">`static`</ph> method (<ph id=\"ph5\">`Shared`</ph> in Visual Basic) named <ph id=\"ph6\">`MyMethod`</ph>.","pos":[11146,11331],"source":" The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`."},{"content":"The method takes an instance of <ph id=\"ph1\">`Base`</ph> and returns an instance of <ph id=\"ph2\">`Derived`</ph>.","pos":[11332,11408],"source":" The method takes an instance of `Base` and returns an instance of `Derived`."},{"content":"(If the argument is an instance of <ph id=\"ph1\">`Derived`</ph>, <ph id=\"ph2\">`MyMethod`</ph> returns it; if the argument is an instance of <ph id=\"ph3\">`Base`</ph>, <ph id=\"ph4\">`MyMethod`</ph> returns a new instance of <ph id=\"ph5\">`Derived`</ph>.) In <ph id=\"ph6\">`Main()`</ph>, the example creates an instance of <ph id=\"ph7\">`Func&lt;Base, Derived&gt;`</ph> (<ph id=\"ph8\">`Func(Of Base, Derived)`</ph> in Visual Basic) that represents <ph id=\"ph9\">`MyMethod`</ph>, and stores it in the variable <ph id=\"ph10\">`f1`</ph>.","pos":[11409,11745],"source":" (If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#2<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)</ept><ept id=\"p1\">]</ept>","pos":[11752,11887],"source":"[!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#2<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)</ept><ept id=\"p1\">]</ept>","pos":[11889,12025],"source":"[!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]"},{"pos":[12032,12216],"content":"The second piece of code shows that the delegate can be assigned to a variable of type <ph id=\"ph1\">`Func&lt;Base, Base&gt;`</ph> (<ph id=\"ph2\">`Func(Of Base, Base)`</ph> in Visual Basic), because the return type is covariant.","source":"The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#3<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)</ept><ept id=\"p1\">]</ept>","pos":[12223,12358],"source":"[!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#3<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)</ept><ept id=\"p1\">]</ept>","pos":[12360,12496],"source":"[!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]"},{"pos":[12503,12705],"content":"The third piece of code shows that the delegate can be assigned to a variable of type <ph id=\"ph1\">`Func&lt;Derived, Derived&gt;`</ph> (<ph id=\"ph2\">`Func(Of Derived, Derived)`</ph> in Visual Basic), because the parameter type is contravariant.","source":"The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#4<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)</ept><ept id=\"p1\">]</ept>","pos":[12712,12847],"source":"[!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#4<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)</ept><ept id=\"p1\">]</ept>","pos":[12849,12985],"source":"[!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]"},{"pos":[12992,13232],"content":"The final piece of code shows that the delegate can be assigned to a variable of type <ph id=\"ph1\">`Func&lt;Derived, Base&gt;`</ph> (<ph id=\"ph2\">`Func(Of Derived, Base)`</ph> in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.","source":"The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#5<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)</ept><ept id=\"p1\">]</ept>","pos":[13239,13374],"source":"[!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegates#5<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)</ept><ept id=\"p1\">]</ept>","pos":[13376,13512],"source":"[!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]"},{"pos":[13522,13567],"content":"Variance in Generic and Non-Generic Delegates","linkify":"Variance in Generic and Non-Generic Delegates","nodes":[{"content":"Variance in Generic and Non-Generic Delegates","pos":[0,45]}]},{"content":"In the preceding code, the signature of <ph id=\"ph1\">`MyMethod`</ph> exactly matches the signature of the constructed generic delegate: <ph id=\"ph2\">`Func&lt;Base, Derived&gt;`</ph> (<ph id=\"ph3\">`Func(Of Base, Derived)`</ph> in Visual Basic).","pos":[13571,13754],"source":"In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic)."},{"content":"The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph>.","pos":[13755,14022],"source":" The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>."},{"content":"This is an important point.","pos":[14029,14056]},{"content":"The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see <bpt id=\"p1\">[</bpt>Variance in Delegates<ept id=\"p1\">](http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)</ept>).","pos":[14057,14337],"source":" The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates](http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca))."},{"content":"However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.","pos":[14338,14478]},{"content":"Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.","pos":[14479,14776]},{"content":"The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.","pos":[14783,14904]},{"content":"The example defines a type hierarchy that includes three types, from least derived (<ph id=\"ph1\">`Type1`</ph>) to most derived (<ph id=\"ph2\">`Type3`</ph>).","pos":[14905,15024],"source":" The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`)."},{"content":"Variance in ordinary delegate binding is used to bind a method with a parameter type of <ph id=\"ph1\">`Type1`</ph> and a return type of <ph id=\"ph2\">`Type3`</ph> to a generic delegate with a parameter type of <ph id=\"ph3\">`Type2`</ph> and a return type of <ph id=\"ph4\">`Type2`</ph>.","pos":[15025,15234],"source":" Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`."},{"content":"The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type <ph id=\"ph1\">`Type3`</ph> and a return type of <ph id=\"ph2\">`Type1`</ph>, using the covariance and contravariance of generic type parameters.","pos":[15235,15460],"source":" The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters."},{"content":"The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph>.","pos":[15461,15631],"source":" The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegatesGenRelaxed#1<ept id=\"p2\">](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)</ept><ept id=\"p1\">]</ept>","pos":[15638,15793],"source":"[!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>CoContravarianceDelegatesGenRelaxed#1<ept id=\"p2\">](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)</ept><ept id=\"p1\">]</ept>","pos":[15795,15951],"source":"[!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]"},{"pos":[15958,15977],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[16034,16083],"content":"Defining Variant Generic Interfaces and Delegates","linkify":"Defining Variant Generic Interfaces and Delegates","nodes":[{"content":"Defining Variant Generic Interfaces and Delegates","pos":[0,49]}]},{"pos":[16087,16315],"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.","source":"Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant."},{"pos":[16323,16820],"content":"[!NOTE]\n Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters. Prior to the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.","leadings":["","> "],"nodes":[{"content":"Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters. Prior to the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.","pos":[9,495],"nodes":[{"content":"Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.","pos":[0,131]},{"content":"Prior to the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](../../../docs/framework/tools/ilasm-exe-il-assembler.md)</ept> or by emitting it in a dynamic assembly.","pos":[132,486],"source":" Prior to the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly."}]}]},{"content":"A covariant type parameter is marked with the <ph id=\"ph1\">`out`</ph> keyword (<ph id=\"ph2\">`Out`</ph> keyword in Visual Basic, <ph id=\"ph3\">`+`</ph> for the <bpt id=\"p1\">[</bpt>MSIL Assembler<ept id=\"p1\">](../../../docs/framework/tools/ilasm-exe-il-assembler.md)</ept>).","pos":[16827,17006],"source":"A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md))."},{"content":"You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.","pos":[17007,17144]},{"content":"You cannot use a covariant type parameter as a generic type constraint for interface methods.","pos":[17145,17238]},{"pos":[17246,17458],"content":"[!NOTE]\n If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.","leadings":["","> "],"nodes":[{"content":"If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.","pos":[9,210]}]},{"content":"A contravariant type parameter is marked with the <ph id=\"ph1\">`in`</ph> keyword (<ph id=\"ph2\">`In`</ph> keyword in Visual Basic, <ph id=\"ph3\">`-`</ph> for the <bpt id=\"p1\">[</bpt>MSIL Assembler<ept id=\"p1\">](../../../docs/framework/tools/ilasm-exe-il-assembler.md)</ept>).","pos":[17465,17646],"source":"A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md))."},{"content":"You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.","pos":[17647,17803]},{"content":"You can use a contravariant type parameter as a generic type constraint for an interface method.","pos":[17804,17900]},{"content":"Only interface types and delegate types can have variant type parameters.","pos":[17907,17980]},{"content":"An interface or delegate type can have both covariant and contravariant type parameters.","pos":[17981,18069]},{"content":"Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.","pos":[18076,18309]},{"content":"The <bpt id=\"p1\">[</bpt>MSIL Assembler<ept id=\"p1\">](../../../docs/framework/tools/ilasm-exe-il-assembler.md)</ept> does not perform such checks, but a <ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if you try to load a type that violates the rules.","pos":[18310,18516],"source":" The [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules."},{"pos":[18523,18666],"content":"For information and example code, see <bpt id=\"p1\">[</bpt>Variance in Generic Interfaces<ept id=\"p1\">](http://msdn.microsoft.com/library/e14322da-1db3-42f2-9a67-397daddd6b6a)</ept>.","source":"For information and example code, see [Variance in Generic Interfaces](http://msdn.microsoft.com/library/e14322da-1db3-42f2-9a67-397daddd6b6a)."},{"pos":[18673,18692],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[18731,18783],"content":"List of Variant Generic Interface and Delegate Types","linkify":"List of Variant Generic Interface and Delegate Types","nodes":[{"content":"List of Variant Generic Interface and Delegate Types","pos":[0,52]}]},{"pos":[18787,18955],"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, the following interface and delegate types have covariant and/or contravariant type parameters.","source":"In the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], the following interface and delegate types have covariant and/or contravariant type parameters."},{"content":"Type","pos":[18962,18966]},{"content":"Covariant type parameters","pos":[18967,18992]},{"content":"Contravariant type parameters","pos":[18993,19022]},{"content":"<ph id=\"ph1\">&lt;xref:System.Action%601&gt;</ph> to <ph id=\"ph2\">&lt;xref:System.Action%6016&gt;</ph>","pos":[19110,19163],"source":"<xref:System.Action%601> to <xref:System.Action%6016>"},{"content":"Yes","pos":[19165,19168]},{"content":"Yes","pos":[19203,19206]},{"content":"Yes","pos":[19239,19242]},{"content":"Yes","pos":[19243,19246]},{"content":"Yes","pos":[19274,19277]},{"content":"<ph id=\"ph1\">&lt;xref:System.Func%602&gt;</ph> to <ph id=\"ph2\">&lt;xref:System.Func%6017&gt;</ph>","pos":[19283,19332],"source":"<xref:System.Func%602> to <xref:System.Func%6017>"},{"content":"Yes","pos":[19333,19336]},{"content":"Yes","pos":[19337,19340]},{"content":"Yes","pos":[19376,19379]},{"content":"Yes","pos":[19413,19416]},{"content":"Yes","pos":[19470,19473]},{"content":"Yes","pos":[19528,19531]},{"content":"Yes","pos":[19587,19590]},{"content":"Yes","pos":[19653,19656]},{"content":"Yes","pos":[19694,19697]},{"content":"Yes","pos":[19745,19748]},{"content":"Yes","pos":[19795,19798]},{"content":"Yes","pos":[19838,19841]},{"pos":[19852,19860],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Covariance and Contravariance<ept id=\"p1\">](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8)</ept><ph id=\"ph1\"> </ph>","pos":[19864,19968],"source":"[Covariance and Contravariance](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8) "},{"content":"<bpt id=\"p1\">[</bpt>Variance in Delegates<ept id=\"p1\">](http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)</ept>","pos":[19972,20067],"source":"[Variance in Delegates](http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca)"}]}