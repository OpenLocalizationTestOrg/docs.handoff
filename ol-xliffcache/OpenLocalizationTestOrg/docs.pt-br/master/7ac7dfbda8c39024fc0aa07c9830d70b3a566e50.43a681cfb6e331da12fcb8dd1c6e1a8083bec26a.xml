{"content":"---\ntitle: \"Troubleshooting Data Types (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"Char data type, converting\"\n  - \"Decimal data type, conversions\"\n  - \"data types [Visual Basic], troubleshooting\"\n  - \"literals, default types\"\n  - \"type characters, literal\"\n  - \"Mod operator [Visual Basic], in floating-point operations\"\n  - \"troubleshooting Visual Basic, data types\"\n  - \"troubleshooting data types\"\n  - \"floating-point numbers, precision\"\n  - \"Boolean data type, converting\"\n  - \"literal types\"\n  - \"literal type characters\"\n  - \"floating-point numbers, imprecision\"\n  - \"String data type, converting\"\n  - \"floating-point numbers, comparison\"\n  - \"floating-point numbers\"\nms.assetid: 90040d67-b630-4125-a6ae-37195b079042\ncaps.latest.revision: 29\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Troubleshooting Data Types (Visual Basic)\nThis page lists some common problems that can occur when you perform operations on intrinsic data types.  \n  \n## Floating-Point Expressions Do Not Compare as Equal  \n When you work with floating-point numbers ([Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md)), remember that they are stored as binary fractions. This means they cannot hold an exact representation of any quantity that is not a binary fraction (of the form k / (2 ^ n) where k and n are integers). For example, 0.5 (= 1/2) and 0.3125 (= 5/16) can be held as precise values, whereas 0.2 (= 1/5) and 0.3 (= 3/10) can be only approximations.  \n  \n Because of this imprecision, you cannot rely on exact results when you operate on floating-point values. In particular, two values that are theoretically equal might have slightly different representations.  \n  \n| To compare floating-point quantities | \n|---| \n|1.  Calculate the absolute value of their difference by using the <xref:System.Math.Abs%2A> method of the <xref:System.Math> class in the <xref:System> namespace.<br />2.  Determine an acceptable maximum difference, such that you can consider the two quantities to be equal for practical purposes if their difference is no larger.<br />3.  Compare the absolute value of the difference to the acceptable difference.|  \n  \n The following example demonstrates both incorrect and correct comparison of two `Double` values.  \n  \n [!code-vb[VbVbalrDataTypes#10](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_1.vb)]  \n  \n The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better  precision than the `CStr` keyword uses. The default is 15 digits, but the \"G17\" format extends it to 17 digits.  \n  \n## Mod Operator Does Not Return Accurate Result  \n Because of the imprecision of floating-point storage, the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md) can return an unexpected result when at least one of the operands is floating-point.  \n  \n The [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md) does not use floating-point representation. Many numbers that are inexact in `Single` and `Double` are exact in `Decimal` (for example 0.2 and 0.3). Although arithmetic is slower in `Decimal` than in floating-point, it might be worth the performance decrease to achieve better precision.  \n  \n|To find the integer remainder of floating-point quantities|  \n|---|  \n|1.  Declare variables as `Decimal`.<br />2.  Use the literal type character `D` to force literals to `Decimal`, in case their values are too large for the `Long` data type.|  \n  \n The following example demonstrates the potential imprecision of floating-point operands.  \n  \n [!code-vb[VbVbalrDataTypes#11](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_2.vb)]  \n  \n The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better precision than the `CStr` keyword uses. The default is 15 digits, but the \"G17\" format extends it to 17 digits.  \n  \n Because `zeroPointTwo` is `Double`, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001. Dividing 2.0 by this quantity yields 9.9999999999999995 with a remainder of 0.19999999999999991.  \n  \n In the expression for `decimalRemainder`, the literal type character `D` forces both operands to `Decimal`, and 0.2 has a precise representation. Therefore the `Mod` operator yields the expected remainder of 0.0.  \n  \n Note that it is not sufficient to declare `decimalRemainder` as `Decimal`. You must also force the literals to `Decimal`, or they use `Double` by default and `decimalRemainder` receives the same inaccurate value as `doubleRemainder`.  \n  \n## Boolean Type Does Not Convert to Numeric Type Accurately  \n [Boolean Data Type](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) values are not stored as numbers, and the stored values are not intended to be equivalent to numbers. For compatibility with earlier versions, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] provides conversion keywords ([CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), `CBool`, `CInt`, and so on) to convert between `Boolean` and numeric types. However, other languages sometimes perform these conversions differently, as do the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] methods.  \n  \n You should never write code that relies on equivalent numeric values for `True` and `False`. Whenever possible, you should restrict usage of `Boolean` variables to the logical values for which they are designed. If you must mix `Boolean` and numeric values, make sure that you understand the conversion method that you select.  \n  \n### Conversion in Visual Basic  \n When you use the `CType` or `CBool` conversion keywords to convert numeric data types to `Boolean`, 0 becomes `False` and all other values become `True`. When you convert `Boolean` values to numeric types by using the conversion keywords, `False` becomes 0 and `True` becomes -1.  \n  \n### Conversion in the Framework  \n The <xref:System.Convert.ToInt32%2A> method of the <xref:System.Convert> class in the <xref:System> namespace converts `True` to +1.  \n  \n If you must convert a `Boolean` value to a numeric data type, be careful about which conversion method you use.  \n  \n## Character Literal Generates Compiler Error  \n In the absence of any type characters, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] assumes default data types for literals. The default type for a character literal — enclosed in quotation marks (`\" \"`) — is `String`.  \n  \n The `String` data type does not widen to the [Char Data Type](../../../../visual-basic/language-reference/data-types/char-data-type.md). This means that if you want to assign a literal to a `Char` variable, you must either make a narrowing conversion or force the literal to the `Char` type.  \n\n|To create a Char literal to assign to a variable or constant|\n|---|  \n|1.  Declare the variable or constant as `Char`.<br />2.  Enclose the character value in quotation marks (`\" \"`).<br />3.  Follow the closing double quotation mark with the literal type character `C` to force the literal to `Char`. This is necessary if the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, and it is desirable in any case.|  \n  \n The following example demonstrates both unsuccessful and successful assignments of a literal to a `Char` variable.  \n  \n [!code-vb[VbVbalrDataTypes#12](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_3.vb)]  \n  \n There is always a risk in using narrowing conversions, because they can fail at run time. For example, a conversion from `String` to `Char` can fail if the `String` value contains more than one character. Therefore, it is better programming to use the `C` type character.  \n  \n## String Conversion Fails at Run Time  \n The [String Data Type](../../../../visual-basic/language-reference/data-types/string-data-type.md) participates in very few widening conversions. `String` widens only to itself and `Object`, and only `Char` and `Char()` (a `Char` array) widen to `String`. This is because `String` variables and constants can contain values that other data types cannot contain.  \n  \n When the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, the compiler disallows all implicit narrowing conversions. This includes those involving `String`. Your code can still use conversion keywords such as `CStr` and [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), which direct the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] to attempt the conversion.  \n  \n> [!NOTE]\n>  The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).  \n  \n### Narrowing Conversion Protection  \n The disadvantage of narrowing conversions is that they can fail at run time. For example, if a `String` variable contains anything other than \"True\" or \"False,\" it cannot be converted to `Boolean`. If it contains punctuation characters, conversion to any numeric type fails. Unless you know that your `String` variable always holds values that the destination type can accept, you should not try a conversion.  \n  \n If you must convert from `String` to another data type, the safest procedure is to enclose the attempted conversion in the [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md). This lets you deal with a run-time failure.  \n  \n### Character Arrays  \n A single `Char` and an array of `Char` elements both widen to `String`. However, `String` does not widen to `Char()`. To convert a `String` value to a `Char` array, you can use the <xref:System.String.ToCharArray%2A> method of the <xref:System.String?displayProperty=fullName> class.  \n  \n### Meaningless Values  \n In general, `String` values are not meaningful in other data types, and conversion is highly artificial and dangerous. Whenever possible, you should restrict usage of `String` variables to the character sequences for which they are designed. You should never write code that relies on equivalent values in other types.  \n  \n## See Also  \n [Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)   \n [Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)   \n [Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)   \n [Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)   \n [Data Types](../../../../visual-basic/language-reference/data-types/data-type-summary.md)   \n [Type Conversion Functions](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)   \n [Efficient Use of Data Types](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)","nodes":[{"pos":[12,70],"content":"Troubleshooting Data Types (Visual Basic) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Troubleshooting Data Types (Visual Basic) | Microsoft Docs","pos":[0,58]}]},{"pos":[1162,1203],"content":"Troubleshooting Data Types (Visual Basic)","linkify":"Troubleshooting Data Types (Visual Basic)","nodes":[{"content":"Troubleshooting Data Types (Visual Basic)","pos":[0,41]}]},{"content":"This page lists some common problems that can occur when you perform operations on intrinsic data types.","pos":[1204,1308]},{"pos":[1317,1367],"content":"Floating-Point Expressions Do Not Compare as Equal","linkify":"Floating-Point Expressions Do Not Compare as Equal","nodes":[{"content":"Floating-Point Expressions Do Not Compare as Equal","pos":[0,50]}]},{"content":"When you work with floating-point numbers (<bpt id=\"p1\">[</bpt>Single Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/single-data-type.md)</ept> and <bpt id=\"p2\">[</bpt>Double Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/double-data-type.md)</ept>), remember that they are stored as binary fractions.","pos":[1371,1660],"source":"When you work with floating-point numbers ([Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md)), remember that they are stored as binary fractions."},{"content":"This means they cannot hold an exact representation of any quantity that is not a binary fraction (of the form k / (2 ^ n) where k and n are integers).","pos":[1661,1812]},{"content":"For example, 0.5 (= 1/2) and 0.3125 (= 5/16) can be held as precise values, whereas 0.2 (= 1/5) and 0.3 (= 3/10) can be only approximations.","pos":[1813,1953]},{"content":"Because of this imprecision, you cannot rely on exact results when you operate on floating-point values.","pos":[1960,2064]},{"content":"In particular, two values that are theoretically equal might have slightly different representations.","pos":[2065,2166]},{"content":"To compare floating-point quantities","pos":[2174,2210]},{"content":"1.  Calculate the absolute value of their difference by using the <ph id=\"ph1\">&lt;xref:System.Math.Abs%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Math&gt;</ph> class in the <ph id=\"ph3\">&lt;xref:System&gt;</ph> namespace.","pos":[2222,2384],"source":"1.  Calculate the absolute value of their difference by using the <xref:System.Math.Abs%2A> method of the <xref:System.Math> class in the <xref:System> namespace."},{"content":"2.  Determine an acceptable maximum difference, such that you can consider the two quantities to be equal for practical purposes if their difference is no larger.","pos":[2390,2552]},{"content":"3.  Compare the absolute value of the difference to the acceptable difference.","pos":[2558,2636]},{"pos":[2644,2740],"content":"The following example demonstrates both incorrect and correct comparison of two <ph id=\"ph1\">`Double`</ph> values.","source":"The following example demonstrates both incorrect and correct comparison of two `Double` values."},{"pos":[2747,2890],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrDataTypes#10<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_1.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrDataTypes#10](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_1.vb)]"},{"content":"The previous example uses the <ph id=\"ph1\">&lt;xref:System.Double.ToString%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Double&gt;</ph> structure so that it can specify better  precision than the <ph id=\"ph3\">`CStr`</ph> keyword uses.","pos":[2897,3075],"source":"The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better  precision than the `CStr` keyword uses."},{"content":"The default is 15 digits, but the \"G17\" format extends it to 17 digits.","pos":[3076,3147]},{"pos":[3156,3200],"content":"Mod Operator Does Not Return Accurate Result","linkify":"Mod Operator Does Not Return Accurate Result","nodes":[{"content":"Mod Operator Does Not Return Accurate Result","pos":[0,44]}]},{"pos":[3204,3432],"content":"Because of the imprecision of floating-point storage, the <bpt id=\"p1\">[</bpt>Mod Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept> can return an unexpected result when at least one of the operands is floating-point.","source":"Because of the imprecision of floating-point storage, the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md) can return an unexpected result when at least one of the operands is floating-point."},{"content":"The <bpt id=\"p1\">[</bpt>Decimal Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept> does not use floating-point representation.","pos":[3439,3583],"source":"The [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md) does not use floating-point representation."},{"content":"Many numbers that are inexact in <ph id=\"ph1\">`Single`</ph> and <ph id=\"ph2\">`Double`</ph> are exact in <ph id=\"ph3\">`Decimal`</ph> (for example 0.2 and 0.3).","pos":[3584,3688],"source":" Many numbers that are inexact in `Single` and `Double` are exact in `Decimal` (for example 0.2 and 0.3)."},{"content":"Although arithmetic is slower in <ph id=\"ph1\">`Decimal`</ph> than in floating-point, it might be worth the performance decrease to achieve better precision.","pos":[3689,3827],"source":" Although arithmetic is slower in `Decimal` than in floating-point, it might be worth the performance decrease to achieve better precision."},{"content":"To find the integer remainder of floating-point quantities","pos":[3834,3892]},{"content":"1.  Declare variables as <ph id=\"ph1\">`Decimal`</ph>.","pos":[3905,3940],"source":"1.  Declare variables as `Decimal`."},{"content":"2.  Use the literal type character <ph id=\"ph1\">`D`</ph> to force literals to <ph id=\"ph2\">`Decimal`</ph>, in case their values are too large for the <ph id=\"ph3\">`Long`</ph> data type.","pos":[3946,4077],"source":"2.  Use the literal type character `D` to force literals to `Decimal`, in case their values are too large for the `Long` data type."},{"content":"The following example demonstrates the potential imprecision of floating-point operands.","pos":[4085,4173]},{"pos":[4180,4323],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrDataTypes#11<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_2.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrDataTypes#11](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_2.vb)]"},{"content":"The previous example uses the <ph id=\"ph1\">&lt;xref:System.Double.ToString%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Double&gt;</ph> structure so that it can specify better precision than the <ph id=\"ph3\">`CStr`</ph> keyword uses.","pos":[4330,4507],"source":"The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better precision than the `CStr` keyword uses."},{"content":"The default is 15 digits, but the \"G17\" format extends it to 17 digits.","pos":[4508,4579]},{"content":"Because <ph id=\"ph1\">`zeroPointTwo`</ph> is <ph id=\"ph2\">`Double`</ph>, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001.","pos":[4586,4726],"source":"Because `zeroPointTwo` is `Double`, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001."},{"content":"Dividing 2.0 by this quantity yields 9.9999999999999995 with a remainder of 0.19999999999999991.","pos":[4727,4823]},{"content":"In the expression for <ph id=\"ph1\">`decimalRemainder`</ph>, the literal type character <ph id=\"ph2\">`D`</ph> forces both operands to <ph id=\"ph3\">`Decimal`</ph>, and 0.2 has a precise representation.","pos":[4830,4975],"source":"In the expression for `decimalRemainder`, the literal type character `D` forces both operands to `Decimal`, and 0.2 has a precise representation."},{"content":"Therefore the <ph id=\"ph1\">`Mod`</ph> operator yields the expected remainder of 0.0.","pos":[4976,5042],"source":" Therefore the `Mod` operator yields the expected remainder of 0.0."},{"content":"Note that it is not sufficient to declare <ph id=\"ph1\">`decimalRemainder`</ph> as <ph id=\"ph2\">`Decimal`</ph>.","pos":[5049,5123],"source":"Note that it is not sufficient to declare `decimalRemainder` as `Decimal`."},{"content":"You must also force the literals to <ph id=\"ph1\">`Decimal`</ph>, or they use <ph id=\"ph2\">`Double`</ph> by default and <ph id=\"ph3\">`decimalRemainder`</ph> receives the same inaccurate value as <ph id=\"ph4\">`doubleRemainder`</ph>.","pos":[5124,5282],"source":" You must also force the literals to `Decimal`, or they use `Double` by default and `decimalRemainder` receives the same inaccurate value as `doubleRemainder`."},{"pos":[5291,5347],"content":"Boolean Type Does Not Convert to Numeric Type Accurately","linkify":"Boolean Type Does Not Convert to Numeric Type Accurately","nodes":[{"content":"Boolean Type Does Not Convert to Numeric Type Accurately","pos":[0,56]}]},{"content":"<bpt id=\"p1\">[</bpt>Boolean Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept> values are not stored as numbers, and the stored values are not intended to be equivalent to numbers.","pos":[5351,5549],"source":"[Boolean Data Type](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) values are not stored as numbers, and the stored values are not intended to be equivalent to numbers."},{"content":"For compatibility with earlier versions, <ph id=\"ph1\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> provides conversion keywords (<bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept>, <ph id=\"ph2\">`CBool`</ph>, <ph id=\"ph3\">`CInt`</ph>, and so on) to convert between <ph id=\"ph4\">`Boolean`</ph> and numeric types.","pos":[5550,5880],"source":" For compatibility with earlier versions, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] provides conversion keywords ([CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), `CBool`, `CInt`, and so on) to convert between `Boolean` and numeric types."},{"content":"However, other languages sometimes perform these conversions differently, as do the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> methods.","pos":[5881,6060],"source":" However, other languages sometimes perform these conversions differently, as do the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] methods."},{"content":"You should never write code that relies on equivalent numeric values for <ph id=\"ph1\">`True`</ph> and <ph id=\"ph2\">`False`</ph>.","pos":[6067,6159],"source":"You should never write code that relies on equivalent numeric values for `True` and `False`."},{"content":"Whenever possible, you should restrict usage of <ph id=\"ph1\">`Boolean`</ph> variables to the logical values for which they are designed.","pos":[6160,6278],"source":" Whenever possible, you should restrict usage of `Boolean` variables to the logical values for which they are designed."},{"content":"If you must mix <ph id=\"ph1\">`Boolean`</ph> and numeric values, make sure that you understand the conversion method that you select.","pos":[6279,6393],"source":" If you must mix `Boolean` and numeric values, make sure that you understand the conversion method that you select."},{"pos":[6403,6429],"content":"Conversion in Visual Basic","linkify":"Conversion in Visual Basic","nodes":[{"content":"Conversion in Visual Basic","pos":[0,26]}]},{"content":"When you use the <ph id=\"ph1\">`CType`</ph> or <ph id=\"ph2\">`CBool`</ph> conversion keywords to convert numeric data types to <ph id=\"ph3\">`Boolean`</ph>, 0 becomes <ph id=\"ph4\">`False`</ph> and all other values become <ph id=\"ph5\">`True`</ph>.","pos":[6433,6586],"source":"When you use the `CType` or `CBool` conversion keywords to convert numeric data types to `Boolean`, 0 becomes `False` and all other values become `True`."},{"content":"When you convert <ph id=\"ph1\">`Boolean`</ph> values to numeric types by using the conversion keywords, <ph id=\"ph2\">`False`</ph> becomes 0 and <ph id=\"ph3\">`True`</ph> becomes -1.","pos":[6587,6712],"source":" When you convert `Boolean` values to numeric types by using the conversion keywords, `False` becomes 0 and `True` becomes -1."},{"pos":[6722,6749],"content":"Conversion in the Framework","linkify":"Conversion in the Framework","nodes":[{"content":"Conversion in the Framework","pos":[0,27]}]},{"pos":[6753,6885],"content":"The <ph id=\"ph1\">&lt;xref:System.Convert.ToInt32%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Convert&gt;</ph> class in the <ph id=\"ph3\">&lt;xref:System&gt;</ph> namespace converts <ph id=\"ph4\">`True`</ph> to +1.","source":"The <xref:System.Convert.ToInt32%2A> method of the <xref:System.Convert> class in the <xref:System> namespace converts `True` to +1."},{"pos":[6892,7003],"content":"If you must convert a <ph id=\"ph1\">`Boolean`</ph> value to a numeric data type, be careful about which conversion method you use.","source":"If you must convert a `Boolean` value to a numeric data type, be careful about which conversion method you use."},{"pos":[7012,7054],"content":"Character Literal Generates Compiler Error","linkify":"Character Literal Generates Compiler Error","nodes":[{"content":"Character Literal Generates Compiler Error","pos":[0,42]}]},{"content":"In the absence of any type characters, <ph id=\"ph1\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> assumes default data types for literals.","pos":[7058,7230],"source":"In the absence of any type characters, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] assumes default data types for literals."},{"content":"The default type for a character literal — enclosed in quotation marks (<ph id=\"ph1\">`\" \"`</ph>) — is <ph id=\"ph2\">`String`</ph>.","pos":[7231,7324],"source":" The default type for a character literal — enclosed in quotation marks (`\" \"`) — is `String`."},{"content":"The <ph id=\"ph1\">`String`</ph> data type does not widen to the <bpt id=\"p1\">[</bpt>Char Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/char-data-type.md)</ept>.","pos":[7331,7467],"source":"The `String` data type does not widen to the [Char Data Type](../../../../visual-basic/language-reference/data-types/char-data-type.md)."},{"content":"This means that if you want to assign a literal to a <ph id=\"ph1\">`Char`</ph> variable, you must either make a narrowing conversion or force the literal to the <ph id=\"ph2\">`Char`</ph> type.","pos":[7468,7622],"source":" This means that if you want to assign a literal to a `Char` variable, you must either make a narrowing conversion or force the literal to the `Char` type."},{"content":"To create a Char literal to assign to a variable or constant","pos":[7627,7687]},{"content":"1.  Declare the variable or constant as <ph id=\"ph1\">`Char`</ph>.","pos":[7698,7745],"source":"1.  Declare the variable or constant as `Char`."},{"content":"2.  Enclose the character value in quotation marks (<ph id=\"ph1\">`\" \"`</ph>).","pos":[7751,7810],"source":"2.  Enclose the character value in quotation marks (`\" \"`)."},{"content":"3.  Follow the closing double quotation mark with the literal type character <ph id=\"ph1\">`C`</ph> to force the literal to <ph id=\"ph2\">`Char`</ph>.","pos":[7816,7928],"source":"3.  Follow the closing double quotation mark with the literal type character `C` to force the literal to `Char`."},{"content":"This is necessary if the type checking switch (<bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>) is <ph id=\"ph1\">`On`</ph>, and it is desirable in any case.","pos":[7929,8127],"source":" This is necessary if the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, and it is desirable in any case."},{"pos":[8135,8249],"content":"The following example demonstrates both unsuccessful and successful assignments of a literal to a <ph id=\"ph1\">`Char`</ph> variable.","source":"The following example demonstrates both unsuccessful and successful assignments of a literal to a `Char` variable."},{"pos":[8256,8399],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbalrDataTypes#12<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_3.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbalrDataTypes#12](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/troubleshooting-data-types_3.vb)]"},{"content":"There is always a risk in using narrowing conversions, because they can fail at run time.","pos":[8406,8495]},{"content":"For example, a conversion from <ph id=\"ph1\">`String`</ph> to <ph id=\"ph2\">`Char`</ph> can fail if the <ph id=\"ph3\">`String`</ph> value contains more than one character.","pos":[8496,8610],"source":" For example, a conversion from `String` to `Char` can fail if the `String` value contains more than one character."},{"content":"Therefore, it is better programming to use the <ph id=\"ph1\">`C`</ph> type character.","pos":[8611,8677],"source":" Therefore, it is better programming to use the `C` type character."},{"pos":[8686,8721],"content":"String Conversion Fails at Run Time","linkify":"String Conversion Fails at Run Time","nodes":[{"content":"String Conversion Fails at Run Time","pos":[0,35]}]},{"content":"The <bpt id=\"p1\">[</bpt>String Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/string-data-type.md)</ept> participates in very few widening conversions.","pos":[8725,8870],"source":"The [String Data Type](../../../../visual-basic/language-reference/data-types/string-data-type.md) participates in very few widening conversions."},{"content":"<ph id=\"ph1\">`String`</ph> widens only to itself and <ph id=\"ph2\">`Object`</ph>, and only <ph id=\"ph3\">`Char`</ph> and <ph id=\"ph4\">`Char()`</ph> (a <ph id=\"ph5\">`Char`</ph> array) widen to <ph id=\"ph6\">`String`</ph>.","pos":[8871,8980],"source":"`String` widens only to itself and `Object`, and only `Char` and `Char()` (a `Char` array) widen to `String`."},{"content":"This is because <ph id=\"ph1\">`String`</ph> variables and constants can contain values that other data types cannot contain.","pos":[8981,9086],"source":" This is because `String` variables and constants can contain values that other data types cannot contain."},{"content":"When the type checking switch (<bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>) is <ph id=\"ph1\">`On`</ph>, the compiler disallows all implicit narrowing conversions.","pos":[9093,9301],"source":"When the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, the compiler disallows all implicit narrowing conversions."},{"content":"This includes those involving <ph id=\"ph1\">`String`</ph>.","pos":[9302,9341],"source":" This includes those involving `String`."},{"content":"Your code can still use conversion keywords such as <ph id=\"ph1\">`CStr`</ph> and <bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept>, which direct the <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)]</ph> to attempt the conversion.","pos":[9342,9626],"source":" Your code can still use conversion keywords such as `CStr` and [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), which direct the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] to attempt the conversion."},{"pos":[9634,9975],"content":"[!NOTE]\n The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).","leadings":["","> "],"nodes":[{"content":" The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).","pos":[8,339],"nodes":[{"content":"The narrowing-conversion error is suppressed for conversions from the elements in a <ph id=\"ph1\">`For Each…Next`</ph> collection to the loop control variable.","pos":[1,141],"source":" The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable."},{"content":"For more information and examples, see the \"Narrowing Conversions\" section in <bpt id=\"p1\">[</bpt>For Each...Next Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)</ept>.","pos":[142,331],"source":" For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)."}]}]},{"pos":[9985,10016],"content":"Narrowing Conversion Protection","linkify":"Narrowing Conversion Protection","nodes":[{"content":"Narrowing Conversion Protection","pos":[0,31]}]},{"content":"The disadvantage of narrowing conversions is that they can fail at run time.","pos":[10020,10096]},{"content":"For example, if a <ph id=\"ph1\">`String`</ph> variable contains anything other than \"True\" or \"False,\" it cannot be converted to <ph id=\"ph2\">`Boolean`</ph>.","pos":[10097,10217],"source":" For example, if a `String` variable contains anything other than \"True\" or \"False,\" it cannot be converted to `Boolean`."},{"content":"If it contains punctuation characters, conversion to any numeric type fails.","pos":[10218,10294]},{"content":"Unless you know that your <ph id=\"ph1\">`String`</ph> variable always holds values that the destination type can accept, you should not try a conversion.","pos":[10295,10429],"source":" Unless you know that your `String` variable always holds values that the destination type can accept, you should not try a conversion."},{"content":"If you must convert from <ph id=\"ph1\">`String`</ph> to another data type, the safest procedure is to enclose the attempted conversion in the <bpt id=\"p1\">[</bpt>Try...Catch...Finally Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.","pos":[10436,10680],"source":"If you must convert from `String` to another data type, the safest procedure is to enclose the attempted conversion in the [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)."},{"content":"This lets you deal with a run-time failure.","pos":[10681,10724]},{"pos":[10734,10750],"content":"Character Arrays","linkify":"Character Arrays","nodes":[{"content":"Character Arrays","pos":[0,16]}]},{"content":"A single <ph id=\"ph1\">`Char`</ph> and an array of <ph id=\"ph2\">`Char`</ph> elements both widen to <ph id=\"ph3\">`String`</ph>.","pos":[10754,10825],"source":"A single `Char` and an array of `Char` elements both widen to `String`."},{"content":"However, <ph id=\"ph1\">`String`</ph> does not widen to <ph id=\"ph2\">`Char()`</ph>.","pos":[10826,10871],"source":" However, `String` does not widen to `Char()`."},{"content":"To convert a <ph id=\"ph1\">`String`</ph> value to a <ph id=\"ph2\">`Char`</ph> array, you can use the <ph id=\"ph3\">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method of the <ph id=\"ph4\">&lt;xref:System.String?displayProperty=fullName&gt;</ph> class.","pos":[10872,11037],"source":" To convert a `String` value to a `Char` array, you can use the <xref:System.String.ToCharArray%2A> method of the <xref:System.String?displayProperty=fullName> class."},{"pos":[11047,11065],"content":"Meaningless Values","linkify":"Meaningless Values","nodes":[{"content":"Meaningless Values","pos":[0,18]}]},{"content":"In general, <ph id=\"ph1\">`String`</ph> values are not meaningful in other data types, and conversion is highly artificial and dangerous.","pos":[11069,11187],"source":"In general, `String` values are not meaningful in other data types, and conversion is highly artificial and dangerous."},{"content":"Whenever possible, you should restrict usage of <ph id=\"ph1\">`String`</ph> variables to the character sequences for which they are designed.","pos":[11188,11310],"source":" Whenever possible, you should restrict usage of `String` variables to the character sequences for which they are designed."},{"content":"You should never write code that relies on equivalent values in other types.","pos":[11311,11387]},{"pos":[11396,11404],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[11408,11503],"source":"[Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Type Characters<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)</ept><ph id=\"ph1\"> </ph>","pos":[11506,11617],"source":" [Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Value Types and Reference Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)</ept><ph id=\"ph1\"> </ph>","pos":[11620,11763],"source":" [Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Type Conversions in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept><ph id=\"ph1\"> </ph>","pos":[11766,11895],"source":" [Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/data-type-summary.md)</ept><ph id=\"ph1\"> </ph>","pos":[11898,11989],"source":" [Data Types](../../../../visual-basic/language-reference/data-types/data-type-summary.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Type Conversion Functions<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)</ept><ph id=\"ph1\"> </ph>","pos":[11992,12105],"source":" [Type Conversion Functions](../../../../visual-basic/language-reference/functions/type-conversion-functions.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Efficient Use of Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)</ept>","pos":[12108,12242],"source":" [Efficient Use of Data Types](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)"}]}