{"content":"---\ntitle: \"Data Transfer Architectural Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"data transfer [WCF], architectural overview\"\nms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9\ncaps.latest.revision: 14\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Data Transfer Architectural Overview\n[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] can be thought of as a messaging infrastructure. It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination. This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data. For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).  \n  \n> [!NOTE]\n>  This topic discusses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] implementation details that are not visible by examining the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] object model. Two words of caution are in order with regard to documented implementation details. First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons. Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.  \n  \n## Basic Architecture  \n At the core of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md). The run-time components of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.  \n  \n The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data. On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message. The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation. The most common action is sending the message over a network protocol. On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.  \n  \n You can use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly. However, doing so is difficult and time-consuming. Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients if you use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] in this manner.  \n  \n Therefore, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects. The service framework maps services to [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types through the notion of service contracts, and dispatches messages to user operations that are simply [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)). These methods may have parameters and return values. On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances. On the client side, it does the opposite. For example, consider the `FindAirfare` operation below.  \n  \n [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]\n [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  \n  \n Suppose `FindAirfare` is called on the client. The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.  \n  \n On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method. When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information. It then passes the `Message` instance to the channel stack to be sent back to the client.  \n  \n On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack. The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.  \n  \n## Message Class  \n The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message. A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.  \n  \n## Message Body  \n The message body is intended to represent the actual data payload of the message. The message body is always represented as an XML Infoset. This does not mean that all messages created or received in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] must be in XML format. It is up to the channel stack to decide how to interpret the message body. It may emit it as XML, convert it to some other format, or even omit it entirely. Of course, with most of the bindings [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] supplies, the message body is represented as XML content in the body section of a SOAP envelope.  \n  \n It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body. Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.  \n  \n### Putting Data into the Message Body  \n There is no uniform mechanism to put data into a message body. The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>. Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents. The message body logically contains the XML Infoset that `OnWriteBodyContent` produces. For example, consider the following `Message` subclass.  \n  \n [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]\n [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  \n  \n Physically, an `AirfareRequestMessage` instance contains only two strings (\"fromCity\" and \"toCity\"). However, logically the message contains the following XML infoset:  \n  \n```  \n<airfareRequest>  \n    <from>Tokyo</from>  \n    <to>London</to>  \n</airfareRequest>  \n```  \n  \n Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters. Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.  \n  \n### Getting Data from a Message Body  \n You can extract the data stored in a message body in two main ways:  \n  \n-   You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer. The complete message body is written out to this writer. Getting the entire message body at one time is also called *writing a message*. Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.  \n  \n-   Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader. The message body can then be accessed sequentially as needed by calling methods on the reader. Getting the message body piece-by-piece is also called *reading a message*. Reading the message is primarily used by the service framework when receiving messages. For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.  \n  \n A message body can be retrieved only once. This makes it possible to work with forward-only streams. For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset. You will never need to \"rewind\" to the beginning of the file.  \n  \n The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.  \n  \n## Message Usage in WCF  \n Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework). Furthermore, the channel stack can operate in either buffered or streaming mode. The service framework may also expose a streamed or nonstreamed programming model. This leads to the cases listed in the following table, along with simplified details of their implementation.  \n  \n|Message type|Body data in message|Write (OnWriteBodyContents) implementation|Read (OnGetReaderAtBodyContents) Implementation|  \n|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  \n|Outgoing, created from nonstreamed programming model|The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)*|Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)*|Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer|  \n|Outgoing, created from streamed programming model|The `Stream` with the data to be written*|Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism*|Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer|  \n|Incoming from streaming channel stack|A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it|Write out the contents from the stored `XmlReader` using `WriteNode`|Returns the stored `XmlReader`|  \n|Incoming from nonstreaming channel stack|A buffer that contains body data with an `XmlReader` over it|Writes out the contents from the stored `XmlReader` using `WriteNode`|Returns the stored lang|  \n  \n \\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class. For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  \n  \n## Message Headers  \n A message may contain headers. A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties. Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>. Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class. Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.  \n  \n Putting information into a message header and extracting information from it is similar to using the message body. The process is somewhat simplified because streaming is not supported. It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered. There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that represents a readable header with such a capability. This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in. This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.  \n  \n [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  \n  \n## Message Properties  \n A message may contain properties. A *property* is any [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] object that is associated with a string name. Properties are accessed through the `Properties` property on `Message`.  \n  \n Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages. Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.  \n  \n For example, the HTTP transport channel included as part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] is capable of producing various HTTP status codes, such as \"404 (Not Found)\" and \"500 (Internal Server Error),\" when it sends replies to clients. Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called \"httpResponse\" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>. If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code. If it is not found, the default \"200 (OK)\" code is used.  \n  \n [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  \n  \n### The Message as a Whole  \n So far, we have discussed methods for accessing the various parts of the message in isolation. However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole. For example, the `WriteMessage` method writes out the entire message to an XML writer.  \n  \n For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset. Such a mapping, in fact, exists: [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the SOAP standard to define this mapping. When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message. Thus, `WriteMessage` would normally perform the following steps:  \n  \n1.  Write the SOAP envelope element opening tag.  \n  \n2.  Write the SOAP header element opening tag, write out all of the headers, and close the header element.  \n  \n3.  Write the SOAP body element opening tag.  \n  \n4.  Call `WriteBodyContents` or an equivalent method to write out the body.  \n  \n5.  Close the body and envelope elements.  \n  \n The preceding steps are closely tied to the SOAP standard. This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use. Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.  \n  \n For these purposes, a `Version` property is provided on `Message`. It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings. If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above. It is expected that on incoming messages, `Version` will be auto-detected and set correctly.  \n  \n## The Channel Stack  \n  \n### Channels  \n As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.  \n  \n The channel stack is composed of one or more channels ordered in a sequence. An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on. The message terminates in the last channel, which is called the *transport channel*. Incoming messages originate in the transport channel and are passed from channel to channel up the stack. From the topmost channel, the message is usually passed into the service framework. While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.  \n  \n Channels may operate on the message in various ways as it passes through the stack. The most common operation is adding a header to an outgoing message and reading headers on an incoming message. For example, a channel may compute the digital signature of a message and add it as a header. A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack. Channels also often set or inspect message properties. The message body is usually not modified, although this is allowed, for example, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] security channel can encrypt the message body.  \n  \n### Transport Channels and Message Encoders  \n The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action. On the receive side, this is the channel that converts some action into a `Message` that other channels process.  \n  \n As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples. All these actions have one thing in common: they require a transformation between the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued. The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.  \n  \n Most transport channels use components called *message encoders* to accomplish the encoding and decoding work. A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class. `MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.  \n  \n On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`. It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination). A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.  \n  \n On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack. A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.  \n  \n The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder. However, the advantage of this separation is ease of composition. As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] or third-party message encoder. Likewise, the same encoder can normally be used in any transport channel.  \n  \n### Message Encoder Operation  \n To describe the typical operation of an encoder, it is useful to consider the following four cases.  \n  \n|Operation|Comment|  \n|---------------|-------------|  \n|Encoding, Buffered|In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it. It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic. The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.|  \n|Encoding, Streamed|In streamed mode, the operation is similar to the above, but simpler. There is no need for a buffer. An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.|  \n|Decoding, Buffered|When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created. The headers of the message are read, and an XML reader positioned on the message body is created. This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.|  \n|Decoding, Streamed|When decoding in streamed mode, a special Message subclass is normally created. The stream is advanced just enough to read all the headers and position it on the message body. An XML reader is then created over the stream. This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.|  \n  \n Encoders can perform other functions as well. For example, the encoders can pool XML readers and writers. It is expensive to create a new XML reader or writer every time one is needed. Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size. In the descriptions of encoder operation described previously, whenever the phrase \"create an XML reader/writer\" is used, it normally means \"take one from the pool, or create one if one is not available.\" The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).  \n  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides three message encoders, although it is possible to create additional custom types. The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM). These are described in detail in [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).  \n  \n### The IStreamProvider Interface  \n When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:  \n  \n-   Write any necessary information preceding the stream (for example, the opening XML tag).  \n  \n-   Write the stream.  \n  \n-   Write any information following the stream (for example, the closing XML tag).  \n  \n This works well with encodings that are similar to the textual XML encoding. However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements. For example, in the MTOM encoding, the message is split into multiple parts. One part contains the XML Infoset, which may contain references to other parts for actual element contents. The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way. This means that by the time the closing element tag is written, the stream should not have been written out yet.  \n  \n For this purpose, the <xref:System.Xml.IStreamProvider> interface is used. The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written. The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:  \n  \n1.  Write any necessary information preceding the stream (for example, the opening XML tag).  \n  \n2.  Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.  \n  \n3.  Write any information following the stream (for example, the closing XML tag).  \n  \n With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data. For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags. The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.  \n  \n## Representing Data in the Service Framework  \n As stated in the \"Basic Architecture\" section of this topic, the service framework is the part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances. Normally, a message exchange is represented in the service framework as a [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute. The method can take in some parameters and can return a return value or out parameters (or both). On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message. On the client side, the reverse is true. The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md). However, this section will provide a brief overview.  \n  \n## Programming Models  \n The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework supports five different programming models for describing messages:  \n  \n### 1. The Empty Message  \n This is the simplest case. To describe an empty incoming message, do not use any input parameters.  \n  \n [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]\n [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  \n  \n To describe an empty outgoing message, use a void return value and do not use any out parameters:  \n  \n [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]\n [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  \n  \n Note that this is different from a one-way operation contract:  \n  \n [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]\n [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  \n  \n In the `SetDesiredTemperature` example, a two-way message exchange pattern is described. A message is returned from the operation, but it is empty. It is possible to return a fault from the operation. In the \"Set Lightbulb\" example, the message exchange pattern is one-way, so there is no outgoing message to describe. The service cannot communicate any status back to the client in this case.  \n  \n### 2. Using the Message Class Directly  \n It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract. In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.  \n  \n There are two main use cases for using `Message` directly. You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message. For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body. You can then create something similar to the following.  \n  \n [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]\n [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  \n  \n The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box. For example, you might have a service that forwards messages to multiple other recipients. The contract can be written as follows.  \n  \n [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]\n [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  \n  \n The Action=\"*\" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation. (Normally, the dispatcher would examine the message’s \"Action\" header to determine which operation it is intended for. Action=\"\\*\" means \"all possible values of the Action header\".) The combination of Action=\"\\*\" and using Message as a parameter is known as the \"universal contract\" because it is able to receive all possible messages. To be able to send all possible messages, use Message as the return value and set `ReplyAction` to \"\\*\". This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.  \n  \n### 3. Message Contracts  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] provides a declarative programming model for describing messages, called *message contracts*. This model is described in detail in [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md). Essentially, the entire message is represented by a single [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.  \n  \n Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly). For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element. These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element. Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.  \n  \n The following code example of a message contract demonstrates these features.  \n  \n [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]\n [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  \n  \n Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] the \"Serialization\" section later in this topic.  \n  \n### 4. Parameters  \n Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide. For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name. Making these decisions often requires deep knowledge of Web services and SOAP.  \n  \n The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user. This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract. For example, consider the following operation contract.  \n  \n [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]\n [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  \n  \n The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.  \n  \n Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.  \n  \n### 5. Stream  \n Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above. Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  \n  \n When `Stream` or one of its subclasses is used in this way, the serializer is not invoked. For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface. For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.  \n  \n## Programming Model Restrictions  \n The programming models described above cannot be arbitrarily combined. For example, if an operation accepts a message contract type, the message contract must be its only input parameter. Furthermore, the operation must then either return an empty message (return type of void) or another message contract. These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), and [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  \n  \n## Message Formatters  \n The programming models described above are supported by plugging in components called *message formatters* into the service framework. Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients, respectively.  \n  \n Message formatters are normally plugged in by behaviors. For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter. This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.  \n  \n The following tables lists the methods that a message formatter may implement.  \n  \n|Interface|Method|Action|  \n|---------------|------------|------------|  \n|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|Converts an incoming `Message` to operation parameters|  \n|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|Creates an outgoing `Message` from operation return value/out parameters|  \n|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|Creates an outgoing `Message` from operation parameters|  \n|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|Converts an incoming `Message` to a return value/out parameters|  \n  \n## Serialization  \n Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types and XML Infoset representation. Serialization is used in other places in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.  \n  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] supports two serialization technologies \"out of the box\" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`. Additionally, you can write custom serializers. However, other parts of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.  \n  \n The `XmlSerializer` is the serialization engine used in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services. The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model. `DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.  \n  \n <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively. The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization). The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer. To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.  \n  \n## See Also  \n [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)","nodes":[{"pos":[4,429],"embed":true,"restype":"x-metadata","content":"title: \"Data Transfer Architectural Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"data transfer [WCF], architectural overview\"\nms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9\ncaps.latest.revision: 14\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"","nodes":[{"content":"Data Transfer Architectural Overview | Microsoft Docs","nodes":[{"pos":[0,53],"content":"Data Transfer Architectural Overview | Microsoft Docs","nodes":[{"content":"Data Transfer Architectural Overview | Microsoft Docs","pos":[0,53]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[436,472],"content":"Data Transfer Architectural Overview","linkify":"Data Transfer Architectural Overview","nodes":[{"content":"Data Transfer Architectural Overview","pos":[0,36]}]},{"content":"can be thought of as a messaging infrastructure.","pos":[529,577]},{"content":"It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.","pos":[578,760]},{"content":"This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.","pos":[761,888]},{"content":"For a simpler, task-oriented view of how to send and receive data, see <bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.","pos":[889,1105],"source":" For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)."},{"pos":[1113,1720],"content":"[!NOTE]\n This topic discusses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] implementation details that are not visible by examining the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] object model. Two words of caution are in order with regard to documented implementation details. First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons. Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.","leadings":["","> "],"nodes":[{"content":"This topic discusses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] implementation details that are not visible by examining the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] object model. Two words of caution are in order with regard to documented implementation details. First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons. Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.","pos":[9,605],"nodes":[{"content":"This topic discusses <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> implementation details that are not visible by examining the <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> object model.","pos":[0,207],"source":"This topic discusses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] implementation details that are not visible by examining the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] object model."},{"content":"Two words of caution are in order with regard to documented implementation details.","pos":[208,291]},{"content":"First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.","pos":[292,412]},{"content":"Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.","pos":[413,596]}]}]},{"pos":[1729,1747],"content":"Basic Architecture","linkify":"Basic Architecture","nodes":[{"content":"Basic Architecture","pos":[0,18]}]},{"content":"At the core of <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> message-handling capabilities is the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class, which is described in detail in <bpt id=\"p1\">[</bpt>Using the Message Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)</ept>.","pos":[1751,2043],"source":"At the core of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)."},{"content":"The run-time components of <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> can be divided into two major parts: the channel stack and the service framework, with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class being the connection point.","pos":[2044,2295],"source":" The run-time components of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point."},{"content":"The channel stack is responsible for converting between a valid <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instance and some action that corresponds to the sending or receiving of message data.","pos":[2302,2496],"source":"The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data."},{"content":"On the sending side, the channel stack takes a valid <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instance and, after some processing, performs some action that logically corresponds to sending the message.","pos":[2497,2702],"source":" On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message."},{"content":"The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.","pos":[2703,2905]},{"content":"The most common action is sending the message over a network protocol.","pos":[2906,2976]},{"content":"On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instance.","pos":[2977,3234],"source":" On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance."},{"content":"You can use <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> by using the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class and the channel stack directly.","pos":[3241,3403],"source":"You can use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly."},{"content":"However, doing so is difficult and time-consuming.","pos":[3404,3454]},{"content":"Additionally, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> object provides no metadata support, so you cannot generate strongly typed <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> clients if you use <ph id=\"ph3\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> in this manner.","pos":[3455,3738],"source":" Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients if you use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] in this manner."},{"content":"Therefore, <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> includes a service framework that provides an easy-to-use programming model that you can use to construct and receive <ph id=\"ph2\">`Message`</ph> objects.","pos":[3745,3948],"source":"Therefore, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects."},{"content":"The service framework maps services to <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types through the notion of service contracts, and dispatches messages to user operations that are simply <ph id=\"ph2\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> methods marked with the <ph id=\"ph3\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute (for more details, see <bpt id=\"p1\">[</bpt>Designing Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/designing-service-contracts.md)</ept>).","pos":[3949,4427],"source":" The service framework maps services to [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types through the notion of service contracts, and dispatches messages to user operations that are simply [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md))."},{"content":"These methods may have parameters and return values.","pos":[4428,4480]},{"content":"On the service side, the service framework converts incoming <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instances into parameters and converts return values into outgoing <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instances.","pos":[4481,4707],"source":" On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances."},{"content":"On the client side, it does the opposite.","pos":[4708,4749]},{"content":"For example, consider the <ph id=\"ph1\">`FindAirfare`</ph> operation below.","pos":[4750,4806],"source":" For example, consider the `FindAirfare` operation below."},{"content":"Suppose <ph id=\"ph1\">`FindAirfare`</ph> is called on the client.","pos":[5069,5115],"source":"Suppose `FindAirfare` is called on the client."},{"content":"The service framework on the client converts the <ph id=\"ph1\">`FromCity`</ph> and <ph id=\"ph2\">`ToCity`</ph> parameters into an outgoing <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instance and passes it to the channel stack to be sent.","pos":[5116,5316],"source":" The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent."},{"content":"On the service side, when a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the <ph id=\"ph2\">`FromCity`</ph> and <ph id=\"ph3\">`ToCity`</ph> parameters and then calls the service-side <ph id=\"ph4\">`FindAirfare`</ph> method.","pos":[5323,5606],"source":"On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method."},{"content":"When the method returns, the service framework takes the returned integer value and the <ph id=\"ph1\">`IsDirectFlight`</ph> output parameter and creates a <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> object instance that contains this information.","pos":[5607,5834],"source":" When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information."},{"content":"It then passes the <ph id=\"ph1\">`Message`</ph> instance to the channel stack to be sent back to the client.","pos":[5835,5924],"source":" It then passes the `Message` instance to the channel stack to be sent back to the client."},{"content":"On the client side, a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instance that contains the response message emerges from the channel stack.","pos":[5931,6072],"source":"On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack."},{"content":"The service framework extracts the return value and the <ph id=\"ph1\">`IsDirectFlight`</ph> value and returns these to the caller of the client.","pos":[6073,6198],"source":" The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client."},{"pos":[6207,6220],"content":"Message Class","linkify":"Message Class","nodes":[{"content":"Message Class","pos":[0,13]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.","pos":[6224,6389],"source":"The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message."},{"content":"A <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> contains three major pieces of information: a message body, message headers, and message properties.","pos":[6390,6536],"source":" A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties."},{"pos":[6545,6557],"content":"Message Body","linkify":"Message Body","nodes":[{"content":"Message Body","pos":[0,12]}]},{"content":"The message body is intended to represent the actual data payload of the message.","pos":[6561,6642]},{"content":"The message body is always represented as an XML Infoset.","pos":[6643,6700]},{"content":"This does not mean that all messages created or received in <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> must be in XML format.","pos":[6701,6839],"source":" This does not mean that all messages created or received in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] must be in XML format."},{"content":"It is up to the channel stack to decide how to interpret the message body.","pos":[6840,6914]},{"content":"It may emit it as XML, convert it to some other format, or even omit it entirely.","pos":[6915,6996]},{"content":"Of course, with most of the bindings <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> supplies, the message body is represented as XML content in the body section of a SOAP envelope.","pos":[6997,7186],"source":" Of course, with most of the bindings [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] supplies, the message body is represented as XML content in the body section of a SOAP envelope."},{"content":"It is important to realize that the <ph id=\"ph1\">`Message`</ph> class does not necessarily contain a buffer with XML data representing the body.","pos":[7193,7319],"source":"It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body."},{"content":"Logically, <ph id=\"ph1\">`Message`</ph> contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.","pos":[7320,7455],"source":" Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory."},{"pos":[7465,7499],"content":"Putting Data into the Message Body","linkify":"Putting Data into the Message Body","nodes":[{"content":"Putting Data into the Message Body","pos":[0,34]}]},{"content":"There is no uniform mechanism to put data into a message body.","pos":[7503,7565]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class has an abstract method, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph>, which takes an <ph id=\"ph3\">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph>.","pos":[7566,7798],"source":" The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>."},{"content":"Each subclass of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class is responsible for overriding this method and writing out its own contents.","pos":[7799,7945],"source":" Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents."},{"content":"The message body logically contains the XML Infoset that <ph id=\"ph1\">`OnWriteBodyContent`</ph> produces.","pos":[7946,8033],"source":" The message body logically contains the XML Infoset that `OnWriteBodyContent` produces."},{"content":"For example, consider the following <ph id=\"ph1\">`Message`</ph> subclass.","pos":[8034,8089],"source":" For example, consider the following `Message` subclass."},{"content":"Physically, an <ph id=\"ph1\">`AirfareRequestMessage`</ph> instance contains only two strings (\"fromCity\" and \"toCity\").","pos":[8352,8452],"source":"Physically, an `AirfareRequestMessage` instance contains only two strings (\"fromCity\" and \"toCity\")."},{"content":"However, logically the message contains the following XML infoset:","pos":[8453,8519]},{"content":"Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.","pos":[8627,8813]},{"content":"Additionally, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class has static <ph id=\"ph2\">`CreateMessage`</ph> methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, a message that contains a SOAP fault, a message that contains XML represented by an <ph id=\"ph4\">&lt;xref:System.Xml.XmlReader&gt;</ph>, and so on.","pos":[8814,9245],"source":" Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on."},{"pos":[9255,9287],"content":"Getting Data from a Message Body","linkify":"Getting Data from a Message Body","nodes":[{"content":"Getting Data from a Message Body","pos":[0,32]}]},{"content":"You can extract the data stored in a message body in two main ways:","pos":[9291,9358]},{"content":"You can get the entire message body at one time by calling the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph> method and passing in an XML writer.","pos":[9368,9565],"source":"You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer."},{"content":"The complete message body is written out to this writer.","pos":[9566,9622]},{"content":"Getting the entire message body at one time is also called <bpt id=\"p1\">*</bpt>writing a message<ept id=\"p1\">*</ept>.","pos":[9623,9702],"source":" Getting the entire message body at one time is also called *writing a message*."},{"content":"Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.","pos":[9703,9878]},{"content":"Another way to get information out of the message body is to call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents&gt;</ph> and get an XML reader.","pos":[9888,10044],"source":"Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader."},{"content":"The message body can then be accessed sequentially as needed by calling methods on the reader.","pos":[10045,10139]},{"content":"Getting the message body piece-by-piece is also called <bpt id=\"p1\">*</bpt>reading a message<ept id=\"p1\">*</ept>.","pos":[10140,10215],"source":" Getting the message body piece-by-piece is also called *reading a message*."},{"content":"Reading the message is primarily used by the service framework when receiving messages.","pos":[10216,10303]},{"content":"For example, when the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.","pos":[10304,10607],"source":" For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph."},{"content":"A message body can be retrieved only once.","pos":[10614,10656]},{"content":"This makes it possible to work with forward-only streams.","pos":[10657,10714]},{"content":"For example, you can write an <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph> override that reads from a <ph id=\"ph2\">&lt;xref:System.IO.FileStream&gt;</ph> and returns the results as an XML Infoset.","pos":[10715,10942],"source":" For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset."},{"content":"You will never need to \"rewind\" to the beginning of the file.","pos":[10943,11004]},{"pos":[11011,11222],"content":"The <ph id=\"ph1\">`WriteBodyContents`</ph> and <ph id=\"ph2\">`GetReaderAtBodyContents`</ph> methods simply check that the message body has never been retrieved before, and then call <ph id=\"ph3\">`OnWriteBodyContents`</ph> or <ph id=\"ph4\">`OnGetReaderAtBodyContents`</ph>, respectively.","source":"The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively."},{"pos":[11231,11251],"content":"Message Usage in WCF","linkify":"Message Usage in WCF","nodes":[{"content":"Message Usage in WCF","pos":[0,20]}]},{"content":"Most messages can be classified as either <bpt id=\"p1\">*</bpt>outgoing<ept id=\"p1\">*</ept> (those that are created by the service framework to be sent by the channel stack) or <bpt id=\"p2\">*</bpt>incoming<ept id=\"p2\">*</ept> (those that arrive from the channel stack and are interpreted by the service framework).","pos":[11255,11492],"source":"Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework)."},{"content":"Furthermore, the channel stack can operate in either buffered or streaming mode.","pos":[11493,11573]},{"content":"The service framework may also expose a streamed or nonstreamed programming model.","pos":[11574,11656]},{"content":"This leads to the cases listed in the following table, along with simplified details of their implementation.","pos":[11657,11766]},{"content":"Message type","pos":[11773,11785]},{"content":"Body data in message","pos":[11786,11806]},{"content":"Write (OnWriteBodyContents) implementation","pos":[11807,11849]},{"content":"Read (OnGetReaderAtBodyContents) Implementation","pos":[11850,11897]},{"content":"Outgoing, created from nonstreamed programming model","pos":[12059,12111]},{"content":"The data needed to write the message (for example, an object and the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> instance needed to serialize it)*","pos":[12112,12273],"source":"The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)*"},{"pos":[12274,12436],"content":"Custom logic to write out the message based on the stored data (for example, call <ph id=\"ph1\">`WriteObject`</ph> on the <ph id=\"ph2\">`DataContractSerializer`</ph> if that is the serializer in use)*","source":"Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)*"},{"pos":[12437,12521],"content":"Call <ph id=\"ph1\">`OnWriteBodyContents`</ph>, buffer the results, return an XML reader over the buffer","source":"Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer"},{"content":"Outgoing, created from streamed programming model","pos":[12526,12575]},{"pos":[12576,12617],"content":"The <ph id=\"ph1\">`Stream`</ph> with the data to be written*","source":"The `Stream` with the data to be written*"},{"content":"Write out data from the stored stream using the <ph id=\"ph1\">&lt;xref:System.Xml.IStreamProvider&gt;</ph> mechanism*","pos":[12618,12710],"source":"Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism*"},{"pos":[12711,12795],"content":"Call <ph id=\"ph1\">`OnWriteBodyContents`</ph>, buffer the results, return an XML reader over the buffer","source":"Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer"},{"content":"Incoming from streaming channel stack","pos":[12800,12837]},{"pos":[12838,12951],"content":"A <ph id=\"ph1\">`Stream`</ph> object that represents the data coming in over the network with an <ph id=\"ph2\">&lt;xref:System.Xml.XmlReader&gt;</ph> over it","source":"A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it"},{"pos":[12952,13020],"content":"Write out the contents from the stored <ph id=\"ph1\">`XmlReader`</ph> using <ph id=\"ph2\">`WriteNode`</ph>","source":"Write out the contents from the stored `XmlReader` using `WriteNode`"},{"pos":[13021,13051],"content":"Returns the stored <ph id=\"ph1\">`XmlReader`</ph>","source":"Returns the stored `XmlReader`"},{"content":"Incoming from nonstreaming channel stack","pos":[13056,13096]},{"pos":[13097,13157],"content":"A buffer that contains body data with an <ph id=\"ph1\">`XmlReader`</ph> over it","source":"A buffer that contains body data with an `XmlReader` over it"},{"pos":[13158,13227],"content":"Writes out the contents from the stored <ph id=\"ph1\">`XmlReader`</ph> using <ph id=\"ph2\">`WriteNode`</ph>","source":"Writes out the contents from the stored `XmlReader` using `WriteNode`"},{"content":"Returns the stored lang","pos":[13228,13251]},{"content":"<ph id=\"ph1\">\\*</ph> These items are not implemented directly in <ph id=\"ph2\">`Message`</ph> subclasses, but in subclasses of the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.BodyWriter&gt;</ph> class.","pos":[13259,13406],"source":"\\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class."},{"content":"For more information about the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BodyWriter&gt;</ph>, see <bpt id=\"p1\">[</bpt>Using the Message Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)</ept>.","pos":[13407,13591],"source":" For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)."},{"pos":[13600,13615],"content":"Message Headers","linkify":"Message Headers","nodes":[{"content":"Message Headers","pos":[0,15]}]},{"content":"A message may contain headers.","pos":[13619,13649]},{"content":"A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.","pos":[13650,13768]},{"content":"Message headers are accessed using the <ph id=\"ph1\">`Headers`</ph> property on <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph>.","pos":[13769,13874],"source":" Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>."},{"content":"Each header is represented by a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageHeader&gt;</ph> class.","pos":[13875,13963],"source":" Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class."},{"content":"Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.","pos":[13964,14090]},{"content":"Putting information into a message header and extracting information from it is similar to using the message body.","pos":[14097,14211]},{"content":"The process is somewhat simplified because streaming is not supported.","pos":[14212,14282]},{"content":"It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.","pos":[14283,14442]},{"content":"There is no general-purpose mechanism available to get an XML reader over a header, but there is a <ph id=\"ph1\">`MessageHeader`</ph> subclass internal to <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> that represents a readable header with such a capability.","pos":[14443,14692],"source":" There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that represents a readable header with such a capability."},{"content":"This type of <ph id=\"ph1\">`MessageHeader`</ph> is created by the channel stack when a message with custom application headers comes in.","pos":[14693,14810],"source":" This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in."},{"content":"This enables the service framework to use a deserialization engine, such as the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>, to interpret these headers.","pos":[14811,14978],"source":" This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers."},{"pos":[15045,15146],"content":"<bpt id=\"p1\">[</bpt>Using the Message Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)</ept>.","source":"[Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)."},{"pos":[15155,15173],"content":"Message Properties","linkify":"Message Properties","nodes":[{"content":"Message Properties","pos":[0,18]}]},{"content":"A message may contain properties.","pos":[15177,15210]},{"content":"A <bpt id=\"p1\">*</bpt>property<ept id=\"p1\">*</ept> is any <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> object that is associated with a string name.","pos":[15211,15340],"source":" A *property* is any [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] object that is associated with a string name."},{"content":"Properties are accessed through the <ph id=\"ph1\">`Properties`</ph> property on <ph id=\"ph2\">`Message`</ph>.","pos":[15341,15412],"source":" Properties are accessed through the `Properties` property on `Message`."},{"content":"Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.","pos":[15419,15610]},{"content":"Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.","pos":[15611,15809]},{"content":"For example, the HTTP transport channel included as part of <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> is capable of producing various HTTP status codes, such as \"404 (Not Found)\" and \"500 (Internal Server Error),\" when it sends replies to clients.","pos":[15816,16077],"source":"For example, the HTTP transport channel included as part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] is capable of producing various HTTP status codes, such as \"404 (Not Found)\" and \"500 (Internal Server Error),\" when it sends replies to clients."},{"content":"Before sending a reply message, it checks to see whether the <ph id=\"ph1\">`Properties`</ph> of the <ph id=\"ph2\">`Message`</ph> contain a property called \"httpResponse\" that contains an object of type <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.HttpResponseMessageProperty&gt;</ph>.","pos":[16078,16306],"source":" Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called \"httpResponse\" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>."},{"content":"If such a property is found, it will look at the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A&gt;</ph> property and use that status code.","pos":[16307,16468],"source":" If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code."},{"content":"If it is not found, the default \"200 (OK)\" code is used.","pos":[16469,16525]},{"pos":[16592,16693],"content":"<bpt id=\"p1\">[</bpt>Using the Message Class<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)</ept>.","source":"[Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)."},{"pos":[16703,16725],"content":"The Message as a Whole","linkify":"The Message as a Whole","nodes":[{"content":"The Message as a Whole","pos":[0,22]}]},{"content":"So far, we have discussed methods for accessing the various parts of the message in isolation.","pos":[16729,16823]},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class also provides methods to work with the entire message as a whole.","pos":[16824,16952],"source":" However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole."},{"content":"For example, the <ph id=\"ph1\">`WriteMessage`</ph> method writes out the entire message to an XML writer.","pos":[16953,17039],"source":" For example, the `WriteMessage` method writes out the entire message to an XML writer."},{"content":"For this to be possible, a mapping must be defined between the entire <ph id=\"ph1\">`Message`</ph> instance and an XML Infoset.","pos":[17046,17154],"source":"For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset."},{"content":"Such a mapping, in fact, exists: <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> uses the SOAP standard to define this mapping.","pos":[17155,17290],"source":" Such a mapping, in fact, exists: [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the SOAP standard to define this mapping."},{"content":"When a <ph id=\"ph1\">`Message`</ph> instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.","pos":[17291,17426],"source":" When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message."},{"content":"Thus, <ph id=\"ph1\">`WriteMessage`</ph> would normally perform the following steps:","pos":[17427,17491],"source":" Thus, `WriteMessage` would normally perform the following steps:"},{"content":"Write the SOAP envelope element opening tag.","pos":[17501,17545]},{"content":"Write the SOAP header element opening tag, write out all of the headers, and close the header element.","pos":[17555,17657]},{"content":"Write the SOAP body element opening tag.","pos":[17667,17707]},{"pos":[17717,17788],"content":"Call <ph id=\"ph1\">`WriteBodyContents`</ph> or an equivalent method to write out the body.","source":"Call `WriteBodyContents` or an equivalent method to write out the body."},{"content":"Close the body and envelope elements.","pos":[17798,17835]},{"content":"The preceding steps are closely tied to the SOAP standard.","pos":[17842,17900]},{"content":"This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.","pos":[17901,18090]},{"content":"Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.","pos":[18091,18190]},{"content":"For these purposes, a <ph id=\"ph1\">`Version`</ph> property is provided on <ph id=\"ph2\">`Message`</ph>.","pos":[18197,18263],"source":"For these purposes, a `Version` property is provided on `Message`."},{"content":"It can be set to the SOAP version to use when writing out the message, or it can be set to <ph id=\"ph1\">`None`</ph> to prevent any SOAP-specific mappings.","pos":[18264,18400],"source":" It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings."},{"content":"If the <ph id=\"ph1\">`Version`</ph> property is set to <ph id=\"ph2\">`None`</ph>, methods that work with the entire message act as if the message consisted of its body only, for example, <ph id=\"ph3\">`WriteMessage`</ph> would simply call <ph id=\"ph4\">`WriteBodyContents`</ph> instead of performing the multiple steps listed above.","pos":[18401,18657],"source":" If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above."},{"content":"It is expected that on incoming messages, <ph id=\"ph1\">`Version`</ph> will be auto-detected and set correctly.","pos":[18658,18750],"source":" It is expected that on incoming messages, `Version` will be auto-detected and set correctly."},{"pos":[18759,18776],"content":"The Channel Stack","linkify":"The Channel Stack","nodes":[{"content":"The Channel Stack","pos":[0,17]}]},{"pos":[18786,18794],"content":"Channels","linkify":"Channels","nodes":[{"content":"Channels","pos":[0,8]}]},{"pos":[18798,19084],"content":"As stated before, the channel stack is responsible for converting outgoing <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming <ph id=\"ph2\">`Message`</ph> instances.","source":"As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances."},{"content":"The channel stack is composed of one or more channels ordered in a sequence.","pos":[19091,19167]},{"content":"An outgoing <ph id=\"ph1\">`Message`</ph> instance is passed to the first channel in the stack (also called the <bpt id=\"p1\">*</bpt>topmost channel<ept id=\"p1\">*</ept>), which passes it to the next channel down in stack, and so on.","pos":[19168,19341],"source":" An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on."},{"content":"The message terminates in the last channel, which is called the <bpt id=\"p1\">*</bpt>transport channel<ept id=\"p1\">*</ept>.","pos":[19342,19426],"source":" The message terminates in the last channel, which is called the *transport channel*."},{"content":"Incoming messages originate in the transport channel and are passed from channel to channel up the stack.","pos":[19427,19532]},{"content":"From the topmost channel, the message is usually passed into the service framework.","pos":[19533,19616]},{"content":"While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.","pos":[19617,19833]},{"content":"Channels may operate on the message in various ways as it passes through the stack.","pos":[19840,19923]},{"content":"The most common operation is adding a header to an outgoing message and reading headers on an incoming message.","pos":[19924,20035]},{"content":"For example, a channel may compute the digital signature of a message and add it as a header.","pos":[20036,20129]},{"content":"A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.","pos":[20130,20305]},{"content":"Channels also often set or inspect message properties.","pos":[20306,20360]},{"content":"The message body is usually not modified, although this is allowed, for example, the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> security channel can encrypt the message body.","pos":[20361,20548],"source":" The message body is usually not modified, although this is allowed, for example, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] security channel can encrypt the message body."},{"pos":[20558,20597],"content":"Transport Channels and Message Encoders","linkify":"Transport Channels and Message Encoders","nodes":[{"content":"Transport Channels and Message Encoders","pos":[0,39]}]},{"content":"The bottommost channel in the stack is responsible for actually transforming an outgoing <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph>, as modified by other channels, into some action.","pos":[20601,20783],"source":"The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action."},{"content":"On the receive side, this is the channel that converts some action into a <ph id=\"ph1\">`Message`</ph> that other channels process.","pos":[20784,20896],"source":" On the receive side, this is the channel that converts some action into a `Message` that other channels process."},{"content":"As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.","pos":[20903,21153]},{"content":"All these actions have one thing in common: they require a transformation between the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph><ph id=\"ph2\">`Message`</ph> instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.","pos":[21154,21406],"source":" All these actions have one thing in common: they require a transformation between the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued."},{"content":"The process of converting a <ph id=\"ph1\">`Message`</ph> into a group of bytes is called <bpt id=\"p1\">*</bpt>encoding<ept id=\"p1\">*</ept>, and the reverse process of creating a <ph id=\"ph2\">`Message`</ph> from a group of bytes is called <bpt id=\"p2\">*</bpt>decoding<ept id=\"p2\">*</ept>.","pos":[21407,21580],"source":" The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*."},{"content":"Most transport channels use components called <bpt id=\"p1\">*</bpt>message encoders<ept id=\"p1\">*</ept> to accomplish the encoding and decoding work.","pos":[21587,21697],"source":"Most transport channels use components called *message encoders* to accomplish the encoding and decoding work."},{"content":"A message encoder is a subclass of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph> class.","pos":[21698,21794],"source":" A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class."},{"content":"<ph id=\"ph1\">`MessageEncoder`</ph> includes various <ph id=\"ph2\">`ReadMessage`</ph> and <ph id=\"ph3\">`WriteMessage`</ph> method overloads to convert between <ph id=\"ph4\">`Message`</ph> and groups of bytes.","pos":[21795,21928],"source":"`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes."},{"content":"On the sending side, a buffering transport channel passes the <ph id=\"ph1\">`Message`</ph> object that it received from a channel above it to <ph id=\"ph2\">`WriteMessage`</ph>.","pos":[21935,22073],"source":"On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`."},{"content":"It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).","pos":[22074,22244]},{"content":"A streaming transport channel first creates a <ph id=\"ph1\">`Stream`</ph> (for example, over the outgoing TCP connection), and then passes both the <ph id=\"ph2\">`Stream`</ph> and the <ph id=\"ph3\">`Message`</ph> it needs to send to the appropriate <ph id=\"ph4\">`WriteMessage`</ph> overload, which writes out the message.","pos":[22245,22491],"source":" A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message."},{"content":"On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls <ph id=\"ph1\">`ReadMessage`</ph> to get a <ph id=\"ph2\">`Message`</ph> object that it can pass further up the channel stack.","pos":[22498,22726],"source":"On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack."},{"content":"A streaming transport channel creates a <ph id=\"ph1\">`Stream`</ph> object (for example, a network stream over the incoming TCP connection) and passes that to <ph id=\"ph2\">`ReadMessage`</ph> to get back a <ph id=\"ph3\">`Message`</ph> object.","pos":[22727,22912],"source":" A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object."},{"content":"The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.","pos":[22919,23087]},{"content":"However, the advantage of this separation is ease of composition.","pos":[23088,23153]},{"content":"As long as a transport channel uses only the base <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MessageEncoder&gt;</ph>, it can work with any <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> or third-party message encoder.","pos":[23154,23364],"source":" As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] or third-party message encoder."},{"content":"Likewise, the same encoder can normally be used in any transport channel.","pos":[23365,23438]},{"pos":[23448,23473],"content":"Message Encoder Operation","linkify":"Message Encoder Operation","nodes":[{"content":"Message Encoder Operation","pos":[0,25]}]},{"content":"To describe the typical operation of an encoder, it is useful to consider the following four cases.","pos":[23477,23576]},{"content":"Operation","pos":[23583,23592]},{"content":"Comment","pos":[23593,23600]},{"content":"Encoding, Buffered","pos":[23639,23657]},{"content":"In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.","pos":[23658,23767]},{"content":"It then calls <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29&gt;</ph> on the message being encoded, which writes out the headers and then the body using <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph>, as explained in the preceding section about <ph id=\"ph3\">`Message`</ph> in this topic.","pos":[23768,24115],"source":" It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic."},{"content":"The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.","pos":[24116,24229]},{"content":"Encoding, Streamed","pos":[24234,24252]},{"content":"In streamed mode, the operation is similar to the above, but simpler.","pos":[24253,24322]},{"content":"There is no need for a buffer.","pos":[24323,24353]},{"content":"An XML writer is normally created over the stream and <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29&gt;</ph> is called on the <ph id=\"ph2\">`Message`</ph> to write it out to this writer.","pos":[24354,24549],"source":" An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer."},{"content":"Decoding, Buffered","pos":[24554,24572]},{"content":"When decoding in buffered mode, a special <ph id=\"ph1\">`Message`</ph> subclass that contains the buffered data is normally created.","pos":[24573,24686],"source":"When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created."},{"content":"The headers of the message are read, and an XML reader positioned on the message body is created.","pos":[24687,24784]},{"content":"This is the reader that will be returned with <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents&gt;</ph>.","pos":[24785,24899],"source":" This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>."},{"content":"Decoding, Streamed","pos":[24904,24922]},{"content":"When decoding in streamed mode, a special Message subclass is normally created.","pos":[24923,25002]},{"content":"The stream is advanced just enough to read all the headers and position it on the message body.","pos":[25003,25098]},{"content":"An XML reader is then created over the stream.","pos":[25099,25145]},{"content":"This is the reader that will be returned with <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents&gt;</ph>.","pos":[25146,25260],"source":" This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>."},{"content":"Encoders can perform other functions as well.","pos":[25268,25313]},{"content":"For example, the encoders can pool XML readers and writers.","pos":[25314,25373]},{"content":"It is expensive to create a new XML reader or writer every time one is needed.","pos":[25374,25452]},{"content":"Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.","pos":[25453,25552]},{"content":"In the descriptions of encoder operation described previously, whenever the phrase \"create an XML reader/writer\" is used, it normally means \"take one from the pool, or create one if one is not available.\"","pos":[25553,25757]},{"content":"The encoder (and the <ph id=\"ph1\">`Message`</ph> subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the <ph id=\"ph2\">`Message`</ph> is closed).","pos":[25758,25959],"source":" The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed)."},{"content":"provides three message encoders, although it is possible to create additional custom types.","pos":[26022,26113]},{"content":"The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).","pos":[26114,26206]},{"content":"These are described in detail in <bpt id=\"p1\">[</bpt>Choosing a Message Encoder<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)</ept>.","pos":[26207,26347],"source":" These are described in detail in [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)."},{"pos":[26357,26386],"content":"The IStreamProvider Interface","linkify":"The IStreamProvider Interface","nodes":[{"content":"The IStreamProvider Interface","pos":[0,29]}]},{"content":"When writing an outgoing message that contains a streamed body to an XML writer, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> uses a sequence of calls similar to the following in its <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph> implementation:","pos":[26390,26691],"source":"When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:"},{"content":"Write any necessary information preceding the stream (for example, the opening XML tag).","pos":[26701,26789]},{"content":"Write the stream.","pos":[26799,26816]},{"content":"Write any information following the stream (for example, the closing XML tag).","pos":[26826,26904]},{"content":"This works well with encodings that are similar to the textual XML encoding.","pos":[26911,26987]},{"content":"However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.","pos":[26988,27155]},{"content":"For example, in the MTOM encoding, the message is split into multiple parts.","pos":[27156,27232]},{"content":"One part contains the XML Infoset, which may contain references to other parts for actual element contents.","pos":[27233,27340]},{"content":"The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.","pos":[27341,27511]},{"content":"This means that by the time the closing element tag is written, the stream should not have been written out yet.","pos":[27512,27624]},{"content":"For this purpose, the <ph id=\"ph1\">&lt;xref:System.Xml.IStreamProvider&gt;</ph> interface is used.","pos":[27631,27705],"source":"For this purpose, the <xref:System.Xml.IStreamProvider> interface is used."},{"content":"The interface has a <ph id=\"ph1\">&lt;xref:System.Xml.IStreamProvider.GetStream&gt;</ph> method that returns the stream to be written.","pos":[27706,27815],"source":" The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written."},{"content":"The correct way to write out a streamed message body in <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29&gt;</ph> is as follows:","pos":[27816,27986],"source":" The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:"},{"content":"Write any necessary information preceding the stream (for example, the opening XML tag).","pos":[27996,28084]},{"pos":[28094,28298],"content":"Call the <ph id=\"ph1\">`WriteValue`</ph> overload on the <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph> that takes an <ph id=\"ph3\">&lt;xref:System.Xml.IStreamProvider&gt;</ph>, with an <ph id=\"ph4\">`IStreamProvider`</ph> implementation that returns the stream to be written.","source":"Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written."},{"content":"Write any information following the stream (for example, the closing XML tag).","pos":[28308,28386]},{"content":"With this approach, the XML writer has a choice of when to call <ph id=\"ph1\">&lt;xref:System.Xml.IStreamProvider.GetStream&gt;</ph> and write out the streamed data.","pos":[28393,28533],"source":"With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data."},{"content":"For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.","pos":[28534,28677]},{"content":"The MTOM writer may decide to call <ph id=\"ph1\">&lt;xref:System.Xml.IStreamProvider.GetStream&gt;</ph> later, when it is ready to write the appropriate part of the message.","pos":[28678,28826],"source":" The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message."},{"pos":[28835,28877],"content":"Representing Data in the Service Framework","linkify":"Representing Data in the Service Framework","nodes":[{"content":"Representing Data in the Service Framework","pos":[0,42]}]},{"content":"As stated in the \"Basic Architecture\" section of this topic, the service framework is the part of <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> that, among other things, is responsible for converting between a user-friendly programming model for message data and actual <ph id=\"ph2\">`Message`</ph> instances.","pos":[28881,29181],"source":"As stated in the \"Basic Architecture\" section of this topic, the service framework is the part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances."},{"content":"Normally, a message exchange is represented in the service framework as a <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> method marked with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph> attribute.","pos":[29182,29407],"source":" Normally, a message exchange is represented in the service framework as a [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute."},{"content":"The method can take in some parameters and can return a return value or out parameters (or both).","pos":[29408,29505]},{"content":"On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.","pos":[29506,29651]},{"content":"On the client side, the reverse is true.","pos":[29652,29692]},{"content":"The programming model for describing messages using parameters and the return value is described in detail in <bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.","pos":[29693,29948],"source":" The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)."},{"content":"However, this section will provide a brief overview.","pos":[29949,30001]},{"pos":[30010,30028],"content":"Programming Models","linkify":"Programming Models","nodes":[{"content":"Programming Models","pos":[0,18]}]},{"pos":[30032,30177],"content":"The <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service framework supports five different programming models for describing messages:","source":"The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework supports five different programming models for describing messages:"},{"pos":[30187,30207],"content":"1. The Empty Message","linkify":"1. The Empty Message","nodes":[{"content":"1. The Empty Message","pos":[0,20]}]},{"content":"This is the simplest case.","pos":[30211,30237]},{"content":"To describe an empty incoming message, do not use any input parameters.","pos":[30238,30309]},{"content":"To describe an empty outgoing message, use a void return value and do not use any out parameters:","pos":[30572,30669]},{"content":"Note that this is different from a one-way operation contract:","pos":[30932,30994]},{"content":"In the <ph id=\"ph1\">`SetDesiredTemperature`</ph> example, a two-way message exchange pattern is described.","pos":[31257,31345],"source":"In the `SetDesiredTemperature` example, a two-way message exchange pattern is described."},{"content":"A message is returned from the operation, but it is empty.","pos":[31346,31404]},{"content":"It is possible to return a fault from the operation.","pos":[31405,31457]},{"content":"In the \"Set Lightbulb\" example, the message exchange pattern is one-way, so there is no outgoing message to describe.","pos":[31458,31575]},{"content":"The service cannot communicate any status back to the client in this case.","pos":[31576,31650]},{"pos":[31660,31695],"content":"2. Using the Message Class Directly","linkify":"2. Using the Message Class Directly","nodes":[{"content":"2. Using the Message Class Directly","pos":[0,35]}]},{"content":"It is possible to use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> class (or one of its subclasses) directly in an operation contract.","pos":[31699,31836],"source":"It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract."},{"content":"In this case, the service framework just passes the <ph id=\"ph1\">`Message`</ph> from the operation to the channel stack and vice versa, with no further processing.","pos":[31837,31982],"source":" In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing."},{"content":"There are two main use cases for using <ph id=\"ph1\">`Message`</ph> directly.","pos":[31989,32047],"source":"There are two main use cases for using `Message` directly."},{"content":"You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.","pos":[32048,32185]},{"content":"For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.","pos":[32186,32360]},{"content":"You can then create something similar to the following.","pos":[32361,32416]},{"content":"The second common use for <ph id=\"ph1\">`Message`</ph> in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.","pos":[32679,32852],"source":"The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box."},{"content":"For example, you might have a service that forwards messages to multiple other recipients.","pos":[32853,32943]},{"content":"The contract can be written as follows.","pos":[32944,32983]},{"content":"The Action=\"*\" line effectively turns off message dispatching and ensures that all messages sent to the <ph id=\"ph1\">`IForwardingService`</ph> contract make their way to the <ph id=\"ph2\">`ForwardMessage`</ph> operation.","pos":[33246,33429],"source":"The Action=\"*\" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation."},{"content":"(Normally, the dispatcher would examine the message’s \"Action\" header to determine which operation it is intended for.","pos":[33430,33548]},{"content":"Action=\"<ph id=\"ph1\">\\*</ph>\" means \"all possible values of the Action header\".) The combination of Action=\"<ph id=\"ph2\">\\*</ph>\" and using Message as a parameter is known as the \"universal contract\" because it is able to receive all possible messages.","pos":[33549,33765],"source":" Action=\"\\*\" means \"all possible values of the Action header\".) The combination of Action=\"\\*\" and using Message as a parameter is known as the \"universal contract\" because it is able to receive all possible messages."},{"content":"To be able to send all possible messages, use Message as the return value and set <ph id=\"ph1\">`ReplyAction`</ph> to \"<ph id=\"ph2\">\\*</ph>\".","pos":[33766,33870],"source":" To be able to send all possible messages, use Message as the return value and set `ReplyAction` to \"\\*\"."},{"content":"This will prevent the service framework from adding its own Action header, enabling you to control this header using the <ph id=\"ph1\">`Message`</ph> object you return.","pos":[33871,34020],"source":" This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return."},{"pos":[34030,34050],"content":"3. Message Contracts","linkify":"3. Message Contracts","nodes":[{"content":"3. Message Contracts","pos":[0,20]}]},{"content":"provides a declarative programming model for describing messages, called <bpt id=\"p1\">*</bpt>message contracts<ept id=\"p1\">*</ept>.","pos":[34110,34203],"source":" provides a declarative programming model for describing messages, called *message contracts*."},{"content":"This model is described in detail in <bpt id=\"p1\">[</bpt>Using Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)</ept>.","pos":[34204,34342],"source":" This model is described in detail in [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)."},{"content":"Essentially, the entire message is represented by a single <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> type that uses attributes like the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> to describe which parts of the message contract class should map to which part of the message.","pos":[34343,34703],"source":" Essentially, the entire message is represented by a single [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message."},{"content":"Message contracts provide a lot of control over the resulting <ph id=\"ph1\">`Message`</ph> instances (although obviously not as much control as using the <ph id=\"ph2\">`Message`</ph> class directly).","pos":[34710,34871],"source":"Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly)."},{"content":"For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.","pos":[34872,34994]},{"content":"These elements can either occur directly in the body (<bpt id=\"p1\">*</bpt>bare<ept id=\"p1\">*</ept> mode) or can be <bpt id=\"p2\">*</bpt>wrapped<ept id=\"p2\">*</ept> in an encompassing XML element.","pos":[34995,35113],"source":" These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element."},{"content":"Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.","pos":[35114,35267]},{"content":"The following code example of a message contract demonstrates these features.","pos":[35274,35351]},{"content":"Items marked to be serialized (with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>, or other related attributes) must be serializable to participate in a message contract.","pos":[35614,35847],"source":"Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph> the \"Serialization\" section later in this topic.","pos":[35848,35956],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] the \"Serialization\" section later in this topic."},{"pos":[35966,35979],"content":"4. Parameters","linkify":"4. Parameters","nodes":[{"content":"4. Parameters","pos":[0,13]}]},{"content":"Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.","pos":[35983,36141]},{"content":"For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.","pos":[36142,36289]},{"content":"Making these decisions often requires deep knowledge of Web services and SOAP.","pos":[36290,36368]},{"content":"The <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.","pos":[36375,36635],"source":"The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user."},{"content":"This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.","pos":[36636,36762]},{"content":"For example, consider the following operation contract.","pos":[36763,36818]},{"pos":[37085,37291],"content":"The service framework automatically decides to put all three pieces of information (<ph id=\"ph1\">`customerID`</ph>, <ph id=\"ph2\">`item`</ph>, and <ph id=\"ph3\">`quantity`</ph>) into the message body and wrap them in a wrapper element named <ph id=\"ph4\">`SubmitOrderRequest`</ph>.","source":"The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`."},{"pos":[37298,37539],"content":"Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or <ph id=\"ph1\">`Message`</ph>-based programming models.","source":"Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models."},{"pos":[37549,37558],"content":"5. Stream","linkify":"5. Stream","nodes":[{"content":"5. Stream","pos":[0,9]}]},{"content":"Using <ph id=\"ph1\">`Stream`</ph> or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.","pos":[37562,37757],"source":"Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above."},{"content":"Using <ph id=\"ph1\">`Stream`</ph> in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible <ph id=\"ph2\">`Message`</ph> subclass.","pos":[37758,37937],"source":" Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Large Data and Streaming<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)</ept>.","pos":[37938,38100],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)."},{"content":"When <ph id=\"ph1\">`Stream`</ph> or one of its subclasses is used in this way, the serializer is not invoked.","pos":[38107,38197],"source":"When `Stream` or one of its subclasses is used in this way, the serializer is not invoked."},{"content":"For outgoing messages, a special streaming <ph id=\"ph1\">`Message`</ph> subclass is created and the stream is written out as described in the section on the <ph id=\"ph2\">&lt;xref:System.Xml.IStreamProvider&gt;</ph> interface.","pos":[38198,38380],"source":" For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface."},{"content":"For incoming messages, the service framework creates a <ph id=\"ph1\">`Stream`</ph> subclass over the incoming message and provides it to the operation.","pos":[38381,38513],"source":" For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation."},{"pos":[38522,38552],"content":"Programming Model Restrictions","linkify":"Programming Model Restrictions","nodes":[{"content":"Programming Model Restrictions","pos":[0,30]}]},{"content":"The programming models described above cannot be arbitrarily combined.","pos":[38556,38626]},{"content":"For example, if an operation accepts a message contract type, the message contract must be its only input parameter.","pos":[38627,38743]},{"content":"Furthermore, the operation must then either return an empty message (return type of void) or another message contract.","pos":[38744,38862]},{"content":"These programming model restrictions are described in the topics for each specific programming model: <bpt id=\"p1\">[</bpt>Using Message Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)</ept>, <bpt id=\"p2\">[</bpt>Using the Message Class<ept id=\"p2\">](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)</ept>, and <bpt id=\"p3\">[</bpt>Large Data and Streaming<ept id=\"p3\">](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)</ept>.","pos":[38863,39276],"source":" These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), and [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)."},{"pos":[39285,39303],"content":"Message Formatters","linkify":"Message Formatters","nodes":[{"content":"Message Formatters","pos":[0,18]}]},{"content":"The programming models described above are supported by plugging in components called <bpt id=\"p1\">*</bpt>message formatters<ept id=\"p1\">*</ept> into the service framework.","pos":[39307,39441],"source":"The programming models described above are supported by plugging in components called *message formatters* into the service framework."},{"content":"Message formatters are types that implement the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IClientMessageFormatter&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter&gt;</ph> interface, or both, for use in clients and service <ph id=\"ph3\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> clients, respectively.","pos":[39442,39748],"source":" Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients, respectively."},{"content":"Message formatters are normally plugged in by behaviors.","pos":[39755,39811]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph> plugs in the data contract message formatter.","pos":[39812,39953],"source":" For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter."},{"content":"This is done on the service side by setting <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A&gt;</ph> to the correct formatter in the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29&gt;</ph> method, or on the client side by setting <ph id=\"ph3\">&lt;xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A&gt;</ph> to the correct formatter in the <ph id=\"ph4\">&lt;xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29&gt;</ph> method.","pos":[39954,40620],"source":" This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method."},{"content":"The following tables lists the methods that a message formatter may implement.","pos":[40627,40705]},{"content":"Interface","pos":[40712,40721]},{"content":"Method","pos":[40722,40728]},{"content":"Action","pos":[40729,40735]},{"pos":[40997,41051],"content":"Converts an incoming <ph id=\"ph1\">`Message`</ph> to operation parameters","source":"Converts an incoming `Message` to operation parameters"},{"pos":[41286,41358],"content":"Creates an outgoing <ph id=\"ph1\">`Message`</ph> from operation return value/out parameters","source":"Creates an outgoing `Message` from operation return value/out parameters"},{"pos":[41575,41630],"content":"Creates an outgoing <ph id=\"ph1\">`Message`</ph> from operation parameters","source":"Creates an outgoing `Message` from operation parameters"},{"pos":[41840,41903],"content":"Converts an incoming <ph id=\"ph1\">`Message`</ph> to a return value/out parameters","source":"Converts an incoming `Message` to a return value/out parameters"},{"pos":[41913,41926],"content":"Serialization","linkify":"Serialization","nodes":[{"content":"Serialization","pos":[0,13]}]},{"content":"Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between <ph id=\"ph1\">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> types and XML Infoset representation.","pos":[41930,42156],"source":"Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types and XML Infoset representation."},{"content":"Serialization is used in other places in <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>, for example, <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> has a Generic <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.Message.GetBody%2A&gt;</ph> method that you can use to read the entire body of the message deserialized into an object.","pos":[42157,42472],"source":" Serialization is used in other places in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object."},{"content":"supports two serialization technologies \"out of the box\" for serializing and deserializing parameters and message parts: the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and the <ph id=\"ph2\">`XmlSerializer`</ph>.","pos":[42535,42743],"source":" supports two serialization technologies \"out of the box\" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`."},{"content":"Additionally, you can write custom serializers.","pos":[42744,42791]},{"content":"However, other parts of <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> (such as the Generic <ph id=\"ph2\">`GetBody`</ph> method or SOAP fault serialization) may be restricted to use only the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph> subclasses (<ph id=\"ph4\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>, but not the <ph id=\"ph6\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph>), or may even be hard-coded to use only the <ph id=\"ph7\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.","pos":[42792,43328],"source":" However, other parts of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>."},{"content":"The <ph id=\"ph1\">`XmlSerializer`</ph> is the serialization engine used in <ph id=\"ph2\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> Web services.","pos":[43335,43462],"source":"The `XmlSerializer` is the serialization engine used in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services."},{"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> is the new serialization engine that understands the new data contract programming model.","pos":[43463,43581],"source":" The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model."},{"content":"<ph id=\"ph1\">`DataContractSerializer`</ph> is the default choice, and the choice to use the <ph id=\"ph2\">`XmlSerializer`</ph> can be made on a per-operation basis using the <ph id=\"ph3\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A&gt;</ph> attribute.","pos":[43582,43839],"source":"`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.XmlSerializerOperationBehavior&gt;</ph> are the operation behaviors responsible for plugging in the message formatters for the <ph id=\"ph3\">`DataContractSerializer`</ph> and the <ph id=\"ph4\">`XmlSerializer`</ph>, respectively.","pos":[43846,44149],"source":"<xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph> behavior can actually operate with any serializer that derives from <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph>, including the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> (described in detail in Using Stand-Alone Serialization).","pos":[44150,44491],"source":" The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization)."},{"content":"The behavior calls one of the <ph id=\"ph1\">`CreateSerializer`</ph> virtual method overloads to obtain the serializer.","pos":[44492,44591],"source":" The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer."},{"content":"To plug in a different serializer, create a new <ph id=\"ph1\">&lt;xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior&gt;</ph> subclass and override both <ph id=\"ph2\">`CreateSerializer`</ph> overloads.","pos":[44592,44775],"source":" To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads."},{"pos":[44784,44792],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[44796,44940],"content":"<bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>","source":"[Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)"}]}