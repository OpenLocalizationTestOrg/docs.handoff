{"content":"---\ntitle: \"Data Contract Versioning\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"versioning [WCF], data contracts\"\n  - \"versioning [WCF]\"\n  - \"data contracts [WCF], versioning\"\nms.assetid: 4a0700cb-5f5f-4137-8705-3a3ecf06461f\n---\n# Data Contract Versioning\nAs applications evolve, you may also have to change the data contracts the services use. This topic explains how to version data contracts. This topic describes the data contract versioning mechanisms. For a complete overview and prescriptive versioning guidance, see [Best Practices: Data Contract Versioning](../../../../docs/framework/wcf/best-practices-data-contract-versioning.md).  \n  \n## Breaking vs. Nonbreaking Changes  \n Changes to a data contract can be breaking or nonbreaking. When a data contract is changed in a nonbreaking way, an application using the older version of the contract can communicate with an application using the newer version, and an application using the newer version of the contract can communicate with an application using the older version. On the other hand, a breaking change prevents communication in one or both directions.  \n  \n Any changes to a type that do not affect how it is transmitted and received are nonbreaking. Such changes do not change the data contract, only the underlying type. For example, you can change the name of a field in a nonbreaking way if you then set the <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to the older version name. The following code shows version 1 of a data contract.  \n  \n [!code-csharp[C_DataContractVersioning#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#1)]\n [!code-vb[C_DataContractVersioning#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#1)]  \n  \n The following code shows a nonbreaking change.  \n  \n [!code-csharp[C_DataContractVersioning#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#2)]\n [!code-vb[C_DataContractVersioning#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#2)]  \n  \n Some changes do modify the transmitted data, but may or may not be breaking. The following changes are always breaking:  \n  \n-   Changing the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> or <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> value of a data contract.  \n  \n-   Changing the order of data members by using the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute>.  \n  \n-   Renaming a data member.  \n  \n-   Changing the data contract of a data member. For example, changing the type of data member from an integer to a string, or from a type with a data contract named \"Customer\" to a type with a data contract named \"Person\".  \n  \n The following changes are also possible.  \n  \n## Adding and Removing Data Members  \n In most cases, adding or removing a data member is not a breaking change, unless you require strict schema validity (new instances validating against the old schema).  \n  \n When a type with an extra field is deserialized into a type with a missing field, the extra information is ignored. (It may also be stored for round-tripping purposes; for more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)).  \n  \n When a type with a missing field is deserialized into a type with an extra field, the extra field is left at its default value, usually zero or `null`. (The default value may be changed; for more information, see [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).)  \n  \n For example, you can use the `CarV1` class on a client and the `CarV2` class on a service, or you can use the `CarV1` class on a service and the `CarV2` class on a client.  \n  \n [!code-csharp[C_DataContractVersioning#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_datacontractversioning/cs/source.cs#3)]\n [!code-vb[C_DataContractVersioning#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractversioning/vb/source.vb#3)]  \n  \n The version 2 endpoint can successfully send data to the version 1 endpoint. Serializing version 2 of the `Car` data contract yields XML similar to the following.  \n  \n```xml  \n<Car>  \n    <Model>Porsche</Model>  \n    <HorsePower>300</HorsePower>  \n</Car>  \n```  \n  \n The deserialization engine on V1 does not find a matching data member for the `HorsePower` field, and discards that data.  \n  \n Also, the version 1 endpoint can send data to the version 2 endpoint. Serializing version 1 of the `Car` data contract yields XML similar to the following.  \n  \n```xml  \n<Car>  \n    <Model>Porsche</Model>  \n</Car>  \n```  \n  \n The version 2 deserializer does not know what to set the `HorsePower` field to, because there is no matching data in the incoming XML. Instead, the field is set to the default value of 0.  \n  \n## Required Data Members  \n A data member may be marked as being required by setting the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to `true`. If required data is missing while deserializing, an exception is thrown instead of setting the data member to its default value.  \n  \n Adding a required data member is a breaking change. That is, the newer type can still be sent to endpoints with the older type, but not the other way around. Removing a data member that was marked as required in any prior version is also a breaking change.  \n  \n Changing the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property value from `true` to `false` is not breaking, but changing it from `false` to `true` may be breaking if any prior versions of the type do not have the data member in question.  \n  \n> [!NOTE]\n>  Although the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property is set to `true`, the incoming data may be null or zero, and a type must be prepared to handle this possibility. Do not use <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> as a security mechanism to protect against bad incoming data.  \n  \n## Omitted Default Values  \n It is possible (although not recommended) to set the `EmitDefaultValue` property on the DataMemberAttribute attribute to `false`, as described in [Data Member Default Values](../../../../docs/framework/wcf/feature-details/data-member-default-values.md). If this setting is `false`, the data member will not be emitted if it is set to its default value (usually null or zero). This is not compatible with required data members in different versions in two ways:  \n  \n-   A data contract with a data member that is required in one version cannot receive default (null or zero) data from a different version in which the data member has `EmitDefaultValue` set to `false`.  \n  \n-   A required data member that has `EmitDefaultValue` set to `false` cannot be used to serialize its default (null or zero) value, but can receive such a value on deserialization. This creates a round-tripping problem (data can be read in but the same data cannot then be written out). Therefore, if `IsRequired` is `true` and `EmitDefaultValue` is `false` in one version, the same combination should apply to all other versions such that no version of the data contract would be able to produce a value that does not result in a round trip.  \n  \n## Schema Considerations  \n For an explanation of what schema is produced for data contract types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).  \n  \n The schema WCF produces for data contract types makes no provisions for versioning. That is, the schema exported from a certain version of a type contains only those data members present in that version. Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface does not change the schema for a type.  \n  \n Data members are exported to the schema as optional elements by default. That is, the `minOccurs` (XML attribute) value is set to 0. Required data members are exported with `minOccurs` set to 1.  \n  \n Many of the changes considered to be nonbreaking are actually breaking if strict adherence to the schema is required. In the preceding example, a `CarV1` instance with just the `Model` element would validate against the `CarV2` schema (which has both `Model` and `Horsepower`, but both are optional). However, the reverse is not true: a `CarV2` instance would fail validation against the `CarV1` schema.  \n  \n Round-tripping also entails some additional considerations. For more information, see the \"Schema Considerations\" section in [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).  \n  \n### Other Permitted Changes  \n Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface is a nonbreaking change. However, round-tripping support does not exist for versions of the type prior to the version in which <xref:System.Runtime.Serialization.IExtensibleDataObject> was implemented. For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).  \n  \n## Enumerations  \n Adding or removing an enumeration member is a breaking change. Changing the name of an enumeration member is breaking, unless its contract name is kept the same as in the old version by using the `EnumMemberAttribute` attribute. For more information, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).  \n  \n## Collections  \n Most collection changes are nonbreaking because most collection types are interchangeable with each other in the data contract model. However, making a noncustomized collection customized or vice versa is a breaking change. Also, changing the collection's customization settings is a breaking change; that is, changing its data contract name and namespace, repeating element name, key element name, and value element name. For more information about collection customization, see [Collection Types in Data Contracts](../../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md).  \nNaturally, changing the data contract of contents of a collection (for example, changing from a list of integers to a list of strings) is a breaking change.  \n  \n## See also\n\n- <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>\n- <xref:System.Runtime.Serialization.DataMemberAttribute>\n- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>\n- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>\n- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>\n- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>\n- <xref:System.Runtime.Serialization.SerializationException>\n- <xref:System.Runtime.Serialization.IExtensibleDataObject>\n- [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)\n- [Best Practices: Data Contract Versioning](../../../../docs/framework/wcf/best-practices-data-contract-versioning.md)\n- [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)\n- [Data Contract Equivalence](../../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)\n- [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)\n","nodes":[{"pos":[4,265],"embed":true,"restype":"x-metadata","content":"title: \"Data Contract Versioning\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"versioning [WCF], data contracts\"\n  - \"versioning [WCF]\"\n  - \"data contracts [WCF], versioning\"\nms.assetid: 4a0700cb-5f5f-4137-8705-3a3ecf06461f","nodes":[{"content":"Data Contract Versioning","nodes":[{"pos":[0,24],"content":"Data Contract Versioning","nodes":[{"content":"Data Contract Versioning","pos":[0,24]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[272,296],"content":"Data Contract Versioning","linkify":"Data Contract Versioning","nodes":[{"content":"Data Contract Versioning","pos":[0,24]}]},{"content":"As applications evolve, you may also have to change the data contracts the services use.","pos":[297,385]},{"content":"This topic explains how to version data contracts.","pos":[386,436]},{"content":"This topic describes the data contract versioning mechanisms.","pos":[437,498]},{"content":"For a complete overview and prescriptive versioning guidance, see <bpt id=\"p1\">[</bpt>Best Practices: Data Contract Versioning<ept id=\"p1\">](../../../../docs/framework/wcf/best-practices-data-contract-versioning.md)</ept>.","pos":[499,683],"source":" For a complete overview and prescriptive versioning guidance, see [Best Practices: Data Contract Versioning](../../../../docs/framework/wcf/best-practices-data-contract-versioning.md)."},{"pos":[692,724],"content":"Breaking vs. Nonbreaking Changes","linkify":"Breaking vs. Nonbreaking Changes","nodes":[{"content":"Breaking vs. Nonbreaking Changes","pos":[0,32]}]},{"content":"Changes to a data contract can be breaking or nonbreaking.","pos":[728,786]},{"content":"When a data contract is changed in a nonbreaking way, an application using the older version of the contract can communicate with an application using the newer version, and an application using the newer version of the contract can communicate with an application using the older version.","pos":[787,1076]},{"content":"On the other hand, a breaking change prevents communication in one or both directions.","pos":[1077,1163]},{"content":"Any changes to a type that do not affect how it is transmitted and received are nonbreaking.","pos":[1170,1262]},{"content":"Such changes do not change the data contract, only the underlying type.","pos":[1263,1334]},{"content":"For example, you can change the name of a field in a nonbreaking way if you then set the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> to the older version name.","pos":[1335,1586],"source":" For example, you can change the name of a field in a nonbreaking way if you then set the <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to the older version name."},{"content":"The following code shows version 1 of a data contract.","pos":[1587,1641]},{"content":"The following code shows a nonbreaking change.","pos":[1928,1974]},{"content":"Some changes do modify the transmitted data, but may or may not be breaking.","pos":[2261,2337]},{"content":"The following changes are always breaking:","pos":[2338,2380]},{"pos":[2390,2568],"content":"Changing the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Name%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A&gt;</ph> value of a data contract.","source":"Changing the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> or <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> value of a data contract."},{"pos":[2578,2763],"content":"Changing the order of data members by using the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph>.","source":"Changing the order of data members by using the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute>."},{"content":"Renaming a data member.","pos":[2773,2796]},{"content":"Changing the data contract of a data member.","pos":[2806,2850]},{"content":"For example, changing the type of data member from an integer to a string, or from a type with a data contract named \"Customer\" to a type with a data contract named \"Person\".","pos":[2851,3025]},{"content":"The following changes are also possible.","pos":[3032,3072]},{"pos":[3081,3113],"content":"Adding and Removing Data Members","linkify":"Adding and Removing Data Members","nodes":[{"content":"Adding and Removing Data Members","pos":[0,32]}]},{"content":"In most cases, adding or removing a data member is not a breaking change, unless you require strict schema validity (new instances validating against the old schema).","pos":[3117,3283]},{"content":"When a type with an extra field is deserialized into a type with a missing field, the extra information is ignored.","pos":[3290,3405]},{"content":"(It may also be stored for round-tripping purposes; for more information, see <bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>).","pos":[3406,3606],"source":" (It may also be stored for round-tripping purposes; for more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md))."},{"content":"When a type with a missing field is deserialized into a type with an extra field, the extra field is left at its default value, usually zero or <ph id=\"ph1\">`null`</ph>.","pos":[3613,3764],"source":"When a type with a missing field is deserialized into a type with an extra field, the extra field is left at its default value, usually zero or `null`."},{"content":"(The default value may be changed; for more information, see <bpt id=\"p1\">[</bpt>Version-Tolerant Serialization Callbacks<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)</ept>.)","pos":[3765,3962],"source":" (The default value may be changed; for more information, see [Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md).)"},{"pos":[3969,4140],"content":"For example, you can use the <ph id=\"ph1\">`CarV1`</ph> class on a client and the <ph id=\"ph2\">`CarV2`</ph> class on a service, or you can use the <ph id=\"ph3\">`CarV1`</ph> class on a service and the <ph id=\"ph4\">`CarV2`</ph> class on a client.","source":"For example, you can use the `CarV1` class on a client and the `CarV2` class on a service, or you can use the `CarV1` class on a service and the `CarV2` class on a client."},{"content":"The version 2 endpoint can successfully send data to the version 1 endpoint.","pos":[4427,4503]},{"content":"Serializing version 2 of the <ph id=\"ph1\">`Car`</ph> data contract yields XML similar to the following.","pos":[4504,4589],"source":" Serializing version 2 of the `Car` data contract yields XML similar to the following."},{"pos":[4695,4816],"content":"The deserialization engine on V1 does not find a matching data member for the <ph id=\"ph1\">`HorsePower`</ph> field, and discards that data.","source":"The deserialization engine on V1 does not find a matching data member for the `HorsePower` field, and discards that data."},{"content":"Also, the version 1 endpoint can send data to the version 2 endpoint.","pos":[4823,4892]},{"content":"Serializing version 1 of the <ph id=\"ph1\">`Car`</ph> data contract yields XML similar to the following.","pos":[4893,4978],"source":" Serializing version 1 of the `Car` data contract yields XML similar to the following."},{"content":"The version 2 deserializer does not know what to set the <ph id=\"ph1\">`HorsePower`</ph> field to, because there is no matching data in the incoming XML.","pos":[5049,5183],"source":"The version 2 deserializer does not know what to set the `HorsePower` field to, because there is no matching data in the incoming XML."},{"content":"Instead, the field is set to the default value of 0.","pos":[5184,5236]},{"pos":[5245,5266],"content":"Required Data Members","linkify":"Required Data Members","nodes":[{"content":"Required Data Members","pos":[0,21]}]},{"content":"A data member may be marked as being required by setting the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> to <ph id=\"ph3\">`true`</ph>.","pos":[5270,5483],"source":"A data member may be marked as being required by setting the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to `true`."},{"content":"If required data is missing while deserializing, an exception is thrown instead of setting the data member to its default value.","pos":[5484,5612]},{"content":"Adding a required data member is a breaking change.","pos":[5619,5670]},{"content":"That is, the newer type can still be sent to endpoints with the older type, but not the other way around.","pos":[5671,5776]},{"content":"Removing a data member that was marked as required in any prior version is also a breaking change.","pos":[5777,5875]},{"pos":[5882,6149],"content":"Changing the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> property value from <ph id=\"ph2\">`true`</ph> to <ph id=\"ph3\">`false`</ph> is not breaking, but changing it from <ph id=\"ph4\">`false`</ph> to <ph id=\"ph5\">`true`</ph> may be breaking if any prior versions of the type do not have the data member in question.","source":"Changing the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property value from `true` to `false` is not breaking, but changing it from `false` to `true` may be breaking if any prior versions of the type do not have the data member in question."},{"pos":[6157,6515],"content":"[!NOTE]\n Although the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property is set to `true`, the incoming data may be null or zero, and a type must be prepared to handle this possibility. Do not use <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> as a security mechanism to protect against bad incoming data.","leadings":["","> "],"nodes":[{"content":"Although the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property is set to `true`, the incoming data may be null or zero, and a type must be prepared to handle this possibility. Do not use <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> as a security mechanism to protect against bad incoming data.","pos":[9,356],"nodes":[{"content":"Although the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> property is set to <ph id=\"ph2\">`true`</ph>, the incoming data may be null or zero, and a type must be prepared to handle this possibility.","pos":[0,204],"source":"Although the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property is set to `true`, the incoming data may be null or zero, and a type must be prepared to handle this possibility."},{"content":"Do not use <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A&gt;</ph> as a security mechanism to protect against bad incoming data.","pos":[205,347],"source":" Do not use <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> as a security mechanism to protect against bad incoming data."}]}]},{"pos":[6524,6546],"content":"Omitted Default Values","linkify":"Omitted Default Values","nodes":[{"content":"Omitted Default Values","pos":[0,22]}]},{"content":"It is possible (although not recommended) to set the <ph id=\"ph1\">`EmitDefaultValue`</ph> property on the DataMemberAttribute attribute to <ph id=\"ph2\">`false`</ph>, as described in <bpt id=\"p1\">[</bpt>Data Member Default Values<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-member-default-values.md)</ept>.","pos":[6550,6803],"source":"It is possible (although not recommended) to set the `EmitDefaultValue` property on the DataMemberAttribute attribute to `false`, as described in [Data Member Default Values](../../../../docs/framework/wcf/feature-details/data-member-default-values.md)."},{"content":"If this setting is <ph id=\"ph1\">`false`</ph>, the data member will not be emitted if it is set to its default value (usually null or zero).","pos":[6804,6925],"source":" If this setting is `false`, the data member will not be emitted if it is set to its default value (usually null or zero)."},{"content":"This is not compatible with required data members in different versions in two ways:","pos":[6926,7010]},{"pos":[7020,7218],"content":"A data contract with a data member that is required in one version cannot receive default (null or zero) data from a different version in which the data member has <ph id=\"ph1\">`EmitDefaultValue`</ph> set to <ph id=\"ph2\">`false`</ph>.","source":"A data contract with a data member that is required in one version cannot receive default (null or zero) data from a different version in which the data member has `EmitDefaultValue` set to `false`."},{"content":"A required data member that has <ph id=\"ph1\">`EmitDefaultValue`</ph> set to <ph id=\"ph2\">`false`</ph> cannot be used to serialize its default (null or zero) value, but can receive such a value on deserialization.","pos":[7228,7404],"source":"A required data member that has `EmitDefaultValue` set to `false` cannot be used to serialize its default (null or zero) value, but can receive such a value on deserialization."},{"content":"This creates a round-tripping problem (data can be read in but the same data cannot then be written out).","pos":[7405,7510]},{"content":"Therefore, if <ph id=\"ph1\">`IsRequired`</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">`EmitDefaultValue`</ph> is <ph id=\"ph4\">`false`</ph> in one version, the same combination should apply to all other versions such that no version of the data contract would be able to produce a value that does not result in a round trip.","pos":[7511,7766],"source":" Therefore, if `IsRequired` is `true` and `EmitDefaultValue` is `false` in one version, the same combination should apply to all other versions such that no version of the data contract would be able to produce a value that does not result in a round trip."},{"pos":[7775,7796],"content":"Schema Considerations","linkify":"Schema Considerations","nodes":[{"content":"Schema Considerations","pos":[0,21]}]},{"pos":[7800,7990],"content":"For an explanation of what schema is produced for data contract types, see <bpt id=\"p1\">[</bpt>Data Contract Schema Reference<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.","source":"For an explanation of what schema is produced for data contract types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)."},{"content":"The schema WCF produces for data contract types makes no provisions for versioning.","pos":[7997,8080]},{"content":"That is, the schema exported from a certain version of a type contains only those data members present in that version.","pos":[8081,8200]},{"content":"Implementing the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface does not change the schema for a type.","pos":[8201,8324],"source":" Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface does not change the schema for a type."},{"content":"Data members are exported to the schema as optional elements by default.","pos":[8331,8403]},{"content":"That is, the <ph id=\"ph1\">`minOccurs`</ph> (XML attribute) value is set to 0.","pos":[8404,8463],"source":" That is, the `minOccurs` (XML attribute) value is set to 0."},{"content":"Required data members are exported with <ph id=\"ph1\">`minOccurs`</ph> set to 1.","pos":[8464,8525],"source":" Required data members are exported with `minOccurs` set to 1."},{"content":"Many of the changes considered to be nonbreaking are actually breaking if strict adherence to the schema is required.","pos":[8532,8649]},{"content":"In the preceding example, a <ph id=\"ph1\">`CarV1`</ph> instance with just the <ph id=\"ph2\">`Model`</ph> element would validate against the <ph id=\"ph3\">`CarV2`</ph> schema (which has both <ph id=\"ph4\">`Model`</ph> and <ph id=\"ph5\">`Horsepower`</ph>, but both are optional).","pos":[8650,8832],"source":" In the preceding example, a `CarV1` instance with just the `Model` element would validate against the `CarV2` schema (which has both `Model` and `Horsepower`, but both are optional)."},{"content":"However, the reverse is not true: a <ph id=\"ph1\">`CarV2`</ph> instance would fail validation against the <ph id=\"ph2\">`CarV1`</ph> schema.","pos":[8833,8935],"source":" However, the reverse is not true: a `CarV2` instance would fail validation against the `CarV1` schema."},{"content":"Round-tripping also entails some additional considerations.","pos":[8942,9001]},{"content":"For more information, see the \"Schema Considerations\" section in <bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>.","pos":[9002,9188],"source":" For more information, see the \"Schema Considerations\" section in [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)."},{"pos":[9198,9221],"content":"Other Permitted Changes","linkify":"Other Permitted Changes","nodes":[{"content":"Other Permitted Changes","pos":[0,23]}]},{"content":"Implementing the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface is a nonbreaking change.","pos":[9225,9334],"source":"Implementing the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface is a nonbreaking change."},{"content":"However, round-tripping support does not exist for versions of the type prior to the version in which <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> was implemented.","pos":[9335,9511],"source":" However, round-tripping support does not exist for versions of the type prior to the version in which <xref:System.Runtime.Serialization.IExtensibleDataObject> was implemented."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>.","pos":[9512,9659],"source":" For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)."},{"pos":[9668,9680],"content":"Enumerations","linkify":"Enumerations","nodes":[{"content":"Enumerations","pos":[0,12]}]},{"content":"Adding or removing an enumeration member is a breaking change.","pos":[9684,9746]},{"content":"Changing the name of an enumeration member is breaking, unless its contract name is kept the same as in the old version by using the <ph id=\"ph1\">`EnumMemberAttribute`</ph> attribute.","pos":[9747,9912],"source":" Changing the name of an enumeration member is breaking, unless its contract name is kept the same as in the old version by using the `EnumMemberAttribute` attribute."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Enumeration Types in Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)</ept>.","pos":[9913,10064],"source":" For more information, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)."},{"pos":[10073,10084],"content":"Collections","linkify":"Collections","nodes":[{"content":"Collections","pos":[0,11]}]},{"content":"Most collection changes are nonbreaking because most collection types are interchangeable with each other in the data contract model.","pos":[10088,10221]},{"content":"However, making a noncustomized collection customized or vice versa is a breaking change.","pos":[10222,10311]},{"content":"Also, changing the collection's customization settings is a breaking change; that is, changing its data contract name and namespace, repeating element name, key element name, and value element name.","pos":[10312,10510]},{"content":"For more information about collection customization, see <bpt id=\"p1\">[</bpt>Collection Types in Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md)</ept>.","pos":[10511,10691],"source":" For more information about collection customization, see [Collection Types in Data Contracts](../../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md)."},{"content":"Naturally, changing the data contract of contents of a collection (for example, changing from a list of integers to a list of strings) is a breaking change.","pos":[10694,10850]},{"pos":[10859,10867],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11396,11530],"content":"<bpt id=\"p1\">[</bpt>Version-Tolerant Serialization Callbacks<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)</ept>","source":"[Version-Tolerant Serialization Callbacks](../../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)"},{"pos":[11533,11650],"content":"<bpt id=\"p1\">[</bpt>Best Practices: Data Contract Versioning<ept id=\"p1\">](../../../../docs/framework/wcf/best-practices-data-contract-versioning.md)</ept>","source":"[Best Practices: Data Contract Versioning](../../../../docs/framework/wcf/best-practices-data-contract-versioning.md)"},{"pos":[11653,11747],"content":"<bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>","source":"[Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)"},{"pos":[11750,11854],"content":"<bpt id=\"p1\">[</bpt>Data Contract Equivalence<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)</ept>","source":"[Data Contract Equivalence](../../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)"},{"pos":[11857,11977],"content":"<bpt id=\"p1\">[</bpt>Forward-Compatible Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept>","source":"[Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)"}]}