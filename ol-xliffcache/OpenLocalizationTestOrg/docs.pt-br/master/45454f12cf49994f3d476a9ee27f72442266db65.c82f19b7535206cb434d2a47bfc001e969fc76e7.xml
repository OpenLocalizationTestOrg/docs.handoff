{"content":"---\ntitle: \"Creating Variant Generic Interfaces (Visual Basic)\"\nms.date: 07/20/2015\nms.assetid: d4037dd2-dfe9-4811-9150-93d4e8b20113\n---\n\n# Creating Variant Generic Interfaces (Visual Basic)\n\nYou can declare generic type parameters in interfaces as covariant or contravariant. *Covariance* allows interface methods to have more derived return types than that defined by the generic type parameters. *Contravariance* allows interface methods to have argument types that are less derived than that specified by the generic parameters. A generic interface that has covariant or contravariant generic type parameters is called *variant*.\n\n> [!NOTE]\n> .NET Framework 4 introduced variance support for several existing generic interfaces. For the list of the variant interfaces in the .NET Framework, see [Variance in Generic Interfaces (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).\n\n## Declaring Variant Generic Interfaces\n\nYou can declare variant generic interfaces by using the `in` and `out` keywords for generic type parameters.\n\n> [!IMPORTANT]\n> `ByRef` parameters in Visual Basic cannot be variant. Value types also do not support variance.\n\nYou can declare a generic type parameter covariant by using the `out` keyword. The covariant type must satisfy the following conditions:\n\n- The type is used only as a return type of interface methods and not used as a type of method arguments. This is illustrated in the following example, in which the type `R` is declared covariant.\n\n    ```vb\n    Interface ICovariant(Of Out R)\n        Function GetSomething() As R\n        ' The following statement generates a compiler error.\n        ' Sub SetSomething(ByVal sampleArg As R)\n    End Interface\n    ```\n\n    There is one exception to this rule. If you have a contravariant generic delegate as a method parameter, you can use the type as a generic type parameter for the delegate. This is illustrated by the type `R` in the following example. For more information, see [Variance in Delegates (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Using Variance for Func and Action Generic Delegates (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md).\n\n    ```vb\n    Interface ICovariant(Of Out R)\n        Sub DoSomething(ByVal callback As Action(Of R))\n    End Interface\n    ```\n\n- The type is not used as a generic constraint for the interface methods. This is illustrated in the following code.\n\n    ```vb\n    Interface ICovariant(Of Out R)\n        ' The following statement generates a compiler error\n        ' because you can use only contravariant or invariant types\n        ' in generic constraints.\n        ' Sub DoSomething(Of T As R)()\n    End Interface\n    ```\n\nYou can declare a generic type parameter contravariant by using the `in` keyword. The contravariant type can be used only as a type of method arguments and not as a return type of interface methods. The contravariant type can also be used for generic constraints. The following code shows how to declare a contravariant interface and use a generic constraint for one of its methods.\n\n```vb\nInterface IContravariant(Of In A)\n    Sub SetSomething(ByVal sampleArg As A)\n    Sub DoSomething(Of T As A)()\n    ' The following statement generates a compiler error.\n    ' Function GetSomething() As A\nEnd Interface\n```\n\nIt is also possible to support both covariance and contravariance in the same interface, but for different type parameters, as shown in the following code example.\n\n```vb\nInterface IVariant(Of Out R, In A)\n    Function GetSomething() As R\n    Sub SetSomething(ByVal sampleArg As A)\n    Function GetSetSomething(ByVal sampleArg As A) As R\nEnd Interface\n```\n\nIn Visual Basic, you can't declare events in variant interfaces without specifying the delegate type. Also, a variant interface can't have nested classes, enums, or structures, but it can have nested interfaces. This is illustrated in the following code.\n\n```vb\nInterface ICovariant(Of Out R)\n    ' The following statement generates a compiler error.\n    ' Event SampleEvent()\n    ' The following statement specifies the delegate type and\n    ' does not generate an error.\n    Event AnotherEvent As EventHandler\n\n    ' The following statements generate compiler errors,\n    ' because a variant interface cannot have\n    ' nested enums, classes, or structures.\n\n    'Enum SampleEnum : test : End Enum\n    'Class SampleClass : End Class\n    'Structure SampleStructure : Dim value As Integer : End Structure\n\n    ' Variant interfaces can have nested interfaces.\n    Interface INested : End Interface\nEnd Interface\n```\n\n## Implementing Variant Generic Interfaces\n\nYou implement variant generic interfaces in classes by using the same syntax that is used for invariant interfaces. The following code example shows how to implement a covariant interface in a generic class.\n\n```vb\nInterface ICovariant(Of Out R)\n    Function GetSomething() As R\nEnd Interface\n\nClass SampleImplementation(Of R)\n    Implements ICovariant(Of R)\n    Public Function GetSomething() As R _\n    Implements ICovariant(Of R).GetSomething\n        ' Some code.\n    End Function\nEnd Class\n```\n\nClasses that implement variant interfaces are invariant. For example, consider the following code.\n\n```vb\n The interface is covariant.\nDim ibutton As ICovariant(Of Button) =\n    New SampleImplementation(Of Button)\nDim iobj As ICovariant(Of Object) = ibutton\n\n' The class is invariant.\nDim button As SampleImplementation(Of Button) =\n    New SampleImplementation(Of Button)\n' The following statement generates a compiler error\n' because classes are invariant.\n' Dim obj As SampleImplementation(Of Object) = button\n```\n\n## Extending Variant Generic Interfaces\n\nWhen you extend a variant generic interface, you have to use the `in` and `out` keywords to explicitly specify whether the derived interface supports variance. The compiler does not infer the variance from the interface that is being extended. For example, consider the following interfaces.\n\n```vb\nInterface ICovariant(Of Out T)\nEnd Interface\n\nInterface IInvariant(Of T)\n    Inherits ICovariant(Of T)\nEnd Interface\n\nInterface IExtCovariant(Of Out T)\n    Inherits ICovariant(Of T)\nEnd Interface\n```\n\nIn the `Invariant(Of T)` interface, the generic type parameter `T` is invariant, whereas in `IExtCovariant (Of Out T)`the type parameter is covariant, although both interfaces extend the same interface. The same rule is applied to contravariant generic type parameters.\n\nYou can create an interface that extends both the interface where the generic type parameter `T` is covariant and the interface where it is contravariant if in the extending interface the generic type parameter `T` is invariant. This is illustrated in the following code example.\n\n```vb\nInterface ICovariant(Of Out T)\nEnd Interface\n\nInterface IContravariant(Of In T)\nEnd Interface\n\nInterface IInvariant(Of T)\n    Inherits ICovariant(Of T), IContravariant(Of T)\nEnd Interface\n```\n\nHowever, if a generic type parameter `T` is declared covariant in one interface, you cannot declare it contravariant in the extending interface, or vice versa. This is illustrated in the following code example.\n\n```vb\nInterface ICovariant(Of Out T)\nEnd Interface\n\n' The following statements generate a compiler error.\n' Interface ICoContraVariant(Of In T)\n'     Inherits ICovariant(Of T)\n' End Interface\n```\n\n### Avoiding Ambiguity\n\nWhen you implement variant generic interfaces, variance can sometimes lead to ambiguity. This should be avoided.\n\nFor example, if you explicitly implement the same variant generic interface with different generic type parameters in one class, it can create ambiguity. The compiler does not produce an error in this case, but it is not specified which interface implementation will be chosen at runtime. This could lead to subtle bugs in your code. Consider the following code example.\n\n> [!NOTE]\n> With `Option Strict Off`, Visual Basic generates a compiler warning when there is an ambiguous interface implementation. With `Option Strict On`, Visual Basic generates a compiler error.\n\n```vb\n' Simple class hierarchy.\nClass Animal\nEnd Class\n\nClass Cat\n    Inherits Animal\nEnd Class\n\nClass Dog\n    Inherits Animal\nEnd Class\n\n' This class introduces ambiguity\n' because IEnumerable(Of Out T) is covariant.\nClass Pets\n    Implements IEnumerable(Of Cat), IEnumerable(Of Dog)\n\n    Public Function GetEnumerator() As IEnumerator(Of Cat) _\n        Implements IEnumerable(Of Cat).GetEnumerator\n        Console.WriteLine(\"Cat\")\n        ' Some code.\n    End Function\n\n    Public Function GetEnumerator1() As IEnumerator(Of Dog) _\n        Implements IEnumerable(Of Dog).GetEnumerator\n        Console.WriteLine(\"Dog\")\n        ' Some code.\n    End Function\n\n    Public Function GetEnumerator2() As IEnumerator _\n        Implements IEnumerable.GetEnumerator\n        ' Some code.\n    End Function\nEnd Class\n\nSub Main()\n    Dim pets As IEnumerable(Of Animal) = New Pets()\n    pets.GetEnumerator()\nEnd Sub\n```\n\nIn this example, it is unspecified how the `pets.GetEnumerator` method chooses between `Cat` and `Dog`. This could cause problems in your code.\n\n## See also\n\n- [Variance in Generic Interfaces (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)\n- [Using Variance for Func and Action Generic Delegates (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)\n","nodes":[{"pos":[4,132],"embed":true,"restype":"x-metadata","content":"title: \"Creating Variant Generic Interfaces (Visual Basic)\"\nms.date: 07/20/2015\nms.assetid: d4037dd2-dfe9-4811-9150-93d4e8b20113","nodes":[{"content":"Creating Variant Generic Interfaces (Visual Basic)","nodes":[{"pos":[0,50],"content":"Creating Variant Generic Interfaces (Visual Basic)","nodes":[{"content":"Creating Variant Generic Interfaces (Visual Basic)","pos":[0,50]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[140,190],"content":"Creating Variant Generic Interfaces (Visual Basic)","linkify":"Creating Variant Generic Interfaces (Visual Basic)","nodes":[{"content":"Creating Variant Generic Interfaces (Visual Basic)","pos":[0,50]}]},{"content":"You can declare generic type parameters in interfaces as covariant or contravariant.","pos":[192,276]},{"content":"<bpt id=\"p1\">*</bpt>Covariance<ept id=\"p1\">*</ept> allows interface methods to have more derived return types than that defined by the generic type parameters.","pos":[277,398],"source":"*Covariance* allows interface methods to have more derived return types than that defined by the generic type parameters."},{"content":"<bpt id=\"p1\">*</bpt>Contravariance<ept id=\"p1\">*</ept> allows interface methods to have argument types that are less derived than that specified by the generic parameters.","pos":[399,532],"source":"*Contravariance* allows interface methods to have argument types that are less derived than that specified by the generic parameters."},{"content":"A generic interface that has covariant or contravariant generic type parameters is called <bpt id=\"p1\">*</bpt>variant<ept id=\"p1\">*</ept>.","pos":[533,633],"source":" A generic interface that has covariant or contravariant generic type parameters is called *variant*."},{"pos":[637,960],"content":"[!NOTE]\n.NET Framework 4 introduced variance support for several existing generic interfaces. For the list of the variant interfaces in the .NET Framework, see [Variance in Generic Interfaces (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).","leadings":["","> "],"nodes":[{"content":".NET Framework 4 introduced variance support for several existing generic interfaces. For the list of the variant interfaces in the .NET Framework, see [Variance in Generic Interfaces (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).","pos":[8,321],"nodes":[{"content":".NET Framework 4 introduced variance support for several existing generic interfaces.","pos":[0,85]},{"content":"For the list of the variant interfaces in the .NET Framework, see <bpt id=\"p1\">[</bpt>Variance in Generic Interfaces (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)</ept>.","pos":[86,313],"source":" For the list of the variant interfaces in the .NET Framework, see [Variance in Generic Interfaces (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)."}]}]},{"pos":[965,1001],"content":"Declaring Variant Generic Interfaces","linkify":"Declaring Variant Generic Interfaces","nodes":[{"content":"Declaring Variant Generic Interfaces","pos":[0,36]}]},{"pos":[1003,1111],"content":"You can declare variant generic interfaces by using the <ph id=\"ph1\">`in`</ph> and <ph id=\"ph2\">`out`</ph> keywords for generic type parameters.","source":"You can declare variant generic interfaces by using the `in` and `out` keywords for generic type parameters."},{"pos":[1115,1225],"content":"[!IMPORTANT]\n`ByRef` parameters in Visual Basic cannot be variant. Value types also do not support variance.","leadings":["","> "],"nodes":[{"content":"`ByRef` parameters in Visual Basic cannot be variant. Value types also do not support variance.","pos":[13,108],"nodes":[{"content":"<ph id=\"ph1\">`ByRef`</ph> parameters in Visual Basic cannot be variant.","pos":[0,53],"source":"`ByRef` parameters in Visual Basic cannot be variant."},{"content":"Value types also do not support variance.","pos":[54,95]}]}]},{"content":"You can declare a generic type parameter covariant by using the <ph id=\"ph1\">`out`</ph> keyword.","pos":[1227,1305],"source":"You can declare a generic type parameter covariant by using the `out` keyword."},{"content":"The covariant type must satisfy the following conditions:","pos":[1306,1363]},{"content":"The type is used only as a return type of interface methods and not used as a type of method arguments.","pos":[1367,1470]},{"content":"This is illustrated in the following example, in which the type <ph id=\"ph1\">`R`</ph> is declared covariant.","pos":[1471,1561],"source":" This is illustrated in the following example, in which the type `R` is declared covariant."},{"content":"There is one exception to this rule.","pos":[1787,1823]},{"content":"If you have a contravariant generic delegate as a method parameter, you can use the type as a generic type parameter for the delegate.","pos":[1824,1958]},{"content":"This is illustrated by the type <ph id=\"ph1\">`R`</ph> in the following example.","pos":[1959,2020],"source":" This is illustrated by the type `R` in the following example."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Variance in Delegates (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)</ept> and <bpt id=\"p2\">[</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id=\"p2\">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>.","pos":[2021,2399],"source":" For more information, see [Variance in Delegates (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Using Variance for Func and Action Generic Delegates (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)."},{"content":"The type is not used as a generic constraint for the interface methods.","pos":[2531,2602]},{"content":"This is illustrated in the following code.","pos":[2603,2645]},{"content":"You can declare a generic type parameter contravariant by using the <ph id=\"ph1\">`in`</ph> keyword.","pos":[2921,3002],"source":"You can declare a generic type parameter contravariant by using the `in` keyword."},{"content":"The contravariant type can be used only as a type of method arguments and not as a return type of interface methods.","pos":[3003,3119]},{"content":"The contravariant type can also be used for generic constraints.","pos":[3120,3184]},{"content":"The following code shows how to declare a contravariant interface and use a generic constraint for one of its methods.","pos":[3185,3303]},{"content":"It is also possible to support both covariance and contravariance in the same interface, but for different type parameters, as shown in the following code example.","pos":[3533,3696]},{"content":"In Visual Basic, you can't declare events in variant interfaces without specifying the delegate type.","pos":[3890,3991]},{"content":"Also, a variant interface can't have nested classes, enums, or structures, but it can have nested interfaces.","pos":[3992,4101]},{"content":"This is illustrated in the following code.","pos":[4102,4144]},{"pos":[4809,4848],"content":"Implementing Variant Generic Interfaces","linkify":"Implementing Variant Generic Interfaces","nodes":[{"content":"Implementing Variant Generic Interfaces","pos":[0,39]}]},{"content":"You implement variant generic interfaces in classes by using the same syntax that is used for invariant interfaces.","pos":[4850,4965]},{"content":"The following code example shows how to implement a covariant interface in a generic class.","pos":[4966,5057]},{"content":"Classes that implement variant interfaces are invariant.","pos":[5349,5405]},{"content":"For example, consider the following code.","pos":[5406,5447]},{"pos":[5870,5906],"content":"Extending Variant Generic Interfaces","linkify":"Extending Variant Generic Interfaces","nodes":[{"content":"Extending Variant Generic Interfaces","pos":[0,36]}]},{"content":"When you extend a variant generic interface, you have to use the <ph id=\"ph1\">`in`</ph> and <ph id=\"ph2\">`out`</ph> keywords to explicitly specify whether the derived interface supports variance.","pos":[5908,6067],"source":"When you extend a variant generic interface, you have to use the `in` and `out` keywords to explicitly specify whether the derived interface supports variance."},{"content":"The compiler does not infer the variance from the interface that is being extended.","pos":[6068,6151]},{"content":"For example, consider the following interfaces.","pos":[6152,6199]},{"content":"In the <ph id=\"ph1\">`Invariant(Of T)`</ph> interface, the generic type parameter <ph id=\"ph2\">`T`</ph> is invariant, whereas in <ph id=\"ph3\">`IExtCovariant (Of Out T)`</ph>the type parameter is covariant, although both interfaces extend the same interface.","pos":[6408,6610],"source":"In the `Invariant(Of T)` interface, the generic type parameter `T` is invariant, whereas in `IExtCovariant (Of Out T)`the type parameter is covariant, although both interfaces extend the same interface."},{"content":"The same rule is applied to contravariant generic type parameters.","pos":[6611,6677]},{"content":"You can create an interface that extends both the interface where the generic type parameter <ph id=\"ph1\">`T`</ph> is covariant and the interface where it is contravariant if in the extending interface the generic type parameter <ph id=\"ph2\">`T`</ph> is invariant.","pos":[6679,6907],"source":"You can create an interface that extends both the interface where the generic type parameter `T` is covariant and the interface where it is contravariant if in the extending interface the generic type parameter `T` is invariant."},{"content":"This is illustrated in the following code example.","pos":[6908,6958]},{"content":"However, if a generic type parameter <ph id=\"ph1\">`T`</ph> is declared covariant in one interface, you cannot declare it contravariant in the extending interface, or vice versa.","pos":[7159,7318],"source":"However, if a generic type parameter `T` is declared covariant in one interface, you cannot declare it contravariant in the extending interface, or vice versa."},{"content":"This is illustrated in the following code example.","pos":[7319,7369]},{"pos":[7572,7590],"content":"Avoiding Ambiguity","linkify":"Avoiding Ambiguity","nodes":[{"content":"Avoiding Ambiguity","pos":[0,18]}]},{"content":"When you implement variant generic interfaces, variance can sometimes lead to ambiguity.","pos":[7592,7680]},{"content":"This should be avoided.","pos":[7681,7704]},{"content":"For example, if you explicitly implement the same variant generic interface with different generic type parameters in one class, it can create ambiguity.","pos":[7706,7859]},{"content":"The compiler does not produce an error in this case, but it is not specified which interface implementation will be chosen at runtime.","pos":[7860,7994]},{"content":"This could lead to subtle bugs in your code.","pos":[7995,8039]},{"content":"Consider the following code example.","pos":[8040,8076]},{"pos":[8080,8276],"content":"[!NOTE]\nWith `Option Strict Off`, Visual Basic generates a compiler warning when there is an ambiguous interface implementation. With `Option Strict On`, Visual Basic generates a compiler error.","leadings":["","> "],"nodes":[{"content":"With `Option Strict Off`, Visual Basic generates a compiler warning when there is an ambiguous interface implementation. With `Option Strict On`, Visual Basic generates a compiler error.","pos":[8,194],"nodes":[{"content":"With <ph id=\"ph1\">`Option Strict Off`</ph>, Visual Basic generates a compiler warning when there is an ambiguous interface implementation.","pos":[0,120],"source":"With `Option Strict Off`, Visual Basic generates a compiler warning when there is an ambiguous interface implementation."},{"content":"With <ph id=\"ph1\">`Option Strict On`</ph>, Visual Basic generates a compiler error.","pos":[121,186],"source":" With `Option Strict On`, Visual Basic generates a compiler error."}]}]},{"content":"In this example, it is unspecified how the <ph id=\"ph1\">`pets.GetEnumerator`</ph> method chooses between <ph id=\"ph2\">`Cat`</ph> and <ph id=\"ph3\">`Dog`</ph>.","pos":[9186,9289],"source":"In this example, it is unspecified how the `pets.GetEnumerator` method chooses between `Cat` and `Dog`."},{"content":"This could cause problems in your code.","pos":[9290,9329]},{"pos":[9334,9342],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9346,9506],"content":"<bpt id=\"p1\">[</bpt>Variance in Generic Interfaces (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)</ept>","source":"[Variance in Generic Interfaces (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md)"},{"pos":[9509,9713],"content":"<bpt id=\"p1\">[</bpt>Using Variance for Func and Action Generic Delegates (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)</ept>","source":"[Using Variance for Func and Action Generic Delegates (Visual Basic)](../../../../visual-basic/programming-guide/concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)"}]}