{"content":"---\ntitle: \"Thread Synchronization (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e\ncaps.latest.revision: 3\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.mt: \n  - \"cs-cz\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"tr-tr\"\n---\n# Thread Synchronization (Visual Basic)\nThe following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.  \n  \n One of the benefits of using multiple threads in an application is that each thread executes asynchronously. For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive. For server applications, multithreading provides the ability to handle each incoming request with a different thread. Otherwise, each new request would not get serviced until the previous request had been fully satisfied.  \n  \n However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated. Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions. The result is unpredictable data corruption.  \n  \n For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class. For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.  \n  \n For background information on multithreaded programming, see:  \n  \n-   [Managed Threading Basics](../../../../standard/threading/managed-threading-basics.md)  \n  \n-   [Using Threads and Threading](../../../../standard/threading/using-threads-and-threading.md)  \n  \n-   [Managed Threading Best Practices](../../../../standard/threading/managed-threading-best-practices.md)  \n  \n## The lock and SyncLock Keywords  \n The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads. This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.  \n  \n A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time. For example:  \n  \n```vb  \nPublic Class TestThreading  \n    Dim lockThis As New Object  \n  \n    Public Sub Process()  \n        SyncLock lockThis  \n            ' Access thread-sensitive resources.  \n        End SyncLock  \n    End Sub  \nEnd Class  \n```  \n  \n The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock. In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function. If such a reference did exist, lock scope would extend to that object. Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance. In practice, however, this object usually represents the resource for which thread synchronization is necessary. For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container. As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.  \n  \n Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application. For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well. This could create deadlock situations where two or more threads wait for the release of the same object. Locking on a public data type, as opposed to an object, can cause problems for the same reason. Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR). This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads. As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application. As a result, it is best to lock a private or protected member that is not interned. Some classes provide members specifically for locking. The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>. Many collection types provide a `SyncRoot` member as well.  \n  \n For more information about the `SyncLock` statement, see the following topics:  \n  \n-   [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md)  \n  \n-   @System.Threading.Monitor  \n  \n## Monitors  \n Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads. The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>. This is just like using the `SyncLock` keyword. For example:  \n  \n```vb  \nSyncLock x  \n    DoSomething()  \nEnd SyncLock  \n```  \n  \n This is equivalent to:  \n  \n```vb  \nDim obj As Object = CType(x, Object)  \nSystem.Threading.Monitor.Enter(obj)  \nTry  \n    DoSomething()  \nFinally  \n    System.Threading.Monitor.Exit(obj)  \nEnd Try  \n```  \n  \n Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception. This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.  \n  \n## Synchronization Events and Wait Handles  \n Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another. This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads. Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled. If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.  \n  \n There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>. They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread. Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.  \n  \n Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled. An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.  \n  \n In the following example, a thread is created and started by the `Main` function. The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function. Once the event becomes signaled, the auxiliary thread returns. In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.  \n  \n```vb  \nImports System.Threading  \n  \nModule Module1  \n    Dim autoEvent As AutoResetEvent  \n  \n    Sub DoWork()  \n        Console.WriteLine(\"   worker thread started, now waiting on event...\")  \n        autoEvent.WaitOne()  \n        Console.WriteLine(\"   worker thread reactivated, now exiting...\")  \n    End Sub  \n  \n    Sub Main()  \n        autoEvent = New AutoResetEvent(False)  \n  \n        Console.WriteLine(\"main thread starting worker thread...\")  \n        Dim t As New Thread(AddressOf DoWork)  \n        t.Start()  \n  \n        Console.WriteLine(\"main thread sleeping for 1 second...\")  \n        Thread.Sleep(1000)  \n  \n        Console.WriteLine(\"main thread signaling worker thread...\")  \n        autoEvent.Set()  \n    End Sub  \nEnd Module  \n```  \n  \n## Mutex Object  \n A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time. In fact, the name \"mutex\" is a shortened form of the term \"mutually exclusive.\" Unlike monitors, however, a mutex can be used to synchronize threads across processes. A mutex is represented by the <xref:System.Threading.Mutex> class.  \n  \n When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable. It must be given a name so that both applications can access the same mutex object.  \n  \n Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources. In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct. While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class. For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md).  \n  \n## Interlocked Class  \n You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value. The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.  \n  \n## ReaderWriter Locks  \n In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated. The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource. ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.  \n  \n## Deadlocks  \n Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt. A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go. Avoiding deadlocks is important; the key is careful planning. You can often predict deadlock situations by diagramming multithreaded applications before you start coding.  \n  \n## See Also  \n <xref:System.Threading.Thread>   \n <xref:System.Threading.WaitHandle.WaitOne%2A>   \n <xref:System.Threading.WaitHandle.WaitAny%2A>   \n <xref:System.Threading.WaitHandle.WaitAll%2A>   \n <xref:System.Threading.Thread.Join%2A>   \n <xref:System.Threading.Thread.Start%2A>   \n <xref:System.Threading.Thread.Sleep%2A>   \n <xref:System.Threading.Monitor>   \n <xref:System.Threading.Mutex>   \n <xref:System.Threading.AutoResetEvent>   \n <xref:System.Threading.ManualResetEvent>   \n <xref:System.Threading.Interlocked>   \n <xref:System.Threading.WaitHandle>   \n <xref:System.Threading.EventWaitHandle>   \n <xref:System.Threading>   \n <xref:System.Threading.EventWaitHandle.Set%2A>   \n [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md)   \n [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md)   \n [Mutexes](../../../../standard/threading/mutexes.md)   \n @System.Threading.Monitor   \n [Interlocked Operations](../../../../standard/threading/interlocked-operations.md)   \n [AutoResetEvent](../../../../standard/threading/autoresetevent.md)   \n [Synchronizing Data for Multithreading](../../../../standard/threading/synchronizing-data-for-multithreading.md)","nodes":[{"pos":[12,66],"content":"Thread Synchronization (Visual Basic) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Thread Synchronization (Visual Basic) | Microsoft Docs","pos":[0,54]}]},{"pos":[447,484],"content":"Thread Synchronization (Visual Basic)","linkify":"Thread Synchronization (Visual Basic)","nodes":[{"content":"Thread Synchronization (Visual Basic)","pos":[0,37]}]},{"content":"The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.","pos":[485,620]},{"content":"One of the benefits of using multiple threads in an application is that each thread executes asynchronously.","pos":[627,735]},{"content":"For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.","pos":[736,889]},{"content":"For server applications, multithreading provides the ability to handle each incoming request with a different thread.","pos":[890,1007]},{"content":"Otherwise, each new request would not get serviced until the previous request had been fully satisfied.","pos":[1008,1111]},{"content":"However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.","pos":[1118,1267]},{"content":"Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.","pos":[1268,1384]},{"content":"The result is unpredictable data corruption.","pos":[1385,1429]},{"content":"For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class.","pos":[1436,1594],"source":"For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class."},{"content":"For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.","pos":[1595,1730]},{"content":"For background information on multithreaded programming, see:","pos":[1737,1798]},{"pos":[1808,1894],"content":"<bpt id=\"p1\">[</bpt>Managed Threading Basics<ept id=\"p1\">](../../../../standard/threading/managed-threading-basics.md)</ept>","source":"[Managed Threading Basics](../../../../standard/threading/managed-threading-basics.md)"},{"pos":[1904,1996],"content":"<bpt id=\"p1\">[</bpt>Using Threads and Threading<ept id=\"p1\">](../../../../standard/threading/using-threads-and-threading.md)</ept>","source":"[Using Threads and Threading](../../../../standard/threading/using-threads-and-threading.md)"},{"pos":[2006,2108],"content":"<bpt id=\"p1\">[</bpt>Managed Threading Best Practices<ept id=\"p1\">](../../../../standard/threading/managed-threading-best-practices.md)</ept>","source":"[Managed Threading Best Practices](../../../../standard/threading/managed-threading-best-practices.md)"},{"pos":[2117,2147],"content":"The lock and SyncLock Keywords","linkify":"The lock and SyncLock Keywords","nodes":[{"content":"The lock and SyncLock Keywords","pos":[0,30]}]},{"content":"The Visual Basic <ph id=\"ph1\">`SyncLock`</ph> statement can be used to ensure that a block of code runs to completion without interruption by other threads.","pos":[2151,2289],"source":"The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads."},{"content":"This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.","pos":[2290,2402]},{"content":"A <ph id=\"ph1\">`SyncLock`</ph> statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.","pos":[2409,2551],"source":"A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time."},{"content":"For example:","pos":[2552,2564]},{"content":"The argument provided to the <ph id=\"ph1\">`SyncLock`</ph> keyword must be an object based on a reference type, and is used to define the scope of the lock.","pos":[2808,2945],"source":"The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock."},{"content":"In the example above, the lock scope is limited to this function because no references to the object <ph id=\"ph1\">`lockThis`</ph> exist outside the function.","pos":[2946,3085],"source":" In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function."},{"content":"If such a reference did exist, lock scope would extend to that object.","pos":[3086,3156]},{"content":"Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.","pos":[3157,3323]},{"content":"In practice, however, this object usually represents the resource for which thread synchronization is necessary.","pos":[3324,3436]},{"content":"For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.","pos":[3437,3627]},{"content":"As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.","pos":[3628,3749]},{"content":"Generally, it is best to avoid locking on a <ph id=\"ph1\">`public`</ph> type, or on object instances beyond the control of your application.","pos":[3756,3877],"source":"Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application."},{"content":"For example, <ph id=\"ph1\">`lockThis`</ph> can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.","pos":[3878,4027],"source":" For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well."},{"content":"This could create deadlock situations where two or more threads wait for the release of the same object.","pos":[4028,4132]},{"content":"Locking on a public data type, as opposed to an object, can cause problems for the same reason.","pos":[4133,4228]},{"content":"Locking on literal strings is especially risky because literal strings are <bpt id=\"p1\">*</bpt>interned<ept id=\"p1\">*</ept> by the common language runtime (CLR).","pos":[4229,4352],"source":" Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR)."},{"content":"This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.","pos":[4353,4539]},{"content":"As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.","pos":[4540,4692]},{"content":"As a result, it is best to lock a private or protected member that is not interned.","pos":[4693,4776]},{"content":"Some classes provide members specifically for locking.","pos":[4777,4831]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> type, for example, provides <ph id=\"ph2\">&lt;xref:System.Array.SyncRoot%2A&gt;</ph>.","pos":[4832,4916],"source":" The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>."},{"content":"Many collection types provide a <ph id=\"ph1\">`SyncRoot`</ph> member as well.","pos":[4917,4975],"source":" Many collection types provide a `SyncRoot` member as well."},{"pos":[4982,5060],"content":"For more information about the <ph id=\"ph1\">`SyncLock`</ph> statement, see the following topics:","source":"For more information about the `SyncLock` statement, see the following topics:"},{"pos":[5070,5168],"content":"<bpt id=\"p1\">[</bpt>SyncLock Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept>","source":"[SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md)"},{"pos":[5212,5220],"content":"Monitors","linkify":"Monitors","nodes":[{"content":"Monitors","pos":[0,8]}]},{"content":"Like the <ph id=\"ph1\">`SyncLock`</ph> keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.","pos":[5224,5333],"source":"Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>.","pos":[5334,5562],"source":" The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>."},{"content":"This is just like using the <ph id=\"ph1\">`SyncLock`</ph> keyword.","pos":[5563,5610],"source":" This is just like using the `SyncLock` keyword."},{"content":"For example:","pos":[5611,5623]},{"content":"This is equivalent to:","pos":[5695,5717]},{"content":"Using the <ph id=\"ph1\">`SyncLock`</ph> keyword is generally preferred over using the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph> class directly, both because <ph id=\"ph3\">`SyncLock`</ph> is more concise, and because <ph id=\"ph4\">`SyncLock`</ph> insures that the underlying monitor is released, even if the protected code throws an exception.","pos":[5905,6180],"source":"Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception."},{"content":"This is accomplished with the <ph id=\"ph1\">`Finally`</ph> keyword, which executes its associated code block regardless of whether an exception is thrown.","pos":[6181,6316],"source":" This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown."},{"pos":[6325,6364],"content":"Synchronization Events and Wait Handles","linkify":"Synchronization Events and Wait Handles","nodes":[{"content":"Synchronization Events and Wait Handles","pos":[0,39]}]},{"content":"Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.","pos":[6368,6560]},{"content":"This requires <bpt id=\"p1\">*</bpt>synchronization events<ept id=\"p1\">*</ept>, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.","pos":[6561,6723],"source":" This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads."},{"content":"Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.","pos":[6724,6879]},{"content":"If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.","pos":[6880,6998]},{"content":"There are two kinds of synchronization events: <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>, and <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>.","pos":[7005,7137],"source":"There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>."},{"content":"They differ only in that <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> changes from signaled to unsignaled automatically any time it activates a thread.","pos":[7138,7283],"source":" They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread."},{"content":"Conversely, a <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.","pos":[7284,7526],"source":" Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called."},{"content":"Threads can be made to wait on events by calling one of the wait methods, such as <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.","pos":[7533,7758],"source":"Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> causes the thread to wait until a single event becomes signaled, <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;</ph> blocks a thread until one or more indicated events become signaled, and <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;</ph> blocks the thread until all of the indicated events become signaled.","pos":[7759,8177],"source":"<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled."},{"content":"An event becomes signaled when its <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method is called.","pos":[8178,8277],"source":" An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called."},{"content":"In the following example, a thread is created and started by the <ph id=\"ph1\">`Main`</ph> function.","pos":[8284,8365],"source":"In the following example, a thread is created and started by the `Main` function."},{"content":"The new thread waits on an event using the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.","pos":[8366,8462],"source":" The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method."},{"content":"The thread is suspended until the event becomes signaled by the primary thread that is executing the <ph id=\"ph1\">`Main`</ph> function.","pos":[8463,8580],"source":" The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function."},{"content":"Once the event becomes signaled, the auxiliary thread returns.","pos":[8581,8643]},{"content":"In this case, because the event is only used for one thread activation, either the <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> classes could be used.","pos":[8644,8832],"source":" In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used."},{"pos":[9600,9612],"content":"Mutex Object","linkify":"Mutex Object","nodes":[{"content":"Mutex Object","pos":[0,12]}]},{"content":"A <bpt id=\"p1\">*</bpt>mutex<ept id=\"p1\">*</ept> is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.","pos":[9616,9743],"source":"A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time."},{"content":"In fact, the name \"mutex\" is a shortened form of the term \"mutually exclusive.\"","pos":[9744,9823]},{"content":"Unlike monitors, however, a mutex can be used to synchronize threads across processes.","pos":[9824,9910]},{"content":"A mutex is represented by the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> class.","pos":[9911,9977],"source":" A mutex is represented by the <xref:System.Threading.Mutex> class."},{"content":"When used for inter-process synchronization, a mutex is called a <bpt id=\"p1\">*</bpt>named mutex<ept id=\"p1\">*</ept> because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.","pos":[9984,10186],"source":"When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable."},{"content":"It must be given a name so that both applications can access the same mutex object.","pos":[10187,10270]},{"content":"Although a mutex can be used for intra-process thread synchronization, using <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.","pos":[10277,10520],"source":"Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources."},{"content":"In contrast, the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> class is a wrapper to a Win32 construct.","pos":[10521,10608],"source":" In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct."},{"content":"While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class.","pos":[10609,10793],"source":" While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class."},{"content":"For an example of using a mutex, see <bpt id=\"p1\">[</bpt>Mutexes<ept id=\"p1\">](../../../../standard/threading/mutexes.md)</ept>.","pos":[10794,10884],"source":" For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md)."},{"pos":[10893,10910],"content":"Interlocked Class","linkify":"Interlocked Class","nodes":[{"content":"Interlocked Class","pos":[0,17]}]},{"content":"You can use the methods of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.","pos":[10914,11103],"source":"You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value."},{"content":"The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.","pos":[11104,11212]},{"pos":[11221,11239],"content":"ReaderWriter Locks","linkify":"ReaderWriter Locks","nodes":[{"content":"ReaderWriter Locks","pos":[0,18]}]},{"content":"In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.","pos":[11243,11409]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.","pos":[11410,11604],"source":" The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource."},{"content":"ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.","pos":[11605,11755]},{"pos":[11764,11773],"content":"Deadlocks","linkify":"Deadlocks","nodes":[{"content":"Deadlocks","pos":[0,9]}]},{"content":"Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a <ph id=\"ph1\">`deadlock`</ph>, where multiple threads are waiting for each other and the application comes to a halt.","pos":[11777,11988],"source":"Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt."},{"content":"A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.","pos":[11989,12120]},{"content":"Avoiding deadlocks is important; the key is careful planning.","pos":[12121,12182]},{"content":"You can often predict deadlock situations by diagramming multithreaded applications before you start coding.","pos":[12183,12291]},{"pos":[12300,12308],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\"> [</bpt>Multithreaded Applications (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md)</ept><ph id=\"ph1\"> </ph>","pos":[12987,13125],"source":" [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) "},{"content":"<bpt id=\"p1\"> [</bpt>SyncLock Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/synclock-statement.md)</ept><ph id=\"ph1\"> </ph>","pos":[13128,13228],"source":" [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Mutexes<ept id=\"p1\">](../../../../standard/threading/mutexes.md)</ept><ph id=\"ph1\"> </ph>","pos":[13231,13285],"source":" [Mutexes](../../../../standard/threading/mutexes.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Interlocked Operations<ept id=\"p1\">](../../../../standard/threading/interlocked-operations.md)</ept><ph id=\"ph1\"> </ph>","pos":[13318,13402],"source":" [Interlocked Operations](../../../../standard/threading/interlocked-operations.md) "},{"content":"<bpt id=\"p1\"> [</bpt>AutoResetEvent<ept id=\"p1\">](../../../../standard/threading/autoresetevent.md)</ept><ph id=\"ph1\"> </ph>","pos":[13405,13473],"source":" [AutoResetEvent](../../../../standard/threading/autoresetevent.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Synchronizing Data for Multithreading<ept id=\"p1\">](../../../../standard/threading/synchronizing-data-for-multithreading.md)</ept>","pos":[13476,13589],"source":" [Synchronizing Data for Multithreading](../../../../standard/threading/synchronizing-data-for-multithreading.md)"}]}