{"content":"---\ntitle: \"How to: Implement a Lightweight Class with Auto-Implemented Properties - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"auto-implemented properties [C#]\"\n  - \"properties [C#], auto-implemented\"\nms.assetid: 1dc5a8ad-a4f7-4f32-8506-3fc6d8c8bfed\n---\n# How to: Implement a Lightweight Class with Auto-Implemented Properties (C# Programming Guide)\nThis example shows how to create an immutable lightweight class that serves only to encapsulate a set of auto-implemented properties. Use this kind of construct instead of a struct when you must use reference type semantics.  \n  \n You can make an immutable property in two ways.  You can declare the [set](../../../csharp/language-reference/keywords/set.md) accessor to be [private](../../../csharp/language-reference/keywords/private.md).  The property is only settable within the type, but it is immutable to consumers.  You can instead declare only the [get](../../../csharp/language-reference/keywords/get.md) accessor, which makes the property immutable everywhere except in the type’s constructor.  \n  \n When you declare a private `set` accessor, you cannot use an object initializer to initialize the property. You must use a constructor or a factory method.  \n  \n## Example  \n The following example shows two ways to implement an immutable class that has auto-implemented properties. Each way declares one of the properties with a private `set` and one of the properties with a `get` only.  The first class uses a constructor only to initialize the properties, and the second class uses a static factory method that calls a constructor.  \n  \n```csharp  \n// This class is immutable. After an object is created,   \n    // it cannot be modified from outside the class. It uses a   \n    // constructor to initialize its properties.   \n    class Contact  \n    {  \n        // Read-only properties.   \n        public string Name { get; }  \n        public string Address { get; private set; }  \n  \n        // Public constructor.   \n        public Contact(string contactName, string contactAddress)  \n        {  \n            Name = contactName;  \n            Address = contactAddress;                 \n        }  \n    }  \n  \n    // This class is immutable. After an object is created,   \n    // it cannot be modified from outside the class. It uses a   \n    // static method and private constructor to initialize its properties.      \n    public class Contact2  \n    {  \n        // Read-only properties.   \n        public string Name { get; private set; }  \n        public string Address { get; }  \n  \n        // Private constructor.   \n        private Contact2(string contactName, string contactAddress)  \n        {  \n            Name = contactName;  \n            Address = contactAddress;                 \n        }  \n  \n        // Public factory method.   \n        public static Contact2 CreateContact(string name, string address)  \n        {  \n            return new Contact2(name, address);  \n        }  \n    }  \n  \n    public class Program  \n    {   \n        static void Main()  \n        {  \n            // Some simple data sources.   \n            string[] names = {\"Terry Adams\",\"Fadi Fakhouri\", \"Hanying Feng\",   \n                              \"Cesar Garcia\", \"Debra Garcia\"};  \n            string[] addresses = {\"123 Main St.\", \"345 Cypress Ave.\", \"678 1st Ave\",  \n                                  \"12 108th St.\", \"89 E. 42nd St.\"};  \n  \n            // Simple query to demonstrate object creation in select clause.   \n            // Create Contact objects by using a constructor.   \n            var query1 = from i in Enumerable.Range(0, 5)  \n                        select new Contact(names[i], addresses[i]);  \n  \n            // List elements cannot be modified by client code.   \n            var list = query1.ToList();  \n            foreach (var contact in list)  \n            {  \n                Console.WriteLine(\"{0}, {1}\", contact.Name, contact.Address);  \n            }  \n  \n            // Create Contact2 objects by using a static factory method.   \n            var query2 = from i in Enumerable.Range(0, 5)  \n                         select Contact2.CreateContact(names[i], addresses[i]);  \n  \n            // Console output is identical to query1.   \n            var list2 = query2.ToList();  \n  \n            // List elements cannot be modified by client code.   \n            // CS0272:   \n            // list2[0].Name = \"Eugene Zabokritski\";   \n  \n            // Keep the console open in debug mode.  \n            Console.WriteLine(\"Press any key to exit.\");  \n            Console.ReadKey();                  \n        }  \n    }  \n  \n/* Output:  \n    Terry Adams, 123 Main St.  \n    Fadi Fakhouri, 345 Cypress Ave.  \n    Hanying Feng, 678 1st Ave  \n    Cesar Garcia, 12 108th St.  \n    Debra Garcia, 89 E. 42nd St.  \n*/  \n```  \n  \n The compiler creates backing fields for each auto-implemented property. The fields are not accessible directly from source code.  \n  \n## See also\n\n- [Properties](../../../csharp/programming-guide/classes-and-structs/properties.md)\n- [struct](../../../csharp/language-reference/keywords/struct.md)\n- [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)\n","nodes":[{"pos":[4,296],"embed":true,"restype":"x-metadata","content":"title: \"How to: Implement a Lightweight Class with Auto-Implemented Properties - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"auto-implemented properties [C#]\"\n  - \"properties [C#], auto-implemented\"\nms.assetid: 1dc5a8ad-a4f7-4f32-8506-3fc6d8c8bfed","nodes":[{"content":"How to: Implement a Lightweight Class with Auto-Implemented Properties - C# Programming Guide","nodes":[{"pos":[0,93],"content":"How to: Implement a Lightweight Class with Auto-Implemented Properties - C# Programming Guide","nodes":[{"content":"How to: Implement a Lightweight Class with Auto-Implemented Properties - C# Programming Guide","pos":[0,93]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[303,396],"content":"How to: Implement a Lightweight Class with Auto-Implemented Properties (C# Programming Guide)","linkify":"How to: Implement a Lightweight Class with Auto-Implemented Properties (C# Programming Guide)","nodes":[{"content":"How to: Implement a Lightweight Class with Auto-Implemented Properties (C# Programming Guide)","pos":[0,93]}]},{"content":"This example shows how to create an immutable lightweight class that serves only to encapsulate a set of auto-implemented properties.","pos":[397,530]},{"content":"Use this kind of construct instead of a struct when you must use reference type semantics.","pos":[531,621]},{"content":"You can make an immutable property in two ways.","pos":[628,675]},{"content":"You can declare the <bpt id=\"p1\">[</bpt>set<ept id=\"p1\">](../../../csharp/language-reference/keywords/set.md)</ept> accessor to be <bpt id=\"p2\">[</bpt>private<ept id=\"p2\">](../../../csharp/language-reference/keywords/private.md)</ept>.","pos":[677,836],"source":"  You can declare the [set](../../../csharp/language-reference/keywords/set.md) accessor to be [private](../../../csharp/language-reference/keywords/private.md)."},{"content":"The property is only settable within the type, but it is immutable to consumers.","pos":[838,918]},{"content":"You can instead declare only the <bpt id=\"p1\">[</bpt>get<ept id=\"p1\">](../../../csharp/language-reference/keywords/get.md)</ept> accessor, which makes the property immutable everywhere except in the type’s constructor.","pos":[920,1100],"source":"  You can instead declare only the [get](../../../csharp/language-reference/keywords/get.md) accessor, which makes the property immutable everywhere except in the type’s constructor."},{"content":"When you declare a private <ph id=\"ph1\">`set`</ph> accessor, you cannot use an object initializer to initialize the property.","pos":[1107,1214],"source":"When you declare a private `set` accessor, you cannot use an object initializer to initialize the property."},{"content":"You must use a constructor or a factory method.","pos":[1215,1262]},{"pos":[1271,1278],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows two ways to implement an immutable class that has auto-implemented properties.","pos":[1282,1388]},{"content":"Each way declares one of the properties with a private <ph id=\"ph1\">`set`</ph> and one of the properties with a <ph id=\"ph2\">`get`</ph> only.","pos":[1389,1494],"source":" Each way declares one of the properties with a private `set` and one of the properties with a `get` only."},{"content":"The first class uses a constructor only to initialize the properties, and the second class uses a static factory method that calls a constructor.","pos":[1496,1641]},{"content":"The compiler creates backing fields for each auto-implemented property.","pos":[4849,4920]},{"content":"The fields are not accessible directly from source code.","pos":[4921,4977]},{"pos":[4986,4994],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4998,5079],"content":"<bpt id=\"p1\">[</bpt>Properties<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/properties.md)</ept>","source":"[Properties](../../../csharp/programming-guide/classes-and-structs/properties.md)"},{"pos":[5082,5145],"content":"<bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](../../../csharp/language-reference/keywords/struct.md)</ept>","source":"[struct](../../../csharp/language-reference/keywords/struct.md)"},{"pos":[5148,5277],"content":"<bpt id=\"p1\">[</bpt>Object and Collection Initializers<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)</ept>","source":"[Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)"}]}