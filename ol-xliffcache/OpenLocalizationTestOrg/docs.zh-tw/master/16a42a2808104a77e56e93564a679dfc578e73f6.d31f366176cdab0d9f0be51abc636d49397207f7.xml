{"content":"---\ntitle: \"Data Contract Names\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"data contracts [WCF], naming\"\nms.assetid: 31f87e6c-247b-48f5-8e94-b9e1e33d8d09\n---\n# Data Contract Names\n\nSometimes a client and a service do not share the same types. They can still pass data to each other as long as the data contracts are equivalent on both sides. [Data Contract Equivalence](data-contract-equivalence.md) is based on data contract and data member names, and therefore a mechanism is provided to map types and members to those names. This topic explains the rules for naming data contracts as well as the default behavior of the Windows Communication Foundation (WCF) infrastructure when creating names.\n\n## Basic Rules\nBasic rules regarding naming data contracts include:\n\n- A fully-qualified data contract name consists of a namespace and a name.\n\n- Data members have only names, but no namespaces.\n\n- When processing data contracts, the WCF infrastructure is case-sensitive to both the namespaces and the names of data contracts and data members.\n\n## Data Contract Namespaces\nA data contract namespace takes the form of a Uniform Resource Identifier (URI). The URI can be either absolute or relative. By default, data contracts for a particular type are assigned a namespace that comes from the common language runtime (CLR) namespace of that type.\n\nBy default, any given CLR namespace (in the format *Clr.Namespace*) is mapped to the namespace `http://schemas.datacontract.org/2004/07/Clr.Namespace`. To override this default, apply the <xref:System.Runtime.Serialization.ContractNamespaceAttribute> attribute to the entire module or assembly. Alternatively, to control the data contract namespace for each type, set the <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute>.\n\n> [!NOTE]\n> The `http://schemas.microsoft.com/2003/10/Serialization` namespace is reserved and cannot be used as a data contract namespace.\n\n> [!NOTE]\n> You cannot override the default namespace in data contract types that contain `delegate` declarations.\n\n## Data Contract Names\nThe default name of a data contract for a given type is the name of that type. To override the default, set the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute> to an alternative name. Special rules for generic types are described in \"Data Contract Names for Generic Types\" later in this topic.\n\n## Data Member Names\nThe default name of a data member for a given field or property is the name of that field or property. To override the default, set the <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to an alternative value.\n\n### Examples\nThe following example shows how you can override the default naming behavior of data contracts and data members.\n\n[!code-csharp[C_DataContractNames#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_datacontractnames/cs/source.cs#1)]\n[!code-vb[C_DataContractNames#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractnames/vb/source.vb#1)]\n\n## Data Contract Names for Generic Types\nSpecial rules exist for determining data contract names for generic types. These rules help avoid data contract name collisions between two closed generics of the same generic type.\n\nBy default, the data contract name for a generic type is the name of the type, followed by the string \"Of\", followed by the data contract names of the generic parameters, followed by a *hash* computed using the data contract namespaces of the generic parameters. A hash is the result of a mathematical function that acts as a \"fingerprint\" that uniquely identifies a piece of data. When all of the generic parameters are primitive types, the hash is omitted.\n\nFor example, see the types in the following example.\n\n[!code-csharp[C_DataContractNames#2](~/samples/snippets/csharp/VS_Snippets_CFX/c_datacontractnames/cs/source.cs#2)]\n[!code-vb[C_DataContractNames#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractnames/vb/source.vb#2)]\n\nIn this example, the type `Drawing<Square,RegularRedBrush>` has the data contract name \"DrawingOfSquareRedBrush5HWGAU6h\", where \"5HWGAU6h\" is a hash of the \"urn:shapes\" and \"urn:default\" namespaces. The type `Drawing<Square,SpecialRedBrush>` has the data contract name \"DrawingOfSquareRedBrushjpB5LgQ_S\", where \"jpB5LgQ_S\" is a hash of the \"urn:shapes\" and the \"urn:special\" namespaces. Note that if the hash is not used, the two names are identical, and thus a name collision occurs.\n\n## Customizing data contract names for generic types\n\nSometimes, the data contract names generated for generic types, as described previously, are unacceptable. For example, you may know in advance that you will not run into name collisions and may want to remove the hash. In this case, you can use the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A?displayProperty=nameWithType> property to specify a different way to generate names. You can use numbers in curly braces inside of the `Name` property to refer to data contract names of the generic parameters. (0 refers to the first parameter, 1 refers to the second, and so on.) You can use a number (#) sign inside curly braces to refer to the hash. You can use each of these references multiple times or not at all.\n\nFor example, the preceding generic `Drawing` type could have been declared as shown in the following example.\n\n[!code-csharp[c_DataContractNames#3](~/samples/snippets/csharp/VS_Snippets_CFX/c_datacontractnames/cs/source.cs#3)]\n[!code-vb[c_DataContractNames#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_datacontractnames/vb/source.vb#3)]\n\nIn this case, the type `Drawing<Square,RegularRedBrush>` has the data contract name \"Drawing_using_RedBrush_brush_and_Square_shape\". Note that because there is a \"{#}\" in the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property, the hash is not a part of the name, and thus the type is susceptible to naming collisions; for example, the type `Drawing<Square,SpecialRedBrush>` would have exactly the same data contract name.\n\n## See also\n\n- <xref:System.Runtime.Serialization.DataContractAttribute>\n- <xref:System.Runtime.Serialization.DataMemberAttribute>\n- <xref:System.Runtime.Serialization.ContractNamespaceAttribute>\n- [Using Data Contracts](using-data-contracts.md)\n- [Data Contract Equivalence](data-contract-equivalence.md)\n- [Data Contract Names](data-contract-names.md)\n- [Data Contract Versioning](data-contract-versioning.md)\n","nodes":[{"pos":[4,194],"embed":true,"restype":"x-metadata","content":"title: \"Data Contract Names\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"data contracts [WCF], naming\"\nms.assetid: 31f87e6c-247b-48f5-8e94-b9e1e33d8d09","nodes":[{"content":"Data Contract Names","nodes":[{"pos":[0,19],"content":"Data Contract Names","nodes":[{"content":"Data Contract Names","pos":[0,19]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[201,220],"content":"Data Contract Names","linkify":"Data Contract Names","nodes":[{"content":"Data Contract Names","pos":[0,19]}]},{"content":"Sometimes a client and a service do not share the same types.","pos":[222,283]},{"content":"They can still pass data to each other as long as the data contracts are equivalent on both sides.","pos":[284,382]},{"content":"<bpt id=\"p1\">[</bpt>Data Contract Equivalence<ept id=\"p1\">](data-contract-equivalence.md)</ept> is based on data contract and data member names, and therefore a mechanism is provided to map types and members to those names.","pos":[383,568],"source":"[Data Contract Equivalence](data-contract-equivalence.md) is based on data contract and data member names, and therefore a mechanism is provided to map types and members to those names."},{"content":"This topic explains the rules for naming data contracts as well as the default behavior of the Windows Communication Foundation (WCF) infrastructure when creating names.","pos":[569,738]},{"pos":[743,754],"content":"Basic Rules","linkify":"Basic Rules","nodes":[{"content":"Basic Rules","pos":[0,11]}]},{"content":"Basic rules regarding naming data contracts include:","pos":[755,807]},{"content":"A fully-qualified data contract name consists of a namespace and a name.","pos":[811,883]},{"content":"Data members have only names, but no namespaces.","pos":[887,935]},{"content":"When processing data contracts, the WCF infrastructure is case-sensitive to both the namespaces and the names of data contracts and data members.","pos":[939,1084]},{"pos":[1089,1113],"content":"Data Contract Namespaces","linkify":"Data Contract Namespaces","nodes":[{"content":"Data Contract Namespaces","pos":[0,24]}]},{"content":"A data contract namespace takes the form of a Uniform Resource Identifier (URI).","pos":[1114,1194]},{"content":"The URI can be either absolute or relative.","pos":[1195,1238]},{"content":"By default, data contracts for a particular type are assigned a namespace that comes from the common language runtime (CLR) namespace of that type.","pos":[1239,1386]},{"content":"By default, any given CLR namespace (in the format <bpt id=\"p1\">*</bpt>Clr.Namespace<ept id=\"p1\">*</ept>) is mapped to the namespace <ph id=\"ph1\">`http://schemas.datacontract.org/2004/07/Clr.Namespace`</ph>.","pos":[1388,1539],"source":"By default, any given CLR namespace (in the format *Clr.Namespace*) is mapped to the namespace `http://schemas.datacontract.org/2004/07/Clr.Namespace`."},{"content":"To override this default, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.ContractNamespaceAttribute&gt;</ph> attribute to the entire module or assembly.","pos":[1540,1682],"source":" To override this default, apply the <xref:System.Runtime.Serialization.ContractNamespaceAttribute> attribute to the entire module or assembly."},{"content":"Alternatively, to control the data contract namespace for each type, set the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph>.","pos":[1683,1905],"source":" Alternatively, to control the data contract namespace for each type, set the <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute>."},{"pos":[1909,2046],"content":"[!NOTE]\nThe `http://schemas.microsoft.com/2003/10/Serialization` namespace is reserved and cannot be used as a data contract namespace.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">`http://schemas.microsoft.com/2003/10/Serialization`</ph> namespace is reserved and cannot be used as a data contract namespace.","pos":[8,135],"source":"The `http://schemas.microsoft.com/2003/10/Serialization` namespace is reserved and cannot be used as a data contract namespace."}]},{"pos":[2050,2162],"content":"[!NOTE]\nYou cannot override the default namespace in data contract types that contain `delegate` declarations.","leadings":["","> "],"nodes":[{"content":"You cannot override the default namespace in data contract types that contain <ph id=\"ph1\">`delegate`</ph> declarations.","pos":[8,110],"source":"You cannot override the default namespace in data contract types that contain `delegate` declarations."}]},{"pos":[2167,2186],"content":"Data Contract Names","linkify":"Data Contract Names","nodes":[{"content":"Data Contract Names","pos":[0,19]}]},{"content":"The default name of a data contract for a given type is the name of that type.","pos":[2187,2265]},{"content":"To override the default, set the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Name%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> to an alternative name.","pos":[2266,2462],"source":" To override the default, set the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute> to an alternative name."},{"content":"Special rules for generic types are described in \"Data Contract Names for Generic Types\" later in this topic.","pos":[2463,2572]},{"pos":[2577,2594],"content":"Data Member Names","linkify":"Data Member Names","nodes":[{"content":"Data Member Names","pos":[0,17]}]},{"content":"The default name of a data member for a given field or property is the name of that field or property.","pos":[2595,2697]},{"content":"To override the default, set the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> to an alternative value.","pos":[2698,2891],"source":" To override the default, set the <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to an alternative value."},{"pos":[2897,2905],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"The following example shows how you can override the default naming behavior of data contracts and data members.","pos":[2906,3018]},{"pos":[3257,3294],"content":"Data Contract Names for Generic Types","linkify":"Data Contract Names for Generic Types","nodes":[{"content":"Data Contract Names for Generic Types","pos":[0,37]}]},{"content":"Special rules exist for determining data contract names for generic types.","pos":[3295,3369]},{"content":"These rules help avoid data contract name collisions between two closed generics of the same generic type.","pos":[3370,3476]},{"content":"By default, the data contract name for a generic type is the name of the type, followed by the string \"Of\", followed by the data contract names of the generic parameters, followed by a <bpt id=\"p1\">*</bpt>hash<ept id=\"p1\">*</ept> computed using the data contract namespaces of the generic parameters.","pos":[3478,3740],"source":"By default, the data contract name for a generic type is the name of the type, followed by the string \"Of\", followed by the data contract names of the generic parameters, followed by a *hash* computed using the data contract namespaces of the generic parameters."},{"content":"A hash is the result of a mathematical function that acts as a \"fingerprint\" that uniquely identifies a piece of data.","pos":[3741,3859]},{"content":"When all of the generic parameters are primitive types, the hash is omitted.","pos":[3860,3936]},{"content":"For example, see the types in the following example.","pos":[3938,3990]},{"content":"In this example, the type <ph id=\"ph1\">`Drawing&lt;Square,RegularRedBrush&gt;`</ph> has the data contract name \"DrawingOfSquareRedBrush5HWGAU6h\", where \"5HWGAU6h\" is a hash of the \"urn:shapes\" and \"urn:default\" namespaces.","pos":[4226,4424],"source":"In this example, the type `Drawing<Square,RegularRedBrush>` has the data contract name \"DrawingOfSquareRedBrush5HWGAU6h\", where \"5HWGAU6h\" is a hash of the \"urn:shapes\" and \"urn:default\" namespaces."},{"content":"The type <ph id=\"ph1\">`Drawing&lt;Square,SpecialRedBrush&gt;`</ph> has the data contract name \"DrawingOfSquareRedBrushjpB5LgQ_S\", where \"jpB5LgQ_S\" is a hash of the \"urn:shapes\" and the \"urn:special\" namespaces.","pos":[4425,4612],"source":" The type `Drawing<Square,SpecialRedBrush>` has the data contract name \"DrawingOfSquareRedBrushjpB5LgQ_S\", where \"jpB5LgQ_S\" is a hash of the \"urn:shapes\" and the \"urn:special\" namespaces."},{"content":"Note that if the hash is not used, the two names are identical, and thus a name collision occurs.","pos":[4613,4710]},{"pos":[4715,4764],"content":"Customizing data contract names for generic types","linkify":"Customizing data contract names for generic types","nodes":[{"content":"Customizing data contract names for generic types","pos":[0,49]}]},{"content":"Sometimes, the data contract names generated for generic types, as described previously, are unacceptable.","pos":[4766,4872]},{"content":"For example, you may know in advance that you will not run into name collisions and may want to remove the hash.","pos":[4873,4985]},{"content":"In this case, you can use the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Name%2A?displayProperty=nameWithType&gt;</ph> property to specify a different way to generate names.","pos":[4986,5165],"source":" In this case, you can use the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A?displayProperty=nameWithType> property to specify a different way to generate names."},{"content":"You can use numbers in curly braces inside of the <ph id=\"ph1\">`Name`</ph> property to refer to data contract names of the generic parameters.","pos":[5166,5290],"source":" You can use numbers in curly braces inside of the `Name` property to refer to data contract names of the generic parameters."},{"content":"(0 refers to the first parameter, 1 refers to the second, and so on.) You can use a number (#) sign inside curly braces to refer to the hash.","pos":[5291,5432]},{"content":"You can use each of these references multiple times or not at all.","pos":[5433,5499]},{"pos":[5501,5610],"content":"For example, the preceding generic <ph id=\"ph1\">`Drawing`</ph> type could have been declared as shown in the following example.","source":"For example, the preceding generic `Drawing` type could have been declared as shown in the following example."},{"content":"In this case, the type <ph id=\"ph1\">`Drawing&lt;Square,RegularRedBrush&gt;`</ph> has the data contract name \"Drawing_using_RedBrush_brush_and_Square_shape\".","pos":[5846,5978],"source":"In this case, the type `Drawing<Square,RegularRedBrush>` has the data contract name \"Drawing_using_RedBrush_brush_and_Square_shape\"."},{"content":"Note that because there is a \"{#}\" in the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute.Name%2A&gt;</ph> property, the hash is not a part of the name, and thus the type is susceptible to naming collisions; for example, the type <ph id=\"ph2\">`Drawing&lt;Square,SpecialRedBrush&gt;`</ph> would have exactly the same data contract name.","pos":[5979,6291],"source":" Note that because there is a \"{#}\" in the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property, the hash is not a part of the name, and thus the type is susceptible to naming collisions; for example, the type `Drawing<Square,SpecialRedBrush>` would have exactly the same data contract name."},{"pos":[6296,6304],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6491,6538],"content":"<bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](using-data-contracts.md)</ept>","source":"[Using Data Contracts](using-data-contracts.md)"},{"pos":[6541,6598],"content":"<bpt id=\"p1\">[</bpt>Data Contract Equivalence<ept id=\"p1\">](data-contract-equivalence.md)</ept>","source":"[Data Contract Equivalence](data-contract-equivalence.md)"},{"pos":[6601,6646],"content":"<bpt id=\"p1\">[</bpt>Data Contract Names<ept id=\"p1\">](data-contract-names.md)</ept>","source":"[Data Contract Names](data-contract-names.md)"},{"pos":[6649,6704],"content":"<bpt id=\"p1\">[</bpt>Data Contract Versioning<ept id=\"p1\">](data-contract-versioning.md)</ept>","source":"[Data Contract Versioning](data-contract-versioning.md)"}]}