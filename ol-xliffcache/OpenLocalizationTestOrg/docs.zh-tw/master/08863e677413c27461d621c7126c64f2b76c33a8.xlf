<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="constraints-on-type-parameters.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">08863e677413c27461d621c7126c64f2b76c33a8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\generics\constraints-on-type-parameters.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8ef0d0a342fa2d8144581a55b3e3f8681e96ef41</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8acdc6d69f0743ab9020015800fa9c5d816cf8e8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Constraints on Type Parameters - C# Programming Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Constraints on type parameters (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Constraints inform the compiler about the capabilities a type argument must have.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Without any constraints, the type argument could be any type.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The compiler can only assume the members of <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>, which is the ultimate base class for any .NET type.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Why use constraints<ept id="p1">](#why-use-constraints)</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Constraints are specified by using the <ph id="ph1">`where`</ph> contextual keyword.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following table lists the seven types of constraints:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Constraint</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The type argument must be a value type.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Any value type except <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> can be specified.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For more information about nullable types, see <bpt id="p1">[</bpt>Nullable types<ept id="p1">](../nullable-types/index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The type argument must be a reference type.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This constraint applies also to any class, interface, delegate, or array type.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The type argument must not be a reference type and must not contain any reference type members at any level of nesting.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The type argument must have a public parameterless constructor.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When used together with other constraints, the <ph id="ph1">`new()`</ph> constraint must be specified last.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`where T :`</ph> <bpt id="p1">*</bpt><ph id="ph2">\&lt;</ph>base class name&gt;<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The type argument must be or derive from the specified base class.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`where T :`</ph> <bpt id="p1">*</bpt><ph id="ph2">\&lt;</ph>interface name&gt;<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The type argument must be or implement the specified interface.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Multiple interface constraints can be specified.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The constraining interface can also be generic.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The type argument supplied for T must be or derive from the argument supplied for U.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Some of the constraints are mutually exclusive.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>All value types must have an accessible parameterless constructor.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`struct`</ph> constraint implies the <ph id="ph2">`new()`</ph> constraint and the <ph id="ph3">`new()`</ph> constraint cannot be combined with the <ph id="ph4">`struct`</ph> constraint.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`unmanaged`</ph> constraint implies the <ph id="ph2">`struct`</ph> constraint.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`unmanaged`</ph> constraint cannot be combined with either the <ph id="ph2">`struct`</ph> or <ph id="ph3">`new()`</ph> constraints.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Why use constraints</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>When you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>, you will have to apply constraints to the type parameter.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following code example demonstrates the functionality you can add to the <ph id="ph1">`GenericList&lt;T&gt;`</ph> class (in <bpt id="p1">[</bpt>Introduction to Generics<ept id="p1">](introduction-to-generics.md)</ept>) by applying a base class constraint.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The constraint enables the generic class to use the <ph id="ph1">`Employee.Name`</ph> property.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The constraint specifies that all items of type <ph id="ph1">`T`</ph> are guaranteed to be either an <ph id="ph2">`Employee`</ph> object or an object that inherits from <ph id="ph3">`Employee`</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When applying the <ph id="ph1">`where T : class`</ph> constraint, avoid the <ph id="ph2">`==`</ph> and <ph id="ph3">`!=`</ph> operators on the type parameter because these operators will test for reference identity only, not for value equality.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>This behavior occurs even if these operators are overloaded in a type that is used as an argument.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following code illustrates this point; the output is false even though the <ph id="ph1">&lt;xref:System.String&gt;</ph> class overloads the <ph id="ph2">`==`</ph> operator.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The compiler only knows that T is a reference type at compile time and must use the default operators that are valid for all reference types.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If you must test for value equality, the recommended way is to also apply the <ph id="ph1">`where T : IEquatable&lt;T&gt;`</ph> or <ph id="ph2">`where T : IComparable&lt;T&gt;`</ph> constraint and implement the interface in any class that will be used to construct the generic class.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Constraining multiple parameters</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Unbounded type parameters</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Type parameters that have no constraints, such as T in public class <ph id="ph1">`SampleClass&lt;T&gt;{}`</ph>, are called unbounded type parameters.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Unbounded type parameters have the following rules:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`!=`</ph> and <ph id="ph2">`==`</ph> operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>They can be converted to and from <ph id="ph1">`System.Object`</ph> or explicitly converted to any interface type.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can compare them to <bpt id="p1">[</bpt>null<ept id="p1">](../../language-reference/keywords/null.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If an unbounded parameter is compared to <ph id="ph1">`null`</ph>, the comparison will always return false if the type argument is a value type.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the previous example, <ph id="ph1">`T`</ph> is a type constraint in the context of the <ph id="ph2">`Add`</ph> method, and an unbounded type parameter in the context of the <ph id="ph3">`List`</ph> class.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Type parameters can also be used as constraints in generic class definitions.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The type parameter must be declared within the angle brackets together with any other type parameters:</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from <ph id="ph1">`System.Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Unmanaged constraint</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Beginning with C# 7.3, you can use the <ph id="ph1">`unmanaged`</ph> constraint to specify that the type parameter must be an <bpt id="p1">**</bpt>unmanaged type<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>unmanaged type<ept id="p1">**</ept> is a type that is not a reference type and doesn't contain reference type fields at any level of nesting.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`unmanaged`</ph> constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The preceding method must be compiled in an <ph id="ph1">`unsafe`</ph> context because it uses the <ph id="ph2">`sizeof`</ph> operator on a type not known to be a built-in type.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Without the <ph id="ph1">`unmanaged`</ph> constraint, the <ph id="ph2">`sizeof`</ph> operator is unavailable.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Delegate constraints</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Also beginning with C# 7.3, you can use <ph id="ph1">&lt;xref:System.Delegate?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph> as a base class constraint.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The CLR always allowed this constraint, but the C# language disallowed it.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`System.Delegate`</ph> constraint enables you to write code that works with delegates in a type-safe manner.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following code defines an extension method that combines two delegates provided they are the same type:</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>You can use the above method to combine delegates that are the same type:</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>If you uncomment the last line, it won't compile.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Both <ph id="ph1">`first`</ph> and <ph id="ph2">`test`</ph> are delegate types, but they are different delegate types.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Enum constraints</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Beginning in C# 7.3, you can also specify the <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph> type as a base class constraint.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The CLR always allowed this constraint, but the C# language disallowed it.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Generics using <ph id="ph1">`System.Enum`</ph> provide type-safe programming to cache results from using the static methods in <ph id="ph2">`System.Enum`</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The methods used make use of reflection, which has performance implications.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can call this method to build a collection that is cached and reused rather than repeating the calls that require reflection.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Introduction to Generics<ept id="p1">](../../../csharp/programming-guide/generics/introduction-to-generics.md)</ept></source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generic Classes<ept id="p1">](../../../csharp/programming-guide/generics/generic-classes.md)</ept></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>new Constraint<ept id="p1">](../../../csharp/language-reference/keywords/new-constraint.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>