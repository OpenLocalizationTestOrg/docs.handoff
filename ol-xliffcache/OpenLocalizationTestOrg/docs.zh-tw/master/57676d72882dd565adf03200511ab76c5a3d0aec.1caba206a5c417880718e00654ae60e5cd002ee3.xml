{"content":"---\ntitle: \"Best Practices for Reliable Sessions | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: b94f6e01-8070-40b6-aac7-a2cb7b4cb4f2\ncaps.latest.revision: 6\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Best Practices for Reliable Sessions\nThis section discusses best practices for reliable sessions.  \n  \n## Setting MaxTransferWindowSize  \n Reliable sessions in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] use a transfer window to hold messages on the client and service. The configurable property <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A>indicates how many messages the transfer window can hold.  \n  \n On the sender, this indicates how many messages the transfer window can hold while waiting for acknowledgements; on the receiver it indicates how many messages to buffer for the service.  \n  \n Choosing the right size impacts how efficiently the network is put to use and the optimal capacity the service is running at. The following sections detail what to consider when choosing a value for this property, and the impact of the value.  \n  \n The default transfer window size is 8 messages.  \n  \n### Efficient Use of the Network  \n The term *network* here corresponds to everything between a client (sender) and a service (receiver) used as the basis of communication. This includes the transport connections and any intermediary or bridges in-between, including SOAP routers or HTTP proxies/firewalls.  \n  \n Efficient use of the network ensures that network capacity is fully used. Both the amount of data that can be transferred per second over the network (called *data rate*) and the time it takes to transfer data from the sender to the receiver (called *latency*) impact how effectively the network is utilized.  \n  \n On the sender, the property <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> indicates how many messages its transfer window can hold while waiting for acknowledgements. Thus, if the network latency is high, in order to ensure a responsive sender and effective network utilization, you should increase the transfer window size.  \n  \n For example, even if the sender keeps up with data rate, latency could be high if several intermediaries exist between the sender and receiver or a lossy intermediary or network. Thus the sender has to wait for acknowledgements for the messages in its transfer window before accepting new messages to send on the wire. The smaller the buffer with high latency, the less effectively the network utilization. On the other hand, too high a transfer window size may impact the service because the service may have to catch up to the high rate of send from the client.  \n  \n### Running the Service to Capacity  \n As much as the network is used efficiently, ideally you also want the service to run to optimal capacity. The transfer window size property on the receiver indicates how many messages the receiver can buffer. This message buffering helps not only the network flow control but also enables the service to run to full capacity. For example, if the buffer is 1 and messages arrive faster than the service can process them, then the network might drop messages, and network capacity might be wasted or underutilized.  \n  \n Using a bufferincreases the availability of the service as it concurrently receives and buffers the message while processing the previously received messages.  \n  \n It is recommended that you use the same `MaxTransferWindowSize` on both the sender and receiver.  \n  \n### Enabling Flow Control  \n Flow control is a mechanism that ensures that the sender and receiver keep pace with each other, that is,  the messages are consumed and acted upon as fast as they are produced. The transfer window size on the client and service ensures that the sender and receiver are within a reasonable window of synchronization.  \n  \n It is highly recommended that you set the property <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled%2A> to true when you are using a reliable session between a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client and a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service.  \n  \n## Setting MaxPendingChannels  \n When writing a service that enables reliable session communication from different clients, it is possible to have many clients establish a reliable session to the service at the same time. The response of the service in these situations depends on the `MaxPendingChannels` property.  \n  \n When the sender creates a reliable session channel to a receiver, a handshake between them establishes a reliable session. After the reliable session is established, the channel is put in a pending channel queue for acceptance by the service. The `MaxPendingChannels` property indicates how many channels can be in this state.  \n  \n It is possible for the service to be in a state where it can accept no more channels. If the queue is full, an attempt to establish a reliable session is rejected and the client has to retry.  \n  \n It is also possible that the pending channels in the queue remain in the queue for a longer duration. In the meantime, inactivity timeout on the reliable session may kick in, causing the channel to transition to a faulted state.  \n  \n Therefore, when writing a service that services multiple clients simultaneously, you should set a value that is suitable for your needs. Setting too high a value for the `MaxPendingChannels` property will impact your working set.  \n  \n The default value for <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels%2A> is 4.  \n  \n## Reliable Sessions and Hosting  \n When Web hosting a service that uses reliable sessions, you should keep the following important considerations in mind:  \n  \n-   Reliable sessions are stateful, and state is maintained in the AppDomain. This means that all messages that are part of a reliable session must be processed in the same AppDomain. Web farms and Web gardens where the size of the farm or garden is > 1 can't guarantee keeping with this constraint.  \n  \n-   Reliable sessions using dual HTTP channels (for example, using `WsDualHttpBinding`) can require more than the default HTTP connections per-client of 2. This means a duplex reliable session can require up to 2 connections each way, because concurrent application and protocol messages may be transferring each way at any given time. This means that, under certain conditions, depending on the message exchange pattern of the service, it is possible to deadlock a Web-hosted service using dual HTTP and reliable sessions. To increase the number of allowable HTTP connections per client, add the following to the relevant configuration file (for example, web.config of the service in question):  \n  \n```  \n<configuration>  \n   <system.net>  \n      <connectionManagement>  \n         <add name = \"*\" maxconnection = \"XX\" />  \n      </connectionManagement>  \n   </system.net>  \n</configuration>  \n```  \n  \n Where \"XX\" is the number of connections needed. The minimum in this case should be 4.","nodes":[{"pos":[12,65],"content":"Best Practices for Reliable Sessions | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Best Practices for Reliable Sessions | Microsoft Docs","pos":[0,53]}]},{"pos":[363,399],"content":"Best Practices for Reliable Sessions","linkify":"Best Practices for Reliable Sessions","nodes":[{"content":"Best Practices for Reliable Sessions","pos":[0,36]}]},{"content":"This section discusses best practices for reliable sessions.","pos":[400,460]},{"pos":[469,498],"content":"Setting MaxTransferWindowSize","linkify":"Setting MaxTransferWindowSize","nodes":[{"content":"Setting MaxTransferWindowSize","pos":[0,29]}]},{"content":"Reliable sessions in <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> use a transfer window to hold messages on the client and service.","pos":[502,644],"source":"Reliable sessions in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] use a transfer window to hold messages on the client and service."},{"content":"The configurable property <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A&gt;</ph>indicates how many messages the transfer window can hold.","pos":[645,818],"source":" The configurable property <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A>indicates how many messages the transfer window can hold."},{"content":"On the sender, this indicates how many messages the transfer window can hold while waiting for acknowledgements; on the receiver it indicates how many messages to buffer for the service.","pos":[825,1011]},{"content":"Choosing the right size impacts how efficiently the network is put to use and the optimal capacity the service is running at.","pos":[1018,1143]},{"content":"The following sections detail what to consider when choosing a value for this property, and the impact of the value.","pos":[1144,1260]},{"content":"The default transfer window size is 8 messages.","pos":[1267,1314]},{"pos":[1324,1352],"content":"Efficient Use of the Network","linkify":"Efficient Use of the Network","nodes":[{"content":"Efficient Use of the Network","pos":[0,28]}]},{"content":"The term <bpt id=\"p1\">*</bpt>network<ept id=\"p1\">*</ept> here corresponds to everything between a client (sender) and a service (receiver) used as the basis of communication.","pos":[1356,1492],"source":"The term *network* here corresponds to everything between a client (sender) and a service (receiver) used as the basis of communication."},{"content":"This includes the transport connections and any intermediary or bridges in-between, including SOAP routers or HTTP proxies/firewalls.","pos":[1493,1626]},{"content":"Efficient use of the network ensures that network capacity is fully used.","pos":[1633,1706]},{"content":"Both the amount of data that can be transferred per second over the network (called <bpt id=\"p1\">*</bpt>data rate<ept id=\"p1\">*</ept>) and the time it takes to transfer data from the sender to the receiver (called <bpt id=\"p2\">*</bpt>latency<ept id=\"p2\">*</ept>) impact how effectively the network is utilized.","pos":[1707,1941],"source":" Both the amount of data that can be transferred per second over the network (called *data rate*) and the time it takes to transfer data from the sender to the receiver (called *latency*) impact how effectively the network is utilized."},{"content":"On the sender, the property <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A&gt;</ph> indicates how many messages its transfer window can hold while waiting for acknowledgements.","pos":[1948,2159],"source":"On the sender, the property <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> indicates how many messages its transfer window can hold while waiting for acknowledgements."},{"content":"Thus, if the network latency is high, in order to ensure a responsive sender and effective network utilization, you should increase the transfer window size.","pos":[2160,2317]},{"content":"For example, even if the sender keeps up with data rate, latency could be high if several intermediaries exist between the sender and receiver or a lossy intermediary or network.","pos":[2324,2502]},{"content":"Thus the sender has to wait for acknowledgements for the messages in its transfer window before accepting new messages to send on the wire.","pos":[2503,2642]},{"content":"The smaller the buffer with high latency, the less effectively the network utilization.","pos":[2643,2730]},{"content":"On the other hand, too high a transfer window size may impact the service because the service may have to catch up to the high rate of send from the client.","pos":[2731,2887]},{"pos":[2897,2928],"content":"Running the Service to Capacity","linkify":"Running the Service to Capacity","nodes":[{"content":"Running the Service to Capacity","pos":[0,31]}]},{"content":"As much as the network is used efficiently, ideally you also want the service to run to optimal capacity.","pos":[2932,3037]},{"content":"The transfer window size property on the receiver indicates how many messages the receiver can buffer.","pos":[3038,3140]},{"content":"This message buffering helps not only the network flow control but also enables the service to run to full capacity.","pos":[3141,3257]},{"content":"For example, if the buffer is 1 and messages arrive faster than the service can process them, then the network might drop messages, and network capacity might be wasted or underutilized.","pos":[3258,3444]},{"content":"Using a bufferincreases the availability of the service as it concurrently receives and buffers the message while processing the previously received messages.","pos":[3451,3609]},{"pos":[3616,3712],"content":"It is recommended that you use the same <ph id=\"ph1\">`MaxTransferWindowSize`</ph> on both the sender and receiver.","source":"It is recommended that you use the same `MaxTransferWindowSize` on both the sender and receiver."},{"pos":[3722,3743],"content":"Enabling Flow Control","linkify":"Enabling Flow Control","nodes":[{"content":"Enabling Flow Control","pos":[0,21]}]},{"content":"Flow control is a mechanism that ensures that the sender and receiver keep pace with each other, that is,  the messages are consumed and acted upon as fast as they are produced.","pos":[3747,3924]},{"content":"The transfer window size on the client and service ensures that the sender and receiver are within a reasonable window of synchronization.","pos":[3925,4063]},{"pos":[4070,4398],"content":"It is highly recommended that you set the property <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled%2A&gt;</ph> to true when you are using a reliable session between a <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> client and a <ph id=\"ph3\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service.","source":"It is highly recommended that you set the property <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled%2A> to true when you are using a reliable session between a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client and a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service."},{"pos":[4407,4433],"content":"Setting MaxPendingChannels","linkify":"Setting MaxPendingChannels","nodes":[{"content":"Setting MaxPendingChannels","pos":[0,26]}]},{"content":"When writing a service that enables reliable session communication from different clients, it is possible to have many clients establish a reliable session to the service at the same time.","pos":[4437,4625]},{"content":"The response of the service in these situations depends on the <ph id=\"ph1\">`MaxPendingChannels`</ph> property.","pos":[4626,4719],"source":" The response of the service in these situations depends on the `MaxPendingChannels` property."},{"content":"When the sender creates a reliable session channel to a receiver, a handshake between them establishes a reliable session.","pos":[4726,4848]},{"content":"After the reliable session is established, the channel is put in a pending channel queue for acceptance by the service.","pos":[4849,4968]},{"content":"The <ph id=\"ph1\">`MaxPendingChannels`</ph> property indicates how many channels can be in this state.","pos":[4969,5052],"source":" The `MaxPendingChannels` property indicates how many channels can be in this state."},{"content":"It is possible for the service to be in a state where it can accept no more channels.","pos":[5059,5144]},{"content":"If the queue is full, an attempt to establish a reliable session is rejected and the client has to retry.","pos":[5145,5250]},{"content":"It is also possible that the pending channels in the queue remain in the queue for a longer duration.","pos":[5257,5358]},{"content":"In the meantime, inactivity timeout on the reliable session may kick in, causing the channel to transition to a faulted state.","pos":[5359,5485]},{"content":"Therefore, when writing a service that services multiple clients simultaneously, you should set a value that is suitable for your needs.","pos":[5492,5628]},{"content":"Setting too high a value for the <ph id=\"ph1\">`MaxPendingChannels`</ph> property will impact your working set.","pos":[5629,5721],"source":" Setting too high a value for the `MaxPendingChannels` property will impact your working set."},{"content":"The default value for <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels%2A&gt;</ph> is 4.","pos":[5728,5843],"source":"The default value for <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels%2A> is 4."},{"pos":[5852,5881],"content":"Reliable Sessions and Hosting","linkify":"Reliable Sessions and Hosting","nodes":[{"content":"Reliable Sessions and Hosting","pos":[0,29]}]},{"content":"When Web hosting a service that uses reliable sessions, you should keep the following important considerations in mind:","pos":[5885,6004]},{"content":"Reliable sessions are stateful, and state is maintained in the AppDomain.","pos":[6014,6087]},{"content":"This means that all messages that are part of a reliable session must be processed in the same AppDomain.","pos":[6088,6193]},{"content":"Web farms and Web gardens where the size of the farm or garden is &gt; 1 can't guarantee keeping with this constraint.","pos":[6194,6309],"source":" Web farms and Web gardens where the size of the farm or garden is > 1 can't guarantee keeping with this constraint."},{"content":"Reliable sessions using dual HTTP channels (for example, using <ph id=\"ph1\">`WsDualHttpBinding`</ph>) can require more than the default HTTP connections per-client of 2.","pos":[6319,6470],"source":"Reliable sessions using dual HTTP channels (for example, using `WsDualHttpBinding`) can require more than the default HTTP connections per-client of 2."},{"content":"This means a duplex reliable session can require up to 2 connections each way, because concurrent application and protocol messages may be transferring each way at any given time.","pos":[6471,6650]},{"content":"This means that, under certain conditions, depending on the message exchange pattern of the service, it is possible to deadlock a Web-hosted service using dual HTTP and reliable sessions.","pos":[6651,6838]},{"content":"To increase the number of allowable HTTP connections per client, add the following to the relevant configuration file (for example, web.config of the service in question):","pos":[6839,7010]},{"content":"Where \"XX\" is the number of connections needed.","pos":[7220,7267]},{"content":"The minimum in this case should be 4.","pos":[7268,7305]}]}