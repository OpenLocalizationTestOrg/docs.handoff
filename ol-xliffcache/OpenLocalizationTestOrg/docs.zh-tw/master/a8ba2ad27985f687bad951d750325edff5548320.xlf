<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-ffc129d" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a8ba2ad27985f687bad951d750325edff5548320</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\advanced\routed-events-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64ae7a9e760abf395d531ff142075393fb1eb701</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3b1d819b3579bf931e654d1baea0d005c0067ab7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Routed Events Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Routed Events Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic describes the concept of routed events in <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The topic defines routed events terminology, describes how routed events are routed through a tree of elements, summarizes how you handle routed events, and introduces how to create your own custom routed events.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic assumes that you have basic knowledge of the <ph id="ph1">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> and object-oriented programming, as well as the concept of how the relationships between <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> elements can be conceptualized as a tree.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In order to follow the examples in this topic, you should also understand <ph id="ph1">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph> and know how to write very basic <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications or pages.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Walkthrough: My First WPF Desktop Application<ept id="p1">](../../../../docs/framework/wpf/getting-started/walkthrough-my-first-wpf-desktop-application.md)</ept> and <bpt id="p2">[</bpt>XAML Overview (WPF)<ept id="p2">](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>What Is a Routed Event?</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can think about routed events either from a functional or implementation perspective.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Both definitions are presented here, because some people find one or the other definition more useful.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Functional definition: A routed event is a type of event that can invoke handlers on multiple listeners in an element tree, rather than just on the object that raised the event.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Implementation definition: A routed event is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event that is backed by an instance of the <ph id="ph2">&lt;xref:System.Windows.RoutedEvent&gt;</ph> class and is processed by the <ph id="ph3">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> event system.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A typical <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application contains many elements.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Whether created in code or declared in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, these elements exist in an element tree relationship to each other.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The event route can travel in one of two directions depending on the event definition, but generally the route travels from the source element and then "bubbles" upward through the element tree until it reaches the element tree root (typically a page or a window).</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This bubbling concept might be familiar to you if you have worked with the DHTML object model previously.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Consider the following simple element tree:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>EventOvwSupport#GroupButton<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This element tree produces something like the following:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Yes, No, and Cancel buttons<ept id="p1">]</ept><bpt id="p2">(../../../../docs/framework/wpf/advanced/media/routedevent-ovw-1.gif "</bpt>RoutedEvent_ovw_1<ept id="p2">")</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In this simplified element tree, the source of a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event is one of the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> elements, and whichever <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> was clicked is the first element that has the opportunity to handle the event.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>But if no handler attached to the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> acts on the event, then the event will bubble upwards to the <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> parent in the element tree, which is the <ph id="ph3">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Potentially, the event bubbles to <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph>, and then beyond to the page root of the element tree (not shown).</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In other words, the event route for this <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event is:</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Button--&gt;StackPanel--&gt;Border--&gt;...</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Top-level Scenarios for Routed Events</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following is a brief summary of the scenarios that motivated the routed event concept, and why a typical <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event was not adequate for these scenarios:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Control composition and encapsulation:<ept id="p1">**</ept> Various controls in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> have a rich content model.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For example, you can place an image inside of a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>, which effectively extends the visual tree of the button.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>However, the added image must not break the hit-testing behavior that causes a button to respond to a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> of its content, even if the user clicks on pixels that are technically part of the image.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Singular handler attachment points:<ept id="p1">**</ept> In <ph id="ph1">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]</ph>, you would have to attach the same handler multiple times to process events that could be raised from multiple elements.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Routed events enable you to attach that handler only once, as was shown in the previous example, and use handler logic to determine where the event came from if necessary.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For instance, this might be the handler for the previously shown <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>EventOvwSupport#GroupButtonCodeBehind<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>EventOvwSupport#GroupButtonCodeBehind<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Class handling:<ept id="p1">**</ept> Routed events permit a static handler that is defined by the class.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This class handler has the opportunity to handle an event before any attached instance handlers can.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Referencing an event without reflection:<ept id="p1">**</ept> Certain code and markup techniques require a way to identify a specific event.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A routed event creates a <ph id="ph1">&lt;xref:System.Windows.RoutedEvent&gt;</ph> field as an identifier, which provides a robust event identification technique that does not require static or run-time reflection.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>How Routed Events Are Implemented</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>A routed event is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event that is backed by an instance of the <ph id="ph2">&lt;xref:System.Windows.RoutedEvent&gt;</ph> class and registered with the <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event system.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.RoutedEvent&gt;</ph> instance obtained from registration is typically retained as a <ph id="ph2">`public`</ph> <ph id="ph3">`static`</ph> <ph id="ph4">`readonly`</ph> field member of the class that registers and thus "owns" the routed event.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The connection to the identically named <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event (which is sometimes termed the "wrapper" event) is accomplished by overriding the <ph id="ph2">`add`</ph> and <ph id="ph3">`remove`</ph> implementations for the <ph id="ph4">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Ordinarily, the <ph id="ph1">`add`</ph> and <ph id="ph2">`remove`</ph> are left as an implicit default that uses the appropriate language-specific event syntax for adding and removing handlers of that event.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The routed event backing and connection mechanism is conceptually similar to how a dependency property is a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> property that is backed by the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> class and registered with the <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The following example shows the declaration for a custom <ph id="ph1">`Tap`</ph> routed event, including the registration and exposure of the <ph id="ph2">&lt;xref:System.Windows.RoutedEvent&gt;</ph> identifier field and the <ph id="ph3">`add`</ph> and <ph id="ph4">`remove`</ph> implementations for the <ph id="ph5">`Tap`</ph> <ph id="ph6">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>RoutedEventCustom#AddRemoveHandler<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>RoutedEventCustom#AddRemoveHandler<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Routed Event Handlers and XAML</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To add a handler for an event using <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, you declare the event name as an attribute on the element that is an event listener.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The value of the attribute is the name of your implemented handler method, which must exist in the partial class of the code-behind file.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>EventOvwSupport#SimplestSyntax<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> syntax for adding standard <ph id="ph2">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event handlers is the same for adding routed event handlers, because you are really adding handlers to the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event wrapper, which has a routed event implementation underneath.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information about adding event handlers in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Overview (WPF)<ept id="p1">](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Routing Strategies</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Routed events use one of three routing strategies:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Bubbling:<ept id="p1">**</ept> Event handlers on the event source are invoked.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The routed event then routes to successive parent elements until reaching the element tree root.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Most routed events use the bubbling routing strategy.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Bubbling routed events are generally used to report input or state changes from distinct controls or other UI elements.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Direct:<ept id="p1">**</ept> Only the source element itself is given the opportunity to invoke handlers in response.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This is analogous to the "routing" that <ph id="ph1">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]</ph> uses for events.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, unlike a standard <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event, direct routed events support class handling (class handling is explained in an upcoming section) and can be used by <ph id="ph2">&lt;xref:System.Windows.EventSetter&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tunneling:<ept id="p1">**</ept> Initially, event handlers at the element tree root are invoked.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The routed event then travels a route through successive child elements along the route, towards the node element that is the routed event source (the element that raised the routed event).</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Tunneling routed events are often used or handled as part of the compositing for a control, such that events from composite parts can be deliberately suppressed or replaced by events that are specific to the complete control.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Input events provided in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> often come implemented as a tunneling/bubbling pair.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Tunneling events are also sometimes referred to as Preview events, because of a naming convention that is used for the pairs.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Why Use Routed Events?</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>As an application developer, you do not always need to know or care that the event you are handling is implemented as a routed event.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Routed events have special behavior, but that behavior is largely invisible if you are handling an event on the element where it is raised.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Where routed events become powerful is if you use any of the suggested scenarios: defining common handlers at a common root, compositing your own control, or defining your own custom control class.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Routed event listeners and routed event sources do not need to share a common event in their hierarchy.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Any <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.ContentElement&gt;</ph> can be an event listener for any routed event.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Therefore, you can use the full set of routed events available throughout the working <ph id="ph1">[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]</ph> set as a conceptual "interface" whereby disparate elements in the application can exchange event information.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This "interface" concept for routed events is particularly applicable for input events.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Routed events can also be used to communicate through the element tree, because the event data for the event is perpetuated to each element in the route.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>One element could change something in the event data, and that change would be available to the next element in the route.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Other than the routing aspect, there are two other reasons that any given <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event might be implemented as a routed event instead of a standard <ph id="ph2">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> event.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If you are implementing your own events, you might also consider these principles:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Certain <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> styling and templating features such as <ph id="ph2">&lt;xref:System.Windows.EventSetter&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> require the referenced event to be a routed event.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This is the event identifier scenario mentioned earlier.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Routed events support a class handling mechanism whereby the class can specify static methods that have the opportunity to handle routed events before any registered instance handlers can access them.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This is very useful in control design, because your class can enforce event-driven class behaviors that cannot be accidentally suppressed by handling an event on an instance.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Each of the above considerations is discussed in a separate section of this topic.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Adding and Implementing an Event Handler for a Routed Event</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To add an event handler in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, you simply add the event name to an element as an attribute and set the attribute value as the name of the event handler that implements an appropriate delegate, as in the following example.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>EventOvwSupport#SimplestSyntax<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`b1SetColor`</ph> is the name of the implemented handler that contains the code that handles the <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`b1SetColor`</ph> must have the same signature as the <ph id="ph2">&lt;xref:System.Windows.RoutedEventHandler&gt;</ph> delegate, which is the event handler delegate for the <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The first parameter of all routed event handler delegates specifies the element to which the event handler is added, and the second parameter specifies the data for the event.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>EventOvwSupport#SimpleHandlerA<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>EventOvwSupport#SimpleHandlerA<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>EventOvwSupport#SimpleHandlerB<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlerb)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>EventOvwSupport#SimpleHandlerB<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlerb)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventHandler&gt;</ph> is the basic routed event handler delegate.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For routed events that are specialized for certain controls or scenarios, the delegates to use for the routed event handlers also might become more specialized, so that they can transmit specialized event data.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For instance, in a common input scenario, you might handle a <ph id="ph1">&lt;xref:System.Windows.UIElement.DragEnter&gt;</ph> routed event.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Your handler should implement the <ph id="ph1">&lt;xref:System.Windows.DragEventHandler&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>By using the most specific delegate, you can process the <ph id="ph1">&lt;xref:System.Windows.DragEventArgs&gt;</ph> in the handler and read the <ph id="ph2">&lt;xref:System.Windows.DragEventArgs.Data%2A&gt;</ph> property, which contains the clipboard payload of the drag operation.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For a complete example of how to add an event handler to an element using <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>Handle a Routed Event<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-handle-a-routed-event.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Adding a handler for a routed event in an application that is created in code is straightforward.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Routed event handlers can always be added through a helper method <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> (which is the same method that the existing backing calls for <ph id="ph2">`add`</ph>.) However, existing <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> routed events generally have backing implementations of <ph id="ph4">`add`</ph> and <ph id="ph5">`remove`</ph> logic that allow the handlers for routed events to be added by a language-specific event syntax, which is more intuitive syntax than the helper method.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The following is an example usage of the helper method:</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>EventOvwSupport#AddHandlerCode<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>EventOvwSupport#AddHandlerCode<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The next example shows the <ph id="ph1">[!INCLUDE[TLA#tla_cshrp](../../../../includes/tlasharptla-cshrp-md.md)]</ph> operator syntax (<ph id="ph2">[!INCLUDE[TLA2#tla_visualb](../../../../includes/tla2sharptla-visualb-md.md)]</ph> has slightly different operator syntax because of its handling of dereferencing):</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>EventOvwSupport#AddHandlerPlusEquals<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>EventOvwSupport#AddHandlerPlusEquals<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For an example of how to add an event handler in code, see <bpt id="p1">[</bpt>Add an Event Handler Using Code<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-add-an-event-handler-using-code.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If you are using <ph id="ph1">[!INCLUDE[TLA2#tla_visualb](../../../../includes/tla2sharptla-visualb-md.md)]</ph>, you can also use the <ph id="ph2">`Handles`</ph> keyword to add handlers as part of the handler declarations.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Visual Basic and WPF Event Handling<ept id="p1">](../../../../docs/framework/wpf/advanced/visual-basic-and-wpf-event-handling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The Concept of Handled</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>All routed events share a common event data base class, <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph> defines the <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> property, which takes a Boolean value.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The purpose of the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> property is to enable any event handler along the route to mark the routed event as <bpt id="p1">*</bpt>handled<ept id="p1">*</ept>, by setting the value of <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>After being processed by the handler at one element along the route, the shared event data is again reported to each listener along the route.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The value of <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> affects how a routed event is reported or processed as it travels further along the route.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> is <ph id="ph2">`true`</ph> in the event data for a routed event, then handlers that listen for that routed event on other elements are generally no longer invoked for that particular event instance.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>This is true both for handlers attached in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> and for handlers added by language-specific event handler attachment syntaxes such as <ph id="ph2">`+=`</ph> or <ph id="ph3">`Handles`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For most common handler scenarios, marking an event as handled by setting <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id="ph2">`true`</ph> will "stop" routing for either a tunneling route or a bubbling route, and also for any event that is handled at a point in the route by a class handler.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>However, there is a "handledEventsToo" mechanism whereby listeners can still run handlers in response to routed events where <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> is <ph id="ph2">`true`</ph> in the event data.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>In other words, the event route is not truly stopped by marking the event data as handled.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>You can only use the handledEventsToo mechanism in code, or in an <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>In code, instead of using a language-specific event syntax that works for general <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> events, call the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> method <ph id="ph3">&lt;xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29&gt;</ph> to add your handler.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Specify the value of <ph id="ph1">`handledEventsToo`</ph> as <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>In an <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph>, set the <ph id="ph2">&lt;xref:System.Windows.EventSetter.HandledEventsToo%2A&gt;</ph> attribute to be <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In addition to the behavior that <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> state produces in routed events, the concept of <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> has implications for how you should design your application and write the event handler code.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>You can conceptualize <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> as being a simple protocol that is exposed by routed events.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Exactly how you use this protocol is up to you, but the conceptual design for how the value of <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> is intended to be used is as follows:</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>If a routed event is marked as handled, then it does not need to be handled again by other elements along that route.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>If a routed event is not marked as handled, then other listeners that were earlier along the route have chosen either not to register a handler, or the handlers that were registered chose not to manipulate the event data and set <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>(Or, it is of course possible that the current listener is the first point in the route.) Handlers on the current listener now have three possible courses of action:</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Take no action at all; the event remains unhandled, and the event routes to the next listener.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The event routes to the next listener.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Execute code in response to the event.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The event still routes to the next listener, but with <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph><ph id="ph2">=</ph><ph id="ph3">`true`</ph> in its event data, so only <ph id="ph4">`handledEventsToo`</ph> listeners have the opportunity to invoke further handlers.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>This conceptual design is reinforced by the routing behavior mentioned earlier: it is more difficult (although still possible in code or styles) to attach handlers for routed events that are invoked even if a previous handler along the route has already set <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For more information about <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph>, class handling of routed events, and recommendations about when it is appropriate to mark a routed event as <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph>, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>In applications, it is quite common to just handle a bubbling routed event on the object that raised it, and not be concerned with the event's routing characteristics at all.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>However, it is still a good practice to mark the routed event as handled in the event data, to prevent unanticipated side effects just in case an element that is further up the element tree also has a handler attached for that same routed event.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Class Handlers</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>If you are defining a class that derives in some way from <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>, you can also define and attach a class handler for a routed event that is a declared or inherited event member of your class.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Class handlers are invoked before any instance listener handlers that are attached to an instance of that class, whenever a routed event reaches an element instance in its route.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Some <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls have inherent class handling for certain routed events.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This might give the outward appearance that the routed event is not ever raised, but in reality it is being class handled, and the routed event can potentially still be handled by your instance handlers if you use certain techniques.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Also, many base classes and controls expose virtual methods that can be used to override class handling behavior.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>For more information both on how to work around undesired class handling and on defining your own class handling in a custom class, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Attached Events in WPF</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> language also defines a special type of event called an <bpt id="p1">*</bpt>attached event<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>An attached event enables you to add a handler for a particular event to an arbitrary element.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The element handling the event need not define or inherit the attached event, and neither the object potentially raising the event nor the destination handling instance must define or otherwise "own" that event as a class member.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> input system uses attached events extensively.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>However, nearly all of these attached events are forwarded through base elements.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The input events then appear as equivalent non-attached routed events that are members of the base element class.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For instance, the underlying attached event <ph id="ph1">&lt;xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName&gt;</ph> can more easily be handled on any given <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> by using <ph id="ph3">&lt;xref:System.Windows.UIElement.MouseDown&gt;</ph> on that <ph id="ph4">&lt;xref:System.Windows.UIElement&gt;</ph> rather than dealing with attached event syntax either in <ph id="ph5">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> or code.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For more information about attached events in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, see <bpt id="p1">[</bpt>Attached Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/attached-events-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Qualified Event Names in XAML</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Another syntax usage that resembles <bpt id="p1">*</bpt>typename<ept id="p1">*</ept>.<bpt id="p2">*</bpt>eventname<ept id="p2">*</ept> attached event syntax but is not strictly speaking an attached event usage is when you attach handlers for routed events that are raised by child elements.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>You attach the handlers to a common parent, to take advantage of event routing, even though the common parent might not have the relevant routed event as a member.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Consider this example again:</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>EventOvwSupport#GroupButton<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Here, the parent element listener where the handler is added is a <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>However, it is adding a handler for a routed event that was declared and will be raised by the <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> class (<ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.ButtonBase&gt;</ph> actually, but available to <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> through inheritance).</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> "owns" the event, but the routed event system permits handlers for any routed event to be attached to any <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.ContentElement&gt;</ph> instance listener that could otherwise attach listeners for a <ph id="ph4">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> event.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The default xmlns namespace for these qualified event attribute names is typically the default <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> xmlns namespace, but you can also specify prefixed namespaces for custom routed events.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>For more information about xmlns, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>WPF Input Events</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>One frequent application of routed events within the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> platform is for input events.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, tunneling routed events names are prefixed with the word "Preview" by convention.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Input events often come in pairs, with one being the bubbling event and the other being the tunneling event.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.ContentElement.KeyDown&gt;</ph> event and the <ph id="ph2">&lt;xref:System.Windows.ContentElement.PreviewKeyDown&gt;</ph> event have the same signature, with the former being the bubbling input event and the latter being the tunneling input event.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Occasionally, input events only have a bubbling version, or perhaps only a direct routed version.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In the documentation, routed event topics cross-reference similar routed events with alternative routing strategies if such routed events exist, and sections in the managed reference pages clarify the routing strategy of each routed event.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> input events that come in pairs are implemented so that a single user action from input, such as a mouse button press, will raise both routed events of the pair in sequence.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>First, the tunneling event is raised and travels its route.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Then the bubbling event is raised and travels its route.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The two events literally share the same event data instance, because the <ph id="ph1">&lt;xref:System.Windows.UIElement.RaiseEvent%2A&gt;</ph> method call in the implementing class that raises the bubbling event listens for the event data from the tunneling event and reuses it in the new raised event.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Listeners with handlers for the tunneling event have the first opportunity to mark the routed event handled (class handlers first, then instance handlers).</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If an element along the tunneling route marked the routed event as handled, the already-handled event data is sent on for the bubbling event, and typical handlers attached for the equivalent bubbling input events will not be invoked.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>To outward appearances it will be as if the handled bubbling event has not even been raised.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This handling behavior is useful for control compositing, where you might want all hit-test based input events or focus-based input events to be reported by your final control, rather than its composite parts.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>The final control element is closer to the root in the compositing, and therefore has the opportunity to class handle the tunneling event first and perhaps to "replace" that routed event with a more control-specific event, as part of the code that backs the control class.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>As an illustration of how input event processing works, consider the following input event example.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>In the following tree illustration, <ph id="ph1">`leaf element #2`</ph> is the source of both a <ph id="ph2">`PreviewMouseDown`</ph> and then a <ph id="ph3">`MouseDown`</ph> event.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>Event routing diagram<ept id="p1">](../../../../docs/framework/wpf/advanced/media/wcsdkcoreinputevents.png "wcsdkCoreInputEvents")</ept></source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Input Event Bubbling and Tunneling</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The order of event processing is as follows:</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PreviewMouseDown`</ph> (tunnel) on root element.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PreviewMouseDown`</ph> (tunnel) on intermediate element #1.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`PreviewMouseDown`</ph> (tunnel) on source element #2.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MouseDown`</ph> (bubble) on source element #2.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MouseDown`</ph> (bubble) on intermediate element #1.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`MouseDown`</ph> (bubble) on root element.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>A routed event handler delegate provides references to two objects: the object that raised the event and the object where the handler was invoked.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The object where the handler was invoked is the object reported by the <ph id="ph1">`sender`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The object where the event was first raised is reported by the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> property in the event data.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>A routed event can still be raised and handled by the same object, in which case <ph id="ph1">`sender`</ph> and <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> are identical (this is the case with Steps 3 and 4 in the event processing example list).</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Because of tunneling and bubbling, parent elements receive input events where the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> is one of their child elements.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>When it is important to know what the source element is, you can identify the source element by accessing the <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Source%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>Usually, once the input event is marked <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph>, further handlers are not invoked.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Typically, you should mark input events as handled as soon as a handler is invoked that addresses your application-specific logical handling of the meaning of the input event.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The exception to this general statement about <ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> state is that input event handlers that are registered to deliberately ignore <ph id="ph2">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> state of the event data would still be invoked along either route.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Preview Events<ept id="p1">](../../../../docs/framework/wpf/advanced/preview-events.md)</ept> or <bpt id="p2">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p2">](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The shared event data model between tunneling and bubbling events, and the sequential raising of first tunneling then bubbling events, is not a concept that is generally true for all routed events.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>That behavior is specifically implemented by how <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> input devices choose to raise and connect the input event pairs.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Implementing your own input events is an advanced scenario, but you might choose to follow that model for your own input events also.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Certain classes choose to class-handle certain input events, usually with the intent of redefining what a particular user-driven input event means within that control and raising a new event.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For more information on input and how input and events interact in typical application scenarios, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>EventSetters and EventTriggers</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>In styles, you can include some pre-declared <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> event handling syntax in the markup by using an <ph id="ph2">&lt;xref:System.Windows.EventSetter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>When the style is applied, the referenced handler is added to the styled instance.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>You can declare an <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph> only for a routed event.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The following is an example.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`b1SetColor`</ph> method referenced here is in a code-behind file.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>EventOvwSupport#XAML2<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The advantage gained here is that the style is likely to contain a great deal of other information that could apply to any button in your application, and having the <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph> be part of that style promotes code reuse even at the markup level.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Also, an <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph> abstracts method names for handlers one step further away from the general application and page markup.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Another specialized syntax that combines the routed event and animation features of <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is an <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>As with <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph>, only routed events may be used for an <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Typically, an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> is declared as part of a style, but an <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph> can also be declared on page-level elements as part of the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Triggers%2A&gt;</ph> collection, or in a <ph id="ph4">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> enables you to specify a <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> that runs whenever a routed event reaches an element in its route that declares an <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> for that event.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The advantage of an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> over just handling the event and causing it to start an existing storyboard is that an <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph> provides better control over the storyboard and its run-time behavior.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Use Event Triggers to Control a Storyboard After It Starts<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>More About Routed Events</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>This topic mainly discusses routed events from the perspective of describing the basic concepts and offering guidance on how and when to respond to the routed events that are already present in the various base elements and controls.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>However, you can create your own routed event on your custom class along with all the necessary support, such as specialized event data classes and delegates.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The routed event owner can be any class, but routed events must be raised by and handled by <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.ContentElement&gt;</ph> derived classes in order to be useful.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>For more information about custom events, see <bpt id="p1">[</bpt>Create a Custom Routed Event<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.EventManager&gt;</ph></source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEvent&gt;</ph></source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.RoutedEventArgs&gt;</ph></source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Input Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/input-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Commanding Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/commanding-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Trees in WPF<ept id="p1">](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Weak Event Patterns<ept id="p1">](../../../../docs/framework/wpf/advanced/weak-event-patterns.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>