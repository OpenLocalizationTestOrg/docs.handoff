{"content":"---\ntitle: \"Query expression basics\"\ndescription: Introduces concepts related to query expressions\nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nmanager: wpickett\nms.author: wiwagn\nms.date: 11/30/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0\n---\n# Query expression basics\n\n## What is a query and what does it do? \n\n A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have. A query is distinct from the results that it produces.  \n  \n Generally, the source data is organized logically as a sequence of elements of the same kind. For example, a SQL database table contains a sequence of rows. In an XML file, there is a \"sequence\" of XML elements (although these are organized hierarchically in a tree structure). An in-memory collection contains a sequence of objects. \n  \n From an application's viewpoint, the specific type and structure of the original source data is not important. The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection. For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\\<<xref:System.Xml.Linq.XElement>>.  \n  \n Given this source sequence, a query may do one of three things:  \n  \n-   Retrieve a subset of the elements to produce a new sequence without modifying the individual elements. The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):  \n  \n     [!code-cs[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]  \n  \n-   Retrieve a sequence of elements as in the previous example but transform them to a new type of object. For example, a query may retrieve only the last names from certain customer records in a data source. Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence. The following example shows a projection from an `int` to a `string`. Note the new type of `highScoresQuery`.  \n  \n     [!code-cs[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]  \n  \n-   Retrieve a singleton value about the source data, such as:  \n  \n    -   The number of elements that match a certain condition.  \n  \n    -   The element that has the greatest or least value.  \n  \n    -   The first element that matches a condition, or the sum of particular values in a specified set of elements. For example, the following query returns the number of scores greater than 80 from the `scores` integer array:  \n  \n     [!code-cs[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]  \n  \n     In the previous example, note the use of parentheses around the query expression before the call to the `Count` method. You can also express this by using a new variable to store the concrete result. This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.  \n  \n     [!code-cs[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]  \n  \n In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.  \n  \n## What is a query expression?  \n\n A *query expression* is a query expressed in query syntax. A query expression is a first-class language construct. It is just like any other expression and can be used in any context in which a C# expression is valid. A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery. Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.  \n  \n A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause. Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses. You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.  \n  \n### Query variable  \n \n In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query. More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.  \n  \n The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements. The `select` clause ends the query.  \n  \n [!code-cs[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]  \n  \n In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*. The query variable stores no actual result data, which is produced in the `foreach` loop. And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`. Rather, they are returned through the iteration variable `testScore`. The `scoreQuery` variable can be iterated in a second `foreach` loop. It will produce the same results as long as neither it nor the data source has been modified.  \n  \n A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two. In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:  \n  \n [!code-cs[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]  \n  \n On the other hand, the following two examples show variables that are not query variables even through each is initialized with a query. They are not query variables because they store results:  \n  \n [!code-cs[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]  \n  \n For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).  \n  \n#### Explicit and implicit typing of query variables  \n \n This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md). However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time. For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:  \n  \n [!code-cs[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]  \n  \n For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).  \n  \n### Starting a query expression  \n \n A query expression must begin with a `from` clause. It specifies a data source together with a range variable. The range variable represents each successive element in the source sequence as the source sequence is being traversed. The range variable is strongly typed based on the type of elements in the data source. In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`. Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.  \n  \n [!code-cs[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]  \n  \n The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.  \n  \n A query expression may contain multiple `from` clauses. Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection. For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`. To query the `City` objects in each `Country`, use two `from` clauses as shown here:  \n  \n [!code-cs[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]  \n  \n For more information, see [from clause](../language-reference/keywords/from-clause.md).  \n  \n### Ending a query expression  \n \n A query expression must end with either a `group` clause or a `select` clause.  \n  \n#### group clause  \n \n Use the `group` clause to produce a sequence of groups organized by a key that you specify. The key can be any data type. For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.  \n  \n [!code-cs[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]  \n  \n For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).  \n  \n#### select clause  \n Use the `select` clause to produce all other types of sequences. A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source. In this example, the data source contains `Country` objects. The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.  \n  \n [!code-cs[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]  \n  \n The `select` clause can be used to transform source data into sequences of new types. This transformation is also named a *projection*. In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element. Note that the new objects are initialized by using an object initializer.  \n  \n [!code-cs[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]  \n  \n For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).  \n  \n#### Continuations with \"into\"  \n \n You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query. Do this when you must perform additional query operations on a query after a grouping or select operation. In the following example `countries` are grouped according to population in ranges of 10 million. After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order. To perform those additional operations, the continuation represented by `countryGroup` is required.  \n  \n [!code-cs[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]  \n  \n For more information, see [into](../language-reference/keywords/into.md).  \n  \n### Filtering, ordering, and joining\n\n Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional. Any of the optional clauses may be used zero times or multiple times in a query body.  \n  \n#### where clause  \n\n Use the `where` clause to filter out elements from the source data based on one or more predicate expressions. The `where` clause in the following example has one predicate with two conditions.  \n  \n [!code-cs[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]  \n  \n For more information, see [where clause](../language-reference/keywords/where-clause.md).  \n  \n#### orderby clause\n\n Use the `orderby` clause to sort the results in either ascending or descending order. You can also specify secondary sort orders. The following example performs a primary sort on the `country` objects by using the `Area` property. It then performs a secondary sort by using the `Population` property.  \n  \n [!code-cs[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]  \n  \n The `ascending` keyword is optional; it is the default sort order if no order is specified. For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).  \n  \n#### join clause\n\n Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element. In LINQ, join operations are performed on sequences of objects whose elements are different types. After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence. You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence. The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array. Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.  \n  \n [!code-cs[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]  \n  \n You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword. For more information, see [join clause](../language-reference/keywords/join-clause.md).  \n  \n#### let clause \n\n Use the `let` clause to store the result of an expression, such as a method call, in a new range variable. In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.  \n  \n [!code-cs[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]  \n  \n For more information, see [let clause](../language-reference/keywords/let-clause.md).  \n  \n### Subqueries in a query expression  \n\n A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*. Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause. For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.  \n  \n [!code-cs[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]  \n  \n For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).  \n  \n## See Also  \n [C# programming guide](../programming-guide/index.md)   \n [LINQ query expressions](index.md)   \n [Query keywords (LINQ)](../language-reference/keywords/query-keywords.md)   \n [Standard query operators overview](../programming-guide/concepts/linq/standard-query-operators-overview.md)\n","nodes":[{"pos":[4,346],"nodes":[{"content":"Query expression basics","nodes":[{"pos":[0,23],"content":"Query expression basics","nodes":[{"content":"Query expression basics","pos":[0,23]}]}],"pos":[6,32],"yaml":true},{"content":"Introduces concepts related to query expressions","nodes":[{"pos":[0,48],"content":"Introduces concepts related to query expressions","nodes":[{"content":"Introduces concepts related to query expressions","pos":[0,48]}]}],"pos":[45,94],"yaml":true},{"content":".NET, .NET Core, C#","nodes":[{"pos":[0,19],"content":".NET, .NET Core, C#","nodes":[{"content":".NET, .NET Core, C#","pos":[0,19]}]}],"pos":[104,124],"yaml":true}],"content":"title: \"Query expression basics\"\ndescription: Introduces concepts related to query expressions\nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nmanager: wpickett\nms.author: wiwagn\nms.date: 11/30/2016\nms.topic: article\nms.prod: .net-core\nms.technology: .net-core-technologies\nms.devlang: dotnet\nms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0","yamlblock":true},{"pos":[353,376],"content":"Query expression basics","linkify":"Query expression basics","nodes":[{"content":"Query expression basics","pos":[0,23]}]},{"pos":[381,417],"content":"What is a query and what does it do?","linkify":"What is a query and what does it do?","nodes":[{"content":"What is a query and what does it do?","pos":[0,36]}]},{"content":"A <bpt id=\"p1\">*</bpt>query<ept id=\"p1\">*</ept> is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.","pos":[421,593],"source":"A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have."},{"content":"A query is distinct from the results that it produces.","pos":[594,648]},{"content":"Generally, the source data is organized logically as a sequence of elements of the same kind.","pos":[655,748]},{"content":"For example, a SQL database table contains a sequence of rows.","pos":[749,811]},{"content":"In an XML file, there is a \"sequence\" of XML elements (although these are organized hierarchically in a tree structure).","pos":[812,932]},{"content":"An in-memory collection contains a sequence of objects.","pos":[933,988]},{"content":"From an application's viewpoint, the specific type and structure of the original source data is not important.","pos":[994,1104]},{"content":"The application always sees the source data as an <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Linq.IQueryable%601&gt;</ph> collection.","pos":[1105,1253],"source":" The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection."},{"content":"For example, in LINQ to XML, the source data is made visible as an <ph id=\"ph1\">`IEnumerable`</ph><ph id=\"ph2\">\\&lt;</ph><ph id=\"ph3\">&lt;xref:System.Xml.Linq.XElement&gt;</ph>&gt;.","pos":[1254,1369],"source":" For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\\<<xref:System.Xml.Linq.XElement>>."},{"content":"Given this source sequence, a query may do one of three things:","pos":[1376,1439]},{"content":"Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.","pos":[1449,1551]},{"content":"The query may then sort or group the returned sequence in various ways, as shown in the following example (assume <ph id=\"ph1\">`scores`</ph> is an <ph id=\"ph2\">`int[]`</ph>):","pos":[1552,1690],"source":" The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):"},{"pos":[1701,1812],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#45<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#45](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]"},{"content":"Retrieve a sequence of elements as in the previous example but transform them to a new type of object.","pos":[1822,1924]},{"content":"For example, a query may retrieve only the last names from certain customer records in a data source.","pos":[1925,2026]},{"content":"Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.","pos":[2027,2186]},{"content":"The following example shows a projection from an <ph id=\"ph1\">`int`</ph> to a <ph id=\"ph2\">`string`</ph>.","pos":[2187,2256],"source":" The following example shows a projection from an `int` to a `string`."},{"content":"Note the new type of <ph id=\"ph1\">`highScoresQuery`</ph>.","pos":[2257,2296],"source":" Note the new type of `highScoresQuery`."},{"pos":[2307,2418],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#46<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#46](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]"},{"content":"Retrieve a singleton value about the source data, such as:","pos":[2428,2486]},{"content":"The number of elements that match a certain condition.","pos":[2500,2554]},{"content":"The element that has the greatest or least value.","pos":[2568,2617]},{"content":"The first element that matches a condition, or the sum of particular values in a specified set of elements.","pos":[2631,2738]},{"content":"For example, the following query returns the number of scores greater than 80 from the <ph id=\"ph1\">`scores`</ph> integer array:","pos":[2739,2849],"source":" For example, the following query returns the number of scores greater than 80 from the `scores` integer array:"},{"pos":[2860,2971],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#47<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#47](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]"},{"content":"In the previous example, note the use of parentheses around the query expression before the call to the <ph id=\"ph1\">`Count`</ph> method.","pos":[2982,3101],"source":"In the previous example, note the use of parentheses around the query expression before the call to the `Count` method."},{"content":"You can also express this by using a new variable to store the concrete result.","pos":[3102,3181]},{"content":"This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.","pos":[3182,3311]},{"pos":[3322,3433],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#48<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#48](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]"},{"pos":[3440,3632],"content":"In the previous example, the query is executed in the call to <ph id=\"ph1\">`Count`</ph>, because <ph id=\"ph2\">`Count`</ph> must iterate over the results in order to determine the number of elements returned by <ph id=\"ph3\">`highScoresQuery`</ph>.","source":"In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`."},{"pos":[3641,3668],"content":"What is a query expression?","linkify":"What is a query expression?","nodes":[{"content":"What is a query expression?","pos":[0,27]}]},{"content":"A <bpt id=\"p1\">*</bpt>query expression<ept id=\"p1\">*</ept> is a query expressed in query syntax.","pos":[3673,3731],"source":"A *query expression* is a query expressed in query syntax."},{"content":"A query expression is a first-class language construct.","pos":[3732,3787]},{"content":"It is just like any other expression and can be used in any context in which a C# expression is valid.","pos":[3788,3890]},{"content":"A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.","pos":[3891,3996]},{"content":"Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.","pos":[3997,4150]},{"content":"A query expression must begin with a <bpt id=\"p1\">[</bpt>from<ept id=\"p1\">](../language-reference/keywords/from-clause.md)</ept> clause and must end with a <bpt id=\"p2\">[</bpt>select<ept id=\"p2\">](../language-reference/keywords/select-clause.md)</ept> or <bpt id=\"p3\">[</bpt>group<ept id=\"p3\">](../language-reference/keywords/group-clause.md)</ept> clause.","pos":[4157,4399],"source":"A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause."},{"content":"Between the first <ph id=\"ph1\">`from`</ph> clause and the last <ph id=\"ph2\">`select`</ph> or <ph id=\"ph3\">`group`</ph> clause, it can contain one or more of these optional clauses: <bpt id=\"p1\">[</bpt>where<ept id=\"p1\">](../language-reference/keywords/where-clause.md)</ept>, <bpt id=\"p2\">[</bpt>orderby<ept id=\"p2\">](../language-reference/keywords/orderby-clause.md)</ept>, <bpt id=\"p3\">[</bpt>join<ept id=\"p3\">](../language-reference/keywords/join-clause.md)</ept>, <bpt id=\"p4\">[</bpt>let<ept id=\"p4\">](../language-reference/keywords/let-clause.md)</ept> and even additional <bpt id=\"p5\">[</bpt>from<ept id=\"p5\">](../language-reference/keywords/from-clause.md)</ept> clauses.","pos":[4400,4834],"source":" Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses."},{"content":"You can also use the <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](../language-reference/keywords/into.md)</ept> keyword to enable the result of a <ph id=\"ph1\">`join`</ph> or <ph id=\"ph2\">`group`</ph> clause to serve as the source for additional query clauses in the same query expression.","pos":[4835,5043],"source":" You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression."},{"pos":[5053,5067],"content":"Query variable","linkify":"Query variable","nodes":[{"content":"Query variable","pos":[0,14]}]},{"content":"In LINQ, a query variable is any variable that stores a <bpt id=\"p1\">*</bpt>query<ept id=\"p1\">*</ept> instead of the <bpt id=\"p2\">*</bpt>results<ept id=\"p2\">*</ept> of a query.","pos":[5073,5173],"source":"In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query."},{"content":"More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a <ph id=\"ph1\">`foreach`</ph> statement or a direct call to its <ph id=\"ph2\">`IEnumerator.MoveNext`</ph> method.","pos":[5174,5384],"source":" More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method."},{"content":"The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.","pos":[5391,5560]},{"content":"The <ph id=\"ph1\">`select`</ph> clause ends the query.","pos":[5561,5596],"source":" The `select` clause ends the query."},{"pos":[5603,5714],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#49<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#49](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]"},{"content":"In the previous example, <ph id=\"ph1\">`scoreQuery`</ph> is a <bpt id=\"p1\">*</bpt>query variable,<ept id=\"p1\">*</ept> which is sometimes referred to as just a <bpt id=\"p2\">*</bpt>query<ept id=\"p2\">*</ept>.","pos":[5721,5831],"source":"In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*."},{"content":"The query variable stores no actual result data, which is produced in the <ph id=\"ph1\">`foreach`</ph> loop.","pos":[5832,5921],"source":" The query variable stores no actual result data, which is produced in the `foreach` loop."},{"content":"And when the <ph id=\"ph1\">`foreach`</ph> statement executes, the query results are not returned through the query variable <ph id=\"ph2\">`scoreQuery`</ph>.","pos":[5922,6040],"source":" And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`."},{"content":"Rather, they are returned through the iteration variable <ph id=\"ph1\">`testScore`</ph>.","pos":[6041,6110],"source":" Rather, they are returned through the iteration variable `testScore`."},{"content":"The <ph id=\"ph1\">`scoreQuery`</ph> variable can be iterated in a second <ph id=\"ph2\">`foreach`</ph> loop.","pos":[6111,6180],"source":" The `scoreQuery` variable can be iterated in a second `foreach` loop."},{"content":"It will produce the same results as long as neither it nor the data source has been modified.","pos":[6181,6274]},{"content":"A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.","pos":[6281,6396]},{"content":"In the following examples, both <ph id=\"ph1\">`queryMajorCities`</ph> and <ph id=\"ph2\">`queryMajorCities2`</ph> are query variables:","pos":[6397,6492],"source":" In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:"},{"pos":[6499,6610],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#50<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#50](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]"},{"content":"On the other hand, the following two examples show variables that are not query variables even through each is initialized with a query.","pos":[6617,6753]},{"content":"They are not query variables because they store results:","pos":[6754,6810]},{"pos":[6817,6928],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#51<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#51](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]"},{"pos":[6935,7124],"content":"For more information about the different ways to express queries, see <bpt id=\"p1\">[</bpt>Query syntax and method syntax in LINQ<ept id=\"p1\">](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)</ept>.","source":"For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)."},{"pos":[7135,7182],"content":"Explicit and implicit typing of query variables","linkify":"Explicit and implicit typing of query variables","nodes":[{"content":"Explicit and implicit typing of query variables","pos":[0,47]}]},{"content":"This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the <bpt id=\"p1\">[</bpt>select clause<ept id=\"p1\">](../language-reference/keywords/select-clause.md)</ept>.","pos":[7188,7403],"source":"This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md)."},{"content":"However, you can also use the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../language-reference/keywords/var.md)</ept> keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.","pos":[7404,7596],"source":" However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time."},{"content":"For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:","pos":[7597,7715]},{"pos":[7722,7833],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#52<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#52](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]"},{"pos":[7840,8112],"content":"For more information, see <bpt id=\"p1\">[</bpt>Implicitly typed local variables<ept id=\"p1\">](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md)</ept> and <bpt id=\"p2\">[</bpt>Type relationships in LINQ query operations<ept id=\"p2\">](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md)</ept>.","source":"For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md)."},{"pos":[8122,8149],"content":"Starting a query expression","linkify":"Starting a query expression","nodes":[{"content":"Starting a query expression","pos":[0,27]}]},{"content":"A query expression must begin with a <ph id=\"ph1\">`from`</ph> clause.","pos":[8155,8206],"source":"A query expression must begin with a `from` clause."},{"content":"It specifies a data source together with a range variable.","pos":[8207,8265]},{"content":"The range variable represents each successive element in the source sequence as the source sequence is being traversed.","pos":[8266,8385]},{"content":"The range variable is strongly typed based on the type of elements in the data source.","pos":[8386,8472]},{"content":"In the following example, because <ph id=\"ph1\">`countries`</ph> is an array of <ph id=\"ph2\">`Country`</ph> objects, the range variable is also typed as <ph id=\"ph3\">`Country`</ph>.","pos":[8473,8599],"source":" In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`."},{"content":"Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.","pos":[8600,8719]},{"pos":[8726,8837],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#53<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#53](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]"},{"pos":[8844,8957],"content":"The range variable is in scope until the query is exited either with a semicolon or with a <bpt id=\"p1\">*</bpt>continuation<ept id=\"p1\">*</ept> clause.","source":"The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause."},{"content":"A query expression may contain multiple <ph id=\"ph1\">`from`</ph> clauses.","pos":[8964,9019],"source":"A query expression may contain multiple `from` clauses."},{"content":"Use additional <ph id=\"ph1\">`from`</ph> clauses when each element in the source sequence is itself a collection or contains a collection.","pos":[9020,9139],"source":" Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection."},{"content":"For example, assume that you have a collection of <ph id=\"ph1\">`Country`</ph> objects, each of which contains a collection of <ph id=\"ph2\">`City`</ph> objects named <ph id=\"ph3\">`Cities`</ph>.","pos":[9140,9278],"source":" For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`."},{"content":"To query the <ph id=\"ph1\">`City`</ph> objects in each <ph id=\"ph2\">`Country`</ph>, use two <ph id=\"ph3\">`from`</ph> clauses as shown here:","pos":[9279,9363],"source":" To query the `City` objects in each `Country`, use two `from` clauses as shown here:"},{"pos":[9370,9482],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#54<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#54](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]"},{"pos":[9489,9576],"content":"For more information, see <bpt id=\"p1\">[</bpt>from clause<ept id=\"p1\">](../language-reference/keywords/from-clause.md)</ept>.","source":"For more information, see [from clause](../language-reference/keywords/from-clause.md)."},{"pos":[9586,9611],"content":"Ending a query expression","linkify":"Ending a query expression","nodes":[{"content":"Ending a query expression","pos":[0,25]}]},{"pos":[9617,9695],"content":"A query expression must end with either a <ph id=\"ph1\">`group`</ph> clause or a <ph id=\"ph2\">`select`</ph> clause.","source":"A query expression must end with either a `group` clause or a `select` clause."},{"pos":[9706,9718],"content":"group clause","linkify":"group clause","nodes":[{"content":"group clause","pos":[0,12]}]},{"content":"Use the <ph id=\"ph1\">`group`</ph> clause to produce a sequence of groups organized by a key that you specify.","pos":[9724,9815],"source":"Use the `group` clause to produce a sequence of groups organized by a key that you specify."},{"content":"The key can be any data type.","pos":[9816,9845]},{"content":"For example, the following query creates a sequence of groups that contains one or more <ph id=\"ph1\">`Country`</ph> objects and whose key is a <ph id=\"ph2\">`char`</ph> value.","pos":[9846,9984],"source":" For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value."},{"pos":[9991,10103],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#55<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#55](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]"},{"pos":[10110,10214],"content":"For more information about grouping, see <bpt id=\"p1\">[</bpt>group clause<ept id=\"p1\">](../language-reference/keywords/group-clause.md)</ept>.","source":"For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md)."},{"pos":[10225,10238],"content":"select clause","linkify":"select clause","nodes":[{"content":"select clause","pos":[0,13]}]},{"content":"Use the <ph id=\"ph1\">`select`</ph> clause to produce all other types of sequences.","pos":[10242,10306],"source":"Use the `select` clause to produce all other types of sequences."},{"content":"A simple <ph id=\"ph1\">`select`</ph> clause just produces a sequence of the same type of objects as the objects that are contained in the data source.","pos":[10307,10438],"source":" A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source."},{"content":"In this example, the data source contains <ph id=\"ph1\">`Country`</ph> objects.","pos":[10439,10499],"source":" In this example, the data source contains `Country` objects."},{"content":"The <ph id=\"ph1\">`orderby`</ph> clause just sorts the elements into a new order and the <ph id=\"ph2\">`select`</ph> clause produces a sequence of the reordered <ph id=\"ph3\">`Country`</ph> objects.","pos":[10500,10641],"source":" The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects."},{"pos":[10648,10760],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#56<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#56](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]"},{"content":"The <ph id=\"ph1\">`select`</ph> clause can be used to transform source data into sequences of new types.","pos":[10767,10852],"source":"The `select` clause can be used to transform source data into sequences of new types."},{"content":"This transformation is also named a <bpt id=\"p1\">*</bpt>projection<ept id=\"p1\">*</ept>.","pos":[10853,10902],"source":" This transformation is also named a *projection*."},{"content":"In the following example, the <ph id=\"ph1\">`select`</ph> clause <bpt id=\"p1\">*</bpt>projects<ept id=\"p1\">*</ept> a sequence of anonymous types which contains only a subset of the fields in the original element.","pos":[10903,11057],"source":" In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element."},{"content":"Note that the new objects are initialized by using an object initializer.","pos":[11058,11131]},{"pos":[11138,11250],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#57<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#57](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]"},{"pos":[11257,11427],"content":"For more information about all the ways that a <ph id=\"ph1\">`select`</ph> clause can be used to transform source data, see <bpt id=\"p1\">[</bpt>select clause<ept id=\"p1\">](../language-reference/keywords/select-clause.md)</ept>.","source":"For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md)."},{"pos":[11438,11463],"content":"Continuations with \"into\"","linkify":"Continuations with \"into\"","nodes":[{"content":"Continuations with \"into\"","pos":[0,25]}]},{"content":"You can use the <ph id=\"ph1\">`into`</ph> keyword in a <ph id=\"ph2\">`select`</ph> or <ph id=\"ph3\">`group`</ph> clause to create a temporary identifier that stores a query.","pos":[11469,11585],"source":"You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query."},{"content":"Do this when you must perform additional query operations on a query after a grouping or select operation.","pos":[11586,11692]},{"content":"In the following example <ph id=\"ph1\">`countries`</ph> are grouped according to population in ranges of 10 million.","pos":[11693,11790],"source":" In the following example `countries` are grouped according to population in ranges of 10 million."},{"content":"After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.","pos":[11791,11913]},{"content":"To perform those additional operations, the continuation represented by <ph id=\"ph1\">`countryGroup`</ph> is required.","pos":[11914,12013],"source":" To perform those additional operations, the continuation represented by `countryGroup` is required."},{"pos":[12020,12132],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#58<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#58](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]"},{"pos":[12139,12212],"content":"For more information, see <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](../language-reference/keywords/into.md)</ept>.","source":"For more information, see [into](../language-reference/keywords/into.md)."},{"pos":[12222,12254],"content":"Filtering, ordering, and joining","linkify":"Filtering, ordering, and joining","nodes":[{"content":"Filtering, ordering, and joining","pos":[0,32]}]},{"content":"Between the starting <ph id=\"ph1\">`from`</ph> clause, and the ending <ph id=\"ph2\">`select`</ph> or <ph id=\"ph3\">`group`</ph> clause, all other clauses (<ph id=\"ph4\">`where`</ph>, <ph id=\"ph5\">`join`</ph>, <ph id=\"ph6\">`orderby`</ph>, <ph id=\"ph7\">`from`</ph>, <ph id=\"ph8\">`let`</ph>) are optional.","pos":[12257,12411],"source":"Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional."},{"content":"Any of the optional clauses may be used zero times or multiple times in a query body.","pos":[12412,12497]},{"pos":[12508,12520],"content":"where clause","linkify":"where clause","nodes":[{"content":"where clause","pos":[0,12]}]},{"content":"Use the <ph id=\"ph1\">`where`</ph> clause to filter out elements from the source data based on one or more predicate expressions.","pos":[12525,12635],"source":"Use the `where` clause to filter out elements from the source data based on one or more predicate expressions."},{"content":"The <ph id=\"ph1\">`where`</ph> clause in the following example has one predicate with two conditions.","pos":[12636,12718],"source":" The `where` clause in the following example has one predicate with two conditions."},{"pos":[12725,12837],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#59<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#59](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]"},{"pos":[12844,12933],"content":"For more information, see <bpt id=\"p1\">[</bpt>where clause<ept id=\"p1\">](../language-reference/keywords/where-clause.md)</ept>.","source":"For more information, see [where clause](../language-reference/keywords/where-clause.md)."},{"pos":[12944,12958],"content":"orderby clause","linkify":"orderby clause","nodes":[{"content":"orderby clause","pos":[0,14]}]},{"content":"Use the <ph id=\"ph1\">`orderby`</ph> clause to sort the results in either ascending or descending order.","pos":[12961,13046],"source":"Use the `orderby` clause to sort the results in either ascending or descending order."},{"content":"You can also specify secondary sort orders.","pos":[13047,13090]},{"content":"The following example performs a primary sort on the <ph id=\"ph1\">`country`</ph> objects by using the <ph id=\"ph2\">`Area`</ph> property.","pos":[13091,13191],"source":" The following example performs a primary sort on the `country` objects by using the `Area` property."},{"content":"It then performs a secondary sort by using the <ph id=\"ph1\">`Population`</ph> property.","pos":[13192,13261],"source":" It then performs a secondary sort by using the `Population` property."},{"pos":[13268,13380],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#60<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#60](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]"},{"content":"The <ph id=\"ph1\">`ascending`</ph> keyword is optional; it is the default sort order if no order is specified.","pos":[13387,13478],"source":"The `ascending` keyword is optional; it is the default sort order if no order is specified."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>orderby clause<ept id=\"p1\">](../language-reference/keywords/orderby-clause.md)</ept>.","pos":[13479,13572],"source":" For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md)."},{"pos":[13583,13594],"content":"join clause","linkify":"join clause","nodes":[{"content":"join clause","pos":[0,11]}]},{"content":"Use the <ph id=\"ph1\">`join`</ph> clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.","pos":[13597,13787],"source":"Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element."},{"content":"In LINQ, join operations are performed on sequences of objects whose elements are different types.","pos":[13788,13886]},{"content":"After you have joined two sequences, you must use a <ph id=\"ph1\">`select`</ph> or <ph id=\"ph2\">`group`</ph> statement to specify which element to store in the output sequence.","pos":[13887,14026],"source":" After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence."},{"content":"You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.","pos":[14027,14161]},{"content":"The following example associates <ph id=\"ph1\">`prod`</ph> objects whose <ph id=\"ph2\">`Category`</ph> property matches one of the categories in the <ph id=\"ph3\">`categories`</ph> string array.","pos":[14162,14299],"source":" The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array."},{"content":"Products whose <ph id=\"ph1\">`Category`</ph> does not match any string in <ph id=\"ph2\">`categories`</ph> are filtered out.","pos":[14300,14385],"source":" Products whose `Category` does not match any string in `categories` are filtered out."},{"content":"The <ph id=\"ph1\">`select`</ph> statement projects a new type whose properties are taken from both <ph id=\"ph2\">`cat`</ph> and <ph id=\"ph3\">`prod`</ph>.","pos":[14386,14483],"source":" The `select` statement projects a new type whose properties are taken from both `cat` and `prod`."},{"pos":[14490,14602],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#61<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#61](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]"},{"content":"You can also perform a group join by storing the results of the <ph id=\"ph1\">`join`</ph> operation into a temporary variable by using the <bpt id=\"p1\">[</bpt>into<ept id=\"p1\">](../language-reference/keywords/into.md)</ept> keyword.","pos":[14609,14784],"source":"You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>join clause<ept id=\"p1\">](../language-reference/keywords/join-clause.md)</ept>.","pos":[14785,14872],"source":" For more information, see [join clause](../language-reference/keywords/join-clause.md)."},{"pos":[14883,14893],"content":"let clause","linkify":"let clause","nodes":[{"content":"let clause","pos":[0,10]}]},{"content":"Use the <ph id=\"ph1\">`let`</ph> clause to store the result of an expression, such as a method call, in a new range variable.","pos":[14897,15003],"source":"Use the `let` clause to store the result of an expression, such as a method call, in a new range variable."},{"content":"In the following example, the range variable <ph id=\"ph1\">`firstName`</ph> stores the first element of the array of strings that is returned by <ph id=\"ph2\">`Split`</ph>.","pos":[15004,15138],"source":" In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`."},{"pos":[15145,15257],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#62<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#62](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]"},{"pos":[15264,15349],"content":"For more information, see <bpt id=\"p1\">[</bpt>let clause<ept id=\"p1\">](../language-reference/keywords/let-clause.md)</ept>.","source":"For more information, see [let clause](../language-reference/keywords/let-clause.md)."},{"pos":[15359,15391],"content":"Subqueries in a query expression","linkify":"Subqueries in a query expression","nodes":[{"content":"Subqueries in a query expression","pos":[0,32]}]},{"content":"A query clause may itself contain a query expression, which is sometimes referred to as a <bpt id=\"p1\">*</bpt>subquery<ept id=\"p1\">*</ept>.","pos":[15396,15497],"source":"A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*."},{"content":"Each subquery starts with its own <ph id=\"ph1\">`from`</ph> clause that does not necessarily point to the same data source in the first <ph id=\"ph2\">`from`</ph> clause.","pos":[15498,15629],"source":" Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause."},{"content":"For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.","pos":[15630,15773]},{"pos":[15780,15892],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>csrefQueryExpBasics#63<ept id=\"p2\">](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[csrefQueryExpBasics#63](../../../samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]"},{"pos":[15899,16025],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: perform a subquery on a grouping operation<ept id=\"p1\">](perform-a-subquery-on-a-grouping-operation.md)</ept>.","source":"For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md)."},{"pos":[16034,16042],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# programming guide<ept id=\"p1\">](../programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[16046,16100],"source":"[C# programming guide](../programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>LINQ query expressions<ept id=\"p1\">](index.md)</ept><ph id=\"ph1\"> </ph>","pos":[16104,16139],"source":"[LINQ query expressions](index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Query keywords (LINQ)<ept id=\"p1\">](../language-reference/keywords/query-keywords.md)</ept><ph id=\"ph1\"> </ph>","pos":[16143,16217],"source":"[Query keywords (LINQ)](../language-reference/keywords/query-keywords.md) "},{"content":"<bpt id=\"p1\">[</bpt>Standard query operators overview<ept id=\"p1\">](../programming-guide/concepts/linq/standard-query-operators-overview.md)</ept>","pos":[16221,16329],"source":"[Standard query operators overview](../programming-guide/concepts/linq/standard-query-operators-overview.md)"}]}