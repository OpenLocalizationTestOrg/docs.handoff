{"content":"---\ntitle: \"from clause (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"from_CSharpKeyword\"\n  - \"from\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"from clause [C#]\"\n  - \"from keyword [C#]\"\nms.assetid: 1aefd18c-1314-47f8-99ec-9bcefb09e699\ncaps.latest.revision: 27\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# from clause (C# Reference)\nA query expression must begin with a `from` clause. Additionally, a query expression can contain sub-queries, which also begin with a `from` clause. The `from` clause specifies the following:  \n  \n-   The data source on which the query or sub-query will be run.  \n  \n-   A local *range variable* that represents each element in the source sequence.  \n  \n Both the range variable and the data source are strongly typed. The data source referenced in the `from` clause must have a type of <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, or a derived type such as <xref:System.Linq.IQueryable%601>.  \n  \n In the following example, `numbers` is the data source and `num` is the range variable. Note that both variables are strongly typed even through the [var](../../../csharp/language-reference/keywords/var.md) keyword is used.  \n  \n [!code-cs[cscsrefQueryKeywords#1](../../../csharp/language-reference/keywords/codesnippet/CSharp/from-clause_1.cs)]  \n  \n## The Range Variable  \n The compiler infers the type of the range variable when the data source implements <xref:System.Collections.Generic.IEnumerable%601>. For example, if the source has a type of `IEnumerable<Customer>`, then the range variable is inferred to be `Customer`. The only time that you must specify the type explicitly is when the source is a non-generic `IEnumerable` type such as <xref:System.Collections.ArrayList>. For more information, see [How to: Query an ArrayList with LINQ](http://msdn.microsoft.com/library/c318b79a-fa4d-4de3-b62d-c1162beb267e).  \n  \n In the previous example `num` is inferred to be of type `int`. Because the range variable is strongly typed, you can call methods on it or use it in other operations. For example, instead of writing `select num`, you could write `select num.ToString()` to cause the query expression to return a sequence of strings instead of integers. Or you could write `select n + 10` to cause the expression to return the sequence 14, 11, 13, 12, 10. For more information, see [select clause](../../../csharp/language-reference/keywords/select-clause.md).  \n  \n The range variable is like an iteration variable in a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statement except for one very important difference: a range variable never actually stores data from the source. It just a syntactic convenience that enables the query to describe what will occur when the query is executed. For more information, see [Introduction to LINQ Queries (C#)](../../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md).  \n  \n## Compound from Clauses  \n In some cases, each element in the source sequence may itself be either a sequence or contain a sequence. For example, your data source may be an `IEnumerable<Student>` where each student object in the sequence contains a list of test scores. To access the inner list within each `Student` element, you can use compound `from` clauses. The technique is like using nested [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statements. You can add [where](../../../csharp/language-reference/keywords/partial-method.md) or [orderby](../../../csharp/language-reference/keywords/orderby-clause.md) clauses to either `from` clause to filter the results. The following example shows a sequence of `Student` objects, each of which contains an inner `List` of integers representing test scores. To access the inner list, use a compound `from` clause. You can insert clauses between the two `from` clauses if necessary.  \n  \n [!code-cs[cscsrefQueryKeywords#2](../../../csharp/language-reference/keywords/codesnippet/CSharp/from-clause_2.cs)]  \n  \n## Using Multiple from Clauses to Perform Joins  \n A compound `from` clause is used to access inner collections in a single data source. However, a query can also contain multiple `from` clauses that generate supplemental queries from independent data sources. This technique enables you to perform certain types of join operations that are not possible by using the [join clause](../../../csharp/language-reference/keywords/join-clause.md).  \n  \n The following example shows how two `from` clauses can be used to form a complete cross join of two data sources.  \n  \n [!code-cs[cscsrefQueryKeywords#3](../../../csharp/language-reference/keywords/codesnippet/CSharp/from-clause_3.cs)]  \n  \n For more information about join operations that use multiple `from` clauses, see [How to: Perform Custom Join Operations](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-custom-join-operations.md).  \n  \n## See Also  \n [Query Keywords (LINQ)](../../../csharp/language-reference/keywords/query-keywords.md)   \n [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md)","nodes":[{"pos":[4,590],"embed":true,"restype":"x-metadata","content":"title: \"from clause (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"from_CSharpKeyword\"\n  - \"from\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"from clause [C#]\"\n  - \"from keyword [C#]\"\nms.assetid: 1aefd18c-1314-47f8-99ec-9bcefb09e699\ncaps.latest.revision: 27\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","nodes":[{"content":"from clause (C# Reference) | Microsoft Docs","nodes":[{"pos":[0,43],"content":"from clause (C# Reference) | Microsoft Docs","nodes":[{"content":"from clause (C# Reference) | Microsoft Docs","pos":[0,43]}]}],"path":["title"]}],"yml":true},{"pos":[597,623],"content":"from clause (C# Reference)","linkify":"from clause (C# Reference)","nodes":[{"content":"from clause (C# Reference)","pos":[0,26]}]},{"content":"A query expression must begin with a <ph id=\"ph1\">`from`</ph> clause.","pos":[624,675],"source":"A query expression must begin with a `from` clause."},{"content":"Additionally, a query expression can contain sub-queries, which also begin with a <ph id=\"ph1\">`from`</ph> clause.","pos":[676,772],"source":" Additionally, a query expression can contain sub-queries, which also begin with a `from` clause."},{"content":"The <ph id=\"ph1\">`from`</ph> clause specifies the following:","pos":[773,815],"source":" The `from` clause specifies the following:"},{"content":"The data source on which the query or sub-query will be run.","pos":[825,885]},{"pos":[895,972],"content":"A local <bpt id=\"p1\">*</bpt>range variable<ept id=\"p1\">*</ept> that represents each element in the source sequence.","source":"A local *range variable* that represents each element in the source sequence."},{"content":"Both the range variable and the data source are strongly typed.","pos":[979,1042]},{"content":"The data source referenced in the <ph id=\"ph1\">`from`</ph> clause must have a type of <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, or a derived type such as <ph id=\"ph4\">&lt;xref:System.Linq.IQueryable%601&gt;</ph>.","pos":[1043,1261],"source":" The data source referenced in the `from` clause must have a type of <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, or a derived type such as <xref:System.Linq.IQueryable%601>."},{"content":"In the following example, <ph id=\"ph1\">`numbers`</ph> is the data source and <ph id=\"ph2\">`num`</ph> is the range variable.","pos":[1268,1355],"source":"In the following example, `numbers` is the data source and `num` is the range variable."},{"content":"Note that both variables are strongly typed even through the <bpt id=\"p1\">[</bpt>var<ept id=\"p1\">](../../../csharp/language-reference/keywords/var.md)</ept> keyword is used.","pos":[1356,1491],"source":" Note that both variables are strongly typed even through the [var](../../../csharp/language-reference/keywords/var.md) keyword is used."},{"pos":[1622,1640],"content":"The Range Variable","linkify":"The Range Variable","nodes":[{"content":"The Range Variable","pos":[0,18]}]},{"content":"The compiler infers the type of the range variable when the data source implements <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[1644,1777],"source":"The compiler infers the type of the range variable when the data source implements <xref:System.Collections.Generic.IEnumerable%601>."},{"content":"For example, if the source has a type of <ph id=\"ph1\">`IEnumerable&lt;Customer&gt;`</ph>, then the range variable is inferred to be <ph id=\"ph2\">`Customer`</ph>.","pos":[1778,1897],"source":" For example, if the source has a type of `IEnumerable<Customer>`, then the range variable is inferred to be `Customer`."},{"content":"The only time that you must specify the type explicitly is when the source is a non-generic <ph id=\"ph1\">`IEnumerable`</ph> type such as <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>.","pos":[1898,2053],"source":" The only time that you must specify the type explicitly is when the source is a non-generic `IEnumerable` type such as <xref:System.Collections.ArrayList>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Query an ArrayList with LINQ<ept id=\"p1\">](http://msdn.microsoft.com/library/c318b79a-fa4d-4de3-b62d-c1162beb267e)</ept>.","pos":[2054,2191],"source":" For more information, see [How to: Query an ArrayList with LINQ](http://msdn.microsoft.com/library/c318b79a-fa4d-4de3-b62d-c1162beb267e)."},{"content":"In the previous example <ph id=\"ph1\">`num`</ph> is inferred to be of type <ph id=\"ph2\">`int`</ph>.","pos":[2198,2260],"source":"In the previous example `num` is inferred to be of type `int`."},{"content":"Because the range variable is strongly typed, you can call methods on it or use it in other operations.","pos":[2261,2364]},{"content":"For example, instead of writing <ph id=\"ph1\">`select num`</ph>, you could write <ph id=\"ph2\">`select num.ToString()`</ph> to cause the query expression to return a sequence of strings instead of integers.","pos":[2365,2533],"source":" For example, instead of writing `select num`, you could write `select num.ToString()` to cause the query expression to return a sequence of strings instead of integers."},{"content":"Or you could write <ph id=\"ph1\">`select n + 10`</ph> to cause the expression to return the sequence 14, 11, 13, 12, 10.","pos":[2534,2635],"source":" Or you could write `select n + 10` to cause the expression to return the sequence 14, 11, 13, 12, 10."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>select clause<ept id=\"p1\">](../../../csharp/language-reference/keywords/select-clause.md)</ept>.","pos":[2636,2740],"source":" For more information, see [select clause](../../../csharp/language-reference/keywords/select-clause.md)."},{"content":"The range variable is like an iteration variable in a <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> statement except for one very important difference: a range variable never actually stores data from the source.","pos":[2747,2982],"source":"The range variable is like an iteration variable in a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statement except for one very important difference: a range variable never actually stores data from the source."},{"content":"It just a syntactic convenience that enables the query to describe what will occur when the query is executed.","pos":[2983,3093]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Introduction to LINQ Queries (C#)<ept id=\"p1\">](../../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md)</ept>.","pos":[3094,3237],"source":" For more information, see [Introduction to LINQ Queries (C#)](../../../csharp/programming-guide/concepts/linq/introduction-to-linq-queries.md)."},{"pos":[3246,3267],"content":"Compound from Clauses","linkify":"Compound from Clauses","nodes":[{"content":"Compound from Clauses","pos":[0,21]}]},{"content":"In some cases, each element in the source sequence may itself be either a sequence or contain a sequence.","pos":[3271,3376]},{"content":"For example, your data source may be an <ph id=\"ph1\">`IEnumerable&lt;Student&gt;`</ph> where each student object in the sequence contains a list of test scores.","pos":[3377,3513],"source":" For example, your data source may be an `IEnumerable<Student>` where each student object in the sequence contains a list of test scores."},{"content":"To access the inner list within each <ph id=\"ph1\">`Student`</ph> element, you can use compound <ph id=\"ph2\">`from`</ph> clauses.","pos":[3514,3606],"source":" To access the inner list within each `Student` element, you can use compound `from` clauses."},{"content":"The technique is like using nested <bpt id=\"p1\">[</bpt>foreach<ept id=\"p1\">](../../../csharp/language-reference/keywords/foreach-in.md)</ept> statements.","pos":[3607,3722],"source":" The technique is like using nested [foreach](../../../csharp/language-reference/keywords/foreach-in.md) statements."},{"content":"You can add <bpt id=\"p1\">[</bpt>where<ept id=\"p1\">](../../../csharp/language-reference/keywords/partial-method.md)</ept> or <bpt id=\"p2\">[</bpt>orderby<ept id=\"p2\">](../../../csharp/language-reference/keywords/orderby-clause.md)</ept> clauses to either <ph id=\"ph1\">`from`</ph> clause to filter the results.","pos":[3723,3936],"source":" You can add [where](../../../csharp/language-reference/keywords/partial-method.md) or [orderby](../../../csharp/language-reference/keywords/orderby-clause.md) clauses to either `from` clause to filter the results."},{"content":"The following example shows a sequence of <ph id=\"ph1\">`Student`</ph> objects, each of which contains an inner <ph id=\"ph2\">`List`</ph> of integers representing test scores.","pos":[3937,4074],"source":" The following example shows a sequence of `Student` objects, each of which contains an inner `List` of integers representing test scores."},{"content":"To access the inner list, use a compound <ph id=\"ph1\">`from`</ph> clause.","pos":[4075,4130],"source":" To access the inner list, use a compound `from` clause."},{"content":"You can insert clauses between the two <ph id=\"ph1\">`from`</ph> clauses if necessary.","pos":[4131,4198],"source":" You can insert clauses between the two `from` clauses if necessary."},{"pos":[4329,4373],"content":"Using Multiple from Clauses to Perform Joins","linkify":"Using Multiple from Clauses to Perform Joins","nodes":[{"content":"Using Multiple from Clauses to Perform Joins","pos":[0,44]}]},{"content":"A compound <ph id=\"ph1\">`from`</ph> clause is used to access inner collections in a single data source.","pos":[4377,4462],"source":"A compound `from` clause is used to access inner collections in a single data source."},{"content":"However, a query can also contain multiple <ph id=\"ph1\">`from`</ph> clauses that generate supplemental queries from independent data sources.","pos":[4463,4586],"source":" However, a query can also contain multiple `from` clauses that generate supplemental queries from independent data sources."},{"content":"This technique enables you to perform certain types of join operations that are not possible by using the <bpt id=\"p1\">[</bpt>join clause<ept id=\"p1\">](../../../csharp/language-reference/keywords/join-clause.md)</ept>.","pos":[4587,4767],"source":" This technique enables you to perform certain types of join operations that are not possible by using the [join clause](../../../csharp/language-reference/keywords/join-clause.md)."},{"pos":[4774,4887],"content":"The following example shows how two <ph id=\"ph1\">`from`</ph> clauses can be used to form a complete cross join of two data sources.","source":"The following example shows how two `from` clauses can be used to form a complete cross join of two data sources."},{"pos":[5016,5237],"content":"For more information about join operations that use multiple <ph id=\"ph1\">`from`</ph> clauses, see <bpt id=\"p1\">[</bpt>How to: Perform Custom Join Operations<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-custom-join-operations.md)</ept>.","source":"For more information about join operations that use multiple `from` clauses, see [How to: Perform Custom Join Operations](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-custom-join-operations.md)."},{"pos":[5246,5254],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Query Keywords (LINQ)<ept id=\"p1\">](../../../csharp/language-reference/keywords/query-keywords.md)</ept><ph id=\"ph1\"> </ph>","pos":[5258,5345],"source":"[Query Keywords (LINQ)](../../../csharp/language-reference/keywords/query-keywords.md) "},{"content":"<bpt id=\"p1\">[</bpt>LINQ Query Expressions<ept id=\"p1\">](../../../csharp/programming-guide/linq-query-expressions/index.md)</ept>","pos":[5349,5440],"source":"[LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md)"}]}