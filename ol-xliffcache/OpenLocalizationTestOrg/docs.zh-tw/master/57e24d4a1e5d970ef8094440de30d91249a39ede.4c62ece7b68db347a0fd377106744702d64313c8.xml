{"content":"---\ntitle: \"Type Converters for XAML Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"XAML [XAML Services], type converters\"\n  - \"XAML [XAML Services], TypeConverter\"\n  - \"type conversion for XAML [XAML Services]\"\nms.assetid: 51a65860-efcb-4fe0-95a0-1c679cde66b7\ncaps.latest.revision: 14\nauthor: \"wadepickett\"\nms.author: \"wpickett\"\nmanager: \"wpickett\"\n---\n# Type Converters for XAML Overview\nType converters supply logic for an object writer that converts from a string in XAML markup into particular objects in an object graph. In .NET Framework XAML Services, the type converter must be a class that derives from <xref:System.ComponentModel.TypeConverter>. Some converters also support the XAML save path and can be used to serialize an object into a string form in serialization markup. This topic describes how and when type converters in XAML are invoked, and provides implementation advice for the method overrides of <xref:System.ComponentModel.TypeConverter>.  \n  \n<a name=\"type_conversion_concepts\"></a>   \n## Type Conversion Concepts  \n The following sections explain basic concepts about how XAML uses strings, and how object writers in .NET Framework XAML Services use type converters to process some of the string values that are encountered in a XAML source.  \n  \n### XAML and String Values  \n When you set an attribute value in a XAML file, the initial type of that value is a string in a general sense, and a string attribute value in an XML sense. Even other primitives such as <xref:System.Double> are initially strings to a XAML processor.  \n  \n In most cases, a XAML processor needs two pieces of information to process an attribute value. The first piece of information is the value type of the property that is being set. Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type. If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted. If the value for the attribute references an enumeration, the supplied string is checked for a name match to a named constant in that enumeration. If the value is neither a parser-understood primitive nor a constant name from an enumeration, the applicable type must be able to provide a value or reference that is based on a converted string.  \n  \n> [!NOTE]\n>  XAML language directives do not use type converters.  \n  \n### Type Converters and Markup Extensions  \n Markup extension usages must be handled by a XAML processor before it checks for property type and other considerations. For example, if a property being set as an attribute normally has a type conversion, but in a particular case is set by a markup extension usage, then the markup extension behavior processes first. One common situation where a markup extension is necessary is to make a reference to an object that already exists. For this scenario, a stateless type converter can only generate a new instance, which might not be desirable. For more information about markup extensions, see [Markup Extensions for XAML Overview](../../../docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).  \n  \n### Native Type Converters  \n In the WPF and .NET XAML services implementations, there are certain CLR types that have native type conversion handling, however, hose CLR types are not conventionally thought of as primitives. An example of such a type is <xref:System.DateTime>. One reason for this is how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET. <xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System); therefore, the usual type converter discovery mechanism by attributing cannot be supported. Instead, the XAML parser has a list of types that need native processing, and it processes these types similar to how the true primitives are processed. In the case of <xref:System.DateTime>, this processing involves a call to <xref:System.DateTime.Parse%2A>.  \n  \n<a name=\"Implementing_a_Type_Converter\"></a>   \n## Implementing a Type Converter  \n The following sections discuss the API of the <xref:System.ComponentModel.TypeConverter> class.  \n  \n### TypeConverter  \n Under .NET Framework XAML Services, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>. The <xref:System.ComponentModel.TypeConverter> class existed in versions of the .NET Framework before XAML existed; one of the original <xref:System.ComponentModel.TypeConverter> scenarios was to provide string conversion for property editors in visual designers.  \n  \n For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded. For XAML purposes, <xref:System.ComponentModel.TypeConverter> is the base class for providing support for certain to-string and from-string conversions. From-string enables parsing a string attribute value from XAML. To-string might enable processing a run-time value of a particular object property back into an attribute in XAML for serialization.  \n  \n <xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to-string and from-string for XAML processing purposes:  \n  \n-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  \n  \n-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  \n  \n-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  \n  \n-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  \n  \n Of these members, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>, which converts the input string to the required object type. The <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method can be implemented to convert a wider range of types into the intended destination type of the converter. Therefore, it can serve purposes that extend beyond XAML, such as supporting run-time conversions. However, for XAML use, only the code path that can process a <xref:System.String> input is important.  \n  \n The second most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>. If an application is converted to a markup representation (for example, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is involved in the larger scenario of a XAML text writers produce a markup representation. In this case, the important code path for XAML is when the caller passes a `destinationType` of <xref:System.String>.  \n  \n <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation. You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support. For XAML purposes, this generally means the <xref:System.String> type.  \n  \n### Culture Information and Type Converters for XAML  \n Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what is a valid string for a conversion, and it can also use or ignore the type description that is passed as parameters. An important consideration for culture and XAML type conversion is the following: although using localizable strings as attribute values is supported by XAML, you cannot use these localizable strings as type converter input with specific culture requirements. This limitation is because type converters for XAML attribute values involve a necessarily fixed-language XAML-processing behavior that uses `en-US` culture. For more information about the design reasons for this restriction, see the XAML language specification ([\\[MS-XAML\\]](http://go.microsoft.com/fwlink/?LinkId=114525)) or [WPF Globalization and Localization Overview](../../../docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md).  \n  \n As an example where culture can be an issue, some cultures use a comma instead of a period as the decimal point delimiter for numbers in string form. This use collides with the behavior that many existing type converters have, which is to use a comma as a delimiter. Passing a culture through `xml:lang` in the surrounding XAML does not solve the issue.  \n  \n### Implementing ConvertFrom  \n To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter. If the string is in a valid format and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, the returned object must support a cast to the type that is expected by the property. Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.  \n  \n Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what constitutes a valid string for a conversion, and it can also use or ignore the type description or culture contexts that are passed as parameters. However, the WPF XAML processing might not pass values to the type description context in all cases and also might not pass culture based on `xml:lang`.  \n  \n> [!NOTE]\n>  Do not use the braces ({}), specifically the opening brace ({), as an element of your string format. These characters are reserved as the entry and exit for a markup extension sequence.  \n  \n It is appropriate to throw an exception when your type converter must have access to a XAML service from the .NET Framework XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.  \n  \n### Implementing ConvertTo  \n <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support. Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement. However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.  \n  \n To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) that is supported as the `value` parameter. When the `destinationType` parameter is of type <xref:System.String>, the returned object must be able to be cast as <xref:System.String>. The returned string must represent a serialized value of `value`. Ideally, the serialization format that you choose should be able to generate the same value as if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.  \n  \n If the value cannot be serialized or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null` and can throw an exception. However, if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.  \n  \n If the `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling. Typically, you revert to base implementation handling, which in the base <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.  \n  \n It is appropriate to throw an exception when your type converter must have access to a XAML service from the .NET Framework XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service.  \n  \n### Implementing CanConvertFrom  \n Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String> and otherwise, defer to the base implementation. Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>.  \n  \n### Implementing CanConvertTo  \n Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation. Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>.  \n  \n<a name=\"Applying_the_TypeConverterAttribute\"></a>   \n## Applying the TypeConverterAttribute  \n For your custom type converter to be used as the acting type converter for a custom class by .NET Framework XAML Services, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition. The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter. If you apply this attribute, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.  \n  \n You can also provide a type converter on a per-property basis. Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it). The type of the property must match the type that is processed by your custom type converter. With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances. The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.  \n  \n To supply a type conversion behavior for a custom attached member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get` accessor method of the implementation pattern for the attached member.  \n  \n<a name=\"accessing_service_provider_context_from_a_markup_extension_implementation\"></a>   \n## Accessing Service Provider Context from a Markup Extension Implementation  \n The available services are the same for any value converter. The difference is in how each value converter receives the service context. Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  \n  \n<a name=\"type_converters_in_the_xaml_node_stream\"></a>   \n## Type Converters in the XAML Node Stream  \n If you are working with a XAML node stream, the action or end result of a type converter is not yet executed. In a load path, the attribute string that eventually needs to be type-converted in order to load remains as a text value within a start member and end member. The type converter that is eventually needed for this operation can be determined by using the <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=fullName> property. However, obtaining a valid value from <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=fullName> relies on having a XAML schema context, which can access such information through the underlying member, or the type of the object value that the member uses. Invoking the type conversion behavior also requires the XAML schema context because that requires type-mapping and creating a converter instance.  \n  \n## See Also  \n <xref:System.ComponentModel.TypeConverterAttribute>   \n [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)   \n [XAML Overview (WPF)](../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)","nodes":[{"pos":[4,518],"nodes":[{"content":"Type Converters for XAML Overview | Microsoft Docs","nodes":[{"pos":[0,50],"content":"Type Converters for XAML Overview | Microsoft Docs","nodes":[{"content":"Type Converters for XAML Overview | Microsoft Docs","pos":[0,50]}]}],"pos":[6,59],"yaml":true}],"content":"title: \"Type Converters for XAML Overview | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"XAML [XAML Services], type converters\"\n  - \"XAML [XAML Services], TypeConverter\"\n  - \"type conversion for XAML [XAML Services]\"\nms.assetid: 51a65860-efcb-4fe0-95a0-1c679cde66b7\ncaps.latest.revision: 14\nauthor: \"wadepickett\"\nms.author: \"wpickett\"\nmanager: \"wpickett\"","yamlblock":true},{"pos":[525,558],"content":"Type Converters for XAML Overview","linkify":"Type Converters for XAML Overview","nodes":[{"content":"Type Converters for XAML Overview","pos":[0,33]}]},{"content":"Type converters supply logic for an object writer that converts from a string in XAML markup into particular objects in an object graph.","pos":[559,695]},{"content":"In .NET Framework XAML Services, the type converter must be a class that derives from <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>.","pos":[696,825],"source":" In .NET Framework XAML Services, the type converter must be a class that derives from <xref:System.ComponentModel.TypeConverter>."},{"content":"Some converters also support the XAML save path and can be used to serialize an object into a string form in serialization markup.","pos":[826,956]},{"content":"This topic describes how and when type converters in XAML are invoked, and provides implementation advice for the method overrides of <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>.","pos":[957,1134],"source":" This topic describes how and when type converters in XAML are invoked, and provides implementation advice for the method overrides of <xref:System.ComponentModel.TypeConverter>."},{"pos":[1186,1210],"content":"Type Conversion Concepts","linkify":"Type Conversion Concepts","nodes":[{"content":"Type Conversion Concepts","pos":[0,24]}]},{"content":"The following sections explain basic concepts about how XAML uses strings, and how object writers in .NET Framework XAML Services use type converters to process some of the string values that are encountered in a XAML source.","pos":[1214,1439]},{"pos":[1449,1471],"content":"XAML and String Values","linkify":"XAML and String Values","nodes":[{"content":"XAML and String Values","pos":[0,22]}]},{"content":"When you set an attribute value in a XAML file, the initial type of that value is a string in a general sense, and a string attribute value in an XML sense.","pos":[1475,1631]},{"content":"Even other primitives such as <ph id=\"ph1\">&lt;xref:System.Double&gt;</ph> are initially strings to a XAML processor.","pos":[1632,1725],"source":" Even other primitives such as <xref:System.Double> are initially strings to a XAML processor."},{"content":"In most cases, a XAML processor needs two pieces of information to process an attribute value.","pos":[1732,1826]},{"content":"The first piece of information is the value type of the property that is being set.","pos":[1827,1910]},{"content":"Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.","pos":[1911,2049]},{"content":"If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.","pos":[2050,2190]},{"content":"If the value for the attribute references an enumeration, the supplied string is checked for a name match to a named constant in that enumeration.","pos":[2191,2337]},{"content":"If the value is neither a parser-understood primitive nor a constant name from an enumeration, the applicable type must be able to provide a value or reference that is based on a converted string.","pos":[2338,2534]},{"pos":[2542,2605],"content":"[!NOTE]\n XAML language directives do not use type converters.","leadings":["","> "],"nodes":[{"content":"XAML language directives do not use type converters.","pos":[9,61]}]},{"pos":[2615,2652],"content":"Type Converters and Markup Extensions","linkify":"Type Converters and Markup Extensions","nodes":[{"content":"Type Converters and Markup Extensions","pos":[0,37]}]},{"content":"Markup extension usages must be handled by a XAML processor before it checks for property type and other considerations.","pos":[2656,2776]},{"content":"For example, if a property being set as an attribute normally has a type conversion, but in a particular case is set by a markup extension usage, then the markup extension behavior processes first.","pos":[2777,2974]},{"content":"One common situation where a markup extension is necessary is to make a reference to an object that already exists.","pos":[2975,3090]},{"content":"For this scenario, a stateless type converter can only generate a new instance, which might not be desirable.","pos":[3091,3200]},{"content":"For more information about markup extensions, see <bpt id=\"p1\">[</bpt>Markup Extensions for XAML Overview<ept id=\"p1\">](../../../docs/framework/xaml-services/markup-extensions-for-xaml-overview.md)</ept>.","pos":[3201,3367],"source":" For more information about markup extensions, see [Markup Extensions for XAML Overview](../../../docs/framework/xaml-services/markup-extensions-for-xaml-overview.md)."},{"pos":[3377,3399],"content":"Native Type Converters","linkify":"Native Type Converters","nodes":[{"content":"Native Type Converters","pos":[0,22]}]},{"content":"In the WPF and .NET XAML services implementations, there are certain CLR types that have native type conversion handling, however, hose CLR types are not conventionally thought of as primitives.","pos":[3403,3597]},{"content":"An example of such a type is <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph>.","pos":[3598,3650],"source":" An example of such a type is <xref:System.DateTime>."},{"content":"One reason for this is how the .NET Framework architecture works: the type <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> is defined in mscorlib, the most basic library in .NET.","pos":[3651,3804],"source":" One reason for this is how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET."},{"content":"<ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> is from System); therefore, the usual type converter discovery mechanism by attributing cannot be supported.","pos":[3805,4103],"source":" <xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System); therefore, the usual type converter discovery mechanism by attributing cannot be supported."},{"content":"Instead, the XAML parser has a list of types that need native processing, and it processes these types similar to how the true primitives are processed.","pos":[4104,4256]},{"content":"In the case of <ph id=\"ph1\">&lt;xref:System.DateTime&gt;</ph>, this processing involves a call to <ph id=\"ph2\">&lt;xref:System.DateTime.Parse%2A&gt;</ph>.","pos":[4257,4363],"source":" In the case of <xref:System.DateTime>, this processing involves a call to <xref:System.DateTime.Parse%2A>."},{"pos":[4420,4449],"content":"Implementing a Type Converter","linkify":"Implementing a Type Converter","nodes":[{"content":"Implementing a Type Converter","pos":[0,29]}]},{"content":"The following sections discuss the API of the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> class.","pos":[4453,4548],"source":"The following sections discuss the API of the <xref:System.ComponentModel.TypeConverter> class."},{"pos":[4558,4571],"content":"TypeConverter","linkify":"TypeConverter","nodes":[{"content":"TypeConverter","pos":[0,13]}]},{"content":"Under .NET Framework XAML Services, all type converters that are used for XAML purposes are classes that derive from the base class <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph>.","pos":[4575,4750],"source":"Under .NET Framework XAML Services, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> class existed in versions of the .NET Framework before XAML existed; one of the original <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> scenarios was to provide string conversion for property editors in visual designers.","pos":[4751,5014],"source":" The <xref:System.ComponentModel.TypeConverter> class existed in versions of the .NET Framework before XAML existed; one of the original <xref:System.ComponentModel.TypeConverter> scenarios was to provide string conversion for property editors in visual designers."},{"content":"For XAML, the role of <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> is expanded.","pos":[5021,5098],"source":"For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded."},{"content":"For XAML purposes, <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> is the base class for providing support for certain to-string and from-string conversions.","pos":[5099,5251],"source":" For XAML purposes, <xref:System.ComponentModel.TypeConverter> is the base class for providing support for certain to-string and from-string conversions."},{"content":"From-string enables parsing a string attribute value from XAML.","pos":[5252,5315]},{"content":"To-string might enable processing a run-time value of a particular object property back into an attribute in XAML for serialization.","pos":[5316,5448]},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> defines four members that are relevant for converting to-string and from-string for XAML processing purposes:","pos":[5455,5607],"source":"<xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to-string and from-string for XAML processing purposes:"},{"content":"Of these members, the most important method is <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph>, which converts the input string to the required object type.","pos":[5884,6050],"source":"Of these members, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>, which converts the input string to the required object type."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> method can be implemented to convert a wider range of types into the intended destination type of the converter.","pos":[6051,6225],"source":" The <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method can be implemented to convert a wider range of types into the intended destination type of the converter."},{"content":"Therefore, it can serve purposes that extend beyond XAML, such as supporting run-time conversions.","pos":[6226,6324]},{"content":"However, for XAML use, only the code path that can process a <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> input is important.","pos":[6325,6426],"source":" However, for XAML use, only the code path that can process a <xref:System.String> input is important."},{"content":"The second most important method is <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph>.","pos":[6433,6525],"source":"The second most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>."},{"content":"If an application is converted to a markup representation (for example, if it is saved to XAML as a file), <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> is involved in the larger scenario of a XAML text writers produce a markup representation.","pos":[6526,6779],"source":" If an application is converted to a markup representation (for example, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is involved in the larger scenario of a XAML text writers produce a markup representation."},{"content":"In this case, the important code path for XAML is when the caller passes a <ph id=\"ph1\">`destinationType`</ph> of <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>.","pos":[6780,6897],"source":" In this case, the important code path for XAML is when the caller passes a `destinationType` of <xref:System.String>."},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A&gt;</ph> are support methods that are used when a service queries the capabilities of the <ph id=\"ph3\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation.","pos":[6904,7167],"source":"<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation."},{"content":"You must implement these methods to return <ph id=\"ph1\">`true`</ph> for type-specific cases that the equivalent conversion methods of your converter support.","pos":[7168,7307],"source":" You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support."},{"content":"For XAML purposes, this generally means the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type.","pos":[7308,7378],"source":" For XAML purposes, this generally means the <xref:System.String> type."},{"pos":[7388,7436],"content":"Culture Information and Type Converters for XAML","linkify":"Culture Information and Type Converters for XAML","nodes":[{"content":"Culture Information and Type Converters for XAML","pos":[0,48]}]},{"content":"Each <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation can uniquely interpret what is a valid string for a conversion, and it can also use or ignore the type description that is passed as parameters.","pos":[7440,7647],"source":"Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what is a valid string for a conversion, and it can also use or ignore the type description that is passed as parameters."},{"content":"An important consideration for culture and XAML type conversion is the following: although using localizable strings as attribute values is supported by XAML, you cannot use these localizable strings as type converter input with specific culture requirements.","pos":[7648,7907]},{"content":"This limitation is because type converters for XAML attribute values involve a necessarily fixed-language XAML-processing behavior that uses <ph id=\"ph1\">`en-US`</ph> culture.","pos":[7908,8065],"source":" This limitation is because type converters for XAML attribute values involve a necessarily fixed-language XAML-processing behavior that uses `en-US` culture."},{"content":"For more information about the design reasons for this restriction, see the XAML language specification (<bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\[</ph>MS-XAML<ph id=\"ph2\">\\]</ph><ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=114525)</ept>) or <bpt id=\"p2\">[</bpt>WPF Globalization and Localization Overview<ept id=\"p2\">](../../../docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md)</ept>.","pos":[8066,8367],"source":" For more information about the design reasons for this restriction, see the XAML language specification ([\\[MS-XAML\\]](http://go.microsoft.com/fwlink/?LinkId=114525)) or [WPF Globalization and Localization Overview](../../../docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md)."},{"content":"As an example where culture can be an issue, some cultures use a comma instead of a period as the decimal point delimiter for numbers in string form.","pos":[8374,8523]},{"content":"This use collides with the behavior that many existing type converters have, which is to use a comma as a delimiter.","pos":[8524,8640]},{"content":"Passing a culture through <ph id=\"ph1\">`xml:lang`</ph> in the surrounding XAML does not solve the issue.","pos":[8641,8727],"source":" Passing a culture through `xml:lang` in the surrounding XAML does not solve the issue."},{"pos":[8737,8761],"content":"Implementing ConvertFrom","linkify":"Implementing ConvertFrom","nodes":[{"content":"Implementing ConvertFrom","pos":[0,24]}]},{"content":"To be usable as a <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation that supports XAML, the <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> method for that converter must accept a string as the <ph id=\"ph3\">`value`</ph> parameter.","pos":[8765,8995],"source":"To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter."},{"content":"If the string is in a valid format and can be converted by the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation, the returned object must support a cast to the type that is expected by the property.","pos":[8996,9203],"source":" If the string is in a valid format and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, the returned object must support a cast to the type that is expected by the property."},{"content":"Otherwise, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> implementation must return <ph id=\"ph2\">`null`</ph>.","pos":[9204,9311],"source":" Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation can uniquely interpret what constitutes a valid string for a conversion, and it can also use or ignore the type description or culture contexts that are passed as parameters.","pos":[9318,9555],"source":"Each <xref:System.ComponentModel.TypeConverter> implementation can uniquely interpret what constitutes a valid string for a conversion, and it can also use or ignore the type description or culture contexts that are passed as parameters."},{"content":"However, the WPF XAML processing might not pass values to the type description context in all cases and also might not pass culture based on <ph id=\"ph1\">`xml:lang`</ph>.","pos":[9556,9708],"source":" However, the WPF XAML processing might not pass values to the type description context in all cases and also might not pass culture based on `xml:lang`."},{"pos":[9716,9912],"content":"[!NOTE]\n Do not use the braces ({}), specifically the opening brace ({), as an element of your string format. These characters are reserved as the entry and exit for a markup extension sequence.","leadings":["","> "],"nodes":[{"content":"Do not use the braces ({}), specifically the opening brace ({), as an element of your string format. These characters are reserved as the entry and exit for a markup extension sequence.","pos":[9,194],"nodes":[{"content":"Do not use the braces ({}), specifically the opening brace ({), as an element of your string format.","pos":[0,100]},{"content":"These characters are reserved as the entry and exit for a markup extension sequence.","pos":[101,185]}]}]},{"content":"It is appropriate to throw an exception when your type converter must have access to a XAML service from the .NET Framework XAML Services object writer, but the <ph id=\"ph1\">&lt;xref:System.IServiceProvider.GetService%2A&gt;</ph> call that is made against the context does not return that service.","pos":[9919,10192],"source":"It is appropriate to throw an exception when your type converter must have access to a XAML service from the .NET Framework XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service."},{"pos":[10202,10224],"content":"Implementing ConvertTo","linkify":"Implementing ConvertTo","nodes":[{"content":"Implementing ConvertTo","pos":[0,22]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> is potentially used for serialization support.","pos":[10228,10330],"source":"<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support."},{"content":"Serialization support through <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> for your custom type and its type converter is not an absolute requirement.","pos":[10331,10492],"source":" Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement."},{"content":"However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph>.","pos":[10493,10689],"source":" However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>."},{"content":"To be usable as a <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter&gt;</ph> implementation that supports XAML, the <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> method for that converter must accept an instance of the type (or a value) that is supported as the <ph id=\"ph3\">`value`</ph> parameter.","pos":[10696,10970],"source":"To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) that is supported as the `value` parameter."},{"content":"When the <ph id=\"ph1\">`destinationType`</ph> parameter is of type <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, the returned object must be able to be cast as <ph id=\"ph3\">&lt;xref:System.String&gt;</ph>.","pos":[10971,11109],"source":" When the `destinationType` parameter is of type <xref:System.String>, the returned object must be able to be cast as <xref:System.String>."},{"content":"The returned string must represent a serialized value of <ph id=\"ph1\">`value`</ph>.","pos":[11110,11175],"source":" The returned string must represent a serialized value of `value`."},{"content":"Ideally, the serialization format that you choose should be able to generate the same value as if that string were passed to the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertFrom%2A&gt;</ph> implementation of the same converter, without significant loss of information.","pos":[11176,11441],"source":" Ideally, the serialization format that you choose should be able to generate the same value as if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information."},{"content":"If the value cannot be serialized or the converter does not support serialization, the <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> implementation must return <ph id=\"ph2\">`null`</ph> and can throw an exception.","pos":[11448,11652],"source":"If the value cannot be serialized or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null` and can throw an exception."},{"content":"However, if you do throw exceptions, you should report the inability to use that conversion as part of your <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> implementation so that the best practice of checking with <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> first to avoid exceptions is supported.","pos":[11653,11976],"source":" However, if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported."},{"content":"If the <ph id=\"ph1\">`destinationType`</ph> parameter is not of type <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can choose your own converter handling.","pos":[11983,12098],"source":"If the `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling."},{"content":"Typically, you revert to base implementation handling, which in the base <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.ConvertTo%2A&gt;</ph> raises a specific exception.","pos":[12099,12256],"source":" Typically, you revert to base implementation handling, which in the base <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception."},{"content":"It is appropriate to throw an exception when your type converter must have access to a XAML service from the .NET Framework XAML Services object writer, but the <ph id=\"ph1\">&lt;xref:System.IServiceProvider.GetService%2A&gt;</ph> call that is made against the context does not return that service.","pos":[12263,12536],"source":"It is appropriate to throw an exception when your type converter must have access to a XAML service from the .NET Framework XAML Services object writer, but the <xref:System.IServiceProvider.GetService%2A> call that is made against the context does not return that service."},{"pos":[12546,12573],"content":"Implementing CanConvertFrom","linkify":"Implementing CanConvertFrom","nodes":[{"content":"Implementing CanConvertFrom","pos":[0,27]}]},{"content":"Your <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A&gt;</ph> implementation should return <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`sourceType`</ph> of type <ph id=\"ph4\">&lt;xref:System.String&gt;</ph> and otherwise, defer to the base implementation.","pos":[12577,12773],"source":"Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String> and otherwise, defer to the base implementation."},{"content":"Do not throw exceptions from <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A&gt;</ph>.","pos":[12774,12864],"source":" Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>."},{"pos":[12874,12899],"content":"Implementing CanConvertTo","linkify":"Implementing CanConvertTo","nodes":[{"content":"Implementing CanConvertTo","pos":[0,25]}]},{"content":"Your <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph> implementation should return <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`destinationType`</ph> of type <ph id=\"ph4\">&lt;xref:System.String&gt;</ph>, and otherwise defer to the base implementation.","pos":[12903,13102],"source":"Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation."},{"content":"Do not throw exceptions from <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverter.CanConvertTo%2A&gt;</ph>.","pos":[13103,13191],"source":" Do not throw exceptions from <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>."},{"pos":[13254,13289],"content":"Applying the TypeConverterAttribute","linkify":"Applying the TypeConverterAttribute","nodes":[{"content":"Applying the TypeConverterAttribute","pos":[0,35]}]},{"content":"For your custom type converter to be used as the acting type converter for a custom class by .NET Framework XAML Services, you must apply the <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewkattr](../../../includes/tlasharptla-netframewkattr-md.md)]</ph> <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to your class definition.","pos":[13293,13599],"source":"For your custom type converter to be used as the acting type converter for a custom class by .NET Framework XAML Services, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A&gt;</ph> that you specify through the attribute must be the type name of your custom type converter.","pos":[13600,13768],"source":" The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter."},{"content":"If you apply this attribute, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.","pos":[13769,13937]},{"content":"You can also provide a type converter on a per-property basis.","pos":[13944,14006]},{"content":"Instead of applying a <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewkattr](../../../includes/tlasharptla-netframewkattr-md.md)]</ph> <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to the class definition, apply it to a property definition (the main definition, not the <ph id=\"ph3\">`get`</ph><ph id=\"ph4\">/</ph><ph id=\"ph5\">`set`</ph> implementations within it).","pos":[14007,14296],"source":" Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it)."},{"content":"The type of the property must match the type that is processed by your custom type converter.","pos":[14297,14390]},{"content":"With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.","pos":[14391,14532]},{"content":"The per-property type converter technique is particularly useful if you choose to use a property type from <ph id=\"ph1\">[!INCLUDE[TLA#tla_netframewk](../../../includes/tlasharptla-netframewk-md.md)]</ph> or from some other library where you cannot control the class definition and cannot apply a <ph id=\"ph2\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> there.","pos":[14533,14869],"source":" The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there."},{"pos":[14876,15084],"content":"To supply a type conversion behavior for a custom attached member, apply <ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph> to the <ph id=\"ph2\">`Get`</ph> accessor method of the implementation pattern for the attached member.","source":"To supply a type conversion behavior for a custom attached member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get` accessor method of the implementation pattern for the attached member."},{"pos":[15185,15258],"content":"Accessing Service Provider Context from a Markup Extension Implementation","linkify":"Accessing Service Provider Context from a Markup Extension Implementation","nodes":[{"content":"Accessing Service Provider Context from a Markup Extension Implementation","pos":[0,73]}]},{"content":"The available services are the same for any value converter.","pos":[15262,15322]},{"content":"The difference is in how each value converter receives the service context.","pos":[15323,15398]},{"content":"Accessing services and the services available are documented in the topic <bpt id=\"p1\">[</bpt>Type Converters and Markup Extensions for XAML<ept id=\"p1\">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept>.","pos":[15399,15611],"source":" Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)."},{"pos":[15678,15717],"content":"Type Converters in the XAML Node Stream","linkify":"Type Converters in the XAML Node Stream","nodes":[{"content":"Type Converters in the XAML Node Stream","pos":[0,39]}]},{"content":"If you are working with a XAML node stream, the action or end result of a type converter is not yet executed.","pos":[15721,15830]},{"content":"In a load path, the attribute string that eventually needs to be type-converted in order to load remains as a text value within a start member and end member.","pos":[15831,15989]},{"content":"The type converter that is eventually needed for this operation can be determined by using the <ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=fullName&gt;</ph> property.","pos":[15990,16166],"source":" The type converter that is eventually needed for this operation can be determined by using the <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=fullName> property."},{"content":"However, obtaining a valid value from <ph id=\"ph1\">&lt;xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=fullName&gt;</ph> relies on having a XAML schema context, which can access such information through the underlying member, or the type of the object value that the member uses.","pos":[16167,16435],"source":" However, obtaining a valid value from <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=fullName> relies on having a XAML schema context, which can access such information through the underlying member, or the type of the object value that the member uses."},{"content":"Invoking the type conversion behavior also requires the XAML schema context because that requires type-mapping and creating a converter instance.","pos":[16436,16581]},{"pos":[16590,16598],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.TypeConverterAttribute&gt;</ph>","pos":[16602,16653],"source":"<xref:System.ComponentModel.TypeConverterAttribute> "},{"content":"<bpt id=\"p1\">[</bpt>Type Converters and Markup Extensions for XAML<ept id=\"p1\">](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)</ept><ph id=\"ph1\"> </ph>","pos":[16658,16796],"source":"[Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md) "},{"content":"<bpt id=\"p1\">[</bpt>XAML Overview (WPF)<ept id=\"p1\">](../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept>","pos":[16800,16880],"source":"[XAML Overview (WPF)](../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)"}]}