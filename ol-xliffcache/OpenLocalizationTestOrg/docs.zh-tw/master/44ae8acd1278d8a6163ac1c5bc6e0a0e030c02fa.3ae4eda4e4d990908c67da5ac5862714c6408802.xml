{"content":"---\ntitle: \"Object and Collection Initializers - C# Programming Guide\"\nms.custom: seodec18\nms.date: 12/19/2018\nhelpviewer_keywords: \n  - \"object initializers [C#]\"\n  - \"collection initializers [C#]\"\nms.assetid: c58f3db5-d7d4-4651-bd2d-5a3a97357f61\n---\n# Object and Collection Initializers (C# Programming Guide)\n\nC# lets you instantiate an object or collection and perform member assignments in a single statement.\n\n## Object initializers\n\nObject initializers let you assign values to any accessible fields or properties of an object at creation time without having to invoke a constructor followed by lines of assignment statements. The object initializer syntax enables you to specify arguments for a constructor or omit the arguments (and parentheses syntax).  The following example shows how to use an object initializer with a named type, `Cat` and how to invoke the default constructor. Note the use of auto-implemented properties in the `Cat` class. For more information, see [Auto-Implemented Properties](auto-implemented-properties.md).  \n  \n[!code-csharp[ObjectInitializer1](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#CatDeclaration)]  \n[!code-csharp[ObjectInitializer1a](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#ObjectPropertyInitialization)]  \n \nThe object initializers syntax allows you to create an instance, and after that it assigns the newly created object, with its assigned properties, to the variable in the assignment.\n\nStarting with C# 6, object initializers can set indexers, in addition to assigning fields and properties. Consider this basic `Matrix` class:\n\n[!code-csharp[ObjectInitializer2](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#MatrixDeclaration)]  \n\nYou could initialize the identity matrix with the following code:\n\n[!code-csharp[ObjectInitializer2a](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#MatrixInitialization)]  \n\nAny accessible indexer that contains an accessible setter can be used as one of the expressions in an object initializer, regardless of the number or types of arguments. The index arguments form the left side of the assignment, and the value is the right side of the expression.  For example, these are all valid if `IndexersExample` has the appropriate indexers:\n\n```csharp\nvar thing = new IndexersExample {\n    name = \"object one\",\n    [1] = '1',\n    [2] = '4',\n    [3] = '9',\n    Baz = Math.PI,\n    ['C',4] = \"Middle C\"\n}\n```\n\nFor the preceding code to compile, the `IndexersExample` type must have the following members:\n\n```csharp\npublic string name;\npublic double Size { set { ... }; }\npublic char this[int i] { set { ... }; }\npublic string this[char c, int i] {  set { ... }; }\n}\n```\n\n## Object Initializers with anonymous types\n\nAlthough object initializers can be used in any context, they are especially useful in [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expressions. Query expressions make frequent use of [anonymous types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md), which can only be initialized by using an object initializer, as shown in the following declaration.  \n\n```csharp\nvar pet = new { Age = 10, Name = \"Fluffy\" };  \n```\n\nAnonymous types enable the `select` clause in a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expression to transform objects of the original sequence into objects whose value and shape may differ from the original. This is useful if you want to store only a part of the information from each object in a sequence. In the following example, assume that a product object (`p`) contains many fields and methods, and that you are only interested in creating a sequence of objects that contain the product name and the unit price.  \n  \n[!code-csharp[ObjectInitializer3](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#AnonymousUse)]  \n\nWhen this query is executed, the `productInfos` variable will contain a sequence of objects that can be accessed in a `foreach` statement as shown in this example:  \n\n```csharp\nforeach(var p in productInfos){...}  \n```\n\nEach object in the new anonymous type has two public properties that receive the same names as the properties or fields in the original object. You can also rename a field when you are creating an anonymous type; the following example renames the `UnitPrice` field to `Price`.  \n\n```csharp\nselect new {p.ProductName, Price = p.UnitPrice};  \n```\n\n## Collection initializers\n\nCollection initializers let you specify one or more element initializers when you initialize a collection type that implements <xref:System.Collections.IEnumerable> and has `Add` with the appropriate signature as an instance method or an extension method. The element initializers can be a simple value, an expression, or an object initializer. By using a collection initializer, you do not have to specify multiple calls; the compiler adds the calls automatically.  \n  \nThe following example shows two simple collection initializers:  \n\n```csharp\nList<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };  \nList<int> digits2 = new List<int> { 0 + 1, 12 % 3, MakeInt() };  \n```\n\nThe following collection initializer uses object initializers to initialize objects of the `Cat` class defined in a previous example. Note that the individual object initializers are enclosed in braces and separated by commas.  \n  \n[!code-csharp[ListInitializer](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#ListInitializer)]  \n  \nYou can specify [null](../../language-reference/keywords/null.md) as an element in a collection initializer if the collection's `Add` method allows it.  \n  \n[!code-csharp[ListInitializerNull](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#ListInitialerWithNull)]  \n  \n You can specify indexed elements if the collection supports read / write indexing.\n  \n[!code-csharp[DictionaryInitializer](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#DictionaryIndexerInitializer)]  \n\nThe preceding sample generates code that calls the <xref:System.Collections.Generic.Dictionary%602.Item(%600)> to set the values. Beginning with C# 6, you can initialize dictionaries and other associative containers using the following syntax. Notice that instead of indexer syntax, with parentheses and an assignment, it uses an object with multiple values:\n\n[!code-csharp[DictionaryAddInitializer](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#DictionaryAddInitializer)]  \n\nThis initializer example calls <xref:System.Collections.Generic.Dictionary%602.Add(%600,%601)> to add the three items into the dictionary. These two different ways to initialize associative collections have slightly different behavior because of the method calls the compiler generates. Both variants work with the `Dictionary` class. Other types may only support one or the other based on their public API.\n\n## Examples\n\nThe following example combines the concepts of object and collection initializers.\n\n[!code-csharp-interactive[InitializerExample](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#FullExample)]  \n\nThe following example shows an object that implements <xref:System.Collections.IEnumerable> and contains an `Add` method with multiple parameters, It uses a collection initializer with multiple elements per item in the list that correspond to the signature of the `Add` method.\n\n[!code-csharp-interactive[InitializerListExample](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#FullListExample)]  \n\n`Add` methods can use the `params` keyword to take a variable number of arguments, as shown in the following example. This example also demonstrates the custom implementation of an indexer to initialize a collection using indexes.\n\n[!code-csharp-interactive[InitializerListExample](../../../../samples/snippets/csharp/programming-guide/classes-and-structs/object-collection-initializers/BasicObjectInitializers.cs#FullDictionaryInitializer)]  \n\n## See also\n\n- [C# Programming Guide](../index.md)\n- [LINQ Query Expressions](../linq-query-expressions/index.md)\n- [Anonymous Types](anonymous-types.md)\n","nodes":[{"pos":[4,247],"embed":true,"restype":"x-metadata","content":"title: \"Object and Collection Initializers - C# Programming Guide\"\nms.custom: seodec18\nms.date: 12/19/2018\nhelpviewer_keywords: \n  - \"object initializers [C#]\"\n  - \"collection initializers [C#]\"\nms.assetid: c58f3db5-d7d4-4651-bd2d-5a3a97357f61","nodes":[{"content":"Object and Collection Initializers - C# Programming Guide","nodes":[{"pos":[0,57],"content":"Object and Collection Initializers - C# Programming Guide","nodes":[{"content":"Object and Collection Initializers - C# Programming Guide","pos":[0,57]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[254,311],"content":"Object and Collection Initializers (C# Programming Guide)","linkify":"Object and Collection Initializers (C# Programming Guide)","nodes":[{"content":"Object and Collection Initializers (C# Programming Guide)","pos":[0,57]}]},{"content":"C# lets you instantiate an object or collection and perform member assignments in a single statement.","pos":[313,414]},{"pos":[419,438],"content":"Object initializers","linkify":"Object initializers","nodes":[{"content":"Object initializers","pos":[0,19]}]},{"content":"Object initializers let you assign values to any accessible fields or properties of an object at creation time without having to invoke a constructor followed by lines of assignment statements.","pos":[440,633]},{"content":"The object initializer syntax enables you to specify arguments for a constructor or omit the arguments (and parentheses syntax).","pos":[634,762]},{"content":"The following example shows how to use an object initializer with a named type, <ph id=\"ph1\">`Cat`</ph> and how to invoke the default constructor.","pos":[764,892],"source":"  The following example shows how to use an object initializer with a named type, `Cat` and how to invoke the default constructor."},{"content":"Note the use of auto-implemented properties in the <ph id=\"ph1\">`Cat`</ph> class.","pos":[893,956],"source":" Note the use of auto-implemented properties in the `Cat` class."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Auto-Implemented Properties<ept id=\"p1\">](auto-implemented-properties.md)</ept>.","pos":[957,1045],"source":" For more information, see [Auto-Implemented Properties](auto-implemented-properties.md)."},{"content":"The object initializers syntax allows you to create an instance, and after that it assigns the newly created object, with its assigned properties, to the variable in the assignment.","pos":[1438,1619]},{"content":"Starting with C# 6, object initializers can set indexers, in addition to assigning fields and properties.","pos":[1621,1726]},{"content":"Consider this basic <ph id=\"ph1\">`Matrix`</ph> class:","pos":[1727,1762],"source":" Consider this basic `Matrix` class:"},{"content":"You could initialize the identity matrix with the following code:","pos":[1953,2018]},{"content":"Any accessible indexer that contains an accessible setter can be used as one of the expressions in an object initializer, regardless of the number or types of arguments.","pos":[2213,2382]},{"content":"The index arguments form the left side of the assignment, and the value is the right side of the expression.","pos":[2383,2491]},{"content":"For example, these are all valid if <ph id=\"ph1\">`IndexersExample`</ph> has the appropriate indexers:","pos":[2493,2576],"source":"  For example, these are all valid if `IndexersExample` has the appropriate indexers:"},{"pos":[2743,2837],"content":"For the preceding code to compile, the <ph id=\"ph1\">`IndexersExample`</ph> type must have the following members:","source":"For the preceding code to compile, the `IndexersExample` type must have the following members:"},{"pos":[3008,3048],"content":"Object Initializers with anonymous types","linkify":"Object Initializers with anonymous types","nodes":[{"content":"Object Initializers with anonymous types","pos":[0,40]}]},{"content":"Although object initializers can be used in any context, they are especially useful in <ph id=\"ph1\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query expressions.","pos":[3050,3205],"source":"Although object initializers can be used in any context, they are especially useful in [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expressions."},{"content":"Query expressions make frequent use of <bpt id=\"p1\">[</bpt>anonymous types<ept id=\"p1\">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>, which can only be initialized by using an object initializer, as shown in the following declaration.","pos":[3206,3438],"source":" Query expressions make frequent use of [anonymous types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md), which can only be initialized by using an object initializer, as shown in the following declaration."},{"content":"Anonymous types enable the <ph id=\"ph1\">`select`</ph> clause in a <ph id=\"ph2\">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query expression to transform objects of the original sequence into objects whose value and shape may differ from the original.","pos":[3504,3729],"source":"Anonymous types enable the `select` clause in a [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] query expression to transform objects of the original sequence into objects whose value and shape may differ from the original."},{"content":"This is useful if you want to store only a part of the information from each object in a sequence.","pos":[3730,3828]},{"content":"In the following example, assume that a product object (<ph id=\"ph1\">`p`</ph>) contains many fields and methods, and that you are only interested in creating a sequence of objects that contain the product name and the unit price.","pos":[3829,4040],"source":" In the following example, assume that a product object (`p`) contains many fields and methods, and that you are only interested in creating a sequence of objects that contain the product name and the unit price."},{"pos":[4230,4393],"content":"When this query is executed, the <ph id=\"ph1\">`productInfos`</ph> variable will contain a sequence of objects that can be accessed in a <ph id=\"ph2\">`foreach`</ph> statement as shown in this example:","source":"When this query is executed, the `productInfos` variable will contain a sequence of objects that can be accessed in a `foreach` statement as shown in this example:"},{"content":"Each object in the new anonymous type has two public properties that receive the same names as the properties or fields in the original object.","pos":[4450,4593]},{"content":"You can also rename a field when you are creating an anonymous type; the following example renames the <ph id=\"ph1\">`UnitPrice`</ph> field to <ph id=\"ph2\">`Price`</ph>.","pos":[4594,4726],"source":" You can also rename a field when you are creating an anonymous type; the following example renames the `UnitPrice` field to `Price`."},{"pos":[4799,4822],"content":"Collection initializers","linkify":"Collection initializers","nodes":[{"content":"Collection initializers","pos":[0,23]}]},{"content":"Collection initializers let you specify one or more element initializers when you initialize a collection type that implements <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph> and has <ph id=\"ph2\">`Add`</ph> with the appropriate signature as an instance method or an extension method.","pos":[4824,5079],"source":"Collection initializers let you specify one or more element initializers when you initialize a collection type that implements <xref:System.Collections.IEnumerable> and has `Add` with the appropriate signature as an instance method or an extension method."},{"content":"The element initializers can be a simple value, an expression, or an object initializer.","pos":[5080,5168]},{"content":"By using a collection initializer, you do not have to specify multiple calls; the compiler adds the calls automatically.","pos":[5169,5289]},{"content":"The following example shows two simple collection initializers:","pos":[5295,5358]},{"content":"The following collection initializer uses object initializers to initialize objects of the <ph id=\"ph1\">`Cat`</ph> class defined in a previous example.","pos":[5512,5645],"source":"The following collection initializer uses object initializers to initialize objects of the `Cat` class defined in a previous example."},{"content":"Note that the individual object initializers are enclosed in braces and separated by commas.","pos":[5646,5738]},{"pos":[5930,6081],"content":"You can specify <bpt id=\"p1\">[</bpt>null<ept id=\"p1\">](../../language-reference/keywords/null.md)</ept> as an element in a collection initializer if the collection's <ph id=\"ph1\">`Add`</ph> method allows it.","source":"You can specify [null](../../language-reference/keywords/null.md) as an element in a collection initializer if the collection's `Add` method allows it."},{"content":"You can specify indexed elements if the collection supports read / write indexing.","pos":[6284,6366]},{"content":"The preceding sample generates code that calls the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602.Item(%600)&gt;</ph> to set the values.","pos":[6573,6702],"source":"The preceding sample generates code that calls the <xref:System.Collections.Generic.Dictionary%602.Item(%600)> to set the values."},{"content":"Beginning with C# 6, you can initialize dictionaries and other associative containers using the following syntax.","pos":[6703,6816]},{"content":"Notice that instead of indexer syntax, with parentheses and an assignment, it uses an object with multiple values:","pos":[6817,6931]},{"content":"This initializer example calls <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602.Add(%600,%601)&gt;</ph> to add the three items into the dictionary.","pos":[7135,7273],"source":"This initializer example calls <xref:System.Collections.Generic.Dictionary%602.Add(%600,%601)> to add the three items into the dictionary."},{"content":"These two different ways to initialize associative collections have slightly different behavior because of the method calls the compiler generates.","pos":[7274,7421]},{"content":"Both variants work with the <ph id=\"ph1\">`Dictionary`</ph> class.","pos":[7422,7469],"source":" Both variants work with the `Dictionary` class."},{"content":"Other types may only support one or the other based on their public API.","pos":[7470,7542]},{"pos":[7547,7555],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"The following example combines the concepts of object and collection initializers.","pos":[7557,7639]},{"pos":[7836,8113],"content":"The following example shows an object that implements <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph> and contains an <ph id=\"ph2\">`Add`</ph> method with multiple parameters, It uses a collection initializer with multiple elements per item in the list that correspond to the signature of the <ph id=\"ph3\">`Add`</ph> method.","source":"The following example shows an object that implements <xref:System.Collections.IEnumerable> and contains an `Add` method with multiple parameters, It uses a collection initializer with multiple elements per item in the list that correspond to the signature of the `Add` method."},{"content":"<ph id=\"ph1\">`Add`</ph> methods can use the <ph id=\"ph2\">`params`</ph> keyword to take a variable number of arguments, as shown in the following example.","pos":[8318,8435],"source":"`Add` methods can use the `params` keyword to take a variable number of arguments, as shown in the following example."},{"content":"This example also demonstrates the custom implementation of an indexer to initialize a collection using indexes.","pos":[8436,8548]},{"pos":[8766,8774],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8778,8813],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../index.md)</ept>","source":"[C# Programming Guide](../index.md)"},{"pos":[8816,8876],"content":"<bpt id=\"p1\">[</bpt>LINQ Query Expressions<ept id=\"p1\">](../linq-query-expressions/index.md)</ept>","source":"[LINQ Query Expressions](../linq-query-expressions/index.md)"},{"pos":[8879,8916],"content":"<bpt id=\"p1\">[</bpt>Anonymous Types<ept id=\"p1\">](anonymous-types.md)</ept>","source":"[Anonymous Types](anonymous-types.md)"}]}