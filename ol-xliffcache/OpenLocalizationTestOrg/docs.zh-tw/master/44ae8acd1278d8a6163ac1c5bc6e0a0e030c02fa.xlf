<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="object-and-collection-initializers.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">44ae8acd1278d8a6163ac1c5bc6e0a0e030c02fa</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\classes-and-structs\object-and-collection-initializers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3ae4eda4e4d990908c67da5ac5862714c6408802</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">abd8579cca7342fdb7c5a57f84c1c1cf52c53ef8</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Object and Collection Initializers - C# Programming Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Object and Collection Initializers (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>C# lets you instantiate an object or collection and perform member assignments in a single statement.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Object initializers</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Object initializers let you assign values to any accessible fields or properties of an object at creation time without having to invoke a constructor followed by lines of assignment statements.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The object initializer syntax enables you to specify arguments for a constructor or omit the arguments (and parentheses syntax).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following example shows how to use an object initializer with a named type, <ph id="ph1">`Cat`</ph> and how to invoke the default constructor.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Note the use of auto-implemented properties in the <ph id="ph1">`Cat`</ph> class.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Auto-Implemented Properties<ept id="p1">](auto-implemented-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The object initializers syntax allows you to create an instance, and after that it assigns the newly created object, with its assigned properties, to the variable in the assignment.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Starting with C# 6, object initializers can set indexers, in addition to assigning fields and properties.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Consider this basic <ph id="ph1">`Matrix`</ph> class:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You could initialize the identity matrix with the following code:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Any accessible indexer that contains an accessible setter can be used as one of the expressions in an object initializer, regardless of the number or types of arguments.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The index arguments form the left side of the assignment, and the value is the right side of the expression.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For example, these are all valid if <ph id="ph1">`IndexersExample`</ph> has the appropriate indexers:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For the preceding code to compile, the <ph id="ph1">`IndexersExample`</ph> type must have the following members:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Object Initializers with anonymous types</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although object initializers can be used in any context, they are especially useful in <ph id="ph1">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query expressions.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Query expressions make frequent use of <bpt id="p1">[</bpt>anonymous types<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)</ept>, which can only be initialized by using an object initializer, as shown in the following declaration.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Anonymous types enable the <ph id="ph1">`select`</ph> clause in a <ph id="ph2">[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)]</ph> query expression to transform objects of the original sequence into objects whose value and shape may differ from the original.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This is useful if you want to store only a part of the information from each object in a sequence.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the following example, assume that a product object (<ph id="ph1">`p`</ph>) contains many fields and methods, and that you are only interested in creating a sequence of objects that contain the product name and the unit price.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When this query is executed, the <ph id="ph1">`productInfos`</ph> variable will contain a sequence of objects that can be accessed in a <ph id="ph2">`foreach`</ph> statement as shown in this example:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Each object in the new anonymous type has two public properties that receive the same names as the properties or fields in the original object.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can also rename a field when you are creating an anonymous type; the following example renames the <ph id="ph1">`UnitPrice`</ph> field to <ph id="ph2">`Price`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Collection initializers</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Collection initializers let you specify one or more element initializers when you initialize a collection type that implements <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> and has <ph id="ph2">`Add`</ph> with the appropriate signature as an instance method or an extension method.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The element initializers can be a simple value, an expression, or an object initializer.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>By using a collection initializer, you do not have to specify multiple calls; the compiler adds the calls automatically.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The following example shows two simple collection initializers:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following collection initializer uses object initializers to initialize objects of the <ph id="ph1">`Cat`</ph> class defined in a previous example.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Note that the individual object initializers are enclosed in braces and separated by commas.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can specify <bpt id="p1">[</bpt>null<ept id="p1">](../../language-reference/keywords/null.md)</ept> as an element in a collection initializer if the collection's <ph id="ph1">`Add`</ph> method allows it.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can specify indexed elements if the collection supports read / write indexing.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The preceding sample generates code that calls the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602.Item(%600)&gt;</ph> to set the values.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Beginning with C# 6, you can initialize dictionaries and other associative containers using the following syntax.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Notice that instead of indexer syntax, with parentheses and an assignment, it uses an object with multiple values:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This initializer example calls <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602.Add(%600,%601)&gt;</ph> to add the three items into the dictionary.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>These two different ways to initialize associative collections have slightly different behavior because of the method calls the compiler generates.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Both variants work with the <ph id="ph1">`Dictionary`</ph> class.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Other types may only support one or the other based on their public API.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Examples</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following example combines the concepts of object and collection initializers.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following example shows an object that implements <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> and contains an <ph id="ph2">`Add`</ph> method with multiple parameters, It uses a collection initializer with multiple elements per item in the list that correspond to the signature of the <ph id="ph3">`Add`</ph> method.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Add`</ph> methods can use the <ph id="ph2">`params`</ph> keyword to take a variable number of arguments, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This example also demonstrates the custom implementation of an indexer to initialize a collection using indexes.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../index.md)</ept></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>LINQ Query Expressions<ept id="p1">](../linq-query-expressions/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Anonymous Types<ept id="p1">](anonymous-types.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>