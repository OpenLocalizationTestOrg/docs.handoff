{"content":"---\ntitle: \"Specifying and Handling Faults in Contracts and Services\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"handling faults [WCF]\"\nms.assetid: a9696563-d404-4905-942d-1e0834c26dea\n---\n# Specifying and Handling Faults in Contracts and Services\nWindows Communication Foundation (WCF) applications handle error situations by mapping managed exception objects to SOAP fault objects and SOAP fault objects to managed exception objects. The topics in this section discuss how to design contracts to expose error conditions as custom SOAP faults, how to return such faults as part of service implementation, and how clients catch such faults.  \n  \n## Error Handling Overview  \n In all managed applications, processing errors are represented by <xref:System.Exception> objects. In SOAP-based applications such as WCF applications, service methods communicate processing error information using SOAP fault messages. SOAP faults are message types that are included in the metadata for a service operation and therefore create a fault contract that clients can use to make their operation more robust or interactive. In addition, because SOAP faults are expressed to clients in XML form, it is a highly interoperable type system that clients on any SOAP platform can use, increasing the reach of your WCF application.  \n  \n Because WCF applications run under both types of error systems, any managed exception information that is sent to the client must be converted from exceptions into SOAP faults on the service, sent, and converted from SOAP faults to fault exceptions in WCF clients. In the case of duplex clients, client contracts can also send SOAP faults back to a service. In either case, you can use the default service exception behaviors, or you can explicitly control whether—and how—exceptions are mapped to fault messages.  \n  \n Two types of SOAP faults can be sent: *declared* and *undeclared*. Declared SOAP faults are those in which an operation has a <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType> attribute that specifies a custom SOAP fault type. *Undeclared* SOAP faults are not specified in the contract for an operation.  \n  \n It is strongly recommended that service operations declare their faults by using the <xref:System.ServiceModel.FaultContractAttribute> attribute to formally specify all SOAP faults that a client can expect to receive in the normal course of an operation. It is also recommended that you return in a SOAP fault only the information that a client must know to minimize information disclosure.  \n  \n Typically, services (and duplex clients) take the following steps to successfully integrate error handling into their applications:  \n  \n-   Map exception conditions to custom SOAP faults.  \n  \n-   Clients and services send and receive SOAP faults as exceptions.  \n  \n In addition, WCF clients and services can use undeclared soap faults for debugging purposes and can extend the default error behavior. The following sections discuss these tasks and concepts.  \n  \n## Map Exceptions to SOAP Faults  \n The first step in creating an operation that handles error conditions is to decide under what conditions a client application should be informed about errors. Some operations have error conditions specific to their functionality. For example, a `PurchaseOrder` operation might return specific information to customers who are no longer permitted to initiate a purchase order. In other cases, such as a `Calculator` service, a more general `MathFault` SOAP fault may be able to describe all error conditions across an entire service. Once the error conditions of clients of your service are identified, a custom SOAP fault can be constructed and the operation can be marked as returning that SOAP fault when its corresponding error condition arises.  \n  \n For more information about this step of developing your service or client, see [Defining and Specifying Faults](../../../docs/framework/wcf/defining-and-specifying-faults.md).  \n  \n## Clients and Services Handle SOAP Faults as Exceptions  \n Identifying operation error conditions, defining custom SOAP faults, and marking those operations as returning those faults are the first steps in successful error handling in WCF applications. The next step is to properly implement the sending and receiving of these faults. Typically services send faults to inform client applications about error conditions, but duplex clients can also send SOAP faults to services.  \n  \n For more information, see [Sending and Receiving Faults](../../../docs/framework/wcf/sending-and-receiving-faults.md).  \n  \n## Undeclared SOAP Faults and Debugging  \n Declared SOAP faults are extremely useful for building robust, interoperable, distributed applications. However, in some cases it is useful for a service (or duplex client) to send an undeclared SOAP fault, one that is not mentioned in the Web Services Description Language (WSDL) for that operation. For example, when developing a service, unexpected situations can occur in which it is useful for debugging purposes to send information back to the client. In addition, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property or the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property to `true` to permit WCF clients to obtain information about internal service operation exceptions. Both sending individual faults and setting the debugging behavior properties are described in [Sending and Receiving Faults](../../../docs/framework/wcf/sending-and-receiving-faults.md).  \n  \n> [!IMPORTANT]\n>  Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.  \n>   \n>  Therefore, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` is recommended only as a way to temporarily debug a service application. In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>. Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> objects) to obtain the debugging information properly.  \n  \n## Customizing Error Handling with IErrorHandler  \n If you have special requirements to either customize the response message to the client when an application-level exception happens or perform some custom processing after the response message is returned, implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> interface.  \n  \n## Fault Serialization Issues  \n When deserializing a fault contract, WCF first attempts to match the fault contract name in the SOAP message with the fault contract type. If it cannot find an exact match it will then search the list of available fault contracts in alphabetical order for a compatible type. If two fault contracts are compatible types (one is a subclass of another, for example) the wrong type may be used to de-serialize the fault. This only occurs if the fault contract does not specify a name, namespace, and action. To prevent this issue from occurring, always fully qualify fault contracts by specifying the name, namespace, and action attributes. Additionally if you have defined a number of related fault contracts derived from a shared base class, make sure to mark any new members with `[DataMember(IsRequired=true)]`. For more information on this `IsRequired` attribute see, <xref:System.Runtime.Serialization.DataMemberAttribute>. This will prevent a base class from being a compatible type and force the fault to be deserialized into the correct derived type.  \n  \n## See also\n\n- <xref:System.ServiceModel.FaultException>\n- <xref:System.ServiceModel.FaultContractAttribute>\n- <xref:System.ServiceModel.FaultException>\n- <xref:System.Xml.Serialization.XmlSerializer>\n- <xref:System.ServiceModel.XmlSerializerFormatAttribute>\n- <xref:System.ServiceModel.FaultContractAttribute>\n- <xref:System.ServiceModel.CommunicationException>\n- <xref:System.ServiceModel.FaultContractAttribute.Action%2A>\n- <xref:System.ServiceModel.FaultException.Code%2A>\n- <xref:System.ServiceModel.FaultException.Reason%2A>\n- <xref:System.ServiceModel.FaultCode.SubCode%2A>\n- <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A>\n- [Defining and Specifying Faults](../../../docs/framework/wcf/defining-and-specifying-faults.md)\n","nodes":[{"pos":[4,190],"embed":true,"restype":"x-metadata","content":"title: \"Specifying and Handling Faults in Contracts and Services\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"handling faults [WCF]\"\nms.assetid: a9696563-d404-4905-942d-1e0834c26dea","nodes":[{"content":"Specifying and Handling Faults in Contracts and Services","nodes":[{"pos":[0,56],"content":"Specifying and Handling Faults in Contracts and Services","nodes":[{"content":"Specifying and Handling Faults in Contracts and Services","pos":[0,56]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[197,253],"content":"Specifying and Handling Faults in Contracts and Services","linkify":"Specifying and Handling Faults in Contracts and Services","nodes":[{"content":"Specifying and Handling Faults in Contracts and Services","pos":[0,56]}]},{"content":"Windows Communication Foundation (WCF) applications handle error situations by mapping managed exception objects to SOAP fault objects and SOAP fault objects to managed exception objects.","pos":[254,441]},{"content":"The topics in this section discuss how to design contracts to expose error conditions as custom SOAP faults, how to return such faults as part of service implementation, and how clients catch such faults.","pos":[442,646]},{"pos":[655,678],"content":"Error Handling Overview","linkify":"Error Handling Overview","nodes":[{"content":"Error Handling Overview","pos":[0,23]}]},{"content":"In all managed applications, processing errors are represented by <ph id=\"ph1\">&lt;xref:System.Exception&gt;</ph> objects.","pos":[682,780],"source":"In all managed applications, processing errors are represented by <xref:System.Exception> objects."},{"content":"In SOAP-based applications such as WCF applications, service methods communicate processing error information using SOAP fault messages.","pos":[781,917]},{"content":"SOAP faults are message types that are included in the metadata for a service operation and therefore create a fault contract that clients can use to make their operation more robust or interactive.","pos":[918,1116]},{"content":"In addition, because SOAP faults are expressed to clients in XML form, it is a highly interoperable type system that clients on any SOAP platform can use, increasing the reach of your WCF application.","pos":[1117,1317]},{"content":"Because WCF applications run under both types of error systems, any managed exception information that is sent to the client must be converted from exceptions into SOAP faults on the service, sent, and converted from SOAP faults to fault exceptions in WCF clients.","pos":[1324,1588]},{"content":"In the case of duplex clients, client contracts can also send SOAP faults back to a service.","pos":[1589,1681]},{"content":"In either case, you can use the default service exception behaviors, or you can explicitly control whether—and how—exceptions are mapped to fault messages.","pos":[1682,1837]},{"content":"Two types of SOAP faults can be sent: <bpt id=\"p1\">*</bpt>declared<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>undeclared<ept id=\"p2\">*</ept>.","pos":[1844,1910],"source":"Two types of SOAP faults can be sent: *declared* and *undeclared*."},{"content":"Declared SOAP faults are those in which an operation has a <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType&gt;</ph> attribute that specifies a custom SOAP fault type.","pos":[1911,2099],"source":" Declared SOAP faults are those in which an operation has a <xref:System.ServiceModel.FaultContractAttribute?displayProperty=nameWithType> attribute that specifies a custom SOAP fault type."},{"content":"<bpt id=\"p1\">*</bpt>Undeclared<ept id=\"p1\">*</ept> SOAP faults are not specified in the contract for an operation.","pos":[2100,2176],"source":"*Undeclared* SOAP faults are not specified in the contract for an operation."},{"content":"It is strongly recommended that service operations declare their faults by using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultContractAttribute&gt;</ph> attribute to formally specify all SOAP faults that a client can expect to receive in the normal course of an operation.","pos":[2183,2437],"source":"It is strongly recommended that service operations declare their faults by using the <xref:System.ServiceModel.FaultContractAttribute> attribute to formally specify all SOAP faults that a client can expect to receive in the normal course of an operation."},{"content":"It is also recommended that you return in a SOAP fault only the information that a client must know to minimize information disclosure.","pos":[2438,2573]},{"content":"Typically, services (and duplex clients) take the following steps to successfully integrate error handling into their applications:","pos":[2580,2711]},{"content":"Map exception conditions to custom SOAP faults.","pos":[2721,2768]},{"content":"Clients and services send and receive SOAP faults as exceptions.","pos":[2778,2842]},{"content":"In addition, WCF clients and services can use undeclared soap faults for debugging purposes and can extend the default error behavior.","pos":[2849,2983]},{"content":"The following sections discuss these tasks and concepts.","pos":[2984,3040]},{"pos":[3049,3078],"content":"Map Exceptions to SOAP Faults","linkify":"Map Exceptions to SOAP Faults","nodes":[{"content":"Map Exceptions to SOAP Faults","pos":[0,29]}]},{"content":"The first step in creating an operation that handles error conditions is to decide under what conditions a client application should be informed about errors.","pos":[3082,3240]},{"content":"Some operations have error conditions specific to their functionality.","pos":[3241,3311]},{"content":"For example, a <ph id=\"ph1\">`PurchaseOrder`</ph> operation might return specific information to customers who are no longer permitted to initiate a purchase order.","pos":[3312,3457],"source":" For example, a `PurchaseOrder` operation might return specific information to customers who are no longer permitted to initiate a purchase order."},{"content":"In other cases, such as a <ph id=\"ph1\">`Calculator`</ph> service, a more general <ph id=\"ph2\">`MathFault`</ph> SOAP fault may be able to describe all error conditions across an entire service.","pos":[3458,3614],"source":" In other cases, such as a `Calculator` service, a more general `MathFault` SOAP fault may be able to describe all error conditions across an entire service."},{"content":"Once the error conditions of clients of your service are identified, a custom SOAP fault can be constructed and the operation can be marked as returning that SOAP fault when its corresponding error condition arises.","pos":[3615,3830]},{"pos":[3837,4012],"content":"For more information about this step of developing your service or client, see <bpt id=\"p1\">[</bpt>Defining and Specifying Faults<ept id=\"p1\">](../../../docs/framework/wcf/defining-and-specifying-faults.md)</ept>.","source":"For more information about this step of developing your service or client, see [Defining and Specifying Faults](../../../docs/framework/wcf/defining-and-specifying-faults.md)."},{"pos":[4021,4074],"content":"Clients and Services Handle SOAP Faults as Exceptions","linkify":"Clients and Services Handle SOAP Faults as Exceptions","nodes":[{"content":"Clients and Services Handle SOAP Faults as Exceptions","pos":[0,53]}]},{"content":"Identifying operation error conditions, defining custom SOAP faults, and marking those operations as returning those faults are the first steps in successful error handling in WCF applications.","pos":[4078,4271]},{"content":"The next step is to properly implement the sending and receiving of these faults.","pos":[4272,4353]},{"content":"Typically services send faults to inform client applications about error conditions, but duplex clients can also send SOAP faults to services.","pos":[4354,4496]},{"pos":[4503,4621],"content":"For more information, see <bpt id=\"p1\">[</bpt>Sending and Receiving Faults<ept id=\"p1\">](../../../docs/framework/wcf/sending-and-receiving-faults.md)</ept>.","source":"For more information, see [Sending and Receiving Faults](../../../docs/framework/wcf/sending-and-receiving-faults.md)."},{"pos":[4630,4666],"content":"Undeclared SOAP Faults and Debugging","linkify":"Undeclared SOAP Faults and Debugging","nodes":[{"content":"Undeclared SOAP Faults and Debugging","pos":[0,36]}]},{"content":"Declared SOAP faults are extremely useful for building robust, interoperable, distributed applications.","pos":[4670,4773]},{"content":"However, in some cases it is useful for a service (or duplex client) to send an undeclared SOAP fault, one that is not mentioned in the Web Services Description Language (WSDL) for that operation.","pos":[4774,4970]},{"content":"For example, when developing a service, unexpected situations can occur in which it is useful for debugging purposes to send information back to the client.","pos":[4971,5127]},{"content":"In addition, you can set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType&gt;</ph> property or the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType&gt;</ph> property to <ph id=\"ph3\">`true`</ph> to permit WCF clients to obtain information about internal service operation exceptions.","pos":[5128,5518],"source":" In addition, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property or the <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> property to `true` to permit WCF clients to obtain information about internal service operation exceptions."},{"content":"Both sending individual faults and setting the debugging behavior properties are described in <bpt id=\"p1\">[</bpt>Sending and Receiving Faults<ept id=\"p1\">](../../../docs/framework/wcf/sending-and-receiving-faults.md)</ept>.","pos":[5519,5705],"source":" Both sending individual faults and setting the debugging behavior properties are described in [Sending and Receiving Faults](../../../docs/framework/wcf/sending-and-receiving-faults.md)."},{"pos":[5713,6215],"content":"[!IMPORTANT]\n Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.","leadings":["","> "],"nodes":[{"content":"Because managed exceptions can expose internal application information, setting <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType&gt;</ph> to <ph id=\"ph3\">`true`</ph> can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information.","pos":[14,500],"source":"Because managed exceptions can expose internal application information, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` can permit WCF clients to obtain information about internal service operation exceptions, including personally identifiable or other sensitive information."}]},{"content":"Therefore, setting <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType&gt;</ph> to <ph id=\"ph3\">`true`</ph> is recommended only as a way to temporarily debug a service application.","pos":[6226,6568],"source":"Therefore, setting <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A?displayProperty=nameWithType> to `true` is recommended only as a way to temporarily debug a service application."},{"content":"In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException%601&gt;</ph> of type <ph id=\"ph2\">&lt;xref:System.ServiceModel.ExceptionDetail&gt;</ph>.","pos":[6569,6793],"source":" In addition, the WSDL for a method that returns unhandled managed exceptions in this way does not contain the contract for the <xref:System.ServiceModel.FaultException%601> of type <xref:System.ServiceModel.ExceptionDetail>."},{"content":"Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <ph id=\"ph1\">&lt;xref:System.ServiceModel.FaultException?displayProperty=nameWithType&gt;</ph> objects) to obtain the debugging information properly.","pos":[6794,7008],"source":" Clients must expect the possibility of an unknown SOAP fault (returned to WCF clients as <xref:System.ServiceModel.FaultException?displayProperty=nameWithType> objects) to obtain the debugging information properly."},{"pos":[7017,7062],"content":"Customizing Error Handling with IErrorHandler","linkify":"Customizing Error Handling with IErrorHandler","nodes":[{"content":"Customizing Error Handling with IErrorHandler","pos":[0,45]}]},{"pos":[7066,7377],"content":"If you have special requirements to either customize the response message to the client when an application-level exception happens or perform some custom processing after the response message is returned, implement the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType&gt;</ph> interface.","source":"If you have special requirements to either customize the response message to the client when an application-level exception happens or perform some custom processing after the response message is returned, implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler?displayProperty=nameWithType> interface."},{"pos":[7386,7412],"content":"Fault Serialization Issues","linkify":"Fault Serialization Issues","nodes":[{"content":"Fault Serialization Issues","pos":[0,26]}]},{"content":"When deserializing a fault contract, WCF first attempts to match the fault contract name in the SOAP message with the fault contract type.","pos":[7416,7554]},{"content":"If it cannot find an exact match it will then search the list of available fault contracts in alphabetical order for a compatible type.","pos":[7555,7690]},{"content":"If two fault contracts are compatible types (one is a subclass of another, for example) the wrong type may be used to de-serialize the fault.","pos":[7691,7832]},{"content":"This only occurs if the fault contract does not specify a name, namespace, and action.","pos":[7833,7919]},{"content":"To prevent this issue from occurring, always fully qualify fault contracts by specifying the name, namespace, and action attributes.","pos":[7920,8052]},{"content":"Additionally if you have defined a number of related fault contracts derived from a shared base class, make sure to mark any new members with <ph id=\"ph1\">`[DataMember(IsRequired=true)]`</ph>.","pos":[8053,8227],"source":" Additionally if you have defined a number of related fault contracts derived from a shared base class, make sure to mark any new members with `[DataMember(IsRequired=true)]`."},{"content":"For more information on this <ph id=\"ph1\">`IsRequired`</ph> attribute see, <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph>.","pos":[8228,8341],"source":" For more information on this `IsRequired` attribute see, <xref:System.Runtime.Serialization.DataMemberAttribute>."},{"content":"This will prevent a base class from being a compatible type and force the fault to be deserialized into the correct derived type.","pos":[8342,8471]},{"pos":[8480,8488],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9128,9223],"content":"<bpt id=\"p1\">[</bpt>Defining and Specifying Faults<ept id=\"p1\">](../../../docs/framework/wcf/defining-and-specifying-faults.md)</ept>","source":"[Defining and Specifying Faults](../../../docs/framework/wcf/defining-and-specifying-faults.md)"}]}