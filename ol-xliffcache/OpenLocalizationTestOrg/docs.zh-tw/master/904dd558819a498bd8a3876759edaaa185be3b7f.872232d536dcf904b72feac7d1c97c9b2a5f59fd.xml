{"content":"---\ntitle: \"Refactoring Using an Extension Method (C#)\"\nms.date: 07/20/2015\nms.assetid: c5fc123d-af10-4a2f-b8e4-db921efb2639\n---\n# Refactoring Using an Extension Method (C#)\nThis example builds on the previous example, [Retrieving the Text of the Paragraphs (C#)](../../../../csharp/programming-guide/concepts/linq/retrieving-the-text-of-the-paragraphs.md), by refactoring the concatenation of strings using a pure function that is implemented as an extension method.  \n  \n The previous example used the <xref:System.Linq.Enumerable.Aggregate%2A> standard query operator to concatenate multiple strings into one string. However, it is more convenient to write an extension method to do this, because the resulting query smaller and more simple.  \n  \n## Example  \n This example processes a WordprocessingML document, retrieving the paragraphs, the style of each paragraph, and the text of each paragraph. This example builds on the previous examples in this tutorial.  \n  \n The example contains multiple overloads of the `StringConcatenate` method.  \n  \n You can find instructions for creating the source document for this example in [Creating the Source Office Open XML Document (C#)](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md).  \n  \n This example uses classes from the WindowsBase assembly. It uses types in the <xref:System.IO.Packaging?displayProperty=nameWithType> namespace.  \n  \n```csharp  \npublic static class LocalExtensions  \n{  \n    public static string StringConcatenate(this IEnumerable<string> source)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item));  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate(this IEnumerable<string> source, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s).Append(separator);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item)).Append(separator);  \n        return sb.ToString();  \n    }  \n}  \n```  \n  \n## Example  \n There are four overloads of the `StringConcatenate` method. One overload simply takes a collection of strings and returns a single string. Another overload can take a collection of any type, and a delegate that projects from a singleton of the collection to a string. There are two more overloads that allow you to specify a separator string.  \n  \n The following code uses all four overloads.  \n  \n```csharp  \nstring[] numbers = { \"one\", \"two\", \"three\" };  \n  \nConsole.WriteLine(\"{0}\", numbers.StringConcatenate());  \nConsole.WriteLine(\"{0}\", numbers.StringConcatenate(\":\"));  \n  \nint[] intNumbers = { 1, 2, 3 };  \nConsole.WriteLine(\"{0}\", intNumbers.StringConcatenate(i => i.ToString()));  \nConsole.WriteLine(\"{0}\", intNumbers.StringConcatenate(i => i.ToString(), \":\"));  \n```  \n  \n This example produces the following output:  \n  \n```  \nonetwothree  \none:two:three:  \n123  \n1:2:3:  \n```  \n  \n## Example  \n Now, the example can be modified to take advantage of the new extension method:  \n  \n```csharp  \npublic static class LocalExtensions  \n{  \n    public static string StringConcatenate(this IEnumerable<string> source)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item));  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate(this IEnumerable<string> source, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s).Append(separator);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item)).Append(separator);  \n        return sb.ToString();  \n    }  \n}  \n  \nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        const string fileName = \"SampleDoc.docx\";  \n  \n        const string documentRelationshipType =  \n          \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\";  \n        const string stylesRelationshipType =  \n          \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\";  \n        const string wordmlNamespace =  \n          \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\";  \n        XNamespace w = wordmlNamespace;  \n  \n        XDocument xDoc = null;  \n        XDocument styleDoc = null;  \n  \n        using (Package wdPackage = Package.Open(fileName, FileMode.Open, FileAccess.Read))  \n        {  \n            PackageRelationship docPackageRelationship =  \n              wdPackage.GetRelationshipsByType(documentRelationshipType).FirstOrDefault();  \n            if (docPackageRelationship != null)  \n            {  \n                Uri documentUri = PackUriHelper.ResolvePartUri(new Uri(\"/\", UriKind.Relative),  \n                  docPackageRelationship.TargetUri);  \n                PackagePart documentPart = wdPackage.GetPart(documentUri);  \n  \n                //  Load the document XML in the part into an XDocument instance.  \n                xDoc = XDocument.Load(XmlReader.Create(documentPart.GetStream()));  \n  \n                //  Find the styles part. There will only be one.  \n                PackageRelationship styleRelation =  \n                  documentPart.GetRelationshipsByType(stylesRelationshipType).FirstOrDefault();  \n                if (styleRelation != null)  \n                {  \n                    Uri styleUri =  \n                      PackUriHelper.ResolvePartUri(documentUri, styleRelation.TargetUri);  \n                    PackagePart stylePart = wdPackage.GetPart(styleUri);  \n  \n                    //  Load the style XML in the part into an XDocument instance.  \n                    styleDoc = XDocument.Load(XmlReader.Create(stylePart.GetStream()));  \n                }  \n            }  \n        }  \n  \n        string defaultStyle =  \n            (string)(  \n                from style in styleDoc.Root.Elements(w + \"style\")  \n                where (string)style.Attribute(w + \"type\") == \"paragraph\" &&  \n                      (string)style.Attribute(w + \"default\") == \"1\"  \n                select style  \n            ).First().Attribute(w + \"styleId\");  \n  \n        // Find all paragraphs in the document.  \n        var paragraphs =  \n            from para in xDoc  \n                         .Root  \n                         .Element(w + \"body\")  \n                         .Descendants(w + \"p\")  \n            let styleNode = para  \n                            .Elements(w + \"pPr\")  \n                            .Elements(w + \"pStyle\")  \n                            .FirstOrDefault()  \n            select new  \n            {  \n                ParagraphNode = para,  \n                StyleName = styleNode != null ?  \n                    (string)styleNode.Attribute(w + \"val\") :  \n                    defaultStyle  \n            };  \n  \n        // Retrieve the text of each paragraph.  \n        var paraWithText =  \n            from para in paragraphs  \n            select new  \n            {  \n                ParagraphNode = para.ParagraphNode,  \n                StyleName = para.StyleName,  \n                Text = para  \n                       .ParagraphNode  \n                       .Elements(w + \"r\")  \n                       .Elements(w + \"t\")  \n                       .StringConcatenate(e => (string)e)  \n            };  \n  \n        foreach (var p in paraWithText)  \n            Console.WriteLine(\"StyleName:{0} >{1}<\", p.StyleName, p.Text);  \n    }  \n}  \n```  \n  \n This example produces the following output when applied to the document described in [Creating the Source Office Open XML Document (C#)](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md).  \n  \n```  \nStyleName:Heading1 >Parsing WordprocessingML with LINQ to XML<  \nStyleName:Normal ><  \nStyleName:Normal >The following example prints to the console.<  \nStyleName:Normal ><  \nStyleName:Code >using System;<  \nStyleName:Code ><  \nStyleName:Code >class Program {<  \nStyleName:Code >    public static void (string[] args) {<  \nStyleName:Code >        Console.WriteLine(\"Hello World\");<  \nStyleName:Code >    }<  \nStyleName:Code >}<  \nStyleName:Normal ><  \nStyleName:Normal >This example produces the following output:<  \nStyleName:Normal ><  \nStyleName:Code >Hello World<  \n```  \n  \n Note that this refactoring is a variant of refactoring into a pure function. The next topic will introduce the idea of factoring into pure functions in more detail.  \n  \n## Next Steps  \n The next example shows how to refactor this code in another way, by using pure functions:  \n  \n-   [Refactoring Using a Pure Function (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/refactoring-using-a-pure-function.md)  \n  \n## See also\n\n- [Tutorial: Manipulating Content in a WordprocessingML Document (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)\n- [Refactoring Into Pure Functions (C#)](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)\n","nodes":[{"pos":[4,124],"embed":true,"restype":"x-metadata","content":"title: \"Refactoring Using an Extension Method (C#)\"\nms.date: 07/20/2015\nms.assetid: c5fc123d-af10-4a2f-b8e4-db921efb2639","nodes":[{"content":"Refactoring Using an Extension Method (C#)","nodes":[{"pos":[0,42],"content":"Refactoring Using an Extension Method (C#)","nodes":[{"content":"Refactoring Using an Extension Method (C#)","pos":[0,42]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[131,173],"content":"Refactoring Using an Extension Method (C#)","linkify":"Refactoring Using an Extension Method (C#)","nodes":[{"content":"Refactoring Using an Extension Method (C#)","pos":[0,42]}]},{"pos":[174,467],"content":"This example builds on the previous example, <bpt id=\"p1\">[</bpt>Retrieving the Text of the Paragraphs (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/retrieving-the-text-of-the-paragraphs.md)</ept>, by refactoring the concatenation of strings using a pure function that is implemented as an extension method.","source":"This example builds on the previous example, [Retrieving the Text of the Paragraphs (C#)](../../../../csharp/programming-guide/concepts/linq/retrieving-the-text-of-the-paragraphs.md), by refactoring the concatenation of strings using a pure function that is implemented as an extension method."},{"content":"The previous example used the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Aggregate%2A&gt;</ph> standard query operator to concatenate multiple strings into one string.","pos":[474,619],"source":"The previous example used the <xref:System.Linq.Enumerable.Aggregate%2A> standard query operator to concatenate multiple strings into one string."},{"content":"However, it is more convenient to write an extension method to do this, because the resulting query smaller and more simple.","pos":[620,744]},{"pos":[753,760],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example processes a WordprocessingML document, retrieving the paragraphs, the style of each paragraph, and the text of each paragraph.","pos":[764,903]},{"content":"This example builds on the previous examples in this tutorial.","pos":[904,966]},{"pos":[973,1047],"content":"The example contains multiple overloads of the <ph id=\"ph1\">`StringConcatenate`</ph> method.","source":"The example contains multiple overloads of the `StringConcatenate` method."},{"pos":[1054,1285],"content":"You can find instructions for creating the source document for this example in <bpt id=\"p1\">[</bpt>Creating the Source Office Open XML Document (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md)</ept>.","source":"You can find instructions for creating the source document for this example in [Creating the Source Office Open XML Document (C#)](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md)."},{"content":"This example uses classes from the WindowsBase assembly.","pos":[1292,1348]},{"content":"It uses types in the <ph id=\"ph1\">&lt;xref:System.IO.Packaging?displayProperty=nameWithType&gt;</ph> namespace.","pos":[1349,1436],"source":" It uses types in the <xref:System.IO.Packaging?displayProperty=nameWithType> namespace."},{"pos":[2639,2646],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"There are four overloads of the <ph id=\"ph1\">`StringConcatenate`</ph> method.","pos":[2650,2709],"source":"There are four overloads of the `StringConcatenate` method."},{"content":"One overload simply takes a collection of strings and returns a single string.","pos":[2710,2788]},{"content":"Another overload can take a collection of any type, and a delegate that projects from a singleton of the collection to a string.","pos":[2789,2917]},{"content":"There are two more overloads that allow you to specify a separator string.","pos":[2918,2992]},{"content":"The following code uses all four overloads.","pos":[2999,3042]},{"content":"This example produces the following output:","pos":[3434,3477]},{"pos":[3547,3554],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Now, the example can be modified to take advantage of the new extension method:","pos":[3558,3637]},{"pos":[8587,8824],"content":"This example produces the following output when applied to the document described in <bpt id=\"p1\">[</bpt>Creating the Source Office Open XML Document (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md)</ept>.","source":"This example produces the following output when applied to the document described in [Creating the Source Office Open XML Document (C#)](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md)."},{"content":"Note that this refactoring is a variant of refactoring into a pure function.","pos":[9416,9492]},{"content":"The next topic will introduce the idea of factoring into pure functions in more detail.","pos":[9493,9580]},{"pos":[9589,9599],"content":"Next Steps","linkify":"Next Steps","nodes":[{"content":"Next Steps","pos":[0,10]}]},{"content":"The next example shows how to refactor this code in another way, by using pure functions:","pos":[9603,9692]},{"pos":[9702,9847],"content":"<bpt id=\"p1\">[</bpt>Refactoring Using a Pure Function (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/refactoring-using-a-pure-function.md)</ept>","source":"[Refactoring Using a Pure Function (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/refactoring-using-a-pure-function.md)"},{"pos":[9856,9864],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9868,10052],"content":"<bpt id=\"p1\">[</bpt>Tutorial: Manipulating Content in a WordprocessingML Document (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept>","source":"[Tutorial: Manipulating Content in a WordprocessingML Document (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)"},{"pos":[10055,10180],"content":"<bpt id=\"p1\">[</bpt>Refactoring Into Pure Functions (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)</ept>","source":"[Refactoring Into Pure Functions (C#)](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)"}]}