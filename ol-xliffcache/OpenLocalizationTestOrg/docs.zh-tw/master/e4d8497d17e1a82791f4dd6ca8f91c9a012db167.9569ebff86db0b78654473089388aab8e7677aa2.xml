{"content":"---\ntitle: \"Securing Wrapper Code\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"security [.NET Framework], wrapper code\"\n  - \"wrapper code, securing\"\n  - \"secure coding, wrapper code\"\n  - \"code security, wrapper code\"\nms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Securing Wrapper Code\n[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  \n  \n Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses. Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.  \n  \n Never enable something through the wrapper that the caller could not do itself. This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand. When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.  \n  \n## Delegates  \n Delegate security differs between versions of the .NET Framework.  This section describes the different delegate behaviors and associated security considerations.  \n  \n### In version 1.0 and 1.1 of the .NET Framework  \n Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.  \n  \n-   When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.  Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.  \n  \n-   When the delegate is invoked, any existing security demands on the delegate caller are performed.  \n  \n Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions. If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation. If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.  \n  \n### In version 2.0 and later versions of the .NET Framework  \n Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.  \n  \n-   When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.  Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.  \n  \n-   The delegate creator's grant set is also captured during delegate creation and stored with the delegate.  \n  \n-   When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.  Next, any existing security demands on the delegate caller are performed.  \n  \n## Link demands and wrappers  \n A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.  \n  \n If fully trusted code calls a property, event, or method protected by a [LinkDemand](../../../docs/framework/misc/link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied. Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property. This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code. In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.  \n  \n To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**. This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.  \n  \n## Assembly loading wrappers  \n Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller. If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies. You should not allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.  \n  \n Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way. If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security.  \n  \n This issue applies to the following API elements:  \n  \n-   <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  \n  \n-   <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  \n  \n-   <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  \n  \n-   <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  \n  \n## Demand vs. LinkDemand  \n Declarative security offers two kinds of security checks that are similar but perform very different checks. You should understand both forms because the wrong choice can result in weak security or performance loss.  \n  \n Declarative security offers the following security checks:  \n  \n-   <xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk. All callers on the stack must have the specified permission or identity to pass. **Demand** occurs on every call because the stack might contain different callers. If you call a method repeatedly, this security check occurs each time. **Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected.  \n  \n-   [LinkDemand](../../../docs/framework/misc/link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller. This security check does not check the caller's caller. Once this check passes, there is no additional security overhead no matter how many times the caller might call. However, there is also no protection from luring attacks. With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code. Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided.  \n  \n    > [!NOTE]\n    >  In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies. The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules. For more information about this change, see [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md).  \n  \n The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement. Any mistake opens a security weakness. All authorized code that uses your code must be responsible for implementing additional security by doing the following:  \n  \n-   Restricting the calling code's access to the class or assembly.  \n  \n-   Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so. For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission. The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code. In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.  \n  \n-   Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf. In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.  \n  \n### Interfaces and Link Demands  \n If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective. It is possible for malicious code to cast back to the base type and call the base class method. Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute.  \n  \n It is a good practice to protect method implementations with link demands when interface methods also have link demands. Note the following about using link demands with interfaces:  \n  \n-   If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method. In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored.  \n  \n Review the following items for security issues:  \n  \n-   Explicit link demands on interface methods. Make sure these link demands offer the expected protection. Determine whether malicious code can use a cast to get around the link demands as described previously.  \n  \n-   Virtual methods with link demands applied.  \n  \n-   Types and the interfaces they implement. These should use link demands consistently.  \n  \n## See also\n\n- [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)\n","nodes":[{"pos":[4,307],"embed":true,"restype":"x-metadata","content":"title: \"Securing Wrapper Code\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"security [.NET Framework], wrapper code\"\n  - \"wrapper code, securing\"\n  - \"secure coding, wrapper code\"\n  - \"code security, wrapper code\"\nms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Securing Wrapper Code","nodes":[{"pos":[0,21],"content":"Securing Wrapper Code","nodes":[{"content":"Securing Wrapper Code","pos":[0,21]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[314,335],"content":"Securing Wrapper Code","linkify":"Securing Wrapper Code","nodes":[{"content":"Securing Wrapper Code","pos":[0,21]}]},{"content":"Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses.","pos":[415,544]},{"content":"Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.","pos":[545,713]},{"content":"Never enable something through the wrapper that the caller could not do itself.","pos":[720,799]},{"content":"This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand.","pos":[800,925]},{"content":"When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.","pos":[926,1144]},{"pos":[1153,1162],"content":"Delegates","linkify":"Delegates","nodes":[{"content":"Delegates","pos":[0,9]}]},{"content":"Delegate security differs between versions of the .NET Framework.","pos":[1166,1231]},{"content":"This section describes the different delegate behaviors and associated security considerations.","pos":[1233,1328]},{"pos":[1338,1382],"content":"In version 1.0 and 1.1 of the .NET Framework","linkify":"In version 1.0 and 1.1 of the .NET Framework","nodes":[{"content":"In version 1.0 and 1.1 of the .NET Framework","pos":[0,44]}]},{"content":"Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.","pos":[1386,1516]},{"content":"When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.","pos":[1526,1666]},{"content":"Failure to satisfy the security action results in a <ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph>.","pos":[1668,1761],"source":"  Failure to satisfy the security action results in a <xref:System.Security.SecurityException>."},{"content":"When the delegate is invoked, any existing security demands on the delegate caller are performed.","pos":[1771,1868]},{"content":"Whenever your code takes a <ph id=\"ph1\">&lt;xref:System.Delegate&gt;</ph> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions.","pos":[1875,2054],"source":"Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions."},{"content":"If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation.","pos":[2055,2259]},{"content":"If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.","pos":[2260,2413]},{"pos":[2423,2478],"content":"In version 2.0 and later versions of the .NET Framework","linkify":"In version 2.0 and later versions of the .NET Framework","nodes":[{"content":"In version 2.0 and later versions of the .NET Framework","pos":[0,55]}]},{"content":"Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.","pos":[2482,2655]},{"content":"When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.","pos":[2665,2805]},{"content":"Failure to satisfy the security action results in a <ph id=\"ph1\">&lt;xref:System.Security.SecurityException&gt;</ph>.","pos":[2807,2900],"source":"  Failure to satisfy the security action results in a <xref:System.Security.SecurityException>."},{"content":"The delegate creator's grant set is also captured during delegate creation and stored with the delegate.","pos":[2910,3014]},{"content":"When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.","pos":[3024,3224]},{"content":"Next, any existing security demands on the delegate caller are performed.","pos":[3226,3299]},{"pos":[3308,3333],"content":"Link demands and wrappers","linkify":"Link demands and wrappers","nodes":[{"content":"Link demands and wrappers","pos":[0,25]}]},{"content":"A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.","pos":[3337,3494]},{"content":"If fully trusted code calls a property, event, or method protected by a <bpt id=\"p1\">[</bpt>LinkDemand<ept id=\"p1\">](../../../docs/framework/misc/link-demands.md)</ept>, the call succeeds if the <bpt id=\"p2\">**</bpt>LinkDemand<ept id=\"p2\">**</ept> permission check for the caller is satisfied.","pos":[3501,3718],"source":"If fully trusted code calls a property, event, or method protected by a [LinkDemand](../../../docs/framework/misc/link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied."},{"content":"Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its <bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept> accessor using reflection, that call to the <bpt id=\"p2\">**</bpt>get<ept id=\"p2\">**</ept> accessor succeeds even though the user code does not have the right to access this property.","pos":[3719,3975],"source":" Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property."},{"content":"This is because the <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> checks only the immediate caller, which is the fully trusted code.","pos":[3976,4077],"source":" This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code."},{"content":"In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.","pos":[4078,4235]},{"content":"To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept>.","pos":[4242,4454],"source":"To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**."},{"content":"This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.","pos":[4455,4640]},{"pos":[4649,4674],"content":"Assembly loading wrappers","linkify":"Assembly loading wrappers","nodes":[{"content":"Assembly loading wrappers","pos":[0,25]}]},{"content":"Several methods used to load managed code, including <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph>, load assemblies with the evidence of the caller.","pos":[4678,4851],"source":"Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller."},{"content":"If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies.","pos":[4852,5027]},{"content":"You should not allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.","pos":[5028,5156]},{"content":"Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way.","pos":[5163,5329]},{"content":"If your code has a public method that takes a byte array and passes it to <bpt id=\"p1\">**</bpt>Assembly.Load<ept id=\"p1\">**</ept>, thereby creating an assembly on the caller's behalf, it might break security.","pos":[5330,5500],"source":" If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security."},{"content":"This issue applies to the following API elements:","pos":[5507,5556]},{"pos":[5886,5907],"content":"Demand vs. LinkDemand","linkify":"Demand vs. LinkDemand","nodes":[{"content":"Demand vs. LinkDemand","pos":[0,21]}]},{"content":"Declarative security offers two kinds of security checks that are similar but perform very different checks.","pos":[5911,6019]},{"content":"You should understand both forms because the wrong choice can result in weak security or performance loss.","pos":[6020,6126]},{"content":"Declarative security offers the following security checks:","pos":[6133,6191]},{"content":"<ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityAction.Demand&gt;</ph> specifies the code access security stack walk.","pos":[6201,6304],"source":"<xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk."},{"content":"All callers on the stack must have the specified permission or identity to pass.","pos":[6305,6385]},{"content":"<bpt id=\"p1\">**</bpt>Demand<ept id=\"p1\">**</ept> occurs on every call because the stack might contain different callers.","pos":[6386,6468],"source":"**Demand** occurs on every call because the stack might contain different callers."},{"content":"If you call a method repeatedly, this security check occurs each time.","pos":[6469,6539]},{"content":"<bpt id=\"p1\">**</bpt>Demand<ept id=\"p1\">**</ept> is good protection against luring attacks; unauthorized code trying to get through it will be detected.","pos":[6540,6654],"source":"**Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected."},{"content":"<bpt id=\"p1\">[</bpt>LinkDemand<ept id=\"p1\">](../../../docs/framework/misc/link-demands.md)</ept> happens at just-in-time (JIT) compilation time and checks only the immediate caller.","pos":[6664,6807],"source":"[LinkDemand](../../../docs/framework/misc/link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller."},{"content":"This security check does not check the caller's caller.","pos":[6808,6863]},{"content":"Once this check passes, there is no additional security overhead no matter how many times the caller might call.","pos":[6864,6976]},{"content":"However, there is also no protection from luring attacks.","pos":[6977,7034]},{"content":"With <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept>, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code.","pos":[7035,7206],"source":" With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code."},{"content":"Therefore, do not use <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> unless all the possible weaknesses can be thoroughly avoided.","pos":[7207,7305],"source":" Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided."},{"pos":[7317,7854],"content":"[!NOTE]\nIn the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies. The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules. For more information about this change, see [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md).","leadings":["","    >  "],"nodes":[{"content":"In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies. The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules. For more information about this change, see [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md).","pos":[8,530],"nodes":[{"content":"In the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, link demands have been replaced by the <ph id=\"ph2\">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> attribute in <ph id=\"ph3\">&lt;xref:System.Security.SecurityRuleSet.Level2&gt;</ph> assemblies.","pos":[0,229],"source":"In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> is equivalent to a link demand for full trust; however, it also affects inheritance rules.","pos":[230,373],"source":" The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules."},{"content":"For more information about this change, see <bpt id=\"p1\">[</bpt>Security-Transparent Code, Level 2<ept id=\"p1\">](../../../docs/framework/misc/security-transparent-code-level-2.md)</ept>.","pos":[374,522],"source":" For more information about this change, see [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md)."}]}]},{"content":"The extra precautions required when using <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> must be programmed individually; the security system can help with enforcement.","pos":[7861,7997],"source":"The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement."},{"content":"Any mistake opens a security weakness.","pos":[7998,8036]},{"content":"All authorized code that uses your code must be responsible for implementing additional security by doing the following:","pos":[8037,8157]},{"content":"Restricting the calling code's access to the class or assembly.","pos":[8167,8230]},{"content":"Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so.","pos":[8240,8366]},{"content":"For example, if you write code that calls a method that is protected with a <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> for the <ph id=\"ph1\">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode&gt;</ph> flag specified, your method should also make a <bpt id=\"p2\">**</bpt>LinkDemand<ept id=\"p2\">**</ept> (or <bpt id=\"p3\">**</bpt>Demand<ept id=\"p3\">**</ept>, which is stronger) for this permission.","pos":[8367,8718],"source":" For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission."},{"content":"The exception is if your code uses the <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept>-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code.","pos":[8719,8906],"source":" The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code."},{"content":"In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.","pos":[8907,9025]},{"content":"Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf.","pos":[9035,9140]},{"content":"In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.","pos":[9141,9280]},{"pos":[9290,9317],"content":"Interfaces and Link Demands","linkify":"Interfaces and Link Demands","nodes":[{"content":"Interfaces and Link Demands","pos":[0,27]}]},{"content":"If a virtual method, property, or event with <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> overrides a base class method, the base class method must also have the same <bpt id=\"p2\">**</bpt>LinkDemand<ept id=\"p2\">**</ept> for the overridden method in order to be effective.","pos":[9321,9524],"source":"If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective."},{"content":"It is possible for malicious code to cast back to the base type and call the base class method.","pos":[9525,9620]},{"content":"Also note that link demands can be added implicitly to assemblies that do not have the <ph id=\"ph1\">&lt;xref:System.Security.AllowPartiallyTrustedCallersAttribute&gt;</ph> assembly-level attribute.","pos":[9621,9794],"source":" Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute."},{"content":"It is a good practice to protect method implementations with link demands when interface methods also have link demands.","pos":[9801,9921]},{"content":"Note the following about using link demands with interfaces:","pos":[9922,9982]},{"content":"If you place a <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> on a public method of a class that implements an interface method, the <bpt id=\"p2\">**</bpt>LinkDemand<ept id=\"p2\">**</ept> will not be enforced if you then cast to the interface and call the method.","pos":[9992,10183],"source":"If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method."},{"content":"In this case, because you linked against the interface, only the <bpt id=\"p1\">**</bpt>LinkDemand<ept id=\"p1\">**</ept> on the interface is honored.","pos":[10184,10292],"source":" In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored."},{"content":"Review the following items for security issues:","pos":[10299,10346]},{"content":"Explicit link demands on interface methods.","pos":[10356,10399]},{"content":"Make sure these link demands offer the expected protection.","pos":[10400,10459]},{"content":"Determine whether malicious code can use a cast to get around the link demands as described previously.","pos":[10460,10563]},{"content":"Virtual methods with link demands applied.","pos":[10573,10615]},{"content":"Types and the interfaces they implement.","pos":[10625,10665]},{"content":"These should use link demands consistently.","pos":[10666,10709]},{"pos":[10718,10726],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10730,10817],"content":"<bpt id=\"p1\">[</bpt>Secure Coding Guidelines<ept id=\"p1\">](../../../docs/standard/security/secure-coding-guidelines.md)</ept>","source":"[Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)"}]}