{"content":"---\ntitle: \"Intermediate Materialization (C#)\"\nms.date: 07/20/2015\nms.assetid: 7922d38f-5044-41cf-8e17-7173d6553a5e\n---\n# Intermediate Materialization (C#)\nIf you are not careful, in some situations you can drastically alter the memory and performance profile of your application by causing premature materialization of collections in your queries. Some standard query operators cause materialization of their source collection before yielding a single element. For example, <xref:System.Linq.Enumerable.OrderBy%2A?displayProperty=nameWithType> first iterates through its entire source collection, then sorts all items, and then finally yields the first item. This means that it is expensive to get the first item of an ordered collection; each item thereafter is not expensive. This makes sense: It would be impossible for that query operator to do otherwise.  \n  \n## Example  \n This example alters the previous example. The `AppendString` method calls <xref:System.Linq.Enumerable.ToList%2A> before iterating through the source. This causes materialization.  \n  \n```csharp  \npublic static class LocalExtensions  \n{  \n    public static IEnumerable<string>  \n      ConvertCollectionToUpperCase(this IEnumerable<string> source)  \n    {  \n        foreach (string str in source)  \n        {  \n            Console.WriteLine(\"ToUpper: source >{0}<\", str);  \n            yield return str.ToUpper();  \n        }  \n    }  \n  \n    public static IEnumerable<string>  \n      AppendString(this IEnumerable<string> source, string stringToAppend)  \n    {  \n        // the following statement materializes the source collection in a List<T>  \n        // before iterating through it  \n        foreach (string str in source.ToList())  \n        {  \n            Console.WriteLine(\"AppendString: source >{0}<\", str);  \n            yield return str + stringToAppend;  \n        }  \n    }  \n}  \n  \nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        string[] stringArray = { \"abc\", \"def\", \"ghi\" };  \n  \n        IEnumerable<string> q1 =  \n            from s in stringArray.ConvertCollectionToUpperCase()  \n            select s;  \n  \n        IEnumerable<string> q2 =  \n            from s in q1.AppendString(\"!!!\")  \n            select s;  \n  \n        foreach (string str in q2)  \n        {  \n            Console.WriteLine(\"Main: str >{0}<\", str);  \n            Console.WriteLine();  \n        }  \n    }  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nToUpper: source >abc<  \nToUpper: source >def<  \nToUpper: source >ghi<  \nAppendString: source >ABC<  \nMain: str >ABC!!!<  \n  \nAppendString: source >DEF<  \nMain: str >DEF!!!<  \n  \nAppendString: source >GHI<  \nMain: str >GHI!!!<  \n```  \n  \n In this example, you can see that the call to <xref:System.Linq.Enumerable.ToList%2A> causes `AppendString` to enumerate its entire source before yielding the first item. If the source were a large array, this would significantly alter the memory profile of the application.  \n  \n Standard query operators can also be chained together. The final topic in this tutorial illustrates this.  \n  \n-   [Chaining Standard Query Operators Together (C#)](../../../../csharp/programming-guide/concepts/linq/chaining-standard-query-operators-together.md)  \n  \n## See also\n\n- [Tutorial: Chaining Queries Together (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)\n","nodes":[{"pos":[4,115],"embed":true,"restype":"x-metadata","content":"title: \"Intermediate Materialization (C#)\"\nms.date: 07/20/2015\nms.assetid: 7922d38f-5044-41cf-8e17-7173d6553a5e","nodes":[{"content":"Intermediate Materialization (C#)","nodes":[{"pos":[0,33],"content":"Intermediate Materialization (C#)","nodes":[{"content":"Intermediate Materialization (C#)","pos":[0,33]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[122,155],"content":"Intermediate Materialization (C#)","linkify":"Intermediate Materialization (C#)","nodes":[{"content":"Intermediate Materialization (C#)","pos":[0,33]}]},{"content":"If you are not careful, in some situations you can drastically alter the memory and performance profile of your application by causing premature materialization of collections in your queries.","pos":[156,348]},{"content":"Some standard query operators cause materialization of their source collection before yielding a single element.","pos":[349,461]},{"content":"For example, <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.OrderBy%2A?displayProperty=nameWithType&gt;</ph> first iterates through its entire source collection, then sorts all items, and then finally yields the first item.","pos":[462,659],"source":" For example, <xref:System.Linq.Enumerable.OrderBy%2A?displayProperty=nameWithType> first iterates through its entire source collection, then sorts all items, and then finally yields the first item."},{"content":"This means that it is expensive to get the first item of an ordered collection; each item thereafter is not expensive.","pos":[660,778]},{"content":"This makes sense: It would be impossible for that query operator to do otherwise.","pos":[779,860]},{"pos":[869,876],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example alters the previous example.","pos":[880,921]},{"content":"The <ph id=\"ph1\">`AppendString`</ph> method calls <ph id=\"ph2\">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> before iterating through the source.","pos":[922,1030],"source":" The `AppendString` method calls <xref:System.Linq.Enumerable.ToList%2A> before iterating through the source."},{"content":"This causes materialization.","pos":[1031,1059]},{"content":"This example produces the following output:","pos":[2415,2458]},{"content":"In this example, you can see that the call to <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> causes <ph id=\"ph2\">`AppendString`</ph> to enumerate its entire source before yielding the first item.","pos":[2708,2878],"source":"In this example, you can see that the call to <xref:System.Linq.Enumerable.ToList%2A> causes `AppendString` to enumerate its entire source before yielding the first item."},{"content":"If the source were a large array, this would significantly alter the memory profile of the application.","pos":[2879,2982]},{"content":"Standard query operators can also be chained together.","pos":[2989,3043]},{"content":"The final topic in this tutorial illustrates this.","pos":[3044,3094]},{"pos":[3104,3251],"content":"<bpt id=\"p1\">[</bpt>Chaining Standard Query Operators Together (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/chaining-standard-query-operators-together.md)</ept>","source":"[Chaining Standard Query Operators Together (C#)](../../../../csharp/programming-guide/concepts/linq/chaining-standard-query-operators-together.md)"},{"pos":[3260,3268],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3272,3404],"content":"<bpt id=\"p1\">[</bpt>Tutorial: Chaining Queries Together (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)</ept>","source":"[Tutorial: Chaining Queries Together (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-chaining-queries-together.md)"}]}