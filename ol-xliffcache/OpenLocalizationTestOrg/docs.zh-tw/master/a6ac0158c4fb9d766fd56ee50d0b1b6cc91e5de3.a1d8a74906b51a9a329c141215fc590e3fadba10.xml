{"content":"---\ntitle: \"How to: Handle the ContextMenuOpening Event\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"ContextMenuOpening properties [WPF]\"\nms.assetid: 789652fb-1951-4217-934a-7843e355adf4\n---\n# How to: Handle the ContextMenuOpening Event\nThe <xref:System.Windows.FrameworkElement.ContextMenuOpening> event can be handled in an application to either adjust an existing context menu prior to display or to suppress the menu that would otherwise be displayed by setting the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data. The typical reason for setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` in the event data is to replace the menu entirely with a new <xref:System.Windows.Controls.ContextMenu> object, which sometimes requires canceling the operation and starting a new open. If you write handlers for the <xref:System.Windows.FrameworkElement.ContextMenuOpening> event, you should be aware of timing issues between a <xref:System.Windows.Controls.ContextMenu> control and the service that is responsible for opening and positioning context menus for controls in general. This topic illustrates some of the code techniques for various context menu opening scenarios and illustrates a case where the timing issue comes into play.  \n  \n There are several scenarios for handling the <xref:System.Windows.FrameworkElement.ContextMenuOpening> event:  \n  \n-   Adjusting the menu items before display.  \n  \n-   Replacing the entire menu before display.  \n  \n-   Completely suppressing any existing context menu and displaying no context menu.  \n  \n## Example  \n  \n## Adjusting the Menu Items Before Display  \n Adjusting the existing menu items is fairly simple and is probably the most common scenario. You might do this in order to add or subtract context menu options in response to current state information in your application or particular state information that is available as a property on the object where the context menu is requested.  \n  \n The general technique is to get the source of the event, which is the specific control that was right-clicked, and get the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property from it. You typically want to check the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection to see what context menu items already exist in the menu, and then add or remove appropriate new <xref:System.Windows.Controls.MenuItem> items to or from the collection.  \n  \n [!code-csharp[ContextMenuOpeningHandlers#AddItemNoHandle](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenuOpeningHandlers/CSharp/Pane1.xaml.cs#additemnohandle)]  \n  \n## Replacing the Entire Menu Before Display  \n An alternative scenario is if you want to replace the entire context menu. You could of course also use a variation of the preceding code, to remove every item of an existing context menu and add new ones starting with item zero. But the more intuitive approach for replacing all items in the context menu is to create a new <xref:System.Windows.Controls.ContextMenu>, populate it with items, and then set the <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> property of a control to be the new <xref:System.Windows.Controls.ContextMenu>.  \n  \n The following is the simple handler code for replacing a <xref:System.Windows.Controls.ContextMenu>. The code references a custom `BuildMenu` method, which is separated out because it is called by more than one of the example handlers.  \n  \n [!code-csharp[ContextMenuOpeningHandlers#ReplaceNoReopen](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenuOpeningHandlers/CSharp/Pane1.xaml.cs#replacenoreopen)]  \n  \n [!code-csharp[ContextMenuOpeningHandlers#BuildMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenuOpeningHandlers/CSharp/Pane1.xaml.cs#buildmenu)]  \n  \n However, if you use this style of handler for <xref:System.Windows.FrameworkElement.ContextMenuOpening>, you can potentially expose a timing issue if the object where you are setting the <xref:System.Windows.Controls.ContextMenu> does not have a preexisting context menu. When a user right-clicks a control, <xref:System.Windows.FrameworkElement.ContextMenuOpening> is raised even if the existing <xref:System.Windows.Controls.ContextMenu> is empty or null. But in this case, whatever new <xref:System.Windows.Controls.ContextMenu> you set on the source element arrives too late to be displayed. Also, if the user happens to right-click a second time, this time your new <xref:System.Windows.Controls.ContextMenu> appears, the value is non null, and your handler will properly replace and display the menu when the handler runs a second time. This suggests two possible workarounds:  \n  \n1.  Insure that <xref:System.Windows.FrameworkElement.ContextMenuOpening> handlers always run against controls that have at least a placeholder <xref:System.Windows.Controls.ContextMenu> available, which you intend to be replaced by the handler code. In this case, you can still use the handler shown in the previous example, but you typically want to assign a placeholder <xref:System.Windows.Controls.ContextMenu> in the initial markup:  \n  \n     [!code-xaml[ContextMenuOpeningHandlers#XAMLWithInitCM](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenuOpeningHandlers/CSharp/Pane1.xaml#xamlwithinitcm)]  \n  \n2.  Assume that the initial <xref:System.Windows.Controls.ContextMenu> value might be null, based on some preliminary logic. You could either check <xref:System.Windows.Controls.ContextMenu> for null, or use a flag in your code to check whether your handler has been run at least once. Because you assume that the <xref:System.Windows.Controls.ContextMenu> is about to be displayed, your handler then sets <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` in the event data. To the <xref:System.Windows.Controls.ContextMenuService> that is responsible for context menu display, a `true` value for <xref:System.Windows.RoutedEventArgs.Handled%2A> in the event data represents a request to cancel the display for the context menu / control combination that raised the event.  \n  \n Now that you have suppressed the potentially suspect context menu, the next step is to supply a new one, then display it. Setting the new one is basically the same as the previous handler: you build a new <xref:System.Windows.Controls.ContextMenu> and set the control source's <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> property with it. The additional step is that you must now force the display of the context menu, because you suppressed the first attempt. To force the display, you set the <xref:System.Windows.Controls.Primitives.Popup.IsOpen%2A?displayProperty=nameWithType> property to `true` within the handler. Be careful when you do this, because opening the context menu in the handler raises the <xref:System.Windows.FrameworkElement.ContextMenuOpening> event again. If you reenter your handler, it becomes infinitely recursive. This is why you always need to check for `null` or use a flag if you open a context menu from within a <xref:System.Windows.FrameworkElement.ContextMenuOpening> event handler.  \n  \n## Suppressing Any Existing Context Menu and Displaying No Context Menu  \n The final scenario, writing a handler that suppresses a menu totally, is uncommon. If a given control is not supposed to display a context menu, there are probably more appropriate ways to assure this than by suppressing the menu just when a user requests it. But if you want to use the handler to suppress a context menu and show nothing, then your handler should simply set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` in the event data. The <xref:System.Windows.Controls.ContextMenuService> that is responsible for displaying a context menu will check the event data of the event it raised on the control. If the event was marked <xref:System.Windows.RoutedEventArgs.Handled%2A> anywhere along the route, then the context menu open action that initiated the event is suppressed.  \n  \n [!code-csharp[ContextMenuOpeningHandlers#ReplaceReopen](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenuOpeningHandlers/CSharp/Pane1.xaml.cs#replacereopen)]  \n  \n## See also\n\n- <xref:System.Windows.Controls.ContextMenu>\n- <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>\n- [Base Elements Overview](base-elements-overview.md)\n- [ContextMenu Overview](../controls/contextmenu-overview.md)\n","nodes":[{"pos":[4,191],"embed":true,"restype":"x-metadata","content":"title: \"How to: Handle the ContextMenuOpening Event\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"ContextMenuOpening properties [WPF]\"\nms.assetid: 789652fb-1951-4217-934a-7843e355adf4","nodes":[{"content":"How to: Handle the ContextMenuOpening Event","nodes":[{"pos":[0,43],"content":"How to: Handle the ContextMenuOpening Event","nodes":[{"content":"How to: Handle the ContextMenuOpening Event","pos":[0,43]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[198,241],"content":"How to: Handle the ContextMenuOpening Event","linkify":"How to: Handle the ContextMenuOpening Event","nodes":[{"content":"How to: Handle the ContextMenuOpening Event","pos":[0,43]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> event can be handled in an application to either adjust an existing context menu prior to display or to suppress the menu that would otherwise be displayed by setting the <ph id=\"ph2\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> property to <ph id=\"ph3\">`true`</ph> in the event data.","pos":[242,561],"source":"The <xref:System.Windows.FrameworkElement.ContextMenuOpening> event can be handled in an application to either adjust an existing context menu prior to display or to suppress the menu that would otherwise be displayed by setting the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data."},{"content":"The typical reason for setting <ph id=\"ph1\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id=\"ph2\">`true`</ph> in the event data is to replace the menu entirely with a new <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> object, which sometimes requires canceling the operation and starting a new open.","pos":[562,837],"source":" The typical reason for setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` in the event data is to replace the menu entirely with a new <xref:System.Windows.Controls.ContextMenu> object, which sometimes requires canceling the operation and starting a new open."},{"content":"If you write handlers for the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> event, you should be aware of timing issues between a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> control and the service that is responsible for opening and positioning context menus for controls in general.","pos":[838,1133],"source":" If you write handlers for the <xref:System.Windows.FrameworkElement.ContextMenuOpening> event, you should be aware of timing issues between a <xref:System.Windows.Controls.ContextMenu> control and the service that is responsible for opening and positioning context menus for controls in general."},{"content":"This topic illustrates some of the code techniques for various context menu opening scenarios and illustrates a case where the timing issue comes into play.","pos":[1134,1290]},{"pos":[1297,1406],"content":"There are several scenarios for handling the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> event:","source":"There are several scenarios for handling the <xref:System.Windows.FrameworkElement.ContextMenuOpening> event:"},{"content":"Adjusting the menu items before display.","pos":[1416,1456]},{"content":"Replacing the entire menu before display.","pos":[1466,1507]},{"content":"Completely suppressing any existing context menu and displaying no context menu.","pos":[1517,1597]},{"pos":[1606,1613],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[1622,1661],"content":"Adjusting the Menu Items Before Display","linkify":"Adjusting the Menu Items Before Display","nodes":[{"content":"Adjusting the Menu Items Before Display","pos":[0,39]}]},{"content":"Adjusting the existing menu items is fairly simple and is probably the most common scenario.","pos":[1665,1757]},{"content":"You might do this in order to add or subtract context menu options in response to current state information in your application or particular state information that is available as a property on the object where the context menu is requested.","pos":[1758,2000]},{"content":"The general technique is to get the source of the event, which is the specific control that was right-clicked, and get the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property from it.","pos":[2007,2201],"source":"The general technique is to get the source of the event, which is the specific control that was right-clicked, and get the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property from it."},{"content":"You typically want to check the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> collection to see what context menu items already exist in the menu, and then add or remove appropriate new <ph id=\"ph2\">&lt;xref:System.Windows.Controls.MenuItem&gt;</ph> items to or from the collection.","pos":[2202,2467],"source":" You typically want to check the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection to see what context menu items already exist in the menu, and then add or remove appropriate new <xref:System.Windows.Controls.MenuItem> items to or from the collection."},{"pos":[2648,2688],"content":"Replacing the Entire Menu Before Display","linkify":"Replacing the Entire Menu Before Display","nodes":[{"content":"Replacing the Entire Menu Before Display","pos":[0,40]}]},{"content":"An alternative scenario is if you want to replace the entire context menu.","pos":[2692,2766]},{"content":"You could of course also use a variation of the preceding code, to remove every item of an existing context menu and add new ones starting with item zero.","pos":[2767,2921]},{"content":"But the more intuitive approach for replacing all items in the context menu is to create a new <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>, populate it with items, and then set the <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType&gt;</ph> property of a control to be the new <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.","pos":[2922,3264],"source":" But the more intuitive approach for replacing all items in the context menu is to create a new <xref:System.Windows.Controls.ContextMenu>, populate it with items, and then set the <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> property of a control to be the new <xref:System.Windows.Controls.ContextMenu>."},{"content":"The following is the simple handler code for replacing a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.","pos":[3271,3371],"source":"The following is the simple handler code for replacing a <xref:System.Windows.Controls.ContextMenu>."},{"content":"The code references a custom <ph id=\"ph1\">`BuildMenu`</ph> method, which is separated out because it is called by more than one of the example handlers.","pos":[3372,3506],"source":" The code references a custom `BuildMenu` method, which is separated out because it is called by more than one of the example handlers."},{"content":"However, if you use this style of handler for <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph>, you can potentially expose a timing issue if the object where you are setting the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> does not have a preexisting context menu.","pos":[3845,4116],"source":"However, if you use this style of handler for <xref:System.Windows.FrameworkElement.ContextMenuOpening>, you can potentially expose a timing issue if the object where you are setting the <xref:System.Windows.Controls.ContextMenu> does not have a preexisting context menu."},{"content":"When a user right-clicks a control, <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> is raised even if the existing <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> is empty or null.","pos":[4117,4302],"source":" When a user right-clicks a control, <xref:System.Windows.FrameworkElement.ContextMenuOpening> is raised even if the existing <xref:System.Windows.Controls.ContextMenu> is empty or null."},{"content":"But in this case, whatever new <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> you set on the source element arrives too late to be displayed.","pos":[4303,4440],"source":" But in this case, whatever new <xref:System.Windows.Controls.ContextMenu> you set on the source element arrives too late to be displayed."},{"content":"Also, if the user happens to right-click a second time, this time your new <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> appears, the value is non null, and your handler will properly replace and display the menu when the handler runs a second time.","pos":[4441,4687],"source":" Also, if the user happens to right-click a second time, this time your new <xref:System.Windows.Controls.ContextMenu> appears, the value is non null, and your handler will properly replace and display the menu when the handler runs a second time."},{"content":"This suggests two possible workarounds:","pos":[4688,4727]},{"content":"Insure that <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> handlers always run against controls that have at least a placeholder <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> available, which you intend to be replaced by the handler code.","pos":[4737,4983],"source":"Insure that <xref:System.Windows.FrameworkElement.ContextMenuOpening> handlers always run against controls that have at least a placeholder <xref:System.Windows.Controls.ContextMenu> available, which you intend to be replaced by the handler code."},{"content":"In this case, you can still use the handler shown in the previous example, but you typically want to assign a placeholder <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> in the initial markup:","pos":[4984,5171],"source":" In this case, you can still use the handler shown in the previous example, but you typically want to assign a placeholder <xref:System.Windows.Controls.ContextMenu> in the initial markup:"},{"content":"Assume that the initial <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> value might be null, based on some preliminary logic.","pos":[5350,5470],"source":"Assume that the initial <xref:System.Windows.Controls.ContextMenu> value might be null, based on some preliminary logic."},{"content":"You could either check <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> for null, or use a flag in your code to check whether your handler has been run at least once.","pos":[5471,5631],"source":" You could either check <xref:System.Windows.Controls.ContextMenu> for null, or use a flag in your code to check whether your handler has been run at least once."},{"content":"Because you assume that the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> is about to be displayed, your handler then sets <ph id=\"ph2\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id=\"ph3\">`true`</ph> in the event data.","pos":[5632,5829],"source":" Because you assume that the <xref:System.Windows.Controls.ContextMenu> is about to be displayed, your handler then sets <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` in the event data."},{"content":"To the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenuService&gt;</ph> that is responsible for context menu display, a <ph id=\"ph2\">`true`</ph> value for <ph id=\"ph3\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> in the event data represents a request to cancel the display for the context menu / control combination that raised the event.","pos":[5830,6127],"source":" To the <xref:System.Windows.Controls.ContextMenuService> that is responsible for context menu display, a `true` value for <xref:System.Windows.RoutedEventArgs.Handled%2A> in the event data represents a request to cancel the display for the context menu / control combination that raised the event."},{"content":"Now that you have suppressed the potentially suspect context menu, the next step is to supply a new one, then display it.","pos":[6134,6255]},{"content":"Setting the new one is basically the same as the previous handler: you build a new <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> and set the control source's <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType&gt;</ph> property with it.","pos":[6256,6511],"source":" Setting the new one is basically the same as the previous handler: you build a new <xref:System.Windows.Controls.ContextMenu> and set the control source's <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> property with it."},{"content":"The additional step is that you must now force the display of the context menu, because you suppressed the first attempt.","pos":[6512,6633]},{"content":"To force the display, you set the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Popup.IsOpen%2A?displayProperty=nameWithType&gt;</ph> property to <ph id=\"ph2\">`true`</ph> within the handler.","pos":[6634,6793],"source":" To force the display, you set the <xref:System.Windows.Controls.Primitives.Popup.IsOpen%2A?displayProperty=nameWithType> property to `true` within the handler."},{"content":"Be careful when you do this, because opening the context menu in the handler raises the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> event again.","pos":[6794,6952],"source":" Be careful when you do this, because opening the context menu in the handler raises the <xref:System.Windows.FrameworkElement.ContextMenuOpening> event again."},{"content":"If you reenter your handler, it becomes infinitely recursive.","pos":[6953,7014]},{"content":"This is why you always need to check for <ph id=\"ph1\">`null`</ph> or use a flag if you open a context menu from within a <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> event handler.","pos":[7015,7190],"source":" This is why you always need to check for `null` or use a flag if you open a context menu from within a <xref:System.Windows.FrameworkElement.ContextMenuOpening> event handler."},{"pos":[7199,7267],"content":"Suppressing Any Existing Context Menu and Displaying No Context Menu","linkify":"Suppressing Any Existing Context Menu and Displaying No Context Menu","nodes":[{"content":"Suppressing Any Existing Context Menu and Displaying No Context Menu","pos":[0,68]}]},{"content":"The final scenario, writing a handler that suppresses a menu totally, is uncommon.","pos":[7271,7353]},{"content":"If a given control is not supposed to display a context menu, there are probably more appropriate ways to assure this than by suppressing the menu just when a user requests it.","pos":[7354,7530]},{"content":"But if you want to use the handler to suppress a context menu and show nothing, then your handler should simply set <ph id=\"ph1\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> to <ph id=\"ph2\">`true`</ph> in the event data.","pos":[7531,7724],"source":" But if you want to use the handler to suppress a context menu and show nothing, then your handler should simply set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` in the event data."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContextMenuService&gt;</ph> that is responsible for displaying a context menu will check the event data of the event it raised on the control.","pos":[7725,7893],"source":" The <xref:System.Windows.Controls.ContextMenuService> that is responsible for displaying a context menu will check the event data of the event it raised on the control."},{"content":"If the event was marked <ph id=\"ph1\">&lt;xref:System.Windows.RoutedEventArgs.Handled%2A&gt;</ph> anywhere along the route, then the context menu open action that initiated the event is suppressed.","pos":[7894,8066],"source":" If the event was marked <xref:System.Windows.RoutedEventArgs.Handled%2A> anywhere along the route, then the context menu open action that initiated the event is suppressed."},{"pos":[8243,8251],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8385,8436],"content":"<bpt id=\"p1\">[</bpt>Base Elements Overview<ept id=\"p1\">](base-elements-overview.md)</ept>","source":"[Base Elements Overview](base-elements-overview.md)"},{"pos":[8439,8498],"content":"<bpt id=\"p1\">[</bpt>ContextMenu Overview<ept id=\"p1\">](../controls/contextmenu-overview.md)</ept>","source":"[ContextMenu Overview](../controls/contextmenu-overview.md)"}]}