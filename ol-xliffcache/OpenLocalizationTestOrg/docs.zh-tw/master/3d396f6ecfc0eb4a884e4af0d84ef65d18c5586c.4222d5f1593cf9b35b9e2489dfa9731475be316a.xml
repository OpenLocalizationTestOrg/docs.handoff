{"content":"---\ntitle: \"Provider Manifest Specification\"\nms.date: \"03/30/2017\"\nms.assetid: bb450b47-8951-4f99-9350-26f05a4d4e46\n---\n# Provider Manifest Specification\nThis section discusses how a data store provider can support the types and functions in the data store.  \n  \n Entity Services operates independently of a specific data store provider yet still allows a data provider to explicitly define how models, mappings, and queries interact with an underlying data store. Without a layer of abstraction, Entity Services could only be targeted at a specific data store or data provider.  \n  \n Types that the provider supports are directly or indirectly supported by the underlying database. These types are not necessarily the exact store types, but the types the provider uses to support the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]. Provider/store types are described in the Entity Data Model (EDM) terms.  \n  \n Parameter and return types for the functions supported by the data store are specified in EDM terms.  \n  \n## Requirements  \n The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] and the data store need to be able to pass data back and forth in known types without any data loss or truncation.  \n  \n The provider manifest must be loadable by tools at design time without having to open a connection to the data store.  \n  \n The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] is case sensitive, but the underlying data store may not be. When EDM artifacts (identifiers and type names, for example) are defined and used in the manifest, they must use the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] case sensitivity. If data store elements that may be case sensitive appear in the provider manifest, that casing needs to be maintained in the provider manifest.  \n  \n The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] requires a provider manifest for all data providers. If you try to use a provider that does not have a provider manifest with the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], you will get an error.  \n  \n The following table describes the kinds of exceptions the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] would throw when exceptions arise through provider interaction:  \n  \n|Issue|Exception|  \n|-----------|---------------|  \n|The Provider does not support GetProviderManifest in DbProviderServices.|ProviderIncompatibleException|  \n|Missing provider manifest: the provider returns `null` when attempting to retrieve the provider manifest.|ProviderIncompatibleException|  \n|Invalid provider manifest: the provider returns invalid XML when attempting to retrieve the provider manifest.|ProviderIncompatibleException|  \n  \n## Scenarios  \n A provider should support the following scenarios:  \n  \n### Writing a Provider with Symmetric Type Mapping  \n You can write a provider for the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] where each store type maps to a single EDM type, regardless of the mapping direction. For a provider type that has very simple mapping that corresponds with an EDM type, you can use a symmetric solution because the type system is simple or matches EDM types.  \n  \n You can use the simplicity of their domain and produce a static declarative provider manifest.  \n  \n You write an XML file that has two sections:  \n  \n-   A list of provider types expressed in terms of the \"EDM counterpart\" of a store type or function. Store types have counterpart EDM types. Store functions have corresponding EDM functions. For example, varchar is a SQL Server type but the corresponding EDM type is string.  \n  \n-   A list of functions supported by the provider where parameter and return types are expressed in EDM terms.  \n  \n### Writing a Provider with Asymmetric Type Mapping  \n When writing a data store provider for the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], the EDM-to-provider type mapping for some types may be different from provider-to-EDM type mapping. For instance, unbounded EDM PrimitiveTypeKind.String may map to nvarchar(4000) on the provider, while nvarchar(4000) maps to the EDM PrimitiveTypeKind.String(MaxLength=4000).  \n  \n You write an XML file that has two sections:  \n  \n-   A list of provider types expressed in EDM terms and define mapping for both direction: EDM-to-provider and provider-to-EDM.  \n  \n-   A list of functions supported by the provider where parameter and return types are expressed in EDM terms.  \n  \n## Provider Manifest Discoverability  \n The manifest is used indirectly by several component types in Entity Services (for example Tools or Query) but more directly leveraged by metadata through the use of the data store metadata loader.  \n  \n ![dfb3d02b&#45;7a8c&#45;4d51&#45;ac5a&#45;a73d8aa145e6](../../../../../docs/framework/data/adonet/ef/media/dfb3d02b-7a8c-4d51-ac5a-a73d8aa145e6.gif \"dfb3d02b-7a8c-4d51-ac5a-a73d8aa145e6\")  \n  \n However, a given provider may support different stores or different versions of the same store. Therefore, a provider must report a different manifest for each supported data store.  \n  \n### Provider Manifest Token  \n When a data store connection is opened, the provider can query for information to return the right manifest. This may not be possible in offline scenarios where connection information is not available or when it is not possible to connect to the store. Identify the manifest by using the `ProviderManifestToken` attribute of the `Schema` element in the .ssdl file. There is no required format for this attribute; the provider chooses the minimum information needed to identify a manifest without opening a connection to the store.  \n  \n For example:  \n  \n```xml  \n<Schema Namespace=\"Northwind\" Provider=\"System.Data.SqlClient\" ProviderManifestToken=\"2005\" xmlns:edm=\"http://schemas.microsoft.com/ado/2006/04/edm/ssdl\" xmlns=\"http://schemas.microsoft.com/ado/2006/04/edm/ssdl\">  \n```  \n  \n## Provider Manifest Programming Model  \n Providers derive from <xref:System.Data.Common.DbXmlEnabledProviderManifest>, which allows them to specify their manifests declaratively. The following illustration shows the class hierarchy of a provider:  \n  \n ![None](../../../../../docs/framework/data/adonet/ef/media/d541eba3-2ee6-4cd1-88f5-89d0b2582a6c.gif \"d541eba3-2ee6-4cd1-88f5-89d0b2582a6c\")  \n  \n### Discoverability API  \n The provider manifest is loaded by the Store Metadata loader (StoreItemCollection), either by using a data store connection or a provider manifest token.  \n  \n#### Using a Data Store Connection  \n When the data store connection is available, call DbProvderServices.GetProviderManifestToken to return the token that is passed to the GetProviderManifest method, which returns DbProviderManifest. This method delegates to the provider's implementation of GetDbProviderManifestToken.  \n  \n```  \npublic string GetProviderManifestToken(DbConnection connection);  \npublic DbProviderManifest GetProviderManifest(string manifestToken);  \n```  \n  \n#### Using a Provider Manifest Token  \n For the offline scenario, the token is picked from SSDL representation. The SSDL allows you to specify a ProviderManifestToken (see [Schema Element (SSDL)](/ef/ef6/modeling/designer/advanced/edmx/ssdl-spec#schema-element-ssdl) for more information). For example, if a connection cannot be opened, the SSDL has a provider manifest token that specifies information about the manifest.  \n  \n```  \npublic DbProviderManifest GetProviderManifest(string manifestToken);  \n```  \n  \n### Provider Manifest Schema  \n The schema of information defined for each provider contains the static information to be consumed by metadata:  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n<xs:schema elementFormDefault=\"qualified\"  \n   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  \n   targetNamespace=\"http://schemas.microsoft.com/ado/2006/04/edm/providermanifest\"  \n   xmlns:pm=\"http://schemas.microsoft.com/ado/2006/04/edm/providermanifest\">  \n  \n  <xs:element name=\"ProviderManifest\">  \n    <xs:complexType>  \n      <xs:sequence>  \n        <xs:element name=\"Types\" type=\"pm:TTypes\" minOccurs=\"1\" maxOccurs=\"1\" />  \n        <xs:element name=\"Functions\" type=\"pm:TFunctions\" minOccurs=\"0\" maxOccurs=\"1\"/>  \n      </xs:sequence>  \n      <xs:attribute name=\"Namespace\" type=\"xs:string\" use=\"required\"/>  \n    </xs:complexType>  \n  </xs:element>  \n  <xs:complexType name=\"TVersion\">  \n    <xs:attribute name=\"Major\" type=\"xs:int\" use=\"required\" />  \n    <xs:attribute name=\"Minor\" type=\"xs:int\" use=\"required\" />  \n    <xs:attribute name=\"Build\" type=\"xs:int\" use=\"required\" />  \n    <xs:attribute name=\"Revision\" type=\"xs:int\" use=\"required\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TIntegerFacetDescription\">  \n    <xs:attribute name=\"Minimum\" type=\"xs:int\" use=\"optional\" />  \n    <xs:attribute name=\"Maximum\" type=\"xs:int\" use=\"optional\" />  \n    <xs:attribute name=\"DefaultValue\" type=\"xs:int\" use=\"optional\" />  \n    <xs:attribute name=\"Constant\" type=\"xs:boolean\" default=\"false\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TBooleanFacetDescription\">  \n    <xs:attribute name=\"DefaultValue\" type=\"xs:boolean\" use=\"optional\" />  \n    <xs:attribute name=\"Constant\" type=\"xs:boolean\" default=\"true\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TDateTimeFacetDescription\">  \n    <xs:attribute name=\"Constant\" type=\"xs:boolean\" default=\"false\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TFacetDescriptions\">  \n    <xs:choice maxOccurs=\"unbounded\">  \n      <xs:element name=\"Precision\" minOccurs=\"0\" maxOccurs=\"1\" type=\"pm:TIntegerFacetDescription\"/>  \n      <xs:element name=\"Scale\" minOccurs=\"0\" maxOccurs=\"1\" type=\"pm:TIntegerFacetDescription\"/>  \n      <xs:element name=\"MaxLength\" minOccurs=\"0\" maxOccurs=\"1\" type=\"pm:TIntegerFacetDescription\"/>  \n      <xs:element name=\"Unicode\" minOccurs=\"0\" maxOccurs=\"1\" type=\"pm:TBooleanFacetDescription\"/>  \n      <xs:element name=\"FixedLength\" minOccurs=\"0\" maxOccurs=\"1\" type=\"pm:TBooleanFacetDescription\"/>  \n    </xs:choice>  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TType\">  \n    <xs:sequence>  \n      <xs:element name=\"FacetDescriptions\" type=\"pm:TFacetDescriptions\" minOccurs=\"0\" maxOccurs=\"1\"/>  \n    </xs:sequence>  \n    <xs:attribute name=\"Name\" type=\"xs:string\" use=\"required\"/>  \n    <xs:attribute name=\"PrimitiveTypeKind\" type=\"pm:TPrimitiveTypeKind\" use=\"required\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TTypes\">  \n    <xs:sequence>  \n      <xs:element name=\"Type\" type=\"pm:TType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>  \n    </xs:sequence>  \n  </xs:complexType>  \n  \n  <xs:attributeGroup name=\"TFacetAttribute\">  \n    <xs:attribute name=\"Precision\" type=\"xs:int\" use=\"optional\"/>  \n    <xs:attribute name=\"Scale\" type=\"xs:int\" use=\"optional\"/>  \n    <xs:attribute name=\"MaxLength\" type=\"xs:int\" use=\"optional\"/>  \n    <xs:attribute name=\"Unicode\" type=\"xs:boolean\" use=\"optional\"/>  \n    <xs:attribute name=\"FixedLength\" type=\"xs:boolean\" use=\"optional\"/>  \n  </xs:attributeGroup>  \n  \n  <xs:complexType name=\"TFunctionParameter\">  \n    <xs:attribute name=\"Name\" type=\"xs:string\" use=\"required\" />  \n    <xs:attribute name=\"Type\" type=\"xs:string\" use=\"required\" />  \n    <xs:attributeGroup ref=\"pm:TFacetAttribute\" />  \n    <xs:attribute name=\"Mode\" type=\"pm:TParameterDirection\" use=\"required\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TReturnType\">  \n    <xs:attribute name=\"Type\" type=\"xs:string\" use=\"required\" />  \n    <xs:attributeGroup ref=\"pm:TFacetAttribute\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TFunction\">  \n    <xs:choice minOccurs=\"0\" maxOccurs =\"unbounded\">  \n      <xs:element name =\"ReturnType\" type=\"pm:TReturnType\" minOccurs=\"0\" maxOccurs=\"1\" />  \n      <xs:element name=\"Parameter\" type=\"pm:TFunctionParameter\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>  \n    </xs:choice>  \n    <xs:attribute name=\"Name\" type=\"xs:string\" use=\"required\" />  \n    <xs:attribute name=\"Aggregate\" type=\"xs:boolean\" use=\"optional\" />  \n    <xs:attribute name=\"BuiltIn\" type=\"xs:boolean\" use=\"optional\" />  \n    <xs:attribute name=\"StoreFunctionName\" type=\"xs:string\" use=\"optional\" />  \n    <xs:attribute name=\"NiladicFunction\" type=\"xs:boolean\" use=\"optional\" />  \n    <xs:attribute name=\"ParameterTypeSemantics\" type=\"pm:TParameterTypeSemantics\" use=\"optional\" default=\"AllowImplicitConversion\" />  \n  </xs:complexType>  \n  \n  <xs:complexType name=\"TFunctions\">  \n    <xs:sequence>  \n      <xs:element name=\"Function\" type=\"pm:TFunction\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>  \n    </xs:sequence>  \n  </xs:complexType>  \n  \n  <xs:simpleType name=\"TPrimitiveTypeKind\">  \n    <xs:restriction base=\"xs:string\">  \n      <xs:enumeration value=\"Binary\"/>  \n      <xs:enumeration value=\"Boolean\"/>  \n      <xs:enumeration value=\"Byte\"/>  \n      <xs:enumeration value=\"Decimal\"/>  \n      <xs:enumeration value=\"DateTime\"/>  \n      <xs:enumeration value=\"Time\"/>  \n      <xs:enumeration value=\"DateTimeOffset\"/>          \n      <xs:enumeration value=\"Double\"/>  \n      <xs:enumeration value=\"Guid\"/>  \n      <xs:enumeration value=\"Single\"/>  \n      <xs:enumeration value=\"SByte\"/>  \n      <xs:enumeration value=\"Int16\"/>  \n      <xs:enumeration value=\"Int32\"/>  \n      <xs:enumeration value=\"Int64\"/>  \n      <xs:enumeration value=\"String\"/>  \n    </xs:restriction>  \n  </xs:simpleType>  \n  \n  <xs:simpleType name=\"TParameterDirection\">  \n    <xs:restriction base=\"xs:string\">  \n      <xs:enumeration value=\"In\"/>  \n      <xs:enumeration value=\"Out\"/>  \n      <xs:enumeration value=\"InOut\"/>  \n    </xs:restriction>  \n  </xs:simpleType>  \n  \n  <xs:simpleType name=\"TParameterTypeSemantics\">  \n    <xs:restriction base=\"xs:string\">  \n      <xs:enumeration value=\"ExactMatchOnly\" />  \n      <xs:enumeration value=\"AllowImplicitPromotion\" />  \n      <xs:enumeration value=\"AllowImplicitConversion\" />  \n    </xs:restriction>  \n  </xs:simpleType>  \n</xs:schema>  \n```  \n  \n#### Types Node  \n The Types node in the provider manifest contains information about the Types that are supported natively by the data store or through the provider.  \n  \n##### Type Node  \n Each Type node defines a provider type in terms of EDM. The Type node describes the name of the provider type, and information related to the model type it maps to and facets to describe that type mapping.  \n  \n In order to express this type information in the provider manifest, each TypeInformation declaration must define several facet descriptions for each Type:  \n  \n|Attribute Name|Data Type|Required|Default Value|Description|  \n|--------------------|---------------|--------------|-------------------|-----------------|  \n|Name|String|Yes|n/a|Provider-specific data type name|  \n|PrimitiveTypeKind|PrimitiveTypeKind|Yes|n/a|EDM type name|  \n  \n###### Function Node  \n Each Function defines a single function available through the provider.  \n  \n|Attribute Name|Data Type|Required|Default Value|Description|  \n|--------------------|---------------|--------------|-------------------|-----------------|  \n|Name|String|Yes|n/a|Identifier/name of the function|  \n|ReturnType|String|No|Void|The EDM return type of the function|  \n|Aggregate|Boolean|No|False|True if the function is an aggregate function|  \n|BuiltIn|Boolean|No|True|True if the function is built into the data store|  \n|StoreFunctionName|String|No|\\<Name>|Function Name in the data store.  Allows for a level of redirection of function names.|  \n|NiladicFunction|Boolean|No|False|True if the function does not require parameters and is called without any parameters|  \n|ParameterType<br /><br /> Semantics|ParameterSemantics|No|AllowImplicit<br /><br /> Conversion|Choice of how the query pipeline should deal with parameter type substitution:<br /><br /> -   ExactMatchOnly<br />-   AllowImplicitPromotion<br />-   AllowImplicitConversion|  \n  \n **Parameters Node**  \n  \n Each function has a collection of one or more Parameter nodes.  \n  \n|Attribute Name|Data Type|Required|Default Value|Description|  \n|--------------------|---------------|--------------|-------------------|-----------------|  \n|Name|String|Yes|n/a|Identifier/name of the parameter.|  \n|Type|String|Yes|n/a|The EDM type of the parameter.|  \n|Mode|Parameter<br /><br /> Direction|Yes|n/a|Direction of parameter:<br /><br /> -   in<br />-   out<br />-   inout|  \n  \n##### Namespace Attribute  \n Each data store provider must define a namespace or group of namespaces for information defined in the manifest. This namespace can be used in Entity SQL queries to resolve names of functions and types. For instance: SqlServer. That namespace must be different from the canonical namespace, EDM, defined by Entity Services for standard functions to be supported by Entity SQL queries.  \n  \n## See also\n\n- [Writing an Entity Framework Data Provider](../../../../../docs/framework/data/adonet/ef/writing-an-ef-data-provider.md)\n","nodes":[{"pos":[4,115],"embed":true,"restype":"x-metadata","content":"title: \"Provider Manifest Specification\"\nms.date: \"03/30/2017\"\nms.assetid: bb450b47-8951-4f99-9350-26f05a4d4e46","nodes":[{"content":"Provider Manifest Specification","nodes":[{"pos":[0,31],"content":"Provider Manifest Specification","nodes":[{"content":"Provider Manifest Specification","pos":[0,31]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[122,153],"content":"Provider Manifest Specification","linkify":"Provider Manifest Specification","nodes":[{"content":"Provider Manifest Specification","pos":[0,31]}]},{"content":"This section discusses how a data store provider can support the types and functions in the data store.","pos":[154,257]},{"content":"Entity Services operates independently of a specific data store provider yet still allows a data provider to explicitly define how models, mappings, and queries interact with an underlying data store.","pos":[264,464]},{"content":"Without a layer of abstraction, Entity Services could only be targeted at a specific data store or data provider.","pos":[465,578]},{"content":"Types that the provider supports are directly or indirectly supported by the underlying database.","pos":[585,682]},{"content":"These types are not necessarily the exact store types, but the types the provider uses to support the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph>.","pos":[683,848],"source":" These types are not necessarily the exact store types, but the types the provider uses to support the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]."},{"content":"Provider/store types are described in the Entity Data Model (EDM) terms.","pos":[849,921]},{"content":"Parameter and return types for the functions supported by the data store are specified in EDM terms.","pos":[928,1028]},{"pos":[1037,1049],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[1053,1234],"content":"The <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> and the data store need to be able to pass data back and forth in known types without any data loss or truncation.","source":"The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] and the data store need to be able to pass data back and forth in known types without any data loss or truncation."},{"content":"The provider manifest must be loadable by tools at design time without having to open a connection to the data store.","pos":[1241,1358]},{"content":"The <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> is case sensitive, but the underlying data store may not be.","pos":[1365,1492],"source":"The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] is case sensitive, but the underlying data store may not be."},{"content":"When EDM artifacts (identifiers and type names, for example) are defined and used in the manifest, they must use the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> case sensitivity.","pos":[1493,1690],"source":" When EDM artifacts (identifiers and type names, for example) are defined and used in the manifest, they must use the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] case sensitivity."},{"content":"If data store elements that may be case sensitive appear in the provider manifest, that casing needs to be maintained in the provider manifest.","pos":[1691,1834]},{"content":"The <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> requires a provider manifest for all data providers.","pos":[1841,1960],"source":"The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] requires a provider manifest for all data providers."},{"content":"If you try to use a provider that does not have a provider manifest with the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph>, you will get an error.","pos":[1961,2124],"source":" If you try to use a provider that does not have a provider manifest with the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], you will get an error."},{"pos":[2131,2315],"content":"The following table describes the kinds of exceptions the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> would throw when exceptions arise through provider interaction:","source":"The following table describes the kinds of exceptions the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] would throw when exceptions arise through provider interaction:"},{"content":"Issue","pos":[2322,2327]},{"content":"Exception","pos":[2328,2337]},{"content":"The Provider does not support GetProviderManifest in DbProviderServices.","pos":[2374,2446]},{"content":"ProviderIncompatibleException","pos":[2447,2476]},{"pos":[2481,2586],"content":"Missing provider manifest: the provider returns <ph id=\"ph1\">`null`</ph> when attempting to retrieve the provider manifest.","source":"Missing provider manifest: the provider returns `null` when attempting to retrieve the provider manifest."},{"content":"ProviderIncompatibleException","pos":[2587,2616]},{"content":"Invalid provider manifest: the provider returns invalid XML when attempting to retrieve the provider manifest.","pos":[2621,2731]},{"content":"ProviderIncompatibleException","pos":[2732,2761]},{"pos":[2771,2780],"content":"Scenarios","linkify":"Scenarios","nodes":[{"content":"Scenarios","pos":[0,9]}]},{"content":"A provider should support the following scenarios:","pos":[2784,2834]},{"pos":[2844,2890],"content":"Writing a Provider with Symmetric Type Mapping","linkify":"Writing a Provider with Symmetric Type Mapping","nodes":[{"content":"Writing a Provider with Symmetric Type Mapping","pos":[0,46]}]},{"content":"You can write a provider for the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> where each store type maps to a single EDM type, regardless of the mapping direction.","pos":[2894,3075],"source":"You can write a provider for the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] where each store type maps to a single EDM type, regardless of the mapping direction."},{"content":"For a provider type that has very simple mapping that corresponds with an EDM type, you can use a symmetric solution because the type system is simple or matches EDM types.","pos":[3076,3248]},{"content":"You can use the simplicity of their domain and produce a static declarative provider manifest.","pos":[3255,3349]},{"content":"You write an XML file that has two sections:","pos":[3356,3400]},{"content":"A list of provider types expressed in terms of the \"EDM counterpart\" of a store type or function.","pos":[3410,3507]},{"content":"Store types have counterpart EDM types.","pos":[3508,3547]},{"content":"Store functions have corresponding EDM functions.","pos":[3548,3597]},{"content":"For example, varchar is a SQL Server type but the corresponding EDM type is string.","pos":[3598,3681]},{"content":"A list of functions supported by the provider where parameter and return types are expressed in EDM terms.","pos":[3691,3797]},{"pos":[3807,3854],"content":"Writing a Provider with Asymmetric Type Mapping","linkify":"Writing a Provider with Asymmetric Type Mapping","nodes":[{"content":"Writing a Provider with Asymmetric Type Mapping","pos":[0,47]}]},{"content":"When writing a data store provider for the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph>, the EDM-to-provider type mapping for some types may be different from provider-to-EDM type mapping.","pos":[3858,4064],"source":"When writing a data store provider for the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], the EDM-to-provider type mapping for some types may be different from provider-to-EDM type mapping."},{"content":"For instance, unbounded EDM PrimitiveTypeKind.String may map to nvarchar(4000) on the provider, while nvarchar(4000) maps to the EDM PrimitiveTypeKind.String(MaxLength=4000).","pos":[4065,4239]},{"content":"You write an XML file that has two sections:","pos":[4246,4290]},{"content":"A list of provider types expressed in EDM terms and define mapping for both direction: EDM-to-provider and provider-to-EDM.","pos":[4300,4423]},{"content":"A list of functions supported by the provider where parameter and return types are expressed in EDM terms.","pos":[4433,4539]},{"pos":[4548,4581],"content":"Provider Manifest Discoverability","linkify":"Provider Manifest Discoverability","nodes":[{"content":"Provider Manifest Discoverability","pos":[0,33]}]},{"content":"The manifest is used indirectly by several component types in Entity Services (for example Tools or Query) but more directly leveraged by metadata through the use of the data store metadata loader.","pos":[4585,4782]},{"pos":[4789,4976],"content":"<bpt id=\"p1\">![</bpt>dfb3d02b&amp;#45;7a8c&amp;#45;4d51&amp;#45;ac5a&amp;#45;a73d8aa145e6<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/dfb3d02b-7a8c-4d51-ac5a-a73d8aa145e6.gif \"</bpt>dfb3d02b-7a8c-4d51-ac5a-a73d8aa145e6<ept id=\"p2\">\")</ept>","source":"![dfb3d02b&#45;7a8c&#45;4d51&#45;ac5a&#45;a73d8aa145e6](../../../../../docs/framework/data/adonet/ef/media/dfb3d02b-7a8c-4d51-ac5a-a73d8aa145e6.gif \"dfb3d02b-7a8c-4d51-ac5a-a73d8aa145e6\")"},{"content":"However, a given provider may support different stores or different versions of the same store.","pos":[4983,5078]},{"content":"Therefore, a provider must report a different manifest for each supported data store.","pos":[5079,5164]},{"pos":[5174,5197],"content":"Provider Manifest Token","linkify":"Provider Manifest Token","nodes":[{"content":"Provider Manifest Token","pos":[0,23]}]},{"content":"When a data store connection is opened, the provider can query for information to return the right manifest.","pos":[5201,5309]},{"content":"This may not be possible in offline scenarios where connection information is not available or when it is not possible to connect to the store.","pos":[5310,5453]},{"content":"Identify the manifest by using the <ph id=\"ph1\">`ProviderManifestToken`</ph> attribute of the <ph id=\"ph2\">`Schema`</ph> element in the .ssdl file.","pos":[5454,5565],"source":" Identify the manifest by using the `ProviderManifestToken` attribute of the `Schema` element in the .ssdl file."},{"content":"There is no required format for this attribute; the provider chooses the minimum information needed to identify a manifest without opening a connection to the store.","pos":[5566,5731]},{"content":"For example:","pos":[5738,5750]},{"pos":[5992,6027],"content":"Provider Manifest Programming Model","linkify":"Provider Manifest Programming Model","nodes":[{"content":"Provider Manifest Programming Model","pos":[0,35]}]},{"content":"Providers derive from <ph id=\"ph1\">&lt;xref:System.Data.Common.DbXmlEnabledProviderManifest&gt;</ph>, which allows them to specify their manifests declaratively.","pos":[6031,6168],"source":"Providers derive from <xref:System.Data.Common.DbXmlEnabledProviderManifest>, which allows them to specify their manifests declaratively."},{"content":"The following illustration shows the class hierarchy of a provider:","pos":[6169,6236]},{"pos":[6243,6382],"content":"<bpt id=\"p1\">![</bpt>None<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../../docs/framework/data/adonet/ef/media/d541eba3-2ee6-4cd1-88f5-89d0b2582a6c.gif \"</bpt>d541eba3-2ee6-4cd1-88f5-89d0b2582a6c<ept id=\"p2\">\")</ept>","source":"![None](../../../../../docs/framework/data/adonet/ef/media/d541eba3-2ee6-4cd1-88f5-89d0b2582a6c.gif \"d541eba3-2ee6-4cd1-88f5-89d0b2582a6c\")"},{"pos":[6392,6411],"content":"Discoverability API","linkify":"Discoverability API","nodes":[{"content":"Discoverability API","pos":[0,19]}]},{"content":"The provider manifest is loaded by the Store Metadata loader (StoreItemCollection), either by using a data store connection or a provider manifest token.","pos":[6415,6568]},{"pos":[6579,6608],"content":"Using a Data Store Connection","linkify":"Using a Data Store Connection","nodes":[{"content":"Using a Data Store Connection","pos":[0,29]}]},{"content":"When the data store connection is available, call DbProvderServices.GetProviderManifestToken to return the token that is passed to the GetProviderManifest method, which returns DbProviderManifest.","pos":[6612,6808]},{"content":"This method delegates to the provider's implementation of GetDbProviderManifestToken.","pos":[6809,6894]},{"pos":[7058,7089],"content":"Using a Provider Manifest Token","linkify":"Using a Provider Manifest Token","nodes":[{"content":"Using a Provider Manifest Token","pos":[0,31]}]},{"content":"For the offline scenario, the token is picked from SSDL representation.","pos":[7093,7164]},{"content":"The SSDL allows you to specify a ProviderManifestToken (see <bpt id=\"p1\">[</bpt>Schema Element (SSDL)<ept id=\"p1\">](/ef/ef6/modeling/designer/advanced/edmx/ssdl-spec#schema-element-ssdl)</ept> for more information).","pos":[7165,7342],"source":" The SSDL allows you to specify a ProviderManifestToken (see [Schema Element (SSDL)](/ef/ef6/modeling/designer/advanced/edmx/ssdl-spec#schema-element-ssdl) for more information)."},{"content":"For example, if a connection cannot be opened, the SSDL has a provider manifest token that specifies information about the manifest.","pos":[7343,7475]},{"pos":[7571,7595],"content":"Provider Manifest Schema","linkify":"Provider Manifest Schema","nodes":[{"content":"Provider Manifest Schema","pos":[0,24]}]},{"content":"The schema of information defined for each provider contains the static information to be consumed by metadata:","pos":[7599,7710]},{"pos":[13991,14001],"content":"Types Node","linkify":"Types Node","nodes":[{"content":"Types Node","pos":[0,10]}]},{"content":"The Types node in the provider manifest contains information about the Types that are supported natively by the data store or through the provider.","pos":[14005,14152]},{"pos":[14164,14173],"content":"Type Node","linkify":"Type Node","nodes":[{"content":"Type Node","pos":[0,9]}]},{"content":"Each Type node defines a provider type in terms of EDM.","pos":[14177,14232]},{"content":"The Type node describes the name of the provider type, and information related to the model type it maps to and facets to describe that type mapping.","pos":[14233,14382]},{"content":"In order to express this type information in the provider manifest, each TypeInformation declaration must define several facet descriptions for each Type:","pos":[14389,14543]},{"content":"Attribute Name","pos":[14550,14564]},{"content":"Data Type","pos":[14565,14574]},{"content":"Required","pos":[14575,14583]},{"content":"Default Value","pos":[14584,14597]},{"content":"Description","pos":[14598,14609]},{"content":"Name","pos":[14708,14712]},{"content":"String","pos":[14713,14719]},{"content":"Yes","pos":[14720,14723]},{"content":"n/a","pos":[14724,14727]},{"content":"Provider-specific data type name","pos":[14728,14760]},{"content":"PrimitiveTypeKind","pos":[14765,14782]},{"content":"PrimitiveTypeKind","pos":[14783,14800]},{"content":"Yes","pos":[14801,14804]},{"content":"n/a","pos":[14805,14808]},{"content":"EDM type name","pos":[14809,14822]},{"pos":[14836,14849],"content":"Function Node","linkify":"Function Node","nodes":[{"content":"Function Node","pos":[0,13]}]},{"content":"Each Function defines a single function available through the provider.","pos":[14853,14924]},{"content":"Attribute Name","pos":[14931,14945]},{"content":"Data Type","pos":[14946,14955]},{"content":"Required","pos":[14956,14964]},{"content":"Default Value","pos":[14965,14978]},{"content":"Description","pos":[14979,14990]},{"content":"Name","pos":[15089,15093]},{"content":"String","pos":[15094,15100]},{"content":"Yes","pos":[15101,15104]},{"content":"n/a","pos":[15105,15108]},{"content":"Identifier/name of the function","pos":[15109,15140]},{"content":"ReturnType","pos":[15145,15155]},{"content":"String","pos":[15156,15162]},{"content":"No","pos":[15163,15165]},{"content":"Void","pos":[15166,15170]},{"content":"The EDM return type of the function","pos":[15171,15206]},{"content":"Aggregate","pos":[15211,15220]},{"content":"Boolean","pos":[15221,15228]},{"content":"No","pos":[15229,15231]},{"content":"False","pos":[15232,15237]},{"content":"True if the function is an aggregate function","pos":[15238,15283]},{"content":"BuiltIn","pos":[15288,15295]},{"content":"Boolean","pos":[15296,15303]},{"content":"No","pos":[15304,15306]},{"content":"True","pos":[15307,15311]},{"content":"True if the function is built into the data store","pos":[15312,15361]},{"content":"StoreFunctionName","pos":[15366,15383]},{"content":"String","pos":[15384,15390]},{"content":"No","pos":[15391,15393]},{"content":"<ph id=\"ph1\">\\&lt;</ph>Name&gt;","pos":[15394,15401],"source":"\\<Name>"},{"content":"Function Name in the data store.","pos":[15402,15434]},{"content":"Allows for a level of redirection of function names.","pos":[15436,15488]},{"content":"NiladicFunction","pos":[15493,15508]},{"content":"Boolean","pos":[15509,15516]},{"content":"No","pos":[15517,15519]},{"content":"False","pos":[15520,15525]},{"content":"True if the function does not require parameters and is called without any parameters","pos":[15526,15611]},{"content":"ParameterType","pos":[15616,15629]},{"content":"Semantics","pos":[15642,15651]},{"content":"ParameterSemantics","pos":[15652,15670]},{"content":"No","pos":[15671,15673]},{"content":"AllowImplicit","pos":[15674,15687]},{"content":"Conversion","pos":[15700,15710]},{"content":"Choice of how the query pipeline should deal with parameter type substitution:","pos":[15711,15789]},{"content":"-   ExactMatchOnly","pos":[15802,15820]},{"content":"-   AllowImplicitPromotion","pos":[15826,15852]},{"content":"-   AllowImplicitConversion","pos":[15858,15885]},{"pos":[15893,15912],"content":"<bpt id=\"p1\">**</bpt>Parameters Node<ept id=\"p1\">**</ept>","source":"**Parameters Node**"},{"content":"Each function has a collection of one or more Parameter nodes.","pos":[15919,15981]},{"content":"Attribute Name","pos":[15988,16002]},{"content":"Data Type","pos":[16003,16012]},{"content":"Required","pos":[16013,16021]},{"content":"Default Value","pos":[16022,16035]},{"content":"Description","pos":[16036,16047]},{"content":"Name","pos":[16146,16150]},{"content":"String","pos":[16151,16157]},{"content":"Yes","pos":[16158,16161]},{"content":"n/a","pos":[16162,16165]},{"content":"Identifier/name of the parameter.","pos":[16166,16199]},{"content":"Type","pos":[16204,16208]},{"content":"String","pos":[16209,16215]},{"content":"Yes","pos":[16216,16219]},{"content":"n/a","pos":[16220,16223]},{"content":"The EDM type of the parameter.","pos":[16224,16254]},{"content":"Mode","pos":[16259,16263]},{"content":"Parameter","pos":[16264,16273]},{"content":"Direction","pos":[16286,16295]},{"content":"Yes","pos":[16296,16299]},{"content":"n/a","pos":[16300,16303]},{"content":"Direction of parameter:","pos":[16304,16327]},{"content":"-   in","pos":[16340,16346]},{"content":"-   out","pos":[16352,16359]},{"content":"-   inout","pos":[16365,16374]},{"pos":[16387,16406],"content":"Namespace Attribute","linkify":"Namespace Attribute","nodes":[{"content":"Namespace Attribute","pos":[0,19]}]},{"content":"Each data store provider must define a namespace or group of namespaces for information defined in the manifest.","pos":[16410,16522]},{"content":"This namespace can be used in Entity SQL queries to resolve names of functions and types.","pos":[16523,16612]},{"content":"For instance: SqlServer.","pos":[16613,16637]},{"content":"That namespace must be different from the canonical namespace, EDM, defined by Entity Services for standard functions to be supported by Entity SQL queries.","pos":[16638,16794]},{"pos":[16803,16811],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[16815,16935],"content":"<bpt id=\"p1\">[</bpt>Writing an Entity Framework Data Provider<ept id=\"p1\">](../../../../../docs/framework/data/adonet/ef/writing-an-ef-data-provider.md)</ept>","source":"[Writing an Entity Framework Data Provider](../../../../../docs/framework/data/adonet/ef/writing-an-ef-data-provider.md)"}]}