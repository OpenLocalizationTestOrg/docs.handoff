{"content":"---\ntitle: \"XML and ADO.NET Types in Data Contracts\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6\n---\n# XML and ADO.NET Types in Data Contracts\nThe Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly. When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing. Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>. The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming. These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model. Some special considerations for these types are listed at the end of this topic.  \n  \n## XML Types  \n  \n### Xml Element  \n The `XmlElement` type is serialized using its XML contents. For example, using the following type.  \n  \n [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]\n [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  \n  \n This is serialized to XML as follows:  \n  \n```xml  \n<MyDataContract xmlns=\"http://schemas.contoso.com\">  \n    <myDataMember>  \n        <myElement xmlns=\"\" myAttribute=\"myValue\">  \n            myContents  \n        </myElement>  \n    </myDataMember>  \n</MyDataContract>  \n```  \n  \n Notice that a wrapper data member element `<myDataMember>` is still present. There is no way of removing this element in the data contract model. The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element. These attributes include the standard XML Schema Instance \"nil\" attribute (allowing the `XmlElement` to be `null`) and the \"type\" attribute (allowing `XmlElement` to be used polymorphically). Also, the following XML attributes are specific to WCF: \"Id\", \"Ref\", \"Type\" and \"Assembly\". These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>. (For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)  \n  \n Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection. That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.  \n  \n On deserialization, an `XmlElement` is created by the deserializer from the incoming XML. A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.  \n  \n Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements. This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.  \n  \n When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>. Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member. As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is \"XmlElement\" in the \"http://schemas.datacontract.org/2004/07/System.Xml\" namespace.  \n  \n With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.  \n  \n Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.  \n  \n### Array of XmlNode  \n Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`. Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`. You can write multiple elements inside the data member wrapping element. You can also inject content other than elements inside of the data member wrapping element, such as XML comments. Finally, you can put attributes into the wrapping data member element. All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>. For example, using the following type.  \n  \n [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]\n [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  \n  \n When serialized, the resulting XML is similar to the following code.  \n  \n```xml  \n<MyDataContract xmlns=\"http://schemas.contoso.com\">  \n  <myDataMember myAttribute=\"myValue\">  \n     <!--myComment-->  \n     <myElement xmlns=\"\" myAttribute=\"myValue\">  \n myContents  \n     </myElement>  \n     <myElement xmlns=\"\" myAttribute=\"myValue\">  \n       myContents  \n     </myElement>  \n  </myDataMember>  \n</MyDataContract>  \n```  \n  \n Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements. These are the four `XmlNode` instances that were serialized.  \n  \n An array of `XmlNode` that results in invalid XML cannot be serialized. For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).  \n  \n On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML. A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer. All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment). The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.  \n  \n When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.  \n  \n Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`. It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array. If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null. On deserialization, the entire array member also becomes null.  \n  \n Only regular arrays of `XmlNode` are treated specially by the serializer. Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially. Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.  \n  \n Arrays or collections of arrays of `XmlNode` are allowed. There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.  \n  \n Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances. Each array member is serialized separately.  \n  \n When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`. Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member. As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is \"ArrayOfXmlNode\" in the \"http://schemas.datacontract.org/2004/07/System.Xml\" namespace. When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.  \n  \n### Schema Considerations  \n For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md). This section provides a summary of the important points.  \n  \n A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.  \n  \n```xml  \n<xsd:complexType>  \n   <xsd:sequence>  \n      <xsd:any minOccurs=\"0\" processContents=\"lax\" />  \n   </xsd:sequence>  \n</xsd:complexType>  \n```  \n  \n A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.  \n  \n```xml  \n<xsd:complexType mixed=\"true\">  \n   <xsd:sequence>  \n      <xsd:any minOccurs=\"0\" maxOccurs=\"unbounded\" processContents=\"lax\" />  \n   </xsd:sequence>  \n   <xsd:anyAttribute/>  \n</xsd:complexType>  \n```  \n  \n## Types Implementing the IXmlSerializable Interface  \n Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`. The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.  \n  \n There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.  \n  \n-   Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute. The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`. This is the most common usage of `IXmlSerializable` types.  \n  \n-   Element types are used when an `IXmlSerializable` type must control its own root element name. To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method. Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`. However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.  \n  \n-   Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute. Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation. This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons. Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.  \n  \n### IXmlSerializable Content Types  \n When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method. The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element. After `WriteXml` is done, the serializer closes the element.  \n  \n When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method. The method must read the entire element, including the start and end tags. Make sure your `ReadXml` code handles the case where the element is empty. Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way. The name is chosen by the serializer can vary.  \n  \n It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>. It is also permitted for the type instances to be null. Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>. All these features require the WCF serializer to attach certain attributes into the wrapper element (\"nil\" and \"type\" in the XML Schema Instance namespace and \"Id\", \"Ref\", \"Type\" and \"Assembly\" in a WCF-specific namespace).  \n  \n#### Attributes to Ignore when Implementing ReadXml  \n Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them. For example, if \"nil\" is `true`, a null value is deserialized and `ReadXml` is not called. If polymorphism is detected, the contents of the element are deserialized as if it was a different type. The polymorphically assigned type’s implementation of `ReadXml` is called. In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.  \n  \n### Schema Considerations for IXmlSerializable Content Types  \n When exporting schema an `IXmlSerializable` content type, the schema provider method is called. An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method. The method can add any valid schema to the schema set. The schema set contains the schema that is already known at the time when schema export occurs. When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set. If it does, the schema provider method must add the new item to the existing `XmlSchema`. Otherwise, it must create a new `XmlSchema` instance. This is important if arrays of `IXmlSerializable` types are being used. For example, if you have an `IXmlSerializable` type that gets exported as type \"A\" in namespace \"B\", it is possible that by the time the schema provider method is called the schema set already contains the schema for \"B\" to hold the \"ArrayOfA\" type.  \n  \n In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value. It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type. This qualified name also serves as the data contract name and namespace for the type. It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns. However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set. Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>. For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).  \n  \n The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use. The type may or may not be anonymous. If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member. The `IXmlSerializable` type still has a data contract name and namespace. (This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`. This case is equivalent to returning the `XmlQualifiedName` of the type.  \n  \n Additionally, a global element declaration is exported for the type. If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its \"nillable\" property is true. The only exception to this is the schema namespace (\"http://www.w3.org/2001/XMLSchema\") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace. If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties. The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and \"nillable\" being true.  \n  \n The same global element declaration rules apply to legacy dataset types. Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.  \n  \n### IXmlSerializable Element Types  \n `IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.  \n  \n Serializing and deserializing an element type is very similar to serializing and deserializing a content type. However, there are some important differences:  \n  \n-   The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements). It should not be writing attributes outside of this single element, multiple sibling elements or mixed content. The element may be empty.  \n  \n-   The `ReadXml` implementation should not read the wrapper element. It is expected to read the one element that `WriteXml` produces.  \n  \n-   When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types. However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors. For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).  \n  \n-   When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`. In this mode, the object being serialized cannot be null and cannot be polymorphically assigned. Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.  \n  \n-   When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element. <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object. `ReadObject` then passes control to `ReadXml` method.  \n  \n The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types. Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.  \n  \n### Differences from the XmlSerializer  \n The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> . However, there are some differences in how these are treated in the data contract model. The important differences are summarized in the following:  \n  \n-   The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.  \n  \n-   The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.  \n  \n-   When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace. In the data contract model, the namespace used is normally the data contract namespace as described earlier.  \n  \n Be aware of these differences when creating types that are used with both serialization technologies.  \n  \n### Importing IXmlSerializable Schema  \n When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:  \n  \n-   The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md). In this case, schema can be imported as usual and regular data contract types are generated.  \n  \n-   The generated schema may not be a valid data contract schema. For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model. In this case, you can import the schema as `IXmlSerializable` types. This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md). This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md). Note that you must work directly with the XML for your type instances. You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.  \n  \n-   You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones. In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse. This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.  \n  \n## Representing Arbitrary XML in Data Contracts  \n The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model. The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process. However, the XML writers may enforce certain restrictions on the XML that they write. Specifically, here are some important examples:  \n  \n-   The XML writers do not typically allow an XML document declaration (for example, \\<?xml version=’1.0’ ?>) in the middle of writing another document. You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member. To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.  \n  \n-   All of the XML writers supplied with WCF reject XML processing instructions (\\<? … ?>) and document type definitions (\\<! … >), because they are not allowed in SOAP messages. Again, you can use your own encoding mechanism to get around this restriction. If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.  \n  \n-   When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer. WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.  \n  \n-   When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.  \n  \n## Using DataSet, Typed DataSet and DataTable  \n Using these types is fully supported in the data contract model. When using these types, consider the following points:  \n  \n-   The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms. Additionally, using the `DataSet` type may have performance implications. Finally, it may make it more difficult for you to version your application in the future. Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.  \n  \n-   When importing `DataSet` or `DataTable` schema, it is important to reference these types. With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch. If importing typed dataset schema, you must reference the typed dataset’s type. With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch. For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).  \n  \n Support for typed DataSets in the data contract model is limited. Typed DataSets can be serialized and deserialized and can export their schema. However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones. You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe. If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected. If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.  \n  \n## See also\n\n- <xref:System.Runtime.Serialization.DataContractSerializer>\n- <xref:System.Xml.Serialization.IXmlSerializable>\n- [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)\n- [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)\n","nodes":[{"pos":[4,157],"embed":true,"restype":"x-metadata","content":"title: \"XML and ADO.NET Types in Data Contracts\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6","nodes":[{"content":"XML and ADO.NET Types in Data Contracts","nodes":[{"pos":[0,39],"content":"XML and ADO.NET Types in Data Contracts","nodes":[{"content":"XML and ADO.NET Types in Data Contracts","pos":[0,39]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[164,203],"content":"XML and ADO.NET Types in Data Contracts","linkify":"XML and ADO.NET Types in Data Contracts","nodes":[{"content":"XML and ADO.NET Types in Data Contracts","pos":[0,39]}]},{"content":"The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.","pos":[204,318]},{"content":"When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.","pos":[319,448]},{"content":"Supported types are <ph id=\"ph1\">&lt;xref:System.Xml.XmlElement&gt;</ph>, arrays of <ph id=\"ph2\">&lt;xref:System.Xml.XmlNode&gt;</ph> (but not the <ph id=\"ph3\">`XmlNode`</ph> type itself), as well as types that implement <ph id=\"ph4\">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.","pos":[449,653],"source":" Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Data.DataTable&gt;</ph> type, as well as typed datasets, are commonly used in database programming.","pos":[654,793],"source":" The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming."},{"content":"These types implement the <ph id=\"ph1\">`IXmlSerializable`</ph> interface and are therefore serializable in the data contract model.","pos":[794,907],"source":" These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model."},{"content":"Some special considerations for these types are listed at the end of this topic.","pos":[908,988]},{"pos":[997,1006],"content":"XML Types","linkify":"XML Types","nodes":[{"content":"XML Types","pos":[0,9]}]},{"pos":[1016,1027],"content":"Xml Element","linkify":"Xml Element","nodes":[{"content":"Xml Element","pos":[0,11]}]},{"content":"The <ph id=\"ph1\">`XmlElement`</ph> type is serialized using its XML contents.","pos":[1031,1090],"source":"The `XmlElement` type is serialized using its XML contents."},{"content":"For example, using the following type.","pos":[1091,1129]},{"content":"This is serialized to XML as follows:","pos":[1408,1445]},{"content":"Notice that a wrapper data member element <ph id=\"ph1\">`&lt;myDataMember&gt;`</ph> is still present.","pos":[1688,1764],"source":"Notice that a wrapper data member element `<myDataMember>` is still present."},{"content":"There is no way of removing this element in the data contract model.","pos":[1765,1833]},{"content":"The serializers that handle this model (the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>) may emit special attributes into this wrapper element.","pos":[1834,2058],"source":" The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element."},{"content":"These attributes include the standard XML Schema Instance \"nil\" attribute (allowing the <ph id=\"ph1\">`XmlElement`</ph> to be <ph id=\"ph2\">`null`</ph>) and the \"type\" attribute (allowing <ph id=\"ph3\">`XmlElement`</ph> to be used polymorphically).","pos":[2059,2250],"source":" These attributes include the standard XML Schema Instance \"nil\" attribute (allowing the `XmlElement` to be `null`) and the \"type\" attribute (allowing `XmlElement` to be used polymorphically)."},{"content":"Also, the following XML attributes are specific to WCF: \"Id\", \"Ref\", \"Type\" and \"Assembly\".","pos":[2251,2342]},{"content":"These attributes may be emitted to support using the <ph id=\"ph1\">`XmlElement`</ph> with the object graph preservation mode enabled, or with the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.","pos":[2343,2532],"source":" These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>."},{"content":"(For more information about the object graph preservation mode, see <bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.)","pos":[2533,2723],"source":" (For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)"},{"content":"Arrays or collections of <ph id=\"ph1\">`XmlElement`</ph> are allowed and are handled as any other array or collection.","pos":[2730,2829],"source":"Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection."},{"content":"That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to <ph id=\"ph1\">`&lt;myDataMember&gt;`</ph> in the preceding example) for each <ph id=\"ph2\">`XmlElement`</ph> in the array.","pos":[2830,3014],"source":" That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array."},{"content":"On deserialization, an <ph id=\"ph1\">`XmlElement`</ph> is created by the deserializer from the incoming XML.","pos":[3021,3110],"source":"On deserialization, an `XmlElement` is created by the deserializer from the incoming XML."},{"content":"A valid parent <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph> is provided by the deserializer.","pos":[3111,3188],"source":" A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer."},{"content":"Make sure that the XML fragment that is deserialized to an <ph id=\"ph1\">`XmlElement`</ph> defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.","pos":[3195,3368],"source":"Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements."},{"content":"This is a concern only when using the <ph id=\"ph1\">`DataContractSerializer`</ph> to access XML from a different (non-<ph id=\"ph2\">`DataContractSerializer`</ph>) source.","pos":[3369,3501],"source":" This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source."},{"content":"When used with the <ph id=\"ph1\">`DataContractSerializer`</ph>, the <ph id=\"ph2\">`XmlElement`</ph> may be assigned polymorphically, but only to a data member of type <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>.","pos":[3508,3658],"source":"When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>."},{"content":"Even though it implements <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable&gt;</ph>, an <ph id=\"ph2\">`XmlElement`</ph> cannot be used as a collection type and cannot be assigned to an <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerable&gt;</ph> data member.","pos":[3659,3855],"source":" Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member."},{"content":"As with all polymorphic assignments, the <ph id=\"ph1\">`DataContractSerializer`</ph> emits the data contract name in the resulting XML – in this case, it is \"XmlElement\" in the \"<ph id=\"ph2\">http://schemas.datacontract.org/2004/07/System.Xml</ph>\" namespace.","pos":[3856,4077],"source":" As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is \"XmlElement\" in the \"http://schemas.datacontract.org/2004/07/System.Xml\" namespace."},{"pos":[4084,4215],"content":"With the <ph id=\"ph1\">`NetDataContractSerializer`</ph>, any valid polymorphic assignment of <ph id=\"ph2\">`XmlElement`</ph> (to <ph id=\"ph3\">`Object`</ph> or <ph id=\"ph4\">`IEnumerable`</ph>) is supported.","source":"With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported."},{"pos":[4222,4357],"content":"Do not attempt to use either of the serializers with types derived from <ph id=\"ph1\">`XmlElement`</ph>, whether they are assigned polymorphically or not.","source":"Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not."},{"pos":[4367,4383],"content":"Array of XmlNode","linkify":"Array of XmlNode","nodes":[{"content":"Array of XmlNode","pos":[0,16]}]},{"content":"Using arrays of <ph id=\"ph1\">&lt;xref:System.Xml.XmlNode&gt;</ph> is very similar to using <ph id=\"ph2\">`XmlElement`</ph>.","pos":[4387,4467],"source":"Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`."},{"content":"Using arrays of <ph id=\"ph1\">`XmlNode`</ph> gives you more flexibility than using <ph id=\"ph2\">`XmlElement`</ph>.","pos":[4468,4545],"source":" Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`."},{"content":"You can write multiple elements inside the data member wrapping element.","pos":[4546,4618]},{"content":"You can also inject content other than elements inside of the data member wrapping element, such as XML comments.","pos":[4619,4732]},{"content":"Finally, you can put attributes into the wrapping data member element.","pos":[4733,4803]},{"content":"All this can be achieved by populating the array of <ph id=\"ph1\">`XmlNode`</ph> with specific derived classes of <ph id=\"ph2\">`XmlNode`</ph> such as <ph id=\"ph3\">&lt;xref:System.Xml.XmlAttribute&gt;</ph>, <ph id=\"ph4\">`XmlElement`</ph> or <ph id=\"ph5\">&lt;xref:System.Xml.XmlComment&gt;</ph>.","pos":[4804,4994],"source":" All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>."},{"content":"For example, using the following type.","pos":[4995,5033]},{"content":"When serialized, the resulting XML is similar to the following code.","pos":[5312,5380]},{"content":"Note that the data member wrapper element <ph id=\"ph1\">`&lt;myDataMember&gt;`</ph> contains an attribute, a comment, and two elements.","pos":[5738,5848],"source":"Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements."},{"content":"These are the four <ph id=\"ph1\">`XmlNode`</ph> instances that were serialized.","pos":[5849,5909],"source":" These are the four `XmlNode` instances that were serialized."},{"content":"An array of <ph id=\"ph1\">`XmlNode`</ph> that results in invalid XML cannot be serialized.","pos":[5916,5987],"source":"An array of `XmlNode` that results in invalid XML cannot be serialized."},{"content":"For example, an array of two <ph id=\"ph1\">`XmlNode`</ph> instances where the first one is an <ph id=\"ph2\">`XmlElement`</ph> and the second one is an <ph id=\"ph3\">&lt;xref:System.Xml.XmlAttribute&gt;</ph> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).","pos":[5988,6259],"source":" For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to)."},{"content":"On deserialization of an array of <ph id=\"ph1\">`XmlNode`</ph>, nodes are created and populated with information from the incoming XML.","pos":[6266,6382],"source":"On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML."},{"content":"A valid parent <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph> is provided by the deserializer.","pos":[6383,6460],"source":" A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer."},{"content":"All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).","pos":[6461,6680]},{"content":"The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of <ph id=\"ph1\">`XmlNode`</ph> just like it does to deserializing <ph id=\"ph2\">`XmlElement`</ph>.","pos":[6681,6852],"source":" The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`."},{"pos":[6859,7031],"content":"When using the serializers with object graph preservation turned on, object equality is only preserved on the level of <ph id=\"ph1\">`XmlNode`</ph> arrays, not individual <ph id=\"ph2\">`XmlNode`</ph> instances.","source":"When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances."},{"content":"Do not attempt to serialize an array of <ph id=\"ph1\">`XmlNode`</ph> where one or more of the nodes is set to <ph id=\"ph2\">`null`</ph>.","pos":[7038,7136],"source":"Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`."},{"content":"It is permitted for the entire array member to be <ph id=\"ph1\">`null`</ph>, but not for any individual <ph id=\"ph2\">`XmlNode`</ph> contained in the array.","pos":[7137,7255],"source":" It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array."},{"content":"If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.","pos":[7256,7384]},{"content":"On deserialization, the entire array member also becomes null.","pos":[7385,7447]},{"content":"Only regular arrays of <ph id=\"ph1\">`XmlNode`</ph> are treated specially by the serializer.","pos":[7454,7527],"source":"Only regular arrays of `XmlNode` are treated specially by the serializer."},{"content":"Data members declared as other collection types that contain <ph id=\"ph1\">`XmlNode`</ph>, or data members declared as arrays of types derived from <ph id=\"ph2\">`XmlNode`</ph>, are not treated specially.","pos":[7528,7694],"source":" Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially."},{"content":"Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.","pos":[7695,7800]},{"content":"Arrays or collections of arrays of <ph id=\"ph1\">`XmlNode`</ph> are allowed.","pos":[7807,7864],"source":"Arrays or collections of arrays of `XmlNode` are allowed."},{"content":"There is a wrapper element for the entire collection, and a separate wrapper element (similar to <ph id=\"ph1\">`&lt;myDataMember&gt;`</ph> in the preceding example) for each array of <ph id=\"ph2\">`XmlNode`</ph> in the outer array or collection.","pos":[7865,8066],"source":" There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection."},{"content":"Populating a data member of type <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> of <ph id=\"ph2\">`Object`</ph> or <ph id=\"ph3\">`Array`</ph> of <ph id=\"ph4\">`IEnumerable`</ph> with <ph id=\"ph5\">`XmlNode`</ph> instances does not result in the data member being treated as an <ph id=\"ph6\">`Array`</ph> of <ph id=\"ph7\">`XmlNode`</ph> instances.","pos":[8073,8277],"source":"Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances."},{"content":"Each array member is serialized separately.","pos":[8278,8321]},{"content":"When used with the <ph id=\"ph1\">`DataContractSerializer`</ph>, arrays of <ph id=\"ph2\">`XmlNode`</ph> can be assigned polymorphically, but only to a data member of type <ph id=\"ph3\">`Object`</ph>.","pos":[8328,8469],"source":"When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`."},{"content":"Even though it implements <ph id=\"ph1\">`IEnumerable`</ph>, an array of <ph id=\"ph2\">`XmlNode`</ph> cannot be used as a collection type and be assigned to an <ph id=\"ph3\">`IEnumerable`</ph> data member.","pos":[8470,8617],"source":" Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member."},{"content":"As with all polymorphic assignments, the <ph id=\"ph1\">`DataContractSerializer`</ph> emits the data contract name in the resulting XML – in this case, it is \"ArrayOfXmlNode\" in the \"<ph id=\"ph2\">http://schemas.datacontract.org/2004/07/System.Xml</ph>\" namespace.","pos":[8618,8843],"source":" As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is \"ArrayOfXmlNode\" in the \"http://schemas.datacontract.org/2004/07/System.Xml\" namespace."},{"content":"When used with the <ph id=\"ph1\">`NetDataContractSerializer`</ph>, any valid assignment of an <ph id=\"ph2\">`XmlNode`</ph> array is supported.","pos":[8844,8948],"source":" When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported."},{"pos":[8958,8979],"content":"Schema Considerations","linkify":"Schema Considerations","nodes":[{"content":"Schema Considerations","pos":[0,21]}]},{"content":"For details about the schema mapping of XML types, see <bpt id=\"p1\">[</bpt>Data Contract Schema Reference<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.","pos":[8983,9153],"source":"For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)."},{"content":"This section provides a summary of the important points.","pos":[9154,9210]},{"pos":[9217,9319],"content":"A data member of type <ph id=\"ph1\">`XmlElement`</ph> is mapped to an element defined using the following anonymous type.","source":"A data member of type `XmlElement` is mapped to an element defined using the following anonymous type."},{"pos":[9482,9590],"content":"A data member of type Array of <ph id=\"ph1\">`XmlNode`</ph> is mapped to an element defined using the following anonymous type.","source":"A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type."},{"pos":[9815,9864],"content":"Types Implementing the IXmlSerializable Interface","linkify":"Types Implementing the IXmlSerializable Interface","nodes":[{"content":"Types Implementing the IXmlSerializable Interface","pos":[0,49]}]},{"content":"Types that implement the <ph id=\"ph1\">`IXmlSerializable`</ph> interface are fully supported by the <ph id=\"ph2\">`DataContractSerializer`</ph>.","pos":[9868,9974],"source":"Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute should always be applied to these types to control their schema.","pos":[9975,10112],"source":" The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema."},{"pos":[10119,10312],"content":"There are three varieties of types that implement <ph id=\"ph1\">`IXmlSerializable`</ph>: types that represent arbitrary content, types that represent a single element, and legacy <ph id=\"ph2\">&lt;xref:System.Data.DataSet&gt;</ph> types.","source":"There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types."},{"content":"Content types use a schema provider method specified by the <ph id=\"ph1\">`XmlSchemaProviderAttribute`</ph> attribute.","pos":[10322,10421],"source":"Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute."},{"content":"The method does not return <ph id=\"ph1\">`null`</ph>, and the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the attribute is left at its default value of <ph id=\"ph3\">`false`</ph>.","pos":[10422,10599],"source":" The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`."},{"content":"This is the most common usage of <ph id=\"ph1\">`IXmlSerializable`</ph> types.","pos":[10600,10658],"source":" This is the most common usage of `IXmlSerializable` types."},{"content":"Element types are used when an <ph id=\"ph1\">`IXmlSerializable`</ph> type must control its own root element name.","pos":[10668,10762],"source":"Element types are used when an `IXmlSerializable` type must control its own root element name."},{"content":"To mark a type as an element type, either set the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A&gt;</ph> property on the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlSchemaProviderAttribute&gt;</ph> attribute to <ph id=\"ph3\">`true`</ph> or return null from the schema provider method.","pos":[10763,11023],"source":" To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method."},{"content":"Having a schema provider method is optional for element types – you may specify null instead of the method name in the <ph id=\"ph1\">`XmlSchemaProviderAttribute`</ph>.","pos":[11024,11172],"source":" Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`."},{"content":"However, if <ph id=\"ph1\">`IsAny`</ph> is <ph id=\"ph2\">`true`</ph> and a schema provider method is specified, the method must return null.","pos":[11173,11274],"source":" However, if `IsAny` is `true` and a schema provider method is specified, the method must return null."},{"content":"Legacy <ph id=\"ph1\">&lt;xref:System.Data.DataSet&gt;</ph> types are <ph id=\"ph2\">`IXmlSerializable`</ph> types that are not marked with the <ph id=\"ph3\">`XmlSchemaProviderAttribute`</ph> attribute.","pos":[11284,11421],"source":"Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute."},{"content":"Instead, they rely on the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A&gt;</ph> method for schema generation.","pos":[11422,11539],"source":" Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation."},{"content":"This pattern is used for the <ph id=\"ph1\">`DataSet`</ph> type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.","pos":[11540,11726],"source":" This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons."},{"content":"Do not rely on this pattern and always apply the <ph id=\"ph1\">`XmlSchemaProviderAttribute`</ph> to your <ph id=\"ph2\">`IXmlSerializable`</ph> types.","pos":[11727,11838],"source":" Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types."},{"pos":[11848,11878],"content":"IXmlSerializable Content Types","linkify":"IXmlSerializable Content Types","nodes":[{"content":"IXmlSerializable Content Types","pos":[0,30]}]},{"content":"When serializing a data member of a type that implements <ph id=\"ph1\">`IXmlSerializable`</ph> and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> method.","pos":[11882,12157],"source":"When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A&gt;</ph> implementation can write any XML, including adding attributes to the wrapper element.","pos":[12158,12308],"source":" The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element."},{"content":"After <ph id=\"ph1\">`WriteXml`</ph> is done, the serializer closes the element.","pos":[12309,12369],"source":" After `WriteXml` is done, the serializer closes the element."},{"content":"When deserializing a data member of a type that implements <ph id=\"ph1\">`IXmlSerializable`</ph> and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A&gt;</ph> method.","pos":[12376,12675],"source":"When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method."},{"content":"The method must read the entire element, including the start and end tags.","pos":[12676,12750]},{"content":"Make sure your <ph id=\"ph1\">`ReadXml`</ph> code handles the case where the element is empty.","pos":[12751,12825],"source":" Make sure your `ReadXml` code handles the case where the element is empty."},{"content":"Additionally, your <ph id=\"ph1\">`ReadXml`</ph> implementation should not rely on the wrapper element being named a particular way.","pos":[12826,12938],"source":" Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way."},{"content":"The name is chosen by the serializer can vary.","pos":[12939,12985]},{"content":"It is permitted to assign <ph id=\"ph1\">`IXmlSerializable`</ph> content types polymorphically, for example, to data members of type <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph>.","pos":[12992,13126],"source":"It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>."},{"content":"It is also permitted for the type instances to be null.","pos":[13127,13182]},{"content":"Finally, it is possible to use <ph id=\"ph1\">`IXmlSerializable`</ph> types with object graph preservation enabled and with the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.","pos":[13183,13353],"source":" Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>."},{"content":"All these features require the WCF serializer to attach certain attributes into the wrapper element (\"nil\" and \"type\" in the XML Schema Instance namespace and \"Id\", \"Ref\", \"Type\" and \"Assembly\" in a WCF-specific namespace).","pos":[13354,13577]},{"pos":[13588,13634],"content":"Attributes to Ignore when Implementing ReadXml","linkify":"Attributes to Ignore when Implementing ReadXml","nodes":[{"content":"Attributes to Ignore when Implementing ReadXml","pos":[0,46]}]},{"content":"Before passing control to your <ph id=\"ph1\">`ReadXml`</ph> code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.","pos":[13638,13783],"source":"Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them."},{"content":"For example, if \"nil\" is <ph id=\"ph1\">`true`</ph>, a null value is deserialized and <ph id=\"ph2\">`ReadXml`</ph> is not called.","pos":[13784,13874],"source":" For example, if \"nil\" is `true`, a null value is deserialized and `ReadXml` is not called."},{"content":"If polymorphism is detected, the contents of the element are deserialized as if it was a different type.","pos":[13875,13979]},{"content":"The polymorphically assigned type’s implementation of <ph id=\"ph1\">`ReadXml`</ph> is called.","pos":[13980,14054],"source":" The polymorphically assigned type’s implementation of `ReadXml` is called."},{"content":"In any case, a <ph id=\"ph1\">`ReadXml`</ph> implementation should ignore these special attributes because they are handled by the deserializer.","pos":[14055,14179],"source":" In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer."},{"pos":[14189,14245],"content":"Schema Considerations for IXmlSerializable Content Types","linkify":"Schema Considerations for IXmlSerializable Content Types","nodes":[{"content":"Schema Considerations for IXmlSerializable Content Types","pos":[0,56]}]},{"content":"When exporting schema an <ph id=\"ph1\">`IXmlSerializable`</ph> content type, the schema provider method is called.","pos":[14249,14344],"source":"When exporting schema an `IXmlSerializable` content type, the schema provider method is called."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> is passed to the schema provider method.","pos":[14345,14426],"source":" An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method."},{"content":"The method can add any valid schema to the schema set.","pos":[14427,14481]},{"content":"The schema set contains the schema that is already known at the time when schema export occurs.","pos":[14482,14577]},{"content":"When the schema provider method must add an item to the schema set, it must determine if an <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchema&gt;</ph> with the appropriate namespace already exists in the set.","pos":[14578,14762],"source":" When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set."},{"content":"If it does, the schema provider method must add the new item to the existing <ph id=\"ph1\">`XmlSchema`</ph>.","pos":[14763,14852],"source":" If it does, the schema provider method must add the new item to the existing `XmlSchema`."},{"content":"Otherwise, it must create a new <ph id=\"ph1\">`XmlSchema`</ph> instance.","pos":[14853,14906],"source":" Otherwise, it must create a new `XmlSchema` instance."},{"content":"This is important if arrays of <ph id=\"ph1\">`IXmlSerializable`</ph> types are being used.","pos":[14907,14978],"source":" This is important if arrays of `IXmlSerializable` types are being used."},{"content":"For example, if you have an <ph id=\"ph1\">`IXmlSerializable`</ph> type that gets exported as type \"A\" in namespace \"B\", it is possible that by the time the schema provider method is called the schema set already contains the schema for \"B\" to hold the \"ArrayOfA\" type.","pos":[14979,15228],"source":" For example, if you have an `IXmlSerializable` type that gets exported as type \"A\" in namespace \"B\", it is possible that by the time the schema provider method is called the schema set already contains the schema for \"B\" to hold the \"ArrayOfA\" type."},{"content":"In addition to adding types to the <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph>, the schema provider method for content types must return a non-null value.","pos":[15235,15383],"source":"In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value."},{"content":"It can return an <ph id=\"ph1\">&lt;xref:System.Xml.XmlQualifiedName&gt;</ph> that specifies the name of the schema type to use for the given <ph id=\"ph2\">`IXmlSerializable`</ph> type.","pos":[15384,15524],"source":" It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type."},{"content":"This qualified name also serves as the data contract name and namespace for the type.","pos":[15525,15610]},{"content":"It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.","pos":[15611,15734]},{"content":"However, it is expected that by the time all related types are exported (the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A&gt;</ph> method is called for all relevant types on the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter&gt;</ph> and the <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A&gt;</ph> property is accessed), the type exists in the schema set.","pos":[15735,16125],"source":" However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set."},{"content":"Accessing the <ph id=\"ph1\">`Schemas`</ph> property before all relevant <ph id=\"ph2\">`Export`</ph> calls have been made can result in an <ph id=\"ph3\">&lt;xref:System.Xml.Schema.XmlSchemaException&gt;</ph>.","pos":[16126,16270],"source":" Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>."},{"content":"For more information about the export process, see <bpt id=\"p1\">[</bpt>Exporting Schemas from Classes<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)</ept>.","pos":[16271,16437],"source":" For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)."},{"content":"The schema provider method can also return the <ph id=\"ph1\">&lt;xref:System.Xml.Schema.XmlSchemaType&gt;</ph> to use.","pos":[16444,16537],"source":"The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use."},{"content":"The type may or may not be anonymous.","pos":[16538,16575]},{"content":"If it is anonymous, the schema for the <ph id=\"ph1\">`IXmlSerializable`</ph> type is exported as an anonymous type every time the <ph id=\"ph2\">`IXmlSerializable`</ph> type is used as a data member.","pos":[16576,16736],"source":" If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member."},{"content":"The <ph id=\"ph1\">`IXmlSerializable`</ph> type still has a data contract name and namespace.","pos":[16737,16810],"source":" The `IXmlSerializable` type still has a data contract name and namespace."},{"content":"(This is determined as described in <bpt id=\"p1\">[</bpt>Data Contract Names<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-names.md)</ept> except that the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the <ph id=\"ph2\">`XmlSchemaSet`</ph>.","pos":[16811,17137],"source":" (This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`."},{"content":"This case is equivalent to returning the <ph id=\"ph1\">`XmlQualifiedName`</ph> of the type.","pos":[17138,17210],"source":" This case is equivalent to returning the `XmlQualifiedName` of the type."},{"content":"Additionally, a global element declaration is exported for the type.","pos":[17217,17285]},{"content":"If the type does not have the <ph id=\"ph1\">&lt;xref:System.Xml.Serialization.XmlRootAttribute&gt;</ph> attribute applied to it, the element has the same name and namespace as the data contract, and its \"nillable\" property is true.","pos":[17286,17492],"source":" If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its \"nillable\" property is true."},{"content":"The only exception to this is the schema namespace (\"<ph id=\"ph1\">http://www.w3.org/2001/XMLSchema</ph>\") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.","pos":[17493,17760],"source":" The only exception to this is the schema namespace (\"http://www.w3.org/2001/XMLSchema\") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace."},{"content":"If the type has the <ph id=\"ph1\">`XmlRootAttribute`</ph> attribute applied to it, the global element declaration is exported using the following: <ph id=\"ph2\">&lt;xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A&gt;</ph> properties.","pos":[17761,18094],"source":" If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties."},{"content":"The defaults with <ph id=\"ph1\">`XmlRootAttribute`</ph> applied are the data contract name, a blank namespace and \"nillable\" being true.","pos":[18095,18212],"source":" The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and \"nillable\" being true."},{"content":"The same global element declaration rules apply to legacy dataset types.","pos":[18219,18291]},{"content":"Note that the <ph id=\"ph1\">`XmlRootAttribute`</ph> cannot override global element declarations added through custom code, either added to the <ph id=\"ph2\">`XmlSchemaSet`</ph> using the schema provider method or through <ph id=\"ph3\">`GetSchema`</ph> for legacy dataset types.","pos":[18292,18512],"source":" Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types."},{"pos":[18522,18552],"content":"IXmlSerializable Element Types","linkify":"IXmlSerializable Element Types","nodes":[{"content":"IXmlSerializable Element Types","pos":[0,30]}]},{"pos":[18556,18687],"content":"<ph id=\"ph1\">`IXmlSerializable`</ph> element types have either the <ph id=\"ph2\">`IsAny`</ph> property set to <ph id=\"ph3\">`true`</ph> or have their schema provider method return <ph id=\"ph4\">`null`</ph>.","source":"`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`."},{"content":"Serializing and deserializing an element type is very similar to serializing and deserializing a content type.","pos":[18694,18804]},{"content":"However, there are some important differences:","pos":[18805,18851]},{"content":"The <ph id=\"ph1\">`WriteXml`</ph> implementation is expected to write exactly one element (which could of course contain multiple child elements).","pos":[18861,18988],"source":"The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements)."},{"content":"It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.","pos":[18989,19100]},{"content":"The element may be empty.","pos":[19101,19126]},{"content":"The <ph id=\"ph1\">`ReadXml`</ph> implementation should not read the wrapper element.","pos":[19136,19201],"source":"The `ReadXml` implementation should not read the wrapper element."},{"content":"It is expected to read the one element that <ph id=\"ph1\">`WriteXml`</ph> produces.","pos":[19202,19266],"source":" It is expected to read the one element that `WriteXml` produces."},{"content":"When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling <ph id=\"ph1\">`WriteXml`</ph>, as with content types.","pos":[19276,19461],"source":"When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types."},{"content":"However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that <ph id=\"ph1\">`WriteXml`</ph> writes, unless a root name and namespace were explicitly specified when constructing the serializer in the <ph id=\"ph2\">`DataContractSerializer`</ph> or <ph id=\"ph3\">`NetDataContractSerializer`</ph> constructors.","pos":[19462,19798],"source":" However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Serialization and Deserialization<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)</ept>.","pos":[19799,19946],"source":" For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md)."},{"content":"When serializing an element type at the top level without specifying the root name and namespace at construction time, <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A&gt;</ph> essentially does nothing and <ph id=\"ph3\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A&gt;</ph> calls <ph id=\"ph4\">`WriteXml`</ph>.","pos":[19956,20353],"source":"When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`."},{"content":"In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.","pos":[20354,20450]},{"content":"Also, object graph preservation cannot enabled and the <ph id=\"ph1\">`NetDataContractSerializer`</ph> cannot be used.","pos":[20451,20549],"source":" Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used."},{"content":"When deserializing an element type at the top level without specifying the root name and namespace at construction time, <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A&gt;</ph> returns <ph id=\"ph2\">`true`</ph> if it can find the start of any element.","pos":[20559,20808],"source":"When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> with the <ph id=\"ph2\">`verifyObjectName`</ph> parameter set to <ph id=\"ph3\">`true`</ph> behaves in the same way as <ph id=\"ph4\">`IsStartObject`</ph> before actually reading the object.","pos":[20809,21009],"source":"<xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object."},{"content":"<ph id=\"ph1\">`ReadObject`</ph> then passes control to <ph id=\"ph2\">`ReadXml`</ph> method.","pos":[21010,21063],"source":"`ReadObject` then passes control to `ReadXml` method."},{"content":"The schema exported for element types is the same as for the <ph id=\"ph1\">`XmlElement`</ph> type as described in an earlier section, except that the schema provider method can add any additional schema to the <ph id=\"ph2\">&lt;xref:System.Xml.Schema.XmlSchemaSet&gt;</ph> as with content types.","pos":[21070,21321],"source":"The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types."},{"content":"Using the <ph id=\"ph1\">`XmlRootAttribute`</ph> attribute with element types is not allowed, and global element declarations are never emitted for these types.","pos":[21322,21462],"source":" Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types."},{"pos":[21472,21506],"content":"Differences from the XmlSerializer","linkify":"Differences from the XmlSerializer","nodes":[{"content":"Differences from the XmlSerializer","pos":[0,34]}]},{"content":"The <ph id=\"ph1\">`IXmlSerializable`</ph> interface and the <ph id=\"ph2\">`XmlSchemaProviderAttribute`</ph> and <ph id=\"ph3\">`XmlRootAttribute`</ph> attributes are also understood by the <ph id=\"ph4\">&lt;xref:System.Xml.Serialization.XmlSerializer&gt;</ph> .","pos":[21510,21688],"source":"The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> ."},{"content":"However, there are some differences in how these are treated in the data contract model.","pos":[21689,21777]},{"content":"The important differences are summarized in the following:","pos":[21778,21836]},{"pos":[21846,21996],"content":"The schema provider method must be public to be usable in the <ph id=\"ph1\">`XmlSerializer`</ph>, but does not have to be public to be usable in the data contract model.","source":"The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model."},{"pos":[22006,22124],"content":"The schema provider method is called when <ph id=\"ph1\">`IsAny`</ph> is true in the data contract model but not with the <ph id=\"ph2\">`XmlSerializer`</ph>.","source":"The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`."},{"content":"When the <ph id=\"ph1\">`XmlRootAttribute`</ph> attribute is not present for content or legacy dataset types, the <ph id=\"ph2\">`XmlSerializer`</ph> exports a global element declaration in the blank namespace.","pos":[22134,22304],"source":"When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace."},{"content":"In the data contract model, the namespace used is normally the data contract namespace as described earlier.","pos":[22305,22413]},{"content":"Be aware of these differences when creating types that are used with both serialization technologies.","pos":[22420,22521]},{"pos":[22531,22564],"content":"Importing IXmlSerializable Schema","linkify":"Importing IXmlSerializable Schema","nodes":[{"content":"Importing IXmlSerializable Schema","pos":[0,33]}]},{"pos":[22568,22663],"content":"When importing a schema generated from <ph id=\"ph1\">`IXmlSerializable`</ph> types, there are a few possibilities:","source":"When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:"},{"content":"The generated schema may be a valid data contract schema as described in <bpt id=\"p1\">[</bpt>Data Contract Schema Reference<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</ept>.","pos":[22673,22861],"source":"The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)."},{"content":"In this case, schema can be imported as usual and regular data contract types are generated.","pos":[22862,22954]},{"content":"The generated schema may not be a valid data contract schema.","pos":[22964,23025]},{"content":"For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.","pos":[23026,23167]},{"content":"In this case, you can import the schema as <ph id=\"ph1\">`IXmlSerializable`</ph> types.","pos":[23168,23236],"source":" In this case, you can import the schema as `IXmlSerializable` types."},{"content":"This import mode is not on by default but can easily be enabled – for example, with the <ph id=\"ph1\">`/importXmlTypes`</ph> command-line switch to the <bpt id=\"p1\">[</bpt>ServiceModel Metadata Utility Tool (Svcutil.exe)<ept id=\"p1\">](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)</ept>.","pos":[23237,23503],"source":" This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)."},{"content":"This is described in detail in the <bpt id=\"p1\">[</bpt>Importing Schema to Generate Classes<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)</ept>.","pos":[23504,23666],"source":" This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)."},{"content":"Note that you must work directly with the XML for your type instances.","pos":[23667,23737]},{"content":"You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the <ph id=\"ph1\">`XmlSerializer`</ph>.","pos":[23738,23886],"source":" You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`."},{"content":"You may want to reuse your existing <ph id=\"ph1\">`IXmlSerializable`</ph> types in the proxy instead of generating new ones.","pos":[23896,24001],"source":"You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones."},{"content":"In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.","pos":[24002,24145]},{"content":"This corresponds to using the <ph id=\"ph1\">`/reference`</ph> switch on svcutil.exe, which specifies the assembly that contains the types to reuse.","pos":[24146,24274],"source":" This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse."},{"pos":[24283,24327],"content":"Representing Arbitrary XML in Data Contracts","linkify":"Representing Arbitrary XML in Data Contracts","nodes":[{"content":"Representing Arbitrary XML in Data Contracts","pos":[0,44]}]},{"content":"The <ph id=\"ph1\">`XmlElement`</ph>, Array of <ph id=\"ph2\">`XmlNode`</ph> and <ph id=\"ph3\">`IXmlSerializable`</ph> types allow you to inject arbitrary XML into the data contract model.","pos":[24331,24460],"source":"The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model."},{"content":"The <ph id=\"ph1\">`DataContractSerializer`</ph> and <ph id=\"ph2\">`NetDataContractSerializer`</ph> pass this XML content on to the XML writer in use, without interfering in the process.","pos":[24461,24608],"source":" The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process."},{"content":"However, the XML writers may enforce certain restrictions on the XML that they write.","pos":[24609,24694]},{"content":"Specifically, here are some important examples:","pos":[24695,24742]},{"content":"The XML writers do not typically allow an XML document declaration (for example, <ph id=\"ph1\">\\&lt;</ph>?xml version=’1.0’ ?&gt;) in the middle of writing another document.","pos":[24752,24900],"source":"The XML writers do not typically allow an XML document declaration (for example, \\<?xml version=’1.0’ ?>) in the middle of writing another document."},{"content":"You cannot take a full XML document and serialize it as an <ph id=\"ph1\">`Array`</ph> of <ph id=\"ph2\">`XmlNode`</ph> data member.","pos":[24901,24993],"source":" You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member."},{"content":"To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.","pos":[24994,25108]},{"content":"All of the XML writers supplied with WCF reject XML processing instructions (<ph id=\"ph1\">\\&lt;</ph>?","pos":[25118,25198],"source":"All of the XML writers supplied with WCF reject XML processing instructions (\\<?"},{"content":"…","pos":[25199,25200]},{"content":"?&gt;) and document type definitions (<ph id=\"ph1\">\\&lt;</ph>!","pos":[25201,25239],"source":" ?>) and document type definitions (\\<!"},{"content":"…","pos":[25240,25241]},{"content":"&gt;), because they are not allowed in SOAP messages.","pos":[25242,25292],"source":" >), because they are not allowed in SOAP messages."},{"content":"Again, you can use your own encoding mechanism to get around this restriction.","pos":[25293,25371]},{"content":"If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.","pos":[25372,25492]},{"content":"When implementing <ph id=\"ph1\">`WriteXml`</ph>, avoid calling <ph id=\"ph2\">&lt;xref:System.Xml.XmlWriter.WriteRaw%2A&gt;</ph> method on the XML writer.","pos":[25502,25611],"source":"When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer."},{"content":"WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use <ph id=\"ph1\">`WriteRaw`</ph> such that the result is usable in any encoding.","pos":[25612,25768],"source":" WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding."},{"pos":[25778,25984],"content":"When implementing <ph id=\"ph1\">`WriteXml`</ph>, avoid using the <ph id=\"ph2\">&lt;xref:System.Xml.XmlWriter.WriteEntityRef%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Xml.XmlWriter.WriteNmToken%2A&gt;</ph> methods that are unsupported on the XML writers supplied with WCF.","source":"When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF."},{"pos":[25993,26035],"content":"Using DataSet, Typed DataSet and DataTable","linkify":"Using DataSet, Typed DataSet and DataTable","nodes":[{"content":"Using DataSet, Typed DataSet and DataTable","pos":[0,42]}]},{"content":"Using these types is fully supported in the data contract model.","pos":[26039,26103]},{"content":"When using these types, consider the following points:","pos":[26104,26158]},{"content":"The schema for these types (especially <ph id=\"ph1\">&lt;xref:System.Data.DataSet&gt;</ph> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.","pos":[26168,26382],"source":"The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms."},{"content":"Additionally, using the <ph id=\"ph1\">`DataSet`</ph> type may have performance implications.","pos":[26383,26456],"source":" Additionally, using the `DataSet` type may have performance implications."},{"content":"Finally, it may make it more difficult for you to version your application in the future.","pos":[26457,26546]},{"content":"Consider using explicitly defined data contract types instead of <ph id=\"ph1\">`DataSet`</ph> types in your contracts.","pos":[26547,26646],"source":" Consider using explicitly defined data contract types instead of `DataSet` types in your contracts."},{"content":"When importing <ph id=\"ph1\">`DataSet`</ph> or <ph id=\"ph2\">`DataTable`</ph> schema, it is important to reference these types.","pos":[26656,26745],"source":"When importing `DataSet` or `DataTable` schema, it is important to reference these types."},{"content":"With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the <ph id=\"ph1\">`/reference`</ph> switch.","pos":[26746,26883],"source":" With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch."},{"content":"If importing typed dataset schema, you must reference the typed dataset’s type.","pos":[26884,26963]},{"content":"With Svcutil.exe, pass the location of the typed dataset’s assembly to the <ph id=\"ph1\">`/reference`</ph> switch.","pos":[26964,27059],"source":" With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch."},{"content":"For more information about referencing types, see the <bpt id=\"p1\">[</bpt>Importing Schema to Generate Classes<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)</ept>.","pos":[27060,27241],"source":" For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md)."},{"content":"Support for typed DataSets in the data contract model is limited.","pos":[27248,27313]},{"content":"Typed DataSets can be serialized and deserialized and can export their schema.","pos":[27314,27392]},{"content":"However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.","pos":[27393,27532]},{"content":"You can point to an existing typed DataSet by using the <ph id=\"ph1\">`/r`</ph> switch on Svcutil.exe.","pos":[27533,27616],"source":" You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe."},{"content":"If you attempt to use a Svcutil.exe without the <ph id=\"ph1\">`/r`</ph> switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.","pos":[27617,27785],"source":" If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected."},{"content":"If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the <ph id=\"ph1\">`/d`</ph> switch on the service), compile the types, and then point to them using the <ph id=\"ph2\">`/r`</ph> switch on Svcutil.exe.","pos":[27786,28083],"source":" If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe."},{"pos":[28092,28100],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[28216,28310],"content":"<bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>","source":"[Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)"},{"pos":[28313,28461],"content":"<bpt id=\"p1\">[</bpt>Types Supported by the Data Contract Serializer<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept>","source":"[Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)"}]}