{"content":"---\ntitle: C# structs | A tour of the C# language\ndescription: Learn the basics of C# value types, called structs\nkeywords: .NET, C#, struct, value type\nauthor: BillWagner\nms.author: wiwagn\nms.date: 08/10/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 88a74571-f741-4a31-a2b5-1ccf165535b8\n---\n\n# Structs\n\nLike classes, ***structs*** are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation. A variable of a struct type directly stores the data of the struct, whereas a variable of a class type stores a reference to a dynamically allocated object. Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <xref:System.ValueType>, which in turn implicitly inherits from `object`.\n\nStructs are particularly useful for small data structures that have value semantics. Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs. The use of structs rather than classes for small data structures can make a large difference in the number of memory allocations an application performs. For example, the following program creates and initializes an array of 100 points. With `Point` implemented as a class, 101 separate objects are instantiated—one for the array and one each for the 100 elements.\n\n[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]\n\nAn alternative is to make Point a struct.\n\n[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]\n\nNow, only one object is instantiated—the one for the array—and the `Point` instances are stored in-line in the array.\n\nStruct constructors are invoked with the new operator, but that does not imply that memory is being allocated. Instead of dynamically allocating an object and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.\n\nWith classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other. For example, the output produced by the following code fragment depends on whether Point is a class or a struct.\n\n[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]\n\nIf `Point` is a class, the output is 20 because a and b reference the same object. If Point is a struct, the output is 10 because the assignment of `a` to `b` creates a copy of the value, and this copy is unaffected by the subsequent assignment to `a.x`.\n\nThe previous example highlights two of the limitations of structs. First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types. Second, except for `ref` and `out` parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.\n\n>[!div class=\"step-by-step\"]\n[Previous](classes-and-objects.md)\n[Next](arrays.md)\n","nodes":[{"pos":[11,49],"content":"C# structs | A tour of the C# language","needQuote":true,"needEscape":true,"nodes":[{"content":"C# structs | A tour of the C# language","pos":[0,38]}]},{"pos":[63,113],"content":"Learn the basics of C# value types, called structs","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn the basics of C# value types, called structs","pos":[0,50]}]},{"pos":[124,152],"content":".NET, C#, struct, value type","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, C#, struct, value type","pos":[0,28]}]},{"pos":[347,354],"content":"Structs","linkify":"Structs","nodes":[{"content":"Structs","pos":[0,7]}]},{"content":"Like classes, <bpt id=\"p1\">***</bpt>structs<ept id=\"p1\">***</ept> are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation.","pos":[356,535],"source":"Like classes, ***structs*** are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation."},{"content":"A variable of a struct type directly stores the data of the struct, whereas a variable of a class type stores a reference to a dynamically allocated object.","pos":[536,692]},{"content":"Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph>, which in turn implicitly inherits from <ph id=\"ph2\">`object`</ph>.","pos":[693,872],"source":" Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <xref:System.ValueType>, which in turn implicitly inherits from `object`."},{"content":"Structs are particularly useful for small data structures that have value semantics.","pos":[874,958]},{"content":"Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs.","pos":[959,1075]},{"content":"The use of structs rather than classes for small data structures can make a large difference in the number of memory allocations an application performs.","pos":[1076,1229]},{"content":"For example, the following program creates and initializes an array of 100 points.","pos":[1230,1312]},{"content":"With <ph id=\"ph1\">`Point`</ph> implemented as a class, 101 separate objects are instantiated—one for the array and one each for the 100 elements.","pos":[1313,1440],"source":" With `Point` implemented as a class, 101 separate objects are instantiated—one for the array and one each for the 100 elements."},{"pos":[1442,1536],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PointClassUse<ept id=\"p2\">](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]"},{"content":"An alternative is to make Point a struct.","pos":[1538,1579]},{"pos":[1581,1671],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PointStruct<ept id=\"p2\">](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]"},{"pos":[1673,1790],"content":"Now, only one object is instantiated—the one for the array—and the <ph id=\"ph1\">`Point`</ph> instances are stored in-line in the array.","source":"Now, only one object is instantiated—the one for the array—and the `Point` instances are stored in-line in the array."},{"content":"Struct constructors are invoked with the new operator, but that does not imply that memory is being allocated.","pos":[1792,1902]},{"content":"Instead of dynamically allocating an object and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.","pos":[1903,2133]},{"content":"With classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable.","pos":[2135,2314]},{"content":"With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.","pos":[2315,2446]},{"content":"For example, the output produced by the following code fragment depends on whether Point is a class or a struct.","pos":[2447,2559]},{"pos":[2561,2651],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>PointUse<ept id=\"p2\">](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]"},{"content":"If <ph id=\"ph1\">`Point`</ph> is a class, the output is 20 because a and b reference the same object.","pos":[2653,2735],"source":"If `Point` is a class, the output is 20 because a and b reference the same object."},{"content":"If Point is a struct, the output is 10 because the assignment of <ph id=\"ph1\">`a`</ph> to <ph id=\"ph2\">`b`</ph> creates a copy of the value, and this copy is unaffected by the subsequent assignment to <ph id=\"ph3\">`a.x`</ph>.","pos":[2736,2907],"source":" If Point is a struct, the output is 10 because the assignment of `a` to `b` creates a copy of the value, and this copy is unaffected by the subsequent assignment to `a.x`."},{"content":"The previous example highlights two of the limitations of structs.","pos":[2909,2975]},{"content":"First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types.","pos":[2976,3173]},{"content":"Second, except for <ph id=\"ph1\">`ref`</ph> and <ph id=\"ph2\">`out`</ph> parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.","pos":[3174,3327],"source":" Second, except for `ref` and `out` parameters, it is not possible to create references to structs, which rules out their usage in a number of situations."},{"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](classes-and-objects.md)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\">[</bpt>Next<ept id=\"p2\">](arrays.md)</ept>","pos":[3358,3410],"source":"[Previous](classes-and-objects.md)\n[Next](arrays.md)"}]}