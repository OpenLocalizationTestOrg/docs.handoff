{"content":"---\ntitle: \"How to: List All Nodes in a Tree (Visual Basic)\"\nms.date: 07/20/2015\nms.assetid: e19289c4-26d1-435b-b0db-fb8bc856b753\n---\n# How to: List All Nodes in a Tree (Visual Basic)\nSometimes it is helpful to list all nodes in a tree. This can be useful when learning exactly how a method or property affects the tree. One approach to listing all nodes in a textual form is to generate an XPath expression that exactly and specifically identifies any node in the tree.  \n  \n It is not particularly helpful to execute XPath expressions using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]. XPath expressions have poorer performance than [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries, and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries are much more powerful. However, as a way to identify nodes in the XML tree, XPath works well.  \n  \n## Example  \n This example shows an function named `GetXPath` that generates a specific XPath expression for any node in the XML tree. It generates appropriate XPath expressions even when nodes are in a namespace. The XPath expressions are generated by using namespace prefixes.  \n  \n The example then creates a small XML tree that contains an example of several types of nodes. It then iterates through the descendant nodes and prints the XPath expression for each node.  \n  \n You will notice that the XML declaration is not a node in the tree.  \n  \n The following is an XML file that contains several types of nodes:  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>  \n<?target data?>  \n<Root AttName=\"An Attribute\" xmlns:aw=\"http://www.adventure-works.com\">  \n  <!--This is a comment-->  \n  <Child>Text</Child>  \n  <Child>Other Text</Child>  \n  <ChildWithMixedContent>text<b>BoldText</b>otherText</ChildWithMixedContent>  \n  <aw:ElementInNamespace>  \n    <aw:ChildInNamespace />  \n  </aw:ElementInNamespace>  \n</Root>  \n```  \n  \n The following is the list of nodes in the above XML tree, expressed as XPath expressions:  \n  \n```  \n/processing-instruction()  \n/Root  \n/Root/@AttName  \n/Root/@xmlns:aw  \n/Root/comment()  \n/Root/Child[1]  \n/Root/Child[1]/text()  \n/Root/Child[2]  \n/Root/Child[2]/text()  \n/Root/ChildWithMixedContent  \n/Root/ChildWithMixedContent/text()[1]  \n/Root/ChildWithMixedContent/b  \n/Root/ChildWithMixedContent/b/text()  \n/Root/ChildWithMixedContent/text()[2]  \n/Root/aw:ElementInNamespace  \n/Root/aw:ElementInNamespace/aw:ChildInNamespace  \n```  \n  \n```vb  \nModule Module1  \n<System.Runtime.CompilerServices.Extension()> _  \n    Private Function StrCat(Of T)(ByVal source As IEnumerable(Of T), _  \n                                  ByVal separator As String) As String  \n        Return _  \n        source.Aggregate(New StringBuilder(), _  \n            Function(sb, i) sb _  \n                .Append(i.ToString()) _  \n                .Append(separator), _  \n                Function(s) s.ToString())  \n    End Function  \n  \n    <System.Runtime.CompilerServices.Extension()> _  \n    Public Function GetXPath(ByVal xobj As XObject) As String  \n        Dim retStr As String  \n        If xobj.Parent Is Nothing Then  \n            Dim doc As XDocument = TryCast(xobj, XDocument)  \n            If doc IsNot Nothing Then  \n                Return \".\"  \n            End If  \n            Dim el As XElement = TryCast(xobj, XElement)  \n            If el IsNot Nothing Then  \n                Return (\"/\" & NameWithPredicate(el))  \n            End If  \n  \n            ' The XPath data model does not include white space text nodes  \n            ' that are children of a document, so this method returns null.  \n            Dim xt As XText = TryCast(xobj, XText)  \n            If xt IsNot Nothing Then  \n                Return Nothing  \n            End If  \n            Dim com As XComment = TryCast(xobj, XComment)  \n            If com IsNot Nothing Then  \n                If com.Document().Nodes().OfType(Of XComment)().Count() <> 1 Then  \n                    Return \"/comment()[\" & (com.NodesBeforeSelf().OfType _  \n                        (Of XComment)().Count() + 1) & \"]\"  \n                Else  \n                    Return \"/comment()\"  \n                End If  \n            End If  \n  \n            Dim pi As XProcessingInstruction = TryCast(xobj, XProcessingInstruction)  \n            If pi IsNot Nothing Then  \n                If pi.Document.Nodes().OfType(Of XProcessingInstruction)(). _  \n                        Count() <> 1 Then  \n                    Return \"/processing-instruction()[\" & _  \n                        (pi.NodesBeforeSelf().OfType(Of XProcessingInstruction)() _  \n                        .Count() + 1) & \"]\"  \n                Else  \n                    Return \"/processing-instruction()\"  \n                End If  \n            End If  \n        Else  \n            Dim el As XElement = TryCast(xobj, XElement)  \n            If el IsNot Nothing Then  \n                Return \"/\" & el.Ancestors().InDocumentOrder(). _  \n                    Select(Function(e) NameWithPredicate(e)) _  \n                    .StrCat(\"/\") & NameWithPredicate(el)  \n            End If  \n  \n            Dim at As XAttribute = TryCast(xobj, XAttribute)  \n            If at IsNot Nothing Then  \n                Return \"/\" & at.Parent().AncestorsAndSelf().InDocumentOrder(). _  \n                    Select(Function(e) NameWithPredicate(e)).StrCat(\"/\") & _  \n                    \"@\" & GetQName(at)  \n            End If  \n  \n            Dim com As XComment = TryCast(xobj, XComment)  \n            If com IsNot Nothing Then  \n                retStr = \"/\" & com.Parent.AncestorsAndSelf().InDocumentOrder(). _  \n                Select(Function(e) NameWithPredicate(e)).StrCat(\"/\") & \"comment()\"  \n                If com.Parent().Nodes().OfType(Of XComment)().Count() <> 1 Then  \n                    retStr &= \"[\" & (com.NodesBeforeSelf().OfType(Of XComment)().Count() + 1) & \"]\"  \n                End If  \n                Return retStr  \n            End If  \n  \n            Dim cd As XCData = TryCast(xobj, XCData)  \n            If cd IsNot Nothing Then  \n                retStr = \"/\" & cd.Parent.AncestorsAndSelf().InDocumentOrder(). _  \n                    Select(Function(e) NameWithPredicate(e)).StrCat(\"/\") & \"text()\"  \n                If cd.Parent.Nodes().OfType(Of XText)().Count() <> 1 Then  \n                    retStr &= \"[\" & (cd.NodesBeforeSelf().OfType(Of XText)(). _  \n                        Count() + 1) & \"]\"  \n                End If  \n                Return retStr  \n            End If  \n  \n            Dim tx As XText = TryCast(xobj, XText)  \n            If tx IsNot Nothing Then  \n                retStr = \"/\" & tx.Parent.AncestorsAndSelf().InDocumentOrder(). _  \n                    Select(Function(e) NameWithPredicate(e)).StrCat(\"/\") & \"text()\"  \n                If tx.Parent.Nodes().OfType(Of XText)().Count() <> 1 Then  \n                    retStr &= \"[\" & (tx.NodesBeforeSelf().OfType(Of XText)(). _  \n                        Count() + 1) & \"]\"  \n                End If  \n                Return retStr  \n            End If  \n  \n            Dim pi As XProcessingInstruction = TryCast(xobj, XProcessingInstruction)  \n            If pi IsNot Nothing Then  \n                retStr = \"/\" & pi.Parent.AncestorsAndSelf().InDocumentOrder(). _  \n                    Select(Function(e) NameWithPredicate(e)). _  \n                    StrCat(\"/\") & \"processing-instruction()\"  \n                If pi.Parent.Nodes().OfType(Of XProcessingInstruction)().Count() <> 1 Then  \n                    retStr &= \"[\" & (pi.NodesBeforeSelf().OfType(Of XProcessingInstruction)(). _  \n                        Count() + 1) & \"]\"  \n                End If  \n            End If  \n        End If  \n        Return Nothing  \n    End Function  \n  \n    Private Function GetQName(ByVal xe As XElement) As String  \n        Dim prefix As String = xe.GetPrefixOfNamespace(xe.Name.Namespace)  \n        If xe.Name.Namespace = XNamespace.None Or prefix Is Nothing Then  \n            Return xe.Name.LocalName.ToString()  \n        Else  \n            Return prefix + \":\" & xe.Name.LocalName.ToString()  \n        End If  \n    End Function  \n  \n    Private Function GetQName(ByVal xa As XAttribute) As String  \n        Dim prefix As String = _  \n            xa.Parent.GetPrefixOfNamespace(xa.Name.Namespace)  \n        If xa.Name.Namespace = XNamespace.None Or prefix Is Nothing Then  \n            Return xa.Name.ToString()  \n        Else  \n            Return prefix + \":\" & xa.Name.LocalName  \n        End If  \n    End Function  \n  \n    Public Function NameWithPredicate(ByVal el As XElement) As String  \n        If el.Parent IsNot Nothing AndAlso el.Parent.Elements(el.Name).Count() <> 1 Then  \n            Return GetQName(el) + \"[\" & _  \n                (el.ElementsBeforeSelf(el.Name).Count() + 1) & \"]\"  \n        Else  \n            Return GetQName(el)  \n        End If  \n    End Function  \n  \n    Sub Main()  \n        Dim aw As XNamespace = \"http://www.adventure-works.com\"  \n        Dim doc As XDocument = _  \n            <?xml version='1.0' encoding=\"utf-8\" standalone='yes'?>  \n            <?target data?>  \n            <Root AttName='An Attribute' xmlns:aw='http://www.adventure-works.com'>  \n                <!--This is a comment-->  \n                <Child>Text</Child>  \n                <Child>Other Text</Child>  \n                <ChildWithMixedContent>text<b>BoldText</b>otherText</ChildWithMixedContent>  \n                <aw:ElementInNamespace>  \n                    <aw:ChildInNamespace/>  \n                </aw:ElementInNamespace>  \n            </Root>  \n        doc.Save(\"Test.xml\")  \n        Console.WriteLine(File.ReadAllText(\"Test.xml\"))  \n        Console.WriteLine(\"------\")  \n        For Each obj As XObject In doc.DescendantNodes()  \n            Console.WriteLine(obj.GetXPath())  \n            Dim el As XElement = TryCast(obj, XElement)  \n            If el IsNot Nothing Then  \n                For Each at As XAttribute In el.Attributes()  \n                    Console.WriteLine(at.GetXPath())  \n                Next  \n            End If  \n        Next  \n    End Sub  \nEnd Module  \n```  \n  \n This example produces the following output:  \n  \n```xml  \n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>  \n<?target data?>  \n<Root AttName=\"An Attribute\" xmlns:aw=\"http://www.adventure-works.com\">  \n  <!--This is a comment-->  \n  <Child>Text</Child>  \n  <Child>Other Text</Child>  \n  <ChildWithMixedContent>text<b>BoldText</b>otherText</ChildWithMixedContent>  \n  <aw:ElementInNamespace>  \n    <aw:ChildInNamespace />  \n  </aw:ElementInNamespace>  \n</Root>  \n------  \n/processing-instruction()  \n/Root  \n/Root/@AttName  \n/Root/@xmlns:aw  \n/Root/comment()  \n/Root/Child[1]  \n/Root/Child[1]/text()  \n/Root/Child[2]  \n/Root/Child[2]/text()  \n/Root/ChildWithMixedContent  \n/Root/ChildWithMixedContent/text()[1]  \n/Root/ChildWithMixedContent/b  \n/Root/ChildWithMixedContent/b/text()  \n/Root/ChildWithMixedContent/text()[2]  \n/Root/aw:ElementInNamespace  \n/Root/aw:ElementInNamespace/aw:ChildInNamespace  \n```  \n  \n## See also\n\n- [Advanced Query Techniques (LINQ to XML) (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)\n","nodes":[{"pos":[4,129],"embed":true,"restype":"x-metadata","content":"title: \"How to: List All Nodes in a Tree (Visual Basic)\"\nms.date: 07/20/2015\nms.assetid: e19289c4-26d1-435b-b0db-fb8bc856b753","nodes":[{"content":"How to: List All Nodes in a Tree (Visual Basic)","nodes":[{"pos":[0,47],"content":"How to: List All Nodes in a Tree (Visual Basic)","nodes":[{"content":"How to: List All Nodes in a Tree (Visual Basic)","pos":[0,47]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[136,183],"content":"How to: List All Nodes in a Tree (Visual Basic)","linkify":"How to: List All Nodes in a Tree (Visual Basic)","nodes":[{"content":"How to: List All Nodes in a Tree (Visual Basic)","pos":[0,47]}]},{"content":"Sometimes it is helpful to list all nodes in a tree.","pos":[184,236]},{"content":"This can be useful when learning exactly how a method or property affects the tree.","pos":[237,320]},{"content":"One approach to listing all nodes in a textual form is to generate an XPath expression that exactly and specifically identifies any node in the tree.","pos":[321,470]},{"content":"It is not particularly helpful to execute XPath expressions using <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph>.","pos":[477,597],"source":"It is not particularly helpful to execute XPath expressions using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]."},{"content":"XPath expressions have poorer performance than <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> queries, and <ph id=\"ph2\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> queries are much more powerful.","pos":[598,797],"source":" XPath expressions have poorer performance than [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries, and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] queries are much more powerful."},{"content":"However, as a way to identify nodes in the XML tree, XPath works well.","pos":[798,868]},{"pos":[877,884],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example shows an function named <ph id=\"ph1\">`GetXPath`</ph> that generates a specific XPath expression for any node in the XML tree.","pos":[888,1008],"source":"This example shows an function named `GetXPath` that generates a specific XPath expression for any node in the XML tree."},{"content":"It generates appropriate XPath expressions even when nodes are in a namespace.","pos":[1009,1087]},{"content":"The XPath expressions are generated by using namespace prefixes.","pos":[1088,1152]},{"content":"The example then creates a small XML tree that contains an example of several types of nodes.","pos":[1159,1252]},{"content":"It then iterates through the descendant nodes and prints the XPath expression for each node.","pos":[1253,1345]},{"content":"You will notice that the XML declaration is not a node in the tree.","pos":[1352,1419]},{"content":"The following is an XML file that contains several types of nodes:","pos":[1426,1492]},{"content":"The following is the list of nodes in the above XML tree, expressed as XPath expressions:","pos":[1927,2016]},{"content":"This example produces the following output:","pos":[10092,10135]},{"pos":[11013,11021],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[11025,11180],"content":"<bpt id=\"p1\">[</bpt>Advanced Query Techniques (LINQ to XML) (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)</ept>","source":"[Advanced Query Techniques (LINQ to XML) (Visual Basic)](../../../../visual-basic/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)"}]}