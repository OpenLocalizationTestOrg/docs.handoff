<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-ffc129d" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">17d878cc6fad84f7e17910d055b9c809e52b1c75</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\advanced\attached-properties-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">432408f3c9b6d25a87be77ffd8e32e0450974360</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">22acd09f144f1be8eb5870f67715116c414a8aa2</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Attached Properties Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Attached Properties Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>An attached property is a concept defined by XAML.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>An attached property is intended to be used as a type of global property that is settable on any object.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>, attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> classes, and have read the <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>To follow the examples in this topic, you should also understand XAML and know how to write <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Why Use Attached Properties</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>One example is the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> property is created as an attached property because it is designed to be set on elements that are contained within a <ph id="ph2">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph>, rather than on <ph id="ph3">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> itself.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> class defines the static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field named <ph id="ph3">&lt;xref:System.Windows.Controls.DockPanel.DockProperty&gt;</ph>, and then provides the <ph id="ph4">&lt;xref:System.Windows.Controls.DockPanel.GetDock%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Windows.Controls.DockPanel.SetDock%2A&gt;</ph> methods as public accessors for the attached property.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Attached Properties in XAML</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In XAML, you set attached properties by using the syntax <bpt id="p1">*</bpt>AttachedPropertyProvider<ept id="p1">*</ept>.<bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The following is an example of how you can set <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> in XAML:</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>PropertiesOvwSupport#APBasicUsage<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Note that the usage is somewhat similar to a static property; you always reference the type <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> that owns and registers the attached property, rather than referring to any instance specified by name.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](../../../../docs/framework/wpf/controls/styling-and-templating.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Attached Property Implementation in WPF</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>, most of the attached properties that exist on <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> types that are related to UI presentation are implemented as dependency properties.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Attached properties are a XAML concept, whereas dependency properties are a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> concept.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>How Attached Properties Are Used by the Owning Type</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The type that defines the attached property typically follows one of these models:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The type that defines the attached property represents a service.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Other types set values for the attached property.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>An Example of a Parent-Defined Attached Property</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The most typical scenario where <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> defines the <ph id="ph2">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> attached property, and <ph id="ph3">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> has class-level code as part of its rendering logic (specifically, <ph id="ph4">&lt;xref:System.Windows.Controls.DockPanel.MeasureOverride%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> instance will always check to see whether any of its immediate child elements have set a value for <ph id="ph2">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If so, those values become input for the rendering logic applied to that particular child element.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Nested <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <ph id="ph2">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> processes <ph id="ph3">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> attached property is set on an element that has no <ph id="ph2">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> parent element to act upon it, no error or exception is raised.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This simply means that a global property value was set, but it has no current <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> parent that could consume the information.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Attached Properties in Code</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Attached properties in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> do not have the typical <ph id="ph2">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> "wrapper" methods for easy get/set access.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is because the attached property is not necessarily part of the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> namespace for instances where the property is set.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>However, a XAML processor must be able to set those values when XAML is parsed.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form <ph id="ph1">`Get`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> and <ph id="ph2">`Set`</ph><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These dedicated accessor methods are also useful to get or set the attached property in code.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example shows how you can set an attached property in code.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`myCheckBox`</ph> is an instance of the <ph id="ph2">&lt;xref:System.Windows.Controls.CheckBox&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>PropertiesOvwSupport#APCode<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>PropertiesOvwSupport#APCode<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Similar to the XAML case, if <ph id="ph1">`myCheckBox`</ph> had not already been added as a child element of <ph id="ph2">`myDockPanel`</ph> by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <ph id="ph3">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> parent and thus would do nothing.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Only a <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph> value set on a child element combined with the presence of a <ph id="ph2">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> parent element will cause an effective behavior in the rendered application.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>(In this case, you could set the attached property, then attach to the tree.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Or you could attach to the tree then set the attached property.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Either action order provides the same result.)</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Attached Property Metadata</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When registering the property, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Metadata for an attached property is generally no different than on a dependency property.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Specifically, your default value is reported if some process queries for the value of an attached property through the <ph id="ph1">`Get`</ph> method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>For details, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Custom Attached Properties</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>When to Create an Attached Property</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The most common scenario for this is layout.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Examples of existing layout properties are <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Yet another scenario is to receive <ph id="ph1">[!INCLUDE[vs_orcas_long](../../../../includes/vs-orcas-long-md.md)]</ph> <ph id="ph2">[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]</ph> support, such as <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window editing.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Control Authoring Overview<ept id="p1">](../../../../docs/framework/wpf/controls/control-authoring-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>As mentioned before, you should register as an attached property if you want to use property value inheritance.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>How to Create an Attached Property</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>But you do need to derive from <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> if you follow the overall <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> model of having your attached property also be a dependency property.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Define your attached property as a dependency property by declaring a <ph id="ph1">`public`</ph> <ph id="ph2">`static`</ph> <ph id="ph3">`readonly`</ph> field of type <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You define this field by using the return value of the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The field name must match the attached property name, appended with the string <ph id="ph1">`Property`</ph>, to follow the established <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> pattern of naming the identifying fields versus the properties that they represent.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The attached property provider must also provide static <ph id="ph1">`Get`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> and <ph id="ph2">`Set`</ph><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as <ph id="ph1">[!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)]</ph> and Expression Blend.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The Get Accessor</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The signature for the <ph id="ph1">`Get`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> accessor must be:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`public static object Get`</ph> <bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> <ph id="ph2">`(object`</ph>  <ph id="ph3">`target`</ph> <ph id="ph4">`)`</ph></source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`target`</ph> object can be specified as a more specific type in your implementation.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=fullName&gt;</ph> method types the parameter as <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>, because the attached property is only intended to be set on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> instances.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The return value can be specified as a more specific type in your implementation.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.GetDock%2A&gt;</ph> method types it as <ph id="ph2">&lt;xref:System.Windows.Controls.Dock&gt;</ph>, because the value can only be set to that enumeration.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The Set Accessor</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The signature for the <ph id="ph1">`Set`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> accessor must be:</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`public static void Set`</ph> <bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> <ph id="ph2">`(object`</ph>  <ph id="ph3">`target`</ph> <ph id="ph4">`, object`</ph>  <ph id="ph5">`value`</ph> <ph id="ph6">`)`</ph></source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`target`</ph> object can be specified as a more specific type in your implementation.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.SetDock%2A&gt;</ph> method types it as <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>, because the attached property is only intended to be set on <ph id="ph3">&lt;xref:System.Windows.UIElement&gt;</ph> instances.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`value`</ph> object can be specified as a more specific type in your implementation.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.SetDock%2A&gt;</ph> method types it as <ph id="ph2">&lt;xref:System.Windows.Controls.Dock&gt;</ph>, because the value can only be set to that enumeration.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>That input is the value specified as a XAML attribute value in markup.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following example shows the dependency property registration (using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method), as well as the <ph id="ph2">`Get`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> and <ph id="ph3">`Set`</ph><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> accessors.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In the example, the attached property name is <ph id="ph1">`IsBubbleSource`</ph>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Therefore, the accessors must be named <ph id="ph1">`GetIsBubbleSource`</ph> and <ph id="ph2">`SetIsBubbleSource`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>WPFAquariumSln#RegisterAttachedBubbler<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>WPFAquariumSln#RegisterAttachedBubbler<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Attached Property Attributes</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> defines several <ph id="ph2">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]</ph> that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]</ph> that <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You might consider applying these attributes for your own custom attached properties also.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The purpose and syntax of the <ph id="ph1">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]</ph> is described on the appropriate reference pages:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Learning More About Attached Properties</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For more information on creating an attached property, see <bpt id="p1">[</bpt>Register an Attached Property<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For more advanced usage scenarios for dependency properties and attached properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>An example of a property with an appropriate scenario for both standard and attached usages is <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph></source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Dependency Properties Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>XAML Overview (WPF)<ept id="p1">](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>Register an Attached Property<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>