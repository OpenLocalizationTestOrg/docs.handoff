<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="attached-and-detached-child-tasks.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b7d726c" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">55146ffefc5563e19fbe65cf9fa6ee68347e4b63</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\standard\parallel-programming\attached-and-detached-child-tasks.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">13dc7ccbab473353356d05fe1f840e28696bfa06</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d2cfe9740ddc79757ad9a1af0094f9e273361de6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Attached and Detached Child Tasks | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Attached and Detached Child Tasks</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>child task<ept id="p1">*</ept> (or <bpt id="p2">*</bpt>nested task<ept id="p2">*</ept>) is a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task?displayProperty=fullName&gt;</ph> instance that is created in the user delegate of another task, which is known as the <bpt id="p3">*</bpt>parent task<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>A child task can be either detached or attached.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>detached child task<ept id="p1">*</ept> is a task that executes independently of its parent.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>attached child task<ept id="p1">*</ept> is a nested task that is created with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option whose parent does not explicitly or by default prohibit it from being attached.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A task may create any number of attached and detached child tasks, limited only by system resources.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following table lists the basic differences between the two kinds of child tasks.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Detached child tasks</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Attached child tasks</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Parent waits for child tasks to complete.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Parent propagates exceptions thrown by child tasks.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Status of parent depends on status of child.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>No</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>In most scenarios, we recommend that you use detached child tasks, because their relationships with other tasks are less complex.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>That is why tasks created inside parent tasks are detached by default, and you must explicitly specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option to create an attached child task.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Detached child tasks</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although a child task is created by a parent task, by default it is independent of the parent task.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In the following example, a parent task creates one simple child task.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you run the example code multiple times, you may notice that the output from the example differs from that shown, and also that the output may change each time you run the code.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This occurs because the parent task and child tasks execute independently of each other; the child is a detached task.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The example waits only for the parent task to complete, and the child task may not execute or complete before the console app terminates.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If the child task is represented by a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object rather than a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object, you can ensure that the parent task will wait for the child to complete by accessing the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName&gt;</ph> property of the child even if it is a detached child task.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property blocks until its task completes, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Attached child tasks</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Unlike detached child tasks, attached child tasks are closely synchronized with the parent.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can change the detached child task in the previous example to an attached child task by using the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option in the task creation statement, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In this code, the attached child task completes before its parent.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>As a result, the output from the example is the same each time you run the code.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can use attached child tasks to create tightly synchronized graphs of asynchronous operations.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>However, a child task can attach to its parent only if its parent does not prohibit attached child tasks.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Parent tasks can explicitly prevent child tasks from attaching to them by specifying the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option in the parent task's class constructor or the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Parent tasks implicitly prevent child tasks from attaching to them if they are created by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>It is identical to the previous example, except that the parent task is created by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=fullName&gt;</ph> method rather than the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Because the child task is not able to attach to its parent, the output from the example is unpredictable.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because the default task creation options for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName&gt;</ph> overloads include <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph>, this example is functionally equivalent to the first example in the "Detached child tasks" section.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Exceptions in child tasks</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If a detached child task throws an exception, that exception must be observed or handled directly in the parent task just as with any non-nested task.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If an attached child task throws an exception, the exception is automatically propagated to the parent task and back to the thread that waits or tries to access the task's <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, by using attached child tasks, you can handle all exceptions at just one point in the call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName&gt;</ph> on the calling thread.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Cancellation and child tasks</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Task cancellation is cooperative.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>That is, to be cancelable, every attached or detached child task must monitor the status of the cancellation token.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you want to cancel a parent and all its children by using one cancellation request, you pass the same token as an argument to all tasks and provide in each task the logic to respond to the request in each task.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Task Cancellation<ept id="p1">](../../../docs/standard/parallel-programming/task-cancellation.md)</ept> and <bpt id="p2">[</bpt>How to: Cancel a Task and Its Children<ept id="p2">](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>When the parent cancels</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If a parent cancels itself before its child task is started, the child never starts.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If a parent cancels itself after its child task has already started, the child runs to completion unless it has its own cancellation logic.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Task Cancellation<ept id="p1">](../../../docs/standard/parallel-programming/task-cancellation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When a detached child task cancels</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If a detached child task cancels itself by using the same token that was passed to the parent, and the parent does not wait for the child task, no exception is propagated, because the exception is treated as benign cooperation cancellation.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This behavior is the same as that of any top-level task.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When an attached child task cancels</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When an attached child task cancels itself by using the same token that was passed to its parent task, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is propagated to the joining thread inside an <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You must wait for the parent task so that you can handle all benign exceptions in addition to all faulting exceptions that are propagated up through a graph of attached child tasks.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Preventing a child task from attaching to its parent</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>An unhandled exception that is thrown by a child task is propagated to the parent task.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can use this behavior to observe all child task exceptions from one root task instead of traversing a tree of tasks.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>However, exception propagation can be problematic when a parent task does not expect attachment from other code.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, consider an app that calls a third-party library component from a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If the third-party library component also creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and specifies <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> to attach it to the parent task, any unhandled exceptions that occur in the child task propagate to the parent.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This could lead to unexpected behavior in the main app.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>To prevent a child task from attaching to its parent task, specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option when you create the parent <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When a task tries to attach to its parent and the parent specifies the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option, the child task will not be able to attach to a parent and will execute just as if the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option was not specified.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You might also want to prevent a child task from attaching to its parent when the child task does not finish in a timely manner.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Because a parent task does not finish until all child tasks finish, a long-running child task can cause the overall app to perform poorly.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For an example that shows how to improve app performance by preventing a task from attaching to its parent task, see <bpt id="p1">[</bpt>How to: Prevent a Child Task from Attaching to its Parent<ept id="p1">](../../../docs/standard/parallel-programming/how-to-prevent-a-child-task-from-attaching-to-its-parent.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Parallel Programming<ept id="p1">](../../../docs/standard/parallel-programming/index.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Data Parallelism<ept id="p1">](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>