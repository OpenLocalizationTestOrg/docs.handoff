{"content":"---\ntitle: \"Read-Only Dependency Properties\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"dependency properties [WPF], read-only\"\n  - \"read-only dependency properties [WPF]\"\nms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1\n---\n# Read-Only Dependency Properties\nThis topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.  \n\n<a name=\"prerequisites\"></a>   \n## Prerequisites  \n This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property. See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.  \n  \n<a name=\"existing\"></a>   \n## Existing Read-Only Dependency Properties  \n Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only. The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective. For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input. Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.  \n  \n By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance). Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system. The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style. You can't enable triggers with a normal [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property; it needs to be a dependency property. The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control. Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.  \n  \n<a name=\"new\"></a>   \n## Creating Custom Read-Only Dependency Properties  \n Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios. But if you have an appropriate scenario, you may wish to create your own read-only dependency property.  \n  \n Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](custom-dependency-properties.md) and [Implement a Dependency Property](how-to-implement-a-dependency-property.md) topics. There are three important differences:  \n  \n-   When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration.  \n  \n-   When implementing the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] \"wrapper\" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.  \n  \n-   The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>. You should still store this field as a member but typically you would not make it a public member of the type.  \n  \n Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide. However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], rather than circumventing the property system and setting the private backing field directly. In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>. How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property. If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal. One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed. Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration.  \n  \n Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property. For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable. For more specifics, see [Dependency Property Security](dependency-property-security.md).  \n  \n## See also\n\n- [Dependency Properties Overview](dependency-properties-overview.md)\n- [Custom Dependency Properties](custom-dependency-properties.md)\n- [Styling and Templating](../controls/styling-and-templating.md)\n","nodes":[{"pos":[4,226],"embed":true,"restype":"x-metadata","content":"title: \"Read-Only Dependency Properties\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"dependency properties [WPF], read-only\"\n  - \"read-only dependency properties [WPF]\"\nms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1","nodes":[{"content":"Read-Only Dependency Properties","nodes":[{"pos":[0,31],"content":"Read-Only Dependency Properties","nodes":[{"content":"Read-Only Dependency Properties","pos":[0,31]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[233,264],"content":"Read-Only Dependency Properties","linkify":"Read-Only Dependency Properties","nodes":[{"content":"Read-Only Dependency Properties","pos":[0,31]}]},{"content":"This topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.","pos":[265,455]},{"pos":[494,507],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.","pos":[511,669]},{"content":"See <bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](custom-dependency-properties.md)</ept> and <bpt id=\"p2\">[</bpt>Dependency Property Metadata<ept id=\"p2\">](dependency-property-metadata.md)</ept> for context.","pos":[670,818],"source":" See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context."},{"pos":[854,894],"content":"Existing Read-Only Dependency Properties","linkify":"Existing Read-Only Dependency Properties","nodes":[{"content":"Existing Read-Only Dependency Properties","pos":[0,40]}]},{"content":"Some of the dependency properties defined in the <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> framework are read-only.","pos":[898,1051],"source":"Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only."},{"content":"The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective.","pos":[1052,1355]},{"content":"For example, the property <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> is really just surfacing state as determined from the mouse input.","pos":[1356,1495],"source":" For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input."},{"content":"Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.","pos":[1496,1634]},{"content":"By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance).","pos":[1641,1898]},{"content":"Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system.","pos":[1899,2064]},{"content":"The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style.","pos":[2065,2198]},{"content":"You can't enable triggers with a normal <ph id=\"ph1\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> property; it needs to be a dependency property.","pos":[2199,2354],"source":" You can't enable triggers with a normal [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property; it needs to be a dependency property."},{"content":"The aforementioned <ph id=\"ph1\">&lt;xref:System.Windows.UIElement.IsMouseOver%2A&gt;</ph> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control.","pos":[2355,2737],"source":" The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control."},{"content":"Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.","pos":[2738,2945]},{"pos":[2976,3023],"content":"Creating Custom Read-Only Dependency Properties","linkify":"Creating Custom Read-Only Dependency Properties","nodes":[{"content":"Creating Custom Read-Only Dependency Properties","pos":[0,47]}]},{"content":"Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios.","pos":[3027,3167]},{"content":"But if you have an appropriate scenario, you may wish to create your own read-only dependency property.","pos":[3168,3271]},{"content":"Much of the process of creating a read-only dependency property is the same as is described in the <bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](custom-dependency-properties.md)</ept> and <bpt id=\"p2\">[</bpt>Implement a Dependency Property<ept id=\"p2\">](how-to-implement-a-dependency-property.md)</ept> topics.","pos":[3278,3529],"source":"Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](custom-dependency-properties.md) and [Implement a Dependency Property](how-to-implement-a-dependency-property.md) topics."},{"content":"There are three important differences:","pos":[3530,3568]},{"pos":[3578,3795],"content":"When registering your property, call the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> method instead of the normal <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method for property registration.","source":"When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration."},{"pos":[3805,4070],"content":"When implementing the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> \"wrapper\" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.","source":"When implementing the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] \"wrapper\" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose."},{"content":"The object returned by the read-only registration is <ph id=\"ph1\">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> rather than <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.","pos":[4080,4230],"source":"The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>."},{"content":"You should still store this field as a member but typically you would not make it a public member of the type.","pos":[4231,4341]},{"content":"Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide.","pos":[4348,4496]},{"content":"However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's <ph id=\"ph1\">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph>, rather than circumventing the property system and setting the private backing field directly.","pos":[4497,4814],"source":" However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], rather than circumventing the property system and setting the private backing field directly."},{"content":"In particular, there is a signature of <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> that accepts a parameter of type <ph id=\"ph2\">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.","pos":[4815,4982],"source":" In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>."},{"content":"How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> created when you first registered the dependency property.","pos":[4983,5215],"source":" How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property."},{"content":"If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal.","pos":[5216,5382]},{"content":"One approach is to call <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed.","pos":[5383,5588],"source":" One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed."},{"content":"Another approach is to tie dependency properties together by using paired <ph id=\"ph1\">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> callbacks as part of those properties' metadata during registration.","pos":[5589,5823],"source":" Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration."},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property.","pos":[5830,6069],"source":"Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property."},{"content":"For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable.","pos":[6070,6206]},{"content":"For more specifics, see <bpt id=\"p1\">[</bpt>Dependency Property Security<ept id=\"p1\">](dependency-property-security.md)</ept>.","pos":[6207,6295],"source":" For more specifics, see [Dependency Property Security](dependency-property-security.md)."},{"pos":[6304,6312],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6316,6383],"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](dependency-properties-overview.md)</ept>","source":"[Dependency Properties Overview](dependency-properties-overview.md)"},{"pos":[6386,6449],"content":"<bpt id=\"p1\">[</bpt>Custom Dependency Properties<ept id=\"p1\">](custom-dependency-properties.md)</ept>","source":"[Custom Dependency Properties](custom-dependency-properties.md)"},{"pos":[6452,6515],"content":"<bpt id=\"p1\">[</bpt>Styling and Templating<ept id=\"p1\">](../controls/styling-and-templating.md)</ept>","source":"[Styling and Templating](../controls/styling-and-templating.md)"}]}