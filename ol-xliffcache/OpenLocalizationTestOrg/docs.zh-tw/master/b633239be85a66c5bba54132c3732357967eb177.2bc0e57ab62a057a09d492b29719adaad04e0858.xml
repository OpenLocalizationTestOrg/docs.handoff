{"content":"---\ntitle: \"COM Wrappers\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"wrapper classes\"\n  - \"COM interop, COM wrappers\"\n  - \"COM wrappers\"\n  - \"COM, wrappers\"\n  - \"interoperation with unmanaged code, COM wrappers\"\n  - \"COM callable wrappers\"\nms.assetid: e56c485b-6b67-4345-8e66-fd21835a6092\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# COM Wrappers\nCOM differs from the .NET Framework object model in several important ways:  \n  \n-   Clients of COM objects must manage the lifetime of those objects; the common language runtime manages the lifetime of objects in its environment.  \n  \n-   Clients of COM objects discover whether a service is available by requesting an interface that provides that service and getting back an interface pointer, or not. Clients of .NET objects can obtain a description of an object's functionality using reflection.  \n  \n-   NET objects reside in memory managed by the .NET Framework execution environment. The execution environment can move objects around in memory for performance reasons and update all references to the objects it moves. Unmanaged clients, having obtained a pointer to an object, rely on the object to remain at the same location. These clients have no mechanism for dealing with an object whose location is not fixed.  \n  \n To overcome these differences, the runtime provides wrapper classes to make both managed and unmanaged clients think they are calling objects within their respective environment. Whenever your managed client calls a method on a COM object, the runtime creates a [runtime callable wrapper](runtime-callable-wrapper.md) (RCW). RCWs abstract the differences between managed and unmanaged reference mechanisms, among other things. The runtime also creates a [COM callable wrapper](com-callable-wrapper.md) (CCW) to reverse the process, enabling a COM client to seamlessly call a method on a .NET object. As the following illustration shows, the perspective of the calling code determines which wrapper class the runtime creates.  \n  \n ![COM wrapper overview](./media/com-wrappers/bidirectional-com-overview.gif)  \n  \n In most cases, the standard RCW or CCW generated by the runtime provides adequate marshaling for calls that cross the boundary between COM and the .NET Framework. Using custom attributes, you can optionally adjust the way the runtime represents managed and unmanaged code.  \n  \n## See also\n\n- [Advanced COM Interoperability](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bd9cdfyx(v=vs.100))\n- [Runtime Callable Wrapper](runtime-callable-wrapper.md)\n- [COM Callable Wrapper](com-callable-wrapper.md)\n- [Customizing Standard Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/h7hx9abd(v=vs.100))\n- [How to: Customize Runtime Callable Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/56kh4hy7(v=vs.100))\n","nodes":[{"pos":[4,334],"embed":true,"restype":"x-metadata","content":"title: \"COM Wrappers\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"wrapper classes\"\n  - \"COM interop, COM wrappers\"\n  - \"COM wrappers\"\n  - \"COM, wrappers\"\n  - \"interoperation with unmanaged code, COM wrappers\"\n  - \"COM callable wrappers\"\nms.assetid: e56c485b-6b67-4345-8e66-fd21835a6092\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"COM Wrappers","nodes":[{"pos":[0,12],"content":"COM Wrappers","nodes":[{"content":"COM Wrappers","pos":[0,12]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[341,353],"content":"COM Wrappers","linkify":"COM Wrappers","nodes":[{"content":"COM Wrappers","pos":[0,12]}]},{"content":"COM differs from the .NET Framework object model in several important ways:","pos":[354,429]},{"content":"Clients of COM objects must manage the lifetime of those objects; the common language runtime manages the lifetime of objects in its environment.","pos":[439,584]},{"content":"Clients of COM objects discover whether a service is available by requesting an interface that provides that service and getting back an interface pointer, or not.","pos":[594,757]},{"content":"Clients of .NET objects can obtain a description of an object's functionality using reflection.","pos":[758,853]},{"content":"NET objects reside in memory managed by the .NET Framework execution environment.","pos":[863,944]},{"content":"The execution environment can move objects around in memory for performance reasons and update all references to the objects it moves.","pos":[945,1079]},{"content":"Unmanaged clients, having obtained a pointer to an object, rely on the object to remain at the same location.","pos":[1080,1189]},{"content":"These clients have no mechanism for dealing with an object whose location is not fixed.","pos":[1190,1277]},{"content":"To overcome these differences, the runtime provides wrapper classes to make both managed and unmanaged clients think they are calling objects within their respective environment.","pos":[1284,1462]},{"content":"Whenever your managed client calls a method on a COM object, the runtime creates a <bpt id=\"p1\">[</bpt>runtime callable wrapper<ept id=\"p1\">](runtime-callable-wrapper.md)</ept> (RCW).","pos":[1463,1608],"source":" Whenever your managed client calls a method on a COM object, the runtime creates a [runtime callable wrapper](runtime-callable-wrapper.md) (RCW)."},{"content":"RCWs abstract the differences between managed and unmanaged reference mechanisms, among other things.","pos":[1609,1710]},{"content":"The runtime also creates a <bpt id=\"p1\">[</bpt>COM callable wrapper<ept id=\"p1\">](com-callable-wrapper.md)</ept> (CCW) to reverse the process, enabling a COM client to seamlessly call a method on a .NET object.","pos":[1711,1883],"source":" The runtime also creates a [COM callable wrapper](com-callable-wrapper.md) (CCW) to reverse the process, enabling a COM client to seamlessly call a method on a .NET object."},{"content":"As the following illustration shows, the perspective of the calling code determines which wrapper class the runtime creates.","pos":[1884,2008]},{"content":"COM wrapper overview","pos":[2017,2037]},{"content":"In most cases, the standard RCW or CCW generated by the runtime provides adequate marshaling for calls that cross the boundary between COM and the .NET Framework.","pos":[2098,2260]},{"content":"Using custom attributes, you can optionally adjust the way the runtime represents managed and unmanaged code.","pos":[2261,2370]},{"pos":[2379,2387],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2391,2511],"content":"<bpt id=\"p1\">[</bpt>Advanced COM Interoperability<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bd9cdfyx(v=vs.100))</ept>","source":"[Advanced COM Interoperability](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bd9cdfyx(v=vs.100))"},{"pos":[2514,2569],"content":"<bpt id=\"p1\">[</bpt>Runtime Callable Wrapper<ept id=\"p1\">](runtime-callable-wrapper.md)</ept>","source":"[Runtime Callable Wrapper](runtime-callable-wrapper.md)"},{"pos":[2572,2619],"content":"<bpt id=\"p1\">[</bpt>COM Callable Wrapper<ept id=\"p1\">](com-callable-wrapper.md)</ept>","source":"[COM Callable Wrapper](com-callable-wrapper.md)"},{"pos":[2622,2742],"content":"<bpt id=\"p1\">[</bpt>Customizing Standard Wrappers<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/h7hx9abd(v=vs.100))</ept>","source":"[Customizing Standard Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/h7hx9abd(v=vs.100))"},{"pos":[2745,2879],"content":"<bpt id=\"p1\">[</bpt>How to: Customize Runtime Callable Wrappers<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/56kh4hy7(v=vs.100))</ept>","source":"[How to: Customize Runtime Callable Wrappers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/56kh4hy7(v=vs.100))"}]}