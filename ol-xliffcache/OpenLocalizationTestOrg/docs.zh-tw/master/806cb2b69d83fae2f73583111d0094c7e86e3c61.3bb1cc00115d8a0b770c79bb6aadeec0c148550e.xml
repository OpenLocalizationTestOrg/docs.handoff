{"content":"---\ntitle: \"How to: Use a Background Thread to Search for Files\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"Multithreaded Windows Forms Control sample [Windows Forms]\"\n  - \"custom controls [Windows Forms], multithreading\"\n  - \"threading [Windows Forms], custom controls\"\n  - \"custom controls [Windows Forms], samples\"\nms.assetid: 7fe3956f-5b8f-4f78-8aae-c9eb0b28f13a\n---\n# How to: Use a Background Thread to Search for Files\nThe <xref:System.ComponentModel.BackgroundWorker> component replaces and adds functionality to the <xref:System.Threading> namespace; however, the <xref:System.Threading> namespace is retained for both backward compatibility and future use, if you choose. For more information, see [BackgroundWorker Component Overview](backgroundworker-component-overview.md).  \n  \n Windows Forms uses the single-threaded apartment (STA) model because Windows Forms is based on native Win32 windows that are inherently apartment-threaded. The STA model implies that a window can be created on any thread, but it cannot switch threads once created, and all function calls to it must occur on its creation thread. Outside Windows Forms, classes in the .NET Framework use the free threading model. For information about threading in the .NET Framework, see [Threading](../../../standard/threading/index.md).  \n  \n The STA model requires that any methods on a control that need to be called from outside the control's creation thread must be marshaled to (executed on) the control's creation thread. The base class <xref:System.Windows.Forms.Control> provides several methods (<xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, and <xref:System.Windows.Forms.Control.EndInvoke%2A>) for this purpose. <xref:System.Windows.Forms.Control.Invoke%2A> makes synchronous method calls; <xref:System.Windows.Forms.Control.BeginInvoke%2A> makes asynchronous method calls.  \n  \n If you use multithreading in your control for resource-intensive tasks, the user interface can remain responsive while a resource-intensive computation executes on a background thread.  \n  \n The following sample (`DirectorySearcher`) shows a multithreaded Windows Forms control that uses a background thread to recursively search a directory for files matching a specified search string and then populates a list box with the search result. The key concepts illustrated by the sample are as follows:  \n  \n-   `DirectorySearcher` starts a new thread to perform the search. The thread executes the `ThreadProcedure` method that in turn calls the helper `RecurseDirectory` method to do the actual search and to populate the list box. However, populating the list box requires a cross-thread call, as explained in the next two bulleted items.  \n  \n-   `DirectorySearcher` defines the `AddFiles` method to add files to a list box; however, `RecurseDirectory` cannot directly invoke `AddFiles` because `AddFiles` can execute only in the STA thread that created `DirectorySearcher`.  \n  \n-   The only way `RecurseDirectory` can call `AddFiles` is through a cross-thread call — that is, by calling <xref:System.Windows.Forms.Control.Invoke%2A> or <xref:System.Windows.Forms.Control.BeginInvoke%2A> to marshal `AddFiles` to the creation thread of `DirectorySearcher`. `RecurseDirectory` uses <xref:System.Windows.Forms.Control.BeginInvoke%2A> so that the call can be made asynchronously.  \n  \n-   Marshaling a method requires the equivalent of a function pointer or callback. This is accomplished using delegates in the .NET Framework. <xref:System.Windows.Forms.Control.BeginInvoke%2A> takes a delegate as an argument. `DirectorySearcher` therefore defines a delegate (`FileListDelegate`), binds `AddFiles` to an instance of `FileListDelegate` in its constructor, and passes this delegate instance to <xref:System.Windows.Forms.Control.BeginInvoke%2A>. `DirectorySearcher` also defines an event delegate that is marshaled when the search is completed.  \n  \n```vb  \nOption Strict  \nOption Explicit  \n  \nImports System  \nImports System.IO  \nImports System.Threading  \nImports System.Windows.Forms  \n  \nNamespace Microsoft.Samples.DirectorySearcher  \n   ' <summary>  \n   '      This class is a Windows Forms control that implements a simple directory searcher.  \n   '      You provide, through code, a search string and it will search directories on  \n   '      a background thread, populating its list box with matches.  \n   ' </summary>  \n   Public Class DirectorySearcher  \n      Inherits Control  \n      ' Define a special delegate that handles marshaling  \n      ' lists of file names from the background directory search  \n      ' thread to the thread that contains the list box.  \n      Delegate Sub FileListDelegate(files() As String, startIndex As Integer, count As Integer)  \n  \n      Private _listBox As ListBox  \n      Private _searchCriteria As String  \n      Private _searching As Boolean  \n      Private _deferSearch As Boolean  \n      Private _searchThread As Thread  \n      Private _fileListDelegate As FileListDelegate  \n      Private _onSearchComplete As EventHandler  \n  \n      Public Sub New()  \n         _listBox = New ListBox()  \n         _listBox.Dock = DockStyle.Fill  \n  \n         Controls.Add(_listBox)  \n  \n         _fileListDelegate = New FileListDelegate(AddressOf AddFiles)  \n         _onSearchComplete = New EventHandler(AddressOf OnSearchComplete)  \n      End Sub  \n  \n      Public Property SearchCriteria() As String  \n         Get  \n            Return _searchCriteria  \n         End Get  \n         Set  \n            ' If currently searching, abort  \n            ' the search and restart it after  \n            ' setting the new criteria.  \n            '  \n            Dim wasSearching As Boolean = Searching  \n  \n            If wasSearching Then  \n               StopSearch()  \n            End If  \n  \n            _listBox.Items.Clear()  \n            _searchCriteria = value  \n  \n            If wasSearching Then  \n               BeginSearch()  \n            End If  \n         End Set  \n      End Property  \n  \n      Public ReadOnly Property Searching() As Boolean  \n         Get  \n            Return _searching  \n         End Get  \n      End Property  \n  \n      Public Event SearchComplete As EventHandler  \n  \n      ' <summary>  \n      ' This method is called from the background thread.  It is called through  \n      ' a BeginInvoke call so that it is always marshaled to the thread that  \n      ' owns the list box control.  \n      ' </summary>  \n      ' <param name=\"files\"></param>  \n      ' <param name=\"startIndex\"></param>  \n      ' <param name=\"count\"></param>  \n      Private Sub AddFiles(files() As String, startIndex As Integer, count As Integer)  \n         While count > 0  \n            count -= 1  \n            _listBox.Items.Add(files((startIndex + count)))  \n         End While  \n      End Sub  \n  \n      Public Sub BeginSearch()  \n         ' Create the search thread, which   \n         ' will begin the search.  \n         ' If already searching, do nothing.  \n         '  \n         If Searching Then  \n            Return  \n         End If  \n  \n         ' Start the search if the handle has  \n         ' been created. Otherwise, defer it until the  \n         ' handle has been created.  \n         If IsHandleCreated Then  \n            _searchThread = New Thread(New ThreadStart(AddressOf ThreadProcedure))  \n            _searching = True  \n            _searchThread.Start()  \n         Else  \n            _deferSearch = True  \n         End If  \n      End Sub  \n  \n      Protected Overrides Sub OnHandleDestroyed(e As EventArgs)  \n         ' If the handle is being destroyed and you are not  \n         ' recreating it, then abort the search.  \n         If Not RecreatingHandle Then  \n            StopSearch()  \n         End If  \n         MyBase.OnHandleDestroyed(e)  \n      End Sub  \n  \n      Protected Overrides Sub OnHandleCreated(e As EventArgs)  \n         MyBase.OnHandleCreated(e)  \n         If _deferSearch Then  \n            _deferSearch = False  \n            BeginSearch()  \n         End If  \n      End Sub  \n  \n      ' <summary>  \n      ' This method is called by the background thread when it has  \n      ' finished the search.  \n      ' </summary>  \n      ' <param name=\"sender\"></param>  \n      ' <param name=\"e\"></param>  \n      Private Sub OnSearchComplete(sender As Object, e As EventArgs)  \n         RaiseEvent SearchComplete(sender, e)  \n      End Sub  \n  \n      Public Sub StopSearch()  \n         If Not _searching Then  \n            Return  \n         End If  \n  \n         If _searchThread.IsAlive Then  \n            _searchThread.Abort()  \n            _searchThread.Join()  \n         End If  \n  \n         _searchThread = Nothing  \n         _searching = False  \n      End Sub  \n  \n      ' <summary>  \n      ' Recurses the given path, adding all files on that path to   \n      ' the list box. After it finishes with the files, it  \n      ' calls itself once for each directory on the path.  \n      ' </summary>  \n      ' <param name=\"searchPath\"></param>  \n      Private Sub RecurseDirectory(searchPath As String)  \n         ' Split searchPath into a directory and a wildcard specification.  \n         '  \n         Dim directoryPath As String = Path.GetDirectoryName(searchPath)  \n         Dim search As String = Path.GetFileName(searchPath)  \n  \n         ' If a directory or search criteria are not specified, then return.  \n         '  \n         If directoryPath Is Nothing Or search Is Nothing Then  \n            Return  \n         End If  \n  \n         Dim files() As String  \n  \n         ' File systems like NTFS that have  \n         ' access permissions might result in exceptions  \n         ' when looking into directories without permission.  \n         ' Catch those exceptions and return.  \n         Try  \n            files = Directory.GetFiles(directoryPath, search)  \n         Catch e As UnauthorizedAccessException  \n            Return  \n         Catch e As DirectoryNotFoundException  \n            Return  \n         End Try  \n  \n         ' Perform a BeginInvoke call to the list box  \n         ' in order to marshal to the correct thread. It is not  \n         ' very efficient to perform this marshal once for every  \n         ' file, so batch up multiple file calls into one  \n         ' marshal invocation.  \n         Dim startingIndex As Integer = 0  \n         While startingIndex < files.Length  \n            ' Batch up 20 files at once, unless at the  \n            ' end.  \n            '  \n            Dim count As Integer = 20  \n            If count + startingIndex >= files.Length Then  \n               count = files.Length - startingIndex  \n            End If  \n            ' Begin the cross-thread call. Because you are passing  \n            ' immutable objects into this invoke method, you do not have to  \n            ' wait for it to finish. If these were complex objects, you would  \n            ' have to either create new instances of them or   \n            ' wait for the thread to process this invoke before modifying  \n            ' the objects.  \n            Dim r As IAsyncResult = BeginInvoke(_fileListDelegate, New Object() {files, startingIndex, count})  \n            startingIndex += count  \n         End While  \n         ' Now that you have finished the files in this directory, recurse  \n         ' for each subdirectory.  \n         Dim directories As String() = Directory.GetDirectories(directoryPath)  \n         Dim d As String  \n         For Each d In  directories  \n            RecurseDirectory(Path.Combine(d, search))  \n         Next d  \n      End Sub  \n  \n      '/ <summary>  \n      '/ This is the actual thread procedure. This method runs in a background  \n      '/ thread to scan directories. When finished, it simply exits.  \n      '/ </summary>  \n      Private Sub ThreadProcedure()  \n         ' Get the search string. Individual   \n         ' field assigns are atomic in .NET, so you do not  \n         ' need to use any thread synchronization to grab  \n         ' the string value here.  \n         Try  \n            Dim localSearch As String = SearchCriteria  \n  \n            ' Now, search the file system.  \n            '  \n            RecurseDirectory(localSearch)  \n         Finally  \n            ' You are done with the search, so update.  \n            '  \n            _searching = False  \n  \n            ' Raise an event that notifies the user that  \n            ' the search has terminated.    \n            ' You do not have to do this through a marshaled call, but  \n            ' marshaling is recommended for the following reason:  \n            ' Users of this control do not know that it is  \n            ' multithreaded, so they expect its events to   \n            ' come back on the same thread as the control.  \n            BeginInvoke(_onSearchComplete, New Object() {Me, EventArgs.Empty})  \n         End Try  \n      End Sub  \n   End Class  \nEnd Namespace  \n```  \n  \n```csharp  \nnamespace Microsoft.Samples.DirectorySearcher  \n{  \n   using System;  \n   using System.IO;  \n   using System.Threading;  \n   using System.Windows.Forms;  \n  \n   /// <summary>  \n   ///      This class is a Windows Forms control that implements a simple directory searcher.  \n   ///      You provide, through code, a search string and it will search directories on  \n   ///      a background thread, populating its list box with matches.  \n   /// </summary>  \n   public class DirectorySearcher : Control  \n   {  \n      // Define a special delegate that handles marshaling  \n      // lists of file names from the background directory search  \n      // thread to the thread that contains the list box.  \n      private delegate void FileListDelegate(string[] files, int startIndex, int count);  \n  \n      private ListBox listBox;  \n      private string  searchCriteria;  \n      private bool searching;  \n      private bool deferSearch;  \n      private Thread searchThread;  \n      private FileListDelegate fileListDelegate;  \n      private EventHandler onSearchComplete;  \n  \n      public DirectorySearcher()  \n      {  \n         listBox = new ListBox();  \n         listBox.Dock = DockStyle.Fill;  \n  \n         Controls.Add(listBox);  \n  \n         fileListDelegate = new FileListDelegate(AddFiles);  \n         onSearchComplete = new EventHandler(OnSearchComplete);  \n      }  \n  \n      public string SearchCriteria   \n      {  \n         get   \n         {  \n            return searchCriteria;  \n         }  \n         set   \n         {  \n            // If currently searching, abort  \n            // the search and restart it after  \n            // setting the new criteria.  \n            //  \n            bool wasSearching = Searching;  \n  \n            if (wasSearching)  \n            {  \n               StopSearch();  \n            }  \n  \n            listBox.Items.Clear();  \n            searchCriteria = value;  \n  \n            if (wasSearching)  \n            {  \n               BeginSearch();  \n            }  \n         }  \n      }  \n  \n      public bool Searching   \n      {  \n         get   \n         {  \n            return searching;  \n         }  \n      }  \n  \n      public event EventHandler SearchComplete;  \n  \n      /// <summary>  \n      /// This method is called from the background thread. It is called through  \n      /// a BeginInvoke call so that it is always marshaled to the thread that  \n      /// owns the list box control.  \n      /// </summary>  \n      /// <param name=\"files\"></param>  \n      /// <param name=\"startIndex\"></param>  \n      /// <param name=\"count\"></param>  \n      private void AddFiles(string[] files, int startIndex, int count)  \n      {  \n         while(count-- > 0)  \n         {  \n            listBox.Items.Add(files[startIndex + count]);  \n         }  \n      }  \n  \n      public void BeginSearch()   \n      {  \n         // Create the search thread, which   \n         // will begin the search.  \n         // If already searching, do nothing.  \n         //  \n         if (Searching)  \n         {  \n            return;  \n         }  \n  \n         // Start the search if the handle has  \n         // been created. Otherwise, defer it until the  \n         // handle has been created.  \n         if (IsHandleCreated)  \n         {  \n            searchThread = new Thread(new ThreadStart(ThreadProcedure));  \n            searching = true;  \n            searchThread.Start();  \n         }  \n         else  \n         {  \n            deferSearch = true;  \n         }  \n      }  \n  \n      protected override void OnHandleDestroyed(EventArgs e)  \n      {  \n         // If the handle is being destroyed and you are not  \n         // recreating it, then abort the search.  \n         if (!RecreatingHandle)  \n         {  \n            StopSearch();  \n         }  \n         base.OnHandleDestroyed(e);  \n      }  \n  \n      protected override void OnHandleCreated(EventArgs e)   \n      {  \n         base.OnHandleCreated(e);  \n         if (deferSearch)  \n         {  \n            deferSearch = false;  \n            BeginSearch();  \n         }  \n      }  \n  \n      /// <summary>  \n      /// This method is called by the background thread when it has finished  \n      /// the search.  \n      /// </summary>  \n      /// <param name=\"sender\"></param>  \n      /// <param name=\"e\"></param>  \n      private void OnSearchComplete(object sender, EventArgs e)  \n      {  \n         if (SearchComplete != null)  \n         {  \n            SearchComplete(sender, e);  \n         }  \n      }  \n  \n      public void StopSearch()  \n      {  \n         if (!searching)  \n         {  \n            return;  \n         }  \n  \n         if (searchThread.IsAlive)  \n         {  \n            searchThread.Abort();  \n            searchThread.Join();  \n         }  \n  \n         searchThread = null;  \n         searching = false;  \n      }  \n  \n      /// <summary>  \n      /// Recurses the given path, adding all files on that path to   \n      /// the list box. After it finishes with the files, it  \n      /// calls itself once for each directory on the path.  \n      /// </summary>  \n      /// <param name=\"searchPath\"></param>  \n      private void RecurseDirectory(string searchPath)  \n      {  \n         // Split searchPath into a directory and a wildcard specification.  \n         //  \n         string directory = Path.GetDirectoryName(searchPath);  \n         string search = Path.GetFileName(searchPath);  \n  \n         // If a directory or search criteria are not specified, then return.  \n         //  \n         if (directory == null || search == null)  \n         {  \n            return;  \n         }  \n  \n         string[] files;  \n  \n         // File systems like NTFS that have  \n         // access permissions might result in exceptions  \n         // when looking into directories without permission.  \n         // Catch those exceptions and return.  \n         try   \n         {  \n            files = Directory.GetFiles(directory, search);  \n         }  \n         catch(UnauthorizedAccessException)  \n         {  \n            return;  \n         }  \n         catch(DirectoryNotFoundException)  \n         {  \n            return;  \n         }  \n  \n         // Perform a BeginInvoke call to the list box  \n         // in order to marshal to the correct thread. It is not  \n         // very efficient to perform this marshal once for every  \n         // file, so batch up multiple file calls into one  \n         // marshal invocation.  \n         int startingIndex = 0;  \n  \n         while(startingIndex < files.Length)  \n         {  \n            // Batch up 20 files at once, unless at the  \n            // end.  \n            //  \n            int count = 20;  \n            if (count + startingIndex >= files.Length)  \n            {  \n               count = files.Length - startingIndex;  \n            }  \n  \n            // Begin the cross-thread call. Because you are passing  \n            // immutable objects into this invoke method, you do not have to  \n            // wait for it to finish. If these were complex objects, you would  \n            // have to either create new instances of them or   \n            // wait for the thread to process this invoke before modifying  \n            // the objects.  \n            IAsyncResult r = BeginInvoke(fileListDelegate, new object[] {files, startingIndex, count});  \n            startingIndex += count;  \n         }  \n  \n         // Now that you have finished the files in this directory, recurse for  \n         // each subdirectory.  \n         string[] directories = Directory.GetDirectories(directory);  \n         foreach(string d in directories)  \n         {  \n            RecurseDirectory(Path.Combine(d, search));  \n         }  \n      }  \n  \n      /// <summary>  \n      /// This is the actual thread procedure. This method runs in a background  \n      /// thread to scan directories. When finished, it simply exits.  \n      /// </summary>  \n      private void ThreadProcedure()  \n      {  \n         // Get the search string. Individual   \n         // field assigns are atomic in .NET, so you do not  \n         // need to use any thread synchronization to grab  \n         // the string value here.  \n         try   \n         {  \n            string localSearch = SearchCriteria;  \n  \n            // Now, search the file system.  \n            //  \n            RecurseDirectory(localSearch);  \n         }  \n         finally  \n         {  \n            // You are done with the search, so update.  \n            //  \n            searching = false;  \n  \n            // Raise an event that notifies the user that  \n            // the search has terminated.    \n            // You do not have to do this through a marshaled call, but  \n            // marshaling is recommended for the following reason:  \n            // Users of this control do not know that it is  \n            // multithreaded, so they expect its events to   \n            // come back on the same thread as the control.  \n            BeginInvoke(onSearchComplete, new object[] {this, EventArgs.Empty});  \n         }  \n      }  \n   }  \n}  \n```  \n  \n## Using the Multithreaded Control on a Form  \n The following example shows how the multithreaded `DirectorySearcher` control can be used on a form.  \n  \n```vb  \nOption Explicit  \nOption Strict  \n  \nImports Microsoft.Samples.DirectorySearcher  \nImports System  \nImports System.Drawing  \nImports System.Collections  \nImports System.ComponentModel  \nImports System.Windows.Forms  \nImports System.Data  \n  \nNamespace SampleUsage  \n  \n   ' <summary>  \n   '      Summary description for Form1.  \n   ' </summary>  \n   Public Class Form1  \n      Inherits System.Windows.Forms.Form  \n      Private WithEvents directorySearcher As DirectorySearcher  \n      Private searchText As System.Windows.Forms.TextBox  \n      Private searchLabel As System.Windows.Forms.Label  \n      Private WithEvents searchButton As System.Windows.Forms.Button  \n  \n      Public Sub New()  \n         '  \n         ' Required for Windows Forms designer support.  \n         '  \n         InitializeComponent()  \n         '  \n         ' Add any constructor code after InitializeComponent call here.  \n         '  \n      End Sub  \n  \n      #Region \"Windows Form Designer generated code\"  \n      ' <summary>  \n      '      Required method for designer support. Do not modify  \n      '      the contents of this method with the code editor.  \n      ' </summary>  \n      Private Sub InitializeComponent()  \n         Me.directorySearcher = New Microsoft.Samples.DirectorySearcher.DirectorySearcher()  \n         Me.searchButton = New System.Windows.Forms.Button()  \n         Me.searchText = New System.Windows.Forms.TextBox()  \n         Me.searchLabel = New System.Windows.Forms.Label()  \n         Me.directorySearcher.Anchor = System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left Or System.Windows.Forms.AnchorStyles.Right  \n         Me.directorySearcher.Location = New System.Drawing.Point(8, 72)  \n         Me.directorySearcher.SearchCriteria = Nothing  \n         Me.directorySearcher.Size = New System.Drawing.Size(271, 173)  \n         Me.directorySearcher.TabIndex = 2  \n         Me.searchButton.Location = New System.Drawing.Point(8, 16)  \n         Me.searchButton.Size = New System.Drawing.Size(88, 40)  \n         Me.searchButton.TabIndex = 0  \n         Me.searchButton.Text = \"&Search\"  \n         Me.searchText.Anchor = System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left Or System.Windows.Forms.AnchorStyles.Right  \n         Me.searchText.Location = New System.Drawing.Point(104, 24)  \n         Me.searchText.Size = New System.Drawing.Size(175, 20)  \n         Me.searchText.TabIndex = 1  \n         Me.searchText.Text = \"c:\\*.cs\"  \n         Me.searchLabel.ForeColor = System.Drawing.Color.Red  \n         Me.searchLabel.Location = New System.Drawing.Point(104, 48)  \n         Me.searchLabel.Size = New System.Drawing.Size(176, 16)  \n         Me.searchLabel.TabIndex = 3  \n         Me.ClientSize = New System.Drawing.Size(291, 264)  \n         Me.Controls.AddRange(New System.Windows.Forms.Control() {Me.searchLabel, Me.directorySearcher, Me.searchText, Me.searchButton})  \n         Me.Text = \"Search Directories\"  \n      End Sub  \n      #End Region  \n  \n      ' <summary>  \n      '    The main entry point for the application.  \n      ' </summary>  \n      <STAThread()> _  \n      Shared Sub Main()  \n         Application.Run(New Form1())  \n      End Sub  \n  \n      Private Sub searchButton_Click(sender As Object, e As System.EventArgs) Handles searchButton.Click  \n         directorySearcher.SearchCriteria = searchText.Text  \n         searchLabel.Text = \"Searching...\"  \n         directorySearcher.BeginSearch()  \n      End Sub  \n  \n      Private Sub directorySearcher_SearchComplete(sender As Object, e As System.EventArgs) Handles directorySearcher.SearchComplete  \n         searchLabel.Text = String.Empty  \n      End Sub  \n   End Class  \nEnd Namespace  \n```  \n  \n```csharp  \nnamespace SampleUsage  \n{  \n   using Microsoft.Samples.DirectorySearcher;  \n   using System;  \n   using System.Drawing;  \n   using System.Collections;  \n   using System.ComponentModel;  \n   using System.Windows.Forms;  \n   using System.Data;  \n  \n   /// <summary>  \n   ///      Summary description for Form1.  \n   /// </summary>  \n   public class Form1 : System.Windows.Forms.Form  \n   {  \n      private DirectorySearcher directorySearcher;  \n      private System.Windows.Forms.TextBox searchText;  \n      private System.Windows.Forms.Label searchLabel;  \n      private System.Windows.Forms.Button searchButton;  \n  \n      public Form1()  \n      {  \n         //  \n         // Required for Windows Forms designer support.  \n         //  \n         InitializeComponent();  \n  \n         //  \n         // Add any constructor code after InitializeComponent call here.  \n         //  \n      }  \n  \n      #region Windows Form Designer generated code  \n      /// <summary>  \n      ///      Required method for designer support. Do not modify  \n      ///      the contents of this method with the code editor.  \n      /// </summary>  \n      private void InitializeComponent()  \n      {  \n         this.directorySearcher = new Microsoft.Samples.DirectorySearcher.DirectorySearcher();  \n         this.searchButton = new System.Windows.Forms.Button();  \n         this.searchText = new System.Windows.Forms.TextBox();  \n         this.searchLabel = new System.Windows.Forms.Label();  \n         this.directorySearcher.Anchor = (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)   \n            | System.Windows.Forms.AnchorStyles.Left)   \n            | System.Windows.Forms.AnchorStyles.Right);  \n         this.directorySearcher.Location = new System.Drawing.Point(8, 72);  \n         this.directorySearcher.SearchCriteria = null;  \n         this.directorySearcher.Size = new System.Drawing.Size(271, 173);  \n         this.directorySearcher.TabIndex = 2;  \n         this.directorySearcher.SearchComplete += new System.EventHandler(this.directorySearcher_SearchComplete);  \n         this.searchButton.Location = new System.Drawing.Point(8, 16);  \n         this.searchButton.Size = new System.Drawing.Size(88, 40);  \n         this.searchButton.TabIndex = 0;  \n         this.searchButton.Text = \"&Search\";  \n         this.searchButton.Click += new System.EventHandler(this.searchButton_Click);  \n         this.searchText.Anchor = ((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)   \n            | System.Windows.Forms.AnchorStyles.Right);  \n         this.searchText.Location = new System.Drawing.Point(104, 24);  \n         this.searchText.Size = new System.Drawing.Size(175, 20);  \n         this.searchText.TabIndex = 1;  \n         this.searchText.Text = \"c:\\\\*.cs\";  \n         this.searchLabel.ForeColor = System.Drawing.Color.Red;  \n         this.searchLabel.Location = new System.Drawing.Point(104, 48);  \n         this.searchLabel.Size = new System.Drawing.Size(176, 16);  \n         this.searchLabel.TabIndex = 3;  \n         this.ClientSize = new System.Drawing.Size(291, 264);  \n         this.Controls.AddRange(new System.Windows.Forms.Control[] {this.searchLabel,  \n                                                        this.directorySearcher,  \n                                                        this.searchText,  \n                                                        this.searchButton});  \n         this.Text = \"Search Directories\";  \n  \n      }  \n      #endregion  \n  \n      /// <summary>  \n      ///    The main entry point for the application.  \n      /// </summary>  \n      [STAThread]  \n      static void Main()   \n      {  \n         Application.Run(new Form1());  \n      }  \n  \n      private void searchButton_Click(object sender, System.EventArgs e)  \n      {  \n         directorySearcher.SearchCriteria = searchText.Text;  \n         searchLabel.Text = \"Searching...\";  \n         directorySearcher.BeginSearch();  \n      }  \n  \n      private void directorySearcher_SearchComplete(object sender, System.EventArgs e)  \n      {  \n         searchLabel.Text = string.Empty;  \n      }  \n   }  \n}  \n```  \n  \n## See also\n\n- <xref:System.ComponentModel.BackgroundWorker>\n- [Developing Custom Windows Forms Controls with the .NET Framework](developing-custom-windows-forms-controls.md)\n- [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)\n","nodes":[{"pos":[4,406],"embed":true,"restype":"x-metadata","content":"title: \"How to: Use a Background Thread to Search for Files\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"Multithreaded Windows Forms Control sample [Windows Forms]\"\n  - \"custom controls [Windows Forms], multithreading\"\n  - \"threading [Windows Forms], custom controls\"\n  - \"custom controls [Windows Forms], samples\"\nms.assetid: 7fe3956f-5b8f-4f78-8aae-c9eb0b28f13a","nodes":[{"content":"How to: Use a Background Thread to Search for Files","nodes":[{"pos":[0,51],"content":"How to: Use a Background Thread to Search for Files","nodes":[{"content":"How to: Use a Background Thread to Search for Files","pos":[0,51]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[413,464],"content":"How to: Use a Background Thread to Search for Files","linkify":"How to: Use a Background Thread to Search for Files","nodes":[{"content":"How to: Use a Background Thread to Search for Files","pos":[0,51]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> component replaces and adds functionality to the <ph id=\"ph2\">&lt;xref:System.Threading&gt;</ph> namespace; however, the <ph id=\"ph3\">&lt;xref:System.Threading&gt;</ph> namespace is retained for both backward compatibility and future use, if you choose.","pos":[465,720],"source":"The <xref:System.ComponentModel.BackgroundWorker> component replaces and adds functionality to the <xref:System.Threading> namespace; however, the <xref:System.Threading> namespace is retained for both backward compatibility and future use, if you choose."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>BackgroundWorker Component Overview<ept id=\"p1\">](backgroundworker-component-overview.md)</ept>.","pos":[721,825],"source":" For more information, see [BackgroundWorker Component Overview](backgroundworker-component-overview.md)."},{"content":"Windows Forms uses the single-threaded apartment (STA) model because Windows Forms is based on native Win32 windows that are inherently apartment-threaded.","pos":[832,987]},{"content":"The STA model implies that a window can be created on any thread, but it cannot switch threads once created, and all function calls to it must occur on its creation thread.","pos":[988,1160]},{"content":"Outside Windows Forms, classes in the .NET Framework use the free threading model.","pos":[1161,1243]},{"content":"For information about threading in the .NET Framework, see <bpt id=\"p1\">[</bpt>Threading<ept id=\"p1\">](../../../standard/threading/index.md)</ept>.","pos":[1244,1353],"source":" For information about threading in the .NET Framework, see [Threading](../../../standard/threading/index.md)."},{"content":"The STA model requires that any methods on a control that need to be called from outside the control's creation thread must be marshaled to (executed on) the control's creation thread.","pos":[1360,1544]},{"content":"The base class <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control&gt;</ph> provides several methods (<ph id=\"ph2\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Windows.Forms.Control.EndInvoke%2A&gt;</ph>) for this purpose.","pos":[1545,1792],"source":" The base class <xref:System.Windows.Forms.Control> provides several methods (<xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, and <xref:System.Windows.Forms.Control.EndInvoke%2A>) for this purpose."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> makes synchronous method calls; <ph id=\"ph2\">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph> makes asynchronous method calls.","pos":[1793,1954],"source":"<xref:System.Windows.Forms.Control.Invoke%2A> makes synchronous method calls; <xref:System.Windows.Forms.Control.BeginInvoke%2A> makes asynchronous method calls."},{"content":"If you use multithreading in your control for resource-intensive tasks, the user interface can remain responsive while a resource-intensive computation executes on a background thread.","pos":[1961,2145]},{"content":"The following sample (<ph id=\"ph1\">`DirectorySearcher`</ph>) shows a multithreaded Windows Forms control that uses a background thread to recursively search a directory for files matching a specified search string and then populates a list box with the search result.","pos":[2152,2401],"source":"The following sample (`DirectorySearcher`) shows a multithreaded Windows Forms control that uses a background thread to recursively search a directory for files matching a specified search string and then populates a list box with the search result."},{"content":"The key concepts illustrated by the sample are as follows:","pos":[2402,2460]},{"content":"<ph id=\"ph1\">`DirectorySearcher`</ph> starts a new thread to perform the search.","pos":[2470,2532],"source":"`DirectorySearcher` starts a new thread to perform the search."},{"content":"The thread executes the <ph id=\"ph1\">`ThreadProcedure`</ph> method that in turn calls the helper <ph id=\"ph2\">`RecurseDirectory`</ph> method to do the actual search and to populate the list box.","pos":[2533,2691],"source":" The thread executes the `ThreadProcedure` method that in turn calls the helper `RecurseDirectory` method to do the actual search and to populate the list box."},{"content":"However, populating the list box requires a cross-thread call, as explained in the next two bulleted items.","pos":[2692,2799]},{"pos":[2809,3036],"content":"<ph id=\"ph1\">`DirectorySearcher`</ph> defines the <ph id=\"ph2\">`AddFiles`</ph> method to add files to a list box; however, <ph id=\"ph3\">`RecurseDirectory`</ph> cannot directly invoke <ph id=\"ph4\">`AddFiles`</ph> because <ph id=\"ph5\">`AddFiles`</ph> can execute only in the STA thread that created <ph id=\"ph6\">`DirectorySearcher`</ph>.","source":"`DirectorySearcher` defines the `AddFiles` method to add files to a list box; however, `RecurseDirectory` cannot directly invoke `AddFiles` because `AddFiles` can execute only in the STA thread that created `DirectorySearcher`."},{"content":"The only way <ph id=\"ph1\">`RecurseDirectory`</ph> can call <ph id=\"ph2\">`AddFiles`</ph> is through a cross-thread call — that is, by calling <ph id=\"ph3\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph> to marshal <ph id=\"ph5\">`AddFiles`</ph> to the creation thread of <ph id=\"ph6\">`DirectorySearcher`</ph>.","pos":[3046,3319],"source":"The only way `RecurseDirectory` can call `AddFiles` is through a cross-thread call — that is, by calling <xref:System.Windows.Forms.Control.Invoke%2A> or <xref:System.Windows.Forms.Control.BeginInvoke%2A> to marshal `AddFiles` to the creation thread of `DirectorySearcher`."},{"content":"<ph id=\"ph1\">`RecurseDirectory`</ph> uses <ph id=\"ph2\">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph> so that the call can be made asynchronously.","pos":[3320,3439],"source":"`RecurseDirectory` uses <xref:System.Windows.Forms.Control.BeginInvoke%2A> so that the call can be made asynchronously."},{"content":"Marshaling a method requires the equivalent of a function pointer or callback.","pos":[3449,3527]},{"content":"This is accomplished using delegates in the .NET Framework.","pos":[3528,3587]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph> takes a delegate as an argument.","pos":[3588,3671],"source":"<xref:System.Windows.Forms.Control.BeginInvoke%2A> takes a delegate as an argument."},{"content":"<ph id=\"ph1\">`DirectorySearcher`</ph> therefore defines a delegate (<ph id=\"ph2\">`FileListDelegate`</ph>), binds <ph id=\"ph3\">`AddFiles`</ph> to an instance of <ph id=\"ph4\">`FileListDelegate`</ph> in its constructor, and passes this delegate instance to <ph id=\"ph5\">&lt;xref:System.Windows.Forms.Control.BeginInvoke%2A&gt;</ph>.","pos":[3672,3905],"source":"`DirectorySearcher` therefore defines a delegate (`FileListDelegate`), binds `AddFiles` to an instance of `FileListDelegate` in its constructor, and passes this delegate instance to <xref:System.Windows.Forms.Control.BeginInvoke%2A>."},{"content":"<ph id=\"ph1\">`DirectorySearcher`</ph> also defines an event delegate that is marshaled when the search is completed.","pos":[3906,4004],"source":"`DirectorySearcher` also defines an event delegate that is marshaled when the search is completed."},{"pos":[22011,22052],"content":"Using the Multithreaded Control on a Form","linkify":"Using the Multithreaded Control on a Form","nodes":[{"content":"Using the Multithreaded Control on a Form","pos":[0,41]}]},{"pos":[22056,22156],"content":"The following example shows how the multithreaded <ph id=\"ph1\">`DirectorySearcher`</ph> control can be used on a form.","source":"The following example shows how the multithreaded `DirectorySearcher` control can be used on a form."},{"pos":[30124,30132],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[30184,30295],"content":"<bpt id=\"p1\">[</bpt>Developing Custom Windows Forms Controls with the .NET Framework<ept id=\"p1\">](developing-custom-windows-forms-controls.md)</ept>","source":"[Developing Custom Windows Forms Controls with the .NET Framework](developing-custom-windows-forms-controls.md)"},{"pos":[30298,30439],"content":"<bpt id=\"p1\">[</bpt>Event-based Asynchronous Pattern Overview<ept id=\"p1\">](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)</ept>","source":"[Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)"}]}