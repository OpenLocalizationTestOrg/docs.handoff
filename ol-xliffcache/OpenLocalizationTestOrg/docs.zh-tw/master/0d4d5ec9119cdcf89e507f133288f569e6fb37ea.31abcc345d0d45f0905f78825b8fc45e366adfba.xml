{"content":"---\ntitle: \"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorProfilerInfo2.GetClassFromTokenAndTypeArgs\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs\"\nhelpviewer_keywords: \n  - \"GetClassFromTokenAndTypeArgs method [.NET Framework profiling]\"\n  - \"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs method [.NET Framework profiling]\"\nms.assetid: b25c88f0-71b9-443b-8eea-1c94db0a44b9\ntopic_type: \n  - \"apiref\"\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method\nGets the `ClassID` of a type by using the specified metadata token and the `ClassID` values of any type arguments.  \n  \n## Syntax  \n  \n```  \nHRESULT GetClassFromTokenAndTypeArgs(  \n    [in] ModuleID moduleID,  \n    [in] mdTypeDef typeDef,  \n    [in] ULONG32 cTypeArgs,  \n    [in, size_is(cTypeArgs)] ClassID typeArgs[],  \n    [out] ClassID* pClassID);  \n```  \n  \n## Parameters  \n `moduleID`  \n [in] The ID of the module in which the type resides.  \n  \n `typeDef`  \n [in] An `mdTypeDef` metadata token that references the type.  \n  \n `cTypeArgs`  \n [in] The number of type parameters for the given type. This value must be zero for non-generic types.  \n  \n `typeArgs`  \n [in] An array of `ClassID` values, each of which is an argument of the type. The value of `typeArgs` can be NULL if `cTypeArgs` is set to zero.  \n  \n `pClassID`  \n [out] A pointer to the `ClassID` of the specified type.  \n  \n## Remarks  \n Calling the `GetClassFromTokenAndTypeArgs` method with an `mdTypeRef` instead of an `mdTypeDef` metadata token can have unpredictable results; callers should resolve the `mdTypeRef` to an `mdTypeDef` when passing it.  \n  \n If the type is not already loaded, calling `GetClassFromTokenAndTypeArgs` will trigger loading, which is a dangerous operation in many contexts. For example, calling this method during loading of modules or other types could lead to an infinite loop as the runtime attempts to circularly load things.  \n  \n In general, use of `GetClassFromTokenAndTypeArgs` is discouraged. If profilers are interested in events for a particular type, they should store the `ModuleID` and `mdTypeDef` of that type, and use [ICorProfilerInfo2::GetClassIDInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getclassidinfo2-method.md) to check whether a given `ClassID` is that of the desired type.  \n  \n## Requirements  \n **Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).  \n  \n **Header:** CorProf.idl, CorProf.h  \n  \n **Library:** CorGuids.lib  \n  \n **.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]  \n  \n## See also\n\n- [ICorProfilerInfo Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)\n- [ICorProfilerInfo2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)\n","nodes":[{"pos":[4,567],"embed":true,"restype":"x-metadata","content":"title: \"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method\"\nms.date: \"03/30/2017\"\napi_name: \n  - \"ICorProfilerInfo2.GetClassFromTokenAndTypeArgs\"\napi_location: \n  - \"mscorwks.dll\"\napi_type: \n  - \"COM\"\nf1_keywords: \n  - \"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs\"\nhelpviewer_keywords: \n  - \"GetClassFromTokenAndTypeArgs method [.NET Framework profiling]\"\n  - \"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs method [.NET Framework profiling]\"\nms.assetid: b25c88f0-71b9-443b-8eea-1c94db0a44b9\ntopic_type: \n  - \"apiref\"\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method","nodes":[{"pos":[0,54],"content":"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method","nodes":[{"content":"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method","pos":[0,54]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[574,628],"content":"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method","linkify":"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method","nodes":[{"content":"ICorProfilerInfo2::GetClassFromTokenAndTypeArgs Method","pos":[0,54]}]},{"pos":[629,743],"content":"Gets the <ph id=\"ph1\">`ClassID`</ph> of a type by using the specified metadata token and the <ph id=\"ph2\">`ClassID`</ph> values of any type arguments.","source":"Gets the `ClassID` of a type by using the specified metadata token and the `ClassID` values of any type arguments."},{"pos":[752,758],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[995,1005],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"[in] The ID of the module in which the type resides.","pos":[1023,1075]},{"content":"[in] An <ph id=\"ph1\">`mdTypeDef`</ph> metadata token that references the type.","pos":[1095,1155],"source":"[in] An `mdTypeDef` metadata token that references the type."},{"content":"[in] The number of type parameters for the given type.","pos":[1177,1231]},{"content":"This value must be zero for non-generic types.","pos":[1232,1278]},{"content":"[in] An array of <ph id=\"ph1\">`ClassID`</ph> values, each of which is an argument of the type.","pos":[1299,1375],"source":"[in] An array of `ClassID` values, each of which is an argument of the type."},{"content":"The value of <ph id=\"ph1\">`typeArgs`</ph> can be NULL if <ph id=\"ph2\">`cTypeArgs`</ph> is set to zero.","pos":[1376,1442],"source":" The value of `typeArgs` can be NULL if `cTypeArgs` is set to zero."},{"content":"[out] A pointer to the <ph id=\"ph1\">`ClassID`</ph> of the specified type.","pos":[1463,1518],"source":"[out] A pointer to the `ClassID` of the specified type."},{"pos":[1527,1534],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"pos":[1538,1754],"content":"Calling the <ph id=\"ph1\">`GetClassFromTokenAndTypeArgs`</ph> method with an <ph id=\"ph2\">`mdTypeRef`</ph> instead of an <ph id=\"ph3\">`mdTypeDef`</ph> metadata token can have unpredictable results; callers should resolve the <ph id=\"ph4\">`mdTypeRef`</ph> to an <ph id=\"ph5\">`mdTypeDef`</ph> when passing it.","source":"Calling the `GetClassFromTokenAndTypeArgs` method with an `mdTypeRef` instead of an `mdTypeDef` metadata token can have unpredictable results; callers should resolve the `mdTypeRef` to an `mdTypeDef` when passing it."},{"content":"If the type is not already loaded, calling <ph id=\"ph1\">`GetClassFromTokenAndTypeArgs`</ph> will trigger loading, which is a dangerous operation in many contexts.","pos":[1761,1905],"source":"If the type is not already loaded, calling `GetClassFromTokenAndTypeArgs` will trigger loading, which is a dangerous operation in many contexts."},{"content":"For example, calling this method during loading of modules or other types could lead to an infinite loop as the runtime attempts to circularly load things.","pos":[1906,2061]},{"content":"In general, use of <ph id=\"ph1\">`GetClassFromTokenAndTypeArgs`</ph> is discouraged.","pos":[2068,2133],"source":"In general, use of `GetClassFromTokenAndTypeArgs` is discouraged."},{"content":"If profilers are interested in events for a particular type, they should store the <ph id=\"ph1\">`ModuleID`</ph> and <ph id=\"ph2\">`mdTypeDef`</ph> of that type, and use <bpt id=\"p1\">[</bpt>ICorProfilerInfo2::GetClassIDInfo2<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getclassidinfo2-method.md)</ept> to check whether a given <ph id=\"ph3\">`ClassID`</ph> is that of the desired type.","pos":[2134,2462],"source":" If profilers are interested in events for a particular type, they should store the `ModuleID` and `mdTypeDef` of that type, and use [ICorProfilerInfo2::GetClassIDInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getclassidinfo2-method.md) to check whether a given `ClassID` is that of the desired type."},{"pos":[2471,2483],"content":"Requirements","linkify":"Requirements","nodes":[{"content":"Requirements","pos":[0,12]}]},{"pos":[2487,2591],"content":"<bpt id=\"p1\">**</bpt>Platforms:<ept id=\"p1\">**</ept> See <bpt id=\"p2\">[</bpt>System Requirements<ept id=\"p2\">](../../../../docs/framework/get-started/system-requirements.md)</ept>.","source":"**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md)."},{"pos":[2598,2632],"content":"<bpt id=\"p1\">**</bpt>Header:<ept id=\"p1\">**</ept> CorProf.idl, CorProf.h","source":"**Header:** CorProf.idl, CorProf.h"},{"pos":[2639,2664],"content":"<bpt id=\"p1\">**</bpt>Library:<ept id=\"p1\">**</ept> CorGuids.lib","source":"**Library:** CorGuids.lib"},{"pos":[2671,2779],"content":"<bpt id=\"p1\">**</bpt>.NET Framework Versions:<ept id=\"p1\">**</ept> <ph id=\"ph1\">[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</ph>","source":"**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]"},{"pos":[2788,2796],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2800,2910],"content":"<bpt id=\"p1\">[</bpt>ICorProfilerInfo Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)</ept>","source":"[ICorProfilerInfo Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)"},{"pos":[2913,3025],"content":"<bpt id=\"p1\">[</bpt>ICorProfilerInfo2 Interface<ept id=\"p1\">](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)</ept>","source":"[ICorProfilerInfo2 Interface](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)"}]}