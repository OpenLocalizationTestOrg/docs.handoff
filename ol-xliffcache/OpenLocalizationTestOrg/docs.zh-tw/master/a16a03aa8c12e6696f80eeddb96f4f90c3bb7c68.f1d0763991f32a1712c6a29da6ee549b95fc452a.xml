{"content":"---\ntitle: \"Troubleshooting Procedures (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"troubleshooting Visual Basic, procedures\"\n  - \"procedures, troubleshooting\"\n  - \"Visual Basic code, procedures\"\n  - \"troubleshooting procedures\"\n  - \"procedures, about procedures\"\nms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b\ncaps.latest.revision: 17\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# Troubleshooting Procedures (Visual Basic)\nThis page lists some common problems that can occur when working with procedures.  \n  \n## Returning an Array Type from a Function Procedure  \n If a `Function` procedure returns an array data type, you cannot use the `Function` name to store values in the elements of the array. If you attempt to do this, the compiler interprets it as a call to the `Function`. The following example generates compiler errors.  \n  \n `Function allOnes(ByVal n As Integer) As Integer()`  \n  \n `For i As Integer = 1 To n - 1`  \n  \n `' The following statement generates a`   `COMPILER ERROR`  `.`  \n  \n `allOnes(i) = 1`  \n  \n `Next i`  \n  \n `' The following statement generates a`   `COMPILER ERROR`  `.`  \n  \n `Return allOnes()`  \n  \n `End Function`  \n  \n The statement `allOnes(i) = 1` generates a compiler error because it appears to call `allOnes` with an argument of the wrong data type (a singleton `Integer` instead of an `Integer` array). The statement `Return allOnes()` generates a compiler error because it appears to call `allOnes` with no argument.  \n  \n **Correct Approach:** To be able to modify the elements of an array that is to be returned, define an internal array as a local variable. The following example compiles without error.  \n  \n [!code-vb[VbVbcnProcedures#66](./codesnippet/VisualBasic/troubleshooting-procedures_1.vb)]  \n  \n## Argument Not Being Modified by Procedure Call  \n If you intend to allow a procedure to change a programming element underlying an argument in the calling code, you must pass it by reference. But a procedure can access the elements of a reference type argument even if you pass it by value.  \n  \n-   **Underlying Variable**. To allow the procedure to replace the value of the underlying variable element itself, the procedure must declare the parameter [ByRef](../../../../visual-basic/language-reference/modifiers/byref.md). Also, the calling code must not enclose the argument in parentheses, because that would override the `ByRef` passing mechanism.  \n  \n-   **Reference Type Elements**. If you declare a parameter [ByVal](../../../../visual-basic/language-reference/modifiers/byval.md), the procedure cannot modify the underlying variable element itself. However, if the argument is a reference type, the procedure can modify the members of the object to which it points, even though it cannot replace the variable's value. For example, if the argument is an array variable, the procedure cannot assign a new array to it, but it can change one or more of its elements. The changed elements are reflected in the underlying array variable in the calling code.  \n  \n The following example defines two procedures that take an array variable by value and operate on its elements. Procedure `increase` simply adds one to each element. Procedure `replace` assigns a new array to the parameter `a()` and then adds one to each element. However, the reassignment does not affect the underlying array variable in the calling code because `a()` is declared `ByVal`.  \n  \n [!code-vb[VbVbcnProcedures#35](./codesnippet/VisualBasic/troubleshooting-procedures_2.vb)]  \n  \n [!code-vb[VbVbcnProcedures#38](./codesnippet/VisualBasic/troubleshooting-procedures_3.vb)]  \n  \n The following example makes calls to `increase` and `replace`.  \n  \n [!code-vb[VbVbcnProcedures#37](./codesnippet/VisualBasic/troubleshooting-procedures_4.vb)]  \n  \n The first `MsgBox` call displays \"After increase(n): 11, 21, 31, 41\". Because `n` is a reference type, `increase` can change its members, even though it is passed `ByVal`.  \n  \n The second `MsgBox` call displays \"After replace(n): 11, 21, 31, 41\". Because `n` is passed `ByVal`, `replace` cannot modify the variable `n` by assigning a new array to it. When `replace` creates the new array instance `k` and assigns it to the local variable `a`, it loses the reference to `n` passed in by the calling code. When it increments the members of `a`, only the local array `k` is affected.  \n  \n **Correct Approach:** To be able to modify an underlying variable element itself, pass it by reference. The following example shows the change in the declaration of `replace` that allows it to replace one array with another in the calling code.  \n  \n [!code-vb[VbVbcnProcedures#64](./codesnippet/VisualBasic/troubleshooting-procedures_5.vb)]  \n  \n## Unable to Define an Overload  \n If you want to define an overloaded version of a procedure, you must use the same name but a different signature. If the compiler cannot differentiate your declaration from an overload with the same signature, it generates an error.  \n  \n The *signature* of a procedure is determined by the procedure name and the parameter list. Each overload must have the same name as all the other overloads but must differ from all of them in at least one of the other components of the signature. For more information, see [Procedure Overloading](./procedure-overloading.md).  \n  \n The following items, even though they pertain to the parameter list, are not components of a procedure's signature:  \n  \n-   Procedure modifier keywords, such as `Public`, `Shared`, and `Static`  \n  \n-   Parameter names  \n  \n-   Parameter modifier keywords, such as `ByRef` and `Optional`  \n  \n-   The data type of the return value (except for a conversion operator)  \n  \n You cannot overload a procedure by varying only one or more of the preceding items.  \n  \n **Correct Approach:** To be able to define a procedure overload, you must vary the signature. Because you must use the same name, you must vary the number, order, or data types of the parameters. In a generic procedure, you can vary the number of type parameters. In a conversion operator ([CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md)), you can vary the return type.  \n  \n### Overload Resolution with Optional and ParamArray Arguments  \n If you are overloading a procedure with one or more [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) parameters or a [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) parameter, you must avoid duplicating any of the *implicit overloads*. For information, see [Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md).  \n  \n## Calling a Wrong Version of an Overloaded Procedure  \n If a procedure has several overloaded versions, you should be familiar with all their parameter lists and understand how [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] resolves calls among the overloads. Otherwise you could call an overload other than the intended one.  \n  \n When you have determined which overload you want to call, be careful to observe the following rules:  \n  \n-   Supply the correct number of arguments, and in the correct order.  \n  \n-   Ideally, your arguments should have the exact same data types as the corresponding parameters. In any case, the data type of each argument must widen to that of its corresponding parameter. This is true even with the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) set to `Off`. If an overload requires any narrowing conversion from your argument list, that overload is not eligible to be called.  \n  \n-   If you supply arguments that require widening, make their data types as close as possible to the corresponding parameter data types. If two or more overloads accept your argument data types, the compiler resolves your call to the overload that calls for the least amount of widening.  \n  \n You can reduce the chance of data type mismatches by using the [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md) conversion keyword when preparing your arguments.  \n  \n### Overload Resolution Failure  \n When you call an overloaded procedure, the compiler attempts to eliminate all but one of the overloads. If it succeeds, it resolves the call to that overload. If it eliminates all the overloads, or if it cannot reduce the eligible overloads to a single candidate, it generates an error.  \n  \n The following example illustrates the overload resolution process.  \n  \n [!code-vb[VbVbcnProcedures#62](./codesnippet/VisualBasic/troubleshooting-procedures_6.vb)]  \n  \n [!code-vb[VbVbcnProcedures#63](./codesnippet/VisualBasic/troubleshooting-procedures_7.vb)]  \n  \n In the first call, the compiler eliminates the first overload because the type of the first argument (`Short`) narrows to the type of the corresponding parameter (`Byte`). It then eliminates the third overload because each argument type in the second overload (`Short` and `Single`) widens to the corresponding type in the third overload (`Integer` and `Single`). The second overload requires less widening, so the compiler uses it for the call.  \n  \n In the second call, the compiler cannot eliminate any of the overloads on the basis of narrowing. It eliminates the third overload for the same reason as in the first call, because it can call the second overload with less widening of the argument types. However, the compiler cannot resolve between the first and second overloads. Each has one defined parameter type that widens to the corresponding type in the other (`Byte` to `Short`, but `Single` to `Double`). The compiler therefore generates an overload resolution error.  \n  \n **Correct Approach:** To be able to call an overloaded procedure without ambiguity, use [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md) to match the argument data types to the parameter types. The following example shows a call to `z` that forces resolution to the second overload.  \n  \n [!code-vb[VbVbcnProcedures#65](./codesnippet/VisualBasic/troubleshooting-procedures_8.vb)]  \n  \n### Overload Resolution with Optional and ParamArray Arguments  \n If two overloads of a procedure have identical signatures except that the last parameter is declared [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) in one and [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) in the other, the compiler resolves a call to that procedure according to the closest match. For more information, see [Overload Resolution](./overload-resolution.md).  \n  \n## See Also  \n [Procedures](./index.md)   \n [Sub Procedures](./sub-procedures.md)   \n [Function Procedures](./function-procedures.md)   \n [Property Procedures](./property-procedures.md)   \n [Operator Procedures](./operator-procedures.md)   \n [Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md)   \n [Procedure Overloading](./procedure-overloading.md)   \n [Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md)   \n [Overload Resolution](./overload-resolution.md)","nodes":[{"pos":[4,743],"nodes":[{"content":"Troubleshooting Procedures (Visual Basic) | Microsoft Docs","nodes":[{"pos":[0,58],"content":"Troubleshooting Procedures (Visual Basic) | Microsoft Docs","nodes":[{"content":"Troubleshooting Procedures (Visual Basic) | Microsoft Docs","pos":[0,58]}]}],"pos":[6,67],"yaml":true}],"content":"title: \"Troubleshooting Procedures (Visual Basic) | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-visual-basic\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\nhelpviewer_keywords: \n  - \"troubleshooting Visual Basic, procedures\"\n  - \"procedures, troubleshooting\"\n  - \"Visual Basic code, procedures\"\n  - \"troubleshooting procedures\"\n  - \"procedures, about procedures\"\nms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b\ncaps.latest.revision: 17\nauthor: dotnet-bot\nms.author: dotnetcontent\n\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","yamlblock":true},{"pos":[750,791],"content":"Troubleshooting Procedures (Visual Basic)","linkify":"Troubleshooting Procedures (Visual Basic)","nodes":[{"content":"Troubleshooting Procedures (Visual Basic)","pos":[0,41]}]},{"content":"This page lists some common problems that can occur when working with procedures.","pos":[792,873]},{"pos":[882,931],"content":"Returning an Array Type from a Function Procedure","linkify":"Returning an Array Type from a Function Procedure","nodes":[{"content":"Returning an Array Type from a Function Procedure","pos":[0,49]}]},{"content":"If a <ph id=\"ph1\">`Function`</ph> procedure returns an array data type, you cannot use the <ph id=\"ph2\">`Function`</ph> name to store values in the elements of the array.","pos":[935,1069],"source":"If a `Function` procedure returns an array data type, you cannot use the `Function` name to store values in the elements of the array."},{"content":"If you attempt to do this, the compiler interprets it as a call to the <ph id=\"ph1\">`Function`</ph>.","pos":[1070,1152],"source":" If you attempt to do this, the compiler interprets it as a call to the `Function`."},{"content":"The following example generates compiler errors.","pos":[1153,1201]},{"pos":[1304,1367],"content":"<ph id=\"ph1\">`' The following statement generates a`</ph>   <ph id=\"ph2\">`COMPILER ERROR`</ph>  <ph id=\"ph3\">`.`</ph>","source":"`' The following statement generates a`   `COMPILER ERROR`  `.`"},{"pos":[1412,1475],"content":"<ph id=\"ph1\">`' The following statement generates a`</ph>   <ph id=\"ph2\">`COMPILER ERROR`</ph>  <ph id=\"ph3\">`.`</ph>","source":"`' The following statement generates a`   `COMPILER ERROR`  `.`"},{"content":"The statement <ph id=\"ph1\">`allOnes(i) = 1`</ph> generates a compiler error because it appears to call <ph id=\"ph2\">`allOnes`</ph> with an argument of the wrong data type (a singleton <ph id=\"ph3\">`Integer`</ph> instead of an <ph id=\"ph4\">`Integer`</ph> array).","pos":[1528,1717],"source":"The statement `allOnes(i) = 1` generates a compiler error because it appears to call `allOnes` with an argument of the wrong data type (a singleton `Integer` instead of an `Integer` array)."},{"content":"The statement <ph id=\"ph1\">`Return allOnes()`</ph> generates a compiler error because it appears to call <ph id=\"ph2\">`allOnes`</ph> with no argument.","pos":[1718,1832],"source":" The statement `Return allOnes()` generates a compiler error because it appears to call `allOnes` with no argument."},{"content":"<bpt id=\"p1\">**</bpt>Correct Approach:<ept id=\"p1\">**</ept> To be able to modify the elements of an array that is to be returned, define an internal array as a local variable.","pos":[1839,1976],"source":"**Correct Approach:** To be able to modify the elements of an array that is to be returned, define an internal array as a local variable."},{"content":"The following example compiles without error.","pos":[1977,2022]},{"pos":[2029,2119],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#66<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_1.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#66](./codesnippet/VisualBasic/troubleshooting-procedures_1.vb)]"},{"pos":[2128,2173],"content":"Argument Not Being Modified by Procedure Call","linkify":"Argument Not Being Modified by Procedure Call","nodes":[{"content":"Argument Not Being Modified by Procedure Call","pos":[0,45]}]},{"content":"If you intend to allow a procedure to change a programming element underlying an argument in the calling code, you must pass it by reference.","pos":[2177,2318]},{"content":"But a procedure can access the elements of a reference type argument even if you pass it by value.","pos":[2319,2417]},{"content":"<bpt id=\"p1\">**</bpt>Underlying Variable<ept id=\"p1\">**</ept>.","pos":[2427,2451],"source":"**Underlying Variable**."},{"content":"To allow the procedure to replace the value of the underlying variable element itself, the procedure must declare the parameter <bpt id=\"p1\">[</bpt>ByRef<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/byref.md)</ept>.","pos":[2452,2652],"source":" To allow the procedure to replace the value of the underlying variable element itself, the procedure must declare the parameter [ByRef](../../../../visual-basic/language-reference/modifiers/byref.md)."},{"content":"Also, the calling code must not enclose the argument in parentheses, because that would override the <ph id=\"ph1\">`ByRef`</ph> passing mechanism.","pos":[2653,2780],"source":" Also, the calling code must not enclose the argument in parentheses, because that would override the `ByRef` passing mechanism."},{"content":"<bpt id=\"p1\">**</bpt>Reference Type Elements<ept id=\"p1\">**</ept>.","pos":[2790,2818],"source":"**Reference Type Elements**."},{"content":"If you declare a parameter <bpt id=\"p1\">[</bpt>ByVal<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/byval.md)</ept>, the procedure cannot modify the underlying variable element itself.","pos":[2819,2986],"source":" If you declare a parameter [ByVal](../../../../visual-basic/language-reference/modifiers/byval.md), the procedure cannot modify the underlying variable element itself."},{"content":"However, if the argument is a reference type, the procedure can modify the members of the object to which it points, even though it cannot replace the variable's value.","pos":[2987,3155]},{"content":"For example, if the argument is an array variable, the procedure cannot assign a new array to it, but it can change one or more of its elements.","pos":[3156,3300]},{"content":"The changed elements are reflected in the underlying array variable in the calling code.","pos":[3301,3389]},{"content":"The following example defines two procedures that take an array variable by value and operate on its elements.","pos":[3396,3506]},{"content":"Procedure <ph id=\"ph1\">`increase`</ph> simply adds one to each element.","pos":[3507,3560],"source":" Procedure `increase` simply adds one to each element."},{"content":"Procedure <ph id=\"ph1\">`replace`</ph> assigns a new array to the parameter <ph id=\"ph2\">`a()`</ph> and then adds one to each element.","pos":[3561,3658],"source":" Procedure `replace` assigns a new array to the parameter `a()` and then adds one to each element."},{"content":"However, the reassignment does not affect the underlying array variable in the calling code because <ph id=\"ph1\">`a()`</ph> is declared <ph id=\"ph2\">`ByVal`</ph>.","pos":[3659,3785],"source":" However, the reassignment does not affect the underlying array variable in the calling code because `a()` is declared `ByVal`."},{"pos":[3792,3882],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#35<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_2.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#35](./codesnippet/VisualBasic/troubleshooting-procedures_2.vb)]"},{"pos":[3889,3979],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#38<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_3.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#38](./codesnippet/VisualBasic/troubleshooting-procedures_3.vb)]"},{"pos":[3986,4048],"content":"The following example makes calls to <ph id=\"ph1\">`increase`</ph> and <ph id=\"ph2\">`replace`</ph>.","source":"The following example makes calls to `increase` and `replace`."},{"pos":[4055,4145],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#37<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_4.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#37](./codesnippet/VisualBasic/troubleshooting-procedures_4.vb)]"},{"content":"The first <ph id=\"ph1\">`MsgBox`</ph> call displays \"After increase(n): 11, 21, 31, 41\".","pos":[4152,4221],"source":"The first `MsgBox` call displays \"After increase(n): 11, 21, 31, 41\"."},{"content":"Because <ph id=\"ph1\">`n`</ph> is a reference type, <ph id=\"ph2\">`increase`</ph> can change its members, even though it is passed <ph id=\"ph3\">`ByVal`</ph>.","pos":[4222,4323],"source":" Because `n` is a reference type, `increase` can change its members, even though it is passed `ByVal`."},{"content":"The second <ph id=\"ph1\">`MsgBox`</ph> call displays \"After replace(n): 11, 21, 31, 41\".","pos":[4330,4399],"source":"The second `MsgBox` call displays \"After replace(n): 11, 21, 31, 41\"."},{"content":"Because <ph id=\"ph1\">`n`</ph> is passed <ph id=\"ph2\">`ByVal`</ph>, <ph id=\"ph3\">`replace`</ph> cannot modify the variable <ph id=\"ph4\">`n`</ph> by assigning a new array to it.","pos":[4400,4503],"source":" Because `n` is passed `ByVal`, `replace` cannot modify the variable `n` by assigning a new array to it."},{"content":"When <ph id=\"ph1\">`replace`</ph> creates the new array instance <ph id=\"ph2\">`k`</ph> and assigns it to the local variable <ph id=\"ph3\">`a`</ph>, it loses the reference to <ph id=\"ph4\">`n`</ph> passed in by the calling code.","pos":[4504,4656],"source":" When `replace` creates the new array instance `k` and assigns it to the local variable `a`, it loses the reference to `n` passed in by the calling code."},{"content":"When it increments the members of <ph id=\"ph1\">`a`</ph>, only the local array <ph id=\"ph2\">`k`</ph> is affected.","pos":[4657,4733],"source":" When it increments the members of `a`, only the local array `k` is affected."},{"content":"<bpt id=\"p1\">**</bpt>Correct Approach:<ept id=\"p1\">**</ept> To be able to modify an underlying variable element itself, pass it by reference.","pos":[4740,4843],"source":"**Correct Approach:** To be able to modify an underlying variable element itself, pass it by reference."},{"content":"The following example shows the change in the declaration of <ph id=\"ph1\">`replace`</ph> that allows it to replace one array with another in the calling code.","pos":[4844,4984],"source":" The following example shows the change in the declaration of `replace` that allows it to replace one array with another in the calling code."},{"pos":[4991,5081],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#64<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_5.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#64](./codesnippet/VisualBasic/troubleshooting-procedures_5.vb)]"},{"pos":[5090,5118],"content":"Unable to Define an Overload","linkify":"Unable to Define an Overload","nodes":[{"content":"Unable to Define an Overload","pos":[0,28]}]},{"content":"If you want to define an overloaded version of a procedure, you must use the same name but a different signature.","pos":[5122,5235]},{"content":"If the compiler cannot differentiate your declaration from an overload with the same signature, it generates an error.","pos":[5236,5354]},{"content":"The <bpt id=\"p1\">*</bpt>signature<ept id=\"p1\">*</ept> of a procedure is determined by the procedure name and the parameter list.","pos":[5361,5451],"source":"The *signature* of a procedure is determined by the procedure name and the parameter list."},{"content":"Each overload must have the same name as all the other overloads but must differ from all of them in at least one of the other components of the signature.","pos":[5452,5607]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Procedure Overloading<ept id=\"p1\">](./procedure-overloading.md)</ept>.","pos":[5608,5686],"source":" For more information, see [Procedure Overloading](./procedure-overloading.md)."},{"content":"The following items, even though they pertain to the parameter list, are not components of a procedure's signature:","pos":[5693,5808]},{"pos":[5818,5887],"content":"Procedure modifier keywords, such as <ph id=\"ph1\">`Public`</ph>, <ph id=\"ph2\">`Shared`</ph>, and <ph id=\"ph3\">`Static`</ph>","source":"Procedure modifier keywords, such as `Public`, `Shared`, and `Static`"},{"content":"Parameter names","pos":[5897,5912]},{"pos":[5922,5981],"content":"Parameter modifier keywords, such as <ph id=\"ph1\">`ByRef`</ph> and <ph id=\"ph2\">`Optional`</ph>","source":"Parameter modifier keywords, such as `ByRef` and `Optional`"},{"content":"The data type of the return value (except for a conversion operator)","pos":[5991,6059]},{"content":"You cannot overload a procedure by varying only one or more of the preceding items.","pos":[6066,6149]},{"content":"<bpt id=\"p1\">**</bpt>Correct Approach:<ept id=\"p1\">**</ept> To be able to define a procedure overload, you must vary the signature.","pos":[6156,6249],"source":"**Correct Approach:** To be able to define a procedure overload, you must vary the signature."},{"content":"Because you must use the same name, you must vary the number, order, or data types of the parameters.","pos":[6250,6351]},{"content":"In a generic procedure, you can vary the number of type parameters.","pos":[6352,6419]},{"content":"In a conversion operator (<bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept>), you can vary the return type.","pos":[6420,6567],"source":" In a conversion operator ([CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md)), you can vary the return type."},{"pos":[6577,6635],"content":"Overload Resolution with Optional and ParamArray Arguments","linkify":"Overload Resolution with Optional and ParamArray Arguments","nodes":[{"content":"Overload Resolution with Optional and ParamArray Arguments","pos":[0,58]}]},{"content":"If you are overloading a procedure with one or more <bpt id=\"p1\">[</bpt>Optional<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/optional.md)</ept> parameters or a <bpt id=\"p2\">[</bpt>ParamArray<ept id=\"p2\">](../../../../visual-basic/language-reference/modifiers/paramarray.md)</ept> parameter, you must avoid duplicating any of the <bpt id=\"p3\">*</bpt>implicit overloads<ept id=\"p3\">*</ept>.","pos":[6639,6937],"source":"If you are overloading a procedure with one or more [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) parameters or a [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) parameter, you must avoid duplicating any of the *implicit overloads*."},{"content":"For information, see <bpt id=\"p1\">[</bpt>Considerations in Overloading Procedures<ept id=\"p1\">](./considerations-in-overloading-procedures.md)</ept>.","pos":[6938,7049],"source":" For information, see [Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md)."},{"pos":[7058,7108],"content":"Calling a Wrong Version of an Overloaded Procedure","linkify":"Calling a Wrong Version of an Overloaded Procedure","nodes":[{"content":"Calling a Wrong Version of an Overloaded Procedure","pos":[0,50]}]},{"content":"If a procedure has several overloaded versions, you should be familiar with all their parameter lists and understand how <ph id=\"ph1\">[!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]</ph> resolves calls among the overloads.","pos":[7112,7361],"source":"If a procedure has several overloaded versions, you should be familiar with all their parameter lists and understand how [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] resolves calls among the overloads."},{"content":"Otherwise you could call an overload other than the intended one.","pos":[7362,7427]},{"content":"When you have determined which overload you want to call, be careful to observe the following rules:","pos":[7434,7534]},{"content":"Supply the correct number of arguments, and in the correct order.","pos":[7544,7609]},{"content":"Ideally, your arguments should have the exact same data types as the corresponding parameters.","pos":[7619,7713]},{"content":"In any case, the data type of each argument must widen to that of its corresponding parameter.","pos":[7714,7808]},{"content":"This is true even with the <bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept> set to <ph id=\"ph1\">`Off`</ph>.","pos":[7809,7958],"source":" This is true even with the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md) set to `Off`."},{"content":"If an overload requires any narrowing conversion from your argument list, that overload is not eligible to be called.","pos":[7959,8076]},{"content":"If you supply arguments that require widening, make their data types as close as possible to the corresponding parameter data types.","pos":[8086,8218]},{"content":"If two or more overloads accept your argument data types, the compiler resolves your call to the overload that calls for the least amount of widening.","pos":[8219,8369]},{"pos":[8376,8578],"content":"You can reduce the chance of data type mismatches by using the <bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept> conversion keyword when preparing your arguments.","source":"You can reduce the chance of data type mismatches by using the [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md) conversion keyword when preparing your arguments."},{"pos":[8588,8615],"content":"Overload Resolution Failure","linkify":"Overload Resolution Failure","nodes":[{"content":"Overload Resolution Failure","pos":[0,27]}]},{"content":"When you call an overloaded procedure, the compiler attempts to eliminate all but one of the overloads.","pos":[8619,8722]},{"content":"If it succeeds, it resolves the call to that overload.","pos":[8723,8777]},{"content":"If it eliminates all the overloads, or if it cannot reduce the eligible overloads to a single candidate, it generates an error.","pos":[8778,8905]},{"content":"The following example illustrates the overload resolution process.","pos":[8912,8978]},{"pos":[8985,9075],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#62<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_6.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#62](./codesnippet/VisualBasic/troubleshooting-procedures_6.vb)]"},{"pos":[9082,9172],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#63<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_7.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#63](./codesnippet/VisualBasic/troubleshooting-procedures_7.vb)]"},{"content":"In the first call, the compiler eliminates the first overload because the type of the first argument (<ph id=\"ph1\">`Short`</ph>) narrows to the type of the corresponding parameter (<ph id=\"ph2\">`Byte`</ph>).","pos":[9179,9350],"source":"In the first call, the compiler eliminates the first overload because the type of the first argument (`Short`) narrows to the type of the corresponding parameter (`Byte`)."},{"content":"It then eliminates the third overload because each argument type in the second overload (<ph id=\"ph1\">`Short`</ph> and <ph id=\"ph2\">`Single`</ph>) widens to the corresponding type in the third overload (<ph id=\"ph3\">`Integer`</ph> and <ph id=\"ph4\">`Single`</ph>).","pos":[9351,9542],"source":" It then eliminates the third overload because each argument type in the second overload (`Short` and `Single`) widens to the corresponding type in the third overload (`Integer` and `Single`)."},{"content":"The second overload requires less widening, so the compiler uses it for the call.","pos":[9543,9624]},{"content":"In the second call, the compiler cannot eliminate any of the overloads on the basis of narrowing.","pos":[9631,9728]},{"content":"It eliminates the third overload for the same reason as in the first call, because it can call the second overload with less widening of the argument types.","pos":[9729,9885]},{"content":"However, the compiler cannot resolve between the first and second overloads.","pos":[9886,9962]},{"content":"Each has one defined parameter type that widens to the corresponding type in the other (<ph id=\"ph1\">`Byte`</ph> to <ph id=\"ph2\">`Short`</ph>, but <ph id=\"ph3\">`Single`</ph> to <ph id=\"ph4\">`Double`</ph>).","pos":[9963,10096],"source":" Each has one defined parameter type that widens to the corresponding type in the other (`Byte` to `Short`, but `Single` to `Double`)."},{"content":"The compiler therefore generates an overload resolution error.","pos":[10097,10159]},{"content":"<bpt id=\"p1\">**</bpt>Correct Approach:<ept id=\"p1\">**</ept> To be able to call an overloaded procedure without ambiguity, use <bpt id=\"p2\">[</bpt>CType Function<ept id=\"p2\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept> to match the argument data types to the parameter types.","pos":[10166,10400],"source":"**Correct Approach:** To be able to call an overloaded procedure without ambiguity, use [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md) to match the argument data types to the parameter types."},{"content":"The following example shows a call to <ph id=\"ph1\">`z`</ph> that forces resolution to the second overload.","pos":[10401,10489],"source":" The following example shows a call to `z` that forces resolution to the second overload."},{"pos":[10496,10586],"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>VbVbcnProcedures#65<ept id=\"p2\">](./codesnippet/VisualBasic/troubleshooting-procedures_8.vb)</ept><ept id=\"p1\">]</ept>","source":"[!code-vb[VbVbcnProcedures#65](./codesnippet/VisualBasic/troubleshooting-procedures_8.vb)]"},{"pos":[10596,10654],"content":"Overload Resolution with Optional and ParamArray Arguments","linkify":"Overload Resolution with Optional and ParamArray Arguments","nodes":[{"content":"Overload Resolution with Optional and ParamArray Arguments","pos":[0,58]}]},{"content":"If two overloads of a procedure have identical signatures except that the last parameter is declared <bpt id=\"p1\">[</bpt>Optional<ept id=\"p1\">](../../../../visual-basic/language-reference/modifiers/optional.md)</ept> in one and <bpt id=\"p2\">[</bpt>ParamArray<ept id=\"p2\">](../../../../visual-basic/language-reference/modifiers/paramarray.md)</ept> in the other, the compiler resolves a call to that procedure according to the closest match.","pos":[10658,11022],"source":"If two overloads of a procedure have identical signatures except that the last parameter is declared [Optional](../../../../visual-basic/language-reference/modifiers/optional.md) in one and [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) in the other, the compiler resolves a call to that procedure according to the closest match."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Overload Resolution<ept id=\"p1\">](./overload-resolution.md)</ept>.","pos":[11023,11097],"source":" For more information, see [Overload Resolution](./overload-resolution.md)."},{"pos":[11106,11114],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Procedures<ept id=\"p1\">](./index.md)</ept><ph id=\"ph1\"> </ph>","pos":[11118,11143],"source":"[Procedures](./index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Sub Procedures<ept id=\"p1\">](./sub-procedures.md)</ept><ph id=\"ph1\"> </ph>","pos":[11147,11185],"source":"[Sub Procedures](./sub-procedures.md) "},{"content":"<bpt id=\"p1\">[</bpt>Function Procedures<ept id=\"p1\">](./function-procedures.md)</ept><ph id=\"ph1\"> </ph>","pos":[11189,11237],"source":"[Function Procedures](./function-procedures.md) "},{"content":"<bpt id=\"p1\">[</bpt>Property Procedures<ept id=\"p1\">](./property-procedures.md)</ept><ph id=\"ph1\"> </ph>","pos":[11241,11289],"source":"[Property Procedures](./property-procedures.md) "},{"content":"<bpt id=\"p1\">[</bpt>Operator Procedures<ept id=\"p1\">](./operator-procedures.md)</ept><ph id=\"ph1\"> </ph>","pos":[11293,11341],"source":"[Operator Procedures](./operator-procedures.md) "},{"content":"<bpt id=\"p1\">[</bpt>Procedure Parameters and Arguments<ept id=\"p1\">](./procedure-parameters-and-arguments.md)</ept><ph id=\"ph1\"> </ph>","pos":[11345,11423],"source":"[Procedure Parameters and Arguments](./procedure-parameters-and-arguments.md) "},{"content":"<bpt id=\"p1\">[</bpt>Procedure Overloading<ept id=\"p1\">](./procedure-overloading.md)</ept><ph id=\"ph1\"> </ph>","pos":[11427,11479],"source":"[Procedure Overloading](./procedure-overloading.md) "},{"content":"<bpt id=\"p1\">[</bpt>Considerations in Overloading Procedures<ept id=\"p1\">](./considerations-in-overloading-procedures.md)</ept><ph id=\"ph1\"> </ph>","pos":[11483,11573],"source":"[Considerations in Overloading Procedures](./considerations-in-overloading-procedures.md) "},{"content":"<bpt id=\"p1\">[</bpt>Overload Resolution<ept id=\"p1\">](./overload-resolution.md)</ept>","pos":[11577,11624],"source":"[Overload Resolution](./overload-resolution.md)"}]}