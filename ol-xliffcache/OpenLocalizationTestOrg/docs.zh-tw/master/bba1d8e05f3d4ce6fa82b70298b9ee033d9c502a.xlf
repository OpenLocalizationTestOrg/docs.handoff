<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bba1d8e05f3d4ce6fa82b70298b9ee033d9c502a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\controls\control-authoring-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0011fdfc866ad0b8b0900afca7681c5ea755a093</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a63c13fa6604946dc1d7f7b696ea5bac0bfa652e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Control Authoring Overview | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Control Authoring Overview</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The extensibility of the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> control model greatly reduces the need to create a new control.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>However, in certain cases you may still need to create a custom control.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic discusses the features that minimize your need to create a custom control and the different control authoring models in <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic also demonstrates how to create a new control.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Alternatives to Writing a New Control</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Although that is still an option, <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Rich Content.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Many of the standard <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls support rich content.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example, the content property of a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> is of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>, so theoretically anything can be displayed on a <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To have a button display an image and text, you can add an image and a <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> to a <ph id="ph2">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> and assign the <ph id="ph3">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> to the <ph id="ph4">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Because the controls can display <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information about the content model for <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> and other content models in <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, see <bpt id="p1">[</bpt>WPF Content Model<ept id="p1">](../../../../docs/framework/wpf/controls/wpf-content-model.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Styles.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> is a collection of values that represent properties for a control.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For example, assume that you want all of your <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> controls to have red, Arial font with a font size of 14.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can create a style as a resource and set the appropriate properties accordingly.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Then every <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> that you add to your application will have the same appearance.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Data Templates.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> enables you to customize how data is displayed on a control.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, a <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> can be used to specify how data is displayed in a <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For an example of this, see <bpt id="p1">[</bpt>Data Templating Overview<ept id="p1">](../../../../docs/framework/wpf/data/data-templating-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In addition to customizing the appearance of data, a <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> can include UI elements, which gives you a lot of flexibility in custom UIs.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example, by using a <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph>, you can create a <ph id="ph2">&lt;xref:System.Windows.Controls.ComboBox&gt;</ph> in which each item contains a check box.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Control Templates.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Many controls in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> use a <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can drastically change the appearance of a control by redefining its <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, suppose you want a control that looks like a stoplight.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This control has a simple user interface and functionality.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The control is three circles, only one of which can be lit up at a time.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After some reflection, you might realize that a <ph id="ph1">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> offers the functionality of only one being selected at a time, but the default appearance of the <ph id="ph2">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> looks nothing like the lights on a stoplight.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> uses a control template to define its appearance, it is easy to redefine the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to fit the requirements of the control, and use radio buttons to make your stoplight.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Although a <ph id="ph1">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> can use a <ph id="ph2">&lt;xref:System.Windows.DataTemplate&gt;</ph>, a <ph id="ph3">&lt;xref:System.Windows.DataTemplate&gt;</ph> is not sufficient in this example.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> defines the appearance of the content of a control.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the case of a <ph id="ph1">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph>, the content is whatever appears to the right of the circle that indicates whether the <ph id="ph2">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph> is selected.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In the example of the stoplight, the radio button needs just be a circle that can "light up."</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Because the appearance requirement for the stoplight is so different than the default appearance of the <ph id="ph1">&lt;xref:System.Windows.Controls.RadioButton&gt;</ph>, it is necessary to redefine the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In general a <ph id="ph1">&lt;xref:System.Windows.DataTemplate&gt;</ph> is used for defining the content (or data) of a control, and a <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is used for defining how a control is structured.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Triggers.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> allows you to dynamically change the appearance and behavior of a control without creating a new control.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For example, suppose you have multiple <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> controls in your application and want the items in each <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> to be bold and red when they are selected.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Your first instinct might be to create a class that inherits from <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> and override the <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A&gt;</ph> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <ph id="ph3">&lt;xref:System.Windows.Controls.ListBoxItem&gt;</ph> that changes the appearance of the selected item.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A trigger enables you to change property values or take actions based on the value of a property.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> enables you to take actions when an event occurs.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information about styles, templates, and triggers, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](../../../../docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Models for Control Authoring</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>However, if you do need to create a new control, it is important to understand the different control authoring models in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The base classes for the three models are <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Deriving from UserControl</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The simplest way to create a control in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is to derive from <ph id="ph2">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>When you build a control that inherits from <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, you add existing components to the <ph id="ph2">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, name the components, and reference event handlers in <ph id="ph3">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You can then reference the named elements and define the event handlers in code.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This development model is very similar to the model used for application development in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If built correctly, a <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> can take advantage of the benefits of rich content, styles, and triggers.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>However, if your control inherits from <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, people who use your control will not be able to use a <ph id="ph2">&lt;xref:System.Windows.DataTemplate&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to customize its appearance.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It is necessary to derive from the <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> class or one of its derived classes (other than <ph id="ph2">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>) to create a custom control that supports templates.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Benefits of Deriving from UserControl</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Consider deriving from <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> if all of the following apply:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You want to build your control similarly to how you build an application.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Your control consists only of existing components.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You don't need to support complex customization.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Deriving from Control</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Deriving from the <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> class is the model used by most of the existing <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>When you create a control that inherits from the <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> class, you define its appearance by using templates.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>By doing so, you separate the operational logic from the visual representation.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> whenever possible.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> to customize its appearance.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Although building a custom <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> is not as simple as building a <ph id="ph2">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, a custom <ph id="ph3">&lt;xref:System.Windows.Controls.Control&gt;</ph> provides the most flexibility.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Benefits of Deriving from Control</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Consider deriving from <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> instead of using the <ph id="ph2">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> class if any of the following apply:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You want the appearance of your control to be customizable via the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You want your control to support different themes.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Deriving from FrameworkElement</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Controls that derive from <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> rely upon composing existing elements.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For many scenarios, this is an acceptable solution, because any object that inherits from <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> can be in a <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>However, there are times when a control's appearance requires more than the functionality of simple element composition.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For these scenarios, basing a component on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is the right choice.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>There are two standard methods for building <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>-based components: direct rendering and custom element composition.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Direct rendering involves overriding the <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRender%2A&gt;</ph> method of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and providing <ph id="ph3">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> operations that explicitly define the component visuals.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This is the method used by <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Border&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Custom element composition involves using objects of type <ph id="ph1">&lt;xref:System.Windows.Media.Visual&gt;</ph> to compose the appearance of your component.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For an example, see <bpt id="p1">[</bpt>Using DrawingVisual Objects<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.Track&gt;</ph> is an example of a control in <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> that uses custom element composition.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>It is also possible to mix direct rendering and custom element composition in the same control.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Benefits of Deriving from FrameworkElement</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Consider deriving from <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> if any of the following apply:</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You want to define the appearance of your control by defining your own render logic.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You want to compose existing elements in novel ways that go beyond what is possible with <ph id="ph1">&lt;xref:System.Windows.Controls.UserControl&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Control Authoring Basics</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>As discussed earlier, one of the most powerful features of <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The styling, data binding, and trigger features are made possible by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system and the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event system.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Use Dependency Properties</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>When a property is a dependency property, it is possible to do the following:</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Set the property in a style.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Bind the property to a data source.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Use a dynamic resource as the property's value.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Animate the property.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following example defines a dependency property named <ph id="ph1">`Value`</ph> by doing the following:</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Define a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier named <ph id="ph2">`ValueProperty`</ph> as a <ph id="ph3">`public`</ph> <ph id="ph4">`static`</ph> <ph id="ph5">`readonly`</ph> field.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Register the property name with the property system, by calling <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A?displayProperty=fullName&gt;</ph>, to specify the following:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The type of the property.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The type that owns the property.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The metadata for the property.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The metadata contains the property's default value, a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> and a <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Define a <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> wrapper property named <ph id="ph2">`Value`</ph>, which is the same name that is used to register the dependency property, by implementing the property's <ph id="ph3">`get`</ph> and <ph id="ph4">`set`</ph> accessors.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors only call <ph id="ph3">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> respectively.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>It is recommended that the accessors of dependency properties not contain additional logic because clients and <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> can bypass the accessors and call <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> directly.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>For example, when a property is bound to a data source, the property's <ph id="ph1">`set`</ph> accessor is not called.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Instead of adding additional logic to the get and set accessors, use the <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> delegates to respond to or check the value when it changes.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For more information on these callbacks, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Define a method for the <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> named <ph id="ph2">`CoerceValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CoerceValue`</ph> ensures that <ph id="ph2">`Value`</ph> is greater or equal to <ph id="ph3">`MinValue`</ph> and less than or equal to <ph id="ph4">`MaxValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Define a method for the <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, named <ph id="ph2">`OnValueChanged`</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`OnValueChanged`</ph> creates a <ph id="ph2">&lt;xref:System.Windows.RoutedPropertyChangedEventArgs%601&gt;</ph> object and prepares to raise the <ph id="ph3">`ValueChanged`</ph> routed event.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Routed events are discussed in the next section.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UserControlNumericUpDown#DependencyProperty<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>UserControlNumericUpDown#DependencyProperty<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Use Routed Events</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Just as dependency properties extend the notion of <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> properties with additional functionality, routed events extend the notion of standard <ph id="ph2">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> events.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>When you create a new <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Events can be handled on a parent of multiple controls.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Then application authors can use one handler to respond to the event of multiple controls.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example, if your control is a part of each item in a <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> (because it is included in a <ph id="ph2">&lt;xref:System.Windows.DataTemplate&gt;</ph>), the application developer can define the event handler for your control's event on the <ph id="ph3">&lt;xref:System.Windows.Controls.ListBox&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Whenever the event occurs on any of the controls, the event handler is called.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Routed events can be used in an <ph id="ph1">&lt;xref:System.Windows.EventSetter&gt;</ph>, which enables application developers to specify the handler of an event within a style.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Routed events can be used in an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>, which is useful for animating properties by using <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The following example defines a routed event by doing the following:</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Define a <ph id="ph1">&lt;xref:System.Windows.RoutedEvent&gt;</ph> identifier named <ph id="ph2">`ValueChangedEvent`</ph> as a <ph id="ph3">`public`</ph> <ph id="ph4">`static`</ph> <ph id="ph5">`readonly`</ph> field.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Register the routed event by calling the <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The example specifies the following information when it calls <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The name of the event is <ph id="ph1">`ValueChanged`</ph>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The routing strategy is <ph id="ph1">&lt;xref:System.Windows.RoutingStrategy&gt;</ph>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The type of the event handler is <ph id="ph1">&lt;xref:System.Windows.RoutedPropertyChangedEventHandler%601&gt;</ph>, constructed with a <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The owning type of the event is <ph id="ph1">`NumericUpDown`</ph>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Declare a public event named <ph id="ph1">`ValueChanged`</ph> and includes event-accessor declarations.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The example calls <ph id="ph1">&lt;xref:System.Windows.UIElement.AddHandler%2A&gt;</ph> in the <ph id="ph2">`add`</ph> accessor declaration and <ph id="ph3">&lt;xref:System.Windows.UIElement.RemoveHandler%2A&gt;</ph> in the <ph id="ph4">`remove`</ph> accessor declaration to use the <ph id="ph5">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> event services.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Create a protected, virtual method named <ph id="ph1">`OnValueChanged`</ph> that raises the <ph id="ph2">`ValueChanged`</ph> event.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UserControlNumericUpDown#RoutedEvent<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>UserControlNumericUpDown#RoutedEvent<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/routed-events-overview.md)</ept> and <bpt id="p2">[</bpt>Create a Custom Routed Event<ept id="p2">](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Use Binding</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>To decouple the UI of your control from its logic, consider using data binding.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This is particularly important if you define the appearance of your control by using a <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>It's a good idea to avoid referencing elements that are in the <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> because when the code references elements that are in the <ph id="ph2">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> and the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> is changed, the referenced element needs to be included in the new <ph id="ph4">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The following example updates the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> of the <ph id="ph2">`NumericUpDown`</ph> control, assigning a name to it and referencing the textbox by name in code.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>UserControlNumericUpDownSimple#UIRefMarkup<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>UserControlNumericUpDownSimple#UIRefCode<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>UserControlNumericUpDownSimple#UIRefCode<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The following example uses binding to accomplish the same thing.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>UserControlNumericUpDown#Binding<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>For more information about data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](../../../../docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Design for Designers</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>To receive support for custom WPF controls in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)]</ph> (for example, property editing with the Properties window), follow these guidelines.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>For more information on developing for the <ph id="ph1">[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]</ph>, see <bpt id="p1">[</bpt>WPF Designer<ept id="p1">](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26)</ept>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Dependency Properties</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Be sure to implement <ph id="ph1">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> <ph id="ph2">`get`</ph> and <ph id="ph3">`set`</ph> accessors as described earlier, in "Use Dependency Properties."</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Designers may use the wrapper to detect the presence of a dependency property, but they, like <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> and clients of the control, are not required to call the accessors when getting or setting the property.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Attached Properties</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You should implement attached properties on custom controls using the following guidelines:</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Have a <ph id="ph1">`public`</ph> <ph id="ph2">`static`</ph> <ph id="ph3">`readonly`</ph> <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> of the form <bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept><ph id="ph5">`Property`</ph> that was creating using the <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The property name that is passed to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> must match <bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Implement a pair of <ph id="ph1">`public`</ph> <ph id="ph2">`static`</ph> CLR methods named <ph id="ph3">`Set`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> and <ph id="ph4">`Get`</ph><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Both methods should accept a class derived from <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as their first argument.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Set`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> method also accepts an argument whose type matches the registered data type for the property.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Get`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> method should return a value of the same type.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>If the <ph id="ph1">`Set`</ph><bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> method is missing, the property is marked read-only.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Set`</ph> <bpt id="p1">*</bpt>PropertyName<ept id="p1">*</ept> and <ph id="ph2">`Get`</ph><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> must route directly to the <ph id="ph3">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> methods on the target dependency object, respectively.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>For more information on attached properties, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Define and Use Shared Resources</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>For the most part, the information discussed in this topic applies regardless of the method you use.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>There is one difference worth noting, however.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>But an assembly that contains only controls does not have an <ph id="ph1">&lt;xref:System.Windows.Application&gt;</ph> object associated with it, so an App.xaml file is not available.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>When an application looks for a resource, it looks at three levels in the following order:</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The element level.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The application level.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Resources defined by the <ph id="ph1">&lt;xref:System.Windows.Application&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The theme level.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Theme-level dictionaries are stored in a subfolder named Themes.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The files in the Themes folder correspond to themes.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>You can also have a file named generic.xaml.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Both methods have their advantages.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Defining Resources at the Element Level</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control’s resource dictionary.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Resources at the element level can also use simple strings as keys.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Windows.Media.LinearGradientBrush&gt;</ph> resource file named Dictionary1.xaml.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>SharedResources#1<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>You can do this by using <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> or code.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The following example merges a resource dictionary by using <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>SharedResources#2<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The disadvantage to this approach is that a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> object is created each time you reference it.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>You can avoid this by creating a static class that merges the resources in code and returns the resulting <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following example creates a class that returns a shared <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SharedResources#3<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls <ph id="ph1">`InitilizeComponent`</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Because the <ph id="ph1">`SharedDictionaryManager.SharedDictionary`</ph> is a static property, the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is created only once.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Because the resource dictionary was merged before <ph id="ph1">`InitializeComponent`</ph> was called, the resources are available to the control in its <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> file.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>SharedResources#4<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Defining Resources at the Theme Level</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> enables you to create resources for different Windows themes.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>For example, the appearance of a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> in the Windows Classic theme (the default theme for Windows 2000) differs from a <ph id="ph2">&lt;xref:System.Windows.Controls.Button&gt;</ph> in the Windows Luna theme (the default theme for Windows XP) because the <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph> uses a different <ph id="ph4">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> for each theme.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>These files must be in a folder named <ph id="ph1">`Themes`</ph> that is a subfolder of the folder that contains the control.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The following table lists the resource dictionary files and the theme that is associated with each file:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Resource dictionary file name</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Windows theme</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Classic Windows 9x/2000 look on Windows XP</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Default blue theme on Windows XP</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Olive theme on Windows XP</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Silver theme on Windows XP</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Default theme on Windows XP Media Center Edition</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Default theme on Windows Vista</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>You do not need to define a resource for every theme.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>If a resource is not defined for a specific theme, then the control checks <ph id="ph1">`Classic.xaml`</ph> for the resource.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>If the resource is not defined in the file that corresponds to the current theme or in <ph id="ph1">`Classic.xaml`</ph>, the control uses the generic resource, which is in a resource dictionary file named <ph id="ph2">`generic.xaml`</ph>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`generic.xaml`</ph> file is located in the same folder as the theme-specific resource dictionary files.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Although <ph id="ph1">`generic.xaml`</ph> does not correspond to a specific Windows theme, it is still a theme-level dictionary.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>NumericUpDown Custom Control with Theme and UI Automation Support Sample<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=160025)</ept> contains two resource dictionaries for the <ph id="ph1">`NumericUpDown`</ph> control: one is in generic.xaml and one is in Luna.NormalColor.xaml.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>You can run the application and switch between the Silver theme in Windows XP and another theme to see the difference between the two control templates.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>(If you are running Windows Vista, you can rename Luna.NormalColor.xaml to Aero.NormalColor.xaml and switch between two themes, such as Windows Classic and the default theme for Windows Vista.)</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>When you put a <ph id="ph1">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph>, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>CustomControlNumericUpDownOneProject#StaticConstructor<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>CustomControlNumericUpDownOneProject#StaticConstructor<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Defining and Referencing Keys for Theme Resources</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>When you define a resource at the theme level, you must use a <ph id="ph1">&lt;xref:System.Windows.ComponentResourceKey&gt;</ph> as the key.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following example defines a resource in generic.xaml.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>ThemeResourcesControlLibrary#5<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>The following example references the resource by specifying the <ph id="ph1">&lt;xref:System.Windows.ComponentResourceKey&gt;</ph> as the key.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-xml</bpt><bpt id="p2">[</bpt>ThemeResourcesControlLibrary#6<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Specifying the Location of Theme Resources</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>You can accomplish that by adding the <ph id="ph1">&lt;xref:System.Windows.ThemeInfoAttribute&gt;</ph> to the assembly that contains the control.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.ThemeInfoAttribute&gt;</ph> has a <ph id="ph2">&lt;xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A&gt;</ph> property that specifies the location of generic resources, and a <ph id="ph3">&lt;xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A&gt;</ph> property that specifies the location of the theme-specific resources.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A&gt;</ph> properties to <ph id="ph3">&lt;xref:System.Windows.ResourceDictionaryLocation&gt;</ph>, to specify that the generic and theme-specific resources are in the same assembly as the control.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>CustomControlNumericUpDown#ThemesSection<ept id="p2">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>CustomControlNumericUpDown#ThemesSection<ept id="p4">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>WPF Designer<ept id="p1">](http://msdn.microsoft.com/en-us/c6c65214-8411-4e16-b254-163ed4099c26)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Pack URIs in WPF<ept id="p1">](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Control Customization<ept id="p1">](../../../../docs/framework/wpf/controls/control-customization.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>