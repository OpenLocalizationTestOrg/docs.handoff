<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="serialization-and-deserialization.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d9afa49525f03c06f94b1b7b704fb3d9caa9e19d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\serialization-and-deserialization.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a269063e7b1f5439056209685b3f3391134352a9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d4efd69e2fddc30205bb39cf58f4acfaddd5600a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Serialization and Deserialization</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Serialization and Deserialization</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Windows Communication Foundation (WCF) includes a new serialization engine, the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> translates between <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> objects and XML, in both directions.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic explains how the serializer works.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>When serializing <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> objects, the serializer understands a variety of serialization programming models, including the new <bpt id="p1">*</bpt>data contract<ept id="p1">*</ept> model.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>For a full list of supported types, see <bpt id="p1">[</bpt>Types Supported by the Data Contract Serializer<ept id="p1">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For an introduction to data contracts, see <bpt id="p1">[</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When deserializing XML, the serializer uses the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also supports the <ph id="ph1">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>WCF also includes a companion serializer, the <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> is similar to the <ph id="ph2">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter&gt;</ph> serializers because it also emits <ph id="ph4">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> type names as part of the serialized data.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>It is used when the same types are shared on the serializing and the deserializing ends.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Both the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> derive from a common base class, the <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This may cause a problem with a non-WCF client when sending such data to a WCF service.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Creating a DataContractSerializer Instance</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Constructing an instance of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> is an important step.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>After construction, you cannot change any of the settings.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Specifying the Root Type</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>root type<ept id="p1">*</ept> is the type of which instances are serialized or deserialized.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> has many constructor overloads, but, at a minimum, a root type must be supplied using the <ph id="ph2">`type`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The following example shows two classes.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This code constructs an instance of the <ph id="ph1">`DataContractSerializer`</ph> that can be used only to serialize or deserialize instances of the <ph id="ph2">`Person`</ph> class.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Specifying Known Types</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If polymorphism is involved in the types being serialized that is not already handled using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the <ph id="ph2">`knownTypes`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For more information about known types, see <bpt id="p1">[</bpt>Data Contract Known Types<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following example shows a class, <ph id="ph1">`LibraryPatron`</ph>, that includes a collection of a specific type, the <ph id="ph2">`LibraryItem`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The second class defines the <ph id="ph1">`LibraryItem`</ph> type.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The third and four classes (<ph id="ph1">`Book`</ph> and <ph id="ph2">`Newspaper`</ph>) inherit from the <ph id="ph3">`LibraryItem`</ph> class.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following code constructs an instance of the serializer using the <ph id="ph1">`knownTypes`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Specifying the Default Root Name and Namespace</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The following example sets <ph id="ph1">`Name`</ph> and <ph id="ph2">`Namespace`</ph> values in the constructors of the <ph id="ph3">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Serializing an instance of the <ph id="ph1">`Person`</ph> class produces XML similar to the following.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>However, you can customize the default name and namespace of the root element by passing the values of the <ph id="ph1">`rootName`</ph> and <ph id="ph2">`rootNamespace`</ph> parameters to the <ph id="ph3">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`rootNamespace`</ph> does not affect the namespace of the contained elements that correspond to data members.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It affects only the namespace of the outermost element.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>These values can be passed as strings or instances of the <ph id="ph1">&lt;xref:System.Xml.XmlDictionaryString&gt;</ph> class to allow for their optimization using the binary XML format.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Setting the Maximum Objects Quota</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Some <ph id="ph1">`DataContractSerializer`</ph> constructor overloads have a <ph id="ph2">`maxItemsInObjectGraph`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> method call.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>(The method always reads one root object, but this object may have other objects in its data members.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Those objects may have other objects, and so on.) The default is 65536.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Note that when serializing or deserializing arrays, every array entry counts as a separate object.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Security Considerations for Data<ept id="p1">](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Round Trips</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>round trip<ept id="p1">*</ept> occurs when an object is deserialized and re-serialized in one operation.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Thus, it goes from XML to an object instance, and back again into an XML stream.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Some <ph id="ph1">`DataContractSerializer`</ph> constructor overloads have an <ph id="ph2">`ignoreExtensionDataObject`</ph> parameter, which is set to <ph id="ph3">`false`</ph> by default.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For example, suppose version 1 of the <ph id="ph1">`Person`</ph> data contract contains the <ph id="ph2">`Name`</ph> and <ph id="ph3">`PhoneNumber`</ph> data members, and version 2 adds a <ph id="ph4">`Nickname`</ph> member.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If <ph id="ph1">`IExtensibleDataObject`</ph> is implemented, when sending information from version 2 to version 1, the <ph id="ph2">`Nickname`</ph> data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Forward-Compatible Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)</ept> and <bpt id="p2">[</bpt>Data Contract Versioning<ept id="p2">](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Security and Schema Validity Concerns with Round Trips</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Round trips may have security implications.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For example, deserializing and storing large amounts of extraneous data may be a security risk.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example, in the previous scenario, the version 1 endpoint could be signing a <ph id="ph1">`Nickname`</ph> value that contains malicious data.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In the previous example, the version 1 endpoint’s contract says that it emits only <ph id="ph1">`Name`</ph> and <ph id="ph2">`PhoneNumber`</ph>, and if schema validation is being used, emitting the extra <ph id="ph3">`Nickname`</ph> value causes validation to fail.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Enabling and Disabling Round Trips</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To turn off round trips, do not implement the <ph id="ph1">&lt;xref:System.Runtime.Serialization.IExtensibleDataObject&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If you have no control over the types, set the <ph id="ph1">`ignoreExtensionDataObject`</ph> parameter to <ph id="ph2">`true`</ph> to achieve the same effect.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Object Graph Preservation</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Normally, the serializer does not care about object identity, as in the following code.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following code creates a purchase order.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Notice that <ph id="ph1">`billTo`</ph> and <ph id="ph2">`shipTo`</ph> fields are set to the same object instance.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>However, this approach has the following characteristics, which may be undesirable:</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Performance.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Replicating data is inefficient.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Circular references.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>(The serializer throws a <ph id="ph1">&lt;xref:System.Runtime.Serialization.SerializationException&gt;</ph> if this happens.)</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Semantics.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For these reasons, some <ph id="ph1">`DataContractSerializer`</ph> constructor overloads have a <ph id="ph2">`preserveObjectReferences`</ph> parameter (the default is <ph id="ph3">`false`</ph>).</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>When this parameter is set to <ph id="ph1">`true`</ph>, a special method of encoding object references, which only WCF understands, is used.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When set to <ph id="ph1">`true`</ph>, the XML code example now resembles the following.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The "ser" namespace refers to the standard serialization namespace, <ph id="ph1">`http://schemas.microsoft.com/2003/10/Serialization/`</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If both "id" and "ref" attributes are present in the data contract <ph id="ph1">`XMLElement`</ph>, then the "ref" attribute is honored and the "id" attribute is ignored.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>It is important to understand the limitations of this mode:</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The XML the <ph id="ph1">`DataContractSerializer`</ph> produces with <ph id="ph2">`preserveObjectReferences`</ph> set to <ph id="ph3">`true`</ph> is not interoperable with any other technologies, and can be accessed only by another <ph id="ph4">`DataContractSerializer`</ph> instance, also with <ph id="ph5">`preserveObjectReferences`</ph> set to <ph id="ph6">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>There is no metadata (schema) support for this feature.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The schema that is produced is valid only for the case when <ph id="ph1">`preserveObjectReferences`</ph> is set to <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This feature may cause the serialization and deserialization process to run slower.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Although data does not have to be replicated, extra object comparisons must be performed in this mode.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`preserveObjectReferences`</ph> mode is enabled, it is especially important to set the <ph id="ph2">`maxItemsInObjectGraph`</ph> value to the correct quota.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the <ph id="ph1">`maxItemsInObjectGraph`</ph> quota.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Specifying a Data Contract Surrogate</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Some <ph id="ph1">`DataContractSerializer`</ph> constructor overloads have a <ph id="ph2">`dataContractSurrogate`</ph> parameter, which may be set to <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Otherwise, you can use it to specify a <bpt id="p1">*</bpt>data contract surrogate<ept id="p1">*</ept>, which is a type that implements the <ph id="ph1">&lt;xref:System.Runtime.Serialization.IDataContractSurrogate&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You can then use the interface to customize the serialization and deserialization process.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Data Contract Surrogates<ept id="p1">](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Serialization</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following information applies to any class that inherits from the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph>, including the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Simple Serialization</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The most basic way to serialize an object is to pass it to the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>There are three overloads, one each for writing to a <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph>, an <ph id="ph2">&lt;xref:System.Xml.XmlWriter&gt;</ph>, or an <ph id="ph3">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>With the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> overload, the output is XML in the UTF-8 encoding.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>With the <ph id="ph1">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph> overload, the serializer optimizes its output for binary XML.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When using the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A&gt;</ph> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The following example demonstrates writing with an <ph id="ph1">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>This produces XML similar to the following.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Step-By-Step Serialization</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A&gt;</ph> methods to write the end element, write the object contents, and close the wrapper element, respectively.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>There are no <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> overloads of these methods.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>This step-by-step serialization has two common uses.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>One is to insert contents such as attributes or comments between <ph id="ph1">`WriteStartObject`</ph> and <ph id="ph2">`WriteObjectContent`</ph>,  as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>This produces XML similar to the following.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Another common use is to avoid using <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A&gt;</ph> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This produces XML similar to the following.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Using step-by-step serialization may result in schema-invalid XML.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Deserialization</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The following information applies to any class that inherits from the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer&gt;</ph>, including the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The most basic way to deserialize an object is to call one of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>There are three overloads, one each for reading with a <ph id="ph1">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph>, an <ph id="ph2">`XmlReader`</ph>, or a <ph id="ph3">`Stream`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Note that the <ph id="ph1">`Stream`</ph> overload creates a textual <ph id="ph2">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> that is not protected by any quotas, and should be used only to read trusted data.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Also note that the object the <ph id="ph1">`ReadObject`</ph> method returns must be cast to the appropriate type.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The following code constructs an instance of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataContractSerializer&gt;</ph> and an <ph id="ph2">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph>, then deserializes a <ph id="ph3">`Person`</ph> instance.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You can do this by calling the <ph id="ph1">&lt;xref:System.Xml.XmlReader.Read%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> or its derivation, and testing the <ph id="ph3">&lt;xref:System.Xml.XmlReader.NodeType%2A&gt;</ph>, as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Note that you can read attributes on this wrapper element before handing the reader to <ph id="ph1">`ReadObject`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When using one of the simple <ph id="ph1">`ReadObject`</ph> overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>In the preceding example, the <ph id="ph1">`&lt;Person&gt;`</ph> wrapper element is expected.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A&gt;</ph> method is called to verify that the reader is positioned on an element that is named as expected.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>There is a way to disable this wrapper element name check; some overloads of the <ph id="ph1">`ReadObject`</ph> method take the Boolean parameter <ph id="ph2">`verifyObjectName`</ph>, which is set to <ph id="ph3">`true`</ph> by default.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>When set to <ph id="ph1">`false`</ph>, the name and namespace of the wrapper element is ignored.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Using the NetDataContractSerializer</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The primary difference between the <ph id="ph1">`DataContractSerializer`</ph> and the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer&gt;</ph> is that the <ph id="ph3">`DataContractSerializer`</ph> uses data contract names, whereas the <ph id="ph4">`NetDataContractSerializer`</ph> outputs full <ph id="ph5">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> assembly and type names in the serialized XML.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This means that the exact same types must be shared between the serialization and deserialization endpoints.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>This means that the known types mechanism is not required with the <ph id="ph1">`NetDataContractSerializer`</ph> because the exact types to be deserialized are always known.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>However, several problems can occur:</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Security.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Any type found in the XML being deserialized is loaded.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>This can be exploited to force the loading of malicious types.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`NetDataContractSerializer`</ph> with untrusted data should be done only if a <bpt id="p1">*</bpt>Serialization Binder<ept id="p1">*</ept> is used (using the <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A&gt;</ph> property or constructor parameter).</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The binder permits only safe types to be loaded.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The Binder mechanism is identical to the one that types in the <ph id="ph1">&lt;xref:System.Runtime.Serialization&gt;</ph> namespace use.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Versioning.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Using full type and assembly names in the XML severely restricts how types can be versioned.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Setting the <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A&gt;</ph> property or constructor parameter to <ph id="ph2">&lt;xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple&gt;</ph> instead of the default value of <ph id="ph3">&lt;xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full&gt;</ph> allows for assembly version changes, but not for generic parameter types.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Interoperability.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> type and assembly names are included in the XML, platforms other than the <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> cannot access the resulting data.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Performance.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Writing out the type and assembly names significantly increases the size of the resulting XML.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>This mechanism is similar to binary or SOAP serialization used by <ph id="ph1">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> remoting (specifically, the <ph id="ph2">&lt;xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&gt;</ph> and the <ph id="ph3">&lt;xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">`NetDataContractSerializer`</ph> is similar to using the <ph id="ph2">`DataContractSerializer`</ph>, with the following differences:</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The constructors do not require you to specify a root type.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>You can serialize any type with the same instance of the <ph id="ph1">`NetDataContractSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The constructors do not accept a list of known types.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The known types mechanism is unnecessary if type names are serialized into the XML.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The constructors do not accept a data contract surrogate.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Instead, they accept an <ph id="ph1">&lt;xref:System.Runtime.Serialization.ISurrogateSelector&gt;</ph> parameter called <ph id="ph2">`surrogateSelector`</ph> (which maps to the <ph id="ph3">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A&gt;</ph> property).</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This is a legacy surrogate mechanism.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The constructors accept a parameter called <ph id="ph1">`assemblyFormat`</ph> of the <ph id="ph2">&lt;xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle&gt;</ph> that maps to the <ph id="ph3">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>This is identical to the <ph id="ph1">&lt;xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle&gt;</ph> mechanism in binary or SOAP serialization.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The constructors accept a <ph id="ph1">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> parameter called <ph id="ph2">`context`</ph> that maps to the <ph id="ph3">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>You can use this to pass information into types being serialized.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>This usage is identical to that of the <ph id="ph1">&lt;xref:System.Runtime.Serialization.StreamingContext&gt;</ph> mechanism used in other <ph id="ph2">&lt;xref:System.Runtime.Serialization&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A&gt;</ph> methods are aliases for the <ph id="ph3">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>These exist to provide a more consistent programming model with binary or SOAP serialization.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For more information about these features, see <bpt id="p1">[</bpt>Binary Serialization<ept id="p1">](../../../../docs/standard/serialization/binary-serialization.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The XML formats that the <ph id="ph1">`NetDataContractSerializer`</ph> and the <ph id="ph2">`DataContractSerializer`</ph> use are normally not compatible.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Also, note that the <ph id="ph1">`NetDataContractSerializer`</ph> does not output the full <ph id="ph2">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]</ph> type and assembly name for each node in the object graph.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>It outputs that information only where it is ambiguous.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>That is, it outputs at the root object level and for any polymorphic cases.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Binary Serialization<ept id="p1">](../../../../docs/standard/serialization/binary-serialization.md)</ept></source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Types Supported by the Data Contract Serializer<ept id="p1">](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>