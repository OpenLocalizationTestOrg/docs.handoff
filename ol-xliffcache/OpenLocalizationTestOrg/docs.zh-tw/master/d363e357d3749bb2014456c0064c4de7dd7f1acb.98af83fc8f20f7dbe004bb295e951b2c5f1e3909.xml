{"content":"---\ntitle: Write safe and efficient C# code\ndescription: Recent enhancements to the C# language enable you to write verifiable safe code that the performance previously associated with unsafe code. \nms.date: 10/23/2018\nms.custom: mvc\n---\n# Write safe and efficient C# code\n\nNew features in C# enable you to write verifiable safe code with better performance. If you carefully apply these techniques, fewer scenarios require unsafe code. These features make it easier to use references to value types as method arguments and method returns. When done safely, these techniques minimize copying value types. By using value types, you can minimize the number of allocations and garbage collection passes.\n\nMuch of the sample code in this article uses features added in C# 7.2. To\nuse those features, you must configure your project to use C# 7.2 or later. For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).\n\nThis article focuses on techniques for efficient resource management. One advantage to using value types is that they often avoid heap allocations. The disadvantage is that they're copied by value. This tradeoff makes it harder to optimize algorithms that operate on large amounts of data. New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types. Use these features wisely to minimize both allocations and copy operations. This article explores those new features.\n\nThis article focuses on the following resource management techniques:\n\n- Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.\n- Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.\n- When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.\n- Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier because it may negatively affect performance and could lead to an obscure behavior.\n- Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.\n\nThese techniques force you to balance two competing goals with regard to **references** and **values**. Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory. Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value. These differences highlight the key differences that are important for managing memory resources. **Value types** are typically copied when passed to a method or returned from a method. This behavior includes copying the value of `this` when calling members of a value type. The cost of the copy is related to the size of the type. **Reference types** are allocated on the managed heap. Each new object requires a new allocation, and subsequently must be reclaimed. Both these operations take time. The reference is copied when a reference type is passed as an argument to a method or returned from a method.\n\nThis article uses the following example concept of the 3D-point structure to explain these recommendations:\n\n```csharp\npublic struct Point3D\n{\n    public double X;\n    public double Y;\n    public double Z;\n}\n```\n\nDifferent examples use different implementations of this concept.\n\n## Declare readonly structs for immutable value types\n\nDeclaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type. The compiler enforces that design decision with the following rules:\n\n- All field members must be `readonly`\n- All properties must be read-only, including auto-implemented properties.\n\nThese two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct. The `struct` is immutable. The `Point3D` structure could be defined as an immutable struct as shown in the following example:\n\n```csharp\nreadonly public struct ReadonlyPoint3D\n{\n    public ReadonlyPoint3D(double x, double y, double z)\n    {\n        this.X = x;\n        this.Y = y;\n        this.Z = z;\n    }\n\n    public double X { get; }\n    public double Y { get; }\n    public double Z { get; }\n}\n```\n\nFollow this recommendation whenever your design intent is to create an immutable value type. Any performance improvements are an added benefit. The `readonly struct` clearly expresses your design intent.\n\n## Use `ref readonly return` statements for large structures when possible\n\nYou can return values by reference when the value being returned isn't local to the returning method. Returning by reference means that only the reference is copied, not the structure. In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:\n\n```csharp\npublic Point3D Origin => new Point3D(0,0,0);\n```\n\nHowever, the following property definition can be returned by reference because the returned value is a static member:\n\n```csharp\npublic struct Point3D\n{\n    private static Point3D origin = new Point3D(0,0,0);\n\n    // Dangerous! returning a mutable reference to internal storage\n    public ref Point3D Origin => ref origin;\n\n    // other members removed for space\n}\n```\n\nYou don't want callers modifying the origin, so you should return the value by `readonly ref`:\n\n```csharp\npublic struct Point3D\n{\n    private static Point3D origin = new Point3D(0,0,0);\n\n    public static ref readonly Point3D Origin => ref origin;\n\n    // other members removed for space\n}\n```\n\nReturning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.\n\nAt the call site, callers make the choice to use the `Origin` property as a `readonly ref` or as a value:\n\n[!code-csharp[AssignRefReadonly](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly \"Assigning a ref readonly\")]\n\nThe first assignment in the preceding code makes a copy of the `Origin` constant and assigns\nthat copy. The second assigns a reference. Notice that the `readonly` modifier\nmust be part of the declaration of the variable. The reference to which it refers\ncan't be modified. Attempts to do so result in a compile-time error.\n\nThe `readonly` modifier is required on the declaration of `originReference`.\n\nThe compiler enforces that the caller can't modify the reference. Attempts\nto assign the value directly generate a compile-time error. However, the compiler\ncan't know if any member method modifies the state of the struct.\nTo ensure that the object isn't modified, the compiler creates a copy and\ncalls member references using that copy. Any modifications are to that\ndefensive copy.\n\n## Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`\n\nThe `in` keyword complements the existing `ref`\nand `out` keywords to pass arguments\nby reference. The `in` keyword specifies passing\nthe argument by reference, but the called method doesn't modify\nthe value.\n\nThis addition provides a full vocabulary to express your design intent.\nValue types are copied when passed to a called method when you don't\nspecify any of the following modifiers in the method signature. Each of these modifiers specifies\nthat a variable is passed by reference, avoiding the copy. Each modifier\nexpresses a different intent:\n\n- `out`: This method sets the value of the argument used as this parameter.\n- `ref`: This method may set the value of the argument used as this parameter.\n- `in`: This method doesn't modify the value of the argument used as this parameter.\n\nAdd the `in` modifier to pass an argument by reference and declare\nyour design intent to pass arguments by reference to\navoid unnecessary copying. You don't intend to modify the object used\nas that argument.\n\nThis practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>. For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal. In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.\n\nThe following code shows an example of a method\nthat calculates the distance between two points in 3D space.\n\n[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument \"Specifying an in argument\")]\n\nThe arguments are two structures that each contain three doubles. A double is 8 bytes,\nso each argument is 24 bytes. By specifying the `in` modifier, you pass a 4 byte\nor 8-byte reference to those arguments, depending on the\narchitecture of the machine. The difference in size is small, but it adds\nup when your application calls this method in a tight loop using many different\nvalues.\n\nThe `in` modifier complements `out` and `ref` in other ways as well. You\ncan't create overloads of a method that differ only in the presence of\n`in`, `out`, or `ref`. These new rules extend the same behavior that had always been\ndefined for `out` and `ref` parameters. Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.\n\nThe `in` modifier may be applied to any member that takes parameters:\nmethods, delegates, lambdas, local functions, indexers, operators.\n\nAnother feature of `in` parameters is that you may use literal values or constants\nfor the argument to an `in` parameter. Also, unlike a `ref` or `out` parameter,\nyou don't need to apply the `in` modifier at the call site. The following\ncode shows you two examples of calling the `CalculateDistance` method. The\nfirst uses two local variables passed by reference. The second includes a\ntemporary variable created as part of the method call.\n\n[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument \"Specifying an In argument\")]\n\nThere are several ways in which the compiler enforces the read-only\nnature of an `in` argument.  First of all, the called method\ncan't directly assign to an `in` parameter. It can't directly assign\nto any field of an `in` parameter when that value is a `struct` type. In addition, you can't pass\nan `in` parameter to any method using the `ref` or `out` modifier.\nThese rules apply to any field of an `in` parameter, provided the\nfield is a `struct` type and the parameter is also a `struct` type. In fact, these rules\napply for multiple layers of member access provided the types at all levels\nof member access are `structs`.\nThe compiler enforces that `struct` types passed as  `in` arguments and their\n`struct` members are read-only variables when used as arguments to other methods.\n\nThe use of `in` parameters can avoid the potential performance costs\nof making copies. It doesn't change the semantics of any method call. Therefore,\nyou don't need to specify the `in` modifier at the call site. Omitting the `in` modifier at the call site informs the compiler that it's\nallowed to make a copy of the argument for the following reasons:\n\n- There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.\n- The argument is an expression but doesn't have a known storage variable.\n- An overload exists that differs by the presence or absence of `in`. In that case, the by value overload is a better match.\n\nThese rules are useful as you update existing code to use read-only\nreference arguments. Inside the called method, you can call any instance\nmethod that uses by value parameters. In\nthose instances, a copy of the `in` parameter is created. Because the compiler\nmay create a temporary variable for any `in` parameter, you can also specify default\nvalues for any `in` parameter. The following code specifies the origin\n(point 0,0) as the default value for the second point:\n\n[!code-csharp[InArgumentDefault](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault \"Specifying defaults for an in parameter\")]\n\nTo force the compiler to pass read-only arguments by reference, specify the `in` modifier\non the arguments at the call site, as shown in the following code:\n\n[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument \"Specifying an In argument\")]\n\nThis behavior makes it easier to adopt `in` parameters over time in large\ncodebases where performance gains are possible. You add the `in` modifier\nto method signatures first. Then, you can add the `in` modifier at call sites\nand create `readonly struct` types to enable the compiler to avoid creating\ndefensive copies of `in` parameters in more locations.\n\nThe `in` parameter designation can also be used with reference types or numeric values. However, the benefits in both cases are minimal, if any.\n\n## Never use mutable structs as in `in` argument\n\nThe techniques described above explain how to avoid copies by returning references and passing values by reference. These techniques work best when the argument types are declared as `readonly struct` types. Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments. Consider the following example that calculates the distance of a 3D point from the origin:\n\n[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument \"Specifying an in argument\")]\n\nThe `Point3D` structure is *not* a readonly struct. There are six different property access calls in the body of this method. On first examination, you may have thought these accesses were safe. After all, a `get` accessor shouldn't modify the state of the object. But there's no language rule that enforces that. It's only a common convention. Any type could implement a `get` accessor that modified the internal state. Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member. The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument. In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`.\n\nInstead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects are not needed:\n\n[!code-csharp[readonlyInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument \"Specifying a readonly in argument\")]\n\nThe compiler generates more efficient code when you call members of a\n`readonly struct`: The `this` reference, instead of a copy of the receiver,\nis always an `in` parameter passed by reference to the member method. This optimization\nsaves copying when you use a `readonly struct` as an `in` argument.\n\nYou can see an example program that demonstrates the performance differences using [Benchmark.net](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub. It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference. The use of the immutable struct and pass by reference is fastest.\n\n## Use `ref struct` types to work with blocks or memory on a single stack frame\n\nA related language feature is the ability to declare a value type that\nmust be constrained to a single stack frame. This restriction enables the compiler to make several optimizations. The primary motivation for this feature\nwas <xref:System.Span%601> and related structures. You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.\n\nYou may have similar requirements working with memory created\nusing [`stackalloc`](language-reference/keywords/stackalloc.md) or\nwhen using memory from interop APIs. You can define your own `ref struct` types\nfor those needs.\n\n## `readonly ref struct` type\n\nDeclaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations. The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.\n\n## Conclusions\n\nUsing value types minimizes the number of allocation operations:\n\n- Storage for value types is stack allocated for local variables and method arguments.\n- Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.\n- Storage for value type return values is stack allocated.\n\nContrast that with reference types in those same situations:\n\n- Storage for reference types are heap allocated for local variables and method arguments. The reference is stored on the stack.\n- Storage for reference types that are members of other objects are separately allocated on the heap. The containing object stores the reference.\n- Storage for reference type return values is heap allocated. The reference to that storage is stored on the stack.\n\nMinimizing allocations comes with tradeoffs. You copy more memory when the size of the `struct` is larger than the size of a reference. A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.\n\nThese tradeoffs generally have minimal performance impact. However, for large structs or larger collections, the performance impact increases. The impact can be large in tight loops and hot paths for programs.\n\nThese enhancements to the C# language are designed for performance critical\nalgorithms where minimizing memory allocations is a major factor in achieving the\nnecessary performance. You may find that you don't often use these features in\nthe code you write. However, these enhancements have been adopted throughout .NET. As more and more APIs make use of these features, you'll\nsee the performance of your applications improve.\n\n## See also\n\n- [ref keyword](language-reference/keywords/ref.md)\n- [Ref returns and ref locals](programming-guide/classes-and-structs/ref-returns.md)\n","nodes":[{"pos":[4,233],"embed":true,"restype":"x-metadata","content":"title: Write safe and efficient C# code\ndescription: Recent enhancements to the C# language enable you to write verifiable safe code that the performance previously associated with unsafe code. \nms.date: 10/23/2018\nms.custom: mvc","nodes":[{"content":"Write safe and efficient C# code","nodes":[{"pos":[0,32],"content":"Write safe and efficient C# code","nodes":[{"content":"Write safe and efficient C# code","pos":[0,32]}]}],"path":["title"],"nosxs":false},{"content":"Recent enhancements to the C# language enable you to write verifiable safe code that the performance previously associated with unsafe code.","nodes":[{"pos":[0,140],"content":"Recent enhancements to the C# language enable you to write verifiable safe code that the performance previously associated with unsafe code.","nodes":[{"content":"Recent enhancements to the C# language enable you to write verifiable safe code that the performance previously associated with unsafe code.","pos":[0,140]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[240,272],"content":"Write safe and efficient C# code","linkify":"Write safe and efficient C# code","nodes":[{"content":"Write safe and efficient C# code","pos":[0,32]}]},{"content":"New features in C# enable you to write verifiable safe code with better performance.","pos":[274,358]},{"content":"If you carefully apply these techniques, fewer scenarios require unsafe code.","pos":[359,436]},{"content":"These features make it easier to use references to value types as method arguments and method returns.","pos":[437,539]},{"content":"When done safely, these techniques minimize copying value types.","pos":[540,604]},{"content":"By using value types, you can minimize the number of allocations and garbage collection passes.","pos":[605,700]},{"content":"Much of the sample code in this article uses features added in C# 7.2.","pos":[702,772]},{"content":"To use those features, you must configure your project to use C# 7.2 or later.","pos":[773,851],"source":" To\nuse those features, you must configure your project to use C# 7.2 or later."},{"content":"For more information on setting the language version, see <bpt id=\"p1\">[</bpt>configure the language version<ept id=\"p1\">](language-reference/configure-language-version.md)</ept>.","pos":[852,993],"source":" For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md)."},{"content":"This article focuses on techniques for efficient resource management.","pos":[995,1064]},{"content":"One advantage to using value types is that they often avoid heap allocations.","pos":[1065,1142]},{"content":"The disadvantage is that they're copied by value.","pos":[1143,1192]},{"content":"This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.","pos":[1193,1284]},{"content":"New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.","pos":[1285,1400]},{"content":"Use these features wisely to minimize both allocations and copy operations.","pos":[1401,1476]},{"content":"This article explores those new features.","pos":[1477,1518]},{"content":"This article focuses on the following resource management techniques:","pos":[1520,1589]},{"pos":[1593,1851],"content":"Declare a <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`readonly struct`</ph><ept id=\"p1\">](language-reference/keywords/readonly.md#readonly-struct-example)</ept> to express that a type is <bpt id=\"p2\">**</bpt>immutable<ept id=\"p2\">**</ept> and enables the compiler to save copies when using <bpt id=\"p3\">[</bpt><ph id=\"ph2\">`in`</ph><ept id=\"p3\">](language-reference/keywords/in-parameter-modifier.md)</ept> parameters.","source":"Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters."},{"pos":[1854,2119],"content":"Use a <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`ref readonly`</ph><ept id=\"p1\">](language-reference/keywords/ref.md#reference-return-values)</ept> return when the return value is a <ph id=\"ph2\">`struct`</ph> larger than <ph id=\"ph3\">&lt;xref:System.IntPtr.Size?displayProperty=nameWithType&gt;</ph> and the storage lifetime is greater than the method returning the value.","source":"Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value."},{"pos":[2122,2294],"content":"When the size of a <ph id=\"ph1\">`readonly struct`</ph> is bigger than <ph id=\"ph2\">&lt;xref:System.IntPtr.Size?displayProperty=nameWithType&gt;</ph>, you should pass it as an <ph id=\"ph3\">`in`</ph> parameter for performance reasons.","source":"When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons."},{"pos":[2297,2473],"content":"Never pass a <ph id=\"ph1\">`struct`</ph> as an <ph id=\"ph2\">`in`</ph> parameter unless it's declared with the <ph id=\"ph3\">`readonly`</ph> modifier because it may negatively affect performance and could lead to an obscure behavior.","source":"Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier because it may negatively affect performance and could lead to an obscure behavior."},{"pos":[2476,2686],"content":"Use a <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`ref struct`</ph><ept id=\"p1\">](language-reference/keywords/ref.md#ref-struct-types)</ept>, or a <ph id=\"ph2\">`readonly ref struct`</ph> such as <ph id=\"ph3\">&lt;xref:System.Span%601&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.ReadOnlySpan%601&gt;</ph> to work with memory as a sequence of bytes.","source":"Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes."},{"content":"These techniques force you to balance two competing goals with regard to <bpt id=\"p1\">**</bpt>references<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>values<ept id=\"p2\">**</ept>.","pos":[2688,2791],"source":"These techniques force you to balance two competing goals with regard to **references** and **values**."},{"content":"Variables that are <bpt id=\"p1\">[</bpt>reference types<ept id=\"p1\">](programming-guide/types/index.md#reference-types)</ept> hold a reference to the location in memory.","pos":[2792,2922],"source":" Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory."},{"content":"Variables that are <bpt id=\"p1\">[</bpt>value types<ept id=\"p1\">](programming-guide/types/index.md#value-types)</ept> directly contain their value.","pos":[2923,3031],"source":" Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value."},{"content":"These differences highlight the key differences that are important for managing memory resources.","pos":[3032,3129]},{"content":"<bpt id=\"p1\">**</bpt>Value types<ept id=\"p1\">**</ept> are typically copied when passed to a method or returned from a method.","pos":[3130,3217],"source":"**Value types** are typically copied when passed to a method or returned from a method."},{"content":"This behavior includes copying the value of <ph id=\"ph1\">`this`</ph> when calling members of a value type.","pos":[3218,3306],"source":" This behavior includes copying the value of `this` when calling members of a value type."},{"content":"The cost of the copy is related to the size of the type.","pos":[3307,3363]},{"content":"<bpt id=\"p1\">**</bpt>Reference types<ept id=\"p1\">**</ept> are allocated on the managed heap.","pos":[3364,3418],"source":"**Reference types** are allocated on the managed heap."},{"content":"Each new object requires a new allocation, and subsequently must be reclaimed.","pos":[3419,3497]},{"content":"Both these operations take time.","pos":[3498,3530]},{"content":"The reference is copied when a reference type is passed as an argument to a method or returned from a method.","pos":[3531,3640]},{"content":"This article uses the following example concept of the 3D-point structure to explain these recommendations:","pos":[3642,3749]},{"content":"Different examples use different implementations of this concept.","pos":[3855,3920]},{"pos":[3925,3975],"content":"Declare readonly structs for immutable value types","linkify":"Declare readonly structs for immutable value types","nodes":[{"content":"Declare readonly structs for immutable value types","pos":[0,50]}]},{"content":"Declaring a <ph id=\"ph1\">`struct`</ph> using the <ph id=\"ph2\">`readonly`</ph> modifier informs the compiler that your intent is to create an immutable type.","pos":[3977,4097],"source":"Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type."},{"content":"The compiler enforces that design decision with the following rules:","pos":[4098,4166]},{"pos":[4170,4206],"content":"All field members must be <ph id=\"ph1\">`readonly`</ph>","source":"All field members must be `readonly`"},{"content":"All properties must be read-only, including auto-implemented properties.","pos":[4209,4281]},{"content":"These two rules are sufficient to ensure that no member of a <ph id=\"ph1\">`readonly struct`</ph> modifies the state of that struct.","pos":[4283,4396],"source":"These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct."},{"content":"The <ph id=\"ph1\">`struct`</ph> is immutable.","pos":[4397,4423],"source":" The `struct` is immutable."},{"content":"The <ph id=\"ph1\">`Point3D`</ph> structure could be defined as an immutable struct as shown in the following example:","pos":[4424,4522],"source":" The `Point3D` structure could be defined as an immutable struct as shown in the following example:"},{"content":"Follow this recommendation whenever your design intent is to create an immutable value type.","pos":[4799,4891]},{"content":"Any performance improvements are an added benefit.","pos":[4892,4942]},{"content":"The <ph id=\"ph1\">`readonly struct`</ph> clearly expresses your design intent.","pos":[4943,5002],"source":" The `readonly struct` clearly expresses your design intent."},{"pos":[5007,5078],"content":"Use <ph id=\"ph1\">`ref readonly return`</ph> statements for large structures when possible","linkify":"Use `ref readonly return` statements for large structures when possible","source":"Use `ref readonly return` statements for large structures when possible"},{"content":"You can return values by reference when the value being returned isn't local to the returning method.","pos":[5080,5181]},{"content":"Returning by reference means that only the reference is copied, not the structure.","pos":[5182,5264]},{"content":"In the following example, the <ph id=\"ph1\">`Origin`</ph> property can't use a <ph id=\"ph2\">`ref`</ph> return because the value being returned is a local variable:","pos":[5265,5391],"source":" In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:"},{"content":"However, the following property definition can be returned by reference because the returned value is a static member:","pos":[5453,5571]},{"pos":[5824,5918],"content":"You don't want callers modifying the origin, so you should return the value by <ph id=\"ph1\">`readonly ref`</ph>:","source":"You don't want callers modifying the origin, so you should return the value by `readonly ref`:"},{"pos":[6119,6250],"content":"Returning <ph id=\"ph1\">`ref readonly`</ph> enables you to save copying larger structures and preserve the immutability of your internal data members.","source":"Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members."},{"pos":[6252,6357],"content":"At the call site, callers make the choice to use the <ph id=\"ph1\">`Origin`</ph> property as a <ph id=\"ph2\">`readonly ref`</ph> or as a value:","source":"At the call site, callers make the choice to use the `Origin` property as a `readonly ref` or as a value:"},{"content":"The first assignment in the preceding code makes a copy of the <ph id=\"ph1\">`Origin`</ph> constant and assigns that copy.","pos":[6512,6615],"source":"The first assignment in the preceding code makes a copy of the `Origin` constant and assigns\nthat copy."},{"content":"The second assigns a reference.","pos":[6616,6647]},{"content":"Notice that the <ph id=\"ph1\">`readonly`</ph> modifier must be part of the declaration of the variable.","pos":[6648,6732],"source":" Notice that the `readonly` modifier\nmust be part of the declaration of the variable."},{"content":"The reference to which it refers can't be modified.","pos":[6733,6784],"source":" The reference to which it refers\ncan't be modified."},{"content":"Attempts to do so result in a compile-time error.","pos":[6785,6834]},{"pos":[6836,6912],"content":"The <ph id=\"ph1\">`readonly`</ph> modifier is required on the declaration of <ph id=\"ph2\">`originReference`</ph>.","source":"The `readonly` modifier is required on the declaration of `originReference`."},{"content":"The compiler enforces that the caller can't modify the reference.","pos":[6914,6979]},{"content":"Attempts to assign the value directly generate a compile-time error.","pos":[6980,7048],"source":" Attempts\nto assign the value directly generate a compile-time error."},{"content":"However, the compiler can't know if any member method modifies the state of the struct.","pos":[7049,7136],"source":" However, the compiler\ncan't know if any member method modifies the state of the struct."},{"content":"To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.","pos":[7137,7251],"source":"\nTo ensure that the object isn't modified, the compiler creates a copy and\ncalls member references using that copy."},{"content":"Any modifications are to that defensive copy.","pos":[7252,7297],"source":" Any modifications are to that\ndefensive copy."},{"pos":[7302,7390],"content":"Apply the <ph id=\"ph1\">`in`</ph> modifier to <ph id=\"ph2\">`readonly struct`</ph> parameters larger than <ph id=\"ph3\">`System.IntPtr.Size`</ph>","linkify":"Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`","source":"Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`"},{"content":"The <ph id=\"ph1\">`in`</ph> keyword complements the existing <ph id=\"ph2\">`ref`</ph> and <ph id=\"ph3\">`out`</ph> keywords to pass arguments by reference.","pos":[7392,7490],"source":"The `in` keyword complements the existing `ref`\nand `out` keywords to pass arguments\nby reference."},{"content":"The <ph id=\"ph1\">`in`</ph> keyword specifies passing the argument by reference, but the called method doesn't modify the value.","pos":[7491,7600],"source":" The `in` keyword specifies passing\nthe argument by reference, but the called method doesn't modify\nthe value."},{"content":"This addition provides a full vocabulary to express your design intent.","pos":[7602,7673]},{"content":"Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.","pos":[7674,7806],"source":"\nValue types are copied when passed to a called method when you don't\nspecify any of the following modifiers in the method signature."},{"content":"Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.","pos":[7807,7899],"source":" Each of these modifiers specifies\nthat a variable is passed by reference, avoiding the copy."},{"content":"Each modifier expresses a different intent:","pos":[7900,7943],"source":" Each modifier\nexpresses a different intent:"},{"pos":[7947,8020],"content":"<ph id=\"ph1\">`out`</ph>: This method sets the value of the argument used as this parameter.","source":"`out`: This method sets the value of the argument used as this parameter."},{"pos":[8023,8099],"content":"<ph id=\"ph1\">`ref`</ph>: This method may set the value of the argument used as this parameter.","source":"`ref`: This method may set the value of the argument used as this parameter."},{"pos":[8102,8184],"content":"<ph id=\"ph1\">`in`</ph>: This method doesn't modify the value of the argument used as this parameter.","source":"`in`: This method doesn't modify the value of the argument used as this parameter."},{"content":"Add the <ph id=\"ph1\">`in`</ph> modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.","pos":[8186,8332],"source":"Add the `in` modifier to pass an argument by reference and declare\nyour design intent to pass arguments by reference to\navoid unnecessary copying."},{"content":"You don't intend to modify the object used as that argument.","pos":[8333,8393],"source":" You don't intend to modify the object used\nas that argument."},{"content":"This practice often improves performance for readonly value types that are larger than <ph id=\"ph1\">&lt;xref:System.IntPtr.Size?displayProperty=nameWithType&gt;</ph>.","pos":[8395,8537],"source":"This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>."},{"content":"For simple types (<ph id=\"ph1\">`sbyte`</ph>, <ph id=\"ph2\">`byte`</ph>, <ph id=\"ph3\">`short`</ph>, <ph id=\"ph4\">`ushort`</ph>, <ph id=\"ph5\">`int`</ph>, <ph id=\"ph6\">`uint`</ph>, <ph id=\"ph7\">`long`</ph>, <ph id=\"ph8\">`ulong`</ph>, <ph id=\"ph9\">`char`</ph>, <ph id=\"ph10\">`float`</ph>, <ph id=\"ph11\">`double`</ph>, <ph id=\"ph12\">`decimal`</ph> and <ph id=\"ph13\">`bool`</ph>, and <ph id=\"ph14\">`enum`</ph> types), any potential performance gains are minimal.","pos":[8538,8736],"source":" For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal."},{"content":"In fact, performance may degrade by using pass-by-reference for types smaller than <ph id=\"ph1\">&lt;xref:System.IntPtr.Size?displayProperty=nameWithType&gt;</ph>.","pos":[8737,8875],"source":" In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>."},{"pos":[8877,8985],"content":"The following code shows an example of a method that calculates the distance between two points in 3D space.","source":"The following code shows an example of a method\nthat calculates the distance between two points in 3D space."},{"content":"The arguments are two structures that each contain three doubles.","pos":[9127,9192]},{"content":"A double is 8 bytes, so each argument is 24 bytes.","pos":[9193,9243],"source":" A double is 8 bytes,\nso each argument is 24 bytes."},{"content":"By specifying the <ph id=\"ph1\">`in`</ph> modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.","pos":[9244,9380],"source":" By specifying the `in` modifier, you pass a 4 byte\nor 8-byte reference to those arguments, depending on the\narchitecture of the machine."},{"content":"The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.","pos":[9381,9513],"source":" The difference in size is small, but it adds\nup when your application calls this method in a tight loop using many different\nvalues."},{"content":"The <ph id=\"ph1\">`in`</ph> modifier complements <ph id=\"ph2\">`out`</ph> and <ph id=\"ph3\">`ref`</ph> in other ways as well.","pos":[9515,9583],"source":"The `in` modifier complements `out` and `ref` in other ways as well."},{"content":"You can't create overloads of a method that differ only in the presence of <ph id=\"ph1\">`in`</ph>, <ph id=\"ph2\">`out`</ph>, or <ph id=\"ph3\">`ref`</ph>.","pos":[9584,9681],"source":" You\ncan't create overloads of a method that differ only in the presence of\n`in`, `out`, or `ref`."},{"content":"These new rules extend the same behavior that had always been defined for <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> parameters.","pos":[9682,9783],"source":" These new rules extend the same behavior that had always been\ndefined for `out` and `ref` parameters."},{"content":"Like the <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> modifiers, value types aren't boxed because the <ph id=\"ph3\">`in`</ph> modifier is applied.","pos":[9784,9882],"source":" Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied."},{"pos":[9884,10020],"content":"The <ph id=\"ph1\">`in`</ph> modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.","source":"The `in` modifier may be applied to any member that takes parameters:\nmethods, delegates, lambdas, local functions, indexers, operators."},{"content":"Another feature of <ph id=\"ph1\">`in`</ph> parameters is that you may use literal values or constants for the argument to an <ph id=\"ph2\">`in`</ph> parameter.","pos":[10022,10143],"source":"Another feature of `in` parameters is that you may use literal values or constants\nfor the argument to an `in` parameter."},{"content":"Also, unlike a <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`out`</ph> parameter, you don't need to apply the <ph id=\"ph3\">`in`</ph> modifier at the call site.","pos":[10144,10244],"source":" Also, unlike a `ref` or `out` parameter,\nyou don't need to apply the `in` modifier at the call site."},{"content":"The following code shows you two examples of calling the <ph id=\"ph1\">`CalculateDistance`</ph> method.","pos":[10245,10329],"source":" The following\ncode shows you two examples of calling the `CalculateDistance` method."},{"content":"The first uses two local variables passed by reference.","pos":[10330,10385],"source":" The\nfirst uses two local variables passed by reference."},{"content":"The second includes a temporary variable created as part of the method call.","pos":[10386,10462],"source":" The second includes a\ntemporary variable created as part of the method call."},{"content":"There are several ways in which the compiler enforces the read-only nature of an <ph id=\"ph1\">`in`</ph> argument.","pos":[10610,10705],"source":"There are several ways in which the compiler enforces the read-only\nnature of an `in` argument."},{"content":"First of all, the called method can't directly assign to an <ph id=\"ph1\">`in`</ph> parameter.","pos":[10707,10782],"source":"  First of all, the called method\ncan't directly assign to an `in` parameter."},{"content":"It can't directly assign to any field of an <ph id=\"ph1\">`in`</ph> parameter when that value is a <ph id=\"ph2\">`struct`</ph> type.","pos":[10783,10877],"source":" It can't directly assign\nto any field of an `in` parameter when that value is a `struct` type."},{"content":"In addition, you can't pass an <ph id=\"ph1\">`in`</ph> parameter to any method using the <ph id=\"ph2\">`ref`</ph> or <ph id=\"ph3\">`out`</ph> modifier.","pos":[10878,10972],"source":" In addition, you can't pass\nan `in` parameter to any method using the `ref` or `out` modifier."},{"content":"These rules apply to any field of an <ph id=\"ph1\">`in`</ph> parameter, provided the field is a <ph id=\"ph2\">`struct`</ph> type and the parameter is also a <ph id=\"ph3\">`struct`</ph> type.","pos":[10973,11106],"source":"\nThese rules apply to any field of an `in` parameter, provided the\nfield is a `struct` type and the parameter is also a `struct` type."},{"content":"In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are <ph id=\"ph1\">`structs`</ph>.","pos":[11107,11235],"source":" In fact, these rules\napply for multiple layers of member access provided the types at all levels\nof member access are `structs`."},{"content":"The compiler enforces that <ph id=\"ph1\">`struct`</ph> types passed as  <ph id=\"ph2\">`in`</ph> arguments and their <ph id=\"ph3\">`struct`</ph> members are read-only variables when used as arguments to other methods.","pos":[11236,11395],"source":"\nThe compiler enforces that `struct` types passed as  `in` arguments and their\n`struct` members are read-only variables when used as arguments to other methods."},{"content":"The use of <ph id=\"ph1\">`in`</ph> parameters can avoid the potential performance costs of making copies.","pos":[11397,11483],"source":"The use of `in` parameters can avoid the potential performance costs\nof making copies."},{"content":"It doesn't change the semantics of any method call.","pos":[11484,11535]},{"content":"Therefore, you don't need to specify the <ph id=\"ph1\">`in`</ph> modifier at the call site.","pos":[11536,11608],"source":" Therefore,\nyou don't need to specify the `in` modifier at the call site."},{"content":"Omitting the <ph id=\"ph1\">`in`</ph> modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:","pos":[11609,11749],"source":" Omitting the `in` modifier at the call site informs the compiler that it's\nallowed to make a copy of the argument for the following reasons:"},{"content":"There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.","pos":[11753,11865]},{"content":"The argument is an expression but doesn't have a known storage variable.","pos":[11868,11940]},{"content":"An overload exists that differs by the presence or absence of <ph id=\"ph1\">`in`</ph>.","pos":[11943,12010],"source":"An overload exists that differs by the presence or absence of `in`."},{"content":"In that case, the by value overload is a better match.","pos":[12011,12065]},{"content":"These rules are useful as you update existing code to use read-only reference arguments.","pos":[12067,12155],"source":"These rules are useful as you update existing code to use read-only\nreference arguments."},{"content":"Inside the called method, you can call any instance method that uses by value parameters.","pos":[12156,12245],"source":" Inside the called method, you can call any instance\nmethod that uses by value parameters."},{"content":"In those instances, a copy of the <ph id=\"ph1\">`in`</ph> parameter is created.","pos":[12246,12306],"source":" In\nthose instances, a copy of the `in` parameter is created."},{"content":"Because the compiler may create a temporary variable for any <ph id=\"ph1\">`in`</ph> parameter, you can also specify default values for any <ph id=\"ph2\">`in`</ph> parameter.","pos":[12307,12443],"source":" Because the compiler\nmay create a temporary variable for any `in` parameter, you can also specify default\nvalues for any `in` parameter."},{"content":"The following code specifies the origin (point 0,0) as the default value for the second point:","pos":[12444,12538],"source":" The following code specifies the origin\n(point 0,0) as the default value for the second point:"},{"pos":[12708,12864],"content":"To force the compiler to pass read-only arguments by reference, specify the <ph id=\"ph1\">`in`</ph> modifier on the arguments at the call site, as shown in the following code:","source":"To force the compiler to pass read-only arguments by reference, specify the `in` modifier\non the arguments at the call site, as shown in the following code:"},{"content":"This behavior makes it easier to adopt <ph id=\"ph1\">`in`</ph> parameters over time in large codebases where performance gains are possible.","pos":[13017,13138],"source":"This behavior makes it easier to adopt `in` parameters over time in large\ncodebases where performance gains are possible."},{"content":"You add the <ph id=\"ph1\">`in`</ph> modifier to method signatures first.","pos":[13139,13192],"source":" You add the `in` modifier\nto method signatures first."},{"content":"Then, you can add the <ph id=\"ph1\">`in`</ph> modifier at call sites and create <ph id=\"ph2\">`readonly struct`</ph> types to enable the compiler to avoid creating defensive copies of <ph id=\"ph3\">`in`</ph> parameters in more locations.","pos":[13193,13373],"source":" Then, you can add the `in` modifier at call sites\nand create `readonly struct` types to enable the compiler to avoid creating\ndefensive copies of `in` parameters in more locations."},{"content":"The <ph id=\"ph1\">`in`</ph> parameter designation can also be used with reference types or numeric values.","pos":[13375,13462],"source":"The `in` parameter designation can also be used with reference types or numeric values."},{"content":"However, the benefits in both cases are minimal, if any.","pos":[13463,13519]},{"pos":[13524,13569],"content":"Never use mutable structs as in <ph id=\"ph1\">`in`</ph> argument","linkify":"Never use mutable structs as in `in` argument","source":"Never use mutable structs as in `in` argument"},{"content":"The techniques described above explain how to avoid copies by returning references and passing values by reference.","pos":[13571,13686]},{"content":"These techniques work best when the argument types are declared as <ph id=\"ph1\">`readonly struct`</ph> types.","pos":[13687,13778],"source":" These techniques work best when the argument types are declared as `readonly struct` types."},{"content":"Otherwise, the compiler must create <bpt id=\"p1\">**</bpt>defensive copies<ept id=\"p1\">**</ept> in many situations to enforce the readonly-ness of any arguments.","pos":[13779,13901],"source":" Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments."},{"content":"Consider the following example that calculates the distance of a 3D point from the origin:","pos":[13902,13992]},{"content":"The <ph id=\"ph1\">`Point3D`</ph> structure is <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> a readonly struct.","pos":[14134,14185],"source":"The `Point3D` structure is *not* a readonly struct."},{"content":"There are six different property access calls in the body of this method.","pos":[14186,14259]},{"content":"On first examination, you may have thought these accesses were safe.","pos":[14260,14328]},{"content":"After all, a <ph id=\"ph1\">`get`</ph> accessor shouldn't modify the state of the object.","pos":[14329,14398],"source":" After all, a `get` accessor shouldn't modify the state of the object."},{"content":"But there's no language rule that enforces that.","pos":[14399,14447]},{"content":"It's only a common convention.","pos":[14448,14478]},{"content":"Any type could implement a <ph id=\"ph1\">`get`</ph> accessor that modified the internal state.","pos":[14479,14554],"source":" Any type could implement a `get` accessor that modified the internal state."},{"content":"Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member.","pos":[14555,14672]},{"content":"The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the <ph id=\"ph1\">`this`</ph> argument.","pos":[14673,14867],"source":" The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument."},{"content":"In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a <ph id=\"ph1\">`readonly struct`</ph>.","pos":[14868,15035],"source":" In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`."},{"pos":[15037,15153],"content":"Instead, if the distance calculation uses the immutable struct, <ph id=\"ph1\">`ReadonlyPoint3D`</ph>, temporary objects are not needed:","source":"Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects are not needed:"},{"content":"The compiler generates more efficient code when you call members of a <ph id=\"ph1\">`readonly struct`</ph>: The <ph id=\"ph2\">`this`</ph> reference, instead of a copy of the receiver, is always an <ph id=\"ph3\">`in`</ph> parameter passed by reference to the member method.","pos":[15319,15534],"source":"The compiler generates more efficient code when you call members of a\n`readonly struct`: The `this` reference, instead of a copy of the receiver,\nis always an `in` parameter passed by reference to the member method."},{"content":"This optimization saves copying when you use a <ph id=\"ph1\">`readonly struct`</ph> as an <ph id=\"ph2\">`in`</ph> argument.","pos":[15535,15620],"source":" This optimization\nsaves copying when you use a `readonly struct` as an `in` argument."},{"content":"You can see an example program that demonstrates the performance differences using <bpt id=\"p1\">[</bpt>Benchmark.net<ept id=\"p1\">](https://www.nuget.org/packages/BenchmarkDotNet/)</ept> in our <bpt id=\"p2\">[</bpt>samples repository<ept id=\"p2\">](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark)</ept> on GitHub.","pos":[15622,15892],"source":"You can see an example program that demonstrates the performance differences using [Benchmark.net](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub."},{"content":"It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.","pos":[15893,16015]},{"content":"The use of the immutable struct and pass by reference is fastest.","pos":[16016,16081]},{"pos":[16086,16162],"content":"Use <ph id=\"ph1\">`ref struct`</ph> types to work with blocks or memory on a single stack frame","linkify":"Use `ref struct` types to work with blocks or memory on a single stack frame","source":"Use `ref struct` types to work with blocks or memory on a single stack frame"},{"content":"A related language feature is the ability to declare a value type that must be constrained to a single stack frame.","pos":[16164,16279],"source":"A related language feature is the ability to declare a value type that\nmust be constrained to a single stack frame."},{"content":"This restriction enables the compiler to make several optimizations.","pos":[16280,16348]},{"content":"The primary motivation for this feature was <ph id=\"ph1\">&lt;xref:System.Span%601&gt;</ph> and related structures.","pos":[16349,16439],"source":" The primary motivation for this feature\nwas <xref:System.Span%601> and related structures."},{"content":"You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <ph id=\"ph1\">&lt;xref:System.Span%601&gt;</ph> type.","pos":[16440,16588],"source":" You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type."},{"content":"You may have similar requirements working with memory created using <bpt id=\"p1\">[</bpt><ph id=\"ph1\">`stackalloc`</ph><ept id=\"p1\">](language-reference/keywords/stackalloc.md)</ept> or when using memory from interop APIs.","pos":[16590,16755],"source":"You may have similar requirements working with memory created\nusing [`stackalloc`](language-reference/keywords/stackalloc.md) or\nwhen using memory from interop APIs."},{"content":"You can define your own <ph id=\"ph1\">`ref struct`</ph> types for those needs.","pos":[16756,16815],"source":" You can define your own `ref struct` types\nfor those needs."},{"pos":[16820,16846],"content":"<ph id=\"ph1\">`readonly ref struct`</ph> type","linkify":"`readonly ref struct` type","source":"`readonly ref struct` type"},{"content":"Declaring a struct as <ph id=\"ph1\">`readonly ref`</ph> combines the benefits and restrictions of <ph id=\"ph2\">`ref struct`</ph> and <ph id=\"ph3\">`readonly struct`</ph> declarations.","pos":[16848,16975],"source":"Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations."},{"content":"The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.","pos":[16976,17111]},{"pos":[17116,17127],"content":"Conclusions","linkify":"Conclusions","nodes":[{"content":"Conclusions","pos":[0,11]}]},{"content":"Using value types minimizes the number of allocation operations:","pos":[17129,17193]},{"content":"Storage for value types is stack allocated for local variables and method arguments.","pos":[17197,17281]},{"content":"Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.","pos":[17284,17408]},{"content":"Storage for value type return values is stack allocated.","pos":[17411,17467]},{"content":"Contrast that with reference types in those same situations:","pos":[17469,17529]},{"content":"Storage for reference types are heap allocated for local variables and method arguments.","pos":[17533,17621]},{"content":"The reference is stored on the stack.","pos":[17622,17659]},{"content":"Storage for reference types that are members of other objects are separately allocated on the heap.","pos":[17662,17761]},{"content":"The containing object stores the reference.","pos":[17762,17805]},{"content":"Storage for reference type return values is heap allocated.","pos":[17808,17867]},{"content":"The reference to that storage is stored on the stack.","pos":[17868,17921]},{"content":"Minimizing allocations comes with tradeoffs.","pos":[17923,17967]},{"content":"You copy more memory when the size of the <ph id=\"ph1\">`struct`</ph> is larger than the size of a reference.","pos":[17968,18058],"source":" You copy more memory when the size of the `struct` is larger than the size of a reference."},{"content":"A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.","pos":[18059,18142]},{"content":"These tradeoffs generally have minimal performance impact.","pos":[18144,18202]},{"content":"However, for large structs or larger collections, the performance impact increases.","pos":[18203,18286]},{"content":"The impact can be large in tight loops and hot paths for programs.","pos":[18287,18353]},{"content":"These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.","pos":[18355,18535],"source":"These enhancements to the C# language are designed for performance critical\nalgorithms where minimizing memory allocations is a major factor in achieving the\nnecessary performance."},{"content":"You may find that you don't often use these features in the code you write.","pos":[18536,18611],"source":" You may find that you don't often use these features in\nthe code you write."},{"content":"However, these enhancements have been adopted throughout .NET.","pos":[18612,18674]},{"content":"As more and more APIs make use of these features, you'll see the performance of your applications improve.","pos":[18675,18781],"source":" As more and more APIs make use of these features, you'll\nsee the performance of your applications improve."},{"pos":[18786,18794],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[18798,18847],"content":"<bpt id=\"p1\">[</bpt>ref keyword<ept id=\"p1\">](language-reference/keywords/ref.md)</ept>","source":"[ref keyword](language-reference/keywords/ref.md)"},{"pos":[18850,18932],"content":"<bpt id=\"p1\">[</bpt>Ref returns and ref locals<ept id=\"p1\">](programming-guide/classes-and-structs/ref-returns.md)</ept>","source":"[Ref returns and ref locals](programming-guide/classes-and-structs/ref-returns.md)"}]}