{"content":"---\ntitle: \"Introduction to PLINQ\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"PLINQ queries, introduction to\"\nms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n\n# Introduction to PLINQ\n\n## What is a Parallel Query?\n\nLanguage-Integrated Query (LINQ) was introduced in the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]. It features a unified model for querying any <xref:System.Collections.IEnumerable?displayProperty=nameWithType> or <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> data source in a type-safe manner. LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays. This article assumes that you have a basic understanding of LINQ. For more information, see [Language-Integrated Query (LINQ) - C#](../../csharp/programming-guide/concepts/linq/index.md) or [Language-Integrated Query (LINQ) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md).\n\nParallel LINQ (PLINQ) is a parallel implementation of the LINQ pattern. A PLINQ query in many ways resembles a non-parallel LINQ to Objects query. PLINQ queries, just like sequential [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated. The primary difference is that PLINQ attempts to make full use of all the processors on the system. It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors. In many cases, parallel execution means that the query runs significantly faster.\n\nThrough parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source. However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ. In fact, parallelization actually slows down certain queries. Therefore, you should understand how issues such as ordering affect parallel queries. For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).\n\n> [!NOTE]\n> This documentation uses lambda expressions to define delegates in PLINQ. If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).\n\nThe remainder of this article gives an overview of the main PLINQ classes, and discusses how to create PLINQ queries. Each section contains links to more detailed information and code examples.\n\n## The ParallelEnumerable Class\n\nThe <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality. It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly. The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.\n\n<xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one. If you are not familiar with [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)], see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).\n\nIn addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution. These PLINQ-specific methods are listed in the following table.\n\n|ParallelEnumerable Operator|Description|\n|---------------------------------|-----------------|\n|<xref:System.Linq.ParallelEnumerable.AsParallel%2A>|The entry point for PLINQ. Specifies that the rest of the query should be parallelized, if it is possible.|\n|<xref:System.Linq.ParallelEnumerable.AsSequential%2A>|Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.|\n|<xref:System.Linq.ParallelEnumerable.AsOrdered%2A>|Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.|\n|<xref:System.Linq.ParallelEnumerable.AsUnordered%2A>|Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.|\n|<xref:System.Linq.ParallelEnumerable.WithCancellation%2A>|Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.|\n|<xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>|Specifies the maximum number of processors that PLINQ should use to parallelize the query.|\n|<xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>|Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.|\n|<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>|Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.|\n|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.|\n|<xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload|An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.|\n\n## The Opt-in Model\n\nWhen you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example.\n\n[!code-csharp[PLINQ#1](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#1)]\n[!code-vb[PLINQ#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#1)]\n\nThe <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations.\n\n## Execution Modes\n\nBy default, PLINQ is conservative. At run time, the PLINQ infrastructure analyzes the overall structure of the query. If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently. If it is not safe to parallelize a query, PLINQ just runs the query sequentially. If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default. You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm. This is useful when you know by testing and measurement that a particular query executes faster in parallel. For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).\n\n## Degree of Parallelism\n\nBy default, PLINQ uses all of the processors on the host computer. You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method. This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time. The following snippet limits the query to utilizing a maximum of two processors.\n\n[!code-csharp[PLINQ#5](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#5)]\n[!code-vb[PLINQ#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#5)]\n\nIn cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.\n\n## Ordered Versus Unordered Parallel Queries\n\nIn some queries, a query operator must produce results that preserve the ordering of the source sequence. PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose. <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>. An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted. Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence. Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.\n\nThe following code example shows how to opt in to order preservation.\n\n[!code-csharp[PLINQ#3](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#3)]\n[!code-vb[PLINQ#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#3)]\n\nFor more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).\n\n## Parallel vs. Sequential Queries\n\nSome operations require that the source data be delivered in a sequential manner. The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required. For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method. When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again. For more information, see [How to: Combine Parallel and Sequential LINQ Queries](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md).\n\n## Options for Merging Query Results\n\nWhen a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array. In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly. For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration. For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).\n\n## The ForAll Operator\n\nIn sequential [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>. In PLINQ, you can also use `foreach` to execute the query and iterate through the results. However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running. In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element. For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query. <xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step. The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method. <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.\n\n[!code-csharp[PLINQ#4](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#4)]\n[!code-vb[PLINQ#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#4)]\n\nThe following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution.\n\n![ForAll vs. ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png \"VS_ISVNT_ALLvsEACH\")\n\n## Cancellation\n\nPLINQ is integrated with the cancellation types in [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]. (For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled. To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument. When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>.\n\nIt is possible that a PLINQ query might continue to process some elements after the cancellation token is set.\n\nFor greater responsiveness, you can also respond to cancellation requests in long-running user delegates. For more information, see [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).\n\n## Exceptions\n\nWhen a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously. Also, the code to handle the exception might be on a different thread than the code that threw the exception. PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread. On the calling thread, only one try-catch block is required. However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from. In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped.\n\nWhen exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.\n\nFor more information, see [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).\n\n## Custom Partitioners\n\nIn some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data. In the query, the custom partitioner itself is the enumerable object that is queried.\n\n[!code-csharp[PLINQ#2](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#2)]\n[!code-vb[PLINQ#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq3.vb#2)]\n\nPLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.). <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time. For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).\n\n## Measuring PLINQ Performance\n\nIn many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained. If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query. You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially. For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).\n\n## See also\n\n- [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)\n- [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)\n","nodes":[{"pos":[4,267],"embed":true,"restype":"x-metadata","content":"title: \"Introduction to PLINQ\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords:\n  - \"PLINQ queries, introduction to\"\nms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Introduction to PLINQ","nodes":[{"pos":[0,21],"content":"Introduction to PLINQ","nodes":[{"content":"Introduction to PLINQ","pos":[0,21]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[275,296],"content":"Introduction to PLINQ","linkify":"Introduction to PLINQ","nodes":[{"content":"Introduction to PLINQ","pos":[0,21]}]},{"pos":[301,326],"content":"What is a Parallel Query?","linkify":"What is a Parallel Query?","nodes":[{"content":"What is a Parallel Query?","pos":[0,25]}]},{"content":"Language-Integrated Query (LINQ) was introduced in the <ph id=\"ph1\">[!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]</ph>.","pos":[328,446],"source":"Language-Integrated Query (LINQ) was introduced in the [!INCLUDE[net_v35_long](../../../includes/net-v35-long-md.md)]."},{"content":"It features a unified model for querying any <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerable?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph> data source in a type-safe manner.","pos":[447,675],"source":" It features a unified model for querying any <xref:System.Collections.IEnumerable?displayProperty=nameWithType> or <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> data source in a type-safe manner."},{"content":"LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> and arrays.","pos":[676,826],"source":" LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays."},{"content":"This article assumes that you have a basic understanding of LINQ.","pos":[827,892]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Language-Integrated Query (LINQ) - C#<ept id=\"p1\">](../../csharp/programming-guide/concepts/linq/index.md)</ept> or <bpt id=\"p2\">[</bpt>Language-Integrated Query (LINQ) - Visual Basic<ept id=\"p2\">](../../visual-basic/programming-guide/concepts/linq/index.md)</ept>.","pos":[893,1128],"source":" For more information, see [Language-Integrated Query (LINQ) - C#](../../csharp/programming-guide/concepts/linq/index.md) or [Language-Integrated Query (LINQ) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md)."},{"content":"Parallel LINQ (PLINQ) is a parallel implementation of the LINQ pattern.","pos":[1130,1201]},{"content":"A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.","pos":[1202,1276]},{"content":"PLINQ queries, just like sequential <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)]</ph> queries, operate on any in-memory <ph id=\"ph2\">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.","pos":[1277,1607],"source":" PLINQ queries, just like sequential [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated."},{"content":"The primary difference is that PLINQ attempts to make full use of all the processors on the system.","pos":[1608,1707]},{"content":"It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.","pos":[1708,1875]},{"content":"In many cases, parallel execution means that the query runs significantly faster.","pos":[1876,1957]},{"content":"Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsParallel%2A&gt;</ph> query operation to the data source.","pos":[1959,2201],"source":"Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source."},{"content":"However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ.","pos":[2202,2308]},{"content":"In fact, parallelization actually slows down certain queries.","pos":[2309,2370]},{"content":"Therefore, you should understand how issues such as ordering affect parallel queries.","pos":[2371,2456]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Understanding Speedup in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)</ept>.","pos":[2457,2595],"source":" For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)."},{"pos":[2599,2879],"content":"[!NOTE]\nThis documentation uses lambda expressions to define delegates in PLINQ. If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).","leadings":["","> "],"nodes":[{"content":"This documentation uses lambda expressions to define delegates in PLINQ. If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).","pos":[8,278],"nodes":[{"content":"This documentation uses lambda expressions to define delegates in PLINQ.","pos":[0,72]},{"content":"If you are not familiar with lambda expressions in C# or Visual Basic, see <bpt id=\"p1\">[</bpt>Lambda Expressions in PLINQ and TPL<ept id=\"p1\">](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md)</ept>.","pos":[73,270],"source":" If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md)."}]}]},{"content":"The remainder of this article gives an overview of the main PLINQ classes, and discusses how to create PLINQ queries.","pos":[2881,2998]},{"content":"Each section contains links to more detailed information and code examples.","pos":[2999,3074]},{"pos":[3079,3107],"content":"The ParallelEnumerable Class","linkify":"The ParallelEnumerable Class","nodes":[{"content":"The ParallelEnumerable Class","pos":[0,28]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType&gt;</ph> class exposes almost all of PLINQ's functionality.","pos":[3109,3230],"source":"The <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality."},{"content":"It and the rest of the <ph id=\"ph1\">&lt;xref:System.Linq?displayProperty=nameWithType&gt;</ph> namespace types are compiled into the System.Core.dll assembly.","pos":[3231,3365],"source":" It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly."},{"content":"The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.","pos":[3366,3477]},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable&gt;</ph> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one.","pos":[3479,3662],"source":"<xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one."},{"content":"If you are not familiar with <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>Introduction to LINQ (C#)<ept id=\"p1\">](../../csharp/programming-guide/concepts/linq/introduction-to-linq.md)</ept> and <bpt id=\"p2\">[</bpt>Introduction to LINQ (Visual Basic)<ept id=\"p2\">](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md)</ept>.","pos":[3663,3970],"source":" If you are not familiar with [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)], see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/introduction-to-linq.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md)."},{"content":"In addition to the standard query operators, the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable&gt;</ph> class contains a set of methods that enable behaviors specific to parallel execution.","pos":[3972,4144],"source":"In addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution."},{"content":"These PLINQ-specific methods are listed in the following table.","pos":[4145,4208]},{"content":"ParallelEnumerable Operator","pos":[4211,4238]},{"content":"Description","pos":[4239,4250]},{"content":"The entry point for PLINQ.","pos":[4359,4385]},{"content":"Specifies that the rest of the query should be parallelized, if it is possible.","pos":[4386,4465]},{"content":"Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.","pos":[4522,4616]},{"content":"Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.","pos":[4670,4875]},{"content":"Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.","pos":[4931,5042]},{"content":"Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.","pos":[5103,5237]},{"content":"Specifies the maximum number of processors that PLINQ should use to parallelize the query.","pos":[5305,5395]},{"content":"Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.","pos":[5456,5590]},{"content":"Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.","pos":[5652,5768]},{"content":"A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.","pos":[5819,6002]},{"pos":[6005,6064],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.Aggregate%2A&gt;</ph> overload","source":"<xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload"},{"content":"An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.","pos":[6065,6243]},{"pos":[6249,6265],"content":"The Opt-in Model","linkify":"The Opt-in Model","nodes":[{"content":"The Opt-in Model","pos":[0,16]}]},{"pos":[6267,6475],"content":"When you write a query, opt in to PLINQ by invoking the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType&gt;</ph> extension method on the data source, as shown in the following example.","source":"When you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example."},{"pos":[6677,6914],"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsParallel%2A&gt;</ph> extension method binds the subsequent query operators, in this case, <ph id=\"ph2\">`where`</ph> and <ph id=\"ph3\">`select`</ph>, to the <ph id=\"ph4\">&lt;xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType&gt;</ph> implementations.","source":"The <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations."},{"pos":[6919,6934],"content":"Execution Modes","linkify":"Execution Modes","nodes":[{"content":"Execution Modes","pos":[0,15]}]},{"content":"By default, PLINQ is conservative.","pos":[6936,6970]},{"content":"At run time, the PLINQ infrastructure analyzes the overall structure of the query.","pos":[6971,7053]},{"content":"If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently.","pos":[7054,7192]},{"content":"If it is not safe to parallelize a query, PLINQ just runs the query sequentially.","pos":[7193,7274]},{"content":"If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default.","pos":[7275,7435]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A&gt;</ph> method and the <ph id=\"ph2\">&lt;xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType&gt;</ph> enumeration to instruct PLINQ to select the parallel algorithm.","pos":[7436,7659],"source":" You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm."},{"content":"This is useful when you know by testing and measurement that a particular query executes faster in parallel.","pos":[7660,7768]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Specify the Execution Mode in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)</ept>.","pos":[7769,7932],"source":" For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)."},{"pos":[7937,7958],"content":"Degree of Parallelism","linkify":"Degree of Parallelism","nodes":[{"content":"Degree of Parallelism","pos":[0,21]}]},{"content":"By default, PLINQ uses all of the processors on the host computer.","pos":[7960,8026]},{"content":"You can instruct PLINQ to use no more than a specified number of processors by using the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A&gt;</ph> method.","pos":[8027,8188],"source":" You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method."},{"content":"This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time.","pos":[8189,8313]},{"content":"The following snippet limits the query to utilizing a maximum of two processors.","pos":[8314,8394]},{"content":"In cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.","pos":[8599,8807]},{"pos":[8812,8853],"content":"Ordered Versus Unordered Parallel Queries","linkify":"Ordered Versus Unordered Parallel Queries","nodes":[{"content":"Ordered Versus Unordered Parallel Queries","pos":[0,41]}]},{"content":"In some queries, a query operator must produce results that preserve the ordering of the source sequence.","pos":[8855,8960]},{"content":"PLINQ provides the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> operator for this purpose.","pos":[8961,9057],"source":" PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose."},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> is distinct from <ph id=\"ph2\">&lt;xref:System.Linq.ParallelEnumerable.AsSequential%2A&gt;</ph>.","pos":[9058,9180],"source":"<xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> sequence is still processed in parallel, but its results are buffered and sorted.","pos":[9181,9316],"source":" An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted."},{"content":"Because order preservation typically involves extra work, an <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsOrdered%2A&gt;</ph> sequence might be processed more slowly than the default <ph id=\"ph2\">&lt;xref:System.Linq.ParallelEnumerable.AsUnordered%2A&gt;</ph> sequence.","pos":[9317,9548],"source":" Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence."},{"content":"Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.","pos":[9549,9674]},{"content":"The following code example shows how to opt in to order preservation.","pos":[9676,9745]},{"pos":[9947,10079],"content":"For more information, see <bpt id=\"p1\">[</bpt>Order Preservation in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)</ept>.","source":"For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)."},{"pos":[10084,10115],"content":"Parallel vs. Sequential Queries","linkify":"Parallel vs. Sequential Queries","nodes":[{"content":"Parallel vs. Sequential Queries","pos":[0,31]}]},{"content":"Some operations require that the source data be delivered in a sequential manner.","pos":[10117,10198]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable&gt;</ph> query operators revert to sequential mode automatically when it is required.","pos":[10199,10317],"source":" The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required."},{"content":"For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsSequential%2A&gt;</ph> method.","pos":[10318,10485],"source":" For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method."},{"content":"When you use <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.AsSequential%2A&gt;</ph>, all subsequent operators in the query are executed sequentially until <ph id=\"ph2\">&lt;xref:System.Linq.ParallelEnumerable.AsParallel%2A&gt;</ph> is called again.","pos":[10486,10692],"source":" When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Combine Parallel and Sequential LINQ Queries<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md)</ept>.","pos":[10693,10874],"source":" For more information, see [How to: Combine Parallel and Sequential LINQ Queries](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md)."},{"pos":[10879,10912],"content":"Options for Merging Query Results","linkify":"Options for Merging Query Results","nodes":[{"content":"Options for Merging Query Results","pos":[0,33]}]},{"content":"When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a <ph id=\"ph1\">`foreach`</ph> loop (<ph id=\"ph2\">`For Each`</ph> in Visual Basic), or insertion into a list or array.","pos":[10914,11132],"source":"When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array."},{"content":"In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly.","pos":[11133,11273]},{"content":"For this purpose, PLINQ supports the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A&gt;</ph> method, and the <ph id=\"ph2\">&lt;xref:System.Linq.ParallelMergeOptions&gt;</ph> enumeration.","pos":[11274,11437],"source":" For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Merge Options in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)</ept>.","pos":[11438,11560],"source":" For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)."},{"pos":[11565,11584],"content":"The ForAll Operator","linkify":"The ForAll Operator","nodes":[{"content":"The ForAll Operator","pos":[0,19]}]},{"content":"In sequential <ph id=\"ph1\">[!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)]</ph> queries, execution is deferred until the query is enumerated either in a <ph id=\"ph2\">`foreach`</ph> (<ph id=\"ph3\">`For Each`</ph> in Visual Basic) loop or by invoking a method such as <ph id=\"ph4\">&lt;xref:System.Linq.ParallelEnumerable.ToList%2A&gt;</ph> , <ph id=\"ph5\">&lt;xref:System.Linq.ParallelEnumerable.ToArray%2A&gt;</ph> , or <ph id=\"ph6\">&lt;xref:System.Linq.ParallelEnumerable.ToDictionary%2A&gt;</ph>.","pos":[11586,11964],"source":"In sequential [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>."},{"content":"In PLINQ, you can also use <ph id=\"ph1\">`foreach`</ph> to execute the query and iterate through the results.","pos":[11965,12055],"source":" In PLINQ, you can also use `foreach` to execute the query and iterate through the results."},{"content":"However, <ph id=\"ph1\">`foreach`</ph> itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.","pos":[12056,12235],"source":" However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running."},{"content":"In PLINQ, you can use <ph id=\"ph1\">`foreach`</ph> when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling <ph id=\"ph2\">`Console.WriteLine`</ph> for each element.","pos":[12236,12471],"source":" In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element."},{"content":"For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.ForAll%2A&gt;</ph> method to execute a PLINQ query.","pos":[12472,12694],"source":" For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query."},{"content":"<ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.ForAll%2A&gt;</ph> does not perform this final merge step.","pos":[12695,12782],"source":"<xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step."},{"content":"The following code example shows how to use the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.ForAll%2A&gt;</ph> method.","pos":[12783,12886],"source":" The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType&gt;</ph> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.","pos":[12887,13088],"source":"<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items."},{"pos":[13290,13439],"content":"The following illustration shows the difference between <ph id=\"ph1\">`foreach`</ph> and <ph id=\"ph2\">&lt;xref:System.Linq.ParallelEnumerable.ForAll%2A&gt;</ph> with regard to query execution.","source":"The following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution."},{"pos":[13441,13557],"content":"<bpt id=\"p1\">![</bpt>ForAll vs. ForEach<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png \"</bpt>VS_ISVNT_ALLvsEACH<ept id=\"p2\">\")</ept>","source":"![ForAll vs. ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png \"VS_ISVNT_ALLvsEACH\")"},{"pos":[13562,13574],"content":"Cancellation","linkify":"Cancellation","nodes":[{"content":"Cancellation","pos":[0,12]}]},{"content":"PLINQ is integrated with the cancellation types in <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>.","pos":[13576,13692],"source":"PLINQ is integrated with the cancellation types in [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]."},{"content":"(For more information, see <bpt id=\"p1\">[</bpt>Cancellation in Managed Threads<ept id=\"p1\">](../../../docs/standard/threading/cancellation-in-managed-threads.md)</ept>.) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled.","pos":[13693,13909],"source":" (For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled."},{"content":"To create a cancelable PLINQ query, use the <ph id=\"ph1\">&lt;xref:System.Linq.ParallelEnumerable.WithCancellation%2A&gt;</ph> operator on the query and provide a <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken&gt;</ph> instance as the argument.","pos":[13910,14115],"source":" To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <ph id=\"ph2\">&lt;xref:System.OperationCanceledException&gt;</ph>.","pos":[14116,14340],"source":" When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>."},{"content":"It is possible that a PLINQ query might continue to process some elements after the cancellation token is set.","pos":[14342,14452]},{"content":"For greater responsiveness, you can also respond to cancellation requests in long-running user delegates.","pos":[14454,14559]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Cancel a PLINQ Query<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md)</ept>.","pos":[14560,14693],"source":" For more information, see [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md)."},{"pos":[14698,14708],"content":"Exceptions","linkify":"Exceptions","nodes":[{"content":"Exceptions","pos":[0,10]}]},{"content":"When a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously.","pos":[14710,14813]},{"content":"Also, the code to handle the exception might be on a different thread than the code that threw the exception.","pos":[14814,14923]},{"content":"PLINQ uses the <ph id=\"ph1\">&lt;xref:System.AggregateException&gt;</ph> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread.","pos":[14924,15096],"source":" PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread."},{"content":"On the calling thread, only one try-catch block is required.","pos":[15097,15157]},{"content":"However, you can iterate through all of the exceptions that are encapsulated in the <ph id=\"ph1\">&lt;xref:System.AggregateException&gt;</ph> and catch any that you can safely recover from.","pos":[15158,15322],"source":" However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from."},{"content":"In rare cases, some exceptions may be thrown that are not wrapped in an <ph id=\"ph1\">&lt;xref:System.AggregateException&gt;</ph>, and <ph id=\"ph2\">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>s  are also not wrapped.","pos":[15323,15501],"source":" In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped."},{"content":"When exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.","pos":[15503,15670]},{"pos":[15672,15833],"content":"For more information, see <bpt id=\"p1\">[</bpt>How to: Handle Exceptions in a PLINQ Query<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)</ept>.","source":"For more information, see [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)."},{"pos":[15838,15857],"content":"Custom Partitioners","linkify":"Custom Partitioners","nodes":[{"content":"Custom Partitioners","pos":[0,19]}]},{"content":"In some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data.","pos":[15859,16003]},{"content":"In the query, the custom partitioner itself is the enumerable object that is queried.","pos":[16004,16089]},{"content":"PLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.).","pos":[16288,16434]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A&gt;</ph> support only dynamic partitioning, which means that the number of partitions changes at run time.","pos":[16435,16632],"source":"<xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Custom Partitioners for PLINQ and TPL<ept id=\"p1\">](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)</ept>.","pos":[16633,16785],"source":" For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)."},{"pos":[16790,16817],"content":"Measuring PLINQ Performance","linkify":"Measuring PLINQ Performance","nodes":[{"content":"Measuring PLINQ Performance","pos":[0,27]}]},{"content":"In many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained.","pos":[16819,16954]},{"content":"If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query.","pos":[16955,17100]},{"content":"You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially.","pos":[17101,17332]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Concurrency Visualizer<ept id=\"p1\">](/visualstudio/profiling/concurrency-visualizer)</ept> and <bpt id=\"p2\">[</bpt>How to: Measure PLINQ Query Performance<ept id=\"p2\">](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md)</ept>.","pos":[17333,17565],"source":" For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md)."},{"pos":[17570,17578],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[17582,17673],"content":"<bpt id=\"p1\">[</bpt>Parallel LINQ (PLINQ)<ept id=\"p1\">](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)</ept>","source":"[Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)"},{"pos":[17676,17787],"content":"<bpt id=\"p1\">[</bpt>Understanding Speedup in PLINQ<ept id=\"p1\">](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)</ept>","source":"[Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)"}]}