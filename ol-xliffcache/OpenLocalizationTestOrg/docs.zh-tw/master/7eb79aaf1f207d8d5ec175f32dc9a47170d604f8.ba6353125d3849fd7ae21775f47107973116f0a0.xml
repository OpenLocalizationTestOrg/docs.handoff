{"content":"---\ntitle: \"Data Structures for Parallel Programming\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"data structures, multi-threading\"\nms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Data Structures for Parallel Programming\nThe .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization. You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.  \n  \n## Concurrent Collection Classes  \n The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary. Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items. The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.  \n  \n The following table lists the new concurrent collection classes:  \n  \n|Type|Description|  \n|----------|-----------------|  \n|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>. Producer threads block if no slots are available or if the collection is full. Consumer threads block if the collection is empty. This type also supports non-blocking access by consumers and producers. <xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.|  \n|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|A thread-safe bag implementation that provides scalable add and get operations.|  \n|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|A concurrent and scalable dictionary type.|  \n|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|A concurrent and scalable FIFO queue.|  \n|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|A concurrent and scalable LIFO stack.|  \n  \n For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).  \n  \n## Synchronization Primitives  \n The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code. Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.  \n  \n The following table lists the new synchronization types:  \n  \n|Type|Description|  \n|----------|-----------------|  \n|<xref:System.Threading.Barrier?displayProperty=nameWithType>|Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived. For more information, see [Barrier](../../../docs/standard/threading/barrier.md).|  \n|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|Simplifies fork and join scenarios by providing an easy rendezvous mechanism. For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).|  \n|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>. <xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.|  \n|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources. For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).|  \n|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum. In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking. For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).|  \n|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.  For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).|  \n  \n For more information, see:  \n  \n-   [How to: Use SpinLock for Low-Level Synchronization](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  \n  \n-   [How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).  \n  \n## Lazy Initialization Classes  \n With lazy initialization, the memory for an object is not allocated until it is needed. Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program. You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.  \n  \n The following table lists the lazy initialization types:  \n  \n|Type|Description|  \n|----------|-----------------|  \n|<xref:System.Lazy%601?displayProperty=nameWithType>|Provides lightweight, thread-safe lazy-initialization.|  \n|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.|  \n|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance. Instead, they use references to ensure targets have been initialized as they are accessed.|  \n  \n For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).  \n  \n## Aggregate Exceptions  \n The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception. The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose. For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).  \n  \n## See also\n\n- <xref:System.Collections.Concurrent?displayProperty=nameWithType>\n- <xref:System.Threading?displayProperty=nameWithType>\n- [Parallel Programming](../../../docs/standard/parallel-programming/index.md)\n","nodes":[{"pos":[4,256],"embed":true,"restype":"x-metadata","content":"title: \"Data Structures for Parallel Programming\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"data structures, multi-threading\"\nms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Data Structures for Parallel Programming","nodes":[{"pos":[0,40],"content":"Data Structures for Parallel Programming","nodes":[{"content":"Data Structures for Parallel Programming","pos":[0,40]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[263,303],"content":"Data Structures for Parallel Programming","linkify":"Data Structures for Parallel Programming","nodes":[{"content":"Data Structures for Parallel Programming","pos":[0,40]}]},{"content":"The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.","pos":[304,527]},{"content":"You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.","pos":[528,639]},{"pos":[648,677],"content":"Concurrent Collection Classes","linkify":"Concurrent Collection Classes","nodes":[{"content":"Concurrent Collection Classes","pos":[0,29]}]},{"content":"The collection classes in the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent?displayProperty=nameWithType&gt;</ph> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.","pos":[681,923],"source":"The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary."},{"content":"Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.","pos":[924,1106]},{"content":"The concurrent collection classes can significantly improve performance over types such as <ph id=\"ph1\">&lt;xref:System.Collections.ArrayList?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601?displayProperty=nameWithType&gt;</ph> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.","pos":[1107,1446],"source":" The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection."},{"content":"The following table lists the new concurrent collection classes:","pos":[1453,1517]},{"content":"Type","pos":[1524,1528]},{"content":"Description","pos":[1529,1540]},{"content":"Provides blocking and bounding capabilities for thread-safe collections that implement <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType&gt;</ph>.","pos":[1667,1852],"source":"Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>."},{"content":"Producer threads block if no slots are available or if the collection is full.","pos":[1853,1931]},{"content":"Consumer threads block if the collection is empty.","pos":[1932,1982]},{"content":"This type also supports non-blocking access by consumers and producers.","pos":[1983,2054]},{"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601&gt;</ph> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[2055,2282],"source":"<xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>."},{"content":"A thread-safe bag implementation that provides scalable add and get operations.","pos":[2371,2450]},{"content":"A concurrent and scalable dictionary type.","pos":[2546,2588]},{"content":"A concurrent and scalable FIFO queue.","pos":[2679,2716]},{"content":"A concurrent and scalable LIFO stack.","pos":[2807,2844]},{"pos":[2852,2961],"content":"For more information, see <bpt id=\"p1\">[</bpt>Thread-Safe Collections<ept id=\"p1\">](../../../docs/standard/collections/thread-safe/index.md)</ept>.","source":"For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md)."},{"pos":[2970,2996],"content":"Synchronization Primitives","linkify":"Synchronization Primitives","nodes":[{"content":"Synchronization Primitives","pos":[0,26]}]},{"content":"The new synchronization primitives in the <ph id=\"ph1\">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.","pos":[3000,3237],"source":"The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code."},{"content":"Some of the new types, such as <ph id=\"ph1\">&lt;xref:System.Threading.Barrier?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.CountdownEvent?displayProperty=nameWithType&gt;</ph> have no counterparts in earlier releases of the .NET Framework.","pos":[3238,3465],"source":" Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework."},{"content":"The following table lists the new synchronization types:","pos":[3472,3528]},{"content":"Type","pos":[3535,3539]},{"content":"Description","pos":[3540,3551]},{"content":"Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.","pos":[3650,3826]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Barrier<ept id=\"p1\">](../../../docs/standard/threading/barrier.md)</ept>.","pos":[3827,3908],"source":" For more information, see [Barrier](../../../docs/standard/threading/barrier.md)."},{"content":"Simplifies fork and join scenarios by providing an easy rendezvous mechanism.","pos":[3981,4058]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>CountdownEvent<ept id=\"p1\">](../../../docs/standard/threading/countdownevent.md)</ept>.","pos":[4059,4154],"source":" For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md)."},{"content":"A synchronization primitive similar to <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent?displayProperty=nameWithType&gt;</ph>.","pos":[4233,4342],"source":"A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEventSlim&gt;</ph> is lighter-weight but can only be used for intra-process communication.","pos":[4343,4459],"source":"<xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication."},{"content":"A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.","pos":[4531,4656]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Semaphore and SemaphoreSlim<ept id=\"p1\">](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)</ept>.","pos":[4657,4778],"source":" For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)."},{"content":"A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or <bpt id=\"p1\">*</bpt>spin<ept id=\"p1\">*</ept>, for a period of time before yielding its quantum.","pos":[4845,5016],"source":"A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum."},{"content":"In scenarios where the wait for the lock is expected to be short, <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> offers better performance than other forms of locking.","pos":[5017,5170],"source":" In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>SpinLock<ept id=\"p1\">](../../../docs/standard/threading/spinlock.md)</ept>.","pos":[5171,5254],"source":" For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md)."},{"content":"A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.","pos":[5321,5461]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>SpinWait<ept id=\"p1\">](../../../docs/standard/threading/spinwait.md)</ept>.","pos":[5463,5546],"source":"  For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md)."},{"content":"For more information, see:","pos":[5554,5580]},{"pos":[5590,5729],"content":"<bpt id=\"p1\">[</bpt>How to: Use SpinLock for Low-Level Synchronization<ept id=\"p1\">](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)</ept>","source":"[How to: Use SpinLock for Low-Level Synchronization](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)"},{"pos":[5739,5891],"content":"<bpt id=\"p1\">[</bpt>How to: Synchronize Concurrent Operations with a Barrier<ept id=\"p1\">](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)</ept>.","source":"[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)."},{"pos":[5900,5927],"content":"Lazy Initialization Classes","linkify":"Lazy Initialization Classes","nodes":[{"content":"Lazy Initialization Classes","pos":[0,27]}]},{"content":"With lazy initialization, the memory for an object is not allocated until it is needed.","pos":[5931,6018]},{"content":"Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.","pos":[6019,6135]},{"content":"You can enable lazy initialization for any custom type by wrapping the type <ph id=\"ph1\">&lt;xref:System.Lazy%601&gt;</ph>.","pos":[6136,6235],"source":" You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>."},{"content":"The following table lists the lazy initialization types:","pos":[6242,6298]},{"content":"Type","pos":[6305,6309]},{"content":"Description","pos":[6310,6321]},{"content":"Provides lightweight, thread-safe lazy-initialization.","pos":[6411,6465]},{"content":"Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.","pos":[6539,6659]},{"content":"Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.","pos":[6733,6831]},{"content":"Instead, they use references to ensure targets have been initialized as they are accessed.","pos":[6832,6922]},{"pos":[6930,7038],"content":"For more information, see <bpt id=\"p1\">[</bpt>Lazy Initialization<ept id=\"p1\">](../../../docs/framework/performance/lazy-initialization.md)</ept>.","source":"For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md)."},{"pos":[7047,7067],"content":"Aggregate Exceptions","linkify":"Aggregate Exceptions","nodes":[{"content":"Aggregate Exceptions","pos":[0,20]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.AggregateException?displayProperty=nameWithType&gt;</ph> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.","pos":[7071,7295],"source":"The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType&gt;</ph> types and PLINQ use <ph id=\"ph3\">&lt;xref:System.AggregateException&gt;</ph> extensively for this purpose.","pos":[7296,7518],"source":" The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Exception Handling<ept id=\"p1\">](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept> and <bpt id=\"p2\">[</bpt>How to: Handle Exceptions in a PLINQ Query<ept id=\"p2\">](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)</ept>.","pos":[7519,7794],"source":" For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)."},{"pos":[7803,7811],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7938,8014],"content":"<bpt id=\"p1\">[</bpt>Parallel Programming<ept id=\"p1\">](../../../docs/standard/parallel-programming/index.md)</ept>","source":"[Parallel Programming](../../../docs/standard/parallel-programming/index.md)"}]}