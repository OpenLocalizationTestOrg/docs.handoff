{"content":"---\ntitle: \"out parameter modifier (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"parameters [C#], out\"\n  - \"out parameters [C#]\"\nms.assetid: 3fce0dc5-03f4-4faa-bd61-36c41bc6baf1\ncaps.latest.revision: 9\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# out parameter modifier (C# Reference)\nThe `out` keyword causes arguments to be passed by reference. It is like the [ref](../../../csharp/language-reference/keywords/ref.md) keyword, except that `ref` requires that the variable be initialized before it is passed. To use an `out` parameter, both the method definition and the calling method must explicitly use the `out` keyword. For example:  \n  \n [!code-cs[cs-out-keyword](../../../../samples/snippets/csharp/language-reference/keywords/out/out-1.cs)]  \n\n> [!NOTE] \n> The `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](../../../csharp/language-reference/keywords/out-generic-modifier.md).\n  \n Variables passed as `out` arguments do not have to be initialized before being passed in a method call. However, the called method is required to assign a value before the method returns.  \n  \n Although the `ref` and `out` keywords cause different run-time behavior, they are not considered part of the method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one method takes a `ref` argument and the other takes an `out` argument. The following code, for example, will not compile:  \n  \n```csharp\nclass CS0663_Example\n{\n    // Compiler error CS0663: \"Cannot define overloaded \n    // methods that differ only on ref and out\".\n    public void SampleMethod(out int i) { }\n    public void SampleMethod(ref int i) { }\n}\n```\n  \nOverloading is legal, however, if one method takes a `ref` or `out` argument and the other uses neither, like this:  \n  \n [!code-cs[csrefKeywordsMethodParams#3](../../../../samples/snippets/csharp/language-reference/keywords/out/out-3.cs)]  \n  \n Properties are not variables and therefore cannot be passed as `out` parameters.  \n  \n For information about passing arrays, see [Passing Arrays Using ref and out](../../../csharp/programming-guide/arrays/passing-arrays-using-ref-and-out.md).  \n  \n You can't use the `ref` and `out` keywords for the following kinds of methods:  \n  \n-   Async methods, which you define by using the [async](../../../csharp/language-reference/keywords/async.md) modifier.  \n  \n-   Iterator methods, which include a [yield return](../../../csharp/language-reference/keywords/yield.md) or `yield break` statement.  \n\n## Declaring `out` arguments   \n\n Declaring a method with `out` arguments is useful when you want a method to return multiple values. The following example uses `out` to return three variables with a single method call. Note that the third argument is assigned to null. This enables methods to return values optionally.  \n  \n [!code-cs[csrefKeywordsMethodParams#4](../../../../samples/snippets/csharp/language-reference/keywords/out/out-4.cs)]  \n\n The [Try pattern](https://docs.microsoft.com/visualstudio/code-quality/ca1021-avoid-out-parameters#try-pattern-methods.md) involves returning a `bool` to indicate whether an operation succeeded and failed, and returning the value produced by the operation in an `out` argument. A number of parsing methods, such as the @System.DateTime.TryParse(System.String,@System.DateTime) method, use this pattern.\n   \n## Calling a method with an `out` argument\n\nIn C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an `out` argument. The following example declares a variable named `number` before it is passed to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,@System.Int32) method, which attempts to convert a string to a number.\n\n [!code-cs[csrefKeywordsMethodParams#5](../../../../samples/snippets/csharp/language-reference/keywords/out/out-5.cs)]  \n\nStarting with C# 7, you can declare the `out` variable in the argument list of the method call, rather than in a separate variable declaration. This produces more compact, readable code, and also prevents you from inadvertently assigning a value to the variable before the method call. The following example is like the previous example, except that it defines the `number` variable in the call to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,@System.Int32) method.\n\n [!code-cs[csrefKeywordsMethodParams#6](../../../../samples/snippets/csharp/language-reference/keywords/out/out-6.cs)]  \n   \nIn the previous example, the `number` variable is strongly typed as an `int`. You can also declare an implicitly typed local variable, as the following example does.\n\n [!code-cs[csrefKeywordsMethodParams#7](../../../../samples/snippets/csharp/language-reference/keywords/out/out-7.cs)]  \n   \n## C# Language Specification  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n## See Also  \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [C# Keywords](../../../csharp/language-reference/keywords/index.md)   \n [Method Parameters](../../../csharp/language-reference/keywords/method-parameters.md)","nodes":[{"pos":[4,556],"embed":true,"restype":"x-metadata","content":"title: \"out parameter modifier (C# Reference) | Microsoft Docs\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"parameters [C#], out\"\n  - \"out parameters [C#]\"\nms.assetid: 3fce0dc5-03f4-4faa-bd61-36c41bc6baf1\ncaps.latest.revision: 9\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","nodes":[{"content":"out parameter modifier (C# Reference) | Microsoft Docs","nodes":[{"pos":[0,54],"content":"out parameter modifier (C# Reference) | Microsoft Docs","nodes":[{"content":"out parameter modifier (C# Reference) | Microsoft Docs","pos":[0,54]}]}],"path":["title"]}],"yml":true},{"pos":[563,600],"content":"out parameter modifier (C# Reference)","linkify":"out parameter modifier (C# Reference)","nodes":[{"content":"out parameter modifier (C# Reference)","pos":[0,37]}]},{"content":"The <ph id=\"ph1\">`out`</ph> keyword causes arguments to be passed by reference.","pos":[601,662],"source":"The `out` keyword causes arguments to be passed by reference."},{"content":"It is like the <bpt id=\"p1\">[</bpt>ref<ept id=\"p1\">](../../../csharp/language-reference/keywords/ref.md)</ept> keyword, except that <ph id=\"ph1\">`ref`</ph> requires that the variable be initialized before it is passed.","pos":[663,825],"source":" It is like the [ref](../../../csharp/language-reference/keywords/ref.md) keyword, except that `ref` requires that the variable be initialized before it is passed."},{"content":"To use an <ph id=\"ph1\">`out`</ph> parameter, both the method definition and the calling method must explicitly use the <ph id=\"ph2\">`out`</ph> keyword.","pos":[826,941],"source":" To use an `out` parameter, both the method definition and the calling method must explicitly use the `out` keyword."},{"content":"For example:","pos":[942,954]},{"pos":[1071,1364],"content":"[!NOTE] \nThe `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](../../../csharp/language-reference/keywords/out-generic-modifier.md).","leadings":["","> "],"nodes":[{"content":"The `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](../../../csharp/language-reference/keywords/out-generic-modifier.md).","pos":[9,291],"nodes":[{"content":"The <ph id=\"ph1\">`out`</ph> keyword can also be used with a generic type parameter to specify that the type parameter is covariant.","pos":[0,113],"source":"The `out` keyword can also be used with a generic type parameter to specify that the type parameter is covariant."},{"content":"For more information on the use of the <ph id=\"ph1\">`out`</ph> keyword in this context, see <bpt id=\"p1\">[</bpt>out (Generic Modifier)<ept id=\"p1\">](../../../csharp/language-reference/keywords/out-generic-modifier.md)</ept>.","pos":[114,282],"source":" For more information on the use of the `out` keyword in this context, see [out (Generic Modifier)](../../../csharp/language-reference/keywords/out-generic-modifier.md)."}]}]},{"content":"Variables passed as <ph id=\"ph1\">`out`</ph> arguments do not have to be initialized before being passed in a method call.","pos":[1369,1472],"source":"Variables passed as `out` arguments do not have to be initialized before being passed in a method call."},{"content":"However, the called method is required to assign a value before the method returns.","pos":[1473,1556]},{"content":"Although the <ph id=\"ph1\">`ref`</ph> and <ph id=\"ph2\">`out`</ph> keywords cause different run-time behavior, they are not considered part of the method signature at compile time.","pos":[1563,1705],"source":"Although the `ref` and `out` keywords cause different run-time behavior, they are not considered part of the method signature at compile time."},{"content":"Therefore, methods cannot be overloaded if the only difference is that one method takes a <ph id=\"ph1\">`ref`</ph> argument and the other takes an <ph id=\"ph2\">`out`</ph> argument.","pos":[1706,1849],"source":" Therefore, methods cannot be overloaded if the only difference is that one method takes a `ref` argument and the other takes an `out` argument."},{"content":"The following code, for example, will not compile:","pos":[1850,1900]},{"pos":[2142,2257],"content":"Overloading is legal, however, if one method takes a <ph id=\"ph1\">`ref`</ph> or <ph id=\"ph2\">`out`</ph> argument and the other uses neither, like this:","source":"Overloading is legal, however, if one method takes a `ref` or `out` argument and the other uses neither, like this:"},{"pos":[2388,2468],"content":"Properties are not variables and therefore cannot be passed as <ph id=\"ph1\">`out`</ph> parameters.","source":"Properties are not variables and therefore cannot be passed as `out` parameters."},{"pos":[2475,2630],"content":"For information about passing arrays, see <bpt id=\"p1\">[</bpt>Passing Arrays Using ref and out<ept id=\"p1\">](../../../csharp/programming-guide/arrays/passing-arrays-using-ref-and-out.md)</ept>.","source":"For information about passing arrays, see [Passing Arrays Using ref and out](../../../csharp/programming-guide/arrays/passing-arrays-using-ref-and-out.md)."},{"pos":[2637,2715],"content":"You can't use the <ph id=\"ph1\">`ref`</ph> and <ph id=\"ph2\">`out`</ph> keywords for the following kinds of methods:","source":"You can't use the `ref` and `out` keywords for the following kinds of methods:"},{"pos":[2725,2841],"content":"Async methods, which you define by using the <bpt id=\"p1\">[</bpt>async<ept id=\"p1\">](../../../csharp/language-reference/keywords/async.md)</ept> modifier.","source":"Async methods, which you define by using the [async](../../../csharp/language-reference/keywords/async.md) modifier."},{"pos":[2851,2981],"content":"Iterator methods, which include a <bpt id=\"p1\">[</bpt>yield return<ept id=\"p1\">](../../../csharp/language-reference/keywords/yield.md)</ept> or <ph id=\"ph1\">`yield break`</ph> statement.","source":"Iterator methods, which include a [yield return](../../../csharp/language-reference/keywords/yield.md) or `yield break` statement."},{"pos":[2988,3013],"content":"Declaring <ph id=\"ph1\">`out`</ph> arguments","linkify":"Declaring `out` arguments","source":"Declaring `out` arguments"},{"content":"Declaring a method with <ph id=\"ph1\">`out`</ph> arguments is useful when you want a method to return multiple values.","pos":[3019,3118],"source":"Declaring a method with `out` arguments is useful when you want a method to return multiple values."},{"content":"The following example uses <ph id=\"ph1\">`out`</ph> to return three variables with a single method call.","pos":[3119,3204],"source":" The following example uses `out` to return three variables with a single method call."},{"content":"Note that the third argument is assigned to null.","pos":[3205,3254]},{"content":"This enables methods to return values optionally.","pos":[3255,3304]},{"content":"The <bpt id=\"p1\">[</bpt>Try pattern<ept id=\"p1\">](https://docs.microsoft.com/visualstudio/code-quality/ca1021-avoid-out-parameters#try-pattern-methods.md)</ept> involves returning a <ph id=\"ph1\">`bool`</ph> to indicate whether an operation succeeded and failed, and returning the value produced by the operation in an <ph id=\"ph2\">`out`</ph> argument.","pos":[3433,3710],"source":"The [Try pattern](https://docs.microsoft.com/visualstudio/code-quality/ca1021-avoid-out-parameters#try-pattern-methods.md) involves returning a `bool` to indicate whether an operation succeeded and failed, and returning the value produced by the operation in an `out` argument."},{"content":"A number of parsing methods, such as the <ph id=\"ph1\">@System.DateTime.TryParse</ph>(System.String,<ph id=\"ph2\">@System.DateTime</ph>) method, use this pattern.","pos":[3711,3835],"source":" A number of parsing methods, such as the @System.DateTime.TryParse(System.String,@System.DateTime) method, use this pattern."},{"pos":[3843,3882],"content":"Calling a method with an <ph id=\"ph1\">`out`</ph> argument","linkify":"Calling a method with an `out` argument","source":"Calling a method with an `out` argument"},{"content":"In C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an <ph id=\"ph1\">`out`</ph> argument.","pos":[3884,3997],"source":"In C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an `out` argument."},{"content":"The following example declares a variable named <ph id=\"ph1\">`number`</ph> before it is passed to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,<ph id=\"ph2\">@System.Int32</ph>) method, which attempts to convert a string to a number.","pos":[3998,4210],"source":" The following example declares a variable named `number` before it is passed to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,@System.Int32) method, which attempts to convert a string to a number."},{"content":"Starting with C# 7, you can declare the <ph id=\"ph1\">`out`</ph> variable in the argument list of the method call, rather than in a separate variable declaration.","pos":[4334,4477],"source":"Starting with C# 7, you can declare the `out` variable in the argument list of the method call, rather than in a separate variable declaration."},{"content":"This produces more compact, readable code, and also prevents you from inadvertently assigning a value to the variable before the method call.","pos":[4478,4619]},{"content":"The following example is like the previous example, except that it defines the <ph id=\"ph1\">`number`</ph> variable in the call to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,<ph id=\"ph2\">@System.Int32</ph>) method.","pos":[4620,4816],"source":" The following example is like the previous example, except that it defines the `number` variable in the call to the [Int32.TryParse](xref:System.Int32.TryParse(System.String,@System.Int32) method."},{"content":"In the previous example, the <ph id=\"ph1\">`number`</ph> variable is strongly typed as an <ph id=\"ph2\">`int`</ph>.","pos":[4943,5020],"source":"In the previous example, the `number` variable is strongly typed as an `int`."},{"content":"You can also declare an implicitly typed local variable, as the following example does.","pos":[5021,5108]},{"pos":[5238,5263],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"pos":[5377,5385],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5389,5449],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5453,5520],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[5524,5592],"source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Method Parameters<ept id=\"p1\">](../../../csharp/language-reference/keywords/method-parameters.md)</ept>","pos":[5596,5681],"source":"[Method Parameters](../../../csharp/language-reference/keywords/method-parameters.md)"}]}