{"content":"---\ntitle: \"long - C# Reference\"\nms.custom: seodec18\nms.date: 03/14/2017\nf1_keywords:\n  - \"long_CSharpKeyword\"\n  - \"long\"\nhelpviewer_keywords:\n  - \"long keyword [C#]\"\nms.assetid: f9b24319-1f39-48be-a42b-d528ee28a7fd\n---\n# long (C# Reference)\n\n`long` denotes an integral type that stores values according to the size and range shown in the following table.\n\n|Type|Range|Size|.NET type|\n|----------|-----------|----------|-------------------------|\n|`long`|-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807|Signed 64-bit integer|<xref:System.Int64?displayProperty=nameWithType>|\n\n## Literals\n\nYou can declare and initialize a `long` variable by assigning a decimal literal, a hexadecimal literal, or (starting with C# 7.0) a binary literal to it.\n\nIn the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and binary literals are assigned to `long` values.\n\n[!code-csharp[long](../../../../samples/snippets/csharp/language-reference/keywords/numeric-literals.cs#Long)]\n\n> [!NOTE]\n> You use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal. Decimal literals have no prefix.\n\nStarting with C# 7.0, a couple of features have been added to enhance readability.\n- C# 7.0 allows the usage of the underscore character, `_`, as a digit separator.\n- C# 7.2 allows `_` to be used as a digit separator for a binary or hexadecimal literal, after the prefix. A decimal literal isn't permitted to have a leading underscore.\n\nSome examples are shown below.\n\n[!code-csharp[long](../../../../samples/snippets/csharp/language-reference/keywords/numeric-literals.cs#LongS)]\n\nInteger literals can also include a suffix that denotes the type. The suffix `L` denotes a `long`. The following example uses the `L` suffix to denote a long integer:\n\n```csharp\nlong value = 4294967296L;\n```\n\n> [!NOTE]\n> You can also use the lowercase letter \"l\" as a suffix. However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\" Use \"L\" for clarity.\n\nWhen you use the suffix `L`, the type of the literal integer is determined to be either `long` or [ulong](../../../csharp/language-reference/keywords/ulong.md), depending on its size. In this case, it is `long` because it less than the range of [ulong](../../../csharp/language-reference/keywords/ulong.md).\n\nA common use of the suffix is to call overloaded methods. For example, the following overloaded methods have parameters of type `long` and [int](../../../csharp/language-reference/keywords/int.md):\n\n```csharp\npublic static void SampleMethod(int i) {}\npublic static void SampleMethod(long l) {}\n```\n\nThe `L` suffix guarantees that the correct overload is called:\n\n```csharp\nSampleMethod(5);    // Calls the method with the int parameter\nSampleMethod(5L);   // Calls the method with the long parameter\n```\nIf an integer literal has no suffix, its type is the first of the following types in which its value can be represented:\n\n1. [int](int.md)\n2. [uint](../../../csharp/language-reference/keywords/uint.md)\n3. `long`\n4. [ulong](../../../csharp/language-reference/keywords/ulong.md)\n\nThe literal 4294967296 in the previous examples is of type `long`, because it exceeds the range of [uint](../../../csharp/language-reference/keywords/uint.md) (see [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md) for the storage sizes of integral types).\n\nIf you use the `long` type with other integral types in the same expression, the expression is evaluated as `long` (or [bool](../../../csharp/language-reference/keywords/bool.md) in the case of relational or Boolean expressions). For example, the following expression evaluates as `long`:\n\n```csharp\n898L + 88\n```\n\nFor information on arithmetic expressions with mixed floating-point types and integral types, see [float](../../../csharp/language-reference/keywords/float.md) and [double](../../../csharp/language-reference/keywords/double.md).\n\n## Conversions\n\nThere is a predefined implicit conversion from `long` to [float](../../../csharp/language-reference/keywords/float.md), [double](../../../csharp/language-reference/keywords/double.md), or [decimal](../../../csharp/language-reference/keywords/decimal.md). Otherwise a cast must be used. For example, the following statement will produce a compilation error without an explicit cast:\n\n```csharp\nint x = 8L;        // Error: no implicit conversion from long to int\nint y = (int)8L;   // OK: explicit conversion to int\n```\n\nThere is a predefined implicit conversion from [sbyte](../../../csharp/language-reference/keywords/sbyte.md), [byte](../../../csharp/language-reference/keywords/byte.md), [short](../../../csharp/language-reference/keywords/short.md), [ushort](../../../csharp/language-reference/keywords/ushort.md), [int](../../../csharp/language-reference/keywords/int.md), [uint](../../../csharp/language-reference/keywords/uint.md), or [char](../../../csharp/language-reference/keywords/char.md) to `long`.\n\nNotice also that there is no implicit conversion from floating-point types to `long`. For example, the following statement generates a compiler error unless an explicit cast is used:\n\n```csharp\nlong x = 3.0;         // Error: no implicit conversion from double\nlong y = (long)3.0;   // OK: explicit conversion\n```\n\n## C# Language Specification\n\nFor more information, see [Integral types](~/_csharplang/spec/types.md#integral-types) in the [C# Language Specification](../language-specification/index.md). The language specification is the definitive source for C# syntax and usage.\n\n## See also\n\n- <xref:System.Int64>\n- [C# Reference](../../../csharp/language-reference/index.md)\n- [C# Programming Guide](../../../csharp/programming-guide/index.md)\n- [C# Keywords](../../../csharp/language-reference/keywords/index.md)\n- [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md)\n- [Built-In Types Table](../../../csharp/language-reference/keywords/built-in-types-table.md)\n- [Implicit Numeric Conversions Table](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md)\n- [Explicit Numeric Conversions Table](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)\n","nodes":[{"pos":[4,215],"embed":true,"restype":"x-metadata","content":"title: \"long - C# Reference\"\nms.custom: seodec18\nms.date: 03/14/2017\nf1_keywords:\n  - \"long_CSharpKeyword\"\n  - \"long\"\nhelpviewer_keywords:\n  - \"long keyword [C#]\"\nms.assetid: f9b24319-1f39-48be-a42b-d528ee28a7fd","nodes":[{"content":"long - C# Reference","nodes":[{"pos":[0,19],"content":"long - C# Reference","nodes":[{"content":"long - C# Reference","pos":[0,19]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[222,241],"content":"long (C# Reference)","linkify":"long (C# Reference)","nodes":[{"content":"long (C# Reference)","pos":[0,19]}]},{"pos":[243,355],"content":"<ph id=\"ph1\">`long`</ph> denotes an integral type that stores values according to the size and range shown in the following table.","source":"`long` denotes an integral type that stores values according to the size and range shown in the following table."},{"content":"Type","pos":[358,362]},{"content":"Range","pos":[363,368]},{"content":"Size","pos":[369,373]},{"content":".NET type","pos":[374,383]},{"content":"-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807","pos":[455,510]},{"content":"Signed 64-bit integer","pos":[511,532]},{"pos":[587,595],"content":"Literals","linkify":"Literals","nodes":[{"content":"Literals","pos":[0,8]}]},{"pos":[597,750],"content":"You can declare and initialize a <ph id=\"ph1\">`long`</ph> variable by assigning a decimal literal, a hexadecimal literal, or (starting with C# 7.0) a binary literal to it.","source":"You can declare and initialize a `long` variable by assigning a decimal literal, a hexadecimal literal, or (starting with C# 7.0) a binary literal to it."},{"pos":[752,906],"content":"In the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and binary literals are assigned to <ph id=\"ph1\">`long`</ph> values.","source":"In the following example, integers equal to 4,294,967,296 that are represented as decimal, hexadecimal, and binary literals are assigned to `long` values."},{"pos":[1022,1184],"content":"[!NOTE]\nYou use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal. Decimal literals have no prefix.","leadings":["","> "],"nodes":[{"content":"You use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal. Decimal literals have no prefix.","pos":[8,160],"nodes":[{"content":"You use the prefix <ph id=\"ph1\">`0x`</ph> or <ph id=\"ph2\">`0X`</ph> to denote a hexadecimal literal and the prefix <ph id=\"ph3\">`0b`</ph> or <ph id=\"ph4\">`0B`</ph> to denote a binary literal.","pos":[0,119],"source":"You use the prefix `0x` or `0X` to denote a hexadecimal literal and the prefix `0b` or `0B` to denote a binary literal."},{"content":"Decimal literals have no prefix.","pos":[120,152]}]}]},{"content":"Starting with C# 7.0, a couple of features have been added to enhance readability.","pos":[1186,1268]},{"pos":[1271,1350],"content":"C# 7.0 allows the usage of the underscore character, <ph id=\"ph1\">`_`</ph>, as a digit separator.","source":"C# 7.0 allows the usage of the underscore character, `_`, as a digit separator."},{"content":"C# 7.2 allows <ph id=\"ph1\">`_`</ph> to be used as a digit separator for a binary or hexadecimal literal, after the prefix.","pos":[1353,1457],"source":"C# 7.2 allows `_` to be used as a digit separator for a binary or hexadecimal literal, after the prefix."},{"content":"A decimal literal isn't permitted to have a leading underscore.","pos":[1458,1521]},{"content":"Some examples are shown below.","pos":[1523,1553]},{"content":"Integer literals can also include a suffix that denotes the type.","pos":[1668,1733]},{"content":"The suffix <ph id=\"ph1\">`L`</ph> denotes a <ph id=\"ph2\">`long`</ph>.","pos":[1734,1766],"source":" The suffix `L` denotes a `long`."},{"content":"The following example uses the <ph id=\"ph1\">`L`</ph> suffix to denote a long integer:","pos":[1767,1834],"source":" The following example uses the `L` suffix to denote a long integer:"},{"pos":[1879,2069],"content":"[!NOTE]\nYou can also use the lowercase letter \"l\" as a suffix. However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\" Use \"L\" for clarity.","leadings":["","> "],"nodes":[{"content":"You can also use the lowercase letter \"l\" as a suffix. However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\" Use \"L\" for clarity.","pos":[8,188],"nodes":[{"content":"You can also use the lowercase letter \"l\" as a suffix.","pos":[0,54]},{"content":"However, this generates a compiler warning because the letter \"l\" is easily confused with the digit \"1.\"","pos":[55,159]},{"content":"Use \"L\" for clarity.","pos":[160,180]}]}]},{"content":"When you use the suffix <ph id=\"ph1\">`L`</ph>, the type of the literal integer is determined to be either <ph id=\"ph2\">`long`</ph> or <bpt id=\"p1\">[</bpt>ulong<ept id=\"p1\">](../../../csharp/language-reference/keywords/ulong.md)</ept>, depending on its size.","pos":[2071,2254],"source":"When you use the suffix `L`, the type of the literal integer is determined to be either `long` or [ulong](../../../csharp/language-reference/keywords/ulong.md), depending on its size."},{"content":"In this case, it is <ph id=\"ph1\">`long`</ph> because it less than the range of <bpt id=\"p1\">[</bpt>ulong<ept id=\"p1\">](../../../csharp/language-reference/keywords/ulong.md)</ept>.","pos":[2255,2378],"source":" In this case, it is `long` because it less than the range of [ulong](../../../csharp/language-reference/keywords/ulong.md)."},{"content":"A common use of the suffix is to call overloaded methods.","pos":[2380,2437]},{"content":"For example, the following overloaded methods have parameters of type <ph id=\"ph1\">`long`</ph> and <bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](../../../csharp/language-reference/keywords/int.md)</ept>:","pos":[2438,2577],"source":" For example, the following overloaded methods have parameters of type `long` and [int](../../../csharp/language-reference/keywords/int.md):"},{"pos":[2679,2741],"content":"The <ph id=\"ph1\">`L`</ph> suffix guarantees that the correct overload is called:","source":"The `L` suffix guarantees that the correct overload is called:"},{"content":"If an integer literal has no suffix, its type is the first of the following types in which its value can be represented:","pos":[2884,3004]},{"pos":[3009,3022],"content":"<bpt id=\"p1\">[</bpt>int<ept id=\"p1\">](int.md)</ept>","source":"[int](int.md)"},{"pos":[3026,3085],"content":"<bpt id=\"p1\">[</bpt>uint<ept id=\"p1\">](../../../csharp/language-reference/keywords/uint.md)</ept>","source":"[uint](../../../csharp/language-reference/keywords/uint.md)"},{"pos":[3099,3160],"content":"<bpt id=\"p1\">[</bpt>ulong<ept id=\"p1\">](../../../csharp/language-reference/keywords/ulong.md)</ept>","source":"[ulong](../../../csharp/language-reference/keywords/ulong.md)"},{"pos":[3162,3459],"content":"The literal 4294967296 in the previous examples is of type <ph id=\"ph1\">`long`</ph>, because it exceeds the range of <bpt id=\"p1\">[</bpt>uint<ept id=\"p1\">](../../../csharp/language-reference/keywords/uint.md)</ept> (see <bpt id=\"p2\">[</bpt>Integral Types Table<ept id=\"p2\">](../../../csharp/language-reference/keywords/integral-types-table.md)</ept> for the storage sizes of integral types).","source":"The literal 4294967296 in the previous examples is of type `long`, because it exceeds the range of [uint](../../../csharp/language-reference/keywords/uint.md) (see [Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md) for the storage sizes of integral types)."},{"content":"If you use the <ph id=\"ph1\">`long`</ph> type with other integral types in the same expression, the expression is evaluated as <ph id=\"ph2\">`long`</ph> (or <bpt id=\"p1\">[</bpt>bool<ept id=\"p1\">](../../../csharp/language-reference/keywords/bool.md)</ept> in the case of relational or Boolean expressions).","pos":[3461,3690],"source":"If you use the `long` type with other integral types in the same expression, the expression is evaluated as `long` (or [bool](../../../csharp/language-reference/keywords/bool.md) in the case of relational or Boolean expressions)."},{"content":"For example, the following expression evaluates as <ph id=\"ph1\">`long`</ph>:","pos":[3691,3749],"source":" For example, the following expression evaluates as `long`:"},{"pos":[3776,4004],"content":"For information on arithmetic expressions with mixed floating-point types and integral types, see <bpt id=\"p1\">[</bpt>float<ept id=\"p1\">](../../../csharp/language-reference/keywords/float.md)</ept> and <bpt id=\"p2\">[</bpt>double<ept id=\"p2\">](../../../csharp/language-reference/keywords/double.md)</ept>.","source":"For information on arithmetic expressions with mixed floating-point types and integral types, see [float](../../../csharp/language-reference/keywords/float.md) and [double](../../../csharp/language-reference/keywords/double.md)."},{"pos":[4009,4020],"content":"Conversions","linkify":"Conversions","nodes":[{"content":"Conversions","pos":[0,11]}]},{"content":"There is a predefined implicit conversion from <ph id=\"ph1\">`long`</ph> to <bpt id=\"p1\">[</bpt>float<ept id=\"p1\">](../../../csharp/language-reference/keywords/float.md)</ept>, <bpt id=\"p2\">[</bpt>double<ept id=\"p2\">](../../../csharp/language-reference/keywords/double.md)</ept>, or <bpt id=\"p3\">[</bpt>decimal<ept id=\"p3\">](../../../csharp/language-reference/keywords/decimal.md)</ept>.","pos":[4022,4276],"source":"There is a predefined implicit conversion from `long` to [float](../../../csharp/language-reference/keywords/float.md), [double](../../../csharp/language-reference/keywords/double.md), or [decimal](../../../csharp/language-reference/keywords/decimal.md)."},{"content":"Otherwise a cast must be used.","pos":[4277,4307]},{"content":"For example, the following statement will produce a compilation error without an explicit cast:","pos":[4308,4403]},{"pos":[4542,5034],"content":"There is a predefined implicit conversion from <bpt id=\"p1\">[</bpt>sbyte<ept id=\"p1\">](../../../csharp/language-reference/keywords/sbyte.md)</ept>, <bpt id=\"p2\">[</bpt>byte<ept id=\"p2\">](../../../csharp/language-reference/keywords/byte.md)</ept>, <bpt id=\"p3\">[</bpt>short<ept id=\"p3\">](../../../csharp/language-reference/keywords/short.md)</ept>, <bpt id=\"p4\">[</bpt>ushort<ept id=\"p4\">](../../../csharp/language-reference/keywords/ushort.md)</ept>, <bpt id=\"p5\">[</bpt>int<ept id=\"p5\">](../../../csharp/language-reference/keywords/int.md)</ept>, <bpt id=\"p6\">[</bpt>uint<ept id=\"p6\">](../../../csharp/language-reference/keywords/uint.md)</ept>, or <bpt id=\"p7\">[</bpt>char<ept id=\"p7\">](../../../csharp/language-reference/keywords/char.md)</ept> to <ph id=\"ph1\">`long`</ph>.","source":"There is a predefined implicit conversion from [sbyte](../../../csharp/language-reference/keywords/sbyte.md), [byte](../../../csharp/language-reference/keywords/byte.md), [short](../../../csharp/language-reference/keywords/short.md), [ushort](../../../csharp/language-reference/keywords/ushort.md), [int](../../../csharp/language-reference/keywords/int.md), [uint](../../../csharp/language-reference/keywords/uint.md), or [char](../../../csharp/language-reference/keywords/char.md) to `long`."},{"content":"Notice also that there is no implicit conversion from floating-point types to <ph id=\"ph1\">`long`</ph>.","pos":[5036,5121],"source":"Notice also that there is no implicit conversion from floating-point types to `long`."},{"content":"For example, the following statement generates a compiler error unless an explicit cast is used:","pos":[5122,5218]},{"pos":[5354,5379],"content":"C# Language Specification","linkify":"C# Language Specification","nodes":[{"content":"C# Language Specification","pos":[0,25]}]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Integral types<ept id=\"p1\">](~/_csharplang/spec/types.md#integral-types)</ept> in the <bpt id=\"p2\">[</bpt>C# Language Specification<ept id=\"p2\">](../language-specification/index.md)</ept>.","pos":[5381,5539],"source":"For more information, see [Integral types](~/_csharplang/spec/types.md#integral-types) in the [C# Language Specification](../language-specification/index.md)."},{"content":"The language specification is the definitive source for C# syntax and usage.","pos":[5540,5616]},{"pos":[5621,5629],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5655,5714],"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept>","source":"[C# Reference](../../../csharp/language-reference/index.md)"},{"pos":[5717,5783],"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept>","source":"[C# Programming Guide](../../../csharp/programming-guide/index.md)"},{"pos":[5786,5853],"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept>","source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md)"},{"pos":[5856,5947],"content":"<bpt id=\"p1\">[</bpt>Integral Types Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/integral-types-table.md)</ept>","source":"[Integral Types Table](../../../csharp/language-reference/keywords/integral-types-table.md)"},{"pos":[5950,6041],"content":"<bpt id=\"p1\">[</bpt>Built-In Types Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/built-in-types-table.md)</ept>","source":"[Built-In Types Table](../../../csharp/language-reference/keywords/built-in-types-table.md)"},{"pos":[6044,6163],"content":"<bpt id=\"p1\">[</bpt>Implicit Numeric Conversions Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md)</ept>","source":"[Implicit Numeric Conversions Table](../../../csharp/language-reference/keywords/implicit-numeric-conversions-table.md)"},{"pos":[6166,6285],"content":"<bpt id=\"p1\">[</bpt>Explicit Numeric Conversions Table<ept id=\"p1\">](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)</ept>","source":"[Explicit Numeric Conversions Table](../../../csharp/language-reference/keywords/explicit-numeric-conversions-table.md)"}]}