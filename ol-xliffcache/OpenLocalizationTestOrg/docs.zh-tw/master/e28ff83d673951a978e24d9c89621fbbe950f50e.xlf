<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="dotnet-core-2-1.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e28ff83d673951a978e24d9c89621fbbe950f50e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\core\whats-new\dotnet-core-2-1.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dotnet-core</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">63681b67a96e55f537cad2c173056bf1d7bf748f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1ad87bea89b7bcf4deb44fcc43f0d112d528c3aa</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's new in .NET Core 2.1</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn about the new features found in .NET Core 2.1.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>What's new in .NET Core 2.1</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>.NET Core 2.1 includes enhancements and new features in the following areas:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tooling<ept id="p1">](#tooling)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Roll forward<ept id="p1">](#roll-forward)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Deployment<ept id="p1">](#deployment)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Windows Compatibility Pack<ept id="p1">](#windows-compatibility-pack)</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>JIT compilation improvements<ept id="p1">](#jit-compiler-improvements)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>API changes<ept id="p1">](#api-changes)</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Tooling</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The .NET Core 2.1 SDK (v 2.1.300), the tooling included with .NET Core 2.1, includes the following changes and enhancements:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Build performance improvements</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>A major focus of .NET Core 2.1 is improving build-time performance, particularly for incremental builds.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>These performance improvements apply to both command-line builds using <ph id="ph1">`dotnet build`</ph> and to builds in Visual Studio.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Some individual areas of improvement include:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For package asset resolution, resolving only assets used by a build rather than all assets.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Caching of assembly references.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Use of long-running SDK build servers, which are processes that span across individual <ph id="ph1">`dotnet build`</ph> invocations.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>They eliminate the need to JIT-compile large blocks of code every time <ph id="ph1">`dotnet build`</ph> is run.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Build server processes can be automatically terminated with the following command:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>New CLI commands</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A number of tools that were available only on a per project basis using <bpt id="p1">[</bpt><ph id="ph1">`DotnetCliToolReference`</ph><ept id="p1">](../tools/extensibility.md)</ept> are now available as part of the .NET Core SDK.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>These tools include:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet watch`</ph> provides a file system watcher that waits for a file to change before executing a designated set of commands.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>For example, the following command automatically rebuilds the current project and generates verbose output whenever a file in it changes:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Note the <ph id="ph1">`--`</ph> option that precedes the <ph id="ph2">`--verbose`</ph> option.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>It delimits the options passed directly to the <ph id="ph1">`dotnet watch`</ph> command from the arguments that are passed to the child <ph id="ph2">`dotnet`</ph> process.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Without it, the <ph id="ph1">`--verbose`</ph> option applies to the <ph id="ph2">`dotnet watch`</ph> command, not the <ph id="ph3">`dotnet build`</ph> command.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Develop ASP.NET Core apps using dotnet watch<ept id="p1">](/aspnet/core/tutorials/dotnet-watch)</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet dev-certs`</ph> generates and manages certificates used during development in ASP.NET Core applications.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet user-secrets`</ph> manages the secrets in a user secret store in ASP.NET Core applications.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet sql-cache`</ph> creates a table and indexes in a Microsoft SQL Server database to be used for distributed caching.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet ef`</ph> is a tool for managing databases, <ph id="ph2">&lt;xref:Microsoft.EntityFrameworkCore.DbContext&gt;</ph> objects, and migrations in Entity Framework Core applications.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>EF Core .NET Command-line Tools<ept id="p1">](/ef/core/miscellaneous/cli/dotnet)</ept>.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Global Tools</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>.NET Core 2.1 supports <bpt id="p1">*</bpt>Global Tools<ept id="p1">*</ept> -- that is, custom tools that are available globally from the command line.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The extensibility model in previous versions of .NET Core made custom tools available on a per project basis only by using <bpt id="p1">[</bpt><ph id="ph1">`DotnetCliToolReference`</ph><ept id="p1">](../tools/extensibility.md#consuming-per-project-tools)</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To install a Global Tool, you use the <bpt id="p1">[</bpt>dotnet tool install<ept id="p1">](../tools/dotnet-tool-install.md)</ept> command.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Once installed, the tool can be run from the command line by specifying the tool name.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Core Global Tools overview<ept id="p1">](../tools/global-tools.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Tool management with the <ph id="ph1">`dotnet tool`</ph> command</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In .NET Core 2.1 SDK, all tools operations use the <ph id="ph1">`dotnet tool`</ph> command.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet tool install`</ph><ept id="p1">](../tools/dotnet-tool-install.md)</ept> to install a tool.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet tool update`</ph><ept id="p1">](../tools/dotnet-tool-update.md)</ept> to uninstall and reinstall a tool, which effectively updates it.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet tool list`</ph><ept id="p1">](../tools/dotnet-tool-list.md)</ept> to list currently installed tools.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`dotnet tool uninstall`</ph><ept id="p1">](../tools/dotnet-tool-uninstall.md)</ept> to uninstall currently installed tools.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Roll forward</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>All .NET Core applications starting with .NET Core 2.0 automatically roll forward to the latest <bpt id="p1">*</bpt>minor version<ept id="p1">*</ept> installed on a system.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Starting with .NET Core 2.0, if the version of .NET Core that an application was built with is not present at runtime, the application automatically runs against the latest installed <bpt id="p1">*</bpt>minor version<ept id="p1">*</ept> of .NET Core.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In other words, if an application is built with .NET Core 2.0, and .NET Core 2.0 is not present on the host system but .NET Core 2.1 is, the application runs with .NET Core 2.1.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This roll-forward behavior doesn't apply to preview releases.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>By default, it also doesn't apply to major releases, but this can be changed with the settings below.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can modify this behavior by changing the setting for the roll-forward on no candidate shared framework.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The available settings are:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`0`</ph> - disable minor version roll-forward behavior.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>With this setting, an application built for .NET Core 2.0.0 will roll forward to .NET Core 2.0.1, but not to .NET Core 2.2.0 or .NET Core 3.0.0.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`1`</ph> - enable minor version roll-forward behavior.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This is the default value for the setting.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>With this setting, an application built for .NET Core 2.0.0 will roll forward to either .NET Core 2.0.1 or .NET Core 2.2.0, depending on which one is installed, but it will not roll forward to .NET Core 3.0.0.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`2`</ph> - enable minor and major version roll-forward behavior.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If set, even different major versions are considered, so an application built for .NET Core 2.0.0 will roll forward to .NET Core 3.0.0.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can modify this setting in any of three ways:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Set the <ph id="ph1">`DOTNET_ROLL_FORWARD_ON_NO_CANDIDATE_FX`</ph> environment variable to the desired value.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Add the following line with the desired value to the <ph id="ph1">`runtimeconfig.json`</ph> file:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>When using <bpt id="p1">[</bpt>.NET Core CLI tools<ept id="p1">](../tools/index.md)</ept>, add the following option with the desired value to a .NET Core command such as <ph id="ph1">`run`</ph>:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Patch version roll forward is independent of this setting and is done after any potential minor or major version roll forward is applied.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Deployment</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Self-contained application servicing</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`dotnet publish`</ph> now publishes self-contained applications with a serviced runtime version.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When you publish a self-contained application with the .NET Core 2.1 SDK (v 2.1.300), your application includes the latest serviced runtime version known by that SDK.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>When you upgrade to the latest SDK, you’ll publish with the latest .NET Core runtime version.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This applies for .NET Core 1.0 runtimes and later.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Self-contained publishing relies on runtime versions on NuGet.org. You do not need to have the serviced runtime on your machine.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Using the .NET Core 2.0 SDK, self-contained applications are published with the .NET Core 2.0.0 runtime unless a different version is specified via the <ph id="ph1">`RuntimeFrameworkVersion`</ph> property.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>With this new behavior, you’ll no longer need to set this property to select a higher runtime version for a self-contained application.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The easiest approach going forward is to always publish with .NET Core 2.1 SDK (v 2.1.300).</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Self-contained deployment runtime roll forward<ept id="p1">](../deploying/runtime-patch-selection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Windows Compatibility Pack</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>When you port existing code from the .NET Framework to .NET Core, you can use the <bpt id="p1">[</bpt>Windows Compatibility Pack<ept id="p1">](https://www.nuget.org/packages/Microsoft.Windows.Compatibility)</ept>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>It provides access to 20,000 more APIs than are available in .NET Core.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>These APIs include types in the <ph id="ph1">&lt;xref:System.Drawing?displayProperty=nameWithType&gt;</ph> namespace, the <ph id="ph2">&lt;xref:System.Diagnostics.EventLog&gt;</ph> class, WMI, Performance Counters, Windows Services, and the Windows registry types and members.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>JIT compiler improvements</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>.NET Core incorporates a new JIT compiler technology called <bpt id="p1">*</bpt>tiered compilation<ept id="p1">*</ept> (also known as <bpt id="p2">*</bpt>adaptive optimization<ept id="p2">*</ept>) that can significantly improve performance.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Tiered compilation is an opt-in setting.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>One of the important tasks performed by the JIT compiler is optimizing code execution.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For little-used code paths, however, the compiler may spend more time optimizing code than the runtime spends running unoptimized code.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Tiered compilation introduces two stages in JIT compilation:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>first tier<ept id="p1">**</ept>, which generates code as quickly as possible.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>second tier<ept id="p1">**</ept>, which generates optimized code for those methods that are executed frequently.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The second tier of compilation is performed in parallel for enhanced performance.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>You can opt into tiered compilation in either of two ways.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>To use tiered compilation in all projects that use the .NET Core 2.1 SDK, set the following environment variable:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>To use tiered compilation on a per-project basis, add the <ph id="ph1">`&lt;TieredCompilation&gt;`</ph> property to the <ph id="ph2">`&lt;PropertyGroup&gt;`</ph> section of the MSBuild project file, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>API changes</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Span&lt;T&gt;`</ph> and <ph id="ph2">`Memory&lt;T&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>.NET Core 2.1 includes some new types that make working with arrays and other types of memory much more efficient.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The new types include:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Span%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.ReadOnlySpan%601?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Memory%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.ReadOnlyMemory%601?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Without these types, when passing such items as a portion of an array or a section of a memory buffer, you have to make a copy of some portion of the data before passing it to a method.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>These types provide a virtual view of that data that eliminates the need for the additional memory allocation and copy operations.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Span%601&gt;</ph> and <ph id="ph2">&lt;xref:System.Memory%601&gt;</ph> instance to provide a virtual view of 10 elements of an array.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Brotli compression</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>.NET Core 2.1 adds support for Brotli compression and decompression.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Brotli is a general-purpose lossless compression algorithm that is defined in <bpt id="p1">[</bpt>RFC 7932<ept id="p1">](https://www.ietf.org/rfc/rfc7932.txt)</ept> and is supported by most web browsers and major web servers.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can use the stream-based <ph id="ph1">&lt;xref:System.IO.Compression.BrotliStream?displayProperty=nameWithType&gt;</ph> class or the high-performance span-based <ph id="ph2">&lt;xref:System.IO.Compression.BrotliEncoder?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.Compression.BrotliDecoder?displayProperty=nameWithType&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example illustrates compression with the <ph id="ph1">&lt;xref:System.IO.Compression.BrotliStream&gt;</ph> class:</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.IO.Compression.BrotliStream&gt;</ph> behavior is the same as <ph id="ph2">&lt;xref:System.IO.Compression.DeflateStream&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.Compression.GZipStream&gt;</ph>, which makes it easy to convert code that calls these APIs to <ph id="ph4">&lt;xref:System.IO.Compression.BrotliStream&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>New cryptography APIs and cryptography improvements</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>.NET Core 2.1 includes numerous enhancements to the cryptography APIs:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.Pkcs.SignedCms?displayProperty=nameWithType&gt;</ph> is available in the System.Security.Cryptography.Pkcs package.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The implementation is the same as the <ph id="ph1">&lt;xref:System.Security.Cryptography.Pkcs.SignedCms&gt;</ph> class in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>New overloads of the <ph id="ph1">&lt;xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHash%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.Cryptography.X509Certificates.X509Certificate.GetCertHashString%2A?displayProperty=nameWithType&gt;</ph> methods accept a hash algorithm identifier to enable callers to get certificate thumbprint values using algorithms other than SHA-1.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>New <ph id="ph1">&lt;xref:System.Span%601&gt;</ph>-based cryptography APIs are available for hashing, HMAC, cryptographic random number generation, asymmetric signature generation, asymmetric signature processing, and RSA encryption.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The performance of <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes?displayProperty=nameWithType&gt;</ph> has improved by about 15% by using a <ph id="ph2">&lt;xref:System.Span%601&gt;</ph>-based implementation.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref:System.Security.Cryptography.CryptographicOperations?displayProperty=nameWithType&gt;</ph> class includes two new methods:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.CryptographicOperations.FixedTimeEquals%2A&gt;</ph> takes a fixed amount of time to return for any two inputs of the same length, which makes it suitable for use in cryptographic verification to avoid contributing to timing side-channel information.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.CryptographicOperations.ZeroMemory%2A&gt;</ph> is a memory-clearing routine that cannot be optimized.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The static <ph id="ph1">&lt;xref:System.Security.Cryptography.RandomNumberGenerator.Fill%2A?displayProperty=nameWithType&gt;</ph> method fills a <ph id="ph2">&lt;xref:System.Span%601&gt;</ph> with random values.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Pkcs.EnvelopedCms?displayProperty=nameWithType&gt;</ph> is now supported on Linux and maxOS.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Elliptic-Curve Diffie-Hellman (ECDH) is now available in the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman?displayProperty=nameWithType&gt;</ph> class family.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The surface area is the same as in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The instance returned by <ph id="ph1">&lt;xref:System.Security.Cryptography.RSA.Create%2A?displayProperty=nameWithType&gt;</ph> can encrypt or decrypt with OAEP using a SHA-2 digest, as well as generate or validate signatures using RSA-PSS.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Sockets improvements</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>.NET Core includes a new type, <ph id="ph1">&lt;xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType&gt;</ph>, and a rewritten <ph id="ph2">&lt;xref:System.Net.Http.HttpMessageHandler?displayProperty=nameWithType&gt;</ph>, that form the basis of higher-level networking APIs.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType&gt;</ph>, for example, is the basis of the <ph id="ph2">&lt;xref:System.Net.Http.HttpClient&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In previous versions of .NET Core, higher-level APIs were based on native networking implementations.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The sockets implementation introduced in .NET Core 2.1 has a number of advantages:</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>A significant performance improvement when compared with the previous implementation.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Elimination of platform dependencies, which simplifies deployment and servicing.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Consistent behavior across all .NET Core platforms.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Net.Http.SocketsHttpHandler&gt;</ph> is the default implementation in .NET Core 2.1.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>However, you can configure your application to use the older <ph id="ph1">&lt;xref:System.Net.Http.HttpClientHandler&gt;</ph> class by calling the <ph id="ph2">&lt;xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType&gt;</ph> method:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>You can also use an environment variable to opt out of using sockets implementations based on <ph id="ph1">&lt;xref:System.Net.Http.SocketsHttpHandler&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>To do this, set the <ph id="ph1">`DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER`</ph> to either <ph id="ph2">`false`</ph> or 0.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>On Windows, you can also choose to use <ph id="ph1">&lt;xref:System.Net.Http.WinHttpHandler?displayProperty=nameWithType&gt;</ph>, which relies on a native implementation, or the <ph id="ph2">&lt;xref:System.Net.Http.SocketsHttpHandler&gt;</ph> class by passing an instance of the class to the <ph id="ph3">&lt;xref:System.Net.Http.HttpClient&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>On Linux and macOS, you can only configure <ph id="ph1">&lt;xref:System.Net.Http.HttpClient&gt;</ph> on a per-process basis.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>On Linux, you need to deploy <bpt id="p1">[</bpt>libcurl<ept id="p1">](https://curl.haxx.se/libcurl/)</ept> if you want to use the old <ph id="ph1">&lt;xref:System.Net.Http.HttpClient&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>(It is installed with .NET Core 2.0.)</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>What's new in .NET Core<ept id="p1">](index.md)</ept></source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>New features in EF Core 2.1<ept id="p1">](/ef/core/what-is-new/ef-core-2.1)</ept></source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>What's new in ASP.NET Core 2.1<ept id="p1">](/aspnet/core/aspnetcore-2.1)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>