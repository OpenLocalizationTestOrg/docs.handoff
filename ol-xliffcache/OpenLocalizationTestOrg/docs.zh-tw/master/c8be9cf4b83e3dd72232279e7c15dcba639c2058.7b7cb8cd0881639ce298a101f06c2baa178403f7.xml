{"content":"---\ntitle: Generate and consume async streams\ndescription: This advanced tutorial illustrates scenarios where generating and consuming async streams provides a more natural way to work with sequences of data that may be generated asynchronously.\nms.date: 02/10/2019\nms.custom: mvc\n---\n# Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0\n\nC# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously. Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.\n\nIn this tutorial, you'll learn how to:\n\n> [!div class=\"checklist\"]\n> * Create a data source that generates a sequence of data elements asynchronously.\n> * Consume that data source asynchronously.\n> * Recognize when the new interface and data source are preferred to earlier synchronous data sequences.\n\n## Prerequisites\n\nYouâ€™ll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler. The C# 8 beta compiler is available starting with [Visual Studio 2019 preview 1](https://visualstudio.microsoft.com/vs/preview/), or [.NET Core 3.0 preview 1 SDK](https://dotnet.microsoft.com/download/dotnet-core/3.0). Async streams are first available in .NET Core 3.0 preview 1.\n\nYou'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint. Select the following permissions for your GitHub Access Token:\n\n- repo:status\n- public_repo\n\nSave the access token in a safe place so you can use it to gain access to the GitHub API endpoint.\n\n> [!WARNING]\n> Keep your personal access token secure. Any software with your personal access token could make GitHub API calls using your access rights.\n\nThis tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.\n\n## Run the starter application\n\nYou can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.\n\nThe starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository. Start by looking at the following code for the starter app `Main` method:\n\n[!code-csharp[StarterAppMain](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]\n\nYou can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token. Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.\n\nAfter creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token. Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues. After that task has finished, the results are displayed.\n\nWhen you run the starter application, you can make some important observations about how this application runs.  You'll see progress reported for each page returned from GitHub. You can observe a noticeable pause before GitHub returns each new page of issues. Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.\n\n## Examine the implementation\n\nThe implementation reveals why you observed the behavior discussed in the previous section. Examine the code for `runPagedQueryAsync`:\n\n[!code-csharp[RunPagedQueryStarter](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]\n\nLet's concentrate on the paging algorithm and async structure of the preceding code. (You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest. It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page. That follows GraphQL's standard paging support for multi-page responses. The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page. The issues are in the `nodes` array. The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.\n\nAfter retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation. If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.\n\nThere are several elements in this code that can be improved. Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned. This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues. In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading. You must look for the progress class to find where progress is reported. You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.\n\n## Async streams provide a better way\n\nAsync streams and the associated language support address all those concerns. The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier. You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.\n\nThese new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:\n\n```csharp\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : IAsyncDisposable\n    {\n        T Current { get; }\n\n        ValueTask<bool> MoveNextAsync();\n    }\n}\n\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        ValueTask DisposeAsync();\n    }\n}\n```\n\nThese three interfaces should be familiar to most C# developers. They behave in a manner similar to their synchronous counterparts:\n\n- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>\n- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>\n- <xref:System.IDisposable?displayProperty=nameWithType>\n\nOne type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>. The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class. `ValueTask` is used in these interfaces for performance reasons.\n\n## Convert to async streams\n\nNext, convert the `runPagedQueryAsync` method to generate an async stream. First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:\n\n[!code-csharp[FinishedSignature](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]\n\nThe starter code processes each page as the page is retrieved, as shown in the following code:\n\n[!code-csharp[StarterPaging](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]\n\nReplace those three lines with the following code:\n\n[!code-csharp[FinishedPaging](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]\n\nYou can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.\n\nYou've finished the changes to generate an async stream. The finished method should resemble the code below:\n\n[!code-csharp[FinishedGenerate](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]\n\nNext, you change the code that consumes the collection to consume the async stream. Find the following code in `Main` that processes the collection of issues:\n\n[!code-csharp[EnumerateOldStyle](~/samples/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]\n\nReplace that code with the following `await foreach` loop:\n\n[!code-csharp[FinishedEnumerateAsyncStream](~/samples/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]\n\nYou can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.\n\n## Run the finished application\n\nRun the application again. Contrast its behavior with the behavior of the starter application. The first page of results is enumerated as soon as it's available. There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated. The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection. Progress is clearly reported because the async stream generates results as each page is downloaded.\n\nYou can see improvements in memory use by examining the code. You no longer need to allocate a collection to store all the results before they're enumerated. The caller can determine how to consume the results and if a storage collection is needed.\n\nRun both the starter and finished applications and you can observe the differences between the implementations for yourself. You can delete the GitHub access token you created when you started this tutorial after you've finished. If an attacker gained access to that token, they could access GitHub APIs using your credentials.\n","nodes":[{"pos":[4,280],"embed":true,"restype":"x-metadata","content":"title: Generate and consume async streams\ndescription: This advanced tutorial illustrates scenarios where generating and consuming async streams provides a more natural way to work with sequences of data that may be generated asynchronously.\nms.date: 02/10/2019\nms.custom: mvc","nodes":[{"content":"Generate and consume async streams","nodes":[{"pos":[0,34],"content":"Generate and consume async streams","nodes":[{"content":"Generate and consume async streams","pos":[0,34]}]}],"path":["title"],"nosxs":false},{"content":"This advanced tutorial illustrates scenarios where generating and consuming async streams provides a more natural way to work with sequences of data that may be generated asynchronously.","nodes":[{"pos":[0,186],"content":"This advanced tutorial illustrates scenarios where generating and consuming async streams provides a more natural way to work with sequences of data that may be generated asynchronously.","nodes":[{"content":"This advanced tutorial illustrates scenarios where generating and consuming async streams provides a more natural way to work with sequences of data that may be generated asynchronously.","pos":[0,186]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[287,362],"content":"Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0","linkify":"Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0","nodes":[{"content":"Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0","pos":[0,75]}]},{"content":"C# 8.0 introduces <bpt id=\"p1\">**</bpt>async streams<ept id=\"p1\">**</ept>, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.","pos":[364,522],"source":"C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously."},{"content":"Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.","pos":[523,704]},{"content":"In this tutorial, you'll learn how to:","pos":[706,744]},{"content":"Create a data source that generates a sequence of data elements asynchronously.","pos":[777,856]},{"content":"Consume that data source asynchronously.","pos":[861,901]},{"content":"Recognize when the new interface and data source are preferred to earlier synchronous data sequences.","pos":[906,1007]},{"pos":[1012,1025],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"Youâ€™ll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler.","pos":[1027,1115]},{"content":"The C# 8 beta compiler is available starting with <bpt id=\"p1\">[</bpt>Visual Studio 2019 preview 1<ept id=\"p1\">](https://visualstudio.microsoft.com/vs/preview/)</ept>, or <bpt id=\"p2\">[</bpt>.NET Core 3.0 preview 1 SDK<ept id=\"p2\">](https://dotnet.microsoft.com/download/dotnet-core/3.0)</ept>.","pos":[1116,1334],"source":" The C# 8 beta compiler is available starting with [Visual Studio 2019 preview 1](https://visualstudio.microsoft.com/vs/preview/), or [.NET Core 3.0 preview 1 SDK](https://dotnet.microsoft.com/download/dotnet-core/3.0)."},{"content":"Async streams are first available in .NET Core 3.0 preview 1.","pos":[1335,1396]},{"content":"You'll need to create a <bpt id=\"p1\">[</bpt>GitHub access token<ept id=\"p1\">](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token)</ept> so that you can access the GitHub GraphQL endpoint.","pos":[1398,1601],"source":"You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint."},{"content":"Select the following permissions for your GitHub Access Token:","pos":[1602,1664]},{"content":"repo:status","pos":[1668,1679]},{"content":"public_repo","pos":[1682,1693]},{"content":"Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.","pos":[1695,1793]},{"pos":[1797,1948],"content":"[!WARNING]\nKeep your personal access token secure. Any software with your personal access token could make GitHub API calls using your access rights.","leadings":["","> "],"nodes":[{"content":"Keep your personal access token secure. Any software with your personal access token could make GitHub API calls using your access rights.","pos":[11,149],"nodes":[{"content":"Keep your personal access token secure.","pos":[0,39]},{"content":"Any software with your personal access token could make GitHub API calls using your access rights.","pos":[40,138]}]}]},{"content":"This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.","pos":[1950,2058]},{"pos":[2063,2090],"content":"Run the starter application","linkify":"Run the starter application","nodes":[{"content":"Run the starter application","pos":[0,27]}]},{"pos":[2092,2364],"content":"You can get the code for the starter application used in this tutorial from our <bpt id=\"p1\">[</bpt>dotnet/samples<ept id=\"p1\">](https://github.com/dotnet/samples)</ept> repository in the <bpt id=\"p2\">[</bpt>csharp/tutorials/AsyncStreams<ept id=\"p2\">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start)</ept> folder.","source":"You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder."},{"content":"The starter application is a console application that uses the <bpt id=\"p1\">[</bpt>GitHub GraphQL<ept id=\"p1\">](https://developer.github.com/v4/)</ept> interface to retrieve recent issues written in the <bpt id=\"p2\">[</bpt>dotnet/docs<ept id=\"p2\">](https://github.com/dotnet/docs)</ept> repository.","pos":[2366,2588],"source":"The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository."},{"content":"Start by looking at the following code for the starter app <ph id=\"ph1\">`Main`</ph> method:","pos":[2589,2662],"source":" Start by looking at the following code for the starter app `Main` method:"},{"content":"You can either set a <ph id=\"ph1\">`GitHubKey`</ph> environment variable to your personal access token, or you can replace the last argument in the call to <ph id=\"ph2\">`GenEnvVariable`</ph> with your personal access token.","pos":[2797,2983],"source":"You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token."},{"content":"Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.","pos":[2984,3114]},{"content":"After creating the GitHub client, the code in <ph id=\"ph1\">`Main`</ph> creates a progress reporting object and a cancellation token.","pos":[3116,3230],"source":"After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token."},{"content":"Once those objects are created, <ph id=\"ph1\">`Main`</ph> calls <ph id=\"ph2\">`runPagedQueryAsync`</ph> to retrieve the most recent 250 created issues.","pos":[3231,3344],"source":" Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues."},{"content":"After that task has finished, the results are displayed.","pos":[3345,3401]},{"content":"When you run the starter application, you can make some important observations about how this application runs.","pos":[3403,3514]},{"content":"You'll see progress reported for each page returned from GitHub.","pos":[3516,3580]},{"content":"You can observe a noticeable pause before GitHub returns each new page of issues.","pos":[3581,3662]},{"content":"Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.","pos":[3663,3753]},{"pos":[3758,3784],"content":"Examine the implementation","linkify":"Examine the implementation","nodes":[{"content":"Examine the implementation","pos":[0,26]}]},{"content":"The implementation reveals why you observed the behavior discussed in the previous section.","pos":[3786,3877]},{"content":"Examine the code for <ph id=\"ph1\">`runPagedQueryAsync`</ph>:","pos":[3878,3920],"source":" Examine the code for `runPagedQueryAsync`:"},{"content":"Let's concentrate on the paging algorithm and async structure of the preceding code.","pos":[4060,4144]},{"content":"(You can consult the <bpt id=\"p1\">[</bpt>GitHub GraphQL documentation<ept id=\"p1\">](https://developer.github.com/v4/guides/)</ept> for details on the GitHub GraphQL API.) The <ph id=\"ph1\">`runPagedQueryAsync`</ph> method enumerates the issues from most recent to oldest.","pos":[4145,4359],"source":" (You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest."},{"content":"It requests 25 issues per page and examines the <ph id=\"ph1\">`pageInfo`</ph> structure of the response to continue with the previous page.","pos":[4360,4480],"source":" It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page."},{"content":"That follows GraphQL's standard paging support for multi-page responses.","pos":[4481,4553]},{"content":"The response includes a <ph id=\"ph1\">`pageInfo`</ph> object that includes a <ph id=\"ph2\">`hasPreviousPages`</ph> value and a <ph id=\"ph3\">`startCursor`</ph> value used to request the previous page.","pos":[4554,4697],"source":" The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page."},{"content":"The issues are in the <ph id=\"ph1\">`nodes`</ph> array.","pos":[4698,4734],"source":" The issues are in the `nodes` array."},{"content":"The <ph id=\"ph1\">`runPagedQueryAsync`</ph> method appends these nodes to an array that contains all the results from all pages.","pos":[4735,4844],"source":" The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages."},{"content":"After retrieving and restoring a page of results, <ph id=\"ph1\">`runPagedQueryAsync`</ph> reports progress and checks for cancellation.","pos":[4846,4962],"source":"After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation."},{"content":"If cancellation has been requested, <ph id=\"ph1\">`runPagedQueryAsync`</ph> throws an <ph id=\"ph2\">&lt;xref:System.OperationCanceledException&gt;</ph>.","pos":[4963,5071],"source":" If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>."},{"content":"There are several elements in this code that can be improved.","pos":[5073,5134]},{"content":"Most importantly, <ph id=\"ph1\">`runPagedQueryAsync`</ph> must allocate storage for all the issues returned.","pos":[5135,5224],"source":" Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned."},{"content":"This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.","pos":[5225,5357]},{"content":"In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.","pos":[5358,5498]},{"content":"You must look for the progress class to find where progress is reported.","pos":[5499,5571]},{"content":"You also have to trace the communications through the <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> and its associated <ph id=\"ph2\">&lt;xref:System.Threading.CancellationToken&gt;</ph> to understand where cancellation is requested and where it's granted.","pos":[5572,5804],"source":" You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted."},{"pos":[5809,5843],"content":"Async streams provide a better way","linkify":"Async streams provide a better way","nodes":[{"content":"Async streams provide a better way","pos":[0,34]}]},{"content":"Async streams and the associated language support address all those concerns.","pos":[5845,5922]},{"content":"The code that generates the sequence can now use <ph id=\"ph1\">`yield return`</ph> to return elements in a method that was declared with the <ph id=\"ph2\">`async`</ph> modifier.","pos":[5923,6062],"source":" The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier."},{"content":"You can consume an async stream using an <ph id=\"ph1\">`await foreach`</ph> loop just as you consume any sequence using a <ph id=\"ph2\">`foreach`</ph> loop.","pos":[6063,6181],"source":" You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop."},{"content":"These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:","pos":[6183,6302]},{"content":"These three interfaces should be familiar to most C# developers.","pos":[6764,6828]},{"content":"They behave in a manner similar to their synchronous counterparts:","pos":[6829,6895]},{"content":"One type that may be unfamiliar is <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType&gt;</ph>.","pos":[7117,7221],"source":"One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>."},{"content":"The <ph id=\"ph1\">`ValueTask`</ph> struct provides a similar API to the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> class.","pos":[7222,7345],"source":" The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class."},{"content":"<ph id=\"ph1\">`ValueTask`</ph> is used in these interfaces for performance reasons.","pos":[7346,7410],"source":"`ValueTask` is used in these interfaces for performance reasons."},{"pos":[7415,7439],"content":"Convert to async streams","linkify":"Convert to async streams","nodes":[{"content":"Convert to async streams","pos":[0,24]}]},{"content":"Next, convert the <ph id=\"ph1\">`runPagedQueryAsync`</ph> method to generate an async stream.","pos":[7441,7515],"source":"Next, convert the `runPagedQueryAsync` method to generate an async stream."},{"content":"First, change the signature of <ph id=\"ph1\">`runPagedQueryAsync`</ph> to return an <ph id=\"ph2\">`IAsyncEnumerable&lt;JToken&gt;`</ph>, and remove the cancellation token and progress objects from the parameter list as shown in the following code:","pos":[7516,7719],"source":" First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:"},{"content":"The starter code processes each page as the page is retrieved, as shown in the following code:","pos":[7861,7955]},{"content":"Replace those three lines with the following code:","pos":[8086,8136]},{"pos":[8275,8414],"content":"You can also remove the declaration of <ph id=\"ph1\">`finalResults`</ph> earlier in this method and the <ph id=\"ph2\">`return`</ph> statement that follows the loop you modified.","source":"You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified."},{"content":"You've finished the changes to generate an async stream.","pos":[8416,8472]},{"content":"The finished method should resemble the code below:","pos":[8473,8524]},{"content":"Next, you change the code that consumes the collection to consume the async stream.","pos":[8669,8752]},{"content":"Find the following code in <ph id=\"ph1\">`Main`</ph> that processes the collection of issues:","pos":[8753,8827],"source":" Find the following code in `Main` that processes the collection of issues:"},{"pos":[8968,9026],"content":"Replace that code with the following <ph id=\"ph1\">`await foreach`</ph> loop:","source":"Replace that code with the following `await foreach` loop:"},{"pos":[9184,9435],"content":"You can get the code for the finished tutorial from the <bpt id=\"p1\">[</bpt>dotnet/samples<ept id=\"p1\">](https://github.com/dotnet/samples)</ept> repository in the <bpt id=\"p2\">[</bpt>csharp/tutorials/AsyncStreams<ept id=\"p2\">](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished)</ept> folder.","source":"You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder."},{"pos":[9440,9468],"content":"Run the finished application","linkify":"Run the finished application","nodes":[{"content":"Run the finished application","pos":[0,28]}]},{"content":"Run the application again.","pos":[9470,9496]},{"content":"Contrast its behavior with the behavior of the starter application.","pos":[9497,9564]},{"content":"The first page of results is enumerated as soon as it's available.","pos":[9565,9631]},{"content":"There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.","pos":[9632,9757]},{"content":"The <ph id=\"ph1\">`try`</ph><ph id=\"ph2\"> / </ph><ph id=\"ph3\">`catch`</ph> block isn't needed to handle cancellation: the caller can stop enumerating the collection.","pos":[9758,9868],"source":" The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection."},{"content":"Progress is clearly reported because the async stream generates results as each page is downloaded.","pos":[9869,9968]},{"content":"You can see improvements in memory use by examining the code.","pos":[9970,10031]},{"content":"You no longer need to allocate a collection to store all the results before they're enumerated.","pos":[10032,10127]},{"content":"The caller can determine how to consume the results and if a storage collection is needed.","pos":[10128,10218]},{"content":"Run both the starter and finished applications and you can observe the differences between the implementations for yourself.","pos":[10220,10344]},{"content":"You can delete the GitHub access token you created when you started this tutorial after you've finished.","pos":[10345,10449]},{"content":"If an attacker gained access to that token, they could access GitHub APIs using your credentials.","pos":[10450,10547]}]}