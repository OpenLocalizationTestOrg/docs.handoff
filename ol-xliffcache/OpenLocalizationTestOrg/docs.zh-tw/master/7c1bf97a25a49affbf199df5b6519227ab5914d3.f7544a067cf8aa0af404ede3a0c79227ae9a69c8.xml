{"content":"---\ntitle: \"Windows Applications Using Callbacks | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-ado\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: ae2ea457-0764-4b06-8977-713c77e85bd2\ncaps.latest.revision: 3\nauthor: \"JennieHubbard\"\nms.author: \"jhubbard\"\nmanager: \"jhubbard\"\n---\n# Windows Applications Using Callbacks\nIn most asynchronous processing scenarios, you want to start a database operation and continue running other processes without waiting for the database operation to complete. However, many scenarios require doing something once the database operation has ended. In a Windows application, for example, you may want to delegate the long-running operation to a background thread while allowing the user interface thread to remain responsive. However, when the database operation is complete, you want to use the results to populate the form. This type of scenario is best implemented with a callback.  \n  \n You define a callback by specifying an <xref:System.AsyncCallback> delegate in the <xref:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery%2A>, <xref:System.Data.SqlClient.SqlCommand.BeginExecuteReader%2A>, or <xref:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader%2A> method. The delegate is called when the operation is complete. You can pass the delegate a reference to the <xref:System.Data.SqlClient.SqlCommand> itself, making it easy to access the <xref:System.Data.SqlClient.SqlCommand> object and call the appropriate `End` method without having to use a global variable.  \n  \n## Example  \n The following Windows application demonstrates the use of the <xref:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery%2A> method, executing a Transact-SQL statement that includes a delay of a few seconds (emulating a long-running command).  \n  \n This example demonstrates a number of important techniques, including calling a method that interacts with the form from a separate thread. In addition, this example demonstrates how you must block users from concurrently executing a command multiple times, and how you must ensure that the form does not close before the callback procedure is called.  \n  \n To set up this example, create a new Windows application. Place a <xref:System.Windows.Forms.Button> control and two <xref:System.Windows.Forms.Label> controls on the form (accepting the default name for each control). Add the following code to the form's class, modifying the connection string as necessary for your environment.  \n  \n```vb  \n' Add these to the top of the class:  \nImports System  \nImports System.Data  \nImports System.Data.SqlClient  \n  \n' Add this code to the form's class:  \n  \n    ' You'll need this delegate in order to display text from a   \n    ' thread other than the form's thread. See the HandleCallback  \n    ' procedure for more information.  \n    ' This same delegate matches both the DisplayStatus   \n    ' and DisplayResults methods.  \n    Private Delegate Sub DisplayInfoDelegate(ByVal Text As String)  \n  \n    ' This flag ensures that the user doesn't attempt  \n    ' to restart the command or close the form while the   \n    ' asynchronous command is executing.  \n    Private isExecuting As Boolean  \n  \n    ' This example maintains the connection object   \n    ' externally, so that it's available for closing.  \n    Private connection As SqlConnection  \n  \n    Private Function GetConnectionString() As String  \n        ' To avoid storing the connection string in your code,              \n        ' you can retrieve it from a configuration file.   \n  \n        ' If you have not included \"Asynchronous Processing=true\"  \n        ' in the connection string, the command will not be able  \n        ' to execute asynchronously.  \n        Return \"Data Source=(local);Integrated Security=SSPI;\" & _  \n          \"Initial Catalog=AdventureWorks;\" & _  \n          \"Asynchronous Processing=true\"  \n    End Function  \n  \n    Private Sub DisplayStatus(ByVal Text As String)  \n        Me.Label1.Text = Text  \n    End Sub  \n  \n    Private Sub DisplayResults(ByVal Text As String)  \n        Me.Label1.Text = Text  \n        DisplayStatus(\"Ready\")  \n    End Sub  \n  \n    Private Sub Form1_FormClosing(ByVal sender As Object, _  \n        ByVal e As System.Windows.Forms.FormClosingEventArgs) _  \n        Handles Me.FormClosing  \n        If isExecuting Then  \n            MessageBox.Show(Me, \"Can't close the form until \" & _  \n             \"the pending asynchronous command has completed. \" & _  \n             \"Please wait...\")  \n            e.Cancel = True  \n        End If  \n    End Sub  \n  \n    Private Sub Button1_Click( _  \n        ByVal sender As System.Object, _  \n        ByVal e As System.EventArgs) Handles Button1.Click  \n        If isExecuting Then  \n            MessageBox.Show(Me, _  \n                \"Already executing. \" & _  \n                \"Please wait until the current query \" & _  \n                \"has completed.\")  \n        Else  \n            Dim command As SqlCommand  \n            Try  \n                DisplayResults(\"\")  \n                DisplayStatus(\"Connecting...\")  \n                connection = New SqlConnection(GetConnectionString())  \n                ' To emulate a long-running query, wait for   \n                ' a few seconds before working with the data.  \n                ' This command doesn't do much, but that's the point--  \n                ' it doesn't change your data, in the long run.  \n                Dim commandText As String = _  \n                    \"WAITFOR DELAY '0:0:05';\" & _  \n                    \"UPDATE Production.Product \" & _  \n                    \"SET ReorderPoint = ReorderPoint + 1 \" & _  \n                    \"WHERE ReorderPoint Is Not Null;\" & _  \n                    \"UPDATE Production.Product \" & _  \n                    \"SET ReorderPoint = ReorderPoint - 1 \" & _  \n                    \"WHERE ReorderPoint Is Not Null\"  \n  \n                command = New SqlCommand(commandText, connection)  \n                connection.Open()  \n  \n                DisplayStatus(\"Executing...\")  \n                isExecuting = True  \n                ' Although it's not required that you pass the   \n                ' SqlCommand object as the second parameter in the   \n                ' BeginExecuteNonQuery call, doing so makes it easier  \n                ' to call EndExecuteNonQuery in the callback procedure.  \n                Dim callback As New _  \n                      AsyncCallback(AddressOf HandleCallback)  \n  \n                ' Once the BeginExecuteNonQuery method is called,  \n                ' the code continues--and the user can interact with  \n                ' the form--while the server executes the query.  \n  \n                command.BeginExecuteNonQuery(callback, command)  \n  \n            Catch ex As Exception  \n                isExecuting = False  \n                DisplayStatus( _  \n                    String.Format(\"Ready (last error: {0})\", _  \n                    ex.Message))  \n                If connection IsNot Nothing Then  \n                    connection.Close()  \n                End If  \n            End Try  \n        End If  \n    End Sub  \n  \n    Private Sub HandleCallback(ByVal result As IAsyncResult)  \n        Try  \n            ' Retrieve the original command object, passed  \n            ' to this procedure in the AsyncState property  \n            ' of the IAsyncResult parameter.  \n            Dim command As SqlCommand = _  \n                CType(result.AsyncState, SqlCommand)  \n            Dim rowCount As Integer = _  \n                command.EndExecuteNonQuery(result)  \n            Dim rowText As String = \" rows affected.\"  \n            If rowCount = 1 Then  \n                rowText = \" row affected.\"  \n            End If  \n            rowText = rowCount & rowText  \n  \n            ' You may not interact with the form and its contents  \n            ' from a different thread, and this callback procedure  \n            ' is all but guaranteed to be running from a different   \n            ' thread than the form. Therefore you cannot simply call   \n            ' code that displays the results, like this:  \n            ' DisplayResults(rowText)  \n  \n            ' Instead, you must call the procedure from the form's  \n            ' thread. One simple way to accomplish this is to call   \n            ' the Invoke method of the form, which calls the delegate   \n            ' you supply from the form's thread.   \n            Dim del As New _  \n                DisplayInfoDelegate(AddressOf DisplayResults)  \n            Me.Invoke(del, rowText)  \n  \n        Catch ex As Exception  \n            ' Because you're now running code in a separate thread,   \n            ' if you don't handle the exception here, none of your   \n            ' other code will catch the exception. Because none of   \n            ' your code is on the call stack in this thread, there's   \n            ' nothing higher up the stack to catch the exception if   \n            ' you don't handle it here. You can either log the   \n            ' exception or invoke a delegate (as in the non-error   \n            ' case in this example) to display the error on the form.   \n            ' In no case can you simply display the error without   \n            ' executing a delegate as in the Try block here.  \n  \n            ' You can create the delegate instance as you   \n            ' invoke it, like this:  \n            Me.Invoke(New _  \n                DisplayInfoDelegate(AddressOf DisplayStatus), _  \n                String.Format(\"Ready(last error: {0}\", ex.Message))  \n        Finally  \n            isExecuting = False  \n            If connection IsNot Nothing Then  \n                connection.Close()  \n            End If  \n        End Try  \n    End Sub  \n```  \n  \n```csharp  \n// Add these to the top of the class, if they're not already there:  \nusing System;  \nusing System.Data;  \nusing System.Data.SqlClient;  \n  \n// Hook up the form's Load event handler (you can double-click on   \n// the form's design surface in Visual Studio), and then add   \n// this code to the form's class:  \n  \n// You'll need this delegate in order to display text from a thread  \n// other than the form's thread. See the HandleCallback  \n// procedure for more information.  \n// This same delegate matches both the DisplayStatus   \n// and DisplayResults methods.  \nprivate delegate void DisplayInfoDelegate(string Text);  \n  \n// This flag ensures that the user doesn't attempt  \n// to restart the command or close the form while the   \n// asynchronous command is executing.  \nprivate bool isExecuting;  \n  \n// This example maintains the connection object   \n// externally, so that it's available for closing.  \nprivate SqlConnection connection;  \n  \nprivate static string GetConnectionString()  \n{  \n    // To avoid storing the connection string in your code,              \n    // you can retrieve it from a configuration file.   \n  \n    // If you have not included \"Asynchronous Processing=true\" in the  \n    // connection string, the command will not be able  \n    // to execute asynchronously.  \n    return \"Data Source=(local);Integrated Security=SSPI;\" +  \n    \"Initial Catalog=AdventureWorks; Asynchronous Processing=true\";  \n}  \n  \nprivate void DisplayStatus(string Text)  \n{  \n    this.label1.Text = Text;  \n}  \n  \nprivate void DisplayResults(string Text)  \n{  \n    this.label1.Text = Text;  \n    DisplayStatus(\"Ready\");  \n}  \n  \nprivate void Form1_FormClosing(object sender, System.Windows.Forms.FormClosingEventArgs e)  \n{  \n    if (isExecuting)  \n    {  \n        MessageBox.Show(this, \"Can't close the form until \" +  \n        \"the pending asynchronous command has completed. Please \" +  \n        wait...\");  \n        e.Cancel = true;  \n    }  \n}  \n  \nprivate void button1_Click(object sender, System.EventArgs e)  \n{  \n    if (isExecuting)  \n    {  \n        MessageBox.Show(this, \"Already executing. Please wait until \" +  \n        \"the current query has completed.\");  \n    }  \n    else  \n    {  \n        SqlCommand command = null;  \n        try  \n        {  \n            DisplayResults(\"\");  \n            DisplayStatus(\"Connecting...\");  \n            connection = new SqlConnection(GetConnectionString());  \n            // To emulate a long-running query, wait for   \n            // a few seconds before working with the data.  \n            // This command doesn't do much, but that's the point--  \n            // it doesn't change your data, in the long run.  \n            string commandText =  \n                \"WAITFOR DELAY '0:0:05';\" +  \n                \"UPDATE Production.Product \" +  \n                \"SET ReorderPoint = ReorderPoint + 1 \" +  \n                \"WHERE ReorderPoint Is Not Null;\" +  \n                \"UPDATE Production.Product \" +  \n                \"SET ReorderPoint = ReorderPoint - 1 \" +  \n                \"WHERE ReorderPoint Is Not Null\";  \n  \n            command = new SqlCommand(commandText, connection);  \n            connection.Open();  \n  \n            DisplayStatus(\"Executing...\");  \n            isExecuting = true;  \n            // Although it's not required that you pass the   \n            // SqlCommand object as the second parameter in the   \n            // BeginExecuteNonQuery call, doing so makes it easier  \n            // to call EndExecuteNonQuery in the callback procedure.  \n            AsyncCallback callback = new AsyncCallback(HandleCallback);  \n  \n            // Once the BeginExecuteNonQuery method is called,  \n            // the code continues--and the user can interact with  \n            // the form--while the server executes the query.  \n            command.BeginExecuteNonQuery(callback, command);  \n  \n        }  \n        catch (Exception ex)  \n        {  \n            isExecuting = false;  \n            DisplayStatus(   \n             string.Format(\"Ready (last error: {0})\", ex.Message));  \n            if (connection != null)  \n            {  \n                connection.Close();  \n            }  \n        }  \n    }  \n}  \n  \nprivate void HandleCallback(IAsyncResult result)  \n{  \n    try  \n    {  \n        // Retrieve the original command object, passed  \n        // to this procedure in the AsyncState property  \n        // of the IAsyncResult parameter.  \n        SqlCommand command = (SqlCommand)result.AsyncState;  \n        int rowCount = command.EndExecuteNonQuery(result);  \n        string rowText = \" rows affected.\";  \n        if (rowCount == 1)  \n        {  \n            rowText = \" row affected.\";  \n        }  \n        rowText = rowCount + rowText;  \n  \n        // You may not interact with the form and its contents  \n        // from a different thread, and this callback procedure  \n        // is all but guaranteed to be running from a different thread  \n        // than the form. Therefore you cannot simply call code that   \n        // displays the results, like this:  \n        // DisplayResults(rowText)  \n  \n        // Instead, you must call the procedure from the form's thread.  \n        // One simple way to accomplish this is to call the Invoke  \n        // method of the form, which calls the delegate you supply  \n        // from the form's thread.   \n        DisplayInfoDelegate del =   \n         new DisplayInfoDelegate(DisplayResults);  \n        this.Invoke(del, rowText);  \n    }  \n    catch (Exception ex)  \n    {  \n        // Because you're now running code in a separate thread,   \n        // if you don't handle the exception here, none of your other  \n        // code will catch the exception. Because none of your  \n        // code is on the call stack in this thread, there's nothing  \n        // higher up the stack to catch the exception if you don't   \n        // handle it here. You can either log the exception or   \n        // invoke a delegate (as in the non-error case in this   \n        // example) to display the error on the form. In no case  \n        // can you simply display the error without executing a   \n        // delegate as in the try block here.   \n  \n        // You can create the delegate instance as you   \n        // invoke it, like this:  \n        this.Invoke(new DisplayInfoDelegate(DisplayStatus),  \n        String.Format(\"Ready(last error: {0}\", ex.Message));  \n    }  \n    finally  \n    {  \n        isExecuting = false;  \n        if (connection != null)  \n        {  \n            connection.Close();  \n        }  \n    }  \n}  \n  \nprivate void Form1_Load(object sender, System.EventArgs e)  \n{  \n    this.button1.Click += new System.EventHandler(this.button1_Click);  \n    this.FormClosing += new System.Windows.Forms.  \n        FormClosingEventHandler(this.Form1_FormClosing);  \n}  \n```  \n  \n## See Also  \n [Asynchronous Operations](../../../../../docs/framework/data/adonet/sql/asynchronous-operations.md)   \n [ADO.NET Managed Providers and DataSet Developer Center](http://go.microsoft.com/fwlink/?LinkId=217917)","nodes":[{"pos":[12,65],"content":"Windows Applications Using Callbacks | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Windows Applications Using Callbacks | Microsoft Docs","pos":[0,53]}]},{"pos":[374,410],"content":"Windows Applications Using Callbacks","linkify":"Windows Applications Using Callbacks","nodes":[{"content":"Windows Applications Using Callbacks","pos":[0,36]}]},{"content":"In most asynchronous processing scenarios, you want to start a database operation and continue running other processes without waiting for the database operation to complete.","pos":[411,585]},{"content":"However, many scenarios require doing something once the database operation has ended.","pos":[586,672]},{"content":"In a Windows application, for example, you may want to delegate the long-running operation to a background thread while allowing the user interface thread to remain responsive.","pos":[673,849]},{"content":"However, when the database operation is complete, you want to use the results to populate the form.","pos":[850,949]},{"content":"This type of scenario is best implemented with a callback.","pos":[950,1008]},{"content":"You define a callback by specifying an <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate in the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Data.SqlClient.SqlCommand.BeginExecuteReader%2A&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader%2A&gt;</ph> method.","pos":[1015,1301],"source":"You define a callback by specifying an <xref:System.AsyncCallback> delegate in the <xref:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery%2A>, <xref:System.Data.SqlClient.SqlCommand.BeginExecuteReader%2A>, or <xref:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader%2A> method."},{"content":"The delegate is called when the operation is complete.","pos":[1302,1356]},{"content":"You can pass the delegate a reference to the <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlCommand&gt;</ph> itself, making it easy to access the <ph id=\"ph2\">&lt;xref:System.Data.SqlClient.SqlCommand&gt;</ph> object and call the appropriate <ph id=\"ph3\">`End`</ph> method without having to use a global variable.","pos":[1357,1604],"source":" You can pass the delegate a reference to the <xref:System.Data.SqlClient.SqlCommand> itself, making it easy to access the <xref:System.Data.SqlClient.SqlCommand> object and call the appropriate `End` method without having to use a global variable."},{"pos":[1613,1620],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following Windows application demonstrates the use of the <ph id=\"ph1\">&lt;xref:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery%2A&gt;</ph> method, executing a Transact-SQL statement that includes a delay of a few seconds (emulating a long-running command).","pos":[1624,1867],"source":"The following Windows application demonstrates the use of the <xref:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery%2A> method, executing a Transact-SQL statement that includes a delay of a few seconds (emulating a long-running command)."},{"content":"This example demonstrates a number of important techniques, including calling a method that interacts with the form from a separate thread.","pos":[1874,2013]},{"content":"In addition, this example demonstrates how you must block users from concurrently executing a command multiple times, and how you must ensure that the form does not close before the callback procedure is called.","pos":[2014,2225]},{"content":"To set up this example, create a new Windows application.","pos":[2232,2289]},{"content":"Place a <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Button&gt;</ph> control and two <ph id=\"ph2\">&lt;xref:System.Windows.Forms.Label&gt;</ph> controls on the form (accepting the default name for each control).","pos":[2290,2450],"source":" Place a <xref:System.Windows.Forms.Button> control and two <xref:System.Windows.Forms.Label> controls on the form (accepting the default name for each control)."},{"content":"Add the following code to the form's class, modifying the connection string as necessary for your environment.","pos":[2451,2561]},{"pos":[16650,16658],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Asynchronous Operations<ept id=\"p1\">](../../../../../docs/framework/data/adonet/sql/asynchronous-operations.md)</ept><ph id=\"ph1\"> </ph>","pos":[16662,16762],"source":"[Asynchronous Operations](../../../../../docs/framework/data/adonet/sql/asynchronous-operations.md) "},{"content":"<bpt id=\"p1\"> [</bpt>ADO.NET Managed Providers and DataSet Developer Center<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=217917)</ept>","pos":[16765,16869],"source":" [ADO.NET Managed Providers and DataSet Developer Center](http://go.microsoft.com/fwlink/?LinkId=217917)"}]}