{"content":"---\ntitle: \"Observer Design Pattern Best Practices\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"observer design pattern [.NET Framework], best practices\"\n  - \"best practices [.NET Framework], observer design pattern\"\nms.assetid: c834760f-ddd4-417f-abb7-a059679d5b8c\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Observer Design Pattern Best Practices\nIn the .NET Framework, the observer design pattern is implemented as a set of interfaces. The <xref:System.IObservable%601?displayProperty=nameWithType> interface represents the data provider, which is also responsible for providing an <xref:System.IDisposable> implementation that lets observers unsubscribe from notifications. The <xref:System.IObserver%601?displayProperty=nameWithType> interface represents the observer. This topic describes the best practices that developers should follow when implementing the observer design pattern using these interfaces.  \n  \n## Threading  \n Typically, a provider implements the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method by adding a particular observer to a subscriber list that is represented by some collection object, and it implements the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method by removing a particular observer from the subscriber list. An observer can call these methods at any time. In addition, because the provider/observer contract does not specify who is responsible for unsubscribing after the <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> callback method, the provider and observer may both try to remove the same member from the list. Because of this possibility, both the <xref:System.IObservable%601.Subscribe%2A> and <xref:System.IDisposable.Dispose%2A> methods should be thread-safe. Typically, this involves using a [concurrent collection](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md) or a lock. Implementations that are not thread-safe should explicitly document that they are not.  \n  \n Any additional guarantees have to be specified in a layer on top of the provider/observer contract. Implementers should clearly call out when they impose additional requirements to avoid user confusion about the observer contract.  \n  \n## Handling Exceptions  \n Because of the loose coupling between a data provider and an observer, exceptions in the observer design pattern are intended to be informational. This affects how providers and observers handle exceptions in the observer design pattern.  \n  \n### The Provider -- Calling the OnError Method  \n The <xref:System.IObserver%601.OnError%2A> method is intended as an informational message to observers, much like the <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> method. However, the <xref:System.IObserver%601.OnNext%2A> method is designed to provide an observer with current or updated data, whereas the <xref:System.IObserver%601.OnError%2A> method is designed to indicate that the provider is unable to provide valid data.  \n  \n The provider should follow these best practices when handling exceptions and calling the <xref:System.IObserver%601.OnError%2A> method:  \n  \n-   The provider must handle its own exceptions if it has any specific requirements.  \n  \n-   The provider should not expect or require that observers handle exceptions in any particular way.  \n  \n-   The provider should call the <xref:System.IObserver%601.OnError%2A> method when it handles an exception that compromises its ability to provide updates. Information on such exceptions can be passed to the observer. In other cases, there is no need to notify observers of an exception.  \n  \n Once the provider calls the <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> method, there should be no further notifications, and the provider can unsubscribe its observers. However, the observers can also unsubscribe themselves at any time, including both before and after they receive an <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> notification. The observer design pattern does not dictate whether the provider or the observer is responsible for unsubscribing; therefore, there is a possibility that both may attempt to unsubscribe. Typically, when observers unsubscribe, they are removed from a subscribers collection. In a single-threaded application, the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation should ensure that an object reference is valid and that the object is a member of the subscribers collection before attempting to remove it. In a multithreaded application, a thread-safe collection object, such as a <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> object, should be used.  \n  \n### The Observer -- Implementing the OnError Method  \n When an observer receives an error notification from a provider, the observer should treat the exception as informational and should not be required to take any particular action.  \n  \n The observer should follow these best practices when responding to an <xref:System.IObserver%601.OnError%2A> method call from a provider:  \n  \n-   The observer should not throw exceptions from its interface implementations, such as <xref:System.IObserver%601.OnNext%2A> or <xref:System.IObserver%601.OnError%2A>. However, if the observer does throw exceptions, it should expect these exceptions to go unhandled.  \n  \n-   To preserve the call stack, an observer that wishes to throw an <xref:System.Exception> object that was passed to its <xref:System.IObserver%601.OnError%2A> method should wrap the exception before throwing it. A standard exception object should be used for this purpose.  \n  \n## Additional Best Practices  \n Attempting to unregister in the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method may result in a null reference. Therefore, we recommend that you avoid this practice.  \n  \n Although it is possible to attach an observer to multiple providers, the recommended pattern is to attach an <xref:System.IObserver%601> instance to only one <xref:System.IObservable%601> instance.  \n  \n## See also\n\n- [Observer Design Pattern](../../../docs/standard/events/observer-design-pattern.md)\n- [How to: Implement an Observer](../../../docs/standard/events/how-to-implement-an-observer.md)\n- [How to: Implement a Provider](../../../docs/standard/events/how-to-implement-a-provider.md)\n","nodes":[{"pos":[4,341],"embed":true,"restype":"x-metadata","content":"title: \"Observer Design Pattern Best Practices\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\nhelpviewer_keywords: \n  - \"observer design pattern [.NET Framework], best practices\"\n  - \"best practices [.NET Framework], observer design pattern\"\nms.assetid: c834760f-ddd4-417f-abb7-a059679d5b8c\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Observer Design Pattern Best Practices","nodes":[{"pos":[0,38],"content":"Observer Design Pattern Best Practices","nodes":[{"content":"Observer Design Pattern Best Practices","pos":[0,38]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[348,386],"content":"Observer Design Pattern Best Practices","linkify":"Observer Design Pattern Best Practices","nodes":[{"content":"Observer Design Pattern Best Practices","pos":[0,38]}]},{"content":"In the .NET Framework, the observer design pattern is implemented as a set of interfaces.","pos":[387,476]},{"content":"The <ph id=\"ph1\">&lt;xref:System.IObservable%601?displayProperty=nameWithType&gt;</ph> interface represents the data provider, which is also responsible for providing an <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph> implementation that lets observers unsubscribe from notifications.","pos":[477,715],"source":" The <xref:System.IObservable%601?displayProperty=nameWithType> interface represents the data provider, which is also responsible for providing an <xref:System.IDisposable> implementation that lets observers unsubscribe from notifications."},{"content":"The <ph id=\"ph1\">&lt;xref:System.IObserver%601?displayProperty=nameWithType&gt;</ph> interface represents the observer.","pos":[716,811],"source":" The <xref:System.IObserver%601?displayProperty=nameWithType> interface represents the observer."},{"content":"This topic describes the best practices that developers should follow when implementing the observer design pattern using these interfaces.","pos":[812,951]},{"pos":[960,969],"content":"Threading","linkify":"Threading","nodes":[{"content":"Threading","pos":[0,9]}]},{"content":"Typically, a provider implements the <ph id=\"ph1\">&lt;xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType&gt;</ph> method by adding a particular observer to a subscriber list that is represented by some collection object, and it implements the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method by removing a particular observer from the subscriber list.","pos":[973,1343],"source":"Typically, a provider implements the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method by adding a particular observer to a subscriber list that is represented by some collection object, and it implements the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method by removing a particular observer from the subscriber list."},{"content":"An observer can call these methods at any time.","pos":[1344,1391]},{"content":"In addition, because the provider/observer contract does not specify who is responsible for unsubscribing after the <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType&gt;</ph> callback method, the provider and observer may both try to remove the same member from the list.","pos":[1392,1676],"source":" In addition, because the provider/observer contract does not specify who is responsible for unsubscribing after the <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> callback method, the provider and observer may both try to remove the same member from the list."},{"content":"Because of this possibility, both the <ph id=\"ph1\">&lt;xref:System.IObservable%601.Subscribe%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> methods should be thread-safe.","pos":[1677,1829],"source":" Because of this possibility, both the <xref:System.IObservable%601.Subscribe%2A> and <xref:System.IDisposable.Dispose%2A> methods should be thread-safe."},{"content":"Typically, this involves using a <bpt id=\"p1\">[</bpt>concurrent collection<ept id=\"p1\">](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md)</ept> or a lock.","pos":[1830,1986],"source":" Typically, this involves using a [concurrent collection](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md) or a lock."},{"content":"Implementations that are not thread-safe should explicitly document that they are not.","pos":[1987,2073]},{"content":"Any additional guarantees have to be specified in a layer on top of the provider/observer contract.","pos":[2080,2179]},{"content":"Implementers should clearly call out when they impose additional requirements to avoid user confusion about the observer contract.","pos":[2180,2310]},{"pos":[2319,2338],"content":"Handling Exceptions","linkify":"Handling Exceptions","nodes":[{"content":"Handling Exceptions","pos":[0,19]}]},{"content":"Because of the loose coupling between a data provider and an observer, exceptions in the observer design pattern are intended to be informational.","pos":[2342,2488]},{"content":"This affects how providers and observers handle exceptions in the observer design pattern.","pos":[2489,2579]},{"pos":[2589,2631],"content":"The Provider -- Calling the OnError Method","linkify":"The Provider -- Calling the OnError Method","nodes":[{"content":"The Provider -- Calling the OnError Method","pos":[0,42]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> method is intended as an informational message to observers, much like the <ph id=\"ph2\">&lt;xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType&gt;</ph> method.","pos":[2635,2827],"source":"The <xref:System.IObserver%601.OnError%2A> method is intended as an informational message to observers, much like the <xref:System.IObserver%601.OnNext%2A?displayProperty=nameWithType> method."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnNext%2A&gt;</ph> method is designed to provide an observer with current or updated data, whereas the <ph id=\"ph2\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> method is designed to indicate that the provider is unable to provide valid data.","pos":[2828,3083],"source":" However, the <xref:System.IObserver%601.OnNext%2A> method is designed to provide an observer with current or updated data, whereas the <xref:System.IObserver%601.OnError%2A> method is designed to indicate that the provider is unable to provide valid data."},{"pos":[3090,3225],"content":"The provider should follow these best practices when handling exceptions and calling the <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> method:","source":"The provider should follow these best practices when handling exceptions and calling the <xref:System.IObserver%601.OnError%2A> method:"},{"content":"The provider must handle its own exceptions if it has any specific requirements.","pos":[3235,3315]},{"content":"The provider should not expect or require that observers handle exceptions in any particular way.","pos":[3325,3422]},{"content":"The provider should call the <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> method when it handles an exception that compromises its ability to provide updates.","pos":[3432,3584],"source":"The provider should call the <xref:System.IObserver%601.OnError%2A> method when it handles an exception that compromises its ability to provide updates."},{"content":"Information on such exceptions can be passed to the observer.","pos":[3585,3646]},{"content":"In other cases, there is no need to notify observers of an exception.","pos":[3647,3716]},{"content":"Once the provider calls the <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType&gt;</ph> method, there should be no further notifications, and the provider can unsubscribe its observers.","pos":[3723,3962],"source":"Once the provider calls the <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> method, there should be no further notifications, and the provider can unsubscribe its observers."},{"content":"However, the observers can also unsubscribe themselves at any time, including both before and after they receive an <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType&gt;</ph> notification.","pos":[3963,4206],"source":" However, the observers can also unsubscribe themselves at any time, including both before and after they receive an <xref:System.IObserver%601.OnError%2A> or <xref:System.IObserver%601.OnCompleted%2A?displayProperty=nameWithType> notification."},{"content":"The observer design pattern does not dictate whether the provider or the observer is responsible for unsubscribing; therefore, there is a possibility that both may attempt to unsubscribe.","pos":[4207,4394]},{"content":"Typically, when observers unsubscribe, they are removed from a subscribers collection.","pos":[4395,4481]},{"content":"In a single-threaded application, the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation should ensure that an object reference is valid and that the object is a member of the subscribers collection before attempting to remove it.","pos":[4482,4742],"source":" In a single-threaded application, the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation should ensure that an object reference is valid and that the object is a member of the subscribers collection before attempting to remove it."},{"content":"In a multithreaded application, a thread-safe collection object, such as a <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType&gt;</ph> object, should be used.","pos":[4743,4930],"source":" In a multithreaded application, a thread-safe collection object, such as a <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> object, should be used."},{"pos":[4940,4987],"content":"The Observer -- Implementing the OnError Method","linkify":"The Observer -- Implementing the OnError Method","nodes":[{"content":"The Observer -- Implementing the OnError Method","pos":[0,47]}]},{"content":"When an observer receives an error notification from a provider, the observer should treat the exception as informational and should not be required to take any particular action.","pos":[4991,5170]},{"pos":[5177,5314],"content":"The observer should follow these best practices when responding to an <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> method call from a provider:","source":"The observer should follow these best practices when responding to an <xref:System.IObserver%601.OnError%2A> method call from a provider:"},{"content":"The observer should not throw exceptions from its interface implementations, such as <ph id=\"ph1\">&lt;xref:System.IObserver%601.OnNext%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph>.","pos":[5324,5489],"source":"The observer should not throw exceptions from its interface implementations, such as <xref:System.IObserver%601.OnNext%2A> or <xref:System.IObserver%601.OnError%2A>."},{"content":"However, if the observer does throw exceptions, it should expect these exceptions to go unhandled.","pos":[5490,5588]},{"content":"To preserve the call stack, an observer that wishes to throw an <ph id=\"ph1\">&lt;xref:System.Exception&gt;</ph> object that was passed to its <ph id=\"ph2\">&lt;xref:System.IObserver%601.OnError%2A&gt;</ph> method should wrap the exception before throwing it.","pos":[5598,5807],"source":"To preserve the call stack, an observer that wishes to throw an <xref:System.Exception> object that was passed to its <xref:System.IObserver%601.OnError%2A> method should wrap the exception before throwing it."},{"content":"A standard exception object should be used for this purpose.","pos":[5808,5868]},{"pos":[5877,5902],"content":"Additional Best Practices","linkify":"Additional Best Practices","nodes":[{"content":"Additional Best Practices","pos":[0,25]}]},{"content":"Attempting to unregister in the <ph id=\"ph1\">&lt;xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType&gt;</ph> method may result in a null reference.","pos":[5906,6048],"source":"Attempting to unregister in the <xref:System.IObservable%601.Subscribe%2A?displayProperty=nameWithType> method may result in a null reference."},{"content":"Therefore, we recommend that you avoid this practice.","pos":[6049,6102]},{"pos":[6109,6306],"content":"Although it is possible to attach an observer to multiple providers, the recommended pattern is to attach an <ph id=\"ph1\">&lt;xref:System.IObserver%601&gt;</ph> instance to only one <ph id=\"ph2\">&lt;xref:System.IObservable%601&gt;</ph> instance.","source":"Although it is possible to attach an observer to multiple providers, the recommended pattern is to attach an <xref:System.IObserver%601> instance to only one <xref:System.IObservable%601> instance."},{"pos":[6315,6323],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6327,6410],"content":"<bpt id=\"p1\">[</bpt>Observer Design Pattern<ept id=\"p1\">](../../../docs/standard/events/observer-design-pattern.md)</ept>","source":"[Observer Design Pattern](../../../docs/standard/events/observer-design-pattern.md)"},{"pos":[6413,6507],"content":"<bpt id=\"p1\">[</bpt>How to: Implement an Observer<ept id=\"p1\">](../../../docs/standard/events/how-to-implement-an-observer.md)</ept>","source":"[How to: Implement an Observer](../../../docs/standard/events/how-to-implement-an-observer.md)"},{"pos":[6510,6602],"content":"<bpt id=\"p1\">[</bpt>How to: Implement a Provider<ept id=\"p1\">](../../../docs/standard/events/how-to-implement-a-provider.md)</ept>","source":"[How to: Implement a Provider](../../../docs/standard/events/how-to-implement-a-provider.md)"}]}