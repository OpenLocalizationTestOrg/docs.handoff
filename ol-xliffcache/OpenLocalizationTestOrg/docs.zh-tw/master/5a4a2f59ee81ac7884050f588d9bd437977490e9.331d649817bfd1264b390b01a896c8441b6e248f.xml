{"content":"---\ntitle: \"Runtime Callable Wrapper\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"COM interop, COM wrappers\"\n  - \"RCW\"\n  - \"COM wrappers\"\n  - \"runtime callable wrappers\"\n  - \"interoperation with unmanaged code, COM wrappers\"\nms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Runtime Callable Wrapper\nThe common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW). Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.  \n  \n The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object. The runtime maintains a single RCW per process for each object.  If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.  As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.  \n\nThe following image shows the process for accessing COM objects through the runtime callable wrapper:\n\n ![Process for accessing COM objects throug the RCW.](./media/runtime-callable-wrapper/runtime-callable-wrapper.gif)  \n\n Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object. Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed. The runtime performs garbage collection on the RCW.  \n  \n Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object. Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.  \n  \n The standard wrapper enforces built-in marshaling rules. For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type. Should the COM object return a BSTR to its managed caller, the caller receives a String. Both the client and the server send and receive data that is familiar to them. Other types require no conversion. For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.  \n  \n## Marshaling selected interfaces  \n The primary goal of the [runtime callable wrapper](runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models. To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration. \n\n The following image shows COM interfaces and the runtime callable wrapper: \n  \n ![Screenshot of the runtime callable wrapper with interfaces.](./media/runtime-callable-wrapper/runtime-callable-wrapper-interfaces.gif)  \n  \n When created as an early-bound object, the RCW is a specific type. It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces. In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces. Further, the RCW exposes all members of the INew interface to the .NET client.  \n  \n The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.  \n  \n|Interface|Description|  \n|---------------|-----------------|  \n|**IDispatch**|For late binding to COM objects through reflection.|  \n|**IErrorInfo**|Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).|  \n|**IProvideClassInfo**|If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity.|  \n|**IUnknown**|For object identity, type coercion, and lifetime management:<br /><br /> -   Object identity<br />     The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object.<br />-   Type coercion<br />     The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method.<br />-   Lifetime management<br />     Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.|  \n  \n The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.  \n  \n|Interface|Description|  \n|---------------|-----------------|  \n|**IConnectionPoint** and **IConnectionPointContainer**|The RCW converts objects that expose the connection-point event style to delegate-based events.|  \n|**IDispatchEx**|If the class implements **IDispatchEx**, the RCW implements **IExpando**. The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.|  \n|**IEnumVARIANT**|Enables COM types that support enumerations to be treated as collections.|  \n  \n## See also\n\n- [COM Wrappers](com-wrappers.md)\n- [COM Callable Wrapper](com-callable-wrapper.md)\n- [Type Library to Assembly Conversion Summary](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))\n- [Importing a Type Library as an Assembly](importing-a-type-library-as-an-assembly.md)\n","nodes":[{"pos":[4,318],"embed":true,"restype":"x-metadata","content":"title: \"Runtime Callable Wrapper\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"COM interop, COM wrappers\"\n  - \"RCW\"\n  - \"COM wrappers\"\n  - \"runtime callable wrappers\"\n  - \"interoperation with unmanaged code, COM wrappers\"\nms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Runtime Callable Wrapper","nodes":[{"pos":[0,24],"content":"Runtime Callable Wrapper","nodes":[{"content":"Runtime Callable Wrapper","pos":[0,24]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[325,349],"content":"Runtime Callable Wrapper","linkify":"Runtime Callable Wrapper","nodes":[{"content":"Runtime Callable Wrapper","pos":[0,24]}]},{"content":"The common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW).","pos":[350,456]},{"content":"Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.","pos":[457,604]},{"content":"The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object.","pos":[611,733]},{"content":"The runtime maintains a single RCW per process for each object.","pos":[734,797]},{"content":"If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.","pos":[799,971]},{"content":"As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.","pos":[973,1119]},{"content":"The following image shows the process for accessing COM objects through the runtime callable wrapper:","pos":[1123,1224]},{"content":"Process for accessing COM objects throug the RCW.","pos":[1229,1278]},{"content":"Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object.","pos":[1347,1474]},{"content":"Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed.","pos":[1475,1629]},{"content":"The runtime performs garbage collection on the RCW.","pos":[1630,1681]},{"content":"Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object.","pos":[1688,1802]},{"content":"Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.","pos":[1803,1985]},{"content":"The standard wrapper enforces built-in marshaling rules.","pos":[1992,2048]},{"content":"For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type.","pos":[2049,2196]},{"content":"Should the COM object return a BSTR to its managed caller, the caller receives a String.","pos":[2197,2285]},{"content":"Both the client and the server send and receive data that is familiar to them.","pos":[2286,2364]},{"content":"Other types require no conversion.","pos":[2365,2399]},{"content":"For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.","pos":[2400,2530]},{"pos":[2539,2569],"content":"Marshaling selected interfaces","linkify":"Marshaling selected interfaces","nodes":[{"content":"Marshaling selected interfaces","pos":[0,30]}]},{"content":"The primary goal of the <bpt id=\"p1\">[</bpt>runtime callable wrapper<ept id=\"p1\">](runtime-callable-wrapper.md)</ept> (RCW) is to hide the differences between the managed and unmanaged programming models.","pos":[2573,2739],"source":"The primary goal of the [runtime callable wrapper](runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models."},{"content":"To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration.","pos":[2740,2895]},{"content":"The following image shows COM interfaces and the runtime callable wrapper:","pos":[2899,2973]},{"content":"Screenshot of the runtime callable wrapper with interfaces.","pos":[2981,3040]},{"content":"When created as an early-bound object, the RCW is a specific type.","pos":[3122,3188]},{"content":"It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces.","pos":[3189,3326]},{"content":"In the illustration, the RCW exposes the INew interface but consumes the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IDispatch<ept id=\"p2\">**</ept> interfaces.","pos":[3327,3442],"source":" In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces."},{"content":"Further, the RCW exposes all members of the INew interface to the .NET client.","pos":[3443,3521]},{"content":"The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.","pos":[3528,3632]},{"content":"Interface","pos":[3639,3648]},{"content":"Description","pos":[3649,3660]},{"pos":[3703,3716],"content":"<bpt id=\"p1\">**</bpt>IDispatch<ept id=\"p1\">**</ept>","source":"**IDispatch**"},{"content":"For late binding to COM objects through reflection.","pos":[3717,3768]},{"pos":[3773,3787],"content":"<bpt id=\"p1\">**</bpt>IErrorInfo<ept id=\"p1\">**</ept>","source":"**IErrorInfo**"},{"pos":[3788,3965],"content":"Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always <bpt id=\"p1\">**</bpt>GUID_NULL<ept id=\"p1\">**</ept> for .NET classes).","source":"Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes)."},{"pos":[3970,3991],"content":"<bpt id=\"p1\">**</bpt>IProvideClassInfo<ept id=\"p1\">**</ept>","source":"**IProvideClassInfo**"},{"pos":[3992,4148],"content":"If the COM object being wrapped implements <bpt id=\"p1\">**</bpt>IProvideClassInfo<ept id=\"p1\">**</ept>, the RCW extracts the type information from this interface to provide better type identity.","source":"If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity."},{"pos":[4153,4165],"content":"<bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept>","source":"**IUnknown**"},{"content":"For object identity, type coercion, and lifetime management:","pos":[4166,4226]},{"content":"-   Object identity","pos":[4239,4258]},{"content":"The runtime distinguishes between COM objects by comparing the value of the <bpt id=\"p1\">**</bpt>IUnknown<ept id=\"p1\">**</ept> interface for each object.","pos":[4269,4384],"source":"The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object."},{"content":"-   Type coercion","pos":[4390,4407]},{"content":"The RCW recognizes the dynamic type discovery performed by the <bpt id=\"p1\">**</bpt>QueryInterface<ept id=\"p1\">**</ept> method.","pos":[4418,4507],"source":"The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method."},{"content":"-   Lifetime management","pos":[4513,4536]},{"content":"Using the <bpt id=\"p1\">**</bpt>QueryInterface<ept id=\"p1\">**</ept> method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.","pos":[4547,4740],"source":"Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object."},{"content":"The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.","pos":[4748,4863]},{"content":"Interface","pos":[4870,4879]},{"content":"Description","pos":[4880,4891]},{"pos":[4934,4988],"content":"<bpt id=\"p1\">**</bpt>IConnectionPoint<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IConnectionPointContainer<ept id=\"p2\">**</ept>","source":"**IConnectionPoint** and **IConnectionPointContainer**"},{"content":"The RCW converts objects that expose the connection-point event style to delegate-based events.","pos":[4989,5084]},{"pos":[5089,5104],"content":"<bpt id=\"p1\">**</bpt>IDispatchEx<ept id=\"p1\">**</ept>","source":"**IDispatchEx**"},{"content":"If the class implements <bpt id=\"p1\">**</bpt>IDispatchEx<ept id=\"p1\">**</ept>, the RCW implements <bpt id=\"p2\">**</bpt>IExpando<ept id=\"p2\">**</ept>.","pos":[5105,5178],"source":"If the class implements **IDispatchEx**, the RCW implements **IExpando**."},{"content":"The <bpt id=\"p1\">**</bpt>IDispatchEx<ept id=\"p1\">**</ept> interface is an extension of the <bpt id=\"p2\">**</bpt>IDispatch<ept id=\"p2\">**</ept> interface that, unlike <bpt id=\"p3\">**</bpt>IDispatch<ept id=\"p3\">**</ept>, enables enumeration, addition, deletion, and case-sensitive calling of members.","pos":[5179,5363],"source":" The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members."},{"pos":[5368,5384],"content":"<bpt id=\"p1\">**</bpt>IEnumVARIANT<ept id=\"p1\">**</ept>","source":"**IEnumVARIANT**"},{"content":"Enables COM types that support enumerations to be treated as collections.","pos":[5385,5458]},{"pos":[5468,5476],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5480,5511],"content":"<bpt id=\"p1\">[</bpt>COM Wrappers<ept id=\"p1\">](com-wrappers.md)</ept>","source":"[COM Wrappers](com-wrappers.md)"},{"pos":[5514,5561],"content":"<bpt id=\"p1\">[</bpt>COM Callable Wrapper<ept id=\"p1\">](com-callable-wrapper.md)</ept>","source":"[COM Callable Wrapper](com-callable-wrapper.md)"},{"pos":[5564,5698],"content":"<bpt id=\"p1\">[</bpt>Type Library to Assembly Conversion Summary<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))</ept>","source":"[Type Library to Assembly Conversion Summary](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/k83zzh38(v=vs.100))"},{"pos":[5701,5786],"content":"<bpt id=\"p1\">[</bpt>Importing a Type Library as an Assembly<ept id=\"p1\">](importing-a-type-library-as-an-assembly.md)</ept>","source":"[Importing a Type Library as an Assembly](importing-a-type-library-as-an-assembly.md)"}]}