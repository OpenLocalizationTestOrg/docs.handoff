{"content":"---\ntitle: \"Troubleshooting Data Types (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Char data type [Visual Basic], converting\"\n  - \"Decimal data type [Visual Basic], conversions\"\n  - \"data types [Visual Basic], troubleshooting\"\n  - \"literals [Visual Basic], default types\"\n  - \"type characters [Visual Basic], literal\"\n  - \"Mod operator [Visual Basic], in floating-point operations\"\n  - \"troubleshooting Visual Basic, data types\"\n  - \"troubleshooting data types [Visual Basic]\"\n  - \"floating-point numbers [Visual Basic], precision\"\n  - \"Boolean data type [Visual Basic], converting\"\n  - \"literal types [Visual Basic]\"\n  - \"literal type characters [Visual Basic]\"\n  - \"floating-point numbers [Visual Basic], imprecision\"\n  - \"String data type [Visual Basic], converting\"\n  - \"floating-point numbers [Visual Basic], comparison\"\n  - \"floating-point numbers\"\nms.assetid: 90040d67-b630-4125-a6ae-37195b079042\n---\n# Troubleshooting Data Types (Visual Basic)\nThis page lists some common problems that can occur when you perform operations on intrinsic data types.  \n  \n## Floating-Point Expressions Do Not Compare as Equal  \n When you work with floating-point numbers ([Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md)), remember that they are stored as binary fractions. This means they cannot hold an exact representation of any quantity that is not a binary fraction (of the form k / (2 ^ n) where k and n are integers). For example, 0.5 (= 1/2) and 0.3125 (= 5/16) can be held as precise values, whereas 0.2 (= 1/5) and 0.3 (= 3/10) can be only approximations.  \n  \n Because of this imprecision, you cannot rely on exact results when you operate on floating-point values. In particular, two values that are theoretically equal might have slightly different representations.  \n  \n| To compare floating-point quantities | \n|---| \n|1.  Calculate the absolute value of their difference by using the <xref:System.Math.Abs%2A> method of the <xref:System.Math> class in the <xref:System> namespace.<br />2.  Determine an acceptable maximum difference, such that you can consider the two quantities to be equal for practical purposes if their difference is no larger.<br />3.  Compare the absolute value of the difference to the acceptable difference.|  \n  \n The following example demonstrates both incorrect and correct comparison of two `Double` values.  \n  \n [!code-vb[VbVbalrDataTypes#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#10)]  \n  \n The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better  precision than the `CStr` keyword uses. The default is 15 digits, but the \"G17\" format extends it to 17 digits.  \n  \n## Mod Operator Does Not Return Accurate Result  \n Because of the imprecision of floating-point storage, the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md) can return an unexpected result when at least one of the operands is floating-point.  \n  \n The [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md) does not use floating-point representation. Many numbers that are inexact in `Single` and `Double` are exact in `Decimal` (for example 0.2 and 0.3). Although arithmetic is slower in `Decimal` than in floating-point, it might be worth the performance decrease to achieve better precision.  \n  \n|To find the integer remainder of floating-point quantities|  \n|---|  \n|1.  Declare variables as `Decimal`.<br />2.  Use the literal type character `D` to force literals to `Decimal`, in case their values are too large for the `Long` data type.|  \n  \n The following example demonstrates the potential imprecision of floating-point operands.  \n  \n [!code-vb[VbVbalrDataTypes#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#11)]  \n  \n The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better precision than the `CStr` keyword uses. The default is 15 digits, but the \"G17\" format extends it to 17 digits.  \n  \n Because `zeroPointTwo` is `Double`, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001. Dividing 2.0 by this quantity yields 9.9999999999999995 with a remainder of 0.19999999999999991.  \n  \n In the expression for `decimalRemainder`, the literal type character `D` forces both operands to `Decimal`, and 0.2 has a precise representation. Therefore the `Mod` operator yields the expected remainder of 0.0.  \n  \n Note that it is not sufficient to declare `decimalRemainder` as `Decimal`. You must also force the literals to `Decimal`, or they use `Double` by default and `decimalRemainder` receives the same inaccurate value as `doubleRemainder`.  \n  \n## Boolean Type Does Not Convert to Numeric Type Accurately  \n [Boolean Data Type](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) values are not stored as numbers, and the stored values are not intended to be equivalent to numbers. For compatibility with earlier versions, Visual Basic provides conversion keywords ([CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), `CBool`, `CInt`, and so on) to convert between `Boolean` and numeric types. However, other languages sometimes perform these conversions differently, as do the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] methods.  \n  \n You should never write code that relies on equivalent numeric values for `True` and `False`. Whenever possible, you should restrict usage of `Boolean` variables to the logical values for which they are designed. If you must mix `Boolean` and numeric values, make sure that you understand the conversion method that you select.  \n  \n### Conversion in Visual Basic  \n When you use the `CType` or `CBool` conversion keywords to convert numeric data types to `Boolean`, 0 becomes `False` and all other values become `True`. When you convert `Boolean` values to numeric types by using the conversion keywords, `False` becomes 0 and `True` becomes -1.  \n  \n### Conversion in the Framework  \n The <xref:System.Convert.ToInt32%2A> method of the <xref:System.Convert> class in the <xref:System> namespace converts `True` to +1.  \n  \n If you must convert a `Boolean` value to a numeric data type, be careful about which conversion method you use.  \n  \n## Character Literal Generates Compiler Error  \n In the absence of any type characters, Visual Basic assumes default data types for literals. The default type for a character literal — enclosed in quotation marks (`\" \"`) — is `String`.  \n  \n The `String` data type does not widen to the [Char Data Type](../../../../visual-basic/language-reference/data-types/char-data-type.md). This means that if you want to assign a literal to a `Char` variable, you must either make a narrowing conversion or force the literal to the `Char` type.  \n\n|To create a Char literal to assign to a variable or constant|\n|---|  \n|1.  Declare the variable or constant as `Char`.<br />2.  Enclose the character value in quotation marks (`\" \"`).<br />3.  Follow the closing double quotation mark with the literal type character `C` to force the literal to `Char`. This is necessary if the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, and it is desirable in any case.|  \n  \n The following example demonstrates both unsuccessful and successful assignments of a literal to a `Char` variable.  \n  \n [!code-vb[VbVbalrDataTypes#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrDataTypes/VB/Class1.vb#12)]  \n  \n There is always a risk in using narrowing conversions, because they can fail at run time. For example, a conversion from `String` to `Char` can fail if the `String` value contains more than one character. Therefore, it is better programming to use the `C` type character.  \n  \n## String Conversion Fails at Run Time  \n The [String Data Type](../../../../visual-basic/language-reference/data-types/string-data-type.md) participates in very few widening conversions. `String` widens only to itself and `Object`, and only `Char` and `Char()` (a `Char` array) widen to `String`. This is because `String` variables and constants can contain values that other data types cannot contain.  \n  \n When the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, the compiler disallows all implicit narrowing conversions. This includes those involving `String`. Your code can still use conversion keywords such as `CStr` and [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), which direct the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] to attempt the conversion.  \n  \n> [!NOTE]\n>  The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).  \n  \n### Narrowing Conversion Protection  \n The disadvantage of narrowing conversions is that they can fail at run time. For example, if a `String` variable contains anything other than \"True\" or \"False,\" it cannot be converted to `Boolean`. If it contains punctuation characters, conversion to any numeric type fails. Unless you know that your `String` variable always holds values that the destination type can accept, you should not try a conversion.  \n  \n If you must convert from `String` to another data type, the safest procedure is to enclose the attempted conversion in the [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md). This lets you deal with a run-time failure.  \n  \n### Character Arrays  \n A single `Char` and an array of `Char` elements both widen to `String`. However, `String` does not widen to `Char()`. To convert a `String` value to a `Char` array, you can use the <xref:System.String.ToCharArray%2A> method of the <xref:System.String?displayProperty=nameWithType> class.  \n  \n### Meaningless Values  \n In general, `String` values are not meaningful in other data types, and conversion is highly artificial and dangerous. Whenever possible, you should restrict usage of `String` variables to the character sequences for which they are designed. You should never write code that relies on equivalent values in other types.  \n  \n## See also\n\n- [Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)\n- [Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)\n- [Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)\n- [Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)\n- [Data Types](../../../../visual-basic/language-reference/data-types/index.md)\n- [Type Conversion Functions](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)\n- [Efficient Use of Data Types](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)\n","nodes":[{"pos":[4,922],"embed":true,"restype":"x-metadata","content":"title: \"Troubleshooting Data Types (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Char data type [Visual Basic], converting\"\n  - \"Decimal data type [Visual Basic], conversions\"\n  - \"data types [Visual Basic], troubleshooting\"\n  - \"literals [Visual Basic], default types\"\n  - \"type characters [Visual Basic], literal\"\n  - \"Mod operator [Visual Basic], in floating-point operations\"\n  - \"troubleshooting Visual Basic, data types\"\n  - \"troubleshooting data types [Visual Basic]\"\n  - \"floating-point numbers [Visual Basic], precision\"\n  - \"Boolean data type [Visual Basic], converting\"\n  - \"literal types [Visual Basic]\"\n  - \"literal type characters [Visual Basic]\"\n  - \"floating-point numbers [Visual Basic], imprecision\"\n  - \"String data type [Visual Basic], converting\"\n  - \"floating-point numbers [Visual Basic], comparison\"\n  - \"floating-point numbers\"\nms.assetid: 90040d67-b630-4125-a6ae-37195b079042","nodes":[{"content":"Troubleshooting Data Types (Visual Basic)","nodes":[{"pos":[0,41],"content":"Troubleshooting Data Types (Visual Basic)","nodes":[{"content":"Troubleshooting Data Types (Visual Basic)","pos":[0,41]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[929,970],"content":"Troubleshooting Data Types (Visual Basic)","linkify":"Troubleshooting Data Types (Visual Basic)","nodes":[{"content":"Troubleshooting Data Types (Visual Basic)","pos":[0,41]}]},{"content":"This page lists some common problems that can occur when you perform operations on intrinsic data types.","pos":[971,1075]},{"pos":[1084,1134],"content":"Floating-Point Expressions Do Not Compare as Equal","linkify":"Floating-Point Expressions Do Not Compare as Equal","nodes":[{"content":"Floating-Point Expressions Do Not Compare as Equal","pos":[0,50]}]},{"content":"When you work with floating-point numbers (<bpt id=\"p1\">[</bpt>Single Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/single-data-type.md)</ept> and <bpt id=\"p2\">[</bpt>Double Data Type<ept id=\"p2\">](../../../../visual-basic/language-reference/data-types/double-data-type.md)</ept>), remember that they are stored as binary fractions.","pos":[1138,1427],"source":"When you work with floating-point numbers ([Single Data Type](../../../../visual-basic/language-reference/data-types/single-data-type.md) and [Double Data Type](../../../../visual-basic/language-reference/data-types/double-data-type.md)), remember that they are stored as binary fractions."},{"content":"This means they cannot hold an exact representation of any quantity that is not a binary fraction (of the form k / (2 ^ n) where k and n are integers).","pos":[1428,1579]},{"content":"For example, 0.5 (= 1/2) and 0.3125 (= 5/16) can be held as precise values, whereas 0.2 (= 1/5) and 0.3 (= 3/10) can be only approximations.","pos":[1580,1720]},{"content":"Because of this imprecision, you cannot rely on exact results when you operate on floating-point values.","pos":[1727,1831]},{"content":"In particular, two values that are theoretically equal might have slightly different representations.","pos":[1832,1933]},{"content":"To compare floating-point quantities","pos":[1941,1977]},{"content":"1.  Calculate the absolute value of their difference by using the <ph id=\"ph1\">&lt;xref:System.Math.Abs%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Math&gt;</ph> class in the <ph id=\"ph3\">&lt;xref:System&gt;</ph> namespace.","pos":[1989,2151],"source":"1.  Calculate the absolute value of their difference by using the <xref:System.Math.Abs%2A> method of the <xref:System.Math> class in the <xref:System> namespace."},{"content":"2.  Determine an acceptable maximum difference, such that you can consider the two quantities to be equal for practical purposes if their difference is no larger.","pos":[2157,2319]},{"content":"3.  Compare the absolute value of the difference to the acceptable difference.","pos":[2325,2403]},{"pos":[2411,2507],"content":"The following example demonstrates both incorrect and correct comparison of two <ph id=\"ph1\">`Double`</ph> values.","source":"The following example demonstrates both incorrect and correct comparison of two `Double` values."},{"content":"The previous example uses the <ph id=\"ph1\">&lt;xref:System.Double.ToString%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Double&gt;</ph> structure so that it can specify better  precision than the <ph id=\"ph3\">`CStr`</ph> keyword uses.","pos":[2638,2816],"source":"The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better  precision than the `CStr` keyword uses."},{"content":"The default is 15 digits, but the \"G17\" format extends it to 17 digits.","pos":[2817,2888]},{"pos":[2897,2941],"content":"Mod Operator Does Not Return Accurate Result","linkify":"Mod Operator Does Not Return Accurate Result","nodes":[{"content":"Mod Operator Does Not Return Accurate Result","pos":[0,44]}]},{"pos":[2945,3173],"content":"Because of the imprecision of floating-point storage, the <bpt id=\"p1\">[</bpt>Mod Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept> can return an unexpected result when at least one of the operands is floating-point.","source":"Because of the imprecision of floating-point storage, the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md) can return an unexpected result when at least one of the operands is floating-point."},{"content":"The <bpt id=\"p1\">[</bpt>Decimal Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/decimal-data-type.md)</ept> does not use floating-point representation.","pos":[3180,3324],"source":"The [Decimal Data Type](../../../../visual-basic/language-reference/data-types/decimal-data-type.md) does not use floating-point representation."},{"content":"Many numbers that are inexact in <ph id=\"ph1\">`Single`</ph> and <ph id=\"ph2\">`Double`</ph> are exact in <ph id=\"ph3\">`Decimal`</ph> (for example 0.2 and 0.3).","pos":[3325,3429],"source":" Many numbers that are inexact in `Single` and `Double` are exact in `Decimal` (for example 0.2 and 0.3)."},{"content":"Although arithmetic is slower in <ph id=\"ph1\">`Decimal`</ph> than in floating-point, it might be worth the performance decrease to achieve better precision.","pos":[3430,3568],"source":" Although arithmetic is slower in `Decimal` than in floating-point, it might be worth the performance decrease to achieve better precision."},{"content":"To find the integer remainder of floating-point quantities","pos":[3575,3633]},{"content":"1.  Declare variables as <ph id=\"ph1\">`Decimal`</ph>.","pos":[3646,3681],"source":"1.  Declare variables as `Decimal`."},{"content":"2.  Use the literal type character <ph id=\"ph1\">`D`</ph> to force literals to <ph id=\"ph2\">`Decimal`</ph>, in case their values are too large for the <ph id=\"ph3\">`Long`</ph> data type.","pos":[3687,3818],"source":"2.  Use the literal type character `D` to force literals to `Decimal`, in case their values are too large for the `Long` data type."},{"content":"The following example demonstrates the potential imprecision of floating-point operands.","pos":[3826,3914]},{"content":"The previous example uses the <ph id=\"ph1\">&lt;xref:System.Double.ToString%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Double&gt;</ph> structure so that it can specify better precision than the <ph id=\"ph3\">`CStr`</ph> keyword uses.","pos":[4045,4222],"source":"The previous example uses the <xref:System.Double.ToString%2A> method of the <xref:System.Double> structure so that it can specify better precision than the `CStr` keyword uses."},{"content":"The default is 15 digits, but the \"G17\" format extends it to 17 digits.","pos":[4223,4294]},{"content":"Because <ph id=\"ph1\">`zeroPointTwo`</ph> is <ph id=\"ph2\">`Double`</ph>, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001.","pos":[4301,4441],"source":"Because `zeroPointTwo` is `Double`, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001."},{"content":"Dividing 2.0 by this quantity yields 9.9999999999999995 with a remainder of 0.19999999999999991.","pos":[4442,4538]},{"content":"In the expression for <ph id=\"ph1\">`decimalRemainder`</ph>, the literal type character <ph id=\"ph2\">`D`</ph> forces both operands to <ph id=\"ph3\">`Decimal`</ph>, and 0.2 has a precise representation.","pos":[4545,4690],"source":"In the expression for `decimalRemainder`, the literal type character `D` forces both operands to `Decimal`, and 0.2 has a precise representation."},{"content":"Therefore the <ph id=\"ph1\">`Mod`</ph> operator yields the expected remainder of 0.0.","pos":[4691,4757],"source":" Therefore the `Mod` operator yields the expected remainder of 0.0."},{"content":"Note that it is not sufficient to declare <ph id=\"ph1\">`decimalRemainder`</ph> as <ph id=\"ph2\">`Decimal`</ph>.","pos":[4764,4838],"source":"Note that it is not sufficient to declare `decimalRemainder` as `Decimal`."},{"content":"You must also force the literals to <ph id=\"ph1\">`Decimal`</ph>, or they use <ph id=\"ph2\">`Double`</ph> by default and <ph id=\"ph3\">`decimalRemainder`</ph> receives the same inaccurate value as <ph id=\"ph4\">`doubleRemainder`</ph>.","pos":[4839,4997],"source":" You must also force the literals to `Decimal`, or they use `Double` by default and `decimalRemainder` receives the same inaccurate value as `doubleRemainder`."},{"pos":[5006,5062],"content":"Boolean Type Does Not Convert to Numeric Type Accurately","linkify":"Boolean Type Does Not Convert to Numeric Type Accurately","nodes":[{"content":"Boolean Type Does Not Convert to Numeric Type Accurately","pos":[0,56]}]},{"content":"<bpt id=\"p1\">[</bpt>Boolean Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/boolean-data-type.md)</ept> values are not stored as numbers, and the stored values are not intended to be equivalent to numbers.","pos":[5066,5264],"source":"[Boolean Data Type](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) values are not stored as numbers, and the stored values are not intended to be equivalent to numbers."},{"content":"For compatibility with earlier versions, Visual Basic provides conversion keywords (<bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept>, <ph id=\"ph1\">`CBool`</ph>, <ph id=\"ph2\">`CInt`</ph>, and so on) to convert between <ph id=\"ph3\">`Boolean`</ph> and numeric types.","pos":[5265,5515],"source":" For compatibility with earlier versions, Visual Basic provides conversion keywords ([CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), `CBool`, `CInt`, and so on) to convert between `Boolean` and numeric types."},{"content":"However, other languages sometimes perform these conversions differently, as do the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> methods.","pos":[5516,5662],"source":" However, other languages sometimes perform these conversions differently, as do the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] methods."},{"content":"You should never write code that relies on equivalent numeric values for <ph id=\"ph1\">`True`</ph> and <ph id=\"ph2\">`False`</ph>.","pos":[5669,5761],"source":"You should never write code that relies on equivalent numeric values for `True` and `False`."},{"content":"Whenever possible, you should restrict usage of <ph id=\"ph1\">`Boolean`</ph> variables to the logical values for which they are designed.","pos":[5762,5880],"source":" Whenever possible, you should restrict usage of `Boolean` variables to the logical values for which they are designed."},{"content":"If you must mix <ph id=\"ph1\">`Boolean`</ph> and numeric values, make sure that you understand the conversion method that you select.","pos":[5881,5995],"source":" If you must mix `Boolean` and numeric values, make sure that you understand the conversion method that you select."},{"pos":[6005,6031],"content":"Conversion in Visual Basic","linkify":"Conversion in Visual Basic","nodes":[{"content":"Conversion in Visual Basic","pos":[0,26]}]},{"content":"When you use the <ph id=\"ph1\">`CType`</ph> or <ph id=\"ph2\">`CBool`</ph> conversion keywords to convert numeric data types to <ph id=\"ph3\">`Boolean`</ph>, 0 becomes <ph id=\"ph4\">`False`</ph> and all other values become <ph id=\"ph5\">`True`</ph>.","pos":[6035,6188],"source":"When you use the `CType` or `CBool` conversion keywords to convert numeric data types to `Boolean`, 0 becomes `False` and all other values become `True`."},{"content":"When you convert <ph id=\"ph1\">`Boolean`</ph> values to numeric types by using the conversion keywords, <ph id=\"ph2\">`False`</ph> becomes 0 and <ph id=\"ph3\">`True`</ph> becomes -1.","pos":[6189,6314],"source":" When you convert `Boolean` values to numeric types by using the conversion keywords, `False` becomes 0 and `True` becomes -1."},{"pos":[6324,6351],"content":"Conversion in the Framework","linkify":"Conversion in the Framework","nodes":[{"content":"Conversion in the Framework","pos":[0,27]}]},{"pos":[6355,6487],"content":"The <ph id=\"ph1\">&lt;xref:System.Convert.ToInt32%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Convert&gt;</ph> class in the <ph id=\"ph3\">&lt;xref:System&gt;</ph> namespace converts <ph id=\"ph4\">`True`</ph> to +1.","source":"The <xref:System.Convert.ToInt32%2A> method of the <xref:System.Convert> class in the <xref:System> namespace converts `True` to +1."},{"pos":[6494,6605],"content":"If you must convert a <ph id=\"ph1\">`Boolean`</ph> value to a numeric data type, be careful about which conversion method you use.","source":"If you must convert a `Boolean` value to a numeric data type, be careful about which conversion method you use."},{"pos":[6614,6656],"content":"Character Literal Generates Compiler Error","linkify":"Character Literal Generates Compiler Error","nodes":[{"content":"Character Literal Generates Compiler Error","pos":[0,42]}]},{"content":"In the absence of any type characters, Visual Basic assumes default data types for literals.","pos":[6660,6752]},{"content":"The default type for a character literal — enclosed in quotation marks (<ph id=\"ph1\">`\" \"`</ph>) — is <ph id=\"ph2\">`String`</ph>.","pos":[6753,6846],"source":" The default type for a character literal — enclosed in quotation marks (`\" \"`) — is `String`."},{"content":"The <ph id=\"ph1\">`String`</ph> data type does not widen to the <bpt id=\"p1\">[</bpt>Char Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/char-data-type.md)</ept>.","pos":[6853,6989],"source":"The `String` data type does not widen to the [Char Data Type](../../../../visual-basic/language-reference/data-types/char-data-type.md)."},{"content":"This means that if you want to assign a literal to a <ph id=\"ph1\">`Char`</ph> variable, you must either make a narrowing conversion or force the literal to the <ph id=\"ph2\">`Char`</ph> type.","pos":[6990,7144],"source":" This means that if you want to assign a literal to a `Char` variable, you must either make a narrowing conversion or force the literal to the `Char` type."},{"content":"To create a Char literal to assign to a variable or constant","pos":[7149,7209]},{"content":"1.  Declare the variable or constant as <ph id=\"ph1\">`Char`</ph>.","pos":[7220,7267],"source":"1.  Declare the variable or constant as `Char`."},{"content":"2.  Enclose the character value in quotation marks (<ph id=\"ph1\">`\" \"`</ph>).","pos":[7273,7332],"source":"2.  Enclose the character value in quotation marks (`\" \"`)."},{"content":"3.  Follow the closing double quotation mark with the literal type character <ph id=\"ph1\">`C`</ph> to force the literal to <ph id=\"ph2\">`Char`</ph>.","pos":[7338,7450],"source":"3.  Follow the closing double quotation mark with the literal type character `C` to force the literal to `Char`."},{"content":"This is necessary if the type checking switch (<bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>) is <ph id=\"ph1\">`On`</ph>, and it is desirable in any case.","pos":[7451,7649],"source":" This is necessary if the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, and it is desirable in any case."},{"pos":[7657,7771],"content":"The following example demonstrates both unsuccessful and successful assignments of a literal to a <ph id=\"ph1\">`Char`</ph> variable.","source":"The following example demonstrates both unsuccessful and successful assignments of a literal to a `Char` variable."},{"content":"There is always a risk in using narrowing conversions, because they can fail at run time.","pos":[7902,7991]},{"content":"For example, a conversion from <ph id=\"ph1\">`String`</ph> to <ph id=\"ph2\">`Char`</ph> can fail if the <ph id=\"ph3\">`String`</ph> value contains more than one character.","pos":[7992,8106],"source":" For example, a conversion from `String` to `Char` can fail if the `String` value contains more than one character."},{"content":"Therefore, it is better programming to use the <ph id=\"ph1\">`C`</ph> type character.","pos":[8107,8173],"source":" Therefore, it is better programming to use the `C` type character."},{"pos":[8182,8217],"content":"String Conversion Fails at Run Time","linkify":"String Conversion Fails at Run Time","nodes":[{"content":"String Conversion Fails at Run Time","pos":[0,35]}]},{"content":"The <bpt id=\"p1\">[</bpt>String Data Type<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/string-data-type.md)</ept> participates in very few widening conversions.","pos":[8221,8366],"source":"The [String Data Type](../../../../visual-basic/language-reference/data-types/string-data-type.md) participates in very few widening conversions."},{"content":"<ph id=\"ph1\">`String`</ph> widens only to itself and <ph id=\"ph2\">`Object`</ph>, and only <ph id=\"ph3\">`Char`</ph> and <ph id=\"ph4\">`Char()`</ph> (a <ph id=\"ph5\">`Char`</ph> array) widen to <ph id=\"ph6\">`String`</ph>.","pos":[8367,8476],"source":"`String` widens only to itself and `Object`, and only `Char` and `Char()` (a `Char` array) widen to `String`."},{"content":"This is because <ph id=\"ph1\">`String`</ph> variables and constants can contain values that other data types cannot contain.","pos":[8477,8582],"source":" This is because `String` variables and constants can contain values that other data types cannot contain."},{"content":"When the type checking switch (<bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>) is <ph id=\"ph1\">`On`</ph>, the compiler disallows all implicit narrowing conversions.","pos":[8589,8797],"source":"When the type checking switch ([Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)) is `On`, the compiler disallows all implicit narrowing conversions."},{"content":"This includes those involving <ph id=\"ph1\">`String`</ph>.","pos":[8798,8837],"source":" This includes those involving `String`."},{"content":"Your code can still use conversion keywords such as <ph id=\"ph1\">`CStr`</ph> and <bpt id=\"p1\">[</bpt>CType Function<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/ctype-function.md)</ept>, which direct the <ph id=\"ph2\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> to attempt the conversion.","pos":[8838,9089],"source":" Your code can still use conversion keywords such as `CStr` and [CType Function](../../../../visual-basic/language-reference/functions/ctype-function.md), which direct the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] to attempt the conversion."},{"pos":[9097,9438],"content":"[!NOTE]\n The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).","leadings":["","> "],"nodes":[{"content":"The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable. For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).","pos":[9,339],"nodes":[{"content":"The narrowing-conversion error is suppressed for conversions from the elements in a <ph id=\"ph1\">`For Each…Next`</ph> collection to the loop control variable.","pos":[0,140],"source":"The narrowing-conversion error is suppressed for conversions from the elements in a `For Each…Next` collection to the loop control variable."},{"content":"For more information and examples, see the \"Narrowing Conversions\" section in <bpt id=\"p1\">[</bpt>For Each...Next Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)</ept>.","pos":[141,330],"source":" For more information and examples, see the \"Narrowing Conversions\" section in [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)."}]}]},{"pos":[9448,9479],"content":"Narrowing Conversion Protection","linkify":"Narrowing Conversion Protection","nodes":[{"content":"Narrowing Conversion Protection","pos":[0,31]}]},{"content":"The disadvantage of narrowing conversions is that they can fail at run time.","pos":[9483,9559]},{"content":"For example, if a <ph id=\"ph1\">`String`</ph> variable contains anything other than \"True\" or \"False,\" it cannot be converted to <ph id=\"ph2\">`Boolean`</ph>.","pos":[9560,9680],"source":" For example, if a `String` variable contains anything other than \"True\" or \"False,\" it cannot be converted to `Boolean`."},{"content":"If it contains punctuation characters, conversion to any numeric type fails.","pos":[9681,9757]},{"content":"Unless you know that your <ph id=\"ph1\">`String`</ph> variable always holds values that the destination type can accept, you should not try a conversion.","pos":[9758,9892],"source":" Unless you know that your `String` variable always holds values that the destination type can accept, you should not try a conversion."},{"content":"If you must convert from <ph id=\"ph1\">`String`</ph> to another data type, the safest procedure is to enclose the attempted conversion in the <bpt id=\"p1\">[</bpt>Try...Catch...Finally Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.","pos":[9899,10143],"source":"If you must convert from `String` to another data type, the safest procedure is to enclose the attempted conversion in the [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)."},{"content":"This lets you deal with a run-time failure.","pos":[10144,10187]},{"pos":[10197,10213],"content":"Character Arrays","linkify":"Character Arrays","nodes":[{"content":"Character Arrays","pos":[0,16]}]},{"content":"A single <ph id=\"ph1\">`Char`</ph> and an array of <ph id=\"ph2\">`Char`</ph> elements both widen to <ph id=\"ph3\">`String`</ph>.","pos":[10217,10288],"source":"A single `Char` and an array of `Char` elements both widen to `String`."},{"content":"However, <ph id=\"ph1\">`String`</ph> does not widen to <ph id=\"ph2\">`Char()`</ph>.","pos":[10289,10334],"source":" However, `String` does not widen to `Char()`."},{"content":"To convert a <ph id=\"ph1\">`String`</ph> value to a <ph id=\"ph2\">`Char`</ph> array, you can use the <ph id=\"ph3\">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method of the <ph id=\"ph4\">&lt;xref:System.String?displayProperty=nameWithType&gt;</ph> class.","pos":[10335,10504],"source":" To convert a `String` value to a `Char` array, you can use the <xref:System.String.ToCharArray%2A> method of the <xref:System.String?displayProperty=nameWithType> class."},{"pos":[10514,10532],"content":"Meaningless Values","linkify":"Meaningless Values","nodes":[{"content":"Meaningless Values","pos":[0,18]}]},{"content":"In general, <ph id=\"ph1\">`String`</ph> values are not meaningful in other data types, and conversion is highly artificial and dangerous.","pos":[10536,10654],"source":"In general, `String` values are not meaningful in other data types, and conversion is highly artificial and dangerous."},{"content":"Whenever possible, you should restrict usage of <ph id=\"ph1\">`String`</ph> variables to the character sequences for which they are designed.","pos":[10655,10777],"source":" Whenever possible, you should restrict usage of `String` variables to the character sequences for which they are designed."},{"content":"You should never write code that relies on equivalent values in other types.","pos":[10778,10854]},{"pos":[10863,10871],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10875,10969],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/index.md)</ept>","source":"[Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md)"},{"pos":[10972,11081],"content":"<bpt id=\"p1\">[</bpt>Type Characters<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)</ept>","source":"[Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)"},{"pos":[11084,11225],"content":"<bpt id=\"p1\">[</bpt>Value Types and Reference Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)</ept>","source":"[Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)"},{"pos":[11228,11355],"content":"<bpt id=\"p1\">[</bpt>Type Conversions in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)</ept>","source":"[Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)"},{"pos":[11358,11435],"content":"<bpt id=\"p1\">[</bpt>Data Types<ept id=\"p1\">](../../../../visual-basic/language-reference/data-types/index.md)</ept>","source":"[Data Types](../../../../visual-basic/language-reference/data-types/index.md)"},{"pos":[11438,11549],"content":"<bpt id=\"p1\">[</bpt>Type Conversion Functions<ept id=\"p1\">](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)</ept>","source":"[Type Conversion Functions](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)"},{"pos":[11552,11685],"content":"<bpt id=\"p1\">[</bpt>Efficient Use of Data Types<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)</ept>","source":"[Efficient Use of Data Types](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)"}]}