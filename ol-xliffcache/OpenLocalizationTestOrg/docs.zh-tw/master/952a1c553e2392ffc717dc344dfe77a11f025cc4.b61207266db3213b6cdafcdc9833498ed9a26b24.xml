{"content":"---\ntitle: Interpreting Expressions\ndescription: Learn how to write code to examine the structure of an expression tree.\nms.date: 06/20/2016\nms.assetid: adf73dde-1e52-4df3-9929-2e0670e28e16\n---\n\n# Interpreting Expressions\n\n[Previous -- Executing Expressions](expression-trees-execution.md)\n\nNow, let's write some code to examine the structure of an \n*expression tree*. Every node in an expression tree will be\nan object of a class that is derived from `Expression`.\n\nThat design makes visiting all the nodes in an expression tree\na relatively straight forward recursive operation. The general strategy\nis to start at the root node and determine what kind of node it is.\n\nIf the node type has children, recursively visit the children. At each\nchild node, repeat the process used at the root node: determine the\ntype, and if the type has children, visit each of the children.\n\n## Examining an Expression with No Children\nLet's start by visiting each node in a very simple expression tree.\nHere's the code that creates a constant expression and then\nexamines its properties:\n\n```csharp\nvar constant = Expression.Constant(24, typeof(int));\n\nConsole.WriteLine($\"This is a/an {constant.NodeType} expression type\");\nConsole.WriteLine($\"The type of the constant value is {constant.Type}\");\nConsole.WriteLine($\"The value of the constant value is {constant.Value}\");\n```\n\nThis will print the following:\n\n```\nThis is an Constant expression type\nThe type of the constant value is System.Int32\nThe value of the constant value is 24\n```\n\nNow, let's write the code that would examine this expression and write\nout some important properties about it. Here's that code:\n\n## Examining a simple Addition Expression\n\nLet's start with the addition sample from the\nintroduction to this section.\n\n```csharp\nExpression<Func<int>> sum = () => 1 + 2;\n```\n\n> I'm not using `var` to declare this expression tree, as it is not possible\n> because the right-hand side of the assignment is implicitly typed. To understand\n> this more deeply, read [here](implicitly-typed-lambda-expressions.md).\n\nThe root node is a `LambdaExpression`. In order to get the interesting\ncode on the right hand side of the `=>` operator, you need to find one\nof the children of the `LambdaExpression`. We'll do that with all the\nexpressions in this section. The parent node does help us find the return\ntype of the `LambdaExpression`.\n\nTo examine each node in this expression, we'll need to recursively\nvisit a number of nodes. Here's a simple first implementation:\n\n```csharp\nExpression<Func<int, int, int>> addition = (a, b) => a + b;\n\nConsole.WriteLine($\"This expression is a {addition.NodeType} expression type\");\nConsole.WriteLine($\"The name of the lambda is {((addition.Name == null) ? \"<null>\" : addition.Name)}\");\nConsole.WriteLine($\"The return type is {addition.ReturnType.ToString()}\");\nConsole.WriteLine($\"The expression has {addition.Parameters.Count} arguments. They are:\");\nforeach(var argumentExpression in addition.Parameters)\n{\n    Console.WriteLine($\"\\tParameter Type: {argumentExpression.Type.ToString()}, Name: {argumentExpression.Name}\");\n}\n\nvar additionBody = (BinaryExpression)addition.Body;\nConsole.WriteLine($\"The body is a {additionBody.NodeType} expression\");\nConsole.WriteLine($\"The left side is a {additionBody.Left.NodeType} expression\");\nvar left = (ParameterExpression)additionBody.Left;\nConsole.WriteLine($\"\\tParameter Type: {left.Type.ToString()}, Name: {left.Name}\");\nConsole.WriteLine($\"The right side is a {additionBody.Right.NodeType} expression\");\nvar right= (ParameterExpression)additionBody.Right;\nConsole.WriteLine($\"\\tParameter Type: {right.Type.ToString()}, Name: {right.Name}\");\n```\n\nThis sample prints the following output:\n\n```\nThis expression is a/an Lambda expression type\nThe name of the lambda is <null>\nThe return type is System.Int32\nThe expression has 2 arguments. They are:\n        Parameter Type: System.Int32, Name: a\n        Parameter Type: System.Int32, Name: b\nThe body is a/an Add expression\nThe left side is a Parameter expression\n        Parameter Type: System.Int32, Name: a\nThe right side is a Parameter expression\n        Parameter Type: System.Int32, Name: b\n```\n\nYou'll notice a lot of repetition in the code sample above.\nLet's clean that up and build a more general purpose expression\nnode visitor. That's going to require us to write a recursive\nalgorithm. Any node could be of a type that might have children.\nAny node that has children requires us to visit those children\nand determine what that node is. Here's the cleaned up version\nthat utilizes recursion to visit the addition operations:\n\n```csharp\n// Base Visitor class:\npublic abstract class Visitor\n{\n    private readonly Expression node;\n\n    protected Visitor(Expression node)\n    {\n        this.node = node;\n    }\n\n    public abstract void Visit(string prefix);\n\n    public ExpressionType NodeType => this.node.NodeType;\n    public static Visitor CreateFromExpression(Expression node)\n    {\n        switch(node.NodeType)\n        {\n            case ExpressionType.Constant:\n                return new ConstantVisitor((ConstantExpression)node);\n            case ExpressionType.Lambda:\n                return new LambdaVisitor((LambdaExpression)node);\n            case ExpressionType.Parameter:\n                return new ParameterVisitor((ParameterExpression)node);\n            case ExpressionType.Add:\n                return new BinaryVisitor((BinaryExpression)node);\n            default:\n                Console.Error.WriteLine($\"Node not processed yet: {node.NodeType}\");\n                return default(Visitor);\n        }\n    }\n}\n\n// Lambda Visitor\npublic class LambdaVisitor : Visitor\n{\n    private readonly LambdaExpression node;\n    public LambdaVisitor(LambdaExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($\"{prefix}This expression is a {NodeType} expression type\");\n        Console.WriteLine($\"{prefix}The name of the lambda is {((node.Name == null) ? \"<null>\" : node.Name)}\");\n        Console.WriteLine($\"{prefix}The return type is {node.ReturnType.ToString()}\");\n        Console.WriteLine($\"{prefix}The expression has {node.Parameters.Count} argument(s). They are:\");\n        // Visit each parameter:\n        foreach (var argumentExpression in node.Parameters)\n        {\n            var argumentVisitor = Visitor.CreateFromExpression(argumentExpression);\n            argumentVisitor.Visit(prefix + \"\\t\");\n        }\n        Console.WriteLine($\"{prefix}The expression body is:\");\n        // Visit the body:\n        var bodyVisitor = Visitor.CreateFromExpression(node.Body);\n        bodyVisitor.Visit(prefix + \"\\t\");\n    }\n}\n\n// Binary Expression Visitor:\npublic class BinaryVisitor : Visitor\n{\n    private readonly BinaryExpression node;\n    public BinaryVisitor(BinaryExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($\"{prefix}This binary expression is a {NodeType} expression\");\n        var left = Visitor.CreateFromExpression(node.Left);\n        Console.WriteLine($\"{prefix}The Left argument is:\");\n        left.Visit(prefix + \"\\t\");\n        var right = Visitor.CreateFromExpression(node.Right);\n        Console.WriteLine($\"{prefix}The Right argument is:\");\n        right.Visit(prefix + \"\\t\");\n    }\n}\n\n// Parameter visitor:\npublic class ParameterVisitor : Visitor\n{\n    private readonly ParameterExpression node;\n    public ParameterVisitor(ParameterExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($\"{prefix}This is an {NodeType} expression type\");\n        Console.WriteLine($\"{prefix}Type: {node.Type.ToString()}, Name: {node.Name}, ByRef: {node.IsByRef}\");\n    }\n}\n\n// Constant visitor:\npublic class ConstantVisitor : Visitor\n{\n    private readonly ConstantExpression node;\n    public ConstantVisitor(ConstantExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($\"{prefix}This is an {NodeType} expression type\");\n        Console.WriteLine($\"{prefix}The type of the constant value is {node.Type}\");\n        Console.WriteLine($\"{prefix}The value of the constant value is {node.Value}\");\n    }\n}\n```\n\nThis algorithm is the basis of an algorithm that can visit\nany arbitrary `LambdaExpression`. There are a lot of holes,\nnamely that the code I created only looks for a very small\nsample of the possible sets of expression tree nodes that\nit may encounter. However, you can still learn quite a bit\nfrom what it produces. (The default case in the `Visitor.CreateFromExpression`\nmethod prints a message to the error console when a new node type\nis encountered. That way, you know to add a new expression type.)\n\nWhen you run this visitor on the addition expression shown above, you get the\nfollowing output:\n\n```\nThis expression is a/an Lambda expression type\nThe name of the lambda is <null>\nThe return type is System.Int32\nThe expression has 2 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: a, ByRef: False\n        This is an Parameter expression type\n        Type: System.Int32, Name: b, ByRef: False\nThe expression body is:\n        This binary expression is a Add expression\n        The Left argument is:\n                This is an Parameter expression type\n                Type: System.Int32, Name: a, ByRef: False\n        The Right argument is:\n                This is an Parameter expression type\n                Type: System.Int32, Name: b, ByRef: False\n```\n\nNow that you've built a more general visitor implementation, you\ncan visit and process many more different types of expressions.\n\n## Examining an Addition Expression with Many Levels\n\nLet's try a more complicated example,\nyet still limit the node types to addition only:\n\n```csharp\nExpression<Func<int>> sum = () => 1 + 2 + 3 + 4;\n```\n\nBefore you run this on the visitor algorithm, try a thought\nexercise to work out what the output might be. Remember that\nthe `+` operator is a *binary operator*: it must have two\nchildren, representing the left and right operands. There\nare several possible ways to construct a tree that \ncould be correct:\n\n```csharp\nExpression<Func<int>> sum1 = () => 1 + (2 + (3 + 4));\nExpression<Func<int>> sum2 = () => ((1 + 2) + 3) + 4;\n\nExpression<Func<int>> sum3 = () => (1 + 2) + (3 + 4);\nExpression<Func<int>> sum4 = () => 1 + ((2 + 3) + 4);\nExpression<Func<int>> sum5 = () => (1 + (2 + 3)) + 4;\n```\n\nYou can see the separation into two possible answers to highlight the\nmost promising. The first represents *right associative*\nexpressions. The second represent *left associative* expressions.\nThe advantage of both of those two formats is that the format scales\nto any arbitrary number of addition expressions. \n\nIf you do run this expression through the visitor, you will see this\nthis output, verifying that the simple addition expression is\n*left associative*. \n\nIn order to run this sample, and see the full expression tree, I had to\nmake one change to the source expression tree. When the expression tree\ncontains all constants, the resulting tree simply contains the constant\nvalue of `10`. The compiler performs all the addition and reduces the\nexpression to its simplest form. Simply adding one variable in the expression\nis sufficient to see the original tree:\n\n```csharp\nExpression<Func<int, int>> sum = (a) => 1 + a + 3 + 4;\n```\n\nCreate a visitor for this sum and run the visitor you'll see this output:\n\n```\nThis expression is a/an Lambda expression type\nThe name of the lambda is <null>\nThe return type is System.Int32\nThe expression has 1 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: a, ByRef: False\nThe expression body is:\n        This binary expression is a Add expression\n        The Left argument is:\n                This binary expression is a Add expression\n                The Left argument is:\n                        This binary expression is a Add expression\n                        The Left argument is:\n                                This is an Constant expression type\n                                The type of the constant value is System.Int32\n                                The value of the constant value is 1\n                        The Right argument is:\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: a, ByRef: False\n                The Right argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 3\n        The Right argument is:\n                This is an Constant expression type\n                The type of the constant value is System.Int32\n                The value of the constant value is 4\n```\n\nYou can also run any of the other samples through the visitor code\nand see what tree it represents. Here's an example of the `sum3`\nexpression above (with an additional parameter to prevent the compiler from\ncomputing the constant):\n\n```csharp\nExpression<Func<int, int, int>> sum3 = (a, b) => (1 + a) + (3 + b);\n```\n\nHere's the output from the visitor:\n\n```\nThis expression is a/an Lambda expression type\nThe name of the lambda is <null>\nThe return type is System.Int32\nThe expression has 2 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: a, ByRef: False\n        This is an Parameter expression type\n        Type: System.Int32, Name: b, ByRef: False\nThe expression body is:\n        This binary expression is a Add expression\n        The Left argument is:\n                This binary expression is a Add expression\n                The Left argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 1\n                The Right argument is:\n                        This is an Parameter expression type\n                        Type: System.Int32, Name: a, ByRef: False\n        The Right argument is:\n                This binary expression is a Add expression\n                The Left argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 3\n                The Right argument is:\n                        This is an Parameter expression type\n                        Type: System.Int32, Name: b, ByRef: False\n```\n\nNotice that the parentheses are not part of the output. There are no\nnodes in the expression tree that represent the parentheses in the\ninput expression. The structure of the expression tree contains all the\ninformation necessary to communicate the precedence.\n\n## Extending from this sample\n\nThe sample deals with only the most rudimentary expression trees. The code\nyou've seen in this section only handles constant integers and the binary\n`+` operator. As a final sample, let's update the visitor to handle a more\ncomplicated expression. Let's make it work for this:\n\n```csharp\nExpression<Func<int, int>> factorial = (n) =>\n    n == 0 ? \n    1 : \n    Enumerable.Range(1, n).Aggregate((product, factor) => product * factor);\n```\n\nThis code represents one possible implementation for the\nmathematical *factorial* function. The way I've written this code highlights\ntwo limitations of building expression trees by assigning lambda expressions\nto Expressions. First, statement lambdas are not allowed. That means I can't use\nloops, blocks, if / else statements, and other control structures common in C#. I'm\nlimited to using expressions. Second, I can't recursively call the same expression.\nI could if it were already a delegate, but I can't call it in its expression tree \nform. In the section on [building expression trees](expression-trees-building.md)\nyou'll learn techniques to overcome these limitations.\n\nIn this expression, you'll encounter nodes of all these types:\n1. Equal (binary expression)\n2. Multiply (binary expression)\n3. Conditional (the ? : expression)\n4. Method Call Expression (calling `Range()` and `Aggregate()`)\n\nOne way to modify the visitor algorithm is to keep executing it, and write\nthe node type every time you reach your `default` clause. After a few\niterations, you'll have seen each of the potential nodes. Then, you have\nall you need. The result would be something like this:\n\n```csharp\npublic static Visitor CreateFromExpression(Expression node)\n{\n    switch(node.NodeType)\n    {\n        case ExpressionType.Constant:\n            return new ConstantVisitor((ConstantExpression)node);\n        case ExpressionType.Lambda:\n            return new LambdaVisitor((LambdaExpression)node);\n        case ExpressionType.Parameter:\n            return new ParameterVisitor((ParameterExpression)node);\n        case ExpressionType.Add:\n        case ExpressionType.Equal:\n        case ExpressionType.Multiply:\n            return new BinaryVisitor((BinaryExpression)node);\n        case ExpressionType.Conditional:\n            return new ConditionalVisitor((ConditionalExpression)node);\n        case ExpressionType.Call:\n            return new MethodCallVisitor((MethodCallExpression)node);\n        default:\n            Console.Error.WriteLine($\"Node not processed yet: {node.NodeType}\");\n            return default(Visitor);\n    }\n}\n```\n\nThe ConditionalVisitor and MethodCallVisitor process those two nodes:\n\n```csharp\npublic class ConditionalVisitor : Visitor\n{\n    private readonly ConditionalExpression node;\n    public ConditionalVisitor(ConditionalExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($\"{prefix}This expression is a {NodeType} expression\");\n        var testVisitor = Visitor.CreateFromExpression(node.Test);\n        Console.WriteLine($\"{prefix}The Test for this expression is:\");\n        testVisitor.Visit(prefix + \"\\t\");\n        var trueVisitor = Visitor.CreateFromExpression(node.IfTrue);\n        Console.WriteLine($\"{prefix}The True clause for this expression is:\");\n        trueVisitor.Visit(prefix + \"\\t\");\n        var falseVisitor = Visitor.CreateFromExpression(node.IfFalse);\n        Console.WriteLine($\"{prefix}The False clause for this expression is:\");\n        falseVisitor.Visit(prefix + \"\\t\");\n    }\n}\n\npublic class MethodCallVisitor : Visitor\n{\n    private readonly MethodCallExpression node;\n    public MethodCallVisitor(MethodCallExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($\"{prefix}This expression is a {NodeType} expression\");\n        if (node.Object == null)\n            Console.WriteLine($\"{prefix}This is a static method call\");\n        else\n        {\n            Console.WriteLine($\"{prefix}The receiver (this) is:\");\n            var receiverVisitor = Visitor.CreateFromExpression(node.Object);\n            receiverVisitor.Visit(prefix + \"\\t\");\n        }\n\n        var methodInfo = node.Method;\n        Console.WriteLine($\"{prefix}The method name is {methodInfo.DeclaringType}.{methodInfo.Name}\");\n        // There is more here, like generic arguments, and so on.\n        Console.WriteLine($\"{prefix}The Arguments are:\");\n        foreach(var arg in node.Arguments)\n        {\n            var argVisitor = Visitor.CreateFromExpression(arg);\n            argVisitor.Visit(prefix + \"\\t\");\n        }\n    }\n}\n```\n\nAnd the output for the expression tree would be:\n\n```\nThis expression is a/an Lambda expression type\nThe name of the lambda is <null>\nThe return type is System.Int32\nThe expression has 1 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: n, ByRef: False\nThe expression body is:\n        This expression is a Conditional expression\n        The Test for this expression is:\n                This binary expression is a Equal expression\n                The Left argument is:\n                        This is an Parameter expression type\n                        Type: System.Int32, Name: n, ByRef: False\n                The Right argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 0\n        The True clause for this expression is:\n                This is an Constant expression type\n                The type of the constant value is System.Int32\n                The value of the constant value is 1\n        The False clause for this expression is:\n                This expression is a Call expression\n                This is a static method call\n                The method name is System.Linq.Enumerable.Aggregate\n                The Arguments are:\n                        This expression is a Call expression\n                        This is a static method call\n                        The method name is System.Linq.Enumerable.Range\n                        The Arguments are:\n                                This is an Constant expression type\n                                The type of the constant value is System.Int32\n                                The value of the constant value is 1\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: n, ByRef: False\n                        This expression is a Lambda expression type\n                        The name of the lambda is <null>\n                        The return type is System.Int32\n                        The expression has 2 arguments. They are:\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: product, ByRef: False\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: factor, ByRef: False\n                        The expression body is:\n                                This binary expression is a Multiply expression\n                                The Left argument is:\n                                        This is an Parameter expression type\n                                        Type: System.Int32, Name: product, ByRef: False\n                                The Right argument is:\n                                        This is an Parameter expression type\n                                        Type: System.Int32, Name: factor, ByRef: False\n```\n\n## Extending the Sample Library\n\nThe samples in this section show the core techniques to visit and\nexamine nodes in an expression tree. I glossed over many actions\nyou might need in order to concentrate on the core tasks of\nvisiting and accessing nodes in an expression tree. \n\nFirst, the visitors only handle constants\nthat are integers. Constant values could be any other numeric type,\nand the C# language supports conversions and promotions between those\ntypes. A more robust version of this code would mirror all those\ncapabilities.\n\nEven the last example recognizes a subset of the possible node types.\nYou can still feed it many expressions that will cause it to fail.\nA full implementation is included in the .NET Standard \nunder the name <xref:System.Linq.Expressions.ExpressionVisitor>\nand can handle all the possible node types.\n\nFinally, the library I used in this article was built for demonstration\nand learning. It's not optimized. I wrote it to make the structures\nused very clear, and to highlight the techniques used to visit\nthe nodes and analyze what's there. A production implementation would\npay more attention to performance than I have.\n\nEven with those limitations, you should be well on your way to writing\nalgorithms that read and understand expression trees.\n\n[Next -- Building Expressions](expression-trees-building.md)\n","nodes":[{"pos":[4,189],"embed":true,"restype":"x-metadata","content":"title: Interpreting Expressions\ndescription: Learn how to write code to examine the structure of an expression tree.\nms.date: 06/20/2016\nms.assetid: adf73dde-1e52-4df3-9929-2e0670e28e16","nodes":[{"content":"Interpreting Expressions","nodes":[{"pos":[0,24],"content":"Interpreting Expressions","nodes":[{"content":"Interpreting Expressions","pos":[0,24]}]}],"path":["title"],"nosxs":false},{"content":"Learn how to write code to examine the structure of an expression tree.","nodes":[{"pos":[0,71],"content":"Learn how to write code to examine the structure of an expression tree.","nodes":[{"content":"Learn how to write code to examine the structure of an expression tree.","pos":[0,71]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[197,221],"content":"Interpreting Expressions","linkify":"Interpreting Expressions","nodes":[{"content":"Interpreting Expressions","pos":[0,24]}]},{"pos":[223,289],"content":"<bpt id=\"p1\">[</bpt>Previous -- Executing Expressions<ept id=\"p1\">](expression-trees-execution.md)</ept>","source":"[Previous -- Executing Expressions](expression-trees-execution.md)"},{"content":"Now, let's write some code to examine the structure of an <bpt id=\"p1\">*</bpt>expression tree<ept id=\"p1\">*</ept>.","pos":[291,368],"source":"Now, let's write some code to examine the structure of an \n*expression tree*."},{"content":"Every node in an expression tree will be an object of a class that is derived from <ph id=\"ph1\">`Expression`</ph>.","pos":[369,465],"source":" Every node in an expression tree will be\nan object of a class that is derived from `Expression`."},{"content":"That design makes visiting all the nodes in an expression tree a relatively straight forward recursive operation.","pos":[467,580],"source":"That design makes visiting all the nodes in an expression tree\na relatively straight forward recursive operation."},{"content":"The general strategy is to start at the root node and determine what kind of node it is.","pos":[581,669],"source":" The general strategy\nis to start at the root node and determine what kind of node it is."},{"content":"If the node type has children, recursively visit the children.","pos":[671,733]},{"content":"At each child node, repeat the process used at the root node: determine the type, and if the type has children, visit each of the children.","pos":[734,873],"source":" At each\nchild node, repeat the process used at the root node: determine the\ntype, and if the type has children, visit each of the children."},{"pos":[878,918],"content":"Examining an Expression with No Children","linkify":"Examining an Expression with No Children","nodes":[{"content":"Examining an Expression with No Children","pos":[0,40]}]},{"content":"Let's start by visiting each node in a very simple expression tree.","pos":[919,986]},{"content":"Here's the code that creates a constant expression and then examines its properties:","pos":[987,1071],"source":"\nHere's the code that creates a constant expression and then\nexamines its properties:"},{"content":"This will print the following:","pos":[1362,1392]},{"content":"Now, let's write the code that would examine this expression and write out some important properties about it.","pos":[1524,1634],"source":"Now, let's write the code that would examine this expression and write\nout some important properties about it."},{"content":"Here's that code:","pos":[1635,1652]},{"pos":[1657,1695],"content":"Examining a simple Addition Expression","linkify":"Examining a simple Addition Expression","nodes":[{"content":"Examining a simple Addition Expression","pos":[0,38]}]},{"pos":[1697,1772],"content":"Let's start with the addition sample from the introduction to this section.","source":"Let's start with the addition sample from the\nintroduction to this section."},{"pos":[1832,2062],"content":"I'm not using `var` to declare this expression tree, as it is not possible\nbecause the right-hand side of the assignment is implicitly typed. To understand\nthis more deeply, read [here](implicitly-typed-lambda-expressions.md).","leadings":["","> ","> "],"nodes":[{"content":"I'm not using <ph id=\"ph1\">`var`</ph> to declare this expression tree, as it is not possible because the right-hand side of the assignment is implicitly typed.","pos":[0,141],"source":"I'm not using `var` to declare this expression tree, as it is not possible\nbecause the right-hand side of the assignment is implicitly typed."},{"content":"To understand this more deeply, read <bpt id=\"p1\">[</bpt>here<ept id=\"p1\">](implicitly-typed-lambda-expressions.md)</ept>.","pos":[142,226],"source":" To understand\nthis more deeply, read [here](implicitly-typed-lambda-expressions.md)."}]},{"content":"The root node is a <ph id=\"ph1\">`LambdaExpression`</ph>.","pos":[2064,2102],"source":"The root node is a `LambdaExpression`."},{"content":"In order to get the interesting code on the right hand side of the <ph id=\"ph1\">`=&gt;`</ph> operator, you need to find one of the children of the <ph id=\"ph2\">`LambdaExpression`</ph>.","pos":[2103,2248],"source":" In order to get the interesting\ncode on the right hand side of the `=>` operator, you need to find one\nof the children of the `LambdaExpression`."},{"content":"We'll do that with all the expressions in this section.","pos":[2249,2304],"source":" We'll do that with all the\nexpressions in this section."},{"content":"The parent node does help us find the return type of the <ph id=\"ph1\">`LambdaExpression`</ph>.","pos":[2305,2381],"source":" The parent node does help us find the return\ntype of the `LambdaExpression`."},{"content":"To examine each node in this expression, we'll need to recursively visit a number of nodes.","pos":[2383,2474],"source":"To examine each node in this expression, we'll need to recursively\nvisit a number of nodes."},{"content":"Here's a simple first implementation:","pos":[2475,2512]},{"content":"This sample prints the following output:","pos":[3676,3716]},{"content":"You'll notice a lot of repetition in the code sample above.","pos":[4178,4237]},{"content":"Let's clean that up and build a more general purpose expression node visitor.","pos":[4238,4315],"source":"\nLet's clean that up and build a more general purpose expression\nnode visitor."},{"content":"That's going to require us to write a recursive algorithm.","pos":[4316,4374],"source":" That's going to require us to write a recursive\nalgorithm."},{"content":"Any node could be of a type that might have children.","pos":[4375,4428]},{"content":"Any node that has children requires us to visit those children and determine what that node is.","pos":[4429,4524],"source":"\nAny node that has children requires us to visit those children\nand determine what that node is."},{"content":"Here's the cleaned up version that utilizes recursion to visit the addition operations:","pos":[4525,4612],"source":" Here's the cleaned up version\nthat utilizes recursion to visit the addition operations:"},{"content":"This algorithm is the basis of an algorithm that can visit any arbitrary <ph id=\"ph1\">`LambdaExpression`</ph>.","pos":[8383,8475],"source":"This algorithm is the basis of an algorithm that can visit\nany arbitrary `LambdaExpression`."},{"content":"There are a lot of holes, namely that the code I created only looks for a very small sample of the possible sets of expression tree nodes that it may encounter.","pos":[8476,8636],"source":" There are a lot of holes,\nnamely that the code I created only looks for a very small\nsample of the possible sets of expression tree nodes that\nit may encounter."},{"content":"However, you can still learn quite a bit from what it produces.","pos":[8637,8700],"source":" However, you can still learn quite a bit\nfrom what it produces."},{"content":"(The default case in the <ph id=\"ph1\">`Visitor.CreateFromExpression`</ph> method prints a message to the error console when a new node type is encountered.","pos":[8701,8838],"source":" (The default case in the `Visitor.CreateFromExpression`\nmethod prints a message to the error console when a new node type\nis encountered."},{"content":"That way, you know to add a new expression type.)","pos":[8839,8888]},{"pos":[8890,8985],"content":"When you run this visitor on the addition expression shown above, you get the following output:","source":"When you run this visitor on the addition expression shown above, you get the\nfollowing output:"},{"pos":[9700,9828],"content":"Now that you've built a more general visitor implementation, you can visit and process many more different types of expressions.","source":"Now that you've built a more general visitor implementation, you\ncan visit and process many more different types of expressions."},{"pos":[9833,9882],"content":"Examining an Addition Expression with Many Levels","linkify":"Examining an Addition Expression with Many Levels","nodes":[{"content":"Examining an Addition Expression with Many Levels","pos":[0,49]}]},{"pos":[9884,9970],"content":"Let's try a more complicated example, yet still limit the node types to addition only:","source":"Let's try a more complicated example,\nyet still limit the node types to addition only:"},{"content":"Before you run this on the visitor algorithm, try a thought exercise to work out what the output might be.","pos":[10036,10142],"source":"Before you run this on the visitor algorithm, try a thought\nexercise to work out what the output might be."},{"content":"Remember that the <ph id=\"ph1\">`+`</ph> operator is a <bpt id=\"p1\">*</bpt>binary operator<ept id=\"p1\">*</ept>: it must have two children, representing the left and right operands.","pos":[10143,10266],"source":" Remember that\nthe `+` operator is a *binary operator*: it must have two\nchildren, representing the left and right operands."},{"content":"There are several possible ways to construct a tree that could be correct:","pos":[10267,10342],"source":" There\nare several possible ways to construct a tree that \ncould be correct:"},{"content":"You can see the separation into two possible answers to highlight the most promising.","pos":[10630,10715],"source":"You can see the separation into two possible answers to highlight the\nmost promising."},{"content":"The first represents <bpt id=\"p1\">*</bpt>right associative<ept id=\"p1\">*</ept> expressions.","pos":[10716,10769],"source":" The first represents *right associative*\nexpressions."},{"content":"The second represent <bpt id=\"p1\">*</bpt>left associative<ept id=\"p1\">*</ept> expressions.","pos":[10770,10822],"source":" The second represent *left associative* expressions."},{"content":"The advantage of both of those two formats is that the format scales to any arbitrary number of addition expressions.","pos":[10823,10940],"source":"\nThe advantage of both of those two formats is that the format scales\nto any arbitrary number of addition expressions."},{"pos":[10943,11093],"content":"If you do run this expression through the visitor, you will see this this output, verifying that the simple addition expression is <bpt id=\"p1\">*</bpt>left associative<ept id=\"p1\">*</ept>.","source":"If you do run this expression through the visitor, you will see this\nthis output, verifying that the simple addition expression is\n*left associative*."},{"content":"In order to run this sample, and see the full expression tree, I had to make one change to the source expression tree.","pos":[11096,11214],"source":"In order to run this sample, and see the full expression tree, I had to\nmake one change to the source expression tree."},{"content":"When the expression tree contains all constants, the resulting tree simply contains the constant value of <ph id=\"ph1\">`10`</ph>.","pos":[11215,11326],"source":" When the expression tree\ncontains all constants, the resulting tree simply contains the constant\nvalue of `10`."},{"content":"The compiler performs all the addition and reduces the expression to its simplest form.","pos":[11327,11414],"source":" The compiler performs all the addition and reduces the\nexpression to its simplest form."},{"content":"Simply adding one variable in the expression is sufficient to see the original tree:","pos":[11415,11499],"source":" Simply adding one variable in the expression\nis sufficient to see the original tree:"},{"content":"Create a visitor for this sum and run the visitor you'll see this output:","pos":[11571,11644]},{"content":"You can also run any of the other samples through the visitor code and see what tree it represents.","pos":[13057,13156],"source":"You can also run any of the other samples through the visitor code\nand see what tree it represents."},{"content":"Here's an example of the <ph id=\"ph1\">`sum3`</ph> expression above (with an additional parameter to prevent the compiler from computing the constant):","pos":[13157,13289],"source":" Here's an example of the `sum3`\nexpression above (with an additional parameter to prevent the compiler from\ncomputing the constant):"},{"content":"Here's the output from the visitor:","pos":[13374,13409]},{"content":"Notice that the parentheses are not part of the output.","pos":[14812,14867]},{"content":"There are no nodes in the expression tree that represent the parentheses in the input expression.","pos":[14868,14965],"source":" There are no\nnodes in the expression tree that represent the parentheses in the\ninput expression."},{"content":"The structure of the expression tree contains all the information necessary to communicate the precedence.","pos":[14966,15072],"source":" The structure of the expression tree contains all the\ninformation necessary to communicate the precedence."},{"pos":[15077,15103],"content":"Extending from this sample","linkify":"Extending from this sample","nodes":[{"content":"Extending from this sample","pos":[0,26]}]},{"content":"The sample deals with only the most rudimentary expression trees.","pos":[15105,15170]},{"content":"The code you've seen in this section only handles constant integers and the binary <ph id=\"ph1\">`+`</ph> operator.","pos":[15171,15267],"source":" The code\nyou've seen in this section only handles constant integers and the binary\n`+` operator."},{"content":"As a final sample, let's update the visitor to handle a more complicated expression.","pos":[15268,15352],"source":" As a final sample, let's update the visitor to handle a more\ncomplicated expression."},{"content":"Let's make it work for this:","pos":[15353,15381]},{"content":"This code represents one possible implementation for the mathematical <bpt id=\"p1\">*</bpt>factorial<ept id=\"p1\">*</ept> function.","pos":[15544,15635],"source":"This code represents one possible implementation for the\nmathematical *factorial* function."},{"content":"The way I've written this code highlights two limitations of building expression trees by assigning lambda expressions to Expressions.","pos":[15636,15770],"source":" The way I've written this code highlights\ntwo limitations of building expression trees by assigning lambda expressions\nto Expressions."},{"content":"First, statement lambdas are not allowed.","pos":[15771,15812]},{"content":"That means I can't use loops, blocks, if / else statements, and other control structures common in C#.","pos":[15813,15915],"source":" That means I can't use\nloops, blocks, if / else statements, and other control structures common in C#."},{"content":"I'm limited to using expressions.","pos":[15916,15949],"source":" I'm\nlimited to using expressions."},{"content":"Second, I can't recursively call the same expression.","pos":[15950,16003]},{"content":"I could if it were already a delegate, but I can't call it in its expression tree form.","pos":[16004,16092],"source":"\nI could if it were already a delegate, but I can't call it in its expression tree \nform."},{"content":"In the section on <bpt id=\"p1\">[</bpt>building expression trees<ept id=\"p1\">](expression-trees-building.md)</ept> you'll learn techniques to overcome these limitations.","pos":[16093,16223],"source":" In the section on [building expression trees](expression-trees-building.md)\nyou'll learn techniques to overcome these limitations."},{"content":"In this expression, you'll encounter nodes of all these types:","pos":[16225,16287]},{"content":"Equal (binary expression)","pos":[16291,16316]},{"content":"Multiply (binary expression)","pos":[16320,16348]},{"content":"Conditional (the ?","pos":[16352,16370]},{"content":": expression)","pos":[16371,16384]},{"pos":[16388,16448],"content":"Method Call Expression (calling <ph id=\"ph1\">`Range()`</ph> and <ph id=\"ph2\">`Aggregate()`</ph>)","source":"Method Call Expression (calling `Range()` and `Aggregate()`)"},{"content":"One way to modify the visitor algorithm is to keep executing it, and write the node type every time you reach your <ph id=\"ph1\">`default`</ph> clause.","pos":[16450,16582],"source":"One way to modify the visitor algorithm is to keep executing it, and write\nthe node type every time you reach your `default` clause."},{"content":"After a few iterations, you'll have seen each of the potential nodes.","pos":[16583,16652],"source":" After a few\niterations, you'll have seen each of the potential nodes."},{"content":"Then, you have all you need.","pos":[16653,16681],"source":" Then, you have\nall you need."},{"content":"The result would be something like this:","pos":[16682,16722]},{"content":"The ConditionalVisitor and MethodCallVisitor process those two nodes:","pos":[17670,17739]},{"content":"And the output for the expression tree would be:","pos":[19778,19826]},{"pos":[22829,22857],"content":"Extending the Sample Library","linkify":"Extending the Sample Library","nodes":[{"content":"Extending the Sample Library","pos":[0,28]}]},{"content":"The samples in this section show the core techniques to visit and examine nodes in an expression tree.","pos":[22859,22961],"source":"The samples in this section show the core techniques to visit and\nexamine nodes in an expression tree."},{"content":"I glossed over many actions you might need in order to concentrate on the core tasks of visiting and accessing nodes in an expression tree.","pos":[22962,23101],"source":" I glossed over many actions\nyou might need in order to concentrate on the core tasks of\nvisiting and accessing nodes in an expression tree."},{"content":"First, the visitors only handle constants that are integers.","pos":[23104,23164],"source":"First, the visitors only handle constants\nthat are integers."},{"content":"Constant values could be any other numeric type, and the C# language supports conversions and promotions between those types.","pos":[23165,23290],"source":" Constant values could be any other numeric type,\nand the C# language supports conversions and promotions between those\ntypes."},{"content":"A more robust version of this code would mirror all those capabilities.","pos":[23291,23362],"source":" A more robust version of this code would mirror all those\ncapabilities."},{"content":"Even the last example recognizes a subset of the possible node types.","pos":[23364,23433]},{"content":"You can still feed it many expressions that will cause it to fail.","pos":[23434,23500],"source":"\nYou can still feed it many expressions that will cause it to fail."},{"content":"A full implementation is included in the .NET Standard under the name <ph id=\"ph1\">&lt;xref:System.Linq.Expressions.ExpressionVisitor&gt;</ph> and can handle all the possible node types.","pos":[23501,23664],"source":"\nA full implementation is included in the .NET Standard \nunder the name <xref:System.Linq.Expressions.ExpressionVisitor>\nand can handle all the possible node types."},{"content":"Finally, the library I used in this article was built for demonstration and learning.","pos":[23666,23751],"source":"Finally, the library I used in this article was built for demonstration\nand learning."},{"content":"It's not optimized.","pos":[23752,23771]},{"content":"I wrote it to make the structures used very clear, and to highlight the techniques used to visit the nodes and analyze what's there.","pos":[23772,23904],"source":" I wrote it to make the structures\nused very clear, and to highlight the techniques used to visit\nthe nodes and analyze what's there."},{"content":"A production implementation would pay more attention to performance than I have.","pos":[23905,23985],"source":" A production implementation would\npay more attention to performance than I have."},{"pos":[23987,24111],"content":"Even with those limitations, you should be well on your way to writing algorithms that read and understand expression trees.","source":"Even with those limitations, you should be well on your way to writing\nalgorithms that read and understand expression trees."},{"pos":[24113,24173],"content":"<bpt id=\"p1\">[</bpt>Next -- Building Expressions<ept id=\"p1\">](expression-trees-building.md)</ept>","source":"[Next -- Building Expressions](expression-trees-building.md)"}]}