{"content":"---\ntitle: \"Tutorial: Write your first analyzer and code fix\"\ndescription: This tutorial provides step-by-step instructions to build an analyzer and code fix using the .NET Compiler SDK (Roslyn APIs).\nms.date: 08/01/2018\nms.custom: mvc\n---\n\n# Tutorial: Write your first analyzer and code fix\n\nThe .NET Compiler Platform SDK provides the tools you need to create custom warnings that target C# or Visual Basic code. Your **analyzer** contains code that recognizes violations of your rule. Your **code fix** contains the code that fixes the violation. The rules you implement can be anything from code structure to coding style to naming conventions and more. The .NET Compiler Platform provides the framework for running analysis as developers are writing code, and all the Visual Studio UI features for fixing code: showing squiggles in the editor, populating the Visual Studio Error List, creating the \"light bulb\" suggestions and showing the rich preview of the suggested fixes.\n\nIn this tutorial, you'll explore the creation of an **analyzer** and an accompanying **code fix** using the Roslyn APIs. An analyzer is a way to perform source code analysis and report a problem to the user. Optionally, an analyzer can also provide a code fix that represents a modification to the user's source code. This tutorial creates an analyzer that finds local variable declarations that could be declared using the `const` modifier but are not. The accompanying code fix modifies those declarations to add the `const` modifier.\n\n## Prerequisites\n\n* [Visual Studio 2017](https://www.visualstudio.com/downloads)\n\nYou'll need to install the **.NET Compiler Platform SDK**:\n\n[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]\n\nThere are several steps to creating and validating your analyzer:\n\n1. Create the solution.\n1. Register the analyzer name and description.\n1. Report analyzer warnings and recommendations.\n1. Implement the code fix to accept recommendations.\n1. Improve the analysis through unit tests.\n\n## Explore the analyzer template\n\nYour analyzer reports to the user any local variable declarations that can be converted to local constants. For example, consider the following code:\n\n```csharp\nint x = 0;\nConsole.WriteLine(x);\n```\n\nIn the code above, `x` is assigned a constant value and is never modified. It can be declared using the `const` modifier:\n\n```csharp\nconst int x = 0;\nConsole.WriteLine(x);\n```\n\nThe analysis to determine whether a variable can be made constant is involved, requiring syntactic analysis, constant analysis of the initializer expression and dataflow analysis to ensure that the variable is never written to. The .NET Compiler Platform provides APIs that make it easier to perform this analysis. The first step is to create a new C# **Analyzer with code fix** project.\n\n* In Visual Studio, choose **File > New > Project...** to display the New Project dialog.\n* Under **Visual C# > Extensibility**, choose **Analyzer with code fix (.NET Standard)**.\n* Name your project \"**MakeConst**\" and click OK.\n\nThe analyzer with code fix template creates three projects: one contains the analyzer and code fix, the second is a unit test project, and the third is the VSIX project. The default startup project is the VSIX project. Press **F5** to start the VSIX project. This starts a second instance of Visual Studio that has loaded your new analyzer.\n\n> [!TIP]\n> When you run your analyzer, you start a second copy of Visual Studio. This second copy uses a different registry hive to store settings. That enables you to differentiate the visual settings in the two copies of Visual Studio. You can pick a different theme for the experimental run of Visual Studio. In addition, don't roam your settings or login to your Visual Studio account using the experimental run of Visual Studio. That keeps the settings different.\n\nIn the second Visual Studio instance that you just started, create a new C# Console Application project (either .NET Core or .NET Framework project will work -- analyzers work at the source level.) Hover over the token with a wavy underline, and the warning text provided by an analyzer appears.\n\nThe template creates an analyzer that reports a warning on each type declaration where the type name contains lowercase letters, as shown in the following figure:\n\n![Analyzer reporting warning](media/how-to-write-csharp-analyzer-code-fix/report-warning.png)\n\nThe template also provides a code fix that changes any type name containing lower case characters to all upper case. You can click on the light bulb displayed with the warning to see the suggested changes. Accepting the suggested changes updates the type name and all references to that type in the solution. Now that you've seen the initial analyzer in action, close the second Visual Studio instance and return to your analyzer project.\n\nYou don't have to start a second copy of Visual Studio and create new code to test every change in your analyzer. The template also creates a unit test project for you. That project contains two tests. `TestMethod1` shows the typical format of a test that analyzes code without triggering a diagnostic. `TestMethod2` shows the format of a test that triggers a diagnostic, and then applies a suggested code fix. As you build your analyzer and code fix, you'll write tests for different code structures to verify your work. Unit tests for analyzers are much quicker than testing them interactively with Visual Studio.\n\n> [!TIP]\n> Analyzer unit tests are a great tool when you know what code constructs should and shouldn't trigger your analyzer. Loading your analyzer in another copy of Visual Studio is a great tool to explore and find constructs you may not have thought about yet.\n\n## Create analyzer registrations\n\nThe template creates the initial `DiagnosticAnalyzer` class, in the **MakeConstAnalyzer.cs** file. This initial analyzer shows two important properties of every analyzer.\n\n* Every diagnostic analyzer must provide a `[DiagnosticAnalyzer]` attribute that describes the language it operates on.\n* Every diagnostic analyzer must derive from the <xref:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> class.\n\nThe template also shows the basic features that are part of any analyzer:\n\n1. Register actions. The actions represent code changes that should trigger your analyzer to examine code for violations. When Visual Studio detects code edits that match a registered action, it calls your analyzer's registered method.\n1. Create diagnostics. When your analyzer detects a violation, it creates a diagnostic object that Visual Studio uses to notify the user of the violation.\n\nYou register actions in your override of <xref:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)?displayProperty=nameWithType> method. In this tutorial, you'll visit **syntax nodes** looking for local declarations, and see which of those have constant values. If a declaration could be constant, your analyzer will create and report a diagnostic.\n\nThe first step is to update the registration constants and `Initialize` method so these constants indicate your \"Make Const\" analyzer. Most of the string constants are defined in the string resource file. You should follow that practice for easier localization. Open the **Resources.resx** file for the **MakeConst** analyzer project. This displays the resource editor. Update the string resources as follows:\n\n* Change `AnalyzerTitle` to \"Variable can be made constant\".\n* Change `AnalyzerMessageFormat` to \"Can be made constant\".\n* Change `AnalyzerDescription` to \"Make Constant\".\n\nAlso, change the **Access Modifier** drop-down to `public`. That makes it easier to use these constants in unit tests. When you have finished, the resource editor should appear as follow figure shows:\n\n![Update string resources](media/how-to-write-csharp-analyzer-code-fix/update-string-resources.png)\n\nThe remaining changes are in the analyzer file. Open **MakeConstAnalyzer.cs** in Visual Studio. Change the registered action from one that acts on symbols to one that acts on syntax. In the `MakeConstAnalyzerAnalyzer.Initialize` method, find the line that registers the action on symbols:\n\n```csharp\ncontext.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n```\n\nReplace it with the following line:\n\n[!code-csharp[Register the node action](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstAnalyzer.cs#RegisterNodeAction \"Register a node action\")]\n\nAfter that change, you can delete the `AnalyzeSymbol` method. This analyzer examines <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LocalDeclarationStatement?displayProperty=nameWithType>, not <xref:Microsoft.CodeAnalysis.SymbolKind.NamedType?displayProperty=nameWithType> statements. Notice that `AnalyzeNode` has red squiggles under it. The code you just added references an `AnalyzeNode` method that hasn't been declared. Declare that method using the following code:\n\n```csharp\nprivate void AnalyzeNode(SyntaxNodeAnalysisContext context)\n{\n}\n```\n\nChange the `Category` to \"Usage\" in **MakeConstAnalyzer.cs** as shown in the following code:\n\n```csharp\nprivate const string Category = \"Usage\";\n```\n\n## Find local declarations that could be const\n\nIt's time to write the first version of the `AnalyzeNode` method. It should look for a single local declaration that could be `const` but is not, like the following code:\n\n```csharp\nint x = 0;\nConsole.WriteLine(x);\n```\n\nThe first step is to find local declarations. Add the following code to `AnalyzeNode` in **MakeConstAnalyzer.cs**:\n\n```csharp\nvar localDeclaration = (LocalDeclarationStatementSyntax)context.Node;\n```\n\nThis cast always succeeds because your analyzer registered for changes to local declarations, and only local declarations. No other node type triggers a call to your `AnalyzeNode` method. Next, check the declaration for any `const` modifiers. If you find them, return immediately. The following code looks for any `const` modifiers on the local declaration:\n\n```csharp\n// make sure the declaration isn't already const:\nif (localDeclaration.Modifiers.Any(SyntaxKind.ConstKeyword))\n{\n    return;\n}\n```\n\nFinally, you need to check that the variable could be `const`. That means making sure it is never assigned after it is initialized.\n\nYou'll perform some semantic analysis using the <xref:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext>. You use the `context` argument to determine whether the local variable declaration can be made `const`. A <xref:Microsoft.CodeAnalysis.SemanticModel?displayProperty=nameWithType> represents of all semantic information in a single source file. You can learn more in the article that covers [semantic models](../work-with-semantics.md). You'll use the <xref:Microsoft.CodeAnalysis.SemanticModel?displayProperty=nameWithType> to perform data flow analysis on the local declaration statement. Then, you use the results of this data flow analysis to ensure that the local variable isn't written with a new value anywhere else. Call the <xref:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol%2A> extension method to retrieve the <xref:Microsoft.CodeAnalysis.ILocalSymbol> for the variable and check that it isn't contained with the <xref:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenOutside%2A?displayProperty=nameWithType> collection of the data flow analysis. Add the following code to the end of the `AnalyzeNode` method:\n\n```csharp\n// Perform data flow analysis on the local declaration.\nvar dataFlowAnalysis = context.SemanticModel.AnalyzeDataFlow(localDeclaration);\n\n// Retrieve the local symbol for each variable in the local declaration\n// and ensure that it is not written outside of the data flow analysis region.\nvar variable = localDeclaration.Declaration.Variables.Single();\nvar variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable);\nif (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))\n{\n    return;\n}\n```\n\nThe code just added ensures that the variable isn't modified, and can therefore be made `const`. It's time to raise the diagnostic. Add the following code as the last line in `AnalyzeNode`:\n\n```csharp\ncontext.ReportDiagnostic(Diagnostic.Create(Rule, context.Node.GetLocation()));\n```\n\nYou can check your progress by pressing **F5** to run your analyzer. You can load the console application you created earlier and then add the following test code:\n\n```csharp\nint x = 0;\nConsole.WriteLine(x);\n```\n\nThe light bulb should appear, and your analyzer should report a diagnostic. However, the light bulb still uses the template generated code fix, and tells you it can be made upper case. The next section explains how to write the code fix.\n\n## Write the code fix\n\nAn analyzer can provide one or more code fixes. A code fix defines an edit that addresses the reported issue. For the analyzer that you created, you can provide a code fix that inserts the const keyword:\n\n```csharp\nconst int x = 0;\nConsole.WriteLine(x);\n```\n\nThe user chooses it from the light bulb UI in the editor and Visual Studio changes the code.\n\nOpen the **MakeConstCodeFixProvider.cs** file added by the template.  This code fix is already wired up to the Diagnostic ID produced by your diagnostic analyzer, but it doesn't yet implement the right code transform. First you should remove some of the template code. Change the title string to \"Make constant\":\n\n[!code-csharp[Update the CodeFix title](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#CodeFixTitle \"Update the CodeFix title\")]\n\nNext, delete the `MakeUppercaseAsync` method. It no longer applies.\n\nAll code fixes derive from <xref:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider>. They all override <xref:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)?displayProperty=nameWithType> to report available code fixes. In `RegisterCodeFixesAsync`, change the ancestor node type you're searching for to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> to match the diagnostic:\n\n[!code-csharp[Find local declaration node](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#FindDeclarationNode  \"Find the local declaration node that raised the diagnostic\")]\n\nNext, change the last line to register a code fix. Your fix will create a new document that results from adding the `const` modifier to an existing declaration:\n\n[!code-csharp[Register the new code fix](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#RegisterCodeFix  \"Register the new code fix\")]\n\nYou'll notice red squiggles in the code you just added on the symbol `MakeConstAsync`. Add a declaration for `MakeConstAsync` like the following code:\n\n```csharp\nprivate async Task<Document> MakeConstAsync(Document document,\n   LocalDeclarationStatementSyntax localDeclaration,\n   CancellationToken cancellationToken)\n{\n}\n```\n\nYour new `MakeConstAsync` method will transform the <xref:Microsoft.CodeAnalysis.Document> representing the user's source file into a new <xref:Microsoft.CodeAnalysis.Document> that now contains a `const` declaration.\n\nYou create a new `const` keyword token to insert at the front of the declaration statement. Be careful to first remove any leading trivia from the first token of the declaration statement and attach it to the `const` token. Add the following code to the `MakeConstAsync` method:\n\n[!code-csharp[Create a new const keyword token](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#CreateConstToken  \"Create the new const keyword token\")]\n\nNext, add the `const` token to the declaration using the following code:\n\n```csharp\n// Insert the const token into the modifiers list, creating a new modifiers list.\nvar newModifiers = trimmedLocal.Modifiers.Insert(0, constToken);\n// Produce the new local declaration.\nvar newLocal = trimmedLocal\n    .WithModifiers(newModifiers)\n    .WithDeclaration(localDeclaration.Declaration);\n```\n\nNext, format the new declaration to match C# formatting rules. Formatting your changes to match existing code creates a better experience. Add the following statement immediately after the existing code:\n\n[!code-csharp[Format the new declaration](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#FormatLocal  \"Format the new declaration\")]\n\nA new namespace is required for this code. Add the following `using` statement to the top of the file:\n\n```csharp\nusing Microsoft.CodeAnalysis.Formatting;\n```\n\nThe final step is to make your edit. There are three steps to this process:\n\n1. Get a handle to the existing document.\n1. Create a new document by replacing the existing declaration with the new declaration.\n1. Return the new document.\n\nAdd the following code to the end of the `MakeConstAsync` method:\n\n[!code-csharp[replace the declaration](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#ReplaceDocument  \"Generate a new document by replacing the declaration\")]\n\nYour code fix is ready to try.  Press F5 to run the analyzer project in a second instance of Visual Studio. In the second Visual Studio instance, create a new C# Console Application project and add a few local variable declarations initialized with constant values to the Main method. You'll see that they are reported as warnings as below.\n\n![Can make const warnings](media/how-to-write-csharp-analyzer-code-fix/make-const-warning.png)\n\nYou've made a lot of progress. There are squiggles under the declarations that can be made `const`. But there is still work to do. This works fine if you add `const` to the declarations starting with `i`, then `j` and finally `k`. But, if you add the `const` modifier i a different order, starting with `k`, your analyzer creates errors: `k` can't be declared `const`, unless `i` and `j` are both already `const`. You've got to do more analysis to ensure you handle the different ways variables can be declared and initialized.\n\n## Build data driven tests\n\nYour analyzer and code fix work on a simple case of a single declaration that can be made const. There are numerous possible declaration statements where this implementation makes mistakes. You'll address these cases by working with the unit test library written by the template. It's much faster than repeatedly opening a second copy of Visual Studio.\n\nOpen the **MakeConstUnitTests.cs** file in the unit test project. The template created two tests that follow the two common patterns for an analyzer and code fix unit test. `TestMethod1` shows the pattern for a test that ensures the analyzer doesn't report a diagnostic when it shouldn't. `TestMethod2` shows the pattern for reporting a diagnostic and running the code fix.\n\nThe code for almost every test for your analyzer follows one of these two patterns. For the first step, you can rework these tests as data driven tests. Then, it will be easy to create new tests by adding new string constants to represent different test inputs.\n\nFor efficiency, the first step is to refactor the two tests into data driven tests. Then, you only need to define a couple string constants for each new test. While your refactoring, rename both methods to better names. Replace `TestMethod1` with this test that ensures no diagnostic is raised:\n\n```csharp\n[DataTestMethod]\n[DataRow(\"\")]\npublic void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)\n{\n    VerifyCSharpDiagnostic(testCode);\n}\n```\n\nYou can create a new data row for this test by defining any code fragment that should not cause your diagnostic to trigger a warning. This overload of `VerifyCSharpDiagnostic` passes when there are no diagnostics triggered for the source code fragment.\n\nNext, replace `TestMethod2` with this test that ensures a diagnostic is raised and a code fix applied for the source code fragment:\n\n```csharp\n[DataTestMethod]\n[DataRow(LocalIntCouldBeConstant, LocalIntCouldBeConstantFixed, 10, 13)]\npublic void WhenDiagnosticIsRaisedFixUpdatesCode(\n    string test,\n    string fixTest,\n    int line,\n    int column)\n{\n    var expected = new DiagnosticResult\n    {\n        Id = MakeConstAnalyzer.DiagnosticId,\n        Message = new LocalizableResourceString(nameof(MakeConst.Resources.AnalyzerMessageFormat), MakeConst.Resources.ResourceManager, typeof(MakeConst.Resources)).ToString(),\n        Severity = DiagnosticSeverity.Warning,\n        Locations =\n            new[] {\n                    new DiagnosticResultLocation(\"Test0.cs\", line, column)\n                }\n    };\n\n    VerifyCSharpDiagnostic(test, expected);\n\n    VerifyCSharpFix(test, fixTest);\n}\n```\n\nThe preceding code also made a couple changes to the code that builds the expected diagnostic result. It uses the public constants registered in the `MakeConst` analyzer. In addition, it uses two string constants for the input and fixed source. Add the following string constants to the `UnitTest` class:\n\n[!code-csharp[string constants for fix test](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#FirstFixTest \"string constants for fix test\")]\n\nRun these two tests to make sure they pass. In Visual Studio, open the **Test Explorer** by selecting **Test** > **Windows** > **Test Explorer**.  The press the **Run All** link.\n\n## Create tests for valid declarations\n\nAs a general rule, analyzers should exit as quickly as possible, doing minimal work. Visual Studio calls registered analyzers as the user edits code. Responsiveness is a key requirement. There are several test cases for code that should not raise your diagnostic. Your analyzer already handles one of those tests, the case where a variable is assigned after being initialized. Add the following string constant to your tests to represent that case:\n\n[!code-csharp[variable assigned](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#VariableAssigned \"a variable that is assigned after being initialized won't raise the diagnostic\")]\n\nThen, add a data row for this test as shown in the snippet below:\n\n```csharp\n[DataTestMethod]\n[DataRow(\"\"),\n DataRow(VariableAssigned)]\npublic void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)\n```\n\nThis test passes as well. Next, add constants for conditions you haven't handled yet:\n\n* Declarations that are already `const`, because they are already const:\n\n   [!code-csharp[already const declaration](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#AlreadyConst \"a declaration that is already const should not raise the diagnostic\")]\n\n* Declarations that have no initializer, because there is no value to use:\n\n   [!code-csharp[declarations that have no initializer](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#NoInitializer \"a declaration that has no initializer should not raise the diagnostic\")]\n\n* Declarations where the initializer is not a constant, because they can't be compile-time constants:\n\n   [!code-csharp[declarations where the initializer isn't const](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#InitializerNotConstant \"a declaration where the initializer is not a compile-time constant should not raise the diagnostic\")]\n\nIt can be even more complicated because C# allows multiple declarations as one statement. Consider the following test case string constant:\n\n[!code-csharp[multiple initializers](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#MultipleInitializers \"A declaration can be made constant only if all variables in that statement can be made constant\")]\n\nThe variable `i` can be made constant, but the variable `j` cannot. Therefore, this statement cannot be made a const declaration. Add the `DataRow` declarations for all these tests:\n\n```csharp\n[DataTestMethod]\n[DataRow(\"\"),\n    DataRow(VariableAssigned),\n    DataRow(AlreadyConst),\n    DataRow(NoInitializer),\n    DataRow(InitializerNotConstant),\n    DataRow(MultipleInitializers)]\npublic void WhenTestCodeIsValidNoDiagnosticIsTriggered(string testCode)\n```\n\nRun your tests again, and you'll see these new test cases fail.\n\n## Update your analyzer to ignore correct declarations\n\nYou need some enhancements to your analyzer's `AnalyzeNode` method to filter out code that matches these conditions. They are all related conditions, so similar changes will fix all these conditions. Make the following changes to `AnalyzeNode`:\n\n* Your semantic analysis examined a single variable declaration. This code needs to be in a `foreach` loop that examines all the variables declared in the same statement.\n* Each declared variable needs to have an initializer.\n* Each declared variable's initializer must be a compile-time constant.\n\nIn your `AnalyzeNode` method, replace the original semantic analysis:\n\n```csharp\n// Perform data flow analysis on the local declaration.\nvar dataFlowAnalysis = context.SemanticModel.AnalyzeDataFlow(localDeclaration);\n\n// Retrieve the local symbol for each variable in the local declaration\n// and ensure that it is not written outside of the data flow analysis region.\nvar variable = localDeclaration.Declaration.Variables.Single();\nvar variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable);\nif (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))\n{\n    return;\n}\n```\n\nwith the following code snippet:\n\n```csharp\n// Ensure that all variables in the local declaration have initializers that\n// are assigned with constant values.\nforeach (var variable in localDeclaration.Declaration.Variables)\n{\n    var initializer = variable.Initializer;\n    if (initializer == null)\n    {\n        return;\n    }\n\n    var constantValue = context.SemanticModel.GetConstantValue(initializer.Value);\n    if (!constantValue.HasValue)\n    {\n        return;\n    }\n}\n\n// Perform data flow analysis on the local declaration.\nvar dataFlowAnalysis = context.SemanticModel.AnalyzeDataFlow(localDeclaration);\n\nforeach (var variable in localDeclaration.Declaration.Variables)\n{\n    // Retrieve the local symbol for each variable in the local declaration\n    // and ensure that it is not written outside of the data flow analysis region.\n    var variableSymbol = context.SemanticModel.GetDeclaredSymbol(variable);\n    if (dataFlowAnalysis.WrittenOutside.Contains(variableSymbol))\n    {\n        return;\n    }\n}\n```\n\nThe first `foreach` loop examines each variable declaration using syntactic analysis. The first check guarantees that the variable has an initializer. The second check guarantees that the initializer is a constant. The second loop has the original semantic analysis. The semantic checks are in a separate loop because it has a greater impact on performance. Run your tests again, and you should see them all pass.\n\n## Add the final polish\n\nYou're almost done. There are a few more conditions for your analyzer to handle. Visual Studio calls analyzers while the user is writing code. It's often the case that your analyzer will be called for code that doesn't compile. The diagnostic analyzer's `AnalyzeNode` method does not check to see if the constant value is convertible to the variable type. So, the current implementation will happily convert an incorrect declaration such as int i = \"abc\"' to a local constant. Add a source string constant for that condition:\n\n[!code-csharp[Mismatched types don't raise diagnostics](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#DeclarationIsInvalid \"When the variable type and the constant type don't match, there's no diagnostic\")]\n\nIn addition, reference types are not handled properly. The only constant value allowed for a reference type is `null`, except in this case of <xref:System.String?displayProperty=nameWIthType>, which allows string literals. In other words, `const string s = \"abc\"` is legal, but `const object s = \"abc\"` is not. This code snippet verifies that condition:\n\n[!code-csharp[Reference types don't raise diagnostics](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#DeclarationIsntString \"When the variable type is a reference type other than string, there's no diagnostic\")]\n\nTo be thorough, you need to add another test to make sure that you can create a constant declaration for a string. The following snippet defines both the code that raises the diagnostic, and the code after the fix has been applied:\n\n[!code-csharp[string reference types raise diagnostics](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#ConstantIsString \"When the variable type is string, it can be constant\")]\n\nFinally, if a variable is declared with the `var` keyword, the code fix does the wrong thing and generates a `const var` declaration, which is not supported by the C# language. To fix this bug, the code fix must replace the `var` keyword with the inferred type's name:\n\n[!code-csharp[var references need to use the inferred types](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#VarDeclarations \"Declarations made using var must have the type replaced with the inferred type\")]\n\nThese changes update the data row declarations for both tests. The following code shows these tests with all data row attributes:\n\n[!code-csharp[The finished tests](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst.Test/MakeConstUnitTests.cs#FinishedTests \"The finished tests for the make const analyzer\")]\n\nFortunately, all of the above bugs can be addressed using the same techniques that you just learned.\n\nTo fix the first bug, first open **DiagnosticAnalyzer.cs** and locate the foreach loop where each of the local declaration's initializers are checked to ensure that they're assigned with constant values. Immediately _before_ the first foreach loop, call `context.SemanticModel.GetTypeInfo()` to retrieve detailed information about the declared type of the local declaration:\n\n```csharp\nvar variableTypeName = localDeclaration.Declaration.Type;\nvar variableType = context.SemanticModel.GetTypeInfo(variableTypeName).ConvertedType;\n```\n\nThen, inside your `foreach` loop, check each initializer to make sure it's convertible to the variable type. Add the following check after ensuring that the initializer is a constant:\n\n```csharp\n// Ensure that the initializer value can be converted to the type of the\n// local declaration without a user-defined conversion.\nvar conversion = context.SemanticModel.ClassifyConversion(initializer.Value, variableType);\nif (!conversion.Exists || conversion.IsUserDefined)\n{\n    return;\n}\n```\n\nThe next change builds upon the last one. Before the closing curly brace of the first foreach loop, add the following code to check the type of the local declaration when the constant is a string or null.\n\n```csharp\n// Special cases:\n//  * If the constant value is a string, the type of the local declaration\n//    must be System.String.\n//  * If the constant value is null, the type of the local declaration must\n//    be a reference type.\nif (constantValue.Value is string)\n{\n    if (variableType.SpecialType != SpecialType.System_String)\n    {\n        return;\n    }\n}\nelse if (variableType.IsReferenceType && constantValue.Value != null)\n{\n    return;\n}\n```\n\nYou must write a bit more code in your code fix provider to replace the var' keyword with the correct type name. Return to **CodeFixProvider.cs**. The code you'll add does the following steps:\n\n* Check if the declaration is a `var` declaration, and if it is:\n* Create a new type for the inferred type.\n* Make sure the type declaration is not an alias. If so, it is legal to declare `const var`.\n* Make sure that `var` isn't a type name in this program. (If so, `const var` is legal).\n* Simplify the full type name\n\nThat sounds like a lot of code. It's not. Replace the line that declares and initializes `newLocal` with the following code. It goes immediately after the initialization of `newModifiers`:\n\n[!code-csharp[Replace Var designations](~/samples/csharp/roslyn-sdk/Tutorials/MakeConst/MakeConst/MakeConstCodeFixProvider.cs#ReplaceVar \"Replace a var designation with the explicit type\")]\n\nYou'll need to add one `using` statement to use the <xref:Microsoft.CodeAnalysis.Simplification.Simplifier> type:\n\n```csharp\nusing Microsoft.CodeAnalysis.Simplification;\n```\n\nRun your tests, and they should all pass. Congratulate yourself by running your finished analyzer. Press Ctrl+F5 to run the analyzer project in a second instance of Visual Studio with the Roslyn Preview extension loaded.\n\n* In the second Visual Studio instance, create a new C# Console Application project and add `int x = \"abc\";` to the Main method. Thanks to the first bug fix, no warning should be reported for this local variable declaration (though there's a compiler error as expected).\n* Next, add `object s = \"abc\";` to the Main method. Because of the second bug fix, no warning should be reported.\n* Finally, add another local variable that uses the `var` keyword. You'll see that a warning is reported and a suggestion appears beneath to the left.\n* Move the editor caret over the squiggly underline and press Ctrl+. to display the suggested code fix. Upon selecting your code fix, note that the var' keyword is now handled correctly.\n\nFinally, add the following code:\n\n```csharp\nint i = 2;\nint j = 32;\nint k = i + j;\n```\n\nAfter these changes, you get red squiggles only on the first two variables. Add `const` to both `i` and `j`, and you get a new warning on `k` because it can now be `const`.\n\nCongratulations! You've created your first .NET Compiler Platform extension that performs on-the-fly code analysis to detect an issue and provides a quick fix to correct it. Along the way, you've learned many of the code APIs that are part of the .NET Compiler Platform SDK (Roslyn APIs). You can check your work against the [completed sample](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/Tutorials/MakeConst) in our samples GitHub repository. Or you can download [zip file of the completed project](https://github.com/dotnet/samples/blob/master/csharp/roslyn-sdk/Tutorials/MakeConst.zip)\n\n## Other resources\n\n- [Get started with syntax analysis](../get-started/syntax-analysis.md)\n- [Get started with semantic analysis](../get-started/semantic-analysis.md)\n","nodes":[{"pos":[4,235],"embed":true,"restype":"x-metadata","content":"title: \"Tutorial: Write your first analyzer and code fix\"\ndescription: This tutorial provides step-by-step instructions to build an analyzer and code fix using the .NET Compiler SDK (Roslyn APIs).\nms.date: 08/01/2018\nms.custom: mvc","nodes":[{"content":"Tutorial: Write your first analyzer and code fix","nodes":[{"pos":[0,48],"content":"Tutorial: Write your first analyzer and code fix","nodes":[{"content":"Tutorial: Write your first analyzer and code fix","pos":[0,48]}]}],"path":["title"],"nosxs":false},{"content":"This tutorial provides step-by-step instructions to build an analyzer and code fix using the .NET Compiler SDK (Roslyn APIs).","nodes":[{"pos":[0,125],"content":"This tutorial provides step-by-step instructions to build an analyzer and code fix using the .NET Compiler SDK (Roslyn APIs).","nodes":[{"content":"This tutorial provides step-by-step instructions to build an analyzer and code fix using the .NET Compiler SDK (Roslyn APIs).","pos":[0,125]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[243,291],"content":"Tutorial: Write your first analyzer and code fix","linkify":"Tutorial: Write your first analyzer and code fix","nodes":[{"content":"Tutorial: Write your first analyzer and code fix","pos":[0,48]}]},{"content":"The .NET Compiler Platform SDK provides the tools you need to create custom warnings that target C# or Visual Basic code.","pos":[293,414]},{"content":"Your <bpt id=\"p1\">**</bpt>analyzer<ept id=\"p1\">**</ept> contains code that recognizes violations of your rule.","pos":[415,487],"source":" Your **analyzer** contains code that recognizes violations of your rule."},{"content":"Your <bpt id=\"p1\">**</bpt>code fix<ept id=\"p1\">**</ept> contains the code that fixes the violation.","pos":[488,549],"source":" Your **code fix** contains the code that fixes the violation."},{"content":"The rules you implement can be anything from code structure to coding style to naming conventions and more.","pos":[550,657]},{"content":"The .NET Compiler Platform provides the framework for running analysis as developers are writing code, and all the Visual Studio UI features for fixing code: showing squiggles in the editor, populating the Visual Studio Error List, creating the \"light bulb\" suggestions and showing the rich preview of the suggested fixes.","pos":[658,980]},{"content":"In this tutorial, you'll explore the creation of an <bpt id=\"p1\">**</bpt>analyzer<ept id=\"p1\">**</ept> and an accompanying <bpt id=\"p2\">**</bpt>code fix<ept id=\"p2\">**</ept> using the Roslyn APIs.","pos":[982,1102],"source":"In this tutorial, you'll explore the creation of an **analyzer** and an accompanying **code fix** using the Roslyn APIs."},{"content":"An analyzer is a way to perform source code analysis and report a problem to the user.","pos":[1103,1189]},{"content":"Optionally, an analyzer can also provide a code fix that represents a modification to the user's source code.","pos":[1190,1299]},{"content":"This tutorial creates an analyzer that finds local variable declarations that could be declared using the <ph id=\"ph1\">`const`</ph> modifier but are not.","pos":[1300,1435],"source":" This tutorial creates an analyzer that finds local variable declarations that could be declared using the `const` modifier but are not."},{"content":"The accompanying code fix modifies those declarations to add the <ph id=\"ph1\">`const`</ph> modifier.","pos":[1436,1518],"source":" The accompanying code fix modifies those declarations to add the `const` modifier."},{"pos":[1523,1536],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"pos":[1540,1600],"content":"<bpt id=\"p1\">[</bpt>Visual Studio 2017<ept id=\"p1\">](https://www.visualstudio.com/downloads)</ept>","source":"[Visual Studio 2017](https://www.visualstudio.com/downloads)"},{"pos":[1602,1660],"content":"You'll need to install the <bpt id=\"p1\">**</bpt>.NET Compiler Platform SDK<ept id=\"p1\">**</ept>:","source":"You'll need to install the **.NET Compiler Platform SDK**:"},{"content":"There are several steps to creating and validating your analyzer:","pos":[1727,1792]},{"content":"Create the solution.","pos":[1797,1817]},{"content":"Register the analyzer name and description.","pos":[1821,1864]},{"content":"Report analyzer warnings and recommendations.","pos":[1868,1913]},{"content":"Implement the code fix to accept recommendations.","pos":[1917,1966]},{"content":"Improve the analysis through unit tests.","pos":[1970,2010]},{"pos":[2015,2044],"content":"Explore the analyzer template","linkify":"Explore the analyzer template","nodes":[{"content":"Explore the analyzer template","pos":[0,29]}]},{"content":"Your analyzer reports to the user any local variable declarations that can be converted to local constants.","pos":[2046,2153]},{"content":"For example, consider the following code:","pos":[2154,2195]},{"content":"In the code above, <ph id=\"ph1\">`x`</ph> is assigned a constant value and is never modified.","pos":[2245,2319],"source":"In the code above, `x` is assigned a constant value and is never modified."},{"content":"It can be declared using the <ph id=\"ph1\">`const`</ph> modifier:","pos":[2320,2366],"source":" It can be declared using the `const` modifier:"},{"content":"The analysis to determine whether a variable can be made constant is involved, requiring syntactic analysis, constant analysis of the initializer expression and dataflow analysis to ensure that the variable is never written to.","pos":[2422,2649]},{"content":"The .NET Compiler Platform provides APIs that make it easier to perform this analysis.","pos":[2650,2736]},{"content":"The first step is to create a new C# <bpt id=\"p1\">**</bpt>Analyzer with code fix<ept id=\"p1\">**</ept> project.","pos":[2737,2809],"source":" The first step is to create a new C# **Analyzer with code fix** project."},{"pos":[2813,2900],"content":"In Visual Studio, choose <bpt id=\"p1\">**</bpt>File &gt; New &gt; Project...<ept id=\"p1\">**</ept> to display the New Project dialog.","source":"In Visual Studio, choose **File > New > Project...** to display the New Project dialog."},{"pos":[2903,2990],"content":"Under <bpt id=\"p1\">**</bpt>Visual C# &gt; Extensibility<ept id=\"p1\">**</ept>, choose <bpt id=\"p2\">**</bpt>Analyzer with code fix (.NET Standard)<ept id=\"p2\">**</ept>.","source":"Under **Visual C# > Extensibility**, choose **Analyzer with code fix (.NET Standard)**."},{"pos":[2993,3040],"content":"Name your project \"<bpt id=\"p1\">**</bpt>MakeConst<ept id=\"p1\">**</ept>\" and click OK.","source":"Name your project \"**MakeConst**\" and click OK."},{"content":"The analyzer with code fix template creates three projects: one contains the analyzer and code fix, the second is a unit test project, and the third is the VSIX project.","pos":[3042,3211]},{"content":"The default startup project is the VSIX project.","pos":[3212,3260]},{"content":"Press <bpt id=\"p1\">**</bpt>F5<ept id=\"p1\">**</ept> to start the VSIX project.","pos":[3261,3300],"source":" Press **F5** to start the VSIX project."},{"content":"This starts a second instance of Visual Studio that has loaded your new analyzer.","pos":[3301,3382]},{"pos":[3386,3852],"content":"[!TIP]\nWhen you run your analyzer, you start a second copy of Visual Studio. This second copy uses a different registry hive to store settings. That enables you to differentiate the visual settings in the two copies of Visual Studio. You can pick a different theme for the experimental run of Visual Studio. In addition, don't roam your settings or login to your Visual Studio account using the experimental run of Visual Studio. That keeps the settings different.","leadings":["","> "],"nodes":[{"content":"When you run your analyzer, you start a second copy of Visual Studio. This second copy uses a different registry hive to store settings. That enables you to differentiate the visual settings in the two copies of Visual Studio. You can pick a different theme for the experimental run of Visual Studio. In addition, don't roam your settings or login to your Visual Studio account using the experimental run of Visual Studio. That keeps the settings different.","pos":[7,464],"nodes":[{"content":"When you run your analyzer, you start a second copy of Visual Studio.","pos":[0,69]},{"content":"This second copy uses a different registry hive to store settings.","pos":[70,136]},{"content":"That enables you to differentiate the visual settings in the two copies of Visual Studio.","pos":[137,226]},{"content":"You can pick a different theme for the experimental run of Visual Studio.","pos":[227,300]},{"content":"In addition, don't roam your settings or login to your Visual Studio account using the experimental run of Visual Studio.","pos":[301,422]},{"content":"That keeps the settings different.","pos":[423,457]}]}]},{"content":"In the second Visual Studio instance that you just started, create a new C# Console Application project (either .NET Core or .NET Framework project will work -- analyzers work at the source level.) Hover over the token with a wavy underline, and the warning text provided by an analyzer appears.","pos":[3854,4149]},{"content":"The template creates an analyzer that reports a warning on each type declaration where the type name contains lowercase letters, as shown in the following figure:","pos":[4151,4313]},{"content":"Analyzer reporting warning","pos":[4317,4343]},{"content":"The template also provides a code fix that changes any type name containing lower case characters to all upper case.","pos":[4410,4526]},{"content":"You can click on the light bulb displayed with the warning to see the suggested changes.","pos":[4527,4615]},{"content":"Accepting the suggested changes updates the type name and all references to that type in the solution.","pos":[4616,4718]},{"content":"Now that you've seen the initial analyzer in action, close the second Visual Studio instance and return to your analyzer project.","pos":[4719,4848]},{"content":"You don't have to start a second copy of Visual Studio and create new code to test every change in your analyzer.","pos":[4850,4963]},{"content":"The template also creates a unit test project for you.","pos":[4964,5018]},{"content":"That project contains two tests.","pos":[5019,5051]},{"content":"<ph id=\"ph1\">`TestMethod1`</ph> shows the typical format of a test that analyzes code without triggering a diagnostic.","pos":[5052,5152],"source":"`TestMethod1` shows the typical format of a test that analyzes code without triggering a diagnostic."},{"content":"<ph id=\"ph1\">`TestMethod2`</ph> shows the format of a test that triggers a diagnostic, and then applies a suggested code fix.","pos":[5153,5260],"source":"`TestMethod2` shows the format of a test that triggers a diagnostic, and then applies a suggested code fix."},{"content":"As you build your analyzer and code fix, you'll write tests for different code structures to verify your work.","pos":[5261,5371]},{"content":"Unit tests for analyzers are much quicker than testing them interactively with Visual Studio.","pos":[5372,5465]},{"pos":[5469,5731],"content":"[!TIP]\nAnalyzer unit tests are a great tool when you know what code constructs should and shouldn't trigger your analyzer. Loading your analyzer in another copy of Visual Studio is a great tool to explore and find constructs you may not have thought about yet.","leadings":["","> "],"nodes":[{"content":"Analyzer unit tests are a great tool when you know what code constructs should and shouldn't trigger your analyzer. Loading your analyzer in another copy of Visual Studio is a great tool to explore and find constructs you may not have thought about yet.","pos":[7,260],"nodes":[{"content":"Analyzer unit tests are a great tool when you know what code constructs should and shouldn't trigger your analyzer.","pos":[0,115]},{"content":"Loading your analyzer in another copy of Visual Studio is a great tool to explore and find constructs you may not have thought about yet.","pos":[116,253]}]}]},{"pos":[5736,5765],"content":"Create analyzer registrations","linkify":"Create analyzer registrations","nodes":[{"content":"Create analyzer registrations","pos":[0,29]}]},{"content":"The template creates the initial <ph id=\"ph1\">`DiagnosticAnalyzer`</ph> class, in the <bpt id=\"p1\">**</bpt>MakeConstAnalyzer.cs<ept id=\"p1\">**</ept> file.","pos":[5767,5865],"source":"The template creates the initial `DiagnosticAnalyzer` class, in the **MakeConstAnalyzer.cs** file."},{"content":"This initial analyzer shows two important properties of every analyzer.","pos":[5866,5937]},{"pos":[5941,6058],"content":"Every diagnostic analyzer must provide a <ph id=\"ph1\">`[DiagnosticAnalyzer]`</ph> attribute that describes the language it operates on.","source":"Every diagnostic analyzer must provide a `[DiagnosticAnalyzer]` attribute that describes the language it operates on."},{"pos":[6061,6175],"content":"Every diagnostic analyzer must derive from the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer&gt;</ph> class.","source":"Every diagnostic analyzer must derive from the <xref:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer> class."},{"content":"The template also shows the basic features that are part of any analyzer:","pos":[6177,6250]},{"content":"Register actions.","pos":[6255,6272]},{"content":"The actions represent code changes that should trigger your analyzer to examine code for violations.","pos":[6273,6373]},{"content":"When Visual Studio detects code edits that match a registered action, it calls your analyzer's registered method.","pos":[6374,6487]},{"content":"Create diagnostics.","pos":[6491,6510]},{"content":"When your analyzer detects a violation, it creates a diagnostic object that Visual Studio uses to notify the user of the violation.","pos":[6511,6642]},{"content":"You register actions in your override of <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)?displayProperty=nameWithType&gt;</ph> method.","pos":[6644,6845],"source":"You register actions in your override of <xref:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)?displayProperty=nameWithType> method."},{"content":"In this tutorial, you'll visit <bpt id=\"p1\">**</bpt>syntax nodes<ept id=\"p1\">**</ept> looking for local declarations, and see which of those have constant values.","pos":[6846,6970],"source":" In this tutorial, you'll visit **syntax nodes** looking for local declarations, and see which of those have constant values."},{"content":"If a declaration could be constant, your analyzer will create and report a diagnostic.","pos":[6971,7057]},{"content":"The first step is to update the registration constants and <ph id=\"ph1\">`Initialize`</ph> method so these constants indicate your \"Make Const\" analyzer.","pos":[7059,7193],"source":"The first step is to update the registration constants and `Initialize` method so these constants indicate your \"Make Const\" analyzer."},{"content":"Most of the string constants are defined in the string resource file.","pos":[7194,7263]},{"content":"You should follow that practice for easier localization.","pos":[7264,7320]},{"content":"Open the <bpt id=\"p1\">**</bpt>Resources.resx<ept id=\"p1\">**</ept> file for the <bpt id=\"p2\">**</bpt>MakeConst<ept id=\"p2\">**</ept> analyzer project.","pos":[7321,7393],"source":" Open the **Resources.resx** file for the **MakeConst** analyzer project."},{"content":"This displays the resource editor.","pos":[7394,7428]},{"content":"Update the string resources as follows:","pos":[7429,7468]},{"pos":[7472,7530],"content":"Change <ph id=\"ph1\">`AnalyzerTitle`</ph> to \"Variable can be made constant\".","source":"Change `AnalyzerTitle` to \"Variable can be made constant\"."},{"pos":[7533,7590],"content":"Change <ph id=\"ph1\">`AnalyzerMessageFormat`</ph> to \"Can be made constant\".","source":"Change `AnalyzerMessageFormat` to \"Can be made constant\"."},{"pos":[7593,7641],"content":"Change <ph id=\"ph1\">`AnalyzerDescription`</ph> to \"Make Constant\".","source":"Change `AnalyzerDescription` to \"Make Constant\"."},{"content":"Also, change the <bpt id=\"p1\">**</bpt>Access Modifier<ept id=\"p1\">**</ept> drop-down to <ph id=\"ph1\">`public`</ph>.","pos":[7643,7702],"source":"Also, change the **Access Modifier** drop-down to `public`."},{"content":"That makes it easier to use these constants in unit tests.","pos":[7703,7761]},{"content":"When you have finished, the resource editor should appear as follow figure shows:","pos":[7762,7843]},{"content":"Update string resources","pos":[7847,7870]},{"content":"The remaining changes are in the analyzer file.","pos":[7946,7993]},{"content":"Open <bpt id=\"p1\">**</bpt>MakeConstAnalyzer.cs<ept id=\"p1\">**</ept> in Visual Studio.","pos":[7994,8041],"source":" Open **MakeConstAnalyzer.cs** in Visual Studio."},{"content":"Change the registered action from one that acts on symbols to one that acts on syntax.","pos":[8042,8128]},{"content":"In the <ph id=\"ph1\">`MakeConstAnalyzerAnalyzer.Initialize`</ph> method, find the line that registers the action on symbols:","pos":[8129,8234],"source":" In the `MakeConstAnalyzerAnalyzer.Initialize` method, find the line that registers the action on symbols:"},{"content":"Replace it with the following line:","pos":[8318,8353]},{"content":"After that change, you can delete the <ph id=\"ph1\">`AnalyzeSymbol`</ph> method.","pos":[8521,8582],"source":"After that change, you can delete the `AnalyzeSymbol` method."},{"content":"This analyzer examines <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LocalDeclarationStatement?displayProperty=nameWithType&gt;</ph>, not <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.SymbolKind.NamedType?displayProperty=nameWithType&gt;</ph> statements.","pos":[8583,8805],"source":" This analyzer examines <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.LocalDeclarationStatement?displayProperty=nameWithType>, not <xref:Microsoft.CodeAnalysis.SymbolKind.NamedType?displayProperty=nameWithType> statements."},{"content":"Notice that <ph id=\"ph1\">`AnalyzeNode`</ph> has red squiggles under it.","pos":[8806,8859],"source":" Notice that `AnalyzeNode` has red squiggles under it."},{"content":"The code you just added references an <ph id=\"ph1\">`AnalyzeNode`</ph> method that hasn't been declared.","pos":[8860,8945],"source":" The code you just added references an `AnalyzeNode` method that hasn't been declared."},{"content":"Declare that method using the following code:","pos":[8946,8991]},{"pos":[9072,9164],"content":"Change the <ph id=\"ph1\">`Category`</ph> to \"Usage\" in <bpt id=\"p1\">**</bpt>MakeConstAnalyzer.cs<ept id=\"p1\">**</ept> as shown in the following code:","source":"Change the `Category` to \"Usage\" in **MakeConstAnalyzer.cs** as shown in the following code:"},{"pos":[9225,9268],"content":"Find local declarations that could be const","linkify":"Find local declarations that could be const","nodes":[{"content":"Find local declarations that could be const","pos":[0,43]}]},{"content":"It's time to write the first version of the <ph id=\"ph1\">`AnalyzeNode`</ph> method.","pos":[9270,9335],"source":"It's time to write the first version of the `AnalyzeNode` method."},{"content":"It should look for a single local declaration that could be <ph id=\"ph1\">`const`</ph> but is not, like the following code:","pos":[9336,9440],"source":" It should look for a single local declaration that could be `const` but is not, like the following code:"},{"content":"The first step is to find local declarations.","pos":[9490,9535]},{"content":"Add the following code to <ph id=\"ph1\">`AnalyzeNode`</ph> in <bpt id=\"p1\">**</bpt>MakeConstAnalyzer.cs<ept id=\"p1\">**</ept>:","pos":[9536,9604],"source":" Add the following code to `AnalyzeNode` in **MakeConstAnalyzer.cs**:"},{"content":"This cast always succeeds because your analyzer registered for changes to local declarations, and only local declarations.","pos":[9691,9813]},{"content":"No other node type triggers a call to your <ph id=\"ph1\">`AnalyzeNode`</ph> method.","pos":[9814,9878],"source":" No other node type triggers a call to your `AnalyzeNode` method."},{"content":"Next, check the declaration for any <ph id=\"ph1\">`const`</ph> modifiers.","pos":[9879,9933],"source":" Next, check the declaration for any `const` modifiers."},{"content":"If you find them, return immediately.","pos":[9934,9971]},{"content":"The following code looks for any <ph id=\"ph1\">`const`</ph> modifiers on the local declaration:","pos":[9972,10048],"source":" The following code looks for any `const` modifiers on the local declaration:"},{"content":"Finally, you need to check that the variable could be <ph id=\"ph1\">`const`</ph>.","pos":[10192,10254],"source":"Finally, you need to check that the variable could be `const`."},{"content":"That means making sure it is never assigned after it is initialized.","pos":[10255,10323]},{"content":"You'll perform some semantic analysis using the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext&gt;</ph>.","pos":[10325,10441],"source":"You'll perform some semantic analysis using the <xref:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext>."},{"content":"You use the <ph id=\"ph1\">`context`</ph> argument to determine whether the local variable declaration can be made <ph id=\"ph2\">`const`</ph>.","pos":[10442,10545],"source":" You use the `context` argument to determine whether the local variable declaration can be made `const`."},{"content":"A <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel?displayProperty=nameWithType&gt;</ph> represents of all semantic information in a single source file.","pos":[10546,10684],"source":" A <xref:Microsoft.CodeAnalysis.SemanticModel?displayProperty=nameWithType> represents of all semantic information in a single source file."},{"content":"You can learn more in the article that covers <bpt id=\"p1\">[</bpt>semantic models<ept id=\"p1\">](../work-with-semantics.md)</ept>.","pos":[10685,10776],"source":" You can learn more in the article that covers [semantic models](../work-with-semantics.md)."},{"content":"You'll use the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.SemanticModel?displayProperty=nameWithType&gt;</ph> to perform data flow analysis on the local declaration statement.","pos":[10777,10930],"source":" You'll use the <xref:Microsoft.CodeAnalysis.SemanticModel?displayProperty=nameWithType> to perform data flow analysis on the local declaration statement."},{"content":"Then, you use the results of this data flow analysis to ensure that the local variable isn't written with a new value anywhere else.","pos":[10931,11063]},{"content":"Call the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol%2A&gt;</ph> extension method to retrieve the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.ILocalSymbol&gt;</ph> for the variable and check that it isn't contained with the <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenOutside%2A?displayProperty=nameWithType&gt;</ph> collection of the data flow analysis.","pos":[11064,11407],"source":" Call the <xref:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol%2A> extension method to retrieve the <xref:Microsoft.CodeAnalysis.ILocalSymbol> for the variable and check that it isn't contained with the <xref:Microsoft.CodeAnalysis.DataFlowAnalysis.WrittenOutside%2A?displayProperty=nameWithType> collection of the data flow analysis."},{"content":"Add the following code to the end of the <ph id=\"ph1\">`AnalyzeNode`</ph> method:","pos":[11408,11470],"source":" Add the following code to the end of the `AnalyzeNode` method:"},{"content":"The code just added ensures that the variable isn't modified, and can therefore be made <ph id=\"ph1\">`const`</ph>.","pos":[11989,12085],"source":"The code just added ensures that the variable isn't modified, and can therefore be made `const`."},{"content":"It's time to raise the diagnostic.","pos":[12086,12120]},{"content":"Add the following code as the last line in <ph id=\"ph1\">`AnalyzeNode`</ph>:","pos":[12121,12178],"source":" Add the following code as the last line in `AnalyzeNode`:"},{"content":"You can check your progress by pressing <bpt id=\"p1\">**</bpt>F5<ept id=\"p1\">**</ept> to run your analyzer.","pos":[12274,12342],"source":"You can check your progress by pressing **F5** to run your analyzer."},{"content":"You can load the console application you created earlier and then add the following test code:","pos":[12343,12437]},{"content":"The light bulb should appear, and your analyzer should report a diagnostic.","pos":[12487,12562]},{"content":"However, the light bulb still uses the template generated code fix, and tells you it can be made upper case.","pos":[12563,12671]},{"content":"The next section explains how to write the code fix.","pos":[12672,12724]},{"pos":[12729,12747],"content":"Write the code fix","linkify":"Write the code fix","nodes":[{"content":"Write the code fix","pos":[0,18]}]},{"content":"An analyzer can provide one or more code fixes.","pos":[12749,12796]},{"content":"A code fix defines an edit that addresses the reported issue.","pos":[12797,12858]},{"content":"For the analyzer that you created, you can provide a code fix that inserts the const keyword:","pos":[12859,12952]},{"content":"The user chooses it from the light bulb UI in the editor and Visual Studio changes the code.","pos":[13008,13100]},{"content":"Open the <bpt id=\"p1\">**</bpt>MakeConstCodeFixProvider.cs<ept id=\"p1\">**</ept> file added by the template.","pos":[13102,13170],"source":"Open the **MakeConstCodeFixProvider.cs** file added by the template."},{"content":"This code fix is already wired up to the Diagnostic ID produced by your diagnostic analyzer, but it doesn't yet implement the right code transform.","pos":[13172,13319]},{"content":"First you should remove some of the template code.","pos":[13320,13370]},{"content":"Change the title string to \"Make constant\":","pos":[13371,13414]},{"content":"Next, delete the <ph id=\"ph1\">`MakeUppercaseAsync`</ph> method.","pos":[13585,13630],"source":"Next, delete the `MakeUppercaseAsync` method."},{"content":"It no longer applies.","pos":[13631,13652]},{"content":"All code fixes derive from <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider&gt;</ph>.","pos":[13654,13737],"source":"All code fixes derive from <xref:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider>."},{"content":"They all override <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)?displayProperty=nameWithType&gt;</ph> to report available code fixes.","pos":[13738,13944],"source":" They all override <xref:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)?displayProperty=nameWithType> to report available code fixes."},{"content":"In <ph id=\"ph1\">`RegisterCodeFixesAsync`</ph>, change the ancestor node type you're searching for to a <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax&gt;</ph> to match the diagnostic:","pos":[13945,14130],"source":" In `RegisterCodeFixesAsync`, change the ancestor node type you're searching for to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> to match the diagnostic:"},{"content":"Next, change the last line to register a code fix.","pos":[14346,14396]},{"content":"Your fix will create a new document that results from adding the <ph id=\"ph1\">`const`</ph> modifier to an existing declaration:","pos":[14397,14506],"source":" Your fix will create a new document that results from adding the `const` modifier to an existing declaration:"},{"content":"You'll notice red squiggles in the code you just added on the symbol <ph id=\"ph1\">`MakeConstAsync`</ph>.","pos":[14683,14769],"source":"You'll notice red squiggles in the code you just added on the symbol `MakeConstAsync`."},{"content":"Add a declaration for <ph id=\"ph1\">`MakeConstAsync`</ph> like the following code:","pos":[14770,14833],"source":" Add a declaration for `MakeConstAsync` like the following code:"},{"pos":[15010,15227],"content":"Your new <ph id=\"ph1\">`MakeConstAsync`</ph> method will transform the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.Document&gt;</ph> representing the user's source file into a new <ph id=\"ph3\">&lt;xref:Microsoft.CodeAnalysis.Document&gt;</ph> that now contains a <ph id=\"ph4\">`const`</ph> declaration.","source":"Your new `MakeConstAsync` method will transform the <xref:Microsoft.CodeAnalysis.Document> representing the user's source file into a new <xref:Microsoft.CodeAnalysis.Document> that now contains a `const` declaration."},{"content":"You create a new <ph id=\"ph1\">`const`</ph> keyword token to insert at the front of the declaration statement.","pos":[15229,15320],"source":"You create a new `const` keyword token to insert at the front of the declaration statement."},{"content":"Be careful to first remove any leading trivia from the first token of the declaration statement and attach it to the <ph id=\"ph1\">`const`</ph> token.","pos":[15321,15452],"source":" Be careful to first remove any leading trivia from the first token of the declaration statement and attach it to the `const` token."},{"content":"Add the following code to the <ph id=\"ph1\">`MakeConstAsync`</ph> method:","pos":[15453,15507],"source":" Add the following code to the `MakeConstAsync` method:"},{"pos":[15701,15773],"content":"Next, add the <ph id=\"ph1\">`const`</ph> token to the declaration using the following code:","source":"Next, add the `const` token to the declaration using the following code:"},{"content":"Next, format the new declaration to match C# formatting rules.","pos":[16088,16150]},{"content":"Formatting your changes to match existing code creates a better experience.","pos":[16151,16226]},{"content":"Add the following statement immediately after the existing code:","pos":[16227,16291]},{"content":"A new namespace is required for this code.","pos":[16466,16508]},{"content":"Add the following <ph id=\"ph1\">`using`</ph> statement to the top of the file:","pos":[16509,16568],"source":" Add the following `using` statement to the top of the file:"},{"content":"The final step is to make your edit.","pos":[16626,16662]},{"content":"There are three steps to this process:","pos":[16663,16701]},{"content":"Get a handle to the existing document.","pos":[16706,16744]},{"content":"Create a new document by replacing the existing declaration with the new declaration.","pos":[16748,16833]},{"content":"Return the new document.","pos":[16837,16861]},{"pos":[16863,16928],"content":"Add the following code to the end of the <ph id=\"ph1\">`MakeConstAsync`</ph> method:","source":"Add the following code to the end of the `MakeConstAsync` method:"},{"content":"Your code fix is ready to try.","pos":[17130,17160]},{"content":"Press F5 to run the analyzer project in a second instance of Visual Studio.","pos":[17162,17237]},{"content":"In the second Visual Studio instance, create a new C# Console Application project and add a few local variable declarations initialized with constant values to the Main method.","pos":[17238,17414]},{"content":"You'll see that they are reported as warnings as below.","pos":[17415,17470]},{"content":"Can make const warnings","pos":[17474,17497]},{"content":"You've made a lot of progress.","pos":[17568,17598]},{"content":"There are squiggles under the declarations that can be made <ph id=\"ph1\">`const`</ph>.","pos":[17599,17667],"source":" There are squiggles under the declarations that can be made `const`."},{"content":"But there is still work to do.","pos":[17668,17698]},{"content":"This works fine if you add <ph id=\"ph1\">`const`</ph> to the declarations starting with <ph id=\"ph2\">`i`</ph>, then <ph id=\"ph3\">`j`</ph> and finally <ph id=\"ph4\">`k`</ph>.","pos":[17699,17798],"source":" This works fine if you add `const` to the declarations starting with `i`, then `j` and finally `k`."},{"content":"But, if you add the <ph id=\"ph1\">`const`</ph> modifier i a different order, starting with <ph id=\"ph2\">`k`</ph>, your analyzer creates errors: <ph id=\"ph3\">`k`</ph> can't be declared <ph id=\"ph4\">`const`</ph>, unless <ph id=\"ph5\">`i`</ph> and <ph id=\"ph6\">`j`</ph> are both already <ph id=\"ph7\">`const`</ph>.","pos":[17799,17981],"source":" But, if you add the `const` modifier i a different order, starting with `k`, your analyzer creates errors: `k` can't be declared `const`, unless `i` and `j` are both already `const`."},{"content":"You've got to do more analysis to ensure you handle the different ways variables can be declared and initialized.","pos":[17982,18095]},{"pos":[18100,18123],"content":"Build data driven tests","linkify":"Build data driven tests","nodes":[{"content":"Build data driven tests","pos":[0,23]}]},{"content":"Your analyzer and code fix work on a simple case of a single declaration that can be made const.","pos":[18125,18221]},{"content":"There are numerous possible declaration statements where this implementation makes mistakes.","pos":[18222,18314]},{"content":"You'll address these cases by working with the unit test library written by the template.","pos":[18315,18404]},{"content":"It's much faster than repeatedly opening a second copy of Visual Studio.","pos":[18405,18477]},{"content":"Open the <bpt id=\"p1\">**</bpt>MakeConstUnitTests.cs<ept id=\"p1\">**</ept> file in the unit test project.","pos":[18479,18544],"source":"Open the **MakeConstUnitTests.cs** file in the unit test project."},{"content":"The template created two tests that follow the two common patterns for an analyzer and code fix unit test.","pos":[18545,18651]},{"content":"<ph id=\"ph1\">`TestMethod1`</ph> shows the pattern for a test that ensures the analyzer doesn't report a diagnostic when it shouldn't.","pos":[18652,18767],"source":"`TestMethod1` shows the pattern for a test that ensures the analyzer doesn't report a diagnostic when it shouldn't."},{"content":"<ph id=\"ph1\">`TestMethod2`</ph> shows the pattern for reporting a diagnostic and running the code fix.","pos":[18768,18852],"source":"`TestMethod2` shows the pattern for reporting a diagnostic and running the code fix."},{"content":"The code for almost every test for your analyzer follows one of these two patterns.","pos":[18854,18937]},{"content":"For the first step, you can rework these tests as data driven tests.","pos":[18938,19006]},{"content":"Then, it will be easy to create new tests by adding new string constants to represent different test inputs.","pos":[19007,19115]},{"content":"For efficiency, the first step is to refactor the two tests into data driven tests.","pos":[19117,19200]},{"content":"Then, you only need to define a couple string constants for each new test.","pos":[19201,19275]},{"content":"While your refactoring, rename both methods to better names.","pos":[19276,19336]},{"content":"Replace <ph id=\"ph1\">`TestMethod1`</ph> with this test that ensures no diagnostic is raised:","pos":[19337,19411],"source":" Replace `TestMethod1` with this test that ensures no diagnostic is raised:"},{"content":"You can create a new data row for this test by defining any code fragment that should not cause your diagnostic to trigger a warning.","pos":[19573,19706]},{"content":"This overload of <ph id=\"ph1\">`VerifyCSharpDiagnostic`</ph> passes when there are no diagnostics triggered for the source code fragment.","pos":[19707,19825],"source":" This overload of `VerifyCSharpDiagnostic` passes when there are no diagnostics triggered for the source code fragment."},{"pos":[19827,19958],"content":"Next, replace <ph id=\"ph1\">`TestMethod2`</ph> with this test that ensures a diagnostic is raised and a code fix applied for the source code fragment:","source":"Next, replace `TestMethod2` with this test that ensures a diagnostic is raised and a code fix applied for the source code fragment:"},{"content":"The preceding code also made a couple changes to the code that builds the expected diagnostic result.","pos":[20723,20824]},{"content":"It uses the public constants registered in the <ph id=\"ph1\">`MakeConst`</ph> analyzer.","pos":[20825,20893],"source":" It uses the public constants registered in the `MakeConst` analyzer."},{"content":"In addition, it uses two string constants for the input and fixed source.","pos":[20894,20967]},{"content":"Add the following string constants to the <ph id=\"ph1\">`UnitTest`</ph> class:","pos":[20968,21027],"source":" Add the following string constants to the `UnitTest` class:"},{"content":"Run these two tests to make sure they pass.","pos":[21207,21250]},{"content":"In Visual Studio, open the <bpt id=\"p1\">**</bpt>Test Explorer<ept id=\"p1\">**</ept> by selecting <bpt id=\"p2\">**</bpt>Test<ept id=\"p2\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p3\">**</bpt>Windows<ept id=\"p3\">**</ept><ph id=\"ph2\"> &gt; </ph><bpt id=\"p4\">**</bpt>Test Explorer<ept id=\"p4\">**</ept>.","pos":[21251,21352],"source":" In Visual Studio, open the **Test Explorer** by selecting **Test** > **Windows** > **Test Explorer**."},{"content":"The press the <bpt id=\"p1\">**</bpt>Run All<ept id=\"p1\">**</ept> link.","pos":[21354,21385],"source":"  The press the **Run All** link."},{"pos":[21390,21425],"content":"Create tests for valid declarations","linkify":"Create tests for valid declarations","nodes":[{"content":"Create tests for valid declarations","pos":[0,35]}]},{"content":"As a general rule, analyzers should exit as quickly as possible, doing minimal work.","pos":[21427,21511]},{"content":"Visual Studio calls registered analyzers as the user edits code.","pos":[21512,21576]},{"content":"Responsiveness is a key requirement.","pos":[21577,21613]},{"content":"There are several test cases for code that should not raise your diagnostic.","pos":[21614,21690]},{"content":"Your analyzer already handles one of those tests, the case where a variable is assigned after being initialized.","pos":[21691,21803]},{"content":"Add the following string constant to your tests to represent that case:","pos":[21804,21875]},{"content":"Then, add a data row for this test as shown in the snippet below:","pos":[22096,22161]},{"content":"This test passes as well.","pos":[22309,22334]},{"content":"Next, add constants for conditions you haven't handled yet:","pos":[22335,22394]},{"pos":[22398,22468],"content":"Declarations that are already <ph id=\"ph1\">`const`</ph>, because they are already const:","source":"Declarations that are already `const`, because they are already const:"},{"content":"Declarations that have no initializer, because there is no value to use:","pos":[22687,22759]},{"content":"Declarations where the initializer is not a constant, because they can't be compile-time constants:","pos":[22993,23092]},{"content":"It can be even more complicated because C# allows multiple declarations as one statement.","pos":[23371,23460]},{"content":"Consider the following test case string constant:","pos":[23461,23510]},{"content":"The variable <ph id=\"ph1\">`i`</ph> can be made constant, but the variable <ph id=\"ph2\">`j`</ph> cannot.","pos":[23756,23823],"source":"The variable `i` can be made constant, but the variable `j` cannot."},{"content":"Therefore, this statement cannot be made a const declaration.","pos":[23824,23885]},{"content":"Add the <ph id=\"ph1\">`DataRow`</ph> declarations for all these tests:","pos":[23886,23937],"source":" Add the `DataRow` declarations for all these tests:"},{"content":"Run your tests again, and you'll see these new test cases fail.","pos":[24215,24278]},{"pos":[24283,24334],"content":"Update your analyzer to ignore correct declarations","linkify":"Update your analyzer to ignore correct declarations","nodes":[{"content":"Update your analyzer to ignore correct declarations","pos":[0,51]}]},{"content":"You need some enhancements to your analyzer's <ph id=\"ph1\">`AnalyzeNode`</ph> method to filter out code that matches these conditions.","pos":[24336,24452],"source":"You need some enhancements to your analyzer's `AnalyzeNode` method to filter out code that matches these conditions."},{"content":"They are all related conditions, so similar changes will fix all these conditions.","pos":[24453,24535]},{"content":"Make the following changes to <ph id=\"ph1\">`AnalyzeNode`</ph>:","pos":[24536,24580],"source":" Make the following changes to `AnalyzeNode`:"},{"content":"Your semantic analysis examined a single variable declaration.","pos":[24584,24646]},{"content":"This code needs to be in a <ph id=\"ph1\">`foreach`</ph> loop that examines all the variables declared in the same statement.","pos":[24647,24752],"source":" This code needs to be in a `foreach` loop that examines all the variables declared in the same statement."},{"content":"Each declared variable needs to have an initializer.","pos":[24755,24807]},{"content":"Each declared variable's initializer must be a compile-time constant.","pos":[24810,24879]},{"pos":[24881,24950],"content":"In your <ph id=\"ph1\">`AnalyzeNode`</ph> method, replace the original semantic analysis:","source":"In your `AnalyzeNode` method, replace the original semantic analysis:"},{"content":"with the following code snippet:","pos":[25469,25501]},{"content":"The first <ph id=\"ph1\">`foreach`</ph> loop examines each variable declaration using syntactic analysis.","pos":[26484,26569],"source":"The first `foreach` loop examines each variable declaration using syntactic analysis."},{"content":"The first check guarantees that the variable has an initializer.","pos":[26570,26634]},{"content":"The second check guarantees that the initializer is a constant.","pos":[26635,26698]},{"content":"The second loop has the original semantic analysis.","pos":[26699,26750]},{"content":"The semantic checks are in a separate loop because it has a greater impact on performance.","pos":[26751,26841]},{"content":"Run your tests again, and you should see them all pass.","pos":[26842,26897]},{"pos":[26902,26922],"content":"Add the final polish","linkify":"Add the final polish","nodes":[{"content":"Add the final polish","pos":[0,20]}]},{"content":"You're almost done.","pos":[26924,26943]},{"content":"There are a few more conditions for your analyzer to handle.","pos":[26944,27004]},{"content":"Visual Studio calls analyzers while the user is writing code.","pos":[27005,27066]},{"content":"It's often the case that your analyzer will be called for code that doesn't compile.","pos":[27067,27151]},{"content":"The diagnostic analyzer's <ph id=\"ph1\">`AnalyzeNode`</ph> method does not check to see if the constant value is convertible to the variable type.","pos":[27152,27279],"source":" The diagnostic analyzer's `AnalyzeNode` method does not check to see if the constant value is convertible to the variable type."},{"content":"So, the current implementation will happily convert an incorrect declaration such as int i = \"abc\"' to a local constant.","pos":[27280,27400]},{"content":"Add a source string constant for that condition:","pos":[27401,27449]},{"content":"In addition, reference types are not handled properly.","pos":[27698,27752]},{"content":"The only constant value allowed for a reference type is <ph id=\"ph1\">`null`</ph>, except in this case of <ph id=\"ph2\">&lt;xref:System.String?displayProperty=nameWIthType&gt;</ph>, which allows string literals.","pos":[27753,27920],"source":" The only constant value allowed for a reference type is `null`, except in this case of <xref:System.String?displayProperty=nameWIthType>, which allows string literals."},{"content":"In other words, <ph id=\"ph1\">`const string s = \"abc\"`</ph> is legal, but <ph id=\"ph2\">`const object s = \"abc\"`</ph> is not.","pos":[27921,28008],"source":" In other words, `const string s = \"abc\"` is legal, but `const object s = \"abc\"` is not."},{"content":"This code snippet verifies that condition:","pos":[28009,28051]},{"content":"To be thorough, you need to add another test to make sure that you can create a constant declaration for a string.","pos":[28304,28418]},{"content":"The following snippet defines both the code that raises the diagnostic, and the code after the fix has been applied:","pos":[28419,28535]},{"content":"Finally, if a variable is declared with the <ph id=\"ph1\">`var`</ph> keyword, the code fix does the wrong thing and generates a <ph id=\"ph2\">`const var`</ph> declaration, which is not supported by the C# language.","pos":[28753,28929],"source":"Finally, if a variable is declared with the `var` keyword, the code fix does the wrong thing and generates a `const var` declaration, which is not supported by the C# language."},{"content":"To fix this bug, the code fix must replace the <ph id=\"ph1\">`var`</ph> keyword with the inferred type's name:","pos":[28930,29021],"source":" To fix this bug, the code fix must replace the `var` keyword with the inferred type's name:"},{"content":"These changes update the data row declarations for both tests.","pos":[29269,29331]},{"content":"The following code shows these tests with all data row attributes:","pos":[29332,29398]},{"content":"Fortunately, all of the above bugs can be addressed using the same techniques that you just learned.","pos":[29585,29685]},{"content":"To fix the first bug, first open <bpt id=\"p1\">**</bpt>DiagnosticAnalyzer.cs<ept id=\"p1\">**</ept> and locate the foreach loop where each of the local declaration's initializers are checked to ensure that they're assigned with constant values.","pos":[29687,29890],"source":"To fix the first bug, first open **DiagnosticAnalyzer.cs** and locate the foreach loop where each of the local declaration's initializers are checked to ensure that they're assigned with constant values."},{"content":"Immediately <bpt id=\"p1\">_</bpt>before<ept id=\"p1\">_</ept> the first foreach loop, call <ph id=\"ph1\">`context.SemanticModel.GetTypeInfo()`</ph> to retrieve detailed information about the declared type of the local declaration:","pos":[29891,30061],"source":" Immediately _before_ the first foreach loop, call `context.SemanticModel.GetTypeInfo()` to retrieve detailed information about the declared type of the local declaration:"},{"content":"Then, inside your <ph id=\"ph1\">`foreach`</ph> loop, check each initializer to make sure it's convertible to the variable type.","pos":[30222,30330],"source":"Then, inside your `foreach` loop, check each initializer to make sure it's convertible to the variable type."},{"content":"Add the following check after ensuring that the initializer is a constant:","pos":[30331,30405]},{"content":"The next change builds upon the last one.","pos":[30711,30752]},{"content":"Before the closing curly brace of the first foreach loop, add the following code to check the type of the local declaration when the constant is a string or null.","pos":[30753,30915]},{"content":"You must write a bit more code in your code fix provider to replace the var' keyword with the correct type name.","pos":[31373,31485]},{"content":"Return to <bpt id=\"p1\">**</bpt>CodeFixProvider.cs<ept id=\"p1\">**</ept>.","pos":[31486,31519],"source":" Return to **CodeFixProvider.cs**."},{"content":"The code you'll add does the following steps:","pos":[31520,31565]},{"pos":[31569,31631],"content":"Check if the declaration is a <ph id=\"ph1\">`var`</ph> declaration, and if it is:","source":"Check if the declaration is a `var` declaration, and if it is:"},{"content":"Create a new type for the inferred type.","pos":[31634,31674]},{"content":"Make sure the type declaration is not an alias.","pos":[31677,31724]},{"content":"If so, it is legal to declare <ph id=\"ph1\">`const var`</ph>.","pos":[31725,31767],"source":" If so, it is legal to declare `const var`."},{"content":"Make sure that <ph id=\"ph1\">`var`</ph> isn't a type name in this program.","pos":[31770,31825],"source":"Make sure that `var` isn't a type name in this program."},{"content":"(If so, <ph id=\"ph1\">`const var`</ph> is legal).","pos":[31826,31856],"source":" (If so, `const var` is legal)."},{"content":"Simplify the full type name","pos":[31859,31886]},{"content":"That sounds like a lot of code.","pos":[31888,31919]},{"content":"It's not.","pos":[31920,31929]},{"content":"Replace the line that declares and initializes <ph id=\"ph1\">`newLocal`</ph> with the following code.","pos":[31930,32012],"source":" Replace the line that declares and initializes `newLocal` with the following code."},{"content":"It goes immediately after the initialization of <ph id=\"ph1\">`newModifiers`</ph>:","pos":[32013,32076],"source":" It goes immediately after the initialization of `newModifiers`:"},{"pos":[32269,32382],"content":"You'll need to add one <ph id=\"ph1\">`using`</ph> statement to use the <ph id=\"ph2\">&lt;xref:Microsoft.CodeAnalysis.Simplification.Simplifier&gt;</ph> type:","source":"You'll need to add one `using` statement to use the <xref:Microsoft.CodeAnalysis.Simplification.Simplifier> type:"},{"content":"Run your tests, and they should all pass.","pos":[32444,32485]},{"content":"Congratulate yourself by running your finished analyzer.","pos":[32486,32542]},{"content":"Press Ctrl+F5 to run the analyzer project in a second instance of Visual Studio with the Roslyn Preview extension loaded.","pos":[32543,32664]},{"content":"In the second Visual Studio instance, create a new C# Console Application project and add <ph id=\"ph1\">`int x = \"abc\";`</ph> to the Main method.","pos":[32668,32794],"source":"In the second Visual Studio instance, create a new C# Console Application project and add `int x = \"abc\";` to the Main method."},{"content":"Thanks to the first bug fix, no warning should be reported for this local variable declaration (though there's a compiler error as expected).","pos":[32795,32936]},{"content":"Next, add <ph id=\"ph1\">`object s = \"abc\";`</ph> to the Main method.","pos":[32939,32988],"source":"Next, add `object s = \"abc\";` to the Main method."},{"content":"Because of the second bug fix, no warning should be reported.","pos":[32989,33050]},{"content":"Finally, add another local variable that uses the <ph id=\"ph1\">`var`</ph> keyword.","pos":[33053,33117],"source":"Finally, add another local variable that uses the `var` keyword."},{"content":"You'll see that a warning is reported and a suggestion appears beneath to the left.","pos":[33118,33201]},{"content":"Move the editor caret over the squiggly underline and press Ctrl+.","pos":[33204,33270]},{"content":"to display the suggested code fix.","pos":[33271,33305]},{"content":"Upon selecting your code fix, note that the var' keyword is now handled correctly.","pos":[33306,33388]},{"content":"Finally, add the following code:","pos":[33390,33422]},{"content":"After these changes, you get red squiggles only on the first two variables.","pos":[33477,33552]},{"content":"Add <ph id=\"ph1\">`const`</ph> to both <ph id=\"ph2\">`i`</ph> and <ph id=\"ph3\">`j`</ph>, and you get a new warning on <ph id=\"ph4\">`k`</ph> because it can now be <ph id=\"ph5\">`const`</ph>.","pos":[33553,33649],"source":" Add `const` to both `i` and `j`, and you get a new warning on `k` because it can now be `const`."},{"content":"Congratulations!","pos":[33651,33667]},{"content":"You've created your first .NET Compiler Platform extension that performs on-the-fly code analysis to detect an issue and provides a quick fix to correct it.","pos":[33668,33824]},{"content":"Along the way, you've learned many of the code APIs that are part of the .NET Compiler Platform SDK (Roslyn APIs).","pos":[33825,33939]},{"content":"You can check your work against the <bpt id=\"p1\">[</bpt>completed sample<ept id=\"p1\">](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/Tutorials/MakeConst)</ept> in our samples GitHub repository.","pos":[33940,34113],"source":" You can check your work against the [completed sample](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/Tutorials/MakeConst) in our samples GitHub repository."},{"content":"Or you can download <bpt id=\"p1\">[</bpt>zip file of the completed project<ept id=\"p1\">](https://github.com/dotnet/samples/blob/master/csharp/roslyn-sdk/Tutorials/MakeConst.zip)</ept>","pos":[34114,34258],"source":" Or you can download [zip file of the completed project](https://github.com/dotnet/samples/blob/master/csharp/roslyn-sdk/Tutorials/MakeConst.zip)"},{"pos":[34263,34278],"content":"Other resources","linkify":"Other resources","nodes":[{"content":"Other resources","pos":[0,15]}]},{"pos":[34282,34351],"content":"<bpt id=\"p1\">[</bpt>Get started with syntax analysis<ept id=\"p1\">](../get-started/syntax-analysis.md)</ept>","source":"[Get started with syntax analysis](../get-started/syntax-analysis.md)"},{"pos":[34354,34427],"content":"<bpt id=\"p1\">[</bpt>Get started with semantic analysis<ept id=\"p1\">](../get-started/semantic-analysis.md)</ept>","source":"[Get started with semantic analysis](../get-started/semantic-analysis.md)"}]}