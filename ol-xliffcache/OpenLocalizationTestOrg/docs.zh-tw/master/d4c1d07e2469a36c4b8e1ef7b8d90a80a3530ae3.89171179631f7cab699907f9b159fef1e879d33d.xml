{"content":"---\ntitle: \"Constrained Execution Regions\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"constrained execution regions\"\n  - \"CERs\"\nms.assetid: 99354547-39c1-4b0b-8553-938e8f8d1808\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# Constrained Execution Regions\nA constrained execution region (CER) is part of a mechanism for authoring reliable managed code. A CER defines an area in which the common language runtime (CLR) is constrained from throwing out-of-band exceptions that would prevent the code in the area from executing in its entirety. Within that region, user code is constrained from executing code that would result in the throwing of out-of-band exceptions. The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method must immediately precede a `try` block and marks `catch`, `finally`, and `fault` blocks as constrained execution regions. Once marked as a constrained region, code must only call other code with strong reliability contracts, and code should not allocate or make virtual calls to unprepared or unreliable methods unless the code is prepared to handle failures. The CLR delays thread aborts for code that is executing in a CER.  \n  \n Constrained execution regions are used in different forms in the CLR in addition to an annotated `try` block, notably critical finalizers executing in classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class and code executed using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.  \n  \n## CER Advance Preparation  \n The CLR prepares CERs in advance to avoid out-of-memory conditions. Advance preparation is required so the CLR does not cause an out of memory condition during just-in-time compilation or type loading.  \n  \n The developer is required to indicate that a code region is a CER:  \n  \n-   The top level CER region and methods in the full call graph that have the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute applied are prepared in advance. The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> can only state guarantees of <xref:System.Runtime.ConstrainedExecution.Cer.Success> or <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>.  \n  \n-   Advance preparation cannot be performed for calls that cannot be statically determined, such as virtual dispatch. Use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A> method in these cases. When using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method, the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute should be applied to the clean up code.  \n  \n## Constraints  \n Users are constrained in the type of code they can write in a CER. The code cannot cause an out-of-band exception, such as might result from the following operations:  \n  \n-   Explicit allocation.  \n  \n-   Boxing.  \n  \n-   Acquiring a lock.  \n  \n-   Calling unprepared methods virtually.  \n  \n-   Calling methods with a weak or nonexistent reliability contract.  \n  \n In the .NET Framework version 2.0, these constraints are guidelines. Diagnostics are provided through code analysis tools.  \n  \n## Reliability Contracts  \n The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> is a custom attribute that documents the reliability guarantees and the corruption state of a given method.  \n  \n### Reliability Guarantees  \n Reliability guarantees, represented by <xref:System.Runtime.ConstrainedExecution.Cer> enumeration values, indicate the degree of reliability of a given method:  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>. Under exceptional conditions, the method might fail. In this case, the method reports back to the calling method whether it succeeded or failed. The method must be contained in a CER to ensure that it can report the return value.  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Cer.None>. The method, type, or assembly has no concept of a CER and is most likely not safe to call within a CER without substantial mitigation from state corruption. It does not take advantage of CER guarantees. This implies the following:  \n  \n    1.  Under exceptional conditions the method might fail.  \n  \n    2.  The method might or might not report that it failed.  \n  \n    3.  The method is not written to use a CER, the most likely scenario.  \n  \n    4.  If a method, type, or assembly is not explicitly identified to succeed, it is implicitly identified as <xref:System.Runtime.ConstrainedExecution.Cer.None>.  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Cer.Success>. Under exceptional conditions, the method is guaranteed to succeed. To achieve this level of reliability you should always construct a CER around the method that is called, even when it is called from within a non-CER region. A method is successful if it accomplishes what is intended, although success can be viewed subjectively. For example, marking Count with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref:System.Collections.ArrayList> and it can never leave the internal fields in an undetermined state.  However, the <xref:System.Threading.Interlocked.CompareExchange%2A> method is marked as success as well, with the understanding that success may mean the value could not be replaced with a new value due to a race condition.  The key point is that the method behaves in the way it is documented to behave, and CER code does not need to be written to expect any unusual behavior beyond what correct but unreliable code would look like.  \n  \n### Corruption levels  \n Corruption levels, represented by <xref:System.Runtime.ConstrainedExecution.Consistency> enumeration values, indicate how much state may be corrupted in a given environment:  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>. Under exceptional conditions, the common language runtime (CLR) makes no guarantees regarding state consistency in the current application domain.  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>. Under exceptional conditions, the method is guaranteed to limit state corruption to the current instance.  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>, Under exceptional conditions, the CLR makes no guarantees regarding state consistency; that is, the condition might corrupt the process.  \n  \n-   <xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>. Under exceptional conditions, the method is guaranteed not to corrupt state.  \n  \n## Reliability try/catch/finally  \n The reliability `try/catch/finally` is an exception handling mechanism with the same level of predictability guarantees as the unmanaged version. The `catch/finally` block is the CER. Methods in the block require advance preparation and must be noninterruptible.  \n  \n In the .NET Framework version 2.0, code informs the runtime that a try is reliable by calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> immediately preceding a try block. <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> is a member of <xref:System.Runtime.CompilerServices.RuntimeHelpers>, a compiler support class. Call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> directly pending its availability through compilers.  \n  \n## Noninterruptible Regions  \n A noninterruptible region groups a set of instructions into a CER.  \n  \n In .NET Framework version 2.0, pending availability through compiler support, user code creates non-interruptible regions with a reliable try/catch/finally that contains an empty try/catch block preceded by a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method call.  \n  \n## Critical Finalizer Object  \n A <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> guarantees that garbage collection will execute the finalizer. Upon allocation, the finalizer and its call graph are prepared in advance. The finalizer method executes in a CER, and must obey all the constraints on CERs and finalizers.  \n  \n Any types inheriting from <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> are guaranteed to have their finalizer execute within a CER. Implement <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> in <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.  \n  \n## Code Not Permitted in CERs  \n The following operations are not permitted in CERs:  \n  \n-   Explicit allocations.  \n  \n-   Acquiring a lock.  \n  \n-   Boxing.  \n  \n-   Multidimensional array access.  \n  \n-   Method calls through reflection.  \n  \n-   <xref:System.Threading.Monitor.Enter%2A> or <xref:System.IO.FileStream.Lock%2A>.  \n  \n-   Security checks. Do not perform demands, only link demands.  \n  \n-   <xref:System.Reflection.Emit.OpCodes.Isinst> and <xref:System.Reflection.Emit.OpCodes.Castclass> for COM objects and proxies  \n  \n-   Getting or setting fields on a transparent proxy.  \n  \n-   Serialization.  \n  \n-   Function pointers and delegates.  \n  \n## See also\n\n- [Reliability Best Practices](../../../docs/framework/performance/reliability-best-practices.md)\n","nodes":[{"pos":[4,219],"embed":true,"restype":"x-metadata","content":"title: \"Constrained Execution Regions\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"constrained execution regions\"\n  - \"CERs\"\nms.assetid: 99354547-39c1-4b0b-8553-938e8f8d1808\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"Constrained Execution Regions","nodes":[{"pos":[0,29],"content":"Constrained Execution Regions","nodes":[{"content":"Constrained Execution Regions","pos":[0,29]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[226,255],"content":"Constrained Execution Regions","linkify":"Constrained Execution Regions","nodes":[{"content":"Constrained Execution Regions","pos":[0,29]}]},{"content":"A constrained execution region (CER) is part of a mechanism for authoring reliable managed code.","pos":[256,352]},{"content":"A CER defines an area in which the common language runtime (CLR) is constrained from throwing out-of-band exceptions that would prevent the code in the area from executing in its entirety.","pos":[353,541]},{"content":"Within that region, user code is constrained from executing code that would result in the throwing of out-of-band exceptions.","pos":[542,667]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method must immediately precede a <ph id=\"ph2\">`try`</ph> block and marks <ph id=\"ph3\">`catch`</ph>, <ph id=\"ph4\">`finally`</ph>, and <ph id=\"ph5\">`fault`</ph> blocks as constrained execution regions.","pos":[668,883],"source":" The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method must immediately precede a `try` block and marks `catch`, `finally`, and `fault` blocks as constrained execution regions."},{"content":"Once marked as a constrained region, code must only call other code with strong reliability contracts, and code should not allocate or make virtual calls to unprepared or unreliable methods unless the code is prepared to handle failures.","pos":[884,1121]},{"content":"The CLR delays thread aborts for code that is executing in a CER.","pos":[1122,1187]},{"pos":[1194,1568],"content":"Constrained execution regions are used in different forms in the CLR in addition to an annotated <ph id=\"ph1\">`try`</ph> block, notably critical finalizers executing in classes derived from the <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class and code executed using the <ph id=\"ph3\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.","source":"Constrained execution regions are used in different forms in the CLR in addition to an annotated `try` block, notably critical finalizers executing in classes derived from the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class and code executed using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method."},{"pos":[1577,1600],"content":"CER Advance Preparation","linkify":"CER Advance Preparation","nodes":[{"content":"CER Advance Preparation","pos":[0,23]}]},{"content":"The CLR prepares CERs in advance to avoid out-of-memory conditions.","pos":[1604,1671]},{"content":"Advance preparation is required so the CLR does not cause an out of memory condition during just-in-time compilation or type loading.","pos":[1672,1805]},{"content":"The developer is required to indicate that a code region is a CER:","pos":[1812,1878]},{"content":"The top level CER region and methods in the full call graph that have the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute applied are prepared in advance.","pos":[1888,2076],"source":"The top level CER region and methods in the full call graph that have the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute applied are prepared in advance."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> can only state guarantees of <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.Cer.Success&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Runtime.ConstrainedExecution.Cer.MayFail&gt;</ph>.","pos":[2077,2295],"source":" The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> can only state guarantees of <xref:System.Runtime.ConstrainedExecution.Cer.Success> or <xref:System.Runtime.ConstrainedExecution.Cer.MayFail>."},{"content":"Advance preparation cannot be performed for calls that cannot be statically determined, such as virtual dispatch.","pos":[2305,2418]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A&gt;</ph> method in these cases.","pos":[2419,2520],"source":" Use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%2A> method in these cases."},{"content":"When using the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method, the <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute should be applied to the clean up code.","pos":[2521,2756],"source":" When using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method, the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute should be applied to the clean up code."},{"pos":[2765,2776],"content":"Constraints","linkify":"Constraints","nodes":[{"content":"Constraints","pos":[0,11]}]},{"content":"Users are constrained in the type of code they can write in a CER.","pos":[2780,2846]},{"content":"The code cannot cause an out-of-band exception, such as might result from the following operations:","pos":[2847,2946]},{"content":"Explicit allocation.","pos":[2956,2976]},{"content":"Boxing.","pos":[2986,2993]},{"content":"Acquiring a lock.","pos":[3003,3020]},{"content":"Calling unprepared methods virtually.","pos":[3030,3067]},{"content":"Calling methods with a weak or nonexistent reliability contract.","pos":[3077,3141]},{"content":"In the .NET Framework version 2.0, these constraints are guidelines.","pos":[3148,3216]},{"content":"Diagnostics are provided through code analysis tools.","pos":[3217,3270]},{"pos":[3279,3300],"content":"Reliability Contracts","linkify":"Reliability Contracts","nodes":[{"content":"Reliability Contracts","pos":[0,21]}]},{"pos":[3304,3487],"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> is a custom attribute that documents the reliability guarantees and the corruption state of a given method.","source":"The <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> is a custom attribute that documents the reliability guarantees and the corruption state of a given method."},{"pos":[3497,3519],"content":"Reliability Guarantees","linkify":"Reliability Guarantees","nodes":[{"content":"Reliability Guarantees","pos":[0,22]}]},{"pos":[3523,3682],"content":"Reliability guarantees, represented by <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph> enumeration values, indicate the degree of reliability of a given method:","source":"Reliability guarantees, represented by <xref:System.Runtime.ConstrainedExecution.Cer> enumeration values, indicate the degree of reliability of a given method:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Cer.MayFail&gt;</ph>.","pos":[3692,3747],"source":"<xref:System.Runtime.ConstrainedExecution.Cer.MayFail>."},{"content":"Under exceptional conditions, the method might fail.","pos":[3748,3800]},{"content":"In this case, the method reports back to the calling method whether it succeeded or failed.","pos":[3801,3892]},{"content":"The method must be contained in a CER to ensure that it can report the return value.","pos":[3893,3977]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Cer.None&gt;</ph>.","pos":[3987,4039],"source":"<xref:System.Runtime.ConstrainedExecution.Cer.None>."},{"content":"The method, type, or assembly has no concept of a CER and is most likely not safe to call within a CER without substantial mitigation from state corruption.","pos":[4040,4196]},{"content":"It does not take advantage of CER guarantees.","pos":[4197,4242]},{"content":"This implies the following:","pos":[4243,4270]},{"content":"Under exceptional conditions the method might fail.","pos":[4284,4335]},{"content":"The method might or might not report that it failed.","pos":[4349,4401]},{"content":"The method is not written to use a CER, the most likely scenario.","pos":[4415,4480]},{"pos":[4494,4649],"content":"If a method, type, or assembly is not explicitly identified to succeed, it is implicitly identified as <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Cer.None&gt;</ph>.","source":"If a method, type, or assembly is not explicitly identified to succeed, it is implicitly identified as <xref:System.Runtime.ConstrainedExecution.Cer.None>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Cer.Success&gt;</ph>.","pos":[4659,4714],"source":"<xref:System.Runtime.ConstrainedExecution.Cer.Success>."},{"content":"Under exceptional conditions, the method is guaranteed to succeed.","pos":[4715,4781]},{"content":"To achieve this level of reliability you should always construct a CER around the method that is called, even when it is called from within a non-CER region.","pos":[4782,4939]},{"content":"A method is successful if it accomplishes what is intended, although success can be viewed subjectively.","pos":[4940,5044]},{"content":"For example, marking Count with <ph id=\"ph1\">`ReliabilityContractAttribute(Cer.Success)`</ph> implies that when it is run under a CER, it always returns a count of the number of elements in the <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph> and it can never leave the internal fields in an undetermined state.","pos":[5045,5325],"source":" For example, marking Count with `ReliabilityContractAttribute(Cer.Success)` implies that when it is run under a CER, it always returns a count of the number of elements in the <xref:System.Collections.ArrayList> and it can never leave the internal fields in an undetermined state."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is marked as success as well, with the understanding that success may mean the value could not be replaced with a new value due to a race condition.","pos":[5327,5550],"source":"  However, the <xref:System.Threading.Interlocked.CompareExchange%2A> method is marked as success as well, with the understanding that success may mean the value could not be replaced with a new value due to a race condition."},{"content":"The key point is that the method behaves in the way it is documented to behave, and CER code does not need to be written to expect any unusual behavior beyond what correct but unreliable code would look like.","pos":[5552,5760]},{"pos":[5770,5787],"content":"Corruption levels","linkify":"Corruption levels","nodes":[{"content":"Corruption levels","pos":[0,17]}]},{"pos":[5791,5964],"content":"Corruption levels, represented by <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency&gt;</ph> enumeration values, indicate how much state may be corrupted in a given environment:","source":"Corruption levels, represented by <xref:System.Runtime.ConstrainedExecution.Consistency> enumeration values, indicate how much state may be corrupted in a given environment:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain&gt;</ph>.","pos":[5974,6049],"source":"<xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain>."},{"content":"Under exceptional conditions, the common language runtime (CLR) makes no guarantees regarding state consistency in the current application domain.","pos":[6050,6196]},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance&gt;</ph>.","pos":[6206,6280],"source":"<xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance>."},{"content":"Under exceptional conditions, the method is guaranteed to limit state corruption to the current instance.","pos":[6281,6386]},{"pos":[6396,6606],"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess&gt;</ph>, Under exceptional conditions, the CLR makes no guarantees regarding state consistency; that is, the condition might corrupt the process.","source":"<xref:System.Runtime.ConstrainedExecution.Consistency.MayCorruptProcess>, Under exceptional conditions, the CLR makes no guarantees regarding state consistency; that is, the condition might corrupt the process."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState&gt;</ph>.","pos":[6616,6691],"source":"<xref:System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState>."},{"content":"Under exceptional conditions, the method is guaranteed not to corrupt state.","pos":[6692,6768]},{"pos":[6777,6806],"content":"Reliability try/catch/finally","linkify":"Reliability try/catch/finally","nodes":[{"content":"Reliability try/catch/finally","pos":[0,29]}]},{"content":"The reliability <ph id=\"ph1\">`try/catch/finally`</ph> is an exception handling mechanism with the same level of predictability guarantees as the unmanaged version.","pos":[6810,6955],"source":"The reliability `try/catch/finally` is an exception handling mechanism with the same level of predictability guarantees as the unmanaged version."},{"content":"The <ph id=\"ph1\">`catch/finally`</ph> block is the CER.","pos":[6956,6993],"source":" The `catch/finally` block is the CER."},{"content":"Methods in the block require advance preparation and must be noninterruptible.","pos":[6994,7072]},{"content":"In the .NET Framework version 2.0, code informs the runtime that a try is reliable by calling <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> immediately preceding a try block.","pos":[7079,7290],"source":"In the .NET Framework version 2.0, code informs the runtime that a try is reliable by calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> immediately preceding a try block."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> is a member of <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers&gt;</ph>, a compiler support class.","pos":[7291,7469],"source":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> is a member of <xref:System.Runtime.CompilerServices.RuntimeHelpers>, a compiler support class."},{"content":"Call <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> directly pending its availability through compilers.","pos":[7470,7610],"source":" Call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> directly pending its availability through compilers."},{"pos":[7619,7643],"content":"Noninterruptible Regions","linkify":"Noninterruptible Regions","nodes":[{"content":"Noninterruptible Regions","pos":[0,24]}]},{"content":"A noninterruptible region groups a set of instructions into a CER.","pos":[7647,7713]},{"pos":[7720,8024],"content":"In .NET Framework version 2.0, pending availability through compiler support, user code creates non-interruptible regions with a reliable try/catch/finally that contains an empty try/catch block preceded by a <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method call.","source":"In .NET Framework version 2.0, pending availability through compiler support, user code creates non-interruptible regions with a reliable try/catch/finally that contains an empty try/catch block preceded by a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method call."},{"pos":[8033,8058],"content":"Critical Finalizer Object","linkify":"Critical Finalizer Object","nodes":[{"content":"Critical Finalizer Object","pos":[0,25]}]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> guarantees that garbage collection will execute the finalizer.","pos":[8062,8193],"source":"A <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> guarantees that garbage collection will execute the finalizer."},{"content":"Upon allocation, the finalizer and its call graph are prepared in advance.","pos":[8194,8268]},{"content":"The finalizer method executes in a CER, and must obey all the constraints on CERs and finalizers.","pos":[8269,8366]},{"content":"Any types inheriting from <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> are guaranteed to have their finalizer execute within a CER.","pos":[8373,8565],"source":"Any types inheriting from <xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> are guaranteed to have their finalizer execute within a CER."},{"content":"Implement <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> in <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> derived classes to execute any code that is required to free the handle.","pos":[8566,8766],"source":" Implement <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> in <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle."},{"pos":[8775,8801],"content":"Code Not Permitted in CERs","linkify":"Code Not Permitted in CERs","nodes":[{"content":"Code Not Permitted in CERs","pos":[0,26]}]},{"content":"The following operations are not permitted in CERs:","pos":[8805,8856]},{"content":"Explicit allocations.","pos":[8866,8887]},{"content":"Acquiring a lock.","pos":[8897,8914]},{"content":"Boxing.","pos":[8924,8931]},{"content":"Multidimensional array access.","pos":[8941,8971]},{"content":"Method calls through reflection.","pos":[8981,9013]},{"pos":[9023,9103],"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph>.","source":"<xref:System.Threading.Monitor.Enter%2A> or <xref:System.IO.FileStream.Lock%2A>."},{"content":"Security checks.","pos":[9113,9129]},{"content":"Do not perform demands, only link demands.","pos":[9130,9172]},{"pos":[9182,9306],"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.Emit.OpCodes.Isinst&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> for COM objects and proxies","source":"<xref:System.Reflection.Emit.OpCodes.Isinst> and <xref:System.Reflection.Emit.OpCodes.Castclass> for COM objects and proxies"},{"content":"Getting or setting fields on a transparent proxy.","pos":[9316,9365]},{"content":"Serialization.","pos":[9375,9389]},{"content":"Function pointers and delegates.","pos":[9399,9431]},{"pos":[9440,9448],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9452,9547],"content":"<bpt id=\"p1\">[</bpt>Reliability Best Practices<ept id=\"p1\">](../../../docs/framework/performance/reliability-best-practices.md)</ept>","source":"[Reliability Best Practices](../../../docs/framework/performance/reliability-best-practices.md)"}]}