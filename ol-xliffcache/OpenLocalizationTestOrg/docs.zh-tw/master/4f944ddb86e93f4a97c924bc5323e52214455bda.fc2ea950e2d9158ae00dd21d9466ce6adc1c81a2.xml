{"content":"---\ntitle: \"How to: Migrate Managed-Code DCOM to WCF\"\nms.date: \"03/30/2017\"\nms.assetid: 52961ffc-d1c7-4f83-832c-786444b951ba\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# How to: Migrate Managed-Code DCOM to WCF\nWindows Communication Foundation (WCF) is the recommended and secure choice over Distributed Component Object Model (DCOM) for managed code calls between servers and clients in a distributed environment. This article shows how you to migrate code from DCOM to WCF for the following scenarios.  \n  \n-   The remote service returns an object by-value to the client  \n  \n-   The client sends an object by-value to the remote service  \n  \n-   The remote service returns an object by-reference to the client  \n  \n For security reasons, sending an object by-reference from the client to the service is not allowed in WCF. A scenario that requires a conversation back and forth between client and server can be achieved in WCF using a duplex service.  For more information about duplex services, see [Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md).  \n  \n For more details about creating WCF services and clients for those services, see [Basic WCF Programming](../../../docs/framework/wcf/basic-wcf-programming.md), [Designing and Implementing Services](../../../docs/framework/wcf/designing-and-implementing-services.md), and [Building Clients](../../../docs/framework/wcf/building-clients.md).  \n  \n## DCOM example code  \n For these scenarios, the DCOM interfaces that are illustrated using WCF have the following structure:  \n  \n```csharp  \n[ComVisible(true)]  \n[Guid(\"AA9C4CDB-55EA-4413-90D2-843F1A49E6E6\")]  \npublic interface IRemoteService  \n{  \n   Customer GetObjectByValue();  \n   IRemoteObject GetObjectByReference();  \n   void SendObjectByValue(Customer customer);  \n}  \n  \n[ComVisible(true)]  \n[Guid(\"A12C98DE-B6A1-463D-8C24-81E4BBC4351B\")]  \npublic interface IRemoteObject  \n{  \n}  \n  \npublic class Customer  \n{  \n}  \n```  \n  \n## The service returns an object by-value  \n For this scenario, you make a call to a service and it method returns an object, which is passed by-value from the server to the client. This scenario represents the following COM call:  \n  \n```csharp  \npublic interface IRemoteService  \n{  \n    Customer GetObjectByValue();  \n}  \n```  \n  \n In this scenario, the client receives a deserialized copy of an object from the remote service. The client can interact with this local copy without calling back to the service.  In other words, the client is guaranteed the service will not be involved in any way when methods on the local copy are called. WCF always returns objects from the service by value, so the following steps describe creating a regular WCF service.  \n  \n### Step 1: Define the WCF service interface  \n Define a public interface for the WCF service and mark it with the [<xref:System.ServiceModel.ServiceContractAttribute>] attribute.  Mark the methods you want to expose to clients with the [<xref:System.ServiceModel.OperationContractAttribute>] attribute. The following example shows using these attributes to identify the server-side interface and interface methods a client can call. The method used for this scenario is shown in bold.  \n  \n```csharp  \nusing System.Runtime.Serialization;  \nusing System.ServiceModel;  \nusing System.ServiceModel.Web;   \n. . .  \n[ServiceContract]  \npublic interface ICustomerManager  \n{  \n    [OperationContract]  \n    void StoreCustomer(Customer customer);  \n  \n    [OperationContract]     Customer GetCustomer(string firstName, string lastName);   \n  \n}  \n```  \n  \n### Step 2: Define the data contract  \n Next you should create a data contract for the service, which will describe how the data will be exchanged between the service and its clients.  Classes described in the data contract should be marked with the [<xref:System.Runtime.Serialization.DataContractAttribute>] attribute. The individual properties or fields you want visible to both client and server should be marked with the [<xref:System.Runtime.Serialization.DataMemberAttribute>] attribute. If you want types derived from a class in the data contract to be allowed, you must identify them with the [<xref:System.Runtime.Serialization.KnownTypeAttribute>] attribute. WCF will only serialize or deserialize types in the service interface and types identified as known types. If you attempt to use a type that is not a known type, an exception will occur.  \n  \n For more information about data contracts, see [Data Contracts](../../../docs/framework/wcf/samples/data-contracts.md).  \n  \n```csharp  \n[DataContract]  \n[KnownType(typeof(PremiumCustomer))]  \npublic class Customer  \n{  \n    [DataMember]  \n    public string Firstname;  \n    [DataMember]  \n    public string Lastname;  \n    [DataMember]  \n    public Address DefaultDeliveryAddress;  \n    [DataMember]  \n    public Address DefaultBillingAddress;  \n}  \n [DataContract]  \npublic class PremiumCustomer : Customer  \n{  \n    [DataMember]  \n    public int AccountID;  \n}  \n  \n [DataContract]  \npublic class Address  \n{  \n    [DataMember]  \n    public string Street;  \n    [DataMember]  \n    public string Zipcode;  \n    [DataMember]  \n    public string City;  \n    [DataMember]  \n    public string State;  \n    [DataMember]  \n    public string Country;  \n}  \n```  \n  \n### Step 3: Implement the WCF service  \n Next, you should implement the WCF service class that implements the interface you defined in the previous step.  \n  \n```csharp  \npublic class CustomerService: ICustomerManager    \n{  \n    public void StoreCustomer(Customer customer)  \n    {  \n        // write to a database  \n    }  \n    public Customer GetCustomer(string firstName, string lastName)  \n    {  \n        // read from a database  \n    }  \n}  \n```  \n  \n### Step 4: Configure the service and the client  \n To run a WCF service, you need to declare an endpoint that exposes that service interface at a specific URL using a specific WCF binding. A binding specifies the transport, encoding and protocol details for the clients and server to communicate. You typically add bindings to the service project’s configuration file (web.config). The following shows a binding entry for the example service:  \n  \n```xml  \n<configuration>  \n  <system.serviceModel>  \n    <services>  \n      <service name=\"Server.CustomerService\">  \n        <endpoint address=\"http://localhost:8083/CustomerManager\"   \n                  binding=\"basicHttpBinding\"  \n                  contract=\"Shared.ICustomerManager\" />  \n      </service>  \n    </services>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n Next, you need to configure the client to match the binding information specified by the service. To do so, add the following to the client’s application configuration (app.config) file.  \n  \n```xml  \n<configuration>  \n  <system.serviceModel>  \n    <client>  \n      <endpoint name=\"customermanager\"   \n                address=\"http://localhost:8083/CustomerManager\"   \n                binding=\"basicHttpBinding\"   \n                contract=\"Shared.ICustomerManager\"/>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n### Step 5: Run the service  \n Finally, you can self-host it in a console application by adding the following lines to the service app, and starting the app. For more information about other ways to host a WCF service application, [Hosting Services](../../../docs/framework/wcf/hosting-services.md).  \n  \n```csharp  \nServiceHost customerServiceHost = new ServiceHost(typeof(CustomerService));  \ncustomerServiceHost.Open();  \n```  \n  \n### Step 6: Call the service from the client  \n To call the service from the client, you need to create a channel factory for the service, and request a channel, which will enable you to directly call the `GetCustomer` method directly from the client. The channel implements the service’s interface and handles the underlying request/reply logic for you.  The return value from that method call is the deserialized copy of the service response.  \n  \n```csharp  \nChannelFactory<ICustomerManager> factory =   \n     new ChannelFactory<ICustomerManager>(\"customermanager\");  \nICustomerManager service = factory.CreateChannel();  \nCustomer customer = service.GetCustomer(\"Mary\", \"Smith\");  \n```  \n  \n## The client sends a by-value object to the server  \n In this scenario, the client sends an object to the server, by-value. This means that the server will receive a deserialized copy of the object.  The server can call methods on that copy and be guaranteed there is no callback into client code. As mentioned previously, normal WCF exchanges of data are by-value.  This guarantees that calling methods on one of these objects executes locally only – it will not invoke code on the client.  \n  \n This scenario represents the following COM method call:  \n  \n```csharp  \npublic interface IRemoteService  \n{  \n    void SendObjectByValue(Customer customer);  \n}  \n```  \n  \n This scenario uses the same service interface and data contract as shown in the first example. In addition, the client and service will be configured in the same way. In this example, a channel is created to send the object and run the same way. However, for this example, you will create a client that calls the service, passing an object by-value. The service method the client will call in the service contract is shown in bold:  \n  \n```csharp  \n[ServiceContract]  \npublic interface ICustomerManager  \n{  \n    [OperationContract]     void StoreCustomer(Customer customer);  \n  \n    [OperationContract]  \n    Customer GetCustomer(string firstName, string lastName);  \n}  \n```  \n  \n### Add code to the client that sends a by-value object  \n The following code shows how the client creates a new by-value customer object, creates a channel to communicate with the `ICustomerManager` service, and sends the customer object to it.  \n  \n The customer object will be serialized, and sent to the service, where it is deserialized by the service into a new copy of that object.  Any methods the service calls on this object will execute only locally on the server. It’s important to note that this code illustrates sending a derived type (`PremiumCustomer`).  The service contract expects a `Customer` object, but the service data contract uses the [<xref:System.Runtime.Serialization.KnownTypeAttribute>] attribute to indicate that `PremiumCustomer` is also allowed.  WCF will fail attempts to serialize or deserialize any other type via this service interface.  \n  \n```csharp  \nPremiumCustomer customer = new PremiumCustomer();  \ncustomer.Firstname = \"John\";  \ncustomer.Lastname = \"Doe\";  \ncustomer.DefaultBillingAddress = new Address();  \ncustomer.DefaultBillingAddress.Street = \"One Microsoft Way\";  \ncustomer.DefaultDeliveryAddress = customer.DefaultBillingAddress;  \ncustomer.AccountID = 42;  \n  \nChannelFactory<ICustomerManager> factory =  \n   new ChannelFactory<ICustomerManager>(\"customermanager\");  \nICustomerManager customerManager = factory.CreateChannel();  \ncustomerManager.StoreCustomer(customer);  \n```  \n  \n## The service returns an object by reference  \n For this scenario, the client app makes a call to the remote service and the method returns an object, which is passed by reference from the service to the client.  \n  \n As mentioned previously, WCF services always return object by value.  However, you can achieve a similar result by using the <xref:System.ServiceModel.EndpointAddress10> class.  The <xref:System.ServiceModel.EndpointAddress10> is a serializable by-value object that can be used by the client to obtain a sessionful by-reference object on the server.  \n  \n The behavior of the by-reference object in WCF shown in this scenario is different than DCOM.  In DCOM, the server can return a by-reference object to the client directly, and the client can call that object’s methods, which execute on the server.  In WCF, however, the object returned is always by-value.  The client must take that by-value object, represented by <xref:System.ServiceModel.EndpointAddress10> and use it to create its own sessionful by-reference object.  The client method calls on the sessionful object execute on the server.In other words, this by-reference object in WCF is a normal WCF service that is configured to be sessionful.  \n  \n In WCF, a session is a way of correlating multiple messages sent between two endpoints.  This means that once a client obtains a connection to this service, a session will be established between the client and the server.  The client will use a single unique instance of the server-side object for all its interactions within this single session. Sessionful WCF contracts are similar to connection-oriented network request/response patterns.  \n  \n This scenario is represented by the following DCOM method.  \n  \n```csharp  \npublic interface IRemoteService  \n{  \n    IRemoteObject GetObjectByReference();  \n}  \n```  \n  \n### Step 1: Define the Sessionful WCF service interface and implementation  \n First, define a WCF service interface that contains the sessionful object.  \n  \n In this code, the sessionful object is marked with the `ServiceContract` attribute, which identifies it as a regular WCF service interface.  In addition, the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property is set to indicate it will be a sessionful service.  \n  \n```csharp  \n[ServiceContract(SessionMode = SessionMode.Allowed)]  \npublic interface ISessionBoundObject  \n{  \n    [OperationContract]  \n    string GetCurrentValue();  \n  \n    [OperationContract]  \n    void SetCurrentValue(string value);  \n}  \n```  \n  \n The following code shows the service implementation.  \n  \n The service is marked with the [ServiceBehavior] attribute, and its InstanceContextMode property set to InstanceContextMode.PerSessions to indicate that a unique instance of this type should be created for each session.  \n  \n```csharp  \n[ServiceBehavior(InstanceContextMode = InstanceContextMode.PerSession)]  \n    public class MySessionBoundObject : ISessionBoundObject  \n    {  \n        private string _value;  \n  \n        public string GetCurrentValue()  \n        {  \n            return _value;  \n        }  \n  \n        public void SetCurrentValue(string val)  \n        {  \n            _value = val;  \n        }  \n  \n    }  \n```  \n  \n### Step 2: Define the WCF factory service for the sessionful object  \n The service that creates the sessionful object must be defined and implemented. The following code shows how to do this. This code creates another WCF service that returns an <xref:System.ServiceModel.EndpointAddress10> object.  This is a serializable form of an endpoint the can use to create the session-full object.  \n  \n```csharp  \n[ServiceContract]  \n    public interface ISessionBoundFactory  \n    {  \n        [OperationContract]  \n        EndpointAddress10 GetInstanceAddress();  \n    }  \n```  \n  \n Following is the implementation of this service. This implementation maintains a singleton channel factory to create sessionful objects.  When `GetInstanceAddress` is called, it creates a channel and creates an <xref:System.ServiceModel.EndpointAddress10> object that points to the remote address associated with this channel.   <xref:System.ServiceModel.EndpointAddress10> is a data type that can be returned to the client by-value.  \n  \n```csharp  \npublic class SessionBoundFactory : ISessionBoundFactory  \n    {  \n        public static ChannelFactory<ISessionBoundObject> _factory =   \n            new ChannelFactory<ISessionBoundObject>(\"sessionbound\");  \n  \n        public SessionBoundFactory()  \n        {  \n        }  \n  \n        public EndpointAddress10 GetInstanceAddress()  \n        {  \n            IClientChannel channel = (IClientChannel)_factory.CreateChannel();  \n            return EndpointAddress10.FromEndpointAddress(channel.RemoteAddress);  \n        }  \n    }  \n```  \n  \n### Step 3: Configure and start the WCF services  \n To host these services, you will need to make the following additions to the server’s configuration file (web.config).  \n  \n1.  Add a `<client>` section that describes the endpoint for the sessionful object.  In this scenario, the server also acts as a client and must be configured to enable this.  \n  \n2.  In the `<services>` section, declare service endpoints for the factory and sessionful object.  This enables the client to communicate with the service endpoints, acquire the <xref:System.ServiceModel.EndpointAddress10> and create the sessionful channel.  \n  \n Following is an example configuration file with these settings:  \n  \n```xml  \n<configuration>  \n  <system.serviceModel>  \n    <client>  \n      <endpoint name=\"sessionbound\"  \n                address=\"net.tcp://localhost:8081/SessionBoundObject\"  \n                binding=\"netTcpBinding\"  \n                contract=\"Shared.ISessionBoundObject\"/>  \n    </client>  \n  \n    <services>  \n      <service name=\"Server.MySessionBoundObject\">  \n        <endpoint address=\"net.tcp://localhost:8081/SessionBoundObject\"  \n                  binding=\"netTcpBinding\"   \n                  contract=\"Shared.ISessionBoundObject\" />  \n      </service>  \n      <service name=\"Server.SessionBoundFactory\">  \n        <endpoint address=\"net.tcp://localhost:8081/SessionBoundFactory\"  \n                  binding=\"netTcpBinding\"   \n                  contract=\"Shared.ISessionBoundFactory\" />  \n      </service>  \n    </services>  \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n Add the following lines to a console application, to self-host the service, and start the app.  \n  \n```csharp  \nServiceHost factoryHost = new ServiceHost(typeof(SessionBoundFactory));  \nfactoryHost.Open();  \n  \nServiceHost sessionBoundServiceHost = new ServiceHost(  \ntypeof(MySessionBoundObject));  \nsessionBoundServiceHost.Open();  \n```  \n  \n### Step 4: Configure the client and call the service  \n Configure the client to communicate with the WCF services by making the following entries in the project’s application configuration file (app.config).  \n  \n```xml  \n<configuration>  \n  <system.serviceModel>  \n    <client>  \n      <endpoint name=\"sessionbound\"   \n                address=\"net.tcp://localhost:8081/SessionBoundObject\"   \n                binding=\"netTcpBinding\"   \n                contract=\"Shared.ISessionBoundObject\"/>  \n      <endpoint name=\"factory\"   \n                address=\"net.tcp://localhost:8081/SessionBoundFactory\"   \n                binding=\"netTcpBinding\"   \n                contract=\"Shared.ISessionBoundFactory\"/>  \n    </client>    \n  </system.serviceModel>  \n</configuration>  \n```  \n  \n To call the service, add the code to the client to do the following:  \n  \n1.  Create a channel to the `ISessionBoundFactory` service.  \n  \n2.  Use the channel to invoke the `ISessionBoundFactory` service an obtain an <xref:System.ServiceModel.EndpointAddress10> object.  \n  \n3.  Use the <xref:System.ServiceModel.EndpointAddress10> to create a channel to obtain a sessionful object.  \n  \n4.  Call the `SetCurrentValue` and `GetCurrentValue` methods to demonstrate it remains the same object instance is used across multiple calls.  \n  \n```csharp  \nChannelFactory<ISessionBoundFactory> factory =  \n        new ChannelFactory<ISessionBoundFactory>(\"factory\");  \n  \nISessionBoundFactory sessionBoundFactory = factory.CreateChannel();  \n  \nEndpointAddress10 address = sessionBoundFactory.GetInstanceAddress();  \n  \nChannelFactory<ISessionBoundObject> sessionBoundObjectFactory =  \n    new ChannelFactory<ISessionBoundObject>(  \n        new NetTcpBinding(),  \n        address.ToEndpointAddress());  \n  \nISessionBoundObject sessionBoundObject =  \n        sessionBoundObjectFactory.CreateChannel();  \n  \nsessionBoundObject.SetCurrentValue(\"Hello\");  \nif (sessionBoundObject.GetCurrentValue() == \"Hello\")  \n{  \n    Console.WriteLine(\"Session-full instance management works as expected\");  \n}  \n```  \n  \n## See also\n\n- [Basic WCF Programming](../../../docs/framework/wcf/basic-wcf-programming.md)\n- [Designing and Implementing Services](../../../docs/framework/wcf/designing-and-implementing-services.md)\n- [Building Clients](../../../docs/framework/wcf/building-clients.md)\n- [Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md)\n","nodes":[{"pos":[4,161],"embed":true,"restype":"x-metadata","content":"title: \"How to: Migrate Managed-Code DCOM to WCF\"\nms.date: \"03/30/2017\"\nms.assetid: 52961ffc-d1c7-4f83-832c-786444b951ba\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"How to: Migrate Managed-Code DCOM to WCF","nodes":[{"pos":[0,40],"content":"How to: Migrate Managed-Code DCOM to WCF","nodes":[{"content":"How to: Migrate Managed-Code DCOM to WCF","pos":[0,40]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[168,208],"content":"How to: Migrate Managed-Code DCOM to WCF","linkify":"How to: Migrate Managed-Code DCOM to WCF","nodes":[{"content":"How to: Migrate Managed-Code DCOM to WCF","pos":[0,40]}]},{"content":"Windows Communication Foundation (WCF) is the recommended and secure choice over Distributed Component Object Model (DCOM) for managed code calls between servers and clients in a distributed environment.","pos":[209,412]},{"content":"This article shows how you to migrate code from DCOM to WCF for the following scenarios.","pos":[413,501]},{"content":"The remote service returns an object by-value to the client","pos":[511,570]},{"content":"The client sends an object by-value to the remote service","pos":[580,637]},{"content":"The remote service returns an object by-reference to the client","pos":[647,710]},{"content":"For security reasons, sending an object by-reference from the client to the service is not allowed in WCF.","pos":[717,823]},{"content":"A scenario that requires a conversation back and forth between client and server can be achieved in WCF using a duplex service.","pos":[824,951]},{"content":"For more information about duplex services, see <bpt id=\"p1\">[</bpt>Duplex Services<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/duplex-services.md)</ept>.","pos":[953,1083],"source":"  For more information about duplex services, see [Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md)."},{"pos":[1090,1429],"content":"For more details about creating WCF services and clients for those services, see <bpt id=\"p1\">[</bpt>Basic WCF Programming<ept id=\"p1\">](../../../docs/framework/wcf/basic-wcf-programming.md)</ept>, <bpt id=\"p2\">[</bpt>Designing and Implementing Services<ept id=\"p2\">](../../../docs/framework/wcf/designing-and-implementing-services.md)</ept>, and <bpt id=\"p3\">[</bpt>Building Clients<ept id=\"p3\">](../../../docs/framework/wcf/building-clients.md)</ept>.","source":"For more details about creating WCF services and clients for those services, see [Basic WCF Programming](../../../docs/framework/wcf/basic-wcf-programming.md), [Designing and Implementing Services](../../../docs/framework/wcf/designing-and-implementing-services.md), and [Building Clients](../../../docs/framework/wcf/building-clients.md)."},{"pos":[1438,1455],"content":"DCOM example code","linkify":"DCOM example code","nodes":[{"content":"DCOM example code","pos":[0,17]}]},{"content":"For these scenarios, the DCOM interfaces that are illustrated using WCF have the following structure:","pos":[1459,1560]},{"pos":[1976,2014],"content":"The service returns an object by-value","linkify":"The service returns an object by-value","nodes":[{"content":"The service returns an object by-value","pos":[0,38]}]},{"content":"For this scenario, you make a call to a service and it method returns an object, which is passed by-value from the server to the client.","pos":[2018,2154]},{"content":"This scenario represents the following COM call:","pos":[2155,2203]},{"content":"In this scenario, the client receives a deserialized copy of an object from the remote service.","pos":[2308,2403]},{"content":"The client can interact with this local copy without calling back to the service.","pos":[2404,2485]},{"content":"In other words, the client is guaranteed the service will not be involved in any way when methods on the local copy are called.","pos":[2487,2614]},{"content":"WCF always returns objects from the service by value, so the following steps describe creating a regular WCF service.","pos":[2615,2732]},{"pos":[2742,2782],"content":"Step 1: Define the WCF service interface","linkify":"Step 1: Define the WCF service interface","nodes":[{"content":"Step 1: Define the WCF service interface","pos":[0,40]}]},{"content":"Define a public interface for the WCF service and mark it with the [<ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute&gt;</ph>] attribute.","pos":[2786,2917],"source":"Define a public interface for the WCF service and mark it with the [<xref:System.ServiceModel.ServiceContractAttribute>] attribute."},{"content":"Mark the methods you want to expose to clients with the [<ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute&gt;</ph>] attribute.","pos":[2919,3041],"source":"  Mark the methods you want to expose to clients with the [<xref:System.ServiceModel.OperationContractAttribute>] attribute."},{"content":"The following example shows using these attributes to identify the server-side interface and interface methods a client can call.","pos":[3042,3171]},{"content":"The method used for this scenario is shown in bold.","pos":[3172,3223]},{"pos":[3592,3624],"content":"Step 2: Define the data contract","linkify":"Step 2: Define the data contract","nodes":[{"content":"Step 2: Define the data contract","pos":[0,32]}]},{"content":"Next you should create a data contract for the service, which will describe how the data will be exchanged between the service and its clients.","pos":[3628,3771]},{"content":"Classes described in the data contract should be marked with the [<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataContractAttribute&gt;</ph>] attribute.","pos":[3773,3908],"source":"  Classes described in the data contract should be marked with the [<xref:System.Runtime.Serialization.DataContractAttribute>] attribute."},{"content":"The individual properties or fields you want visible to both client and server should be marked with the [<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute&gt;</ph>] attribute.","pos":[3909,4082],"source":" The individual properties or fields you want visible to both client and server should be marked with the [<xref:System.Runtime.Serialization.DataMemberAttribute>] attribute."},{"content":"If you want types derived from a class in the data contract to be allowed, you must identify them with the [<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph>] attribute.","pos":[4083,4257],"source":" If you want types derived from a class in the data contract to be allowed, you must identify them with the [<xref:System.Runtime.Serialization.KnownTypeAttribute>] attribute."},{"content":"WCF will only serialize or deserialize types in the service interface and types identified as known types.","pos":[4258,4364]},{"content":"If you attempt to use a type that is not a known type, an exception will occur.","pos":[4365,4444]},{"pos":[4451,4570],"content":"For more information about data contracts, see <bpt id=\"p1\">[</bpt>Data Contracts<ept id=\"p1\">](../../../docs/framework/wcf/samples/data-contracts.md)</ept>.","source":"For more information about data contracts, see [Data Contracts](../../../docs/framework/wcf/samples/data-contracts.md)."},{"pos":[5316,5349],"content":"Step 3: Implement the WCF service","linkify":"Step 3: Implement the WCF service","nodes":[{"content":"Step 3: Implement the WCF service","pos":[0,33]}]},{"content":"Next, you should implement the WCF service class that implements the interface you defined in the previous step.","pos":[5353,5465]},{"pos":[5774,5818],"content":"Step 4: Configure the service and the client","linkify":"Step 4: Configure the service and the client","nodes":[{"content":"Step 4: Configure the service and the client","pos":[0,44]}]},{"content":"To run a WCF service, you need to declare an endpoint that exposes that service interface at a specific URL using a specific WCF binding.","pos":[5822,5959]},{"content":"A binding specifies the transport, encoding and protocol details for the clients and server to communicate.","pos":[5960,6067]},{"content":"You typically add bindings to the service project’s configuration file (web.config).","pos":[6068,6152]},{"content":"The following shows a binding entry for the example service:","pos":[6153,6213]},{"content":"Next, you need to configure the client to match the binding information specified by the service.","pos":[6604,6701]},{"content":"To do so, add the following to the client’s application configuration (app.config) file.","pos":[6702,6790]},{"pos":[7133,7156],"content":"Step 5: Run the service","linkify":"Step 5: Run the service","nodes":[{"content":"Step 5: Run the service","pos":[0,23]}]},{"content":"Finally, you can self-host it in a console application by adding the following lines to the service app, and starting the app.","pos":[7160,7286]},{"content":"For more information about other ways to host a WCF service application, <bpt id=\"p1\">[</bpt>Hosting Services<ept id=\"p1\">](../../../docs/framework/wcf/hosting-services.md)</ept>.","pos":[7287,7428],"source":" For more information about other ways to host a WCF service application, [Hosting Services](../../../docs/framework/wcf/hosting-services.md)."},{"pos":[7567,7607],"content":"Step 6: Call the service from the client","linkify":"Step 6: Call the service from the client","nodes":[{"content":"Step 6: Call the service from the client","pos":[0,40]}]},{"content":"To call the service from the client, you need to create a channel factory for the service, and request a channel, which will enable you to directly call the <ph id=\"ph1\">`GetCustomer`</ph> method directly from the client.","pos":[7611,7814],"source":"To call the service from the client, you need to create a channel factory for the service, and request a channel, which will enable you to directly call the `GetCustomer` method directly from the client."},{"content":"The channel implements the service’s interface and handles the underlying request/reply logic for you.","pos":[7815,7917]},{"content":"The return value from that method call is the deserialized copy of the service response.","pos":[7919,8007]},{"pos":[8261,8309],"content":"The client sends a by-value object to the server","linkify":"The client sends a by-value object to the server","nodes":[{"content":"The client sends a by-value object to the server","pos":[0,48]}]},{"content":"In this scenario, the client sends an object to the server, by-value.","pos":[8313,8382]},{"content":"This means that the server will receive a deserialized copy of the object.","pos":[8383,8457]},{"content":"The server can call methods on that copy and be guaranteed there is no callback into client code.","pos":[8459,8556]},{"content":"As mentioned previously, normal WCF exchanges of data are by-value.","pos":[8557,8624]},{"content":"This guarantees that calling methods on one of these objects executes locally only – it will not invoke code on the client.","pos":[8626,8749]},{"content":"This scenario represents the following COM method call:","pos":[8756,8811]},{"content":"This scenario uses the same service interface and data contract as shown in the first example.","pos":[8930,9024]},{"content":"In addition, the client and service will be configured in the same way.","pos":[9025,9096]},{"content":"In this example, a channel is created to send the object and run the same way.","pos":[9097,9175]},{"content":"However, for this example, you will create a client that calls the service, passing an object by-value.","pos":[9176,9279]},{"content":"The service method the client will call in the service contract is shown in bold:","pos":[9280,9361]},{"pos":[9617,9668],"content":"Add code to the client that sends a by-value object","linkify":"Add code to the client that sends a by-value object","nodes":[{"content":"Add code to the client that sends a by-value object","pos":[0,51]}]},{"pos":[9672,9858],"content":"The following code shows how the client creates a new by-value customer object, creates a channel to communicate with the <ph id=\"ph1\">`ICustomerManager`</ph> service, and sends the customer object to it.","source":"The following code shows how the client creates a new by-value customer object, creates a channel to communicate with the `ICustomerManager` service, and sends the customer object to it."},{"content":"The customer object will be serialized, and sent to the service, where it is deserialized by the service into a new copy of that object.","pos":[9865,10001]},{"content":"Any methods the service calls on this object will execute only locally on the server.","pos":[10003,10088]},{"content":"It’s important to note that this code illustrates sending a derived type (<ph id=\"ph1\">`PremiumCustomer`</ph>).","pos":[10089,10182],"source":" It’s important to note that this code illustrates sending a derived type (`PremiumCustomer`)."},{"content":"The service contract expects a <ph id=\"ph1\">`Customer`</ph> object, but the service data contract uses the [<ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph>] attribute to indicate that <ph id=\"ph3\">`PremiumCustomer`</ph> is also allowed.","pos":[10184,10391],"source":"  The service contract expects a `Customer` object, but the service data contract uses the [<xref:System.Runtime.Serialization.KnownTypeAttribute>] attribute to indicate that `PremiumCustomer` is also allowed."},{"content":"WCF will fail attempts to serialize or deserialize any other type via this service interface.","pos":[10393,10486]},{"pos":[11051,11093],"content":"The service returns an object by reference","linkify":"The service returns an object by reference","nodes":[{"content":"The service returns an object by reference","pos":[0,42]}]},{"content":"For this scenario, the client app makes a call to the remote service and the method returns an object, which is passed by reference from the service to the client.","pos":[11097,11260]},{"content":"As mentioned previously, WCF services always return object by value.","pos":[11267,11335]},{"content":"However, you can achieve a similar result by using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> class.","pos":[11337,11443],"source":"  However, you can achieve a similar result by using the <xref:System.ServiceModel.EndpointAddress10> class."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> is a serializable by-value object that can be used by the client to obtain a sessionful by-reference object on the server.","pos":[11445,11616],"source":"  The <xref:System.ServiceModel.EndpointAddress10> is a serializable by-value object that can be used by the client to obtain a sessionful by-reference object on the server."},{"content":"The behavior of the by-reference object in WCF shown in this scenario is different than DCOM.","pos":[11623,11716]},{"content":"In DCOM, the server can return a by-reference object to the client directly, and the client can call that object’s methods, which execute on the server.","pos":[11718,11870]},{"content":"In WCF, however, the object returned is always by-value.","pos":[11872,11928]},{"content":"The client must take that by-value object, represented by <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> and use it to create its own sessionful by-reference object.","pos":[11930,12093],"source":"  The client must take that by-value object, represented by <xref:System.ServiceModel.EndpointAddress10> and use it to create its own sessionful by-reference object."},{"content":"The client method calls on the sessionful object execute on the server.In other words, this by-reference object in WCF is a normal WCF service that is configured to be sessionful.","pos":[12095,12274]},{"content":"In WCF, a session is a way of correlating multiple messages sent between two endpoints.","pos":[12281,12368]},{"content":"This means that once a client obtains a connection to this service, a session will be established between the client and the server.","pos":[12370,12502]},{"content":"The client will use a single unique instance of the server-side object for all its interactions within this single session.","pos":[12504,12627]},{"content":"Sessionful WCF contracts are similar to connection-oriented network request/response patterns.","pos":[12628,12722]},{"content":"This scenario is represented by the following DCOM method.","pos":[12729,12787]},{"pos":[12904,12974],"content":"Step 1: Define the Sessionful WCF service interface and implementation","linkify":"Step 1: Define the Sessionful WCF service interface and implementation","nodes":[{"content":"Step 1: Define the Sessionful WCF service interface and implementation","pos":[0,70]}]},{"content":"First, define a WCF service interface that contains the sessionful object.","pos":[12978,13052]},{"content":"In this code, the sessionful object is marked with the <ph id=\"ph1\">`ServiceContract`</ph> attribute, which identifies it as a regular WCF service interface.","pos":[13059,13198],"source":"In this code, the sessionful object is marked with the `ServiceContract` attribute, which identifies it as a regular WCF service interface."},{"content":"In addition, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A&gt;</ph> property is set to indicate it will be a sessionful service.","pos":[13200,13344],"source":"  In addition, the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> property is set to indicate it will be a sessionful service."},{"content":"The following code shows the service implementation.","pos":[13603,13655]},{"content":"The service is marked with the [ServiceBehavior] attribute, and its InstanceContextMode property set to InstanceContextMode.PerSessions to indicate that a unique instance of this type should be created for each session.","pos":[13662,13881]},{"pos":[14303,14367],"content":"Step 2: Define the WCF factory service for the sessionful object","linkify":"Step 2: Define the WCF factory service for the sessionful object","nodes":[{"content":"Step 2: Define the WCF factory service for the sessionful object","pos":[0,64]}]},{"content":"The service that creates the sessionful object must be defined and implemented.","pos":[14371,14450]},{"content":"The following code shows how to do this.","pos":[14451,14491]},{"content":"This code creates another WCF service that returns an <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> object.","pos":[14492,14598],"source":" This code creates another WCF service that returns an <xref:System.ServiceModel.EndpointAddress10> object."},{"content":"This is a serializable form of an endpoint the can use to create the session-full object.","pos":[14600,14689]},{"content":"Following is the implementation of this service.","pos":[14877,14925]},{"content":"This implementation maintains a singleton channel factory to create sessionful objects.","pos":[14926,15013]},{"content":"When <ph id=\"ph1\">`GetInstanceAddress`</ph> is called, it creates a channel and creates an <ph id=\"ph2\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> object that points to the remote address associated with this channel.","pos":[15015,15203],"source":"  When `GetInstanceAddress` is called, it creates a channel and creates an <xref:System.ServiceModel.EndpointAddress10> object that points to the remote address associated with this channel."},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> is a data type that can be returned to the client by-value.","pos":[15206,15310],"source":"<xref:System.ServiceModel.EndpointAddress10> is a data type that can be returned to the client by-value."},{"pos":[15871,15915],"content":"Step 3: Configure and start the WCF services","linkify":"Step 3: Configure and start the WCF services","nodes":[{"content":"Step 3: Configure and start the WCF services","pos":[0,44]}]},{"content":"To host these services, you will need to make the following additions to the server’s configuration file (web.config).","pos":[15919,16037]},{"content":"Add a <ph id=\"ph1\">`&lt;client&gt;`</ph> section that describes the endpoint for the sessionful object.","pos":[16047,16126],"source":"Add a `<client>` section that describes the endpoint for the sessionful object."},{"content":"In this scenario, the server also acts as a client and must be configured to enable this.","pos":[16128,16217]},{"content":"In the <ph id=\"ph1\">`&lt;services&gt;`</ph> section, declare service endpoints for the factory and sessionful object.","pos":[16227,16320],"source":"In the `<services>` section, declare service endpoints for the factory and sessionful object."},{"content":"This enables the client to communicate with the service endpoints, acquire the <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> and create the sessionful channel.","pos":[16322,16480],"source":"  This enables the client to communicate with the service endpoints, acquire the <xref:System.ServiceModel.EndpointAddress10> and create the sessionful channel."},{"content":"Following is an example configuration file with these settings:","pos":[16487,16550]},{"content":"Add the following lines to a console application, to self-host the service, and start the app.","pos":[17449,17543]},{"pos":[17797,17846],"content":"Step 4: Configure the client and call the service","linkify":"Step 4: Configure the client and call the service","nodes":[{"content":"Step 4: Configure the client and call the service","pos":[0,49]}]},{"content":"Configure the client to communicate with the WCF services by making the following entries in the project’s application configuration file (app.config).","pos":[17850,18001]},{"content":"To call the service, add the code to the client to do the following:","pos":[18572,18640]},{"pos":[18650,18705],"content":"Create a channel to the <ph id=\"ph1\">`ISessionBoundFactory`</ph> service.","source":"Create a channel to the `ISessionBoundFactory` service."},{"pos":[18715,18841],"content":"Use the channel to invoke the <ph id=\"ph1\">`ISessionBoundFactory`</ph> service an obtain an <ph id=\"ph2\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> object.","source":"Use the channel to invoke the `ISessionBoundFactory` service an obtain an <xref:System.ServiceModel.EndpointAddress10> object."},{"pos":[18851,18954],"content":"Use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.EndpointAddress10&gt;</ph> to create a channel to obtain a sessionful object.","source":"Use the <xref:System.ServiceModel.EndpointAddress10> to create a channel to obtain a sessionful object."},{"pos":[18964,19102],"content":"Call the <ph id=\"ph1\">`SetCurrentValue`</ph> and <ph id=\"ph2\">`GetCurrentValue`</ph> methods to demonstrate it remains the same object instance is used across multiple calls.","source":"Call the `SetCurrentValue` and `GetCurrentValue` methods to demonstrate it remains the same object instance is used across multiple calls."},{"pos":[19870,19878],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[19882,19959],"content":"<bpt id=\"p1\">[</bpt>Basic WCF Programming<ept id=\"p1\">](../../../docs/framework/wcf/basic-wcf-programming.md)</ept>","source":"[Basic WCF Programming](../../../docs/framework/wcf/basic-wcf-programming.md)"},{"pos":[19962,20067],"content":"<bpt id=\"p1\">[</bpt>Designing and Implementing Services<ept id=\"p1\">](../../../docs/framework/wcf/designing-and-implementing-services.md)</ept>","source":"[Designing and Implementing Services](../../../docs/framework/wcf/designing-and-implementing-services.md)"},{"pos":[20070,20137],"content":"<bpt id=\"p1\">[</bpt>Building Clients<ept id=\"p1\">](../../../docs/framework/wcf/building-clients.md)</ept>","source":"[Building Clients](../../../docs/framework/wcf/building-clients.md)"},{"pos":[20140,20221],"content":"<bpt id=\"p1\">[</bpt>Duplex Services<ept id=\"p1\">](../../../docs/framework/wcf/feature-details/duplex-services.md)</ept>","source":"[Duplex Services](../../../docs/framework/wcf/feature-details/duplex-services.md)"}]}