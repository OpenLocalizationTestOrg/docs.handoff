{"content":"---\ntitle: \"Claims Based Authorization Using WIF | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: e24000a3-8fd8-4c0e-bdf0-39882cc0f6d8\ncaps.latest.revision: 6\nauthor: \"BrucePerlerMS\"\nms.author: \"bruceper\"\nmanager: \"mbaldwin\"\n---\n# Claims Based Authorization Using WIF\nIn a relying party application, authorization determines what resources an authenticated identity is allowed to access and what operations it is allowed to perform on those resources. Improper or weak authorization leads to information disclosure and data tampering. This topic outlines the available approaches to implementing authorization for claims-aware ASP.NET web applications and services using Windows Identity Foundation (WIF) and a Security Token Service (STS), for example, the Windows Azure Access Control Service (ACS).  \n  \n## Overview  \n Since its first version, the .NET Framework has offered a flexible mechanism for implementing authorization. This mechanism is based on two simple interfaces—**IPrincipal** and **IIdentity**. Concrete implementations of **IIdentity** represent an authenticated user. For example, the **WindowsIdentity** implementation represents a user who is authenticated by Active Directory, and **GenericIdentity** represents a user whose identity is verified via a custom authentication process. Concrete implementations of **IPrincipal** help to check permissions using roles depending on the role store. For example, **WindowsPrincipal** checks **WindowsIdentity** for membership in Active Directory groups. This check is performed by calling the **IsInRole** method on the **IPrincipal** interface. Checking access based on roles is called Role-Based Access Control (RBAC). For more information, see [Role-Based Access Control](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1).  Claims can be used to carry information about roles to support familiar, role-based authorization mechanisms.  \n  \n Claims can also be used to enable more complicated authorization decisions beyond roles. Claims can be based on virtually any information about the user - age, zip code, shoe size, etc. An access control mechanism that is based on arbitrary claims is called claims-based authorization. For more information, see [Claims-based Authorization](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2).  \n  \n<a name=\"BKMK_1\"></a>   \n## Role-Based Access Control  \n RBAC is an authorization approach in which user permissions are managed and enforced by an application based on user roles. If a user has a role that is required to perform an action, the access is granted; otherwise, access is denied.  \n  \n### IPrincipal.IsInRole Method  \n To implement the RBAC approach in claims-aware applications, use the **IsInRole()** method in the **IPrinicpal** interface, just as you would in non-claims-aware applications. There are several ways of using the **IsInRole()** method:  \n  \n-   Explicitly calling on **IPrincipal.IsInRole(\"Administrator\")**. In this approach, the outcome is a Boolean. Use it in your conditional statements. It can be used arbitrarily any place in your code.  \n  \n-   Using the security demand **PrincipalPermission.Demand()**. In this approach, the outcome is an exception in case the demand is not satisfied. This should fit your exception handling strategy. Throwing exceptions is much more expensive from a performance perspective compared to retiring Boolean. This can be used any place in your code.  \n  \n-   Using the declarative attributes **[PrincipalPermission(SecurityAction.Demand, Role = \"Administrator\")]**. This approach is called declarative, because it is used to decorate methods. It cannot be used in code blocks inside the method’s implementations. The outcome is an exception in case the demand is not satisfied. You should make sure that it fits your exception-handling strategy.  \n  \n-   Using URL authorization, using the **\\<authorization>** section in **web.config**. This approach is suitable when you are managing authorization on a URL level. This is the most coarse level among those previously mentioned. The advantage of this approach is that changes are made in the configuration file, which means that the code should not be compiled to take advantage of the change.  \n  \n### Expressing Roles as Claims  \n When the **IsInRole()** method is called, there is a check made to see if the current user has that role. In claims-aware applications, the role is expressed by a role claim type that should be available in the token. The role claim type is expressed using the following URI:  \n  \n http://schemas.microsoft.com/ws/2008/06/identity/claims/role  \n  \n There are several ways to enrich a token with a role claim type:  \n  \n-   **During token issuance**. When a user is authenticated the role claim can be issued by the identity provider STS or by a federation drovider such as the Windows Azure Access Control Service (ACS).  \n  \n-   **Transforming arbitrary claims into of claims role type using ClaimsAuthenticationManager**. The ClaimsAuthenticationManager is a component that ships as part of WIF. It allows requests to be intercepted when they launch an application, inspecting tokens and transforming them by adding, changing, or removing claims. For more information about how to use ClaimsAuthenticationManager for transforming claims, see [How To: Implement Role Based Access Control (RBAC) in a Claims Aware ASP.NET Application Using WIF and ACS](http://go.microsoft.com/fwlink/?LinkID=247445) (http://go.microsoft.com/fwlink/?LinkID=247444).  \n  \n-   **Mapping arbitrary claims to a role type using the samlSecurityTokenRequirement configuration section**—A declarative approach where the claims transformation is done using only the configuration and no coding is required.  \n  \n<a name=\"BKMK_2\"></a>   \n## Claims-based Authorization  \n Claims-based authorization is an approach where the authorization decision to grant or deny access is based on arbitrary logic that uses data available in claims to make the decision. Recall that in the case of RBAC, the only claim used was role type claim. A role type claim was used to check if the user belongs to specific role or not. To illustrate the process of making the authorization decisions using claims-based authorization approach, consider the following steps:  \n  \n1.  The application receives a request that requires the user is authenticated.  \n  \n2.  WIF redirects the user to their identity provider, after they are authenticated the application request is made with an associated security token representing the user containing claims about them. WIF associates those claims with the principal that represents the user.  \n  \n3.  The application passes the claims to the decision logic mechanism. It can be in-memory code, a call to a web service, a query to a database, a sophisticated rules engine, or using the ClaimsAuthorizationManager.  \n  \n4.  The decision mechanism calculates the outcome based on the claims.  \n  \n5.  Access is granted if the outcome is true and denied if it is false. For example, the rule might be that the user is of age 21 or above and lives in Washington State.  \n  \n <xref:System.Security.Claims.ClaimsAuthorizationManager> is useful for externalizing the decision logic for  claims-based authorization in your applications. ClaimsAuthorizationManager is a WIF component that ships as part of .NET 4.5. ClaimsAuthorizationManager allows you to intercept incoming requests and implement any logic of your choice to make authorization decisions based on the incoming claims. This becomes important when authorization logic needs to be changed. In that case, using ClaimsAuthorizationManager will not affect the application’s integrity, thereby reducing the likelihood of an application error as a result of the change. To learn more about how to use ClaimsAuthorizationManager to implement claims-based access control, see [How To: Implement Claims Authorization in a Claims Aware ASP.NET Application Using WIF and ACS](http://go.microsoft.com/fwlink/?LinkID=247446).","nodes":[{"pos":[12,65],"content":"Claims Based Authorization Using WIF | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Claims Based Authorization Using WIF | Microsoft Docs","pos":[0,53]}]},{"pos":[374,410],"content":"Claims Based Authorization Using WIF","linkify":"Claims Based Authorization Using WIF","nodes":[{"content":"Claims Based Authorization Using WIF","pos":[0,36]}]},{"content":"In a relying party application, authorization determines what resources an authenticated identity is allowed to access and what operations it is allowed to perform on those resources.","pos":[411,594]},{"content":"Improper or weak authorization leads to information disclosure and data tampering.","pos":[595,677]},{"content":"This topic outlines the available approaches to implementing authorization for claims-aware ASP.NET web applications and services using Windows Identity Foundation (WIF) and a Security Token Service (STS), for example, the Windows Azure Access Control Service (ACS).","pos":[678,944]},{"pos":[953,961],"content":"Overview","linkify":"Overview","nodes":[{"content":"Overview","pos":[0,8]}]},{"content":"Since its first version, the .NET Framework has offered a flexible mechanism for implementing authorization.","pos":[965,1073]},{"content":"This mechanism is based on two simple interfaces—<bpt id=\"p1\">**</bpt>IPrincipal<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>IIdentity<ept id=\"p2\">**</ept>.","pos":[1074,1156],"source":" This mechanism is based on two simple interfaces—**IPrincipal** and **IIdentity**."},{"content":"Concrete implementations of <bpt id=\"p1\">**</bpt>IIdentity<ept id=\"p1\">**</ept> represent an authenticated user.","pos":[1157,1231],"source":" Concrete implementations of **IIdentity** represent an authenticated user."},{"content":"For example, the <bpt id=\"p1\">**</bpt>WindowsIdentity<ept id=\"p1\">**</ept> implementation represents a user who is authenticated by Active Directory, and <bpt id=\"p2\">**</bpt>GenericIdentity<ept id=\"p2\">**</ept> represents a user whose identity is verified via a custom authentication process.","pos":[1232,1449],"source":" For example, the **WindowsIdentity** implementation represents a user who is authenticated by Active Directory, and **GenericIdentity** represents a user whose identity is verified via a custom authentication process."},{"content":"Concrete implementations of <bpt id=\"p1\">**</bpt>IPrincipal<ept id=\"p1\">**</ept> help to check permissions using roles depending on the role store.","pos":[1450,1559],"source":" Concrete implementations of **IPrincipal** help to check permissions using roles depending on the role store."},{"content":"For example, <bpt id=\"p1\">**</bpt>WindowsPrincipal<ept id=\"p1\">**</ept> checks <bpt id=\"p2\">**</bpt>WindowsIdentity<ept id=\"p2\">**</ept> for membership in Active Directory groups.","pos":[1560,1663],"source":" For example, **WindowsPrincipal** checks **WindowsIdentity** for membership in Active Directory groups."},{"content":"This check is performed by calling the <bpt id=\"p1\">**</bpt>IsInRole<ept id=\"p1\">**</ept> method on the <bpt id=\"p2\">**</bpt>IPrincipal<ept id=\"p2\">**</ept> interface.","pos":[1664,1755],"source":" This check is performed by calling the **IsInRole** method on the **IPrincipal** interface."},{"content":"Checking access based on roles is called Role-Based Access Control (RBAC).","pos":[1756,1830]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Role-Based Access Control<ept id=\"p1\">](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1)</ept>.","pos":[1831,1966],"source":" For more information, see [Role-Based Access Control](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1)."},{"content":"Claims can be used to carry information about roles to support familiar, role-based authorization mechanisms.","pos":[1968,2077]},{"content":"Claims can also be used to enable more complicated authorization decisions beyond roles.","pos":[2084,2172]},{"content":"Claims can be based on virtually any information about the user - age, zip code, shoe size, etc. An access control mechanism that is based on arbitrary claims is called claims-based authorization.","pos":[2173,2369]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Claims-based Authorization<ept id=\"p1\">](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2)</ept>.","pos":[2370,2506],"source":" For more information, see [Claims-based Authorization](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2)."},{"pos":[2540,2565],"content":"Role-Based Access Control","linkify":"Role-Based Access Control","nodes":[{"content":"Role-Based Access Control","pos":[0,25]}]},{"content":"RBAC is an authorization approach in which user permissions are managed and enforced by an application based on user roles.","pos":[2569,2692]},{"content":"If a user has a role that is required to perform an action, the access is granted; otherwise, access is denied.","pos":[2693,2804]},{"pos":[2814,2840],"content":"IPrincipal.IsInRole Method","linkify":"IPrincipal.IsInRole Method","nodes":[{"content":"IPrincipal.IsInRole Method","pos":[0,26]}]},{"content":"To implement the RBAC approach in claims-aware applications, use the <bpt id=\"p1\">**</bpt>IsInRole()<ept id=\"p1\">**</ept> method in the <bpt id=\"p2\">**</bpt>IPrinicpal<ept id=\"p2\">**</ept> interface, just as you would in non-claims-aware applications.","pos":[2844,3019],"source":"To implement the RBAC approach in claims-aware applications, use the **IsInRole()** method in the **IPrinicpal** interface, just as you would in non-claims-aware applications."},{"content":"There are several ways of using the <bpt id=\"p1\">**</bpt>IsInRole()<ept id=\"p1\">**</ept> method:","pos":[3020,3078],"source":" There are several ways of using the **IsInRole()** method:"},{"content":"Explicitly calling on <bpt id=\"p1\">**</bpt>IPrincipal.IsInRole(\"Administrator\")<ept id=\"p1\">**</ept>.","pos":[3088,3151],"source":"Explicitly calling on **IPrincipal.IsInRole(\"Administrator\")**."},{"content":"In this approach, the outcome is a Boolean.","pos":[3152,3195]},{"content":"Use it in your conditional statements.","pos":[3196,3234]},{"content":"It can be used arbitrarily any place in your code.","pos":[3235,3285]},{"content":"Using the security demand <bpt id=\"p1\">**</bpt>PrincipalPermission.Demand()<ept id=\"p1\">**</ept>.","pos":[3295,3354],"source":"Using the security demand **PrincipalPermission.Demand()**."},{"content":"In this approach, the outcome is an exception in case the demand is not satisfied.","pos":[3355,3437]},{"content":"This should fit your exception handling strategy.","pos":[3438,3487]},{"content":"Throwing exceptions is much more expensive from a performance perspective compared to retiring Boolean.","pos":[3488,3591]},{"content":"This can be used any place in your code.","pos":[3592,3632]},{"content":"Using the declarative attributes <bpt id=\"p1\">**</bpt>[PrincipalPermission(SecurityAction.Demand, Role = \"Administrator\")]<ept id=\"p1\">**</ept>.","pos":[3642,3748],"source":"Using the declarative attributes **[PrincipalPermission(SecurityAction.Demand, Role = \"Administrator\")]**."},{"content":"This approach is called declarative, because it is used to decorate methods.","pos":[3749,3825]},{"content":"It cannot be used in code blocks inside the method’s implementations.","pos":[3826,3895]},{"content":"The outcome is an exception in case the demand is not satisfied.","pos":[3896,3960]},{"content":"You should make sure that it fits your exception-handling strategy.","pos":[3961,4028]},{"content":"Using URL authorization, using the <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\&lt;</ph>authorization&gt;<ept id=\"p1\">**</ept> section in <bpt id=\"p2\">**</bpt>web.config<ept id=\"p2\">**</ept>.","pos":[4038,4120],"source":"Using URL authorization, using the **\\<authorization>** section in **web.config**."},{"content":"This approach is suitable when you are managing authorization on a URL level.","pos":[4121,4198]},{"content":"This is the most coarse level among those previously mentioned.","pos":[4199,4262]},{"content":"The advantage of this approach is that changes are made in the configuration file, which means that the code should not be compiled to take advantage of the change.","pos":[4263,4427]},{"pos":[4437,4463],"content":"Expressing Roles as Claims","linkify":"Expressing Roles as Claims","nodes":[{"content":"Expressing Roles as Claims","pos":[0,26]}]},{"content":"When the <bpt id=\"p1\">**</bpt>IsInRole()<ept id=\"p1\">**</ept> method is called, there is a check made to see if the current user has that role.","pos":[4467,4572],"source":"When the **IsInRole()** method is called, there is a check made to see if the current user has that role."},{"content":"In claims-aware applications, the role is expressed by a role claim type that should be available in the token.","pos":[4573,4684]},{"content":"The role claim type is expressed using the following URI:","pos":[4685,4742]},{"content":"http://schemas.microsoft.com/ws/2008/06/identity/claims/role","pos":[4749,4809]},{"content":"There are several ways to enrich a token with a role claim type:","pos":[4816,4880]},{"content":"<bpt id=\"p1\">**</bpt>During token issuance<ept id=\"p1\">**</ept>.","pos":[4890,4916],"source":"**During token issuance**."},{"content":"When a user is authenticated the role claim can be issued by the identity provider STS or by a federation drovider such as the Windows Azure Access Control Service (ACS).","pos":[4917,5087]},{"content":"<bpt id=\"p1\">**</bpt>Transforming arbitrary claims into of claims role type using ClaimsAuthenticationManager<ept id=\"p1\">**</ept>.","pos":[5097,5190],"source":"**Transforming arbitrary claims into of claims role type using ClaimsAuthenticationManager**."},{"content":"The ClaimsAuthenticationManager is a component that ships as part of WIF.","pos":[5191,5264]},{"content":"It allows requests to be intercepted when they launch an application, inspecting tokens and transforming them by adding, changing, or removing claims.","pos":[5265,5415]},{"content":"For more information about how to use ClaimsAuthenticationManager for transforming claims, see <bpt id=\"p1\">[</bpt>How To: Implement Role Based Access Control (RBAC) in a Claims Aware ASP.NET Application Using WIF and ACS<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247445)</ept> (http://go.microsoft.com/fwlink/?LinkID=247444).","pos":[5416,5715],"source":" For more information about how to use ClaimsAuthenticationManager for transforming claims, see [How To: Implement Role Based Access Control (RBAC) in a Claims Aware ASP.NET Application Using WIF and ACS](http://go.microsoft.com/fwlink/?LinkID=247445) (http://go.microsoft.com/fwlink/?LinkID=247444)."},{"pos":[5725,5948],"content":"<bpt id=\"p1\">**</bpt>Mapping arbitrary claims to a role type using the samlSecurityTokenRequirement configuration section<ept id=\"p1\">**</ept>—A declarative approach where the claims transformation is done using only the configuration and no coding is required.","source":"**Mapping arbitrary claims to a role type using the samlSecurityTokenRequirement configuration section**—A declarative approach where the claims transformation is done using only the configuration and no coding is required."},{"pos":[5982,6008],"content":"Claims-based Authorization","linkify":"Claims-based Authorization","nodes":[{"content":"Claims-based Authorization","pos":[0,26]}]},{"content":"Claims-based authorization is an approach where the authorization decision to grant or deny access is based on arbitrary logic that uses data available in claims to make the decision.","pos":[6012,6195]},{"content":"Recall that in the case of RBAC, the only claim used was role type claim.","pos":[6196,6269]},{"content":"A role type claim was used to check if the user belongs to specific role or not.","pos":[6270,6350]},{"content":"To illustrate the process of making the authorization decisions using claims-based authorization approach, consider the following steps:","pos":[6351,6487]},{"content":"The application receives a request that requires the user is authenticated.","pos":[6497,6572]},{"content":"WIF redirects the user to their identity provider, after they are authenticated the application request is made with an associated security token representing the user containing claims about them.","pos":[6582,6779]},{"content":"WIF associates those claims with the principal that represents the user.","pos":[6780,6852]},{"content":"The application passes the claims to the decision logic mechanism.","pos":[6862,6928]},{"content":"It can be in-memory code, a call to a web service, a query to a database, a sophisticated rules engine, or using the ClaimsAuthorizationManager.","pos":[6929,7073]},{"content":"The decision mechanism calculates the outcome based on the claims.","pos":[7083,7149]},{"content":"Access is granted if the outcome is true and denied if it is false.","pos":[7159,7226]},{"content":"For example, the rule might be that the user is of age 21 or above and lives in Washington State.","pos":[7227,7324]},{"content":"<ph id=\"ph1\">&lt;xref:System.Security.Claims.ClaimsAuthorizationManager&gt;</ph> is useful for externalizing the decision logic for  claims-based authorization in your applications.","pos":[7331,7488],"source":"<xref:System.Security.Claims.ClaimsAuthorizationManager> is useful for externalizing the decision logic for  claims-based authorization in your applications."},{"content":"ClaimsAuthorizationManager is a WIF component that ships as part of .NET 4.5.","pos":[7489,7566]},{"content":"ClaimsAuthorizationManager allows you to intercept incoming requests and implement any logic of your choice to make authorization decisions based on the incoming claims.","pos":[7567,7736]},{"content":"This becomes important when authorization logic needs to be changed.","pos":[7737,7805]},{"content":"In that case, using ClaimsAuthorizationManager will not affect the application’s integrity, thereby reducing the likelihood of an application error as a result of the change.","pos":[7806,7980]},{"content":"To learn more about how to use ClaimsAuthorizationManager to implement claims-based access control, see <bpt id=\"p1\">[</bpt>How To: Implement Claims Authorization in a Claims Aware ASP.NET Application Using WIF and ACS<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247446)</ept>.","pos":[7981,8229],"source":" To learn more about how to use ClaimsAuthorizationManager to implement claims-based access control, see [How To: Implement Claims Authorization in a Claims Aware ASP.NET Application Using WIF and ACS](http://go.microsoft.com/fwlink/?LinkID=247446)."}]}