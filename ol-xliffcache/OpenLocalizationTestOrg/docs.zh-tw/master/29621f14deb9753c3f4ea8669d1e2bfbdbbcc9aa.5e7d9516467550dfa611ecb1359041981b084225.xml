{"content":"---\ntitle: \"Using Message Contracts | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"message contracts [WCF]\"\nms.assetid: 1e19c64a-ae84-4c2f-9155-91c54a77c249\ncaps.latest.revision: 46\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Using Message Contracts\nTypically when building [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] applications, developers pay close attention to the data structures and serialization issues and do not need to concern themselves with the structure of the messages in which the data is carried. For these applications, creating data contracts for the parameters or return values is straightforward. ([!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).)  \n  \n However, sometimes complete control over the structure of a SOAP message is just as important as control over its contents. This is especially true when interoperability is important or to specifically control security issues at the level of the message or message part. In these cases, you can create a *message contract* that enables you to specify the structure of the precise SOAP message required.  \n  \n This topic discusses how to use the various message contract attributes to create a specific message contract for your operation.  \n  \n## Using Message Contracts in Operations  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] supports operations modeled on either the *remote procedure call (RPC) style* or the *messaging style*. In an RPC-style operation, you can use any serializable type, and you have access to the features that are available to local calls, such as multiple parameters and `ref` and `out` parameters. In this style, the form of serialization chosen controls the structure of the data in the underlying messages, and the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime creates the messages to support the operation. This enables developers who are not familiar with SOAP and SOAP messages to quickly and easily create and use service applications.  \n  \n The following code example shows a service operation modeled on the RPC style.  \n  \n```csharp  \n[OperationContract]  \npublic BankingTransactionResponse PostBankingTransaction(BankingTransaction bt);  \n```  \n  \n Normally, a data contract is sufficient to define the schema for the messages. For instance, in the preceding example, it is sufficient for most applications if `BankingTransaction` and `BankingTransactionResponse` have data contracts to define the contents of the underlying SOAP messages. [!INCLUDE[crabout](../../../../includes/crabout-md.md)] data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).  \n  \n However, occasionally it is necessary to precisely control how the structure of the SOAP message transmitted over the wire. The most common scenario for this is inserting custom SOAP headers. Another common scenario is to define security properties for the message's headers and body, that is, to decide whether these elements are digitally signed and encrypted. Finally, some third-party SOAP stacks require messages be in a specific format. Messaging-style operations provide this control.  \n  \n A messaging-style operation has at most one parameter and one return value where both types are message types; that is, they serialize directly into a specified SOAP message structure. This may be any type marked with the <xref:System.ServiceModel.MessageContractAttribute> or the <xref:System.ServiceModel.Channels.Message> type. The following code example shows an operation similar to the preceding RCP-style, but which uses the messaging style.  \n  \n For example, if `BankingTransaction` and `BankingTransactionResponse` are both types that are message contracts, then the code in the following operations is valid.  \n  \n```csharp  \n[OperationContract]  \nBankingTransactionResponse Process(BankingTransaction bt);  \n[OperationContract]  \nvoid Store(BankingTransaction bt);  \n[OperationContract]  \nBankingTransactionResponse GetResponse();  \n```  \n  \n However, the following code is invalid.  \n  \n```csharp  \n[OperationContract]  \nbool Validate(BankingTransaction bt);  \n// Invalid, the return type is not a message contract.  \n[OperationContract]  \nvoid Reconcile(BankingTransaction bt1, BankingTransaction bt2);  \n// Invalid, there is more than one parameter.  \n```  \n  \n An exception is thrown for any operation that involves a message contract type and that does not follow one of the valid patterns. Of course, operations that do not involve message contract types are not subject to these restrictions.  \n  \n If a type has both a message contract and a data contract, only its message contract is considered when the type is used in an operation.  \n  \n## Defining Message Contracts  \n To define a message contract for a type (that is, to define the mapping between the type and a SOAP envelope), apply the <xref:System.ServiceModel.MessageContractAttribute> to the type. Then apply the <xref:System.ServiceModel.MessageHeaderAttribute> to those members of the type you want to make into SOAP headers, and apply the <xref:System.ServiceModel.MessageBodyMemberAttribute> to those members you want to make into parts of the SOAP body of the message.  \n  \n The following code provides an example of using a message contract.  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader] public Operation operation;  \n  [MessageHeader] public DateTime transactionDate;  \n  [MessageBodyMember] private Account sourceAccount;  \n  [MessageBodyMember] private Account targetAccount;  \n  [MessageBodyMember] public int amount;  \n}  \n```  \n  \n When using this type as an operation parameter, the following SOAP envelope is generated:  \n  \n```xml  \n<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\">  \n  <s:Header>  \n    <h:operation xmlns:h=\"http://tempuri.org/\" xmlns=\"http://tempuri.org/\">Deposit</h:operation>  \n    <h:transactionDate xmlns:h=\"http://tempuri.org/\" xmlns=\"http://tempuri.org/\">2012-02-16T16:10:00</h:transactionDate>  \n  </s:Header>  \n  <s:Body xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">  \n    <BankingTransaction xmlns=\"http://tempuri.org/\">  \n      <amount>0</amount>  \n      <sourceAccount xsi:nil=\"true\"/>  \n      <targetAccount xsi:nil=\"true\"/>  \n    </BankingTransaction>  \n  </s:Body>  \n</s:Envelope>  \n```  \n  \n Notice that `operation` and `transactionDate` appear as SOAP headers and the SOAP body consists of a wrapper element `BankingTransaction` containing `sourceAccount`,`targetAccount`, and `amount`.  \n  \n You can apply the <xref:System.ServiceModel.MessageHeaderAttribute> and <xref:System.ServiceModel.MessageBodyMemberAttribute> to all fields, properties, and events, regardless of whether they are public, private, protected, or internal.  \n  \n The <xref:System.ServiceModel.MessageContractAttribute> allows you to specify the WrapperName and WrapperNamespace attributes which control the name of the wrapper element in the body of the SOAP message. By default the name of the message contract type is used for the wrapper and the namespace in which the message contract is defined  `HYPERLINK \"http://tempuri.org/\" http://tempuri.org/` is used as the default namespace.  \n  \n> [!NOTE]\n>  <xref:System.Runtime.Serialization.KnownTypeAttribute> attributes are ignored in message contracts. If a <xref:System.Runtime.Serialization.KnownTypeAttribute> is required, place it on the operation that is using the message contract in question.  \n  \n## Controlling Header and Body Part Names and Namespaces  \n In the SOAP representation of a message contract, each header and body part maps to an XML element that has a name and a namespace.  \n  \n By default, the namespace is the same as the namespace of the service contract that the message is participating in, and the name is determined by the member name to which the <xref:System.ServiceModel.MessageHeaderAttribute> or the <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes are applied.  \n  \n You can change these defaults by manipulating the <xref:System.ServiceModel.MessageContractMemberAttribute.Name%2A?displayProperty=fullName> and <xref:System.ServiceModel.MessageContractMemberAttribute.Namespace%2A?displayProperty=fullName> (on the parent class of the <xref:System.ServiceModel.MessageHeaderAttribute> and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes).  \n  \n Consider the class in the following code example.  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader] public Operation operation;  \n  [MessageHeader(Namespace=\"http://schemas.contoso.com/auditing/2005\")] public bool IsAudited;  \n  [MessageBodyMember(Name=\"transactionData\")] public BankingTransactionData theData;  \n}  \n```  \n  \n In this example, the `IsAudited` header is in the namespace specified in the code, and the body part that represents the `theData` member is represented by an XML element with the name `transactionData`. The following shows the XML generated for this message contract.  \n  \n```xml  \n<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\">  \n  <s:Header>  \n    <h:IsAudited xmlns:h=\"http://schemas.contoso.com/auditing/2005\" xmlns=\"http://schemas.contoso.com/auditing/2005\">false</h:IsAudited>  \n    <h:operation xmlns:h=\"http://tempuri.org/\" xmlns=\"http://tempuri.org/\">Deposit</h:operation>  \n  </s:Header>  \n  <s:Body xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">  \n    <AuditedBankingTransaction xmlns=\"http://tempuri.org/\">  \n      <transactionData/>  \n    </AuditedBankingTransaction>  \n  </s:Body>  \n</s:Envelope>  \n```  \n  \n## Controlling Whether the SOAP Body Parts Are Wrapped  \n By default, the SOAP body parts are serialized inside a wrapped element. For example, the following code shows the `HelloGreetingMessage` wrapper element generated from the name of the <xref:System.ServiceModel.MessageContractAttribute> type in the message contract for the `HelloGreetingMessage` message.  \n  \n [!code-csharp[MessageHeaderAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/messageheaderattribute/cs/services.cs#3)]\n [!code-vb[MessageHeaderAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/messageheaderattribute/vb/services.vb#3)]  \n  \n To suppress the wrapper element, set the <xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A> property to `false`. To control the name and the namespace of the wrapper element, use the <xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A> and <xref:System.ServiceModel.MessageContractAttribute.WrapperNamespace%2A> properties.  \n  \n> [!NOTE]\n>  Having more than one message body part in messages that are not wrapped is not compliant with WS-I Basic Profile 1.1 and is not recommended when designing new message contracts. However, it may be necessary to have more than one unwrapped message body part in certain specific interoperability scenarios. If you are going to transmit more than one piece of data in a message body, it is recommended to use the default (wrapped) mode. Having more than one message header in unwrapped messages is completely acceptable.  \n  \n## Using Custom Types Inside Message Contracts  \n Each individual message header and message body part is serialized (turned into XML) using the chosen serialization engine for the service contract where the message is used. The default serialization engine, the `XmlFormatter`, can handle any type that has a data contract, either explicitly (by having the <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=fullName>) or implicitly (by being a primitive type, having the <xref:System.SerializableAttribute?displayProperty=fullName>, and so on). [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).  \n  \n In the preceding example, the `Operation` and `BankingTransactionData` types must have a data contract, and `transactionDate` is serializable because <xref:System.DateTime> is a primitive (and so has an implicit data contract).  \n  \n However, it is possible to switch to a different serialization engine, the `XmlSerializer`. If you make such a switch, you should ensure that all of the types used for message headers and body parts are serializable using the `XmlSerializer`.  \n  \n## Using Arrays Inside Message Contracts  \n You can use arrays of repeating elements in message contracts in two ways.  \n  \n The first is to use a <xref:System.ServiceModel.MessageHeaderAttribute> or a <xref:System.ServiceModel.MessageBodyMemberAttribute> directly on the array. In this case, the entire array is serialized as one element (that is, one header or one body part) with multiple child elements. Consider the class in the following example.  \n  \n```csharp  \n[MessageContract]  \npublic class BankingDepositLog  \n{  \n  [MessageHeader] public int numRecords;  \n  [MessageHeader] public DepositRecord[] records;  \n  [MessageHeader] public int branchID;  \n}  \n```  \n  \n This results in SOAP headers is similar to the following.  \n  \n```xml  \n<BankingDepositLog>  \n<numRecords>3</numRecords>  \n<records>  \n  <DepositRecord>Record1</DepositRecord>  \n  <DepositRecord>Record2</DepositRecord>  \n  <DepositRecord>Record3</DepositRecord>  \n</records>  \n<branchID>20643</branchID>  \n</BankingDepositLog>  \n```  \n  \n An alternative to this is to use the <xref:System.ServiceModel.MessageHeaderArrayAttribute>. In this case, each array element is serialized independently and so that each array element has one header, similar to the following.  \n  \n```xml  \n<numRecords>3</numRecords>  \n<records>Record1</records>  \n<records>Record2</records>  \n<records>Record3</records>  \n<branchID>20643</branchID>  \n```  \n  \n The default name for array entries is the name of the member to which the <xref:System.ServiceModel.MessageHeaderArrayAttribute> attributes is applied.  \n  \n The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute inherits from the <xref:System.ServiceModel.MessageHeaderAttribute>. It has the same set of features as the non-array attributes, for example, it is possible to set the order, name, and namespace for an array of headers in the same way you set it for a single header. When you use the `Order` property on an array, it applies to the entire array.  \n  \n You can apply the <xref:System.ServiceModel.MessageHeaderArrayAttribute> only to arrays, not collections.  \n  \n## Using Byte Arrays in Message Contracts  \n Byte arrays, when used with the non-array attributes (<xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute>), are not treated as arrays but as a special primitive type represented as Base64-encoded data in the resulting XML.  \n  \n When you use byte arrays with the array attribute <xref:System.ServiceModel.MessageHeaderArrayAttribute>, the results depend on the serializer in use. With the default serializer, the array is represented as an individual entry for each byte. However, when the `XmlSerializer` is selected, (using the <xref:System.ServiceModel.XmlSerializerFormatAttribute> on the service contract), byte arrays are treated as Base64 data regardless of whether the array or non-array attributes are used.  \n  \n## Signing and Encrypting Parts of the Message  \n A message contract can indicate whether the headers and/or body of the message should be digitally signed and encrypted.  \n  \n This is done by setting the <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=fullName> property on the <xref:System.ServiceModel.MessageHeaderAttribute> and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes. The property is an enumeration of the <xref:System.Net.Security.ProtectionLevel?displayProperty=fullName> type and can be set to <xref:System.Net.Security.ProtectionLevel> (no encryption or signature), <xref:System.Net.Security.ProtectionLevel> (digital signature only), or <xref:System.Net.Security.ProtectionLevel> (both encryption and a digital signature). The default is <xref:System.Net.Security.ProtectionLevel>.  \n  \n For these security features to work, you must properly configure the binding and behaviors. If you use these security features without the proper configuration (for example, attempting to sign a message without supplying your credentials), an exception is thrown at validation time.  \n  \n For message headers, the protection level is determined individually for each header.  \n  \n For message body parts, the protection level can be thought of as the \"minimum protection level.\" The body has only one protection level, regardless of the number of body parts. The protection level of the body is determined by the highest <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property setting of all the body parts. However, you should set the protection level of each body part to the actual minimum protection level required.  \n  \n Consider the class in the following code example.  \n  \n```csharp  \n[MessageContract]  \npublic class PatientRecord  \n{  \n   [MessageHeader(ProtectionLevel=None)] public int recordID;  \n   [MessageHeader(ProtectionLevel=Sign)] public string patientName;  \n   [MessageHeader(ProtectionLevel=EncryptAndSign)] public string SSN;  \n   [MessageBodyMember(ProtectionLevel=None)] public string comments;  \n   [MessageBodyMember(ProtectionLevel=Sign)] public string diagnosis;  \n   [MessageBodyMember(ProtectionLevel=EncryptAndSign)] public string medicalHistory;  \n}  \n```  \n  \n In this example, the `recordID` header is not protected, `patientName` is `signed`, and `SSN` is encrypted and signed. At least one body part, `medicalHistory`, has <xref:System.Net.Security.ProtectionLevel> applied, and thus the entire message body is encrypted and signed, even though the comments and diagnosis body parts specify lower protection levels.  \n  \n## SOAP Action  \n SOAP and related Web services standards define a property called `Action` that can be present for every SOAP message sent. The operation's <xref:System.ServiceModel.OperationContractAttribute.Action%2A?displayProperty=fullName> and <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A?displayProperty=fullName> properties control the value of this property.  \n  \n## SOAP Header Attributes  \n The SOAP standard defines the following attributes that may exist on a header:  \n  \n-   `Actor/Role` (`Actor` in SOAP 1.1, `Role` in SOAP 1.2)  \n  \n-   `MustUnderstand`  \n  \n-   `Relay`  \n  \n The `Actor` or `Role` attribute specifies the Uniform Resource Identifier (URI) of the node for which a given header is intended. The `MustUnderstand` attribute specifies whether the node processing the header must understand it. The `Relay` attribute specifies whether the header is to be relayed to downstream nodes. [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] does not perform any processing of these attributes on incoming messages, except for the `MustUnderstand` attribute, as specified in the \"Message Contract Versioning\" section later in this topic. However, it allows you to read and write these attributes as necessary, as in the following description.  \n  \n When sending a message, these attributes are not emitted by default. You can change this in two ways. First, you may statically set the attributes to any desired values by changing the <xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A?displayProperty=fullName>, <xref:System.ServiceModel.MessageHeaderAttribute.MustUnderstand%2A?displayProperty=fullName>, and <xref:System.ServiceModel.MessageHeaderAttribute.Relay%2A?displayProperty=fullName> properties, as shown in the following code example. (Note that there is no `Role` property; setting the <xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A> property emits the `Role` attribute if you are using SOAP 1.2).  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader(Actor=\"http://auditingservice.contoso.com\", MustUnderstand=true)] public bool IsAudited;  \n  [MessageHeader] public Operation operation;  \n  [MessageBodyMember] public BankingTransactionData theData;  \n}  \n```  \n  \n The second way to control these attributes is dynamically, through code. You can achieve this by wrapping the desired header type in the <xref:System.ServiceModel.MessageHeader%601> type (be sure not to confuse this type with the non-generic version) and by using the type together with the <xref:System.ServiceModel.MessageHeaderAttribute>. Then, you can use properties on the <xref:System.ServiceModel.MessageHeader%601> to set the SOAP attributes, as shown in the following code example.  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader] public MessageHeader<bool> IsAudited;  \n  [MessageHeader] public Operation operation;  \n  [MessageBodyMember] public BankingTransactionData theData;  \n}  \n// application code:  \nBankingTransaction bt = new BankingTransaction();  \nbt.IsAudited = new MessageHeader<bool>();  \nbt.IsAudited.Content = false; // Set IsAudited header value to \"false\"  \nbt.IsAudited.Actor=\"http://auditingservice.contoso.com\";  \nbt.IsAudited.MustUnderstand=true;  \n```  \n  \n If you use both the dynamic and the static control mechanisms, the static settings are used as a default but can later be overridden by using the dynamic mechanism, as shown in the following code.  \n  \n```csharp  \n[MessageHeader(MustUnderstand=true)] public MessageHeader<Person> documentApprover;  \n// later on in the code:  \nBankingTransaction bt = new BankingTransaction();  \nbt.documentApprover = new MessageHeader<Person>();  \nbt.documentApprover.MustUnderstand = false; // override the static default of 'true'  \n```  \n  \n Creating repeated headers with dynamic attribute control is allowed, as shown in the following code.  \n  \n```csharp  \n[MessageHeaderArray] public MessageHeader<Person> documentApprovers[];  \n```  \n  \n On the receiving side, reading these SOAP attributes can only be done if the <xref:System.ServiceModel.MessageHeader%601> class is used for the header in the type. Examine the `Actor`, `Relay`, or `MustUnderstand` properties of a header of the <xref:System.ServiceModel.MessageHeader%601> type to discover the attribute settings on the received message.  \n  \n When a message is received and then sent back, the SOAP attribute settings only go round-trip for headers of the <xref:System.ServiceModel.MessageHeader%601> type.  \n  \n## Order of SOAP Body Parts  \n In some circumstances, you may need to control the order of the body parts. The order of the body elements is alphabetical by default, but can be controlled by the <xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName> property. This property has the same semantics as the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A?displayProperty=fullName> property, except for the behavior in inheritance scenarios (in message contracts, base type body members are not sorted before the derived type body members). [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Data Member Order](../../../../docs/framework/wcf/feature-details/data-member-order.md).  \n  \n In the following example, `amount` would normally come first because it is first alphabetically. However, the <xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A> property puts it into the third position.  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader] public Operation operation;  \n  [MessageBodyMember(Order=1)] public Account sourceAccount;  \n  [MessageBodyMember(Order=2)] public Account targetAccount;  \n  [MessageBodyMember(Order=3)] public int amount;  \n}  \n```  \n  \n## Message Contract Versioning  \n Occasionally, you may need to change message contracts. For example, a new version of your application may add an extra header to a message. Then, when sending from the new version to the old, the system must deal with an extra header, as well as a missing header when going in the other direction.  \n  \n The following rules apply for versioning headers:  \n  \n-   [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] does not object to the missing headers—the corresponding members are left at their default values.  \n  \n-   [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] also ignores unexpected extra headers. The one exception to this rule is if the extra header has a `MustUnderstand` attribute set to `true` in the incoming SOAP message—in this case, an exception is thrown because a header that must be understood cannot be processed.  \n  \n Message bodies have similar versioning rules—both missing and additional message body parts are ignored.  \n  \n## Inheritance Considerations  \n A message contract type can inherit from another type, as long as the base type also has a message contract.  \n  \n When creating or accessing a message using a message contract type that inherits from other message contract types, the following rules apply:  \n  \n-   All of the message headers in the inheritance hierarchy are collected together to form the full set of headers for the message.  \n  \n-   All of the message body parts in the inheritance hierarchy are collected together to form the full message body. The body parts are ordered according to the usual ordering rules (by <xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName> property and then alphabetical), with no relevance to their place in the inheritance hierarchy. Using message contract inheritance where message body parts occur at multiple levels of the inheritance tree is strongly discouraged. If a base class and a derived class define a header or a body part with the same name, the member from the base-most class is used to store the value of that header or body part.  \n  \n Consider the classes in the following code example.  \n  \n```csharp  \n[MessageContract]  \npublic class PersonRecord  \n{  \n  [MessageHeader(Name=\"ID\")] public int personID;  \n  [MessageBodyMember] public string patientName;  \n}  \n  \n[MessageContract]  \npublic class PatientRecord : PersonRecord  \n{  \n  [MessageHeader(Name=\"ID\")] public int patientID;  \n  [MessageBodyMember] public string diagnosis;  \n}  \n```  \n  \n The `PatientRecord` class describes a message with one header called `ID`. The header corresponds to the `personID` and not the `patientID` member, because the base-most member is chosen. Thus, the `patientID` field is useless in this case. The body of the message contains the `diagnosis` element followed by the `patientName` element, because that is the alphabetical order. Notice that the example shows a pattern that is strongly discouraged: both the base and the derived message contracts have message body parts.  \n  \n## WSDL Considerations  \n When generating a Web Services Description Language (WSDL) contract from a service that uses message contracts, it is important to remember that not all message contract features are reflected in the resulting WSDL. Consider the following points:  \n  \n-   WSDL cannot express the concept of an array of headers. When creating messages with an array of headers using the <xref:System.ServiceModel.MessageHeaderArrayAttribute>, the resulting WSDL reflects only one header instead of the array.  \n  \n-   The resulting WSDL document may not reflect some protection-level information.  \n  \n-   The message type generated in the WSDL has the same name as the class name of the message contract type.  \n  \n-   When using the same message contract in multiple operations, multiple message types are generated in the WSDL document. The names are made unique by adding the numbers \"2\", \"3\", and so on, for subsequent uses. When importing back the WSDL, multiple message contract types are created and are identical except for their names.  \n  \n## SOAP Encoding Considerations  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] allows you to use the legacy SOAP encoding style of XML, however, its use is not recommended. When using this style (by setting the `Use` property to `Encoded` on the <xref:System.ServiceModel.XmlSerializerFormatAttribute?displayProperty=fullName> applied to the service contract), the following additional considerations apply:  \n  \n-   The message headers are not supported; this means that the attribute <xref:System.ServiceModel.MessageHeaderAttribute> and the array attribute <xref:System.ServiceModel.MessageHeaderArrayAttribute> are incompatible with SOAP encoding.  \n  \n-   If the message contract is not wrapped, that is, if the property <xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A> is set to `false`, the message contract can have only one body part.  \n  \n-   The name of the wrapper element for the request message contract must match the operation name. Use the `WrapperName` property of the message contract for this.  \n  \n-   The name of the wrapper element for the response message contract must be the same as the name of the operation suffixed by 'Response'. Use the <xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A> property of the message contract for this.  \n  \n-   SOAP encoding preserves object references. For example, consider the following code.  \n  \n    ```csharp  \n    [MessageContract(WrapperName=\"updateChangeRecord\")]  \n    public class ChangeRecordRequest  \n    {  \n      [MessageBodyMember] Person changedBy;  \n      [MessageBodyMember] Person changedFrom;  \n      [MessageBodyMember] Person changedTo;  \n    }  \n  \n    [MessageContract(WrapperName=\"updateChangeRecordResponse\")]  \n    public class ChangeRecordResponse  \n    {  \n      [MessageBodyMember] Person changedBy;  \n      [MessageBodyMember] Person changedFrom;  \n      [MessageBodyMember] Person changedTo;  \n    }  \n  \n    // application code:  \n    ChangeRecordRequest cr = new ChangeRecordRequest();  \n    Person p = new Person(\"John Doe\");  \n    cr.changedBy=p;  \n    cr.changedFrom=p;  \n    cr.changedTo=p;  \n    ```  \n  \n After serializing the message using SOAP encoding, `changedFrom` and `changedTo` do not contain their own copies of `p`, but instead point to the copy inside the `changedBy` element.  \n  \n## Performance Considerations  \n Every message header and message body part is serialized independently of the others. Therefore, the same namespaces can be declared again for each header and body part. To improve performance, especially in terms of the size of the message on the wire, consolidate multiple headers and body parts into a single header or body part. For example, instead of the following code:  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader] public Operation operation;  \n  [MessageBodyMember] public Account sourceAccount;  \n  [MessageBodyMember] public Account targetAccount;  \n  [MessageBodyMember] public int amount;  \n}  \n```  \n  \n Use this code.  \n  \n```csharp  \n[MessageContract]  \npublic class BankingTransaction  \n{  \n  [MessageHeader] public Operation operation;  \n  [MessageBodyMember] public OperationDetails details;  \n}  \n  \n[DataContract]  \npublic class OperationDetails  \n{  \n  [DataMember] public Account sourceAccount;  \n  [DataMember] public Account targetAccount;  \n  [DataMember] public int amount;  \n}  \n```  \n  \n### Event-based Asynchronous and Message Contracts  \n The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the `Result` property and the others are returned as properties on the <xref:System.EventArgs> object. One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <xref:System.EventArgs> object returns one value as the `Result` property and the remainder are properties of the <xref:System.EventArgs> object.  \n  \n If you want to receive the message object as the `Result` property and have the returned values as properties on that object, use the `/messageContract` command option. This generates a signature that returns the response message as the `Result` property on the <xref:System.EventArgs> object. All internal return values are then properties of the response message object.  \n  \n## See Also  \n [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)   \n [Designing and Implementing Services](../../../../docs/framework/wcf/designing-and-implementing-services.md)","nodes":[{"pos":[4,430],"embed":true,"restype":"x-metadata","content":"title: \"Using Message Contracts | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"message contracts [WCF]\"\nms.assetid: 1e19c64a-ae84-4c2f-9155-91c54a77c249\ncaps.latest.revision: 46\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"","nodes":[{"content":"Using Message Contracts | Microsoft Docs","nodes":[{"pos":[0,40],"content":"Using Message Contracts | Microsoft Docs","nodes":[{"content":"Using Message Contracts | Microsoft Docs","pos":[0,40]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[437,460],"content":"Using Message Contracts","linkify":"Using Message Contracts","nodes":[{"content":"Using Message Contracts","pos":[0,23]}]},{"content":"Typically when building <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> applications, developers pay close attention to the data structures and serialization issues and do not need to concern themselves with the structure of the messages in which the data is carried.","pos":[461,736],"source":"Typically when building [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] applications, developers pay close attention to the data structures and serialization issues and do not need to concern themselves with the structure of the messages in which the data is carried."},{"content":"For these applications, creating data contracts for the parameters or return values is straightforward.","pos":[737,840]},{"content":"(<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Specifying Data Transfer in Service Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.)","pos":[841,1047],"source":" ([!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).)"},{"content":"However, sometimes complete control over the structure of a SOAP message is just as important as control over its contents.","pos":[1054,1177]},{"content":"This is especially true when interoperability is important or to specifically control security issues at the level of the message or message part.","pos":[1178,1324]},{"content":"In these cases, you can create a <bpt id=\"p1\">*</bpt>message contract<ept id=\"p1\">*</ept> that enables you to specify the structure of the precise SOAP message required.","pos":[1325,1456],"source":" In these cases, you can create a *message contract* that enables you to specify the structure of the precise SOAP message required."},{"content":"This topic discusses how to use the various message contract attributes to create a specific message contract for your operation.","pos":[1463,1592]},{"pos":[1601,1638],"content":"Using Message Contracts in Operations","linkify":"Using Message Contracts in Operations","nodes":[{"content":"Using Message Contracts in Operations","pos":[0,37]}]},{"content":"supports operations modeled on either the <bpt id=\"p1\">*</bpt>remote procedure call (RPC) style<ept id=\"p1\">*</ept> or the <bpt id=\"p2\">*</bpt>messaging style<ept id=\"p2\">*</ept>.","pos":[1698,1801],"source":" supports operations modeled on either the *remote procedure call (RPC) style* or the *messaging style*."},{"content":"In an RPC-style operation, you can use any serializable type, and you have access to the features that are available to local calls, such as multiple parameters and <ph id=\"ph1\">`ref`</ph> and <ph id=\"ph2\">`out`</ph> parameters.","pos":[1802,1994],"source":" In an RPC-style operation, you can use any serializable type, and you have access to the features that are available to local calls, such as multiple parameters and `ref` and `out` parameters."},{"content":"In this style, the form of serialization chosen controls the structure of the data in the underlying messages, and the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime creates the messages to support the operation.","pos":[1995,2224],"source":" In this style, the form of serialization chosen controls the structure of the data in the underlying messages, and the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime creates the messages to support the operation."},{"content":"This enables developers who are not familiar with SOAP and SOAP messages to quickly and easily create and use service applications.","pos":[2225,2356]},{"content":"The following code example shows a service operation modeled on the RPC style.","pos":[2363,2441]},{"content":"Normally, a data contract is sufficient to define the schema for the messages.","pos":[2574,2652]},{"content":"For instance, in the preceding example, it is sufficient for most applications if <ph id=\"ph1\">`BankingTransaction`</ph> and <ph id=\"ph2\">`BankingTransactionResponse`</ph> have data contracts to define the contents of the underlying SOAP messages.","pos":[2653,2864],"source":" For instance, in the preceding example, it is sufficient for most applications if `BankingTransaction` and `BankingTransactionResponse` have data contracts to define the contents of the underlying SOAP messages."},{"content":"<ph id=\"ph1\">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> data contracts, see <bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.","pos":[2865,3036],"source":"[!INCLUDE[crabout](../../../../includes/crabout-md.md)] data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)."},{"content":"However, occasionally it is necessary to precisely control how the structure of the SOAP message transmitted over the wire.","pos":[3043,3166]},{"content":"The most common scenario for this is inserting custom SOAP headers.","pos":[3167,3234]},{"content":"Another common scenario is to define security properties for the message's headers and body, that is, to decide whether these elements are digitally signed and encrypted.","pos":[3235,3405]},{"content":"Finally, some third-party SOAP stacks require messages be in a specific format.","pos":[3406,3485]},{"content":"Messaging-style operations provide this control.","pos":[3486,3534]},{"content":"A messaging-style operation has at most one parameter and one return value where both types are message types; that is, they serialize directly into a specified SOAP message structure.","pos":[3541,3725]},{"content":"This may be any type marked with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> type.","pos":[3726,3871],"source":" This may be any type marked with the <xref:System.ServiceModel.MessageContractAttribute> or the <xref:System.ServiceModel.Channels.Message> type."},{"content":"The following code example shows an operation similar to the preceding RCP-style, but which uses the messaging style.","pos":[3872,3989]},{"pos":[3996,4160],"content":"For example, if <ph id=\"ph1\">`BankingTransaction`</ph> and <ph id=\"ph2\">`BankingTransactionResponse`</ph> are both types that are message contracts, then the code in the following operations is valid.","source":"For example, if `BankingTransaction` and `BankingTransactionResponse` are both types that are message contracts, then the code in the following operations is valid."},{"content":"However, the following code is invalid.","pos":[4396,4435]},{"content":"An exception is thrown for any operation that involves a message contract type and that does not follow one of the valid patterns.","pos":[4718,4848]},{"content":"Of course, operations that do not involve message contract types are not subject to these restrictions.","pos":[4849,4952]},{"content":"If a type has both a message contract and a data contract, only its message contract is considered when the type is used in an operation.","pos":[4959,5096]},{"pos":[5105,5131],"content":"Defining Message Contracts","linkify":"Defining Message Contracts","nodes":[{"content":"Defining Message Contracts","pos":[0,26]}]},{"content":"To define a message contract for a type (that is, to define the mapping between the type and a SOAP envelope), apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> to the type.","pos":[5135,5320],"source":"To define a message contract for a type (that is, to define the mapping between the type and a SOAP envelope), apply the <xref:System.ServiceModel.MessageContractAttribute> to the type."},{"content":"Then apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> to those members of the type you want to make into SOAP headers, and apply the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> to those members you want to make into parts of the SOAP body of the message.","pos":[5321,5596],"source":" Then apply the <xref:System.ServiceModel.MessageHeaderAttribute> to those members of the type you want to make into SOAP headers, and apply the <xref:System.ServiceModel.MessageBodyMemberAttribute> to those members you want to make into parts of the SOAP body of the message."},{"content":"The following code provides an example of using a message contract.","pos":[5603,5670]},{"content":"When using this type as an operation parameter, the following SOAP envelope is generated:","pos":[6014,6103]},{"pos":[6780,6975],"content":"Notice that <ph id=\"ph1\">`operation`</ph> and <ph id=\"ph2\">`transactionDate`</ph> appear as SOAP headers and the SOAP body consists of a wrapper element <ph id=\"ph3\">`BankingTransaction`</ph> containing <ph id=\"ph4\">`sourceAccount`</ph>,<ph id=\"ph5\">`targetAccount`</ph>, and <ph id=\"ph6\">`amount`</ph>.","source":"Notice that `operation` and `transactionDate` appear as SOAP headers and the SOAP body consists of a wrapper element `BankingTransaction` containing `sourceAccount`,`targetAccount`, and `amount`."},{"content":"You can apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> to all fields, properties, and events, regardless of whether they are public, private, protected, or internal.","pos":[6982,7218],"source":"You can apply the <xref:System.ServiceModel.MessageHeaderAttribute> and <xref:System.ServiceModel.MessageBodyMemberAttribute> to all fields, properties, and events, regardless of whether they are public, private, protected, or internal."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> allows you to specify the WrapperName and WrapperNamespace attributes which control the name of the wrapper element in the body of the SOAP message.","pos":[7225,7429],"source":"The <xref:System.ServiceModel.MessageContractAttribute> allows you to specify the WrapperName and WrapperNamespace attributes which control the name of the wrapper element in the body of the SOAP message."},{"content":"By default the name of the message contract type is used for the wrapper and the namespace in which the message contract is defined  <ph id=\"ph1\">`HYPERLINK \"http://tempuri.org/\" http://tempuri.org/`</ph> is used as the default namespace.","pos":[7430,7650],"source":" By default the name of the message contract type is used for the wrapper and the namespace in which the message contract is defined  `HYPERLINK \"http://tempuri.org/\" http://tempuri.org/` is used as the default namespace."},{"pos":[7658,7915],"content":"[!NOTE]\n <xref:System.Runtime.Serialization.KnownTypeAttribute> attributes are ignored in message contracts. If a <xref:System.Runtime.Serialization.KnownTypeAttribute> is required, place it on the operation that is using the message contract in question.","leadings":["","> "],"nodes":[{"content":"<xref:System.Runtime.Serialization.KnownTypeAttribute> attributes are ignored in message contracts. If a <xref:System.Runtime.Serialization.KnownTypeAttribute> is required, place it on the operation that is using the message contract in question.","pos":[9,255],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attributes are ignored in message contracts.","pos":[0,99],"source":"<xref:System.Runtime.Serialization.KnownTypeAttribute> attributes are ignored in message contracts."},{"content":"If a <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> is required, place it on the operation that is using the message contract in question.","pos":[100,246],"source":" If a <xref:System.Runtime.Serialization.KnownTypeAttribute> is required, place it on the operation that is using the message contract in question."}]}]},{"pos":[7924,7977],"content":"Controlling Header and Body Part Names and Namespaces","linkify":"Controlling Header and Body Part Names and Namespaces","nodes":[{"content":"Controlling Header and Body Part Names and Namespaces","pos":[0,53]}]},{"content":"In the SOAP representation of a message contract, each header and body part maps to an XML element that has a name and a namespace.","pos":[7981,8112]},{"content":"By default, the namespace is the same as the namespace of the service contract that the message is participating in, and the name is determined by the member name to which the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> attributes are applied.","pos":[8119,8429],"source":"By default, the namespace is the same as the namespace of the service contract that the message is participating in, and the name is determined by the member name to which the <xref:System.ServiceModel.MessageHeaderAttribute> or the <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes are applied."},{"content":"You can change these defaults by manipulating the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.Name%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.Namespace%2A?displayProperty=fullName&gt;</ph> (on the parent class of the <ph id=\"ph3\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> attributes).","pos":[8436,8825],"source":"You can change these defaults by manipulating the <xref:System.ServiceModel.MessageContractMemberAttribute.Name%2A?displayProperty=fullName> and <xref:System.ServiceModel.MessageContractMemberAttribute.Namespace%2A?displayProperty=fullName> (on the parent class of the <xref:System.ServiceModel.MessageHeaderAttribute> and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes)."},{"content":"Consider the class in the following code example.","pos":[8832,8881]},{"content":"In this example, the <ph id=\"ph1\">`IsAudited`</ph> header is in the namespace specified in the code, and the body part that represents the <ph id=\"ph2\">`theData`</ph> member is represented by an XML element with the name <ph id=\"ph3\">`transactionData`</ph>.","pos":[9203,9406],"source":"In this example, the `IsAudited` header is in the namespace specified in the code, and the body part that represents the `theData` member is represented by an XML element with the name `transactionData`."},{"content":"The following shows the XML generated for this message contract.","pos":[9407,9471]},{"pos":[10100,10151],"content":"Controlling Whether the SOAP Body Parts Are Wrapped","linkify":"Controlling Whether the SOAP Body Parts Are Wrapped","nodes":[{"content":"Controlling Whether the SOAP Body Parts Are Wrapped","pos":[0,51]}]},{"content":"By default, the SOAP body parts are serialized inside a wrapped element.","pos":[10155,10227]},{"content":"For example, the following code shows the <ph id=\"ph1\">`HelloGreetingMessage`</ph> wrapper element generated from the name of the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> type in the message contract for the <ph id=\"ph3\">`HelloGreetingMessage`</ph> message.","pos":[10228,10460],"source":" For example, the following code shows the `HelloGreetingMessage` wrapper element generated from the name of the <xref:System.ServiceModel.MessageContractAttribute> type in the message contract for the `HelloGreetingMessage` message."},{"content":"To suppress the wrapper element, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","pos":[10743,10869],"source":"To suppress the wrapper element, set the <xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A> property to `false`."},{"content":"To control the name and the namespace of the wrapper element, use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageContractAttribute.WrapperNamespace%2A&gt;</ph> properties.","pos":[10870,11094],"source":" To control the name and the namespace of the wrapper element, use the <xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A> and <xref:System.ServiceModel.MessageContractAttribute.WrapperNamespace%2A> properties."},{"pos":[11102,11630],"content":"[!NOTE]\n Having more than one message body part in messages that are not wrapped is not compliant with WS-I Basic Profile 1.1 and is not recommended when designing new message contracts. However, it may be necessary to have more than one unwrapped message body part in certain specific interoperability scenarios. If you are going to transmit more than one piece of data in a message body, it is recommended to use the default (wrapped) mode. Having more than one message header in unwrapped messages is completely acceptable.","leadings":["","> "],"nodes":[{"content":"Having more than one message body part in messages that are not wrapped is not compliant with WS-I Basic Profile 1.1 and is not recommended when designing new message contracts. However, it may be necessary to have more than one unwrapped message body part in certain specific interoperability scenarios. If you are going to transmit more than one piece of data in a message body, it is recommended to use the default (wrapped) mode. Having more than one message header in unwrapped messages is completely acceptable.","pos":[9,526],"nodes":[{"content":"Having more than one message body part in messages that are not wrapped is not compliant with WS-I Basic Profile 1.1 and is not recommended when designing new message contracts.","pos":[0,177]},{"content":"However, it may be necessary to have more than one unwrapped message body part in certain specific interoperability scenarios.","pos":[178,304]},{"content":"If you are going to transmit more than one piece of data in a message body, it is recommended to use the default (wrapped) mode.","pos":[305,433]},{"content":"Having more than one message header in unwrapped messages is completely acceptable.","pos":[434,517]}]}]},{"pos":[11639,11682],"content":"Using Custom Types Inside Message Contracts","linkify":"Using Custom Types Inside Message Contracts","nodes":[{"content":"Using Custom Types Inside Message Contracts","pos":[0,43]}]},{"content":"Each individual message header and message body part is serialized (turned into XML) using the chosen serialization engine for the service contract where the message is used.","pos":[11686,11860]},{"content":"The default serialization engine, the <ph id=\"ph1\">`XmlFormatter`</ph>, can handle any type that has a data contract, either explicitly (by having the <ph id=\"ph2\">&lt;xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=fullName&gt;</ph>) or implicitly (by being a primitive type, having the <ph id=\"ph3\">&lt;xref:System.SerializableAttribute?displayProperty=fullName&gt;</ph>, and so on).","pos":[11861,12204],"source":" The default serialization engine, the `XmlFormatter`, can handle any type that has a data contract, either explicitly (by having the <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=fullName>) or implicitly (by being a primitive type, having the <xref:System.SerializableAttribute?displayProperty=fullName>, and so on)."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.","pos":[12205,12359],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)."},{"pos":[12366,12593],"content":"In the preceding example, the <ph id=\"ph1\">`Operation`</ph> and <ph id=\"ph2\">`BankingTransactionData`</ph> types must have a data contract, and <ph id=\"ph3\">`transactionDate`</ph> is serializable because <ph id=\"ph4\">&lt;xref:System.DateTime&gt;</ph> is a primitive (and so has an implicit data contract).","source":"In the preceding example, the `Operation` and `BankingTransactionData` types must have a data contract, and `transactionDate` is serializable because <xref:System.DateTime> is a primitive (and so has an implicit data contract)."},{"content":"However, it is possible to switch to a different serialization engine, the <ph id=\"ph1\">`XmlSerializer`</ph>.","pos":[12600,12691],"source":"However, it is possible to switch to a different serialization engine, the `XmlSerializer`."},{"content":"If you make such a switch, you should ensure that all of the types used for message headers and body parts are serializable using the <ph id=\"ph1\">`XmlSerializer`</ph>.","pos":[12692,12842],"source":" If you make such a switch, you should ensure that all of the types used for message headers and body parts are serializable using the `XmlSerializer`."},{"pos":[12851,12888],"content":"Using Arrays Inside Message Contracts","linkify":"Using Arrays Inside Message Contracts","nodes":[{"content":"Using Arrays Inside Message Contracts","pos":[0,37]}]},{"content":"You can use arrays of repeating elements in message contracts in two ways.","pos":[12892,12966]},{"content":"The first is to use a <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> or a <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> directly on the array.","pos":[12973,13126],"source":"The first is to use a <xref:System.ServiceModel.MessageHeaderAttribute> or a <xref:System.ServiceModel.MessageBodyMemberAttribute> directly on the array."},{"content":"In this case, the entire array is serialized as one element (that is, one header or one body part) with multiple child elements.","pos":[13127,13255]},{"content":"Consider the class in the following example.","pos":[13256,13300]},{"content":"This results in SOAP headers is similar to the following.","pos":[13525,13582]},{"content":"An alternative to this is to use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>.","pos":[13864,13956],"source":"An alternative to this is to use the <xref:System.ServiceModel.MessageHeaderArrayAttribute>."},{"content":"In this case, each array element is serialized independently and so that each array element has one header, similar to the following.","pos":[13957,14090]},{"content":"The default name for array entries is the name of the member to which the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> attributes is applied.","pos":[14260,14411],"source":"The default name for array entries is the name of the member to which the <xref:System.ServiceModel.MessageHeaderArrayAttribute> attributes is applied."},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> attribute inherits from the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>.","pos":[14418,14555],"source":"The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute inherits from the <xref:System.ServiceModel.MessageHeaderAttribute>."},{"content":"It has the same set of features as the non-array attributes, for example, it is possible to set the order, name, and namespace for an array of headers in the same way you set it for a single header.","pos":[14556,14754]},{"content":"When you use the <ph id=\"ph1\">`Order`</ph> property on an array, it applies to the entire array.","pos":[14755,14833],"source":" When you use the `Order` property on an array, it applies to the entire array."},{"content":"You can apply the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> only to arrays, not collections.","pos":[14840,14945],"source":"You can apply the <xref:System.ServiceModel.MessageHeaderArrayAttribute> only to arrays, not collections."},{"pos":[14954,14992],"content":"Using Byte Arrays in Message Contracts","linkify":"Using Byte Arrays in Message Contracts","nodes":[{"content":"Using Byte Arrays in Message Contracts","pos":[0,38]}]},{"content":"Byte arrays, when used with the non-array attributes (<ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>), are not treated as arrays but as a special primitive type represented as Base64-encoded data in the resulting XML.","pos":[14996,15274],"source":"Byte arrays, when used with the non-array attributes (<xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute>), are not treated as arrays but as a special primitive type represented as Base64-encoded data in the resulting XML."},{"content":"When you use byte arrays with the array attribute <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>, the results depend on the serializer in use.","pos":[15281,15431],"source":"When you use byte arrays with the array attribute <xref:System.ServiceModel.MessageHeaderArrayAttribute>, the results depend on the serializer in use."},{"content":"With the default serializer, the array is represented as an individual entry for each byte.","pos":[15432,15523]},{"content":"However, when the <ph id=\"ph1\">`XmlSerializer`</ph> is selected, (using the <ph id=\"ph2\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> on the service contract), byte arrays are treated as Base64 data regardless of whether the array or non-array attributes are used.","pos":[15524,15768],"source":" However, when the `XmlSerializer` is selected, (using the <xref:System.ServiceModel.XmlSerializerFormatAttribute> on the service contract), byte arrays are treated as Base64 data regardless of whether the array or non-array attributes are used."},{"pos":[15777,15820],"content":"Signing and Encrypting Parts of the Message","linkify":"Signing and Encrypting Parts of the Message","nodes":[{"content":"Signing and Encrypting Parts of the Message","pos":[0,43]}]},{"content":"A message contract can indicate whether the headers and/or body of the message should be digitally signed and encrypted.","pos":[15824,15944]},{"content":"This is done by setting the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=fullName&gt;</ph> property on the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> attributes.","pos":[15951,16216],"source":"This is done by setting the <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=fullName> property on the <xref:System.ServiceModel.MessageHeaderAttribute> and <xref:System.ServiceModel.MessageBodyMemberAttribute> attributes."},{"content":"The property is an enumeration of the <ph id=\"ph1\">&lt;xref:System.Net.Security.ProtectionLevel?displayProperty=fullName&gt;</ph> type and can be set to <ph id=\"ph2\">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> (no encryption or signature), <ph id=\"ph3\">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> (digital signature only), or <ph id=\"ph4\">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> (both encryption and a digital signature).","pos":[16217,16576],"source":" The property is an enumeration of the <xref:System.Net.Security.ProtectionLevel?displayProperty=fullName> type and can be set to <xref:System.Net.Security.ProtectionLevel> (no encryption or signature), <xref:System.Net.Security.ProtectionLevel> (digital signature only), or <xref:System.Net.Security.ProtectionLevel> (both encryption and a digital signature)."},{"content":"The default is <ph id=\"ph1\">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph>.","pos":[16577,16635],"source":" The default is <xref:System.Net.Security.ProtectionLevel>."},{"content":"For these security features to work, you must properly configure the binding and behaviors.","pos":[16642,16733]},{"content":"If you use these security features without the proper configuration (for example, attempting to sign a message without supplying your credentials), an exception is thrown at validation time.","pos":[16734,16924]},{"content":"For message headers, the protection level is determined individually for each header.","pos":[16931,17016]},{"content":"For message body parts, the protection level can be thought of as the \"minimum protection level.\"","pos":[17023,17120]},{"content":"The body has only one protection level, regardless of the number of body parts.","pos":[17121,17200]},{"content":"The protection level of the body is determined by the highest <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A&gt;</ph> property setting of all the body parts.","pos":[17201,17379],"source":" The protection level of the body is determined by the highest <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A> property setting of all the body parts."},{"content":"However, you should set the protection level of each body part to the actual minimum protection level required.","pos":[17380,17491]},{"content":"Consider the class in the following code example.","pos":[17498,17547]},{"content":"In this example, the <ph id=\"ph1\">`recordID`</ph> header is not protected, <ph id=\"ph2\">`patientName`</ph> is <ph id=\"ph3\">`signed`</ph>, and <ph id=\"ph4\">`SSN`</ph> is encrypted and signed.","pos":[18068,18186],"source":"In this example, the `recordID` header is not protected, `patientName` is `signed`, and `SSN` is encrypted and signed."},{"content":"At least one body part, <ph id=\"ph1\">`medicalHistory`</ph>, has <ph id=\"ph2\">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> applied, and thus the entire message body is encrypted and signed, even though the comments and diagnosis body parts specify lower protection levels.","pos":[18187,18425],"source":" At least one body part, `medicalHistory`, has <xref:System.Net.Security.ProtectionLevel> applied, and thus the entire message body is encrypted and signed, even though the comments and diagnosis body parts specify lower protection levels."},{"pos":[18434,18445],"content":"SOAP Action","linkify":"SOAP Action","nodes":[{"content":"SOAP Action","pos":[0,11]}]},{"content":"SOAP and related Web services standards define a property called <ph id=\"ph1\">`Action`</ph> that can be present for every SOAP message sent.","pos":[18449,18571],"source":"SOAP and related Web services standards define a property called `Action` that can be present for every SOAP message sent."},{"content":"The operation's <ph id=\"ph1\">&lt;xref:System.ServiceModel.OperationContractAttribute.Action%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A?displayProperty=fullName&gt;</ph> properties control the value of this property.","pos":[18572,18821],"source":" The operation's <xref:System.ServiceModel.OperationContractAttribute.Action%2A?displayProperty=fullName> and <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A?displayProperty=fullName> properties control the value of this property."},{"pos":[18830,18852],"content":"SOAP Header Attributes","linkify":"SOAP Header Attributes","nodes":[{"content":"SOAP Header Attributes","pos":[0,22]}]},{"content":"The SOAP standard defines the following attributes that may exist on a header:","pos":[18856,18934]},{"pos":[18944,18998],"content":"<ph id=\"ph1\">`Actor/Role`</ph> (<ph id=\"ph2\">`Actor`</ph> in SOAP 1.1, <ph id=\"ph3\">`Role`</ph> in SOAP 1.2)","source":"`Actor/Role` (`Actor` in SOAP 1.1, `Role` in SOAP 1.2)"},{"content":"The <ph id=\"ph1\">`Actor`</ph> or <ph id=\"ph2\">`Role`</ph> attribute specifies the Uniform Resource Identifier (URI) of the node for which a given header is intended.","pos":[19048,19177],"source":"The `Actor` or `Role` attribute specifies the Uniform Resource Identifier (URI) of the node for which a given header is intended."},{"content":"The <ph id=\"ph1\">`MustUnderstand`</ph> attribute specifies whether the node processing the header must understand it.","pos":[19178,19277],"source":" The `MustUnderstand` attribute specifies whether the node processing the header must understand it."},{"content":"The <ph id=\"ph1\">`Relay`</ph> attribute specifies whether the header is to be relayed to downstream nodes.","pos":[19278,19366],"source":" The `Relay` attribute specifies whether the header is to be relayed to downstream nodes."},{"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does not perform any processing of these attributes on incoming messages, except for the <ph id=\"ph2\">`MustUnderstand`</ph> attribute, as specified in the \"Message Contract Versioning\" section later in this topic.","pos":[19367,19618],"source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] does not perform any processing of these attributes on incoming messages, except for the `MustUnderstand` attribute, as specified in the \"Message Contract Versioning\" section later in this topic."},{"content":"However, it allows you to read and write these attributes as necessary, as in the following description.","pos":[19619,19723]},{"content":"When sending a message, these attributes are not emitted by default.","pos":[19730,19798]},{"content":"You can change this in two ways.","pos":[19799,19831]},{"content":"First, you may statically set the attributes to any desired values by changing the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute.MustUnderstand%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.ServiceModel.MessageHeaderAttribute.Relay%2A?displayProperty=fullName&gt;</ph> properties, as shown in the following code example.","pos":[19832,20233],"source":" First, you may statically set the attributes to any desired values by changing the <xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A?displayProperty=fullName>, <xref:System.ServiceModel.MessageHeaderAttribute.MustUnderstand%2A?displayProperty=fullName>, and <xref:System.ServiceModel.MessageHeaderAttribute.Relay%2A?displayProperty=fullName> properties, as shown in the following code example."},{"content":"(Note that there is no <ph id=\"ph1\">`Role`</ph> property; setting the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A&gt;</ph> property emits the <ph id=\"ph3\">`Role`</ph> attribute if you are using SOAP 1.2).","pos":[20234,20408],"source":" (Note that there is no `Role` property; setting the <xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A> property emits the `Role` attribute if you are using SOAP 1.2)."},{"content":"The second way to control these attributes is dynamically, through code.","pos":[20717,20789]},{"content":"You can achieve this by wrapping the desired header type in the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> type (be sure not to confuse this type with the non-generic version) and by using the type together with the <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>.","pos":[20790,21058],"source":" You can achieve this by wrapping the desired header type in the <xref:System.ServiceModel.MessageHeader%601> type (be sure not to confuse this type with the non-generic version) and by using the type together with the <xref:System.ServiceModel.MessageHeaderAttribute>."},{"content":"Then, you can use properties on the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> to set the SOAP attributes, as shown in the following code example.","pos":[21059,21207],"source":" Then, you can use properties on the <xref:System.ServiceModel.MessageHeader%601> to set the SOAP attributes, as shown in the following code example."},{"content":"If you use both the dynamic and the static control mechanisms, the static settings are used as a default but can later be overridden by using the dynamic mechanism, as shown in the following code.","pos":[21753,21949]},{"content":"Creating repeated headers with dynamic attribute control is allowed, as shown in the following code.","pos":[22282,22382]},{"content":"On the receiving side, reading these SOAP attributes can only be done if the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> class is used for the header in the type.","pos":[22483,22646],"source":"On the receiving side, reading these SOAP attributes can only be done if the <xref:System.ServiceModel.MessageHeader%601> class is used for the header in the type."},{"content":"Examine the <ph id=\"ph1\">`Actor`</ph>, <ph id=\"ph2\">`Relay`</ph>, or <ph id=\"ph3\">`MustUnderstand`</ph> properties of a header of the <ph id=\"ph4\">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> type to discover the attribute settings on the received message.","pos":[22647,22836],"source":" Examine the `Actor`, `Relay`, or `MustUnderstand` properties of a header of the <xref:System.ServiceModel.MessageHeader%601> type to discover the attribute settings on the received message."},{"content":"When a message is received and then sent back, the SOAP attribute settings only go round-trip for headers of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> type.","pos":[22843,23006],"source":"When a message is received and then sent back, the SOAP attribute settings only go round-trip for headers of the <xref:System.ServiceModel.MessageHeader%601> type."},{"pos":[23015,23039],"content":"Order of SOAP Body Parts","linkify":"Order of SOAP Body Parts","nodes":[{"content":"Order of SOAP Body Parts","pos":[0,24]}]},{"content":"In some circumstances, you may need to control the order of the body parts.","pos":[23043,23118]},{"content":"The order of the body elements is alphabetical by default, but can be controlled by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName&gt;</ph> property.","pos":[23119,23304],"source":" The order of the body elements is alphabetical by default, but can be controlled by the <xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName> property."},{"content":"This property has the same semantics as the <ph id=\"ph1\">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A?displayProperty=fullName&gt;</ph> property, except for the behavior in inheritance scenarios (in message contracts, base type body members are not sorted before the derived type body members).","pos":[23305,23597],"source":" This property has the same semantics as the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A?displayProperty=fullName> property, except for the behavior in inheritance scenarios (in message contracts, base type body members are not sorted before the derived type body members)."},{"content":"<ph id=\"ph1\">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id=\"p1\">[</bpt>Data Member Order<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/data-member-order.md)</ept>.","pos":[23598,23746],"source":"[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Data Member Order](../../../../docs/framework/wcf/feature-details/data-member-order.md)."},{"content":"In the following example, <ph id=\"ph1\">`amount`</ph> would normally come first because it is first alphabetically.","pos":[23753,23849],"source":"In the following example, `amount` would normally come first because it is first alphabetically."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A&gt;</ph> property puts it into the third position.","pos":[23850,23967],"source":" However, the <xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A> property puts it into the third position."},{"pos":[24285,24312],"content":"Message Contract Versioning","linkify":"Message Contract Versioning","nodes":[{"content":"Message Contract Versioning","pos":[0,27]}]},{"content":"Occasionally, you may need to change message contracts.","pos":[24316,24371]},{"content":"For example, a new version of your application may add an extra header to a message.","pos":[24372,24456]},{"content":"Then, when sending from the new version to the old, the system must deal with an extra header, as well as a missing header when going in the other direction.","pos":[24457,24614]},{"content":"The following rules apply for versioning headers:","pos":[24621,24670]},{"pos":[24736,24834],"content":"does not object to the missing headers—the corresponding members are left at their default values."},{"content":"also ignores unexpected extra headers.","pos":[24900,24938]},{"content":"The one exception to this rule is if the extra header has a <ph id=\"ph1\">`MustUnderstand`</ph> attribute set to <ph id=\"ph2\">`true`</ph> in the incoming SOAP message—in this case, an exception is thrown because a header that must be understood cannot be processed.","pos":[24939,25167],"source":" The one exception to this rule is if the extra header has a `MustUnderstand` attribute set to `true` in the incoming SOAP message—in this case, an exception is thrown because a header that must be understood cannot be processed."},{"content":"Message bodies have similar versioning rules—both missing and additional message body parts are ignored.","pos":[25174,25278]},{"pos":[25287,25313],"content":"Inheritance Considerations","linkify":"Inheritance Considerations","nodes":[{"content":"Inheritance Considerations","pos":[0,26]}]},{"content":"A message contract type can inherit from another type, as long as the base type also has a message contract.","pos":[25317,25425]},{"content":"When creating or accessing a message using a message contract type that inherits from other message contract types, the following rules apply:","pos":[25432,25574]},{"content":"All of the message headers in the inheritance hierarchy are collected together to form the full set of headers for the message.","pos":[25584,25711]},{"content":"All of the message body parts in the inheritance hierarchy are collected together to form the full message body.","pos":[25721,25833]},{"content":"The body parts are ordered according to the usual ordering rules (by <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName&gt;</ph> property and then alphabetical), with no relevance to their place in the inheritance hierarchy.","pos":[25834,26086],"source":" The body parts are ordered according to the usual ordering rules (by <xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName> property and then alphabetical), with no relevance to their place in the inheritance hierarchy."},{"content":"Using message contract inheritance where message body parts occur at multiple levels of the inheritance tree is strongly discouraged.","pos":[26087,26220]},{"content":"If a base class and a derived class define a header or a body part with the same name, the member from the base-most class is used to store the value of that header or body part.","pos":[26221,26399]},{"content":"Consider the classes in the following code example.","pos":[26406,26457]},{"content":"The <ph id=\"ph1\">`PatientRecord`</ph> class describes a message with one header called <ph id=\"ph2\">`ID`</ph>.","pos":[26821,26895],"source":"The `PatientRecord` class describes a message with one header called `ID`."},{"content":"The header corresponds to the <ph id=\"ph1\">`personID`</ph> and not the <ph id=\"ph2\">`patientID`</ph> member, because the base-most member is chosen.","pos":[26896,27008],"source":" The header corresponds to the `personID` and not the `patientID` member, because the base-most member is chosen."},{"content":"Thus, the <ph id=\"ph1\">`patientID`</ph> field is useless in this case.","pos":[27009,27061],"source":" Thus, the `patientID` field is useless in this case."},{"content":"The body of the message contains the <ph id=\"ph1\">`diagnosis`</ph> element followed by the <ph id=\"ph2\">`patientName`</ph> element, because that is the alphabetical order.","pos":[27062,27197],"source":" The body of the message contains the `diagnosis` element followed by the `patientName` element, because that is the alphabetical order."},{"content":"Notice that the example shows a pattern that is strongly discouraged: both the base and the derived message contracts have message body parts.","pos":[27198,27340]},{"pos":[27349,27368],"content":"WSDL Considerations","linkify":"WSDL Considerations","nodes":[{"content":"WSDL Considerations","pos":[0,19]}]},{"content":"When generating a Web Services Description Language (WSDL) contract from a service that uses message contracts, it is important to remember that not all message contract features are reflected in the resulting WSDL.","pos":[27372,27587]},{"content":"Consider the following points:","pos":[27588,27618]},{"content":"WSDL cannot express the concept of an array of headers.","pos":[27628,27683]},{"content":"When creating messages with an array of headers using the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>, the resulting WSDL reflects only one header instead of the array.","pos":[27684,27863],"source":" When creating messages with an array of headers using the <xref:System.ServiceModel.MessageHeaderArrayAttribute>, the resulting WSDL reflects only one header instead of the array."},{"content":"The resulting WSDL document may not reflect some protection-level information.","pos":[27873,27951]},{"content":"The message type generated in the WSDL has the same name as the class name of the message contract type.","pos":[27961,28065]},{"content":"When using the same message contract in multiple operations, multiple message types are generated in the WSDL document.","pos":[28075,28194]},{"content":"The names are made unique by adding the numbers \"2\", \"3\", and so on, for subsequent uses.","pos":[28195,28284]},{"content":"When importing back the WSDL, multiple message contract types are created and are identical except for their names.","pos":[28285,28400]},{"pos":[28409,28437],"content":"SOAP Encoding Considerations","linkify":"SOAP Encoding Considerations","nodes":[{"content":"SOAP Encoding Considerations","pos":[0,28]}]},{"content":"allows you to use the legacy SOAP encoding style of XML, however, its use is not recommended.","pos":[28497,28590]},{"content":"When using this style (by setting the <ph id=\"ph1\">`Use`</ph> property to <ph id=\"ph2\">`Encoded`</ph> on the <ph id=\"ph3\">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute?displayProperty=fullName&gt;</ph> applied to the service contract), the following additional considerations apply:","pos":[28591,28825],"source":" When using this style (by setting the `Use` property to `Encoded` on the <xref:System.ServiceModel.XmlSerializerFormatAttribute?displayProperty=fullName> applied to the service contract), the following additional considerations apply:"},{"content":"The message headers are not supported; this means that the attribute <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and the array attribute <ph id=\"ph2\">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> are incompatible with SOAP encoding.","pos":[28835,29069],"source":"The message headers are not supported; this means that the attribute <xref:System.ServiceModel.MessageHeaderAttribute> and the array attribute <xref:System.ServiceModel.MessageHeaderArrayAttribute> are incompatible with SOAP encoding."},{"pos":[29079,29277],"content":"If the message contract is not wrapped, that is, if the property <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A&gt;</ph> is set to <ph id=\"ph2\">`false`</ph>, the message contract can have only one body part.","source":"If the message contract is not wrapped, that is, if the property <xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A> is set to `false`, the message contract can have only one body part."},{"content":"The name of the wrapper element for the request message contract must match the operation name.","pos":[29287,29382]},{"content":"Use the <ph id=\"ph1\">`WrapperName`</ph> property of the message contract for this.","pos":[29383,29447],"source":" Use the `WrapperName` property of the message contract for this."},{"content":"The name of the wrapper element for the response message contract must be the same as the name of the operation suffixed by 'Response'.","pos":[29457,29592]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A&gt;</ph> property of the message contract for this.","pos":[29593,29710],"source":" Use the <xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A> property of the message contract for this."},{"content":"SOAP encoding preserves object references.","pos":[29720,29762]},{"content":"For example, consider the following code.","pos":[29763,29804]},{"pos":[30555,30737],"content":"After serializing the message using SOAP encoding, <ph id=\"ph1\">`changedFrom`</ph> and <ph id=\"ph2\">`changedTo`</ph> do not contain their own copies of <ph id=\"ph3\">`p`</ph>, but instead point to the copy inside the <ph id=\"ph4\">`changedBy`</ph> element.","source":"After serializing the message using SOAP encoding, `changedFrom` and `changedTo` do not contain their own copies of `p`, but instead point to the copy inside the `changedBy` element."},{"pos":[30746,30772],"content":"Performance Considerations","linkify":"Performance Considerations","nodes":[{"content":"Performance Considerations","pos":[0,26]}]},{"content":"Every message header and message body part is serialized independently of the others.","pos":[30776,30861]},{"content":"Therefore, the same namespaces can be declared again for each header and body part.","pos":[30862,30945]},{"content":"To improve performance, especially in terms of the size of the message on the wire, consolidate multiple headers and body parts into a single header or body part.","pos":[30946,31108]},{"content":"For example, instead of the following code:","pos":[31109,31152]},{"content":"Use this code.","pos":[31441,31455]},{"pos":[31843,31889],"content":"Event-based Asynchronous and Message Contracts","linkify":"Event-based Asynchronous and Message Contracts","nodes":[{"content":"Event-based Asynchronous and Message Contracts","pos":[0,46]}]},{"content":"The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the <ph id=\"ph1\">`Result`</ph> property and the others are returned as properties on the <ph id=\"ph2\">&lt;xref:System.EventArgs&gt;</ph> object.","pos":[31893,32128],"source":"The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the `Result` property and the others are returned as properties on the <xref:System.EventArgs> object."},{"content":"One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> object returns one value as the <ph id=\"ph2\">`Result`</ph> property and the remainder are properties of the <ph id=\"ph3\">&lt;xref:System.EventArgs&gt;</ph> object.","pos":[32129,32440],"source":" One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <xref:System.EventArgs> object returns one value as the `Result` property and the remainder are properties of the <xref:System.EventArgs> object."},{"content":"If you want to receive the message object as the <ph id=\"ph1\">`Result`</ph> property and have the returned values as properties on that object, use the <ph id=\"ph2\">`/messageContract`</ph> command option.","pos":[32447,32615],"source":"If you want to receive the message object as the `Result` property and have the returned values as properties on that object, use the `/messageContract` command option."},{"content":"This generates a signature that returns the response message as the <ph id=\"ph1\">`Result`</ph> property on the <ph id=\"ph2\">&lt;xref:System.EventArgs&gt;</ph> object.","pos":[32616,32740],"source":" This generates a signature that returns the response message as the `Result` property on the <xref:System.EventArgs> object."},{"content":"All internal return values are then properties of the response message object.","pos":[32741,32819]},{"pos":[32828,32836],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Using Data Contracts<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept><ph id=\"ph1\"> </ph>","pos":[32840,32935],"source":"[Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md) "},{"content":"<bpt id=\"p1\">[</bpt>Designing and Implementing Services<ept id=\"p1\">](../../../../docs/framework/wcf/designing-and-implementing-services.md)</ept>","pos":[32939,33047],"source":"[Designing and Implementing Services](../../../../docs/framework/wcf/designing-and-implementing-services.md)"}]}