{"content":"---\ntitle: C# Expressions | A tour of the C# language\ndescription: expressions, operands, and operators are building blocks of the C# language\nkeywords: .NET, csharp, expression, operator, operand\nauthor: BillWagner\nms.author: wiwagn\nms.date: 11/06/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 20d5eb10-7381-47b9-ad90-f1cc895aa27e\n---\n\n# Expressions\n\n*Expressions* are constructed from *operands* and *operators*. The operators of an expression indicate which operations to apply to the operands. Examples of operators include `+`, `-`, `*`, `/`, and `new`. Examples of operands include literals, fields, local variables, and expressions.\n\nWhen an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated. For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.\n\nWhen an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:\n\n*    Except for the assignment operators, all binary operators are *left-associative*, meaning that operations are performed from left to right. For example, `x + y + z` is evaluated as `(x + y) + z`.\n*    The assignment operators and the conditional operator (`?:`) are *right-associative*, meaning that operations are performed from right to left. For example, `x = y = z` is evaluated as `x = (y = z)`.\n\nPrecedence and associativity can be controlled using parentheses. For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.\n\nMost operators can be *overloaded*. Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.\n\nThe following summarizes C#’s operators, listing the operator categories in order of precedence from highest to lowest. Operators in the same category have equal precedence. Under each category is a list of expressions in that category along with the description of that expression type.\n\n* Primary\n    - `x.m`: Member access\n    - `x(...)`: Method and delegate invocation\n    - `x[...]`: Array and indexer access\n    - `x++`: Post-increment\n    - `x--`: Post-decrement\n    - `new T(...)`:    Object and delegate creation\n    - `new T(...){...}`: Object creation with initializer\n    - `new {...}`:  Anonymous object initializer\n    - `new T[...]`: Array creation\n    - `typeof(T)`: Obtain @System.Type object for `T`\n    - `checked(x)`: Evaluate expression in checked context\n    - `unchecked(x)`: Evaluate expression in unchecked context\n    - `default(T)`: Obtain default value of type `T`\n    - `delegate {...}`: Anonymous function (anonymous method)\n* Unary\n    - `+x`: Identity\n    - `-x`: Negation\n    - `!x`: Logical negation\n    - `~x`: Bitwise negation\n    - `++x`: Pre-increment\n    - `--x`: Pre-decrement\n    - `(T)x`: Explicitly convert `x` to type `T`\n    - `await x`: Asynchronously wait for `x` to complete\n* Multiplicative\n    - `x * y`: Multiplication\n    - `x / y`: Division\n    - `x % y`: Remainder\n* Additive\n    - `x + y`: Addition, string concatenation, delegate combination\n    - `x – y`: Subtraction, delegate removal\n* Shift\n    - `x << y`: Shift left\n    - `x >> y`: Shift right\n* Relational and type testing\n    - `x < y`: Less than\n    - `x > y`: Greater than\n    - `x <= y`: Less than or equal\n    - `x >= y`: Greater than or equal\n    - `x is T`: Return `true` if `x` is a `T`, `false` otherwise\n    - `x as T`: Return `x` typed as `T`, or `null` if `x` is not a `T`\n* Equality\n    - `x == y`: Equal\n    - `x != y`: Not equal\n* Logical AND\n    - `x & y`: Integer bitwise AND, boolean logical AND\n* Logical XOR\n    - `x ^ y`: Integer bitwise XOR, boolean logical XOR\n* Logical OR\n    - `x | y`: Integer bitwise OR, boolean logical OR\n* Conditional AND\n    - `x && y`: Evaluates `y` only if `x` is not `false`\n* Conditional OR\n    - `x || y`: Evaluates `y` only if `x` is not `true`\n* Null coalescing\n    - `x ?? y`: Evaluates to `y` if `x` is null, to `x` otherwise\n* Conditional\n    - `x ? y : z`: Evaluates `y` if `x` is `true`, `z` if `x` is `false`\n* Assignment or anonymous function\n    - `x = y`: Assignment\n    - `x op= y`: Compound assignment; supported operators are\n        - `*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`  `^=`  `|=`\n    - `(T x) => y`: Anonymous function (lambda expression)\n\n>[!div class=\"step-by-step\"]\n[Previous](types-and-variables.md)\n[Next](statements.md)\n","nodes":[{"pos":[11,53],"content":"C# Expressions | A tour of the C# language","needQuote":true,"needEscape":true,"nodes":[{"content":"C# Expressions | A tour of the C# language","pos":[0,42]}]},{"pos":[67,142],"content":"expressions, operands, and operators are building blocks of the C# language","needQuote":true,"needEscape":true,"nodes":[{"content":"expressions, operands, and operators are building blocks of the C# language","pos":[0,75]}]},{"pos":[153,196],"content":".NET, csharp, expression, operator, operand","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, csharp, expression, operator, operand","pos":[0,43]}]},{"pos":[391,402],"content":"Expressions","linkify":"Expressions","nodes":[{"content":"Expressions","pos":[0,11]}]},{"content":"<bpt id=\"p1\">*</bpt>Expressions<ept id=\"p1\">*</ept> are constructed from <bpt id=\"p2\">*</bpt>operands<ept id=\"p2\">*</ept> and <bpt id=\"p3\">*</bpt>operators<ept id=\"p3\">*</ept>.","pos":[404,466],"source":"*Expressions* are constructed from *operands* and *operators*."},{"content":"The operators of an expression indicate which operations to apply to the operands.","pos":[467,549]},{"content":"Examples of operators include <ph id=\"ph1\">`+`</ph>, <ph id=\"ph2\">`-`</ph>, <ph id=\"ph3\">`*`</ph>, <ph id=\"ph4\">`/`</ph>, and <ph id=\"ph5\">`new`</ph>.","pos":[550,610],"source":" Examples of operators include `+`, `-`, `*`, `/`, and `new`."},{"content":"Examples of operands include literals, fields, local variables, and expressions.","pos":[611,691]},{"content":"When an expression contains multiple operators, the <bpt id=\"p1\">*</bpt>precedence<ept id=\"p1\">*</ept> of the operators controls the order in which the individual operators are evaluated.","pos":[693,842],"source":"When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated."},{"content":"For example, the expression <ph id=\"ph1\">`x + y * z`</ph> is evaluated as <ph id=\"ph2\">`x + (y * z)`</ph> because the <ph id=\"ph3\">`*`</ph> operator has higher precedence than the <ph id=\"ph4\">`+`</ph> operator.","pos":[843,982],"source":" For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator."},{"pos":[984,1149],"content":"When an operand occurs between two operators with the same precedence, the <bpt id=\"p1\">*</bpt>associativity<ept id=\"p1\">*</ept> of the operators controls the order in which the operations are performed:","source":"When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:"},{"content":"Except for the assignment operators, all binary operators are <bpt id=\"p1\">*</bpt>left-associative<ept id=\"p1\">*</ept>, meaning that operations are performed from left to right.","pos":[1156,1295],"source":"Except for the assignment operators, all binary operators are *left-associative*, meaning that operations are performed from left to right."},{"content":"For example, <ph id=\"ph1\">`x + y + z`</ph> is evaluated as <ph id=\"ph2\">`(x + y) + z`</ph>.","pos":[1296,1351],"source":" For example, `x + y + z` is evaluated as `(x + y) + z`."},{"content":"The assignment operators and the conditional operator (<ph id=\"ph1\">`?:`</ph>) are <bpt id=\"p1\">*</bpt>right-associative<ept id=\"p1\">*</ept>, meaning that operations are performed from right to left.","pos":[1357,1500],"source":"The assignment operators and the conditional operator (`?:`) are *right-associative*, meaning that operations are performed from right to left."},{"content":"For example, <ph id=\"ph1\">`x = y = z`</ph> is evaluated as <ph id=\"ph2\">`x = (y = z)`</ph>.","pos":[1501,1556],"source":" For example, `x = y = z` is evaluated as `x = (y = z)`."},{"content":"Precedence and associativity can be controlled using parentheses.","pos":[1558,1623]},{"content":"For example, <ph id=\"ph1\">`x + y * z`</ph> first multiplies <ph id=\"ph2\">`y`</ph> by <ph id=\"ph3\">`z`</ph> and then adds the result to <ph id=\"ph4\">`x`</ph>, but <ph id=\"ph5\">`(x + y) * z`</ph> first adds <ph id=\"ph6\">`x`</ph> and <ph id=\"ph7\">`y`</ph> and then multiplies the result by <ph id=\"ph8\">`z`</ph>.","pos":[1624,1789],"source":" For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`."},{"content":"Most operators can be <bpt id=\"p1\">*</bpt>overloaded<ept id=\"p1\">*</ept>.","pos":[1791,1826],"source":"Most operators can be *overloaded*."},{"content":"Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.","pos":[1827,2002]},{"content":"The following summarizes C#’s operators, listing the operator categories in order of precedence from highest to lowest.","pos":[2004,2123]},{"content":"Operators in the same category have equal precedence.","pos":[2124,2177]},{"content":"Under each category is a list of expressions in that category along with the description of that expression type.","pos":[2178,2291]},{"content":"Primary","pos":[2295,2302]},{"pos":[2309,2329],"content":"<ph id=\"ph1\">`x.m`</ph>: Member access","source":"`x.m`: Member access"},{"pos":[2336,2376],"content":"<ph id=\"ph1\">`x(...)`</ph>: Method and delegate invocation","source":"`x(...)`: Method and delegate invocation"},{"pos":[2383,2417],"content":"<ph id=\"ph1\">`x[...]`</ph>: Array and indexer access","source":"`x[...]`: Array and indexer access"},{"pos":[2424,2445],"content":"<ph id=\"ph1\">`x++`</ph>: Post-increment","source":"`x++`: Post-increment"},{"pos":[2452,2473],"content":"<ph id=\"ph1\">`x--`</ph>: Post-decrement","source":"`x--`: Post-decrement"},{"pos":[2480,2525],"content":"<ph id=\"ph1\">`new T(...)`</ph>:    Object and delegate creation","source":"`new T(...)`:    Object and delegate creation"},{"pos":[2532,2583],"content":"<ph id=\"ph1\">`new T(...){...}`</ph>: Object creation with initializer","source":"`new T(...){...}`: Object creation with initializer"},{"pos":[2590,2632],"content":"<ph id=\"ph1\">`new {...}`</ph>:  Anonymous object initializer","source":"`new {...}`:  Anonymous object initializer"},{"pos":[2639,2667],"content":"<ph id=\"ph1\">`new T[...]`</ph>: Array creation","source":"`new T[...]`: Array creation"},{"pos":[2674,2721],"content":"<ph id=\"ph1\">`typeof(T)`</ph>: Obtain <ph id=\"ph2\">@System.Type</ph> object for <ph id=\"ph3\">`T`</ph>","source":"`typeof(T)`: Obtain @System.Type object for `T`"},{"pos":[2728,2780],"content":"<ph id=\"ph1\">`checked(x)`</ph>: Evaluate expression in checked context","source":"`checked(x)`: Evaluate expression in checked context"},{"pos":[2787,2843],"content":"<ph id=\"ph1\">`unchecked(x)`</ph>: Evaluate expression in unchecked context","source":"`unchecked(x)`: Evaluate expression in unchecked context"},{"pos":[2850,2896],"content":"<ph id=\"ph1\">`default(T)`</ph>: Obtain default value of type <ph id=\"ph2\">`T`</ph>","source":"`default(T)`: Obtain default value of type `T`"},{"pos":[2903,2958],"content":"<ph id=\"ph1\">`delegate {...}`</ph>: Anonymous function (anonymous method)","source":"`delegate {...}`: Anonymous function (anonymous method)"},{"content":"Unary","pos":[2961,2966]},{"pos":[2973,2987],"content":"<ph id=\"ph1\">`+x`</ph>: Identity","source":"`+x`: Identity"},{"pos":[2994,3008],"content":"<ph id=\"ph1\">`-x`</ph>: Negation","source":"`-x`: Negation"},{"pos":[3015,3037],"content":"<ph id=\"ph1\">`!x`</ph>: Logical negation","source":"`!x`: Logical negation"},{"pos":[3044,3066],"content":"<ph id=\"ph1\">`~x`</ph>: Bitwise negation","source":"`~x`: Bitwise negation"},{"pos":[3073,3093],"content":"<ph id=\"ph1\">`++x`</ph>: Pre-increment","source":"`++x`: Pre-increment"},{"pos":[3100,3120],"content":"<ph id=\"ph1\">`--x`</ph>: Pre-decrement","source":"`--x`: Pre-decrement"},{"pos":[3127,3169],"content":"<ph id=\"ph1\">`(T)x`</ph>: Explicitly convert <ph id=\"ph2\">`x`</ph> to type <ph id=\"ph3\">`T`</ph>","source":"`(T)x`: Explicitly convert `x` to type `T`"},{"pos":[3176,3226],"content":"<ph id=\"ph1\">`await x`</ph>: Asynchronously wait for <ph id=\"ph2\">`x`</ph> to complete","source":"`await x`: Asynchronously wait for `x` to complete"},{"content":"Multiplicative","pos":[3229,3243]},{"pos":[3250,3273],"content":"<ph id=\"ph1\">`x * y`</ph>: Multiplication","source":"`x * y`: Multiplication"},{"pos":[3280,3297],"content":"<ph id=\"ph1\">`x / y`</ph>: Division","source":"`x / y`: Division"},{"pos":[3304,3322],"content":"<ph id=\"ph1\">`x % y`</ph>: Remainder","source":"`x % y`: Remainder"},{"content":"Additive","pos":[3325,3333]},{"pos":[3340,3401],"content":"<ph id=\"ph1\">`x + y`</ph>: Addition, string concatenation, delegate combination","source":"`x + y`: Addition, string concatenation, delegate combination"},{"pos":[3408,3446],"content":"<ph id=\"ph1\">`x – y`</ph>: Subtraction, delegate removal","source":"`x – y`: Subtraction, delegate removal"},{"content":"Shift","pos":[3449,3454]},{"pos":[3461,3481],"content":"<ph id=\"ph1\">`x &lt;&lt; y`</ph>: Shift left","source":"`x << y`: Shift left"},{"pos":[3488,3509],"content":"<ph id=\"ph1\">`x &gt;&gt; y`</ph>: Shift right","source":"`x >> y`: Shift right"},{"content":"Relational and type testing","pos":[3512,3539]},{"pos":[3546,3564],"content":"<ph id=\"ph1\">`x &lt; y`</ph>: Less than","source":"`x < y`: Less than"},{"pos":[3571,3592],"content":"<ph id=\"ph1\">`x &gt; y`</ph>: Greater than","source":"`x > y`: Greater than"},{"pos":[3599,3627],"content":"<ph id=\"ph1\">`x &lt;= y`</ph>: Less than or equal","source":"`x <= y`: Less than or equal"},{"pos":[3634,3665],"content":"<ph id=\"ph1\">`x &gt;= y`</ph>: Greater than or equal","source":"`x >= y`: Greater than or equal"},{"pos":[3672,3730],"content":"<ph id=\"ph1\">`x is T`</ph>: Return <ph id=\"ph2\">`true`</ph> if <ph id=\"ph3\">`x`</ph> is a <ph id=\"ph4\">`T`</ph>, <ph id=\"ph5\">`false`</ph> otherwise","source":"`x is T`: Return `true` if `x` is a `T`, `false` otherwise"},{"pos":[3737,3801],"content":"<ph id=\"ph1\">`x as T`</ph>: Return <ph id=\"ph2\">`x`</ph> typed as <ph id=\"ph3\">`T`</ph>, or <ph id=\"ph4\">`null`</ph> if <ph id=\"ph5\">`x`</ph> is not a <ph id=\"ph6\">`T`</ph>","source":"`x as T`: Return `x` typed as `T`, or `null` if `x` is not a `T`"},{"content":"Equality","pos":[3804,3812]},{"pos":[3819,3834],"content":"<ph id=\"ph1\">`x == y`</ph>: Equal","source":"`x == y`: Equal"},{"pos":[3841,3860],"content":"<ph id=\"ph1\">`x != y`</ph>: Not equal","source":"`x != y`: Not equal"},{"content":"Logical AND","pos":[3863,3874]},{"pos":[3881,3930],"content":"<ph id=\"ph1\">`x &amp; y`</ph>: Integer bitwise AND, boolean logical AND","source":"`x & y`: Integer bitwise AND, boolean logical AND"},{"content":"Logical XOR","pos":[3933,3944]},{"pos":[3951,4000],"content":"<ph id=\"ph1\">`x ^ y`</ph>: Integer bitwise XOR, boolean logical XOR","source":"`x ^ y`: Integer bitwise XOR, boolean logical XOR"},{"content":"Logical OR","pos":[4003,4013]},{"pos":[4020,4067],"content":"<ph id=\"ph1\">`x | y`</ph>: Integer bitwise OR, boolean logical OR","source":"`x | y`: Integer bitwise OR, boolean logical OR"},{"content":"Conditional AND","pos":[4070,4085]},{"pos":[4092,4142],"content":"<ph id=\"ph1\">`x &amp;&amp; y`</ph>: Evaluates <ph id=\"ph2\">`y`</ph> only if <ph id=\"ph3\">`x`</ph> is not <ph id=\"ph4\">`false`</ph>","source":"`x && y`: Evaluates `y` only if `x` is not `false`"},{"content":"Conditional OR","pos":[4145,4159]},{"pos":[4166,4215],"content":"<ph id=\"ph1\">`x || y`</ph>: Evaluates <ph id=\"ph2\">`y`</ph> only if <ph id=\"ph3\">`x`</ph> is not <ph id=\"ph4\">`true`</ph>","source":"`x || y`: Evaluates `y` only if `x` is not `true`"},{"content":"Null coalescing","pos":[4218,4233]},{"pos":[4240,4299],"content":"<ph id=\"ph1\">`x ?? y`</ph>: Evaluates to <ph id=\"ph2\">`y`</ph> if <ph id=\"ph3\">`x`</ph> is null, to <ph id=\"ph4\">`x`</ph> otherwise","source":"`x ?? y`: Evaluates to `y` if `x` is null, to `x` otherwise"},{"content":"Conditional","pos":[4302,4313]},{"pos":[4320,4386],"content":"<ph id=\"ph1\">`x ? y : z`</ph>: Evaluates <ph id=\"ph2\">`y`</ph> if <ph id=\"ph3\">`x`</ph> is <ph id=\"ph4\">`true`</ph>, <ph id=\"ph5\">`z`</ph> if <ph id=\"ph6\">`x`</ph> is <ph id=\"ph7\">`false`</ph>","source":"`x ? y : z`: Evaluates `y` if `x` is `true`, `z` if `x` is `false`"},{"content":"Assignment or anonymous function","pos":[4389,4421]},{"pos":[4428,4447],"content":"<ph id=\"ph1\">`x = y`</ph>: Assignment","source":"`x = y`: Assignment"},{"pos":[4454,4509],"content":"<ph id=\"ph1\">`x op= y`</ph>: Compound assignment; supported operators are","source":"`x op= y`: Compound assignment; supported operators are"},{"pos":[4520,4587],"content":"<ph id=\"ph1\">`*=`</ph>   <ph id=\"ph2\">`/=`</ph>   <ph id=\"ph3\">`%=`</ph>   <ph id=\"ph4\">`+=`</ph>   <ph id=\"ph5\">`-=`</ph>   <ph id=\"ph6\">`&lt;&lt;=`</ph>   <ph id=\"ph7\">`&gt;&gt;=`</ph>   <ph id=\"ph8\">`&amp;=`</ph>  <ph id=\"ph9\">`^=`</ph>  <ph id=\"ph10\">`|=`</ph>","source":"`*=`   `/=`   `%=`   `+=`   `-=`   `<<=`   `>>=`   `&=`  `^=`  `|=`"},{"pos":[4594,4646],"content":"<ph id=\"ph1\">`(T x) =&gt; y`</ph>: Anonymous function (lambda expression)","source":"`(T x) => y`: Anonymous function (lambda expression)"},{"content":"<bpt id=\"p1\">[</bpt>Previous<ept id=\"p1\">](types-and-variables.md)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\">[</bpt>Next<ept id=\"p2\">](statements.md)</ept>","pos":[4677,4733],"source":"[Previous](types-and-variables.md)\n[Next](statements.md)"}]}