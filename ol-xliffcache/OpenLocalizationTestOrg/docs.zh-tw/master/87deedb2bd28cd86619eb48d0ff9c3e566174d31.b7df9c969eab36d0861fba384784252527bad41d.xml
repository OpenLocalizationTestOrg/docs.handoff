{"content":"---\ntitle: \"Authorization Policy\"\nms.date: \"03/30/2017\"\nms.assetid: 1db325ec-85be-47d0-8b6e-3ba2fdf3dda0\n---\n# Authorization Policy\n\nThis sample demonstrates how to implement a custom claim authorization policy and an associated custom service authorization manager. This is useful when the service makes claim-based access checks to service operations and prior to the access checks, grants the caller certain rights. This sample shows both the process of adding claims as well as the process for doing an access check against the finalized set of claims. All application messages between the client and server are signed and encrypted. By default with the `wsHttpBinding` binding, a username and password supplied by the client are used to logon to a valid Windows NT account. This sample demonstrates how to utilize a custom <xref:System.IdentityModel.Selectors.UserNamePasswordValidator> to authenticate the client. In addition this sample shows the client authenticating to the service using an X.509 certificate. This sample shows an implementation of <xref:System.IdentityModel.Policy.IAuthorizationPolicy> and <xref:System.ServiceModel.ServiceAuthorizationManager>, which between them grant access to specific methods of the service for specific users. This sample is based on the [Message Security User Name](../../../../docs/framework/wcf/samples/message-security-user-name.md), but demonstrates how to perform a claim transformation prior to the <xref:System.ServiceModel.ServiceAuthorizationManager> being called.\n\n> [!NOTE]\n> The setup procedure and build instructions for this sample are located at the end of this topic.\n\n In summary, this sample demonstrates how:\n\n-   The client can be authenticated using a user name-password.\n\n-   The client can be authenticated using an X.509 certificate.\n\n-   The server validates the client credentials against a custom `UsernamePassword` validator.\n\n-   The server is authenticated using the server's X.509 certificate.\n\n-   The server can use <xref:System.ServiceModel.ServiceAuthorizationManager> to control access to certain methods in the service.\n\n-   How to implement <xref:System.IdentityModel.Policy.IAuthorizationPolicy>.\n\nThe service exposes two endpoints for communicating with the service, defined using the configuration file App.config. Each endpoint consists of an address, a binding, and a contract. One binding is configured with a standard `wsHttpBinding` binding that uses WS-Security and client username authentication. The other binding is configured with a standard `wsHttpBinding` binding that uses WS-Security and client certificate authentication. The [\\<behavior>](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-endpointbehaviors.md) specifies that the user credentials are to be used for service authentication. The server certificate must contain the same value for the `SubjectName` property as the `findValue` attribute in the [\\<serviceCertificate>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecertificate-of-servicecredentials.md).\n\n```xml\n<system.serviceModel>\n  <services>\n    <service name=\"Microsoft.ServiceModel.Samples.CalculatorService\"\n             behaviorConfiguration=\"CalculatorServiceBehavior\">\n      <host>\n        <baseAddresses>\n          <!-- configure base address provided by host -->\n          <add baseAddress =\"http://localhost:8001/servicemodelsamples/service\"/>\n        </baseAddresses>\n      </host>\n      <!-- use base address provided by host, provide two endpoints -->\n      <endpoint address=\"username\"\n                binding=\"wsHttpBinding\"\n                bindingConfiguration=\"Binding1\"\n                contract=\"Microsoft.ServiceModel.Samples.ICalculator\" />\n      <endpoint address=\"certificate\"\n                binding=\"wsHttpBinding\"\n                bindingConfiguration=\"Binding2\"\n                contract=\"Microsoft.ServiceModel.Samples.ICalculator\" />\n    </service>\n  </services>\n\n  <bindings>\n    <wsHttpBinding>\n      <!-- Username binding -->\n      <binding name=\"Binding1\">\n        <security mode=\"Message\">\n    <message clientCredentialType=\"UserName\" />\n        </security>\n      </binding>\n      <!-- X509 certificate binding -->\n      <binding name=\"Binding2\">\n        <security mode=\"Message\">\n          <message clientCredentialType=\"Certificate\" />\n        </security>\n      </binding>\n    </wsHttpBinding>\n  </bindings>\n\n  <behaviors>\n    <serviceBehaviors>\n      <behavior name=\"CalculatorServiceBehavior\" >\n        <serviceDebug includeExceptionDetailInFaults =\"true\" />\n        <serviceCredentials>\n          <!--\n          The serviceCredentials behavior allows one to specify a custom validator for username/password combinations.\n          -->\n          <userNameAuthentication userNamePasswordValidationMode=\"Custom\" customUserNamePasswordValidatorType=\"Microsoft.ServiceModel.Samples.MyCustomUserNameValidator, service\" />\n          <!--\n          The serviceCredentials behavior allows one to specify authentication constraints on client certificates.\n          -->\n          <clientCertificate>\n            <!--\n            Setting the certificateValidationMode to PeerOrChainTrust means that if the certificate\n            is in the user's Trusted People store, then it will be trusted without performing a\n            validation of the certificate's issuer chain. This setting is used here for convenience so that the\n            sample can be run without having to have certificates issued by a certification authority (CA).\n            This setting is less secure than the default, ChainTrust. The security implications of this\n            setting should be carefully considered before using PeerOrChainTrust in production code.\n            -->\n            <authentication certificateValidationMode=\"PeerOrChainTrust\" />\n          </clientCertificate>\n          <!--\n          The serviceCredentials behavior allows one to define a service certificate.\n          A service certificate is used by a client to authenticate the service and provide message protection.\n          This configuration references the \"localhost\" certificate installed during the setup instructions.\n          -->\n          <serviceCertificate findValue=\"localhost\" storeLocation=\"LocalMachine\" storeName=\"My\" x509FindType=\"FindBySubjectName\" />\n        </serviceCredentials>\n        <serviceAuthorization serviceAuthorizationManagerType=\"Microsoft.ServiceModel.Samples.MyServiceAuthorizationManager, service\">\n          <!--\n          The serviceAuthorization behavior allows one to specify custom authorization policies.\n          -->\n          <authorizationPolicies>\n            <add policyType=\"Microsoft.ServiceModel.Samples.CustomAuthorizationPolicy.MyAuthorizationPolicy, PolicyLibrary\" />\n          </authorizationPolicies>\n        </serviceAuthorization>\n      </behavior>\n    </serviceBehaviors>\n  </behaviors>\n\n</system.serviceModel>\n```\n\nEach client endpoint configuration consists of a configuration name, an absolute address for the service endpoint, the binding, and the contract. The client binding is configured with the appropriate security mode as specified in this case in the [\\<security>](../../../../docs/framework/configure-apps/file-schema/wcf/security-of-wshttpbinding.md) and `clientCredentialType` as specified in the [\\<message>](../../../../docs/framework/configure-apps/file-schema/wcf/message-of-wshttpbinding.md).\n\n```xml\n<system.serviceModel>\n\n    <client>\n      <!-- Username based endpoint -->\n      <endpoint name=\"Username\"\n            address=\"http://localhost:8001/servicemodelsamples/service/username\"\n    binding=\"wsHttpBinding\"\n    bindingConfiguration=\"Binding1\"\n                behaviorConfiguration=\"ClientCertificateBehavior\"\n                contract=\"Microsoft.ServiceModel.Samples.ICalculator\" >\n      </endpoint>\n      <!-- X509 certificate based endpoint -->\n      <endpoint name=\"Certificate\"\n                        address=\"http://localhost:8001/servicemodelsamples/service/certificate\"\n                binding=\"wsHttpBinding\"\n            bindingConfiguration=\"Binding2\"\n                behaviorConfiguration=\"ClientCertificateBehavior\"\n                contract=\"Microsoft.ServiceModel.Samples.ICalculator\">\n      </endpoint>\n    </client>\n\n    <bindings>\n      <wsHttpBinding>\n        <!-- Username binding -->\n      <binding name=\"Binding1\">\n        <security mode=\"Message\">\n          <message clientCredentialType=\"UserName\" />\n        </security>\n      </binding>\n        <!-- X509 certificate binding -->\n        <binding name=\"Binding2\">\n          <security mode=\"Message\">\n            <message clientCredentialType=\"Certificate\" />\n          </security>\n        </binding>\n    </wsHttpBinding>\n    </bindings>\n\n    <behaviors>\n      <behavior name=\"ClientCertificateBehavior\">\n        <clientCredentials>\n          <serviceCertificate>\n            <!--\n            Setting the certificateValidationMode to PeerOrChainTrust\n            means that if the certificate\n            is in the user's Trusted People store, then it will be\n            trusted without performing a\n            validation of the certificate's issuer chain. This setting\n            is used here for convenience so that the\n            sample can be run without having to have certificates\n            issued by a certification authority (CA).\n            This setting is less secure than the default, ChainTrust.\n            The security implications of this\n            setting should be carefully considered before using\n            PeerOrChainTrust in production code.\n            -->\n            <authentication certificateValidationMode = \"PeerOrChainTrust\" />\n          </serviceCertificate>\n        </clientCredentials>\n      </behavior>\n    </behaviors>\n\n  </system.serviceModel>\n```\n\nFor the user name-based endpoint, the client implementation sets the user name and password to use.\n\n```csharp\n// Create a client with Username endpoint configuration\nCalculatorClient client1 = new CalculatorClient(\"Username\");\n\nclient1.ClientCredentials.UserName.UserName = \"test1\";\nclient1.ClientCredentials.UserName.Password = \"1tset\";\n\ntry\n{\n    // Call the Add service operation.\n    double value1 = 100.00D;\n    double value2 = 15.99D;\n    double result = client1.Add(value1, value2);\n    Console.WriteLine(\"Add({0},{1}) = {2}\", value1, value2, result);\n    ...\n}\ncatch (Exception e)\n{\n    Console.WriteLine(\"Call failed : {0}\", e.Message);\n}\n\nclient1.Close();\n```\n\nFor the certificate-based endpoint, the client implementation sets the client certificate to use.\n\n```csharp\n// Create a client with Certificate endpoint configuration\nCalculatorClient client2 = new CalculatorClient(\"Certificate\");\n\nclient2.ClientCredentials.ClientCertificate.SetCertificate(StoreLocation.CurrentUser, StoreName.My, X509FindType.FindBySubjectName, \"test1\");\n\ntry\n{\n    // Call the Add service operation.\n    double value1 = 100.00D;\n    double value2 = 15.99D;\n    double result = client2.Add(value1, value2);\n    Console.WriteLine(\"Add({0},{1}) = {2}\", value1, value2, result);\n    ...\n}\ncatch (Exception e)\n{\n    Console.WriteLine(\"Call failed : {0}\", e.Message);\n}\n\nclient2.Close();\n```\n\nThis sample uses a custom <xref:System.IdentityModel.Selectors.UserNamePasswordValidator> to validate user names and passwords. The sample implements `MyCustomUserNamePasswordValidator`, derived from <xref:System.IdentityModel.Selectors.UserNamePasswordValidator>. See the documentation about <xref:System.IdentityModel.Selectors.UserNamePasswordValidator> for more information. For the purposes of demonstrating the integration with the <xref:System.IdentityModel.Selectors.UserNamePasswordValidator>, this custom validator sample implements the <xref:System.IdentityModel.Selectors.UserNamePasswordValidator.Validate%2A> method to accept user name/password pairs where the user name matches the password as shown in the following code.\n\n```csharp\npublic class MyCustomUserNamePasswordValidator : UserNamePasswordValidator\n{\n  // This method validates users. It allows in two users,\n  // test1 and test2 with passwords 1tset and 2tset respectively.\n  // This code is for illustration purposes only and\n  // MUST NOT be used in a production environment because it\n  // is NOT secure.\n  public override void Validate(string userName, string password)\n  {\n    if (null == userName || null == password)\n    {\n      throw new ArgumentNullException();\n    }\n\n    if (!(userName == \"test1\" && password == \"1tset\") && !(userName == \"test2\" && password == \"2tset\"))\n    {\n      throw new SecurityTokenException(\"Unknown Username or Password\");\n    }\n  }\n}\n```\n\nOnce the validator is implemented in service code, the service host must be informed about the validator instance to use. This is done using the following code:\n\n```csharp\nServicehost.Credentials.UserNameAuthentication.UserNamePasswordValidationMode = UserNamePasswordValidationMode.Custom;\nserviceHost.Credentials.UserNameAuthentication.CustomUserNamePasswordValidator = new MyCustomUserNamePasswordValidatorProvider();\n```\n\nOr you can do the same thing in configuration:\n\n```xml\n<behavior ...>\n    <serviceCredentials>\n      <!--\n      The serviceCredentials behavior allows one to specify a custom validator for username/password combinations.\n      -->\n      <userNameAuthentication userNamePasswordValidationMode=\"Custom\" customUserNamePasswordValidatorType=\"Microsoft.ServiceModel.Samples.MyCustomUserNameValidator, service\" />\n    ...\n    </serviceCredentials>\n</behavior>\n```\n\nWindows Communication Foundation (WCF) provides a rich claims-based model for performing access checks. The <xref:System.ServiceModel.ServiceAuthorizationManager> object is used to perform the access check and determine whether the claims associated with the client satisfy the requirements necessary to access the service method.\n\nFor the purposes of demonstration, this sample shows an implementation of <xref:System.ServiceModel.ServiceAuthorizationManager> that implements the <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> method to allow a user's access to methods based on claims of type `http://example.com/claims/allowedoperation` whose value is the Action URI of the operation that is allowed to be called.\n\n```csharp\npublic class MyServiceAuthorizationManager : ServiceAuthorizationManager\n{\n  protected override bool CheckAccessCore(OperationContext operationContext)\n  {\n    string action = operationContext.RequestContext.RequestMessage.Headers.Action;\n    Console.WriteLine(\"action: {0}\", action);\n    foreach(ClaimSet cs in operationContext.ServiceSecurityContext.AuthorizationContext.ClaimSets)\n    {\n      if ( cs.Issuer == ClaimSet.System )\n      {\n        foreach (Claim c in cs.FindClaims(\"http://example.com/claims/allowedoperation\", Rights.PossessProperty))\n        {\n          Console.WriteLine(\"resource: {0}\", c.Resource.ToString());\n          if (action == c.Resource.ToString())\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n```\n\nOnce the custom <xref:System.ServiceModel.ServiceAuthorizationManager> is implemented, the service host must be informed about the <xref:System.ServiceModel.ServiceAuthorizationManager> to use. This is done as shown in the following code.\n\n```xml\n<behavior ...>\n    ...\n    <serviceAuthorization serviceAuthorizationManagerType=\"Microsoft.ServiceModel.Samples.MyServiceAuthorizationManager, service\">\n        ...\n    </serviceAuthorization>\n</behavior>\n```\n\nThe primary <xref:System.IdentityModel.Policy.IAuthorizationPolicy> method to implement is the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%28System.IdentityModel.Policy.EvaluationContext%2CSystem.Object%40%29> method.\n\n```csharp\npublic class MyAuthorizationPolicy : IAuthorizationPolicy\n{\n    string id;\n\n    public MyAuthorizationPolicy()\n    {\n    id =  Guid.NewGuid().ToString();\n    }\n\n    public bool Evaluate(EvaluationContext evaluationContext,\n                                            ref object state)\n    {\n        bool bRet = false;\n        CustomAuthState customstate = null;\n\n        if (state == null)\n        {\n            customstate = new CustomAuthState();\n            state = customstate;\n        }\n        else\n            customstate = (CustomAuthState)state;\n        Console.WriteLine(\"In Evaluate\");\n        if (!customstate.ClaimsAdded)\n        {\n           IList<Claim> claims = new List<Claim>();\n\n           foreach (ClaimSet cs in evaluationContext.ClaimSets)\n              foreach (Claim c in cs.FindClaims(ClaimTypes.Name,\n                                         Rights.PossessProperty))\n                  foreach (string s in\n                        GetAllowedOpList(c.Resource.ToString()))\n                  {\n                       claims.Add(new\n               Claim(\"http://example.com/claims/allowedoperation\",\n                                    s, Rights.PossessProperty));\n                            Console.WriteLine(\"Claim added {0}\", s);\n                      }\n                   evaluationContext.AddClaimSet(this,\n                           new DefaultClaimSet(this.Issuer,claims));\n                   customstate.ClaimsAdded = true;\n                   bRet = true;\n                }\n         else\n         {\n              bRet = true;\n         }\n         return bRet;\n     }\n...\n}\n```\n\nThe previous code shows how the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%28System.IdentityModel.Policy.EvaluationContext%2CSystem.Object%40%29> method checks that no new claims have been added that affect the processing and adds specific claims. The claims that are allowed are obtained from the `GetAllowedOpList` method, which is implemented to return a specific list of operations that the user is allowed to perform. The authorization policy adds claims for accessing the particular operation. This is later used by the <xref:System.ServiceModel.ServiceAuthorizationManager> to perform access check decisions.\n\nOnce the custom <xref:System.IdentityModel.Policy.IAuthorizationPolicy> is implemented, the service host must be informed about the authorization policies to use.\n\n```xml\n<serviceAuthorization ...>\n       <authorizationPolicies>\n            <add policyType='Microsoft.ServiceModel.Samples.CustomAuthorizationPolicy.MyAuthorizationPolicy, PolicyLibrary' />\n       </authorizationPolicies>\n</serviceAuthorization>\n```\n\nWhen you run the sample, the operation requests and responses are displayed in the client console window. The client successfully calls the Add, Subtract and Multiple methods and gets an \"Access is denied\" message when trying to call the Divide method. Press ENTER in the client window to shut down the client.\n\n## Setup Batch File\n\nThe Setup.bat batch file included with this sample allows you to configure the server with relevant certificates to run a self-hosted application that requires server certificate-based security.\n\nThe following provides a brief overview of the different sections of the batch files so that they can be modified to run in the appropriate configuration:\n\n-   Creating the server certificate.\n\n     The following lines from the Setup.bat batch file create the server certificate to be used. The %SERVER_NAME% variable specifies the server name. Change this variable to specify your own server name. The default value is localhost.\n\n    ```\n    echo ************\n    echo Server cert setup starting\n    echo %SERVER_NAME%\n    echo ************\n    echo making server cert\n    echo ************\n    makecert.exe -sr LocalMachine -ss MY -a sha1 -n CN=%SERVER_NAME% -sky exchange -pe\n    ```\n\n-   Installing the server certificate into client's trusted certificate store.\n\n     The following lines in the Setup.bat batch file copy the server certificate into the client trusted people store. This step is required because certificates that are generated by Makecert.exe are not implicitly trusted by the client system. If you already have a certificate that is rooted in a client trusted root certificate—for example, a Microsoft issued certificate—this step of populating the client certificate store with the server certificate is not required.\n\n    ```\n    certmgr.exe -add -r LocalMachine -s My -c -n %SERVER_NAME% -r CurrentUser -s TrustedPeople\n    ```\n\n-   Creating the client certificate.\n\n     The following lines from the Setup.bat batch file create the client certificate to be used. The %USER_NAME% variable specifies the server name. This value is set to \"test1\" because this is the name the `IAuthorizationPolicy` looks for. If you change the value of %USER_NAME% you must change the corresponding value in the `IAuthorizationPolicy.Evaluate` method.\n\n     The certificate is stored in My (Personal) store under the CurrentUser store location.\n\n    ```\n    echo ************\n    echo making client cert\n    echo ************\n    makecert.exe -sr CurrentUser -ss MY -a sha1 -n CN=%CLIENT_NAME% -sky exchange -pe\n    ```\n\n-   Installing the client certificate into server's trusted certificate store.\n\n     The following lines in the Setup.bat batch file copy the client certificate into the trusted people store. This step is required because certificates that are generated by Makecert.exe are not implicitly trusted by the server system. If you already have a certificate that is rooted in a trusted root certificate—for example, a Microsoft issued certificate—this step of populating the server certificate store with the client certificate is not required.\n\n    ```\n    certmgr.exe -add -r CurrentUser -s My -c -n %CLIENT_NAME% -r LocalMachine -s TrustedPeople\n    ```\n\n### To set up and build the sample\n\n1. To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).\n\n2. To run the sample in a single- or cross-computer configuration, use the following instructions.\n\n> [!NOTE]\n> If you use Svcutil.exe to regenerate the configuration for this sample, be sure to modify the endpoint name in the client configuration to match the client code.\n\n### To run the sample on the same computer\n\n1. Open Developer Command Prompt for Visual Studio with administrator privileges and run *Setup.bat* from the sample install folder. This installs all the certificates required for running the sample.\n\n    > [!NOTE]\n    > The Setup.bat batch file is designed to be run from Developer Command Prompt for Visual Studio. The PATH environment variable set within Developer Command Prompt for Visual Studio points to the directory that contains executables required by the *Setup.bat* script.\n\n1. Launch Service.exe from *service\\bin*.\n\n1. Launch Client.exe from *\\client\\bin*. Client activity is displayed on the client console application.\n\n  If the client and service are not able to communicate, see [Troubleshooting Tips for WCF Samples](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751511(v=vs.90)).\n\n### To run the sample across computers\n\n1. Create a directory on the service computer.\n\n2. Copy the service program files from *\\service\\bin* to the directory on the service computer. Also copy the Setup.bat, Cleanup.bat, GetComputerName.vbs and ImportClientCert.bat files to the service computer.\n\n3. Create a directory on the client computer for the client binaries.\n\n4. Copy the client program files to the client directory on the client computer. Also copy the Setup.bat, Cleanup.bat, and ImportServiceCert.bat files to the client.\n\n5. On the server, run `setup.bat service` in Developer Command Prompt for Visual Studio opened with administrator privileges.\n\n   Running `setup.bat` with the `service` argument creates a service certificate with the fully qualified domain name of the computer, and exports the service certificate to a file named *Service.cer*.\n\n6. Edit *Service.exe.config* to reflect the new certificate name (in the `findValue` attribute in the [\\<serviceCertificate>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecertificate-of-servicecredentials.md)) which is the same as the fully qualified domain name of the computer. Also change the **computername** in the \\<service>/\\<baseAddresses> element from localhost to the fully qualified name of your service computer.\n\n7. Copy the *Service.cer* file from the service directory to the client directory on the client computer.\n\n8. On the client, run `setup.bat client` in Developer Command Prompt for Visual Studio opened with administrator privileges.\n\n   Running `setup.bat` with the `client` argument creates a client certificate named **test1** and exports the client certificate to a file named *Client.cer*.\n\n9. In the *Client.exe.config* file on the client computer, change the address value of the endpoint to match the new address of your service. Do this by replacing **localhost** with the fully qualified domain name of the server.\n\n10. Copy the Client.cer file from the client directory to the service directory on the server.\n\n11. On the client, run *ImportServiceCert.bat* in Developer Command Prompt for Visual Studio opened with administrator privileges.\n\n   This imports the service certificate from the Service.cer file into the **CurrentUser - TrustedPeople** store.\n\n12. On the server, run *ImportClientCert.bat* in Developer Command Prompt for Visual Studio opened with administrator privileges.\n\n   This imports the client certificate from the Client.cer file into the **LocalMachine - TrustedPeople** store.\n\n13. On the server computer, launch Service.exe from the command prompt window.\n\n14. On the client computer, launch Client.exe from a command prompt window.\n\n   If the client and service are not able to communicate, see [Troubleshooting Tips for WCF Samples](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751511(v=vs.90)).\n\n### Clean up after the sample\n\nTo clean up after the sample, run *Cleanup.bat* in the samples folder when you have finished running the sample. This removes the server and client certificates from the certificate store.\n\n> [!NOTE]\n> This script does not remove service certificates on a client when running this sample across computers. If you have run WCF samples that use certificates across computers, be sure to clear the service certificates that have been installed in the CurrentUser - TrustedPeople store. To do this, use the following command: `certmgr -del -r CurrentUser -s TrustedPeople -c -n <Fully Qualified Server Machine Name>` For example: `certmgr -del -r CurrentUser -s TrustedPeople -c -n server1.contoso.com`.","nodes":[{"pos":[4,104],"embed":true,"restype":"x-metadata","content":"title: \"Authorization Policy\"\nms.date: \"03/30/2017\"\nms.assetid: 1db325ec-85be-47d0-8b6e-3ba2fdf3dda0","nodes":[{"content":"Authorization Policy","nodes":[{"pos":[0,20],"content":"Authorization Policy","nodes":[{"content":"Authorization Policy","pos":[0,20]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[111,131],"content":"Authorization Policy","linkify":"Authorization Policy","nodes":[{"content":"Authorization Policy","pos":[0,20]}]},{"content":"This sample demonstrates how to implement a custom claim authorization policy and an associated custom service authorization manager.","pos":[133,266]},{"content":"This is useful when the service makes claim-based access checks to service operations and prior to the access checks, grants the caller certain rights.","pos":[267,418]},{"content":"This sample shows both the process of adding claims as well as the process for doing an access check against the finalized set of claims.","pos":[419,556]},{"content":"All application messages between the client and server are signed and encrypted.","pos":[557,637]},{"content":"By default with the <ph id=\"ph1\">`wsHttpBinding`</ph> binding, a username and password supplied by the client are used to logon to a valid Windows NT account.","pos":[638,778],"source":" By default with the `wsHttpBinding` binding, a username and password supplied by the client are used to logon to a valid Windows NT account."},{"content":"This sample demonstrates how to utilize a custom <ph id=\"ph1\">&lt;xref:System.IdentityModel.Selectors.UserNamePasswordValidator&gt;</ph> to authenticate the client.","pos":[779,919],"source":" This sample demonstrates how to utilize a custom <xref:System.IdentityModel.Selectors.UserNamePasswordValidator> to authenticate the client."},{"content":"In addition this sample shows the client authenticating to the service using an X.509 certificate.","pos":[920,1018]},{"content":"This sample shows an implementation of <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph>, which between them grant access to specific methods of the service for specific users.","pos":[1019,1260],"source":" This sample shows an implementation of <xref:System.IdentityModel.Policy.IAuthorizationPolicy> and <xref:System.ServiceModel.ServiceAuthorizationManager>, which between them grant access to specific methods of the service for specific users."},{"content":"This sample is based on the <bpt id=\"p1\">[</bpt>Message Security User Name<ept id=\"p1\">](../../../../docs/framework/wcf/samples/message-security-user-name.md)</ept>, but demonstrates how to perform a claim transformation prior to the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> being called.","pos":[1261,1525],"source":" This sample is based on the [Message Security User Name](../../../../docs/framework/wcf/samples/message-security-user-name.md), but demonstrates how to perform a claim transformation prior to the <xref:System.ServiceModel.ServiceAuthorizationManager> being called."},{"pos":[1529,1635],"content":"[!NOTE]\nThe setup procedure and build instructions for this sample are located at the end of this topic.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this topic.","pos":[8,104]}]},{"content":"In summary, this sample demonstrates how:","pos":[1638,1679]},{"content":"The client can be authenticated using a user name-password.","pos":[1685,1744]},{"content":"The client can be authenticated using an X.509 certificate.","pos":[1750,1809]},{"pos":[1815,1905],"content":"The server validates the client credentials against a custom <ph id=\"ph1\">`UsernamePassword`</ph> validator.","source":"The server validates the client credentials against a custom `UsernamePassword` validator."},{"content":"The server is authenticated using the server's X.509 certificate.","pos":[1911,1976]},{"pos":[1982,2108],"content":"The server can use <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> to control access to certain methods in the service.","source":"The server can use <xref:System.ServiceModel.ServiceAuthorizationManager> to control access to certain methods in the service."},{"pos":[2114,2187],"content":"How to implement <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ph>.","source":"How to implement <xref:System.IdentityModel.Policy.IAuthorizationPolicy>."},{"content":"The service exposes two endpoints for communicating with the service, defined using the configuration file App.config. Each endpoint consists of an address, a binding, and a contract.","pos":[2189,2372]},{"content":"One binding is configured with a standard <ph id=\"ph1\">`wsHttpBinding`</ph> binding that uses WS-Security and client username authentication.","pos":[2373,2496],"source":" One binding is configured with a standard `wsHttpBinding` binding that uses WS-Security and client username authentication."},{"content":"The other binding is configured with a standard <ph id=\"ph1\">`wsHttpBinding`</ph> binding that uses WS-Security and client certificate authentication.","pos":[2497,2629],"source":" The other binding is configured with a standard `wsHttpBinding` binding that uses WS-Security and client certificate authentication."},{"content":"The <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>behavior&gt;<ept id=\"p1\">](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-endpointbehaviors.md)</ept> specifies that the user credentials are to be used for service authentication.","pos":[2630,2818],"source":" The [\\<behavior>](../../../../docs/framework/configure-apps/file-schema/wcf/behavior-of-endpointbehaviors.md) specifies that the user credentials are to be used for service authentication."},{"content":"The server certificate must contain the same value for the <ph id=\"ph1\">`SubjectName`</ph> property as the <ph id=\"ph2\">`findValue`</ph> attribute in the <bpt id=\"p1\">[</bpt><ph id=\"ph3\">\\&lt;</ph>serviceCertificate&gt;<ept id=\"p1\">](../../../../docs/framework/configure-apps/file-schema/wcf/servicecertificate-of-servicecredentials.md)</ept>.","pos":[2819,3064],"source":" The server certificate must contain the same value for the `SubjectName` property as the `findValue` attribute in the [\\<serviceCertificate>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecertificate-of-servicecredentials.md)."},{"content":"Each client endpoint configuration consists of a configuration name, an absolute address for the service endpoint, the binding, and the contract.","pos":[6925,7070]},{"content":"The client binding is configured with the appropriate security mode as specified in this case in the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">\\&lt;</ph>security&gt;<ept id=\"p1\">](../../../../docs/framework/configure-apps/file-schema/wcf/security-of-wshttpbinding.md)</ept> and <ph id=\"ph2\">`clientCredentialType`</ph> as specified in the <bpt id=\"p2\">[</bpt><ph id=\"ph3\">\\&lt;</ph>message&gt;<ept id=\"p2\">](../../../../docs/framework/configure-apps/file-schema/wcf/message-of-wshttpbinding.md)</ept>.","pos":[7071,7421],"source":" The client binding is configured with the appropriate security mode as specified in this case in the [\\<security>](../../../../docs/framework/configure-apps/file-schema/wcf/security-of-wshttpbinding.md) and `clientCredentialType` as specified in the [\\<message>](../../../../docs/framework/configure-apps/file-schema/wcf/message-of-wshttpbinding.md)."},{"content":"For the user name-based endpoint, the client implementation sets the user name and password to use.","pos":[9804,9903]},{"content":"For the certificate-based endpoint, the client implementation sets the client certificate to use.","pos":[10476,10573]},{"content":"This sample uses a custom <ph id=\"ph1\">&lt;xref:System.IdentityModel.Selectors.UserNamePasswordValidator&gt;</ph> to validate user names and passwords.","pos":[11184,11311],"source":"This sample uses a custom <xref:System.IdentityModel.Selectors.UserNamePasswordValidator> to validate user names and passwords."},{"content":"The sample implements <ph id=\"ph1\">`MyCustomUserNamePasswordValidator`</ph>, derived from <ph id=\"ph2\">&lt;xref:System.IdentityModel.Selectors.UserNamePasswordValidator&gt;</ph>.","pos":[11312,11448],"source":" The sample implements `MyCustomUserNamePasswordValidator`, derived from <xref:System.IdentityModel.Selectors.UserNamePasswordValidator>."},{"content":"See the documentation about <ph id=\"ph1\">&lt;xref:System.IdentityModel.Selectors.UserNamePasswordValidator&gt;</ph> for more information.","pos":[11449,11562],"source":" See the documentation about <xref:System.IdentityModel.Selectors.UserNamePasswordValidator> for more information."},{"content":"For the purposes of demonstrating the integration with the <ph id=\"ph1\">&lt;xref:System.IdentityModel.Selectors.UserNamePasswordValidator&gt;</ph>, this custom validator sample implements the <ph id=\"ph2\">&lt;xref:System.IdentityModel.Selectors.UserNamePasswordValidator.Validate%2A&gt;</ph> method to accept user name/password pairs where the user name matches the password as shown in the following code.","pos":[11563,11921],"source":" For the purposes of demonstrating the integration with the <xref:System.IdentityModel.Selectors.UserNamePasswordValidator>, this custom validator sample implements the <xref:System.IdentityModel.Selectors.UserNamePasswordValidator.Validate%2A> method to accept user name/password pairs where the user name matches the password as shown in the following code."},{"content":"Once the validator is implemented in service code, the service host must be informed about the validator instance to use.","pos":[12637,12758]},{"content":"This is done using the following code:","pos":[12759,12797]},{"content":"Or you can do the same thing in configuration:","pos":[13063,13109]},{"content":"Windows Communication Foundation (WCF) provides a rich claims-based model for performing access checks.","pos":[13522,13625]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> object is used to perform the access check and determine whether the claims associated with the client satisfy the requirements necessary to access the service method.","pos":[13626,13852],"source":" The <xref:System.ServiceModel.ServiceAuthorizationManager> object is used to perform the access check and determine whether the claims associated with the client satisfy the requirements necessary to access the service method."},{"pos":[13854,14265],"content":"For the purposes of demonstration, this sample shows an implementation of <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> that implements the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A&gt;</ph> method to allow a user's access to methods based on claims of type <ph id=\"ph3\">`http://example.com/claims/allowedoperation`</ph> whose value is the Action URI of the operation that is allowed to be called.","source":"For the purposes of demonstration, this sample shows an implementation of <xref:System.ServiceModel.ServiceAuthorizationManager> that implements the <xref:System.ServiceModel.ServiceAuthorizationManager.CheckAccessCore%2A> method to allow a user's access to methods based on claims of type `http://example.com/claims/allowedoperation` whose value is the Action URI of the operation that is allowed to be called."},{"content":"Once the custom <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> is implemented, the service host must be informed about the <ph id=\"ph2\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> to use.","pos":[15034,15227],"source":"Once the custom <xref:System.ServiceModel.ServiceAuthorizationManager> is implemented, the service host must be informed about the <xref:System.ServiceModel.ServiceAuthorizationManager> to use."},{"content":"This is done as shown in the following code.","pos":[15228,15272]},{"pos":[15492,15729],"content":"The primary <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ph> method to implement is the <ph id=\"ph2\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%28System.IdentityModel.Policy.EvaluationContext%2CSystem.Object%40%29&gt;</ph> method.","source":"The primary <xref:System.IdentityModel.Policy.IAuthorizationPolicy> method to implement is the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%28System.IdentityModel.Policy.EvaluationContext%2CSystem.Object%40%29> method."},{"content":"The previous code shows how the <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%28System.IdentityModel.Policy.EvaluationContext%2CSystem.Object%40%29&gt;</ph> method checks that no new claims have been added that affect the processing and adds specific claims.","pos":[17349,17617],"source":"The previous code shows how the <xref:System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate%28System.IdentityModel.Policy.EvaluationContext%2CSystem.Object%40%29> method checks that no new claims have been added that affect the processing and adds specific claims."},{"content":"The claims that are allowed are obtained from the <ph id=\"ph1\">`GetAllowedOpList`</ph> method, which is implemented to return a specific list of operations that the user is allowed to perform.","pos":[17618,17792],"source":" The claims that are allowed are obtained from the `GetAllowedOpList` method, which is implemented to return a specific list of operations that the user is allowed to perform."},{"content":"The authorization policy adds claims for accessing the particular operation.","pos":[17793,17869]},{"content":"This is later used by the <ph id=\"ph1\">&lt;xref:System.ServiceModel.ServiceAuthorizationManager&gt;</ph> to perform access check decisions.","pos":[17870,17985],"source":" This is later used by the <xref:System.ServiceModel.ServiceAuthorizationManager> to perform access check decisions."},{"pos":[17987,18149],"content":"Once the custom <ph id=\"ph1\">&lt;xref:System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ph> is implemented, the service host must be informed about the authorization policies to use.","source":"Once the custom <xref:System.IdentityModel.Policy.IAuthorizationPolicy> is implemented, the service host must be informed about the authorization policies to use."},{"content":"When you run the sample, the operation requests and responses are displayed in the client console window.","pos":[18404,18509]},{"content":"The client successfully calls the Add, Subtract and Multiple methods and gets an \"Access is denied\" message when trying to call the Divide method.","pos":[18510,18656]},{"content":"Press ENTER in the client window to shut down the client.","pos":[18657,18714]},{"pos":[18719,18735],"content":"Setup Batch File","linkify":"Setup Batch File","nodes":[{"content":"Setup Batch File","pos":[0,16]}]},{"content":"The Setup.bat batch file included with this sample allows you to configure the server with relevant certificates to run a self-hosted application that requires server certificate-based security.","pos":[18737,18931]},{"content":"The following provides a brief overview of the different sections of the batch files so that they can be modified to run in the appropriate configuration:","pos":[18933,19087]},{"content":"Creating the server certificate.","pos":[19093,19125]},{"content":"The following lines from the Setup.bat batch file create the server certificate to be used.","pos":[19132,19223]},{"content":"The %SERVER_NAME% variable specifies the server name.","pos":[19224,19277]},{"content":"Change this variable to specify your own server name.","pos":[19278,19331]},{"content":"The default value is localhost.","pos":[19332,19363]},{"content":"Installing the server certificate into client's trusted certificate store.","pos":[19626,19700]},{"content":"The following lines in the Setup.bat batch file copy the server certificate into the client trusted people store.","pos":[19707,19820]},{"content":"This step is required because certificates that are generated by Makecert.exe are not implicitly trusted by the client system.","pos":[19821,19947]},{"content":"If you already have a certificate that is rooted in a client trusted root certificate—for example, a Microsoft issued certificate—this step of populating the client certificate store with the server certificate is not required.","pos":[19948,20175]},{"content":"Creating the client certificate.","pos":[20293,20325]},{"content":"The following lines from the Setup.bat batch file create the client certificate to be used.","pos":[20332,20423]},{"content":"The %USER_NAME% variable specifies the server name.","pos":[20424,20475]},{"content":"This value is set to \"test1\" because this is the name the <ph id=\"ph1\">`IAuthorizationPolicy`</ph> looks for.","pos":[20476,20567],"source":" This value is set to \"test1\" because this is the name the `IAuthorizationPolicy` looks for."},{"content":"If you change the value of %USER_NAME% you must change the corresponding value in the <ph id=\"ph1\">`IAuthorizationPolicy.Evaluate`</ph> method.","pos":[20568,20693],"source":" If you change the value of %USER_NAME% you must change the corresponding value in the `IAuthorizationPolicy.Evaluate` method."},{"content":"The certificate is stored in My (Personal) store under the CurrentUser store location.","pos":[20700,20786]},{"content":"Installing the client certificate into server's trusted certificate store.","pos":[20967,21041]},{"content":"The following lines in the Setup.bat batch file copy the client certificate into the trusted people store.","pos":[21048,21154]},{"content":"This step is required because certificates that are generated by Makecert.exe are not implicitly trusted by the server system.","pos":[21155,21281]},{"content":"If you already have a certificate that is rooted in a trusted root certificate—for example, a Microsoft issued certificate—this step of populating the server certificate store with the client certificate is not required.","pos":[21282,21502]},{"pos":[21620,21650],"content":"To set up and build the sample","linkify":"To set up and build the sample","nodes":[{"content":"To set up and build the sample","pos":[0,30]}]},{"pos":[21655,21825],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"content":"To run the sample in a single- or cross-computer configuration, use the following instructions.","pos":[21830,21925]},{"pos":[21929,22100],"content":"[!NOTE]\nIf you use Svcutil.exe to regenerate the configuration for this sample, be sure to modify the endpoint name in the client configuration to match the client code.","leadings":["","> "],"nodes":[{"content":"If you use Svcutil.exe to regenerate the configuration for this sample, be sure to modify the endpoint name in the client configuration to match the client code.","pos":[8,169]}]},{"pos":[22106,22144],"content":"To run the sample on the same computer","linkify":"To run the sample on the same computer","nodes":[{"content":"To run the sample on the same computer","pos":[0,38]}]},{"content":"Open Developer Command Prompt for Visual Studio with administrator privileges and run <bpt id=\"p1\">*</bpt>Setup.bat<ept id=\"p1\">*</ept> from the sample install folder.","pos":[22149,22278],"source":"Open Developer Command Prompt for Visual Studio with administrator privileges and run *Setup.bat* from the sample install folder."},{"content":"This installs all the certificates required for running the sample.","pos":[22279,22346]},{"pos":[22354,22633],"content":"[!NOTE]\nThe Setup.bat batch file is designed to be run from Developer Command Prompt for Visual Studio. The PATH environment variable set within Developer Command Prompt for Visual Studio points to the directory that contains executables required by the *Setup.bat* script.","leadings":["","    > "],"nodes":[{"content":"The Setup.bat batch file is designed to be run from Developer Command Prompt for Visual Studio. The PATH environment variable set within Developer Command Prompt for Visual Studio points to the directory that contains executables required by the *Setup.bat* script.","pos":[8,273],"nodes":[{"content":"The Setup.bat batch file is designed to be run from Developer Command Prompt for Visual Studio.","pos":[0,95]},{"content":"The PATH environment variable set within Developer Command Prompt for Visual Studio points to the directory that contains executables required by the <bpt id=\"p1\">*</bpt>Setup.bat<ept id=\"p1\">*</ept> script.","pos":[96,265],"source":" The PATH environment variable set within Developer Command Prompt for Visual Studio points to the directory that contains executables required by the *Setup.bat* script."}]}]},{"pos":[22638,22676],"content":"Launch Service.exe from <bpt id=\"p1\">*</bpt>service\\bin<ept id=\"p1\">*</ept>.","source":"Launch Service.exe from *service\\bin*."},{"content":"Launch Client.exe from <bpt id=\"p1\">*</bpt>\\client\\bin<ept id=\"p1\">*</ept>.","pos":[22681,22718],"source":"Launch Client.exe from *\\client\\bin*."},{"content":"Client activity is displayed on the client console application.","pos":[22719,22782]},{"pos":[22786,22972],"content":"If the client and service are not able to communicate, see <bpt id=\"p1\">[</bpt>Troubleshooting Tips for WCF Samples<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751511(v=vs.90))</ept>.","source":"If the client and service are not able to communicate, see [Troubleshooting Tips for WCF Samples](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751511(v=vs.90))."},{"pos":[22978,23012],"content":"To run the sample across computers","linkify":"To run the sample across computers","nodes":[{"content":"To run the sample across computers","pos":[0,34]}]},{"content":"Create a directory on the service computer.","pos":[23017,23060]},{"content":"Copy the service program files from <bpt id=\"p1\">*</bpt>\\service\\bin<ept id=\"p1\">*</ept> to the directory on the service computer.","pos":[23065,23157],"source":"Copy the service program files from *\\service\\bin* to the directory on the service computer."},{"content":"Also copy the Setup.bat, Cleanup.bat, GetComputerName.vbs and ImportClientCert.bat files to the service computer.","pos":[23158,23271]},{"content":"Create a directory on the client computer for the client binaries.","pos":[23276,23342]},{"content":"Copy the client program files to the client directory on the client computer.","pos":[23347,23424]},{"content":"Also copy the Setup.bat, Cleanup.bat, and ImportServiceCert.bat files to the client.","pos":[23425,23509]},{"pos":[23514,23636],"content":"On the server, run <ph id=\"ph1\">`setup.bat service`</ph> in Developer Command Prompt for Visual Studio opened with administrator privileges.","source":"On the server, run `setup.bat service` in Developer Command Prompt for Visual Studio opened with administrator privileges."},{"pos":[23641,23839],"content":"Running <ph id=\"ph1\">`setup.bat`</ph> with the <ph id=\"ph2\">`service`</ph> argument creates a service certificate with the fully qualified domain name of the computer, and exports the service certificate to a file named <bpt id=\"p1\">*</bpt>Service.cer<ept id=\"p1\">*</ept>.","source":"Running `setup.bat` with the `service` argument creates a service certificate with the fully qualified domain name of the computer, and exports the service certificate to a file named *Service.cer*."},{"content":"Edit <bpt id=\"p1\">*</bpt>Service.exe.config<ept id=\"p1\">*</ept> to reflect the new certificate name (in the <ph id=\"ph1\">`findValue`</ph> attribute in the <bpt id=\"p2\">[</bpt><ph id=\"ph2\">\\&lt;</ph>serviceCertificate&gt;<ept id=\"p2\">](../../../../docs/framework/configure-apps/file-schema/wcf/servicecertificate-of-servicecredentials.md)</ept>) which is the same as the fully qualified domain name of the computer.","pos":[23844,24140],"source":"Edit *Service.exe.config* to reflect the new certificate name (in the `findValue` attribute in the [\\<serviceCertificate>](../../../../docs/framework/configure-apps/file-schema/wcf/servicecertificate-of-servicecredentials.md)) which is the same as the fully qualified domain name of the computer."},{"content":"Also change the <bpt id=\"p1\">**</bpt>computername<ept id=\"p1\">**</ept> in the <ph id=\"ph1\">\\&lt;</ph>service&gt;/<ph id=\"ph2\">\\&lt;</ph>baseAddresses&gt; element from localhost to the fully qualified name of your service computer.","pos":[24141,24285],"source":" Also change the **computername** in the \\<service>/\\<baseAddresses> element from localhost to the fully qualified name of your service computer."},{"pos":[24290,24392],"content":"Copy the <bpt id=\"p1\">*</bpt>Service.cer<ept id=\"p1\">*</ept> file from the service directory to the client directory on the client computer.","source":"Copy the *Service.cer* file from the service directory to the client directory on the client computer."},{"pos":[24397,24518],"content":"On the client, run <ph id=\"ph1\">`setup.bat client`</ph> in Developer Command Prompt for Visual Studio opened with administrator privileges.","source":"On the client, run `setup.bat client` in Developer Command Prompt for Visual Studio opened with administrator privileges."},{"pos":[24523,24679],"content":"Running <ph id=\"ph1\">`setup.bat`</ph> with the <ph id=\"ph2\">`client`</ph> argument creates a client certificate named <bpt id=\"p1\">**</bpt>test1<ept id=\"p1\">**</ept> and exports the client certificate to a file named <bpt id=\"p2\">*</bpt>Client.cer<ept id=\"p2\">*</ept>.","source":"Running `setup.bat` with the `client` argument creates a client certificate named **test1** and exports the client certificate to a file named *Client.cer*."},{"content":"In the <bpt id=\"p1\">*</bpt>Client.exe.config<ept id=\"p1\">*</ept> file on the client computer, change the address value of the endpoint to match the new address of your service.","pos":[24684,24822],"source":"In the *Client.exe.config* file on the client computer, change the address value of the endpoint to match the new address of your service."},{"content":"Do this by replacing <bpt id=\"p1\">**</bpt>localhost<ept id=\"p1\">**</ept> with the fully qualified domain name of the server.","pos":[24823,24909],"source":" Do this by replacing **localhost** with the fully qualified domain name of the server."},{"content":"Copy the Client.cer file from the client directory to the service directory on the server.","pos":[24915,25005]},{"pos":[25011,25137],"content":"On the client, run <bpt id=\"p1\">*</bpt>ImportServiceCert.bat<ept id=\"p1\">*</ept> in Developer Command Prompt for Visual Studio opened with administrator privileges.","source":"On the client, run *ImportServiceCert.bat* in Developer Command Prompt for Visual Studio opened with administrator privileges."},{"pos":[25142,25252],"content":"This imports the service certificate from the Service.cer file into the <bpt id=\"p1\">**</bpt>CurrentUser - TrustedPeople<ept id=\"p1\">**</ept> store.","source":"This imports the service certificate from the Service.cer file into the **CurrentUser - TrustedPeople** store."},{"pos":[25258,25383],"content":"On the server, run <bpt id=\"p1\">*</bpt>ImportClientCert.bat<ept id=\"p1\">*</ept> in Developer Command Prompt for Visual Studio opened with administrator privileges.","source":"On the server, run *ImportClientCert.bat* in Developer Command Prompt for Visual Studio opened with administrator privileges."},{"pos":[25388,25497],"content":"This imports the client certificate from the Client.cer file into the <bpt id=\"p1\">**</bpt>LocalMachine - TrustedPeople<ept id=\"p1\">**</ept> store.","source":"This imports the client certificate from the Client.cer file into the **LocalMachine - TrustedPeople** store."},{"content":"On the server computer, launch Service.exe from the command prompt window.","pos":[25503,25577]},{"content":"On the client computer, launch Client.exe from a command prompt window.","pos":[25583,25654]},{"pos":[25659,25845],"content":"If the client and service are not able to communicate, see <bpt id=\"p1\">[</bpt>Troubleshooting Tips for WCF Samples<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751511(v=vs.90))</ept>.","source":"If the client and service are not able to communicate, see [Troubleshooting Tips for WCF Samples](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751511(v=vs.90))."},{"pos":[25851,25876],"content":"Clean up after the sample","linkify":"Clean up after the sample","nodes":[{"content":"Clean up after the sample","pos":[0,25]}]},{"content":"To clean up after the sample, run <bpt id=\"p1\">*</bpt>Cleanup.bat<ept id=\"p1\">*</ept> in the samples folder when you have finished running the sample.","pos":[25878,25990],"source":"To clean up after the sample, run *Cleanup.bat* in the samples folder when you have finished running the sample."},{"content":"This removes the server and client certificates from the certificate store.","pos":[25991,26066]},{"pos":[26070,26577],"content":"[!NOTE]\nThis script does not remove service certificates on a client when running this sample across computers. If you have run WCF samples that use certificates across computers, be sure to clear the service certificates that have been installed in the CurrentUser - TrustedPeople store. To do this, use the following command: `certmgr -del -r CurrentUser -s TrustedPeople -c -n <Fully Qualified Server Machine Name>` For example: `certmgr -del -r CurrentUser -s TrustedPeople -c -n server1.contoso.com`.","leadings":["","> "],"nodes":[{"content":"This script does not remove service certificates on a client when running this sample across computers. If you have run WCF samples that use certificates across computers, be sure to clear the service certificates that have been installed in the CurrentUser - TrustedPeople store. To do this, use the following command: `certmgr -del -r CurrentUser -s TrustedPeople -c -n <Fully Qualified Server Machine Name>` For example: `certmgr -del -r CurrentUser -s TrustedPeople -c -n server1.contoso.com`.","pos":[8,505],"nodes":[{"content":"This script does not remove service certificates on a client when running this sample across computers.","pos":[0,103]},{"content":"If you have run WCF samples that use certificates across computers, be sure to clear the service certificates that have been installed in the CurrentUser - TrustedPeople store.","pos":[104,280]},{"content":"To do this, use the following command: <ph id=\"ph1\">`certmgr -del -r CurrentUser -s TrustedPeople -c -n &lt;Fully Qualified Server Machine Name&gt;`</ph> For example: <ph id=\"ph2\">`certmgr -del -r CurrentUser -s TrustedPeople -c -n server1.contoso.com`</ph>.","pos":[281,497],"source":" To do this, use the following command: `certmgr -del -r CurrentUser -s TrustedPeople -c -n <Fully Qualified Server Machine Name>` For example: `certmgr -del -r CurrentUser -s TrustedPeople -c -n server1.contoso.com`."}]}]}]}