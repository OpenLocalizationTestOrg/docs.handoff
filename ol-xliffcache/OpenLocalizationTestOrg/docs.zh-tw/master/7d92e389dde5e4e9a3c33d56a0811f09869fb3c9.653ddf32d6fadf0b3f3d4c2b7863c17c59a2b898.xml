{"content":"---\ntitle: \"Overview of Synchronization Primitives | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"synchronization, threads\"\n  - \"threading [.NET Framework],synchronizing threads\"\n  - \"managed threading\"\nms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309\ncaps.latest.revision: 17\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Overview of Synchronization Primitives\n<a name=\"top\"></a> The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions. These can be roughly divided into three categories: locking, signaling, and interlocked operations.  \n  \n The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks. However, the categories are still useful.  \n  \n It is important to remember that thread synchronization is cooperative. If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.  \n  \n This overview contains the following sections:  \n  \n-   [Locking](#locking)  \n  \n-   [Signaling](#signaling)  \n  \n-   [Lightweight Synchronization Types](#lightweight_synchronization_types)  \n  \n-   [SpinWait](#spinwait)  \n  \n-   [Interlocked Operations](#interlocked_operations)  \n  \n<a name=\"locking\"></a>   \n## Locking  \n Locks give control of a resource to one thread at a time, or to a specified number of threads. A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.  \n  \n### Exclusive Locks  \n The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code. Such a block is frequently referred to as a critical section. The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods, and it uses `try…catch…finally` block to ensure that the lock is released.  \n  \n In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class. Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.  \n  \n#### Monitor Class  \n The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:  \n  \n-   The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval. It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.  \n  \n-   The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section. It gives up control of the resource and blocks until the resource is available again.  \n  \n-   The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.  \n  \n Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.  \n  \n The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.  \n  \n <xref:System.Threading.Monitor> has thread affinity. That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.  \n  \n The <xref:System.Threading.Monitor> class is not instantiable. Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.  \n  \n For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).  \n  \n#### Mutex Class  \n Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method. Overloads with timeouts are provided, to allow threads to give up the wait. Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global. Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes. Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.  \n  \n In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.  \n  \n Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity. Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.  \n  \n For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).  \n  \n#### SpinLock Class  \n Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance. When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available. If the lock is held for a very short time, spinning can provide better performance than blocking. However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.  \n  \n### Other Locks  \n Locks need not be exclusive. It is often useful to allow a limited number of threads concurrent access to a resource. Semaphores and reader-writer locks are designed to control this kind of pooled resource access.  \n  \n#### ReaderWriterLock Class  \n The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource. When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method). When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.  \n  \n <xref:System.Threading.ReaderWriterLockSlim> has thread affinity.  \n  \n For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).  \n  \n#### Semaphore Class  \n The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource. Additional threads requesting the resource block until a thread releases the semaphore.  \n  \n Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>. Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global. It can be used across application domain boundaries.  \n  \n Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity. This means it can be used in scenarios where one thread acquires the semaphore and another releases it.  \n  \n For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).  \n  \n <xref:System.Threading.SemaphoreSlim?displayProperty=fullName> is a lightweight semaphore for synchronization within a single process boundary.  \n  \n [Back to top](#top)  \n  \n<a name=\"signaling\"></a>   \n## Signaling  \n The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes. <xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.  \n  \n Wait handles provide a much richer set of waiting and signaling capabilities.  \n  \n### Wait Handles  \n Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>. Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.  \n  \n Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>. How they are released depends on which method was called, and on the kind of wait handles.  \n  \n For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).  \n  \n#### Event Wait Handles  \n Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>. Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.  \n  \n Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it. As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively. <xref:System.Threading.ManualResetEventSlim?displayProperty=fullName> is a lightweight event for synchronization within a single process boundary.  \n  \n An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global. The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.  \n  \n Event wait handles do not have thread affinity. Any thread can signal an event wait handle.  \n  \n For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  \n  \n#### Mutex and Semaphore Classes  \n Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>. For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released. Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.  \n  \n For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released. If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released. In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex. As noted previously, semaphores do not have thread affinity.  \n  \n#### Barrier  \n The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete. A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm. For more information, see [Barrier](../../../docs/standard/threading/barrier.md).  \n  \n [Back to top](#top)  \n  \n<a name=\"lightweight_synchronization_types\"></a>   \n## Lightweight Synchronization Types  \n Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible. In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory. The lightweight types cannot be used in scenarios that require cross-process communication.  \n  \n-   <xref:System.Threading.SemaphoreSlim?displayProperty=fullName> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=fullName>.  \n  \n-   <xref:System.Threading.ManualResetEventSlim?displayProperty=fullName> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=fullName>.  \n  \n-   <xref:System.Threading.CountdownEvent?displayProperty=fullName> represents an event that becomes signaled when its count is zero.  \n  \n-   <xref:System.Threading.Barrier?displayProperty=fullName> enables multiple threads to synchronize with one another without requiring control by a master thread. A barrier prevents each thread from continuing until all threads have reached a specified point.  \n  \n [Back to top](#top)  \n  \n<a name=\"spinwait\"></a>   \n## SpinWait  \n Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=fullName> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread. By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.  \n  \n [Back to top](#top)  \n  \n<a name=\"interlocked_operations\"></a>   \n## Interlocked Operations  \n Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class. Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.  \n  \n> [!NOTE]\n>  The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.  \n  \n Although none of these operations are locks or signals, they can be used to construct locks and signals. Because they are native to the Windows operating system, interlocked operations are extremely fast.  \n  \n Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency. However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.  \n  \n For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).  \n  \n## See Also  \n [Synchronizing Data for Multithreading](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)   \n [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)   \n [Mutexes](../../../docs/standard/threading/mutexes.md)   \n [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)   \n [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)   \n [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)   \n [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md)   \n [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md)   \n [Barrier](../../../docs/standard/threading/barrier.md)   \n [SpinWait](../../../docs/standard/threading/spinwait.md)   \n [SpinLock](../../../docs/standard/threading/spinlock.md)","nodes":[{"pos":[12,67],"content":"Overview of Synchronization Primitives | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Overview of Synchronization Primitives | Microsoft Docs","pos":[0,55]}]},{"pos":[491,529],"content":"Overview of Synchronization Primitives","linkify":"Overview of Synchronization Primitives","nodes":[{"content":"Overview of Synchronization Primitives","pos":[0,38]}]},{"content":"<bpt id=\"p1\">&lt;a name=\"top\"&gt;</bpt><ept id=\"p1\">&lt;/a&gt;</ept> The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.","pos":[530,688],"source":"<a name=\"top\"></a> The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions."},{"content":"These can be roughly divided into three categories: locking, signaling, and interlocked operations.","pos":[689,788]},{"content":"The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.","pos":[795,1109]},{"content":"However, the categories are still useful.","pos":[1110,1151]},{"content":"It is important to remember that thread synchronization is cooperative.","pos":[1158,1229]},{"content":"If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.","pos":[1230,1383]},{"content":"This overview contains the following sections:","pos":[1390,1436]},{"pos":[1446,1465],"content":"<bpt id=\"p1\">[</bpt>Locking<ept id=\"p1\">](#locking)</ept>","source":"[Locking](#locking)"},{"pos":[1475,1498],"content":"<bpt id=\"p1\">[</bpt>Signaling<ept id=\"p1\">](#signaling)</ept>","source":"[Signaling](#signaling)"},{"pos":[1508,1579],"content":"<bpt id=\"p1\">[</bpt>Lightweight Synchronization Types<ept id=\"p1\">](#lightweight_synchronization_types)</ept>","source":"[Lightweight Synchronization Types](#lightweight_synchronization_types)"},{"pos":[1589,1610],"content":"<bpt id=\"p1\">[</bpt>SpinWait<ept id=\"p1\">](#spinwait)</ept>","source":"[SpinWait](#spinwait)"},{"pos":[1620,1669],"content":"<bpt id=\"p1\">[</bpt>Interlocked Operations<ept id=\"p1\">](#interlocked_operations)</ept>","source":"[Interlocked Operations](#interlocked_operations)"},{"pos":[1704,1711],"content":"Locking","linkify":"Locking","nodes":[{"content":"Locking","pos":[0,7]}]},{"content":"Locks give control of a resource to one thread at a time, or to a specified number of threads.","pos":[1715,1809]},{"content":"A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.","pos":[1810,1915]},{"pos":[1925,1940],"content":"Exclusive Locks","linkify":"Exclusive Locks","nodes":[{"content":"Exclusive Locks","pos":[0,15]}]},{"content":"The simplest form of locking is the <ph id=\"ph1\">`lock`</ph> statement in C# and the <ph id=\"ph2\">`SyncLock`</ph> statement in Visual Basic, which controls access to a block of code.","pos":[1944,2090],"source":"The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code."},{"content":"Such a block is frequently referred to as a critical section.","pos":[2091,2152]},{"content":"The <ph id=\"ph1\">`lock`</ph> statement is implemented by using the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName&gt;</ph> methods, and it uses <ph id=\"ph4\">`try…catch…finally`</ph> block to ensure that the lock is released.","pos":[2153,2420],"source":" The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods, and it uses `try…catch…finally` block to ensure that the lock is released."},{"content":"In general, using the <ph id=\"ph1\">`lock`</ph> or <ph id=\"ph2\">`SyncLock`</ph> statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor&gt;</ph> class.","pos":[2427,2620],"source":"In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class."},{"content":"Although powerful, the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class is prone to orphan locks and deadlocks.","pos":[2621,2721],"source":" Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks."},{"pos":[2732,2745],"content":"Monitor Class","linkify":"Monitor Class","nodes":[{"content":"Monitor Class","pos":[0,13]}]},{"pos":[2749,2885],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class provides additional functionality, which can be used in conjunction with the <ph id=\"ph2\">`lock`</ph> statement:","source":"The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:"},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> method allows a thread that is blocked waiting for the resource to give up after a specified interval.","pos":[2895,3045],"source":"The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval."},{"content":"It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.","pos":[3046,3162]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called by a thread in a critical section.","pos":[3172,3267],"source":"The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section."},{"content":"It gives up control of the resource and blocks until the resource is available again.","pos":[3268,3353]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> methods allow a thread that is about to release the lock or to call <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> to put one or more threads into the ready queue, so that they can acquire the lock.","pos":[3363,3647],"source":"The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock."},{"content":"Timeouts on <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method overloads allow waiting threads to escape to the ready queue.","pos":[3654,3774],"source":"Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class can provide locking in multiple application domains if the object used for the lock derives from <ph id=\"ph2\">&lt;xref:System.MarshalByRefObject&gt;</ph>.","pos":[3781,3953],"source":"The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> has thread affinity.","pos":[3960,4012],"source":"<xref:System.Threading.Monitor> has thread affinity."},{"content":"That is, a thread that entered the monitor must exit by calling <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph>.","pos":[4013,4160],"source":" That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class is not instantiable.","pos":[4167,4229],"source":"The <xref:System.Threading.Monitor> class is not instantiable."},{"content":"Its methods are static (<ph id=\"ph1\">`Shared`</ph> in Visual Basic), and act on an instantiable lock object.","pos":[4230,4320],"source":" Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object."},{"pos":[4327,4441],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>Monitors<ept id=\"p1\">](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)</ept>.","source":"For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)."},{"pos":[4452,4463],"content":"Mutex Class","linkify":"Mutex Class","nodes":[{"content":"Mutex Class","pos":[0,11]}]},{"content":"Threads request a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> by calling an overload of its <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.","pos":[4467,4598],"source":"Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method."},{"content":"Overloads with timeouts are provided, to allow threads to give up the wait.","pos":[4599,4674]},{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class, a mutex can be either local or global.","pos":[4675,4763],"source":" Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global."},{"content":"Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.","pos":[4764,4936]},{"content":"Local mutexes derive from <ph id=\"ph1\">&lt;xref:System.MarshalByRefObject&gt;</ph>, and can be used across application domain boundaries.","pos":[4937,5050],"source":" Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries."},{"content":"In addition, <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> derives from <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph>, which means that it can be used with the signaling mechanisms provided by <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle&gt;</ph>, such as the <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, and <ph id=\"ph6\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> methods.","pos":[5057,5429],"source":"In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods."},{"content":"Like <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> has thread affinity.","pos":[5436,5524],"source":"Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity."},{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph>, a <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph> is an instantiable object.","pos":[5525,5623],"source":" Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object."},{"pos":[5630,5716],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>Mutexes<ept id=\"p1\">](../../../docs/standard/threading/mutexes.md)</ept>.","source":"For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md)."},{"pos":[5727,5741],"content":"SpinLock Class","linkify":"SpinLock Class","nodes":[{"content":"SpinLock Class","pos":[0,14]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]</ph>, you can use the <ph id=\"ph2\">&lt;xref:System.Threading.SpinLock&gt;</ph> class when the overhead required by <ph id=\"ph3\">&lt;xref:System.Threading.Monitor&gt;</ph> degrades performance.","pos":[5745,5965],"source":"Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> encounters a locked critical section, it simply spins in a loop until the lock becomes available.","pos":[5966,6101],"source":" When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available."},{"content":"If the lock is held for a very short time, spinning can provide better performance than blocking.","pos":[6102,6199]},{"content":"However, if the lock is held for more than a few tens of cycles, <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> performs just as well as <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.","pos":[6200,6452],"source":" However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes."},{"pos":[6462,6473],"content":"Other Locks","linkify":"Other Locks","nodes":[{"content":"Other Locks","pos":[0,11]}]},{"content":"Locks need not be exclusive.","pos":[6477,6505]},{"content":"It is often useful to allow a limited number of threads concurrent access to a resource.","pos":[6506,6594]},{"content":"Semaphores and reader-writer locks are designed to control this kind of pooled resource access.","pos":[6595,6690]},{"pos":[6701,6723],"content":"ReaderWriterLock Class","linkify":"ReaderWriterLock Class","nodes":[{"content":"ReaderWriterLock Class","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.","pos":[6727,6888],"source":"The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource."},{"content":"When the writer is not active, any number of readers can access the resource (for example, by calling the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method).","pos":[6889,7065],"source":" When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method)."},{"content":"When a thread requests exclusive access, (for example, by calling the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.","pos":[7066,7337],"source":" When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has thread affinity.","pos":[7344,7409],"source":"<xref:System.Threading.ReaderWriterLockSlim> has thread affinity."},{"pos":[7416,7526],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>Reader-Writer Locks<ept id=\"p1\">](../../../docs/standard/threading/reader-writer-locks.md)</ept>.","source":"For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md)."},{"pos":[7537,7552],"content":"Semaphore Class","linkify":"Semaphore Class","nodes":[{"content":"Semaphore Class","pos":[0,15]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> class allows a specified number of threads to access a resource.","pos":[7556,7658],"source":"The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource."},{"content":"Additional threads requesting the resource block until a thread releases the semaphore.","pos":[7659,7746]},{"content":"Like the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> class, <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> derives from <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle&gt;</ph>.","pos":[7753,7881],"source":"Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>."},{"content":"Also like <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph>, a <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> can be either local or global.","pos":[7882,7989],"source":" Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global."},{"content":"It can be used across application domain boundaries.","pos":[7990,8042]},{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Mutex&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Threading.Semaphore&gt;</ph> does not have thread affinity.","pos":[8049,8230],"source":"Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity."},{"content":"This means it can be used in scenarios where one thread acquires the semaphore and another releases it.","pos":[8231,8334]},{"pos":[8341,8467],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>Semaphore and SemaphoreSlim<ept id=\"p1\">](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)</ept>.","source":"For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim?displayProperty=fullName&gt;</ph> is a lightweight semaphore for synchronization within a single process boundary.","pos":[8474,8617],"source":"<xref:System.Threading.SemaphoreSlim?displayProperty=fullName> is a lightweight semaphore for synchronization within a single process boundary."},{"pos":[8624,8643],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[8680,8689],"content":"Signaling","linkify":"Signaling","nodes":[{"content":"Signaling","pos":[0,9]}]},{"content":"The simplest way to wait for a signal from another thread is to call the <ph id=\"ph1\">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method, which blocks until the other thread completes.","pos":[8693,8859],"source":"The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.","pos":[8860,9011],"source":"<xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed."},{"content":"Wait handles provide a much richer set of waiting and signaling capabilities.","pos":[9018,9095]},{"pos":[9105,9117],"content":"Wait Handles","linkify":"Wait Handles","nodes":[{"content":"Wait Handles","pos":[0,12]}]},{"content":"Wait handles derive from the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, which in turn derives from <ph id=\"ph2\">&lt;xref:System.MarshalByRefObject&gt;</ph>.","pos":[9121,9252],"source":"Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>."},{"content":"Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.","pos":[9253,9362]},{"content":"Threads block on wait handles by calling the instance method <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or one of the static methods <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph>.","pos":[9369,9654],"source":"Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>."},{"content":"How they are released depends on which method was called, and on the kind of wait handles.","pos":[9655,9745]},{"pos":[9752,9870],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>Wait Handles<ept id=\"p1\">](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)</ept>.","source":"For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)."},{"pos":[9881,9899],"content":"Event Wait Handles","linkify":"Event Wait Handles","nodes":[{"content":"Event Wait Handles","pos":[0,18]}]},{"content":"Event wait handles include the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class and its derived classes, <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>.","pos":[9903,10089],"source":"Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>."},{"content":"Threads are released from an event wait handle when the event wait handle is signaled by calling its <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method or by using the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method.","pos":[10090,10320],"source":" Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method."},{"content":"Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.","pos":[10327,10571]},{"content":"As their names imply, <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> represent the former and latter, respectively.","pos":[10572,10724],"source":" As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEventSlim?displayProperty=fullName&gt;</ph> is a lightweight event for synchronization within a single process boundary.","pos":[10725,10871],"source":"<xref:System.Threading.ManualResetEventSlim?displayProperty=fullName> is a lightweight event for synchronization within a single process boundary."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> can represent either type of event, and can be either local or global.","pos":[10878,10991],"source":"An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global."},{"content":"The derived classes <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> are always local.","pos":[10992,11113],"source":" The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local."},{"content":"Event wait handles do not have thread affinity.","pos":[11120,11167]},{"content":"Any thread can signal an event wait handle.","pos":[11168,11211]},{"pos":[11218,11417],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id=\"p1\">](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.","source":"For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)."},{"pos":[11428,11455],"content":"Mutex and Semaphore Classes","linkify":"Mutex and Semaphore Classes","nodes":[{"content":"Mutex and Semaphore Classes","pos":[0,27]}]},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> classes derive from <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle&gt;</ph>, they can be used with the static methods of <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle&gt;</ph>.","pos":[11459,11674],"source":"Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>."},{"content":"For example, a thread can use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method to wait until all three of the following are true: an <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is signaled, a <ph id=\"ph3\">&lt;xref:System.Threading.Mutex&gt;</ph> is released, and a <ph id=\"ph4\">&lt;xref:System.Threading.Semaphore&gt;</ph> is released.","pos":[11675,11966],"source":" For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released."},{"content":"Similarly, a thread can use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method to wait until any one of those conditions is true.","pos":[11967,12102],"source":" Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true."},{"content":"For a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> or a <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph>, being signaled means being released.","pos":[12109,12221],"source":"For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released."},{"content":"If either type is used as the first argument of the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method, it is released.","pos":[12222,12349],"source":" If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released."},{"content":"In the case of a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.","pos":[12350,12493],"source":" In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex."},{"content":"As noted previously, semaphores do not have thread affinity.","pos":[12494,12554]},{"pos":[12565,12572],"content":"Barrier","linkify":"Barrier","nodes":[{"content":"Barrier","pos":[0,7]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Barrier&gt;</ph> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.","pos":[12576,12760],"source":"The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete."},{"content":"A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.","pos":[12761,12896]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Barrier<ept id=\"p1\">](../../../docs/standard/threading/barrier.md)</ept>.","pos":[12897,12978],"source":" For more information, see [Barrier](../../../docs/standard/threading/barrier.md)."},{"pos":[12985,13004],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[13065,13098],"content":"Lightweight Synchronization Types","linkify":"Lightweight Synchronization Types","nodes":[{"content":"Lightweight Synchronization Types","pos":[0,33]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.","pos":[13102,13349],"source":"Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible."},{"content":"In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.","pos":[13350,13511]},{"content":"The lightweight types cannot be used in scenarios that require cross-process communication.","pos":[13512,13603]},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreSlim?displayProperty=fullName&gt;</ph> is a lightweight version of <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore?displayProperty=fullName&gt;</ph>.","pos":[13613,13763],"source":"<xref:System.Threading.SemaphoreSlim?displayProperty=fullName> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=fullName>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEventSlim?displayProperty=fullName&gt;</ph> is a lightweight version of <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent?displayProperty=fullName&gt;</ph>.","pos":[13773,13937],"source":"<xref:System.Threading.ManualResetEventSlim?displayProperty=fullName> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=fullName>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.CountdownEvent?displayProperty=fullName&gt;</ph> represents an event that becomes signaled when its count is zero.","pos":[13947,14076],"source":"<xref:System.Threading.CountdownEvent?displayProperty=fullName> represents an event that becomes signaled when its count is zero."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Barrier?displayProperty=fullName&gt;</ph> enables multiple threads to synchronize with one another without requiring control by a master thread.","pos":[14086,14245],"source":"<xref:System.Threading.Barrier?displayProperty=fullName> enables multiple threads to synchronize with one another without requiring control by a master thread."},{"content":"A barrier prevents each thread from continuing until all threads have reached a specified point.","pos":[14246,14342]},{"pos":[14349,14368],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[14404,14412],"content":"SpinWait","linkify":"SpinWait","nodes":[{"content":"SpinWait","pos":[0,8]}]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]</ph>, you can use the <ph id=\"ph2\">&lt;xref:System.Threading.SpinWait?displayProperty=fullName&gt;</ph> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.","pos":[14416,14815],"source":"Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=fullName> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread."},{"content":"By using <ph id=\"ph1\">&lt;xref:System.Threading.SpinWait&gt;</ph>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.","pos":[14816,15030],"source":" By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time."},{"pos":[15037,15056],"content":"<bpt id=\"p1\">[</bpt>Back to top<ept id=\"p1\">](#top)</ept>","source":"[Back to top](#top)"},{"pos":[15106,15128],"content":"Interlocked Operations","linkify":"Interlocked Operations","nodes":[{"content":"Interlocked Operations","pos":[0,22]}]},{"content":"Interlocked operations are simple atomic operations performed on a memory location by static methods of the <ph id=\"ph1\">&lt;xref:System.Threading.Interlocked&gt;</ph> class.","pos":[15132,15282],"source":"Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class."},{"content":"Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.","pos":[15283,15466]},{"pos":[15474,15664],"content":"[!NOTE]\n The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.","leadings":["","> "],"nodes":[{"content":"The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.","pos":[9,188]}]},{"content":"Although none of these operations are locks or signals, they can be used to construct locks and signals.","pos":[15671,15775]},{"content":"Because they are native to the Windows operating system, interlocked operations are extremely fast.","pos":[15776,15875]},{"content":"Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.","pos":[15882,16018]},{"content":"However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.","pos":[16019,16134]},{"pos":[16141,16257],"content":"For a conceptual overview, see <bpt id=\"p1\">[</bpt>Interlocked Operations<ept id=\"p1\">](../../../docs/standard/threading/interlocked-operations.md)</ept>.","source":"For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md)."},{"pos":[16266,16274],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Synchronizing Data for Multithreading<ept id=\"p1\">](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)</ept><ph id=\"ph1\"> </ph>","pos":[16278,16393],"source":"[Synchronizing Data for Multithreading](../../../docs/standard/threading/synchronizing-data-for-multithreading.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Monitors<ept id=\"p1\">](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)</ept><ph id=\"ph1\"> </ph>","pos":[16396,16480],"source":" [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db) "},{"content":"<bpt id=\"p1\"> [</bpt>Mutexes<ept id=\"p1\">](../../../docs/standard/threading/mutexes.md)</ept><ph id=\"ph1\"> </ph>","pos":[16483,16539],"source":" [Mutexes](../../../docs/standard/threading/mutexes.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Semaphore and SemaphoreSlim<ept id=\"p1\">](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)</ept><ph id=\"ph1\"> </ph>","pos":[16542,16638],"source":" [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md) "},{"content":"<bpt id=\"p1\"> [</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id=\"p1\">](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept><ph id=\"ph1\"> </ph>","pos":[16641,16810],"source":" [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Wait Handles<ept id=\"p1\">](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)</ept><ph id=\"ph1\"> </ph>","pos":[16813,16901],"source":" [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489) "},{"content":"<bpt id=\"p1\"> [</bpt>Interlocked Operations<ept id=\"p1\">](../../../docs/standard/threading/interlocked-operations.md)</ept><ph id=\"ph1\"> </ph>","pos":[16904,16990],"source":" [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Reader-Writer Locks<ept id=\"p1\">](../../../docs/standard/threading/reader-writer-locks.md)</ept><ph id=\"ph1\"> </ph>","pos":[16993,17073],"source":" [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Barrier<ept id=\"p1\">](../../../docs/standard/threading/barrier.md)</ept><ph id=\"ph1\"> </ph>","pos":[17076,17132],"source":" [Barrier](../../../docs/standard/threading/barrier.md) "},{"content":"<bpt id=\"p1\"> [</bpt>SpinWait<ept id=\"p1\">](../../../docs/standard/threading/spinwait.md)</ept><ph id=\"ph1\"> </ph>","pos":[17135,17193],"source":" [SpinWait](../../../docs/standard/threading/spinwait.md) "},{"content":"<bpt id=\"p1\"> [</bpt>SpinLock<ept id=\"p1\">](../../../docs/standard/threading/spinlock.md)</ept>","pos":[17196,17253],"source":" [SpinLock](../../../docs/standard/threading/spinlock.md)"}]}