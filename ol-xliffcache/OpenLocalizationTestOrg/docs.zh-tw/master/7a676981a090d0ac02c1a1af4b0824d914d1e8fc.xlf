<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="whats-new.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7a676981a090d0ac02c1a1af4b0824d914d1e8fc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\getting-started\whats-new.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7833c5e1cb9324599ec11f4a4506256fde1f5d1d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">51dc74f97f7ba984cc28ee5ec49bbab04b5d75c5</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's new for Visual Basic</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>What's new for Visual Basic</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Current version</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.8 / Visual Studio 2017 Version 15.8</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 15.8<ept id="p1">](#visual-basic-158)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Previous versions</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.5 / Visual Studio 2017 Version 15.5</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 15.5<ept id="p1">](#visual-basic-155)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.3 / Visual Studio 2017 Version 15.3</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 15.3<ept id="p1">](#visual-basic-153)</ept></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Visual Basic 2017 / Visual Studio 2017</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 2017<ept id="p1">](#visual-basic-2017)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio 2015</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For new features, see <bpt id="p1">[</bpt>Visual Basic 14<ept id="p1">](#visual-basic-14)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio 2013</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Technology previews of the .NET Compiler Platform (“Roslyn”)</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio 2012</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Async`</ph> and <ph id="ph2">`await`</ph> keywords, iterators, caller info attributes</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Visual Basic, Visual Studio 2010</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio 2008</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local <ph id="ph1">`var`</ph> type inference, lambda expressions, <ph id="ph2">`if`</ph> operator, partial methods, nullable value types</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio 2005</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`My`</ph> type and helper types (access to app, computer, files system, network)</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2003</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Bit-shift operators, loop variable declaration</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Visual Basic / Visual Studio .NET 2002</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The first release of Visual Basic .NET</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.8</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Optimized floating-point to integer conversion<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In previous versions of Visual Basic, conversion of <bpt id="p1">[</bpt>Double<ept id="p1">](../language-reference/data-types/double-data-type.md)</ept> and <bpt id="p2">[</bpt>Single<ept id="p2">](../language-reference/data-types/single-data-type.md)</ept> values to integers offered relatively poor performance.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the <bpt id="p1">[</bpt>intrinsic Visual Basic integer conversion functions<ept id="p1">](../language-reference/functions/type-conversion-functions.md)</ept> (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when <bpt id="p2">[</bpt>Option Strict<ept id="p2">](~/docs/visual-basic/language-reference/statements/option-strict-statement.md)</ept> is set to <ph id="ph1">`Off`</ph>:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following example illustrates some simple method calls that are affected by this optimization:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Note that this truncates rather than rounds floating-point values.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.5</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Non-trailing named arguments<ept id="p1">](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)</ept></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This is particularly useful when named arguments are used to make code more readable.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For example, the following method call has two positional arguments between a named argument.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The named argument makes it clear that the value 19 represents an age.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`Private Protected`</ph> member access modifier<ept id="p1">](../language-reference/modifiers/private-protected.md)</ept></source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Because structures cannot be inherited, <ph id="ph1">`Private Protected`</ph> can only be applied to the members of a class.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Leading hex/binary/octal separator<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Visual Basic 2017 added support for the underscore character (<ph id="ph1">`_`</ph>) as a digit separator.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (<ph id="ph1">\*</ph>.vbproj) file:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Visual Basic 15.3</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>Named tuple inference<ept id="p2">**</ept><ept id="p1">](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The following example uses inference to create a tuple with three named elements, <ph id="ph1">`state`</ph>, <ph id="ph2">`stateName`</ph>, and <ph id="ph3">`capital`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Additional compiler switches<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The Visual Basic command-line compiler now supports the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>-refout<ept id="p2">**</ept><ept id="p1">](../reference/command-line-compiler/refout-compiler-option.md)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>-refonly<ept id="p4">**</ept><ept id="p3">](../reference/command-line-compiler/refonly-compiler-option.md)</ept> compiler options to control the output of reference assemblies.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>-refout<ept id="p1">**</ept> defines the output directory of the reference assembly, and <bpt id="p2">**</bpt>-refonly<ept id="p2">**</ept> specifies that only a reference assembly is to be output by compilation.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Visual Basic 2017</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>Tuples<ept id="p2">**</ept><ept id="p1">](../programming-guide/language-features/data-types/tuples.md)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Ordinarily, to return multiple values from a method, you have to do one of the following:</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Define a custom type (a <ph id="ph1">`Class`</ph> or a <ph id="ph2">`Structure`</ph>).</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is a heavyweight solution.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Define one or more <ph id="ph1">`ByRef`</ph> parameters, in addition to returning a value from the method.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example wraps a call to the <ph id="ph1">&lt;xref:System.Int32.TryParse%2A&gt;</ph> method and returns a tuple.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>You can then call the method and handle the returned tuple with code like the following.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Binary literals and digit separators<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You can define a binary literal by using the prefix <ph id="ph1">`&amp;B`</ph> or <ph id="ph2">`&amp;b`</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In addition, you can use the underscore character, <ph id="ph1">`_`</ph>, as a digit separator to enhance readability.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The following example uses both features to assign a <ph id="ph1">`Byte`</ph> value and to display it as a decimal, hexadecimal, and binary number.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For more information, see the "Literal assignments" section of the <bpt id="p1">[</bpt>Byte<ept id="p1">](../language-reference/data-types/byte-data-type.md#literal-assignments)</ept>, <bpt id="p2">[</bpt>Integer<ept id="p2">](../language-reference/data-types/integer-data-type.md#literal-assignments)</ept>, <bpt id="p3">[</bpt>Long<ept id="p3">](../language-reference/data-types/long-data-type.md#literal-assignments)</ept>, <bpt id="p4">[</bpt>Short<ept id="p4">](../language-reference/data-types/short-data-type.md#literal-assignments)</ept>, <bpt id="p5">[</bpt>SByte<ept id="p5">](../language-reference/data-types/sbyte-data-type.md#literal-assignments)</ept>, <bpt id="p6">[</bpt>UInteger<ept id="p6">](../language-reference/data-types/uinteger-data-type.md#literal-assignments)</ept>, <bpt id="p7">[</bpt>ULong<ept id="p7">](../language-reference/data-types/ulong-data-type.md#literal-assignments)</ept>, and <bpt id="p8">[</bpt>UShort<ept id="p8">](../language-reference/data-types/ushort-data-type.md#literal-assignments)</ept> data types.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>Support for C# reference return values<ept id="p2">**</ept><ept id="p1">](../programming-guide/language-features/procedures/ref-return-values.md)</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Starting with C# 7.0, C# supports reference return values.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>That is, when the calling method receives a value returned by reference, it can change the value of the reference.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, the following <ph id="ph1">`Sentence`</ph> class written in C# includes a <ph id="ph2">`FindNext`</ph> method that finds the next word in a sentence that begins with a specified substring.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The string is returned as a reference return value, and a <ph id="ph1">`Boolean`</ph> variable passed by reference to the method indicates whether the search was successful.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the <ph id="ph1">`Sentence`</ph> class.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>In its simplest form, you can modify the word found in the sentence by using code like the following.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>A problem with this code, though, is that if a match is not found, the method returns the first word.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Since the example does not examine the value of the <ph id="ph1">`Boolean`</ph> argument to determine whether a match is found, it modifies the first word if there is no match.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The following example corrects this by replacing the first word with itself if there is no match.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A better solution is to use a helper method to which the reference return value is passed by reference.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The helper method can then modify the argument passed to it by reference.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The following example does that.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Reference Return Values<ept id="p1">](../programming-guide/language-features/procedures/ref-return-values.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Visual Basic 14</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Nameof<ept id="p1">](../../csharp/language-reference/keywords/nameof.md)</ept></source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This allows your code to remain correct when refactoring.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>String interpolation<ept id="p1">](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)</ept></source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can use string interpolation expressions to construct strings.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>An interpolated string expression looks like a template string that contains expressions.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>An interpolated string is easier to understand with respect to arguments than <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](../../standard/base-types/composite-format.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Null-conditional member access and indexing<ept id="p1">](../language-reference/operators/null-conditional-operators.md)</ept></source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can test for null in a very light syntactic way before performing a member access (<ph id="ph1">`?.`</ph>) or index (<ph id="ph2">`?[]`</ph>) operation.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>These operators help you write less code to handle null checks, especially for descending into data structures.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If the left operand or object reference is null, the operations returns null.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multi-line string literals<ept id="p1">](../../visual-basic/programming-guide/language-features/strings/string-basics.md)</ept></source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>String literals can contain newline sequences.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You no longer need the old work around of using <ph id="ph1">`&lt;xml&gt;&lt;![CDATA[...text with newlines...]]&gt;&lt;/xml&gt;.Value`</ph></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Comments<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Smarter fully-qualified name resolution<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Given code such as <ph id="ph1">`Threading.Thread.Sleep(1000)`</ph>, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Visual Basic now considers both possible namespaces together.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Year-first date literals<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>You can have date literals in yyyy-mm-dd format, <ph id="ph1">`#2015-03-17 16:10 PM#`</ph>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Readonly interface properties<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can implement readonly interface properties using a readwrite property.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>TypeOf <ph id="ph1">\&lt;</ph>expr&gt; IsNot <ph id="ph2">\&lt;</ph>type&gt;<ept id="p1">](../../visual-basic/language-reference/operators/typeof-operator.md)</ept></source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For more readability of your code, you can now use <ph id="ph1">`TypeOf`</ph> with <ph id="ph2">`IsNot`</ph>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>#Disable Warning <ph id="ph1">\&lt;</ph>ID&gt; and #Enable Warning <ph id="ph2">\&lt;</ph>ID&gt;<ept id="p1">](../../visual-basic/language-reference/directives/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>You can disable and enable specific warnings for regions within a source file.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>XML doc comment improvements<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of <ph id="ph1">`crefs`</ph> (generics, operators, etc.), colorizing, and refactoring.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Partial module and interface definitions<ept id="p1">](../../visual-basic/language-reference/modifiers/partial.md)</ept></source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>In addition to classes and structs, you can declare partial modules and interfaces.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>#Region directives inside method bodies<ept id="p1">](../../visual-basic/language-reference/directives/region-directive.md)</ept></source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Overrides definitions are implicitly overloads<ept id="p1">](../../visual-basic/language-reference/modifiers/overrides.md)</ept></source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If you add the <ph id="ph1">`Overrides`</ph> modifier to a definition, the compiler implicitly adds <ph id="ph2">`Overloads`</ph> so that you can type less code in common cases.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CObj allowed in attributes arguments<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Declaring and consuming ambiguous methods from different interfaces<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Previously the following code yielded errors that prevented you from declaring <ph id="ph1">`IMock`</ph> or from calling <ph id="ph2">`GetDetails`</ph> (if these had been declared in C#):</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Now the compiler will use normal overload resolution rules to choose the most appropriate <ph id="ph1">`GetDetails`</ph> to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>What's New in Visual Studio 2017<ept id="p1">](/visualstudio/ide/whats-new-in-visual-studio)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>