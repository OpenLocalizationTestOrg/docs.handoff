<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="default-xaml-schema-context-and-wpf-xaml-schema-context.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1312541321e74668e6527c6c54e712342fbb3a17</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\xaml-services\default-xaml-schema-context-and-wpf-xaml-schema-context.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">163f4d137e67b145c0a3fa970556a69c9ff8245d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">19453ce67f0f852737c6cb09151967def9f656cb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Default XAML Schema Context and WPF XAML Schema Context</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Default XAML Schema Context and WPF XAML Schema Context</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic describes the features of the .NET Framework XAML Services and the associated default XAML schema context, which is based on the CLR type system.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic also describes the XAML schema context that is used for WPF.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Default XAML Schema Context</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>.NET Framework XAML Services both implements and uses a default XAML schema context.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The default XAML schema context behavior is not always fully visible in the API of the <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <ph id="ph1">&lt;xref:System.Xaml.XamlMember&gt;</ph> or <ph id="ph2">&lt;xref:System.Xaml.XamlType&gt;</ph>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can create a <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph> that encapsulates the default behavior by calling the <ph id="ph2">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This explicitly creates the default XAML schema context.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph> input parameter.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The default XAML schema context relies on CLR reflection for its type mapping behavior.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This includes examining the defining CLR <ph id="ph1">&lt;xref:System.Type&gt;</ph>, and related <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The default XAML schema context does not require type system extension techniques such as the <ph id="ph1">`Invoker`</ph> pattern, because the necessary information is available from the CLR type system.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Also, <ph id="ph1">&lt;xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A&gt;</ph> can hint an assembly to load, for scenarios such as loading internal types.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>WPF XAML Schema Context</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The WPF XAML schema context implements the following behavior.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Lookup overrides:<ept id="p1">**</ept> WPF has a few content  models for XAML where there are XAML content properties that function without being <ph id="ph1">&lt;xref:System.Windows.Markup.ContentPropertyAttribute&gt;</ph> attributed.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Xaml.XamlType.LookupContentProperty%2A&gt;</ph> overrides for WPF implement this behavior.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Deferral for WPF expressions:<ept id="p1">**</ept> WPF features several expression classes that defer a value until a runtime context is available.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Also, template expansion is a runtime behavior that relies on deferral techniques.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Type system lookup optimizations:<ept id="p1">**</ept> WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Also, WPF itself is spread across several assemblies.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>WPF optimizes its type lookup using lookup tables and other techniques.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>XamlType and XamlMember extension:<ept id="p1">**</ept> WPF extends property concepts with dependency properties, and event concepts with routed events.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To give these concepts greater visibility for XAML processing operations, WPF extends <ph id="ph1">&lt;xref:System.Xaml.XamlType&gt;</ph> and <ph id="ph2">&lt;xref:System.Xaml.XamlMember&gt;</ph>, and adds internal properties that report dependency property and routed event characteristics.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Accessing the WPF XAML Schema Context</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you are using XAML techniques that are based on the WPF <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType&gt;</ph>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can then use this value as initialization for other API that use a <ph id="ph1">&lt;xref:System.Xaml.XamlSchemaContext&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, you could call <ph id="ph1">&lt;xref:System.Xaml.XamlXmlReader.%23ctor%2A&gt;</ph> for initialization and pass the WPF XAML schema context.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Or you could use the WPF XAML schema context for XAML type system operations.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This might include construction initialization of a <ph id="ph1">&lt;xref:System.Xaml.XamlType&gt;</ph> or <ph id="ph2">&lt;xref:System.Xaml.XamlMember&gt;</ph>, or calling <ph id="ph3">&lt;xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For example, WPF templates for controls are not yet applied.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>XAML and Assembly Loading</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Assembly loading for XAML and .NET Framework XAML Services integrates with the CLR-defined concept of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> and other factors.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by <ph id="ph1">`XamlBuildTask`</ph>, or is BAML generated by WPF's <ph id="ph2">`PresentationBuildTask`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The XAML schema context for WPF integrates with the WPF application model, which in turn uses <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> as well as other factors that are WPF implementation details.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>XAML reader input (loose XAML)</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The XAML schema context iterates through the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If a match is found, that assembly is used for resolution.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Otherwise, one of the following techniques based on CLR <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> API are used to load an assembly:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If the name is qualified in the mapping, call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph> on the qualified name.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If the previous step fails, use the short name (and public key token if present) to call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the name is unqualified in the mapping, call <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>XamlBuildTask</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`XamlBuildTask`</ph> is used for Windows Communication Foundation (WCF) and Windows Workflow Foundation.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Note that assembly references through <ph id="ph1">`XamlBuildTask`</ph> are always fully qualified.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph> on the qualified name.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If the previous step fails, use the short name (and public key token if present) to call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>BAML (PresentationBuildTask)</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Assembly load for initial markup:</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The reference to the assembly to load the markup from is always unqualified.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The WPF XAML schema context iterates through the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If a match is found, that assembly is used for resolution.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If the previous step fails, use the short name (and public key token if present) to call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Assembly references by BAML types:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The WPF XAML schema context iterates through the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If a match is found, that assembly is used for resolution.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Otherwise, one of the following techniques is used to load an assembly:</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph> on the qualified name.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Use short name + public key token to call <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Understanding XAML Node Stream Structures and Concepts<ept id="p1">](understanding-xaml-node-stream-structures-and-concepts.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>