{"content":"---\ntitle: \"callbackOnCollectedDelegate MDA\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"cpp\"\nhelpviewer_keywords: \n  - \"MDAs (managed debugging assistants), garbage collection\"\n  - \"managed debugging assistants (MDAs), callback on collected delegates\"\n  - \"MDAs (managed debugging assistants), callback on collected delegates\"\n  - \"callback on delegate after garbage collection\"\n  - \"callbackOnCollectedDelegate MDA\"\n  - \"managed debugging assistants (MDAs), garbage collection\"\n  - \"call back collected delegates\"\n  - \"garbage collection, run-time errors\"\n  - \"delegates [.NET Framework], garbage collection\"\nms.assetid: 398b0ce0-5cc9-4518-978d-b8263aa21e5b\nauthor: \"mairaw\"\nms.author: \"mairaw\"\n---\n# callbackOnCollectedDelegate MDA\nThe `callbackOnCollectedDelegate` managed debugging assistant (MDA) is activated if a delegate is marshaled from managed to unmanaged code as a function pointer and a callback is placed on that function pointer after the delegate has been garbage collected.  \n  \n## Symptoms  \n Access violations occur when attempting to call into managed code through function pointers that were obtained from managed delegates. These failures, while not common language runtime (CLR) bugs, may appear to be so because the access violation occurs in the CLR code.  \n  \n The failure is not consistent; sometimes the call on the function pointer succeeds and sometimes it fails. The failure might occur only under heavy load or on a random number of attempts.  \n  \n## Cause  \n The delegate from which the function pointer was created and exposed to unmanaged code was garbage collected. When the unmanaged component tries to call on the function pointer, it generates an access violation.  \n  \n The failure appears random because it depends on when garbage collection occurs. If a delegate is eligible for collection, the garbage collection can occur after the callback and the call succeeds. At other times, the garbage collection occurs before the callback, the callback generates an access violation, and the program stops.  \n  \n The probability of the failure depends on the time between marshaling the delegate and the callback on the function pointer as well as the frequency of garbage collections. The failure is sporadic if the time between marshaling the delegate and the ensuing callback is short. This is usually the case if the unmanaged method receiving the function pointer does not save the function pointer for later use but instead calls back on the function pointer immediately to complete its operation before returning. Similarly, more garbage collections occur when a system is under heavy load, which makes it more likely that a garbage collection will occur before the callback.  \n  \n## Resolution  \n Once a delegate has been marshaled out as an unmanaged function pointer, the garbage collector cannot track its lifetime. Instead, your code must keep a reference to the delegate for the lifetime of the unmanaged function pointer. But before you can do that, you first must identify which delegate was collected. When the MDA is activated, it provides the type name of the delegate. Use this name to search your code for platform invoke or COM signatures that pass that delegate out to unmanaged code. The offending delegate is passed out through one of these call sites. You can also enable the `gcUnmanagedToManaged` MDA to force a garbage collection before every callback into the runtime. This will remove the uncertainty introduced by the garbage collection by ensuring that a garbage collection always occurs before the callback. Once you know what delegate was collected, change your code to keep a reference to that delegate on the managed side for the lifetime of the marshaled unmanaged function pointer.  \n  \n## Effect on the Runtime  \n When delegates are marshaled as function pointers, the runtime allocates a thunk that does the transition from unmanaged to managed. This thunk is what the unmanaged code actually calls before the managed delegate is finally invoked. Without the `callbackOnCollectedDelegate` MDA enabled, the unmanaged marshaling code is deleted when the delegate is collected. With the `callbackOnCollectedDelegate` MDA enabled, the unmanaged marshaling code is not immediately deleted when the delegate is collected. Instead, the last 1,000 instances are kept alive by default and changed to activate the MDA when called. The thunk is eventually deleted after 1,001 more marshaled delegates are collected.  \n  \n## Output  \n The MDA reports the type name of the delegate that was collected before a callback was attempted on its unmanaged function pointer.  \n  \n## Configuration  \n The following example shows the application configuration options. It sets the number of thunks the MDA keeps alive to 1,500. The default `listSize` value is 1,000, the minimum is 50, and the maximum is 2,000.  \n  \n```xml  \n<mdaConfig>  \n  <assistants>  \n    <callbackOnCollectedDelegate listSize=\"1500\" />  \n  </assistants>  \n</mdaConfig>  \n```  \n  \n## Example  \n The following example demonstrates a situation that can activate this MDA:  \n  \n```cpp\n// Library.cpp : Defines the unmanaged entry point for the DLL application.  \n#include \"windows.h\"  \n#include \"stdio.h\"  \n  \nvoid (__stdcall *g_pfTarget)();  \n  \nvoid __stdcall Initialize(void __stdcall pfTarget())  \n{  \n    g_pfTarget = pfTarget;  \n}  \n  \nvoid __stdcall Callback()  \n{  \n    g_pfTarget();  \n}\n```\n\n```csharp\n// C# Client  \nusing System;  \nusing System.Runtime.InteropServices;  \n  \npublic class Entry  \n{  \n    public delegate void DCallback();  \n  \n    public static void Main()  \n    {  \n        new Entry();  \n        Initialize(Target);  \n        GC.Collect();  \n        GC.WaitForPendingFinalizers();  \n        Callback();  \n    }  \n  \n    public static void Target()  \n    {          \n    }  \n  \n    [DllImport(\"Library\", CallingConvention = CallingConvention.StdCall)]  \n    public static extern void Initialize(DCallback pfDelegate);  \n  \n    [DllImport (\"Library\", CallingConvention = CallingConvention.StdCall)]  \n    public static extern void Callback();  \n  \n    ~Entry() { Console.Error.WriteLine(\"Entry Collected\"); }  \n}  \n```  \n  \n## See also\n\n- <xref:System.Runtime.InteropServices.MarshalAsAttribute>\n- [Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)\n- [Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)\n- [gcUnmanagedToManaged](../../../docs/framework/debug-trace-profile/gcunmanagedtomanaged-mda.md)\n","nodes":[{"pos":[4,691],"embed":true,"restype":"x-metadata","content":"title: \"callbackOnCollectedDelegate MDA\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"cpp\"\nhelpviewer_keywords: \n  - \"MDAs (managed debugging assistants), garbage collection\"\n  - \"managed debugging assistants (MDAs), callback on collected delegates\"\n  - \"MDAs (managed debugging assistants), callback on collected delegates\"\n  - \"callback on delegate after garbage collection\"\n  - \"callbackOnCollectedDelegate MDA\"\n  - \"managed debugging assistants (MDAs), garbage collection\"\n  - \"call back collected delegates\"\n  - \"garbage collection, run-time errors\"\n  - \"delegates [.NET Framework], garbage collection\"\nms.assetid: 398b0ce0-5cc9-4518-978d-b8263aa21e5b\nauthor: \"mairaw\"\nms.author: \"mairaw\"","nodes":[{"content":"callbackOnCollectedDelegate MDA","nodes":[{"pos":[0,31],"content":"callbackOnCollectedDelegate MDA","nodes":[{"content":"callbackOnCollectedDelegate MDA","pos":[0,31]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[698,729],"content":"callbackOnCollectedDelegate MDA","linkify":"callbackOnCollectedDelegate MDA","nodes":[{"content":"callbackOnCollectedDelegate MDA","pos":[0,31]}]},{"pos":[730,987],"content":"The <ph id=\"ph1\">`callbackOnCollectedDelegate`</ph> managed debugging assistant (MDA) is activated if a delegate is marshaled from managed to unmanaged code as a function pointer and a callback is placed on that function pointer after the delegate has been garbage collected.","source":"The `callbackOnCollectedDelegate` managed debugging assistant (MDA) is activated if a delegate is marshaled from managed to unmanaged code as a function pointer and a callback is placed on that function pointer after the delegate has been garbage collected."},{"pos":[996,1004],"content":"Symptoms","linkify":"Symptoms","nodes":[{"content":"Symptoms","pos":[0,8]}]},{"content":"Access violations occur when attempting to call into managed code through function pointers that were obtained from managed delegates.","pos":[1008,1142]},{"content":"These failures, while not common language runtime (CLR) bugs, may appear to be so because the access violation occurs in the CLR code.","pos":[1143,1277]},{"content":"The failure is not consistent; sometimes the call on the function pointer succeeds and sometimes it fails.","pos":[1284,1390]},{"content":"The failure might occur only under heavy load or on a random number of attempts.","pos":[1391,1471]},{"pos":[1480,1485],"content":"Cause","linkify":"Cause","nodes":[{"content":"Cause","pos":[0,5]}]},{"content":"The delegate from which the function pointer was created and exposed to unmanaged code was garbage collected.","pos":[1489,1598]},{"content":"When the unmanaged component tries to call on the function pointer, it generates an access violation.","pos":[1599,1700]},{"content":"The failure appears random because it depends on when garbage collection occurs.","pos":[1707,1787]},{"content":"If a delegate is eligible for collection, the garbage collection can occur after the callback and the call succeeds.","pos":[1788,1904]},{"content":"At other times, the garbage collection occurs before the callback, the callback generates an access violation, and the program stops.","pos":[1905,2038]},{"content":"The probability of the failure depends on the time between marshaling the delegate and the callback on the function pointer as well as the frequency of garbage collections.","pos":[2045,2217]},{"content":"The failure is sporadic if the time between marshaling the delegate and the ensuing callback is short.","pos":[2218,2320]},{"content":"This is usually the case if the unmanaged method receiving the function pointer does not save the function pointer for later use but instead calls back on the function pointer immediately to complete its operation before returning.","pos":[2321,2552]},{"content":"Similarly, more garbage collections occur when a system is under heavy load, which makes it more likely that a garbage collection will occur before the callback.","pos":[2553,2714]},{"pos":[2723,2733],"content":"Resolution","linkify":"Resolution","nodes":[{"content":"Resolution","pos":[0,10]}]},{"content":"Once a delegate has been marshaled out as an unmanaged function pointer, the garbage collector cannot track its lifetime.","pos":[2737,2858]},{"content":"Instead, your code must keep a reference to the delegate for the lifetime of the unmanaged function pointer.","pos":[2859,2967]},{"content":"But before you can do that, you first must identify which delegate was collected.","pos":[2968,3049]},{"content":"When the MDA is activated, it provides the type name of the delegate.","pos":[3050,3119]},{"content":"Use this name to search your code for platform invoke or COM signatures that pass that delegate out to unmanaged code.","pos":[3120,3238]},{"content":"The offending delegate is passed out through one of these call sites.","pos":[3239,3308]},{"content":"You can also enable the <ph id=\"ph1\">`gcUnmanagedToManaged`</ph> MDA to force a garbage collection before every callback into the runtime.","pos":[3309,3429],"source":" You can also enable the `gcUnmanagedToManaged` MDA to force a garbage collection before every callback into the runtime."},{"content":"This will remove the uncertainty introduced by the garbage collection by ensuring that a garbage collection always occurs before the callback.","pos":[3430,3572]},{"content":"Once you know what delegate was collected, change your code to keep a reference to that delegate on the managed side for the lifetime of the marshaled unmanaged function pointer.","pos":[3573,3751]},{"pos":[3760,3781],"content":"Effect on the Runtime","linkify":"Effect on the Runtime","nodes":[{"content":"Effect on the Runtime","pos":[0,21]}]},{"content":"When delegates are marshaled as function pointers, the runtime allocates a thunk that does the transition from unmanaged to managed.","pos":[3785,3917]},{"content":"This thunk is what the unmanaged code actually calls before the managed delegate is finally invoked.","pos":[3918,4018]},{"content":"Without the <ph id=\"ph1\">`callbackOnCollectedDelegate`</ph> MDA enabled, the unmanaged marshaling code is deleted when the delegate is collected.","pos":[4019,4146],"source":" Without the `callbackOnCollectedDelegate` MDA enabled, the unmanaged marshaling code is deleted when the delegate is collected."},{"content":"With the <ph id=\"ph1\">`callbackOnCollectedDelegate`</ph> MDA enabled, the unmanaged marshaling code is not immediately deleted when the delegate is collected.","pos":[4147,4287],"source":" With the `callbackOnCollectedDelegate` MDA enabled, the unmanaged marshaling code is not immediately deleted when the delegate is collected."},{"content":"Instead, the last 1,000 instances are kept alive by default and changed to activate the MDA when called.","pos":[4288,4392]},{"content":"The thunk is eventually deleted after 1,001 more marshaled delegates are collected.","pos":[4393,4476]},{"pos":[4485,4491],"content":"Output","linkify":"Output","nodes":[{"content":"Output","pos":[0,6]}]},{"content":"The MDA reports the type name of the delegate that was collected before a callback was attempted on its unmanaged function pointer.","pos":[4495,4626]},{"pos":[4635,4648],"content":"Configuration","linkify":"Configuration","nodes":[{"content":"Configuration","pos":[0,13]}]},{"content":"The following example shows the application configuration options.","pos":[4652,4718]},{"content":"It sets the number of thunks the MDA keeps alive to 1,500.","pos":[4719,4777]},{"content":"The default <ph id=\"ph1\">`listSize`</ph> value is 1,000, the minimum is 50, and the maximum is 2,000.","pos":[4778,4861],"source":" The default `listSize` value is 1,000, the minimum is 50, and the maximum is 2,000."},{"pos":[5006,5013],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example demonstrates a situation that can activate this MDA:","pos":[5017,5091]},{"pos":[6172,6180],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6243,6396],"content":"<bpt id=\"p1\">[</bpt>Diagnosing Errors with Managed Debugging Assistants<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)</ept>","source":"[Diagnosing Errors with Managed Debugging Assistants](../../../docs/framework/debug-trace-profile/diagnosing-errors-with-managed-debugging-assistants.md)"},{"pos":[6399,6474],"content":"<bpt id=\"p1\">[</bpt>Interop Marshaling<ept id=\"p1\">](../../../docs/framework/interop/interop-marshaling.md)</ept>","source":"[Interop Marshaling](../../../docs/framework/interop/interop-marshaling.md)"},{"pos":[6477,6572],"content":"<bpt id=\"p1\">[</bpt>gcUnmanagedToManaged<ept id=\"p1\">](../../../docs/framework/debug-trace-profile/gcunmanagedtomanaged-mda.md)</ept>","source":"[gcUnmanagedToManaged](../../../docs/framework/debug-trace-profile/gcunmanagedtomanaged-mda.md)"}]}