<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="using-message-contracts.md" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-3be5d15" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29621f14deb9753c3f4ea8669d1e2bfbdbbcc9aa</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\using-message-contracts.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56bcbc8e3fbffbc2fb9ee42f2414f88dbf696a8a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">235f9b7547da04f6e0554f0d7c2c70301a1290fb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Using Message Contracts | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Using Message Contracts</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Typically when building <ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> applications, developers pay close attention to the data structures and serialization issues and do not need to concern themselves with the structure of the messages in which the data is carried.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For these applications, creating data contracts for the parameters or return values is straightforward.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>(<ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Specifying Data Transfer in Service Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>However, sometimes complete control over the structure of a SOAP message is just as important as control over its contents.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This is especially true when interoperability is important or to specifically control security issues at the level of the message or message part.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>In these cases, you can create a <bpt id="p1">*</bpt>message contract<ept id="p1">*</ept> that enables you to specify the structure of the precise SOAP message required.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic discusses how to use the various message contract attributes to create a specific message contract for your operation.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Using Message Contracts in Operations</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> supports operations modeled on either the <bpt id="p1">*</bpt>remote procedure call (RPC) style<ept id="p1">*</ept> or the <bpt id="p2">*</bpt>messaging style<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In an RPC-style operation, you can use any serializable type, and you have access to the features that are available to local calls, such as multiple parameters and <ph id="ph1">`ref`</ph> and <ph id="ph2">`out`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In this style, the form of serialization chosen controls the structure of the data in the underlying messages, and the <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime creates the messages to support the operation.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This enables developers who are not familiar with SOAP and SOAP messages to quickly and easily create and use service applications.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The following code example shows a service operation modeled on the RPC style.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Normally, a data contract is sufficient to define the schema for the messages.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For instance, in the preceding example, it is sufficient for most applications if <ph id="ph1">`BankingTransaction`</ph> and <ph id="ph2">`BankingTransactionResponse`</ph> have data contracts to define the contents of the underlying SOAP messages.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crabout](../../../../includes/crabout-md.md)]</ph> data contracts, see <bpt id="p1">[</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, occasionally it is necessary to precisely control how the structure of the SOAP message transmitted over the wire.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The most common scenario for this is inserting custom SOAP headers.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Another common scenario is to define security properties for the message's headers and body, that is, to decide whether these elements are digitally signed and encrypted.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Finally, some third-party SOAP stacks require messages be in a specific format.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Messaging-style operations provide this control.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A messaging-style operation has at most one parameter and one return value where both types are message types; that is, they serialize directly into a specified SOAP message structure.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This may be any type marked with the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> or the <ph id="ph2">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The following code example shows an operation similar to the preceding RCP-style, but which uses the messaging style.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, if <ph id="ph1">`BankingTransaction`</ph> and <ph id="ph2">`BankingTransactionResponse`</ph> are both types that are message contracts, then the code in the following operations is valid.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, the following code is invalid.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>An exception is thrown for any operation that involves a message contract type and that does not follow one of the valid patterns.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Of course, operations that do not involve message contract types are not subject to these restrictions.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If a type has both a message contract and a data contract, only its message contract is considered when the type is used in an operation.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Defining Message Contracts</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To define a message contract for a type (that is, to define the mapping between the type and a SOAP envelope), apply the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> to the type.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then apply the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> to those members of the type you want to make into SOAP headers, and apply the <ph id="ph2">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> to those members you want to make into parts of the SOAP body of the message.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following code provides an example of using a message contract.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When using this type as an operation parameter, the following SOAP envelope is generated:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Notice that <ph id="ph1">`operation`</ph> and <ph id="ph2">`transactionDate`</ph> appear as SOAP headers and the SOAP body consists of a wrapper element <ph id="ph3">`BankingTransaction`</ph> containing <ph id="ph4">`sourceAccount`</ph>,<ph id="ph5">`targetAccount`</ph>, and <ph id="ph6">`amount`</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You can apply the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> to all fields, properties, and events, regardless of whether they are public, private, protected, or internal.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> allows you to specify the WrapperName and WrapperNamespace attributes which control the name of the wrapper element in the body of the SOAP message.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>By default the name of the message contract type is used for the wrapper and the namespace in which the message contract is defined  <ph id="ph1">`HYPERLINK "http://tempuri.org/" http://tempuri.org/`</ph> is used as the default namespace.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> attributes are ignored in message contracts.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.Serialization.KnownTypeAttribute&gt;</ph> is required, place it on the operation that is using the message contract in question.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Controlling Header and Body Part Names and Namespaces</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In the SOAP representation of a message contract, each header and body part maps to an XML element that has a name and a namespace.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>By default, the namespace is the same as the namespace of the service contract that the message is participating in, and the name is determined by the member name to which the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> or the <ph id="ph2">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> attributes are applied.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can change these defaults by manipulating the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.Name%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.Namespace%2A?displayProperty=fullName&gt;</ph> (on the parent class of the <ph id="ph3">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and <ph id="ph4">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> attributes).</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Consider the class in the following code example.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In this example, the <ph id="ph1">`IsAudited`</ph> header is in the namespace specified in the code, and the body part that represents the <ph id="ph2">`theData`</ph> member is represented by an XML element with the name <ph id="ph3">`transactionData`</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The following shows the XML generated for this message contract.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Controlling Whether the SOAP Body Parts Are Wrapped</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>By default, the SOAP body parts are serialized inside a wrapped element.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For example, the following code shows the <ph id="ph1">`HelloGreetingMessage`</ph> wrapper element generated from the name of the <ph id="ph2">&lt;xref:System.ServiceModel.MessageContractAttribute&gt;</ph> type in the message contract for the <ph id="ph3">`HelloGreetingMessage`</ph> message.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>To suppress the wrapper element, set the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>To control the name and the namespace of the wrapper element, use the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.MessageContractAttribute.WrapperNamespace%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Having more than one message body part in messages that are not wrapped is not compliant with WS-I Basic Profile 1.1 and is not recommended when designing new message contracts.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>However, it may be necessary to have more than one unwrapped message body part in certain specific interoperability scenarios.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If you are going to transmit more than one piece of data in a message body, it is recommended to use the default (wrapped) mode.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Having more than one message header in unwrapped messages is completely acceptable.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Using Custom Types Inside Message Contracts</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Each individual message header and message body part is serialized (turned into XML) using the chosen serialization engine for the service contract where the message is used.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The default serialization engine, the <ph id="ph1">`XmlFormatter`</ph>, can handle any type that has a data contract, either explicitly (by having the <ph id="ph2">&lt;xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=fullName&gt;</ph>) or implicitly (by being a primitive type, having the <ph id="ph3">&lt;xref:System.SerializableAttribute?displayProperty=fullName&gt;</ph>, and so on).</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In the preceding example, the <ph id="ph1">`Operation`</ph> and <ph id="ph2">`BankingTransactionData`</ph> types must have a data contract, and <ph id="ph3">`transactionDate`</ph> is serializable because <ph id="ph4">&lt;xref:System.DateTime&gt;</ph> is a primitive (and so has an implicit data contract).</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>However, it is possible to switch to a different serialization engine, the <ph id="ph1">`XmlSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If you make such a switch, you should ensure that all of the types used for message headers and body parts are serializable using the <ph id="ph1">`XmlSerializer`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Using Arrays Inside Message Contracts</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can use arrays of repeating elements in message contracts in two ways.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The first is to use a <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> or a <ph id="ph2">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> directly on the array.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In this case, the entire array is serialized as one element (that is, one header or one body part) with multiple child elements.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Consider the class in the following example.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This results in SOAP headers is similar to the following.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>An alternative to this is to use the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In this case, each array element is serialized independently and so that each array element has one header, similar to the following.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The default name for array entries is the name of the member to which the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> attributes is applied.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> attribute inherits from the <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It has the same set of features as the non-array attributes, for example, it is possible to set the order, name, and namespace for an array of headers in the same way you set it for a single header.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When you use the <ph id="ph1">`Order`</ph> property on an array, it applies to the entire array.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can apply the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> only to arrays, not collections.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Using Byte Arrays in Message Contracts</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Byte arrays, when used with the non-array attributes (<ph id="ph1">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>), are not treated as arrays but as a special primitive type represented as Base64-encoded data in the resulting XML.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>When you use byte arrays with the array attribute <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>, the results depend on the serializer in use.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>With the default serializer, the array is represented as an individual entry for each byte.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, when the <ph id="ph1">`XmlSerializer`</ph> is selected, (using the <ph id="ph2">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute&gt;</ph> on the service contract), byte arrays are treated as Base64 data regardless of whether the array or non-array attributes are used.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Signing and Encrypting Parts of the Message</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A message contract can indicate whether the headers and/or body of the message should be digitally signed and encrypted.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This is done by setting the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=fullName&gt;</ph> property on the <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and <ph id="ph3">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute&gt;</ph> attributes.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The property is an enumeration of the <ph id="ph1">&lt;xref:System.Net.Security.ProtectionLevel?displayProperty=fullName&gt;</ph> type and can be set to <ph id="ph2">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> (no encryption or signature), <ph id="ph3">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> (digital signature only), or <ph id="ph4">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> (both encryption and a digital signature).</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For these security features to work, you must properly configure the binding and behaviors.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If you use these security features without the proper configuration (for example, attempting to sign a message without supplying your credentials), an exception is thrown at validation time.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For message headers, the protection level is determined individually for each header.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For message body parts, the protection level can be thought of as the "minimum protection level."</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The body has only one protection level, regardless of the number of body parts.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The protection level of the body is determined by the highest <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A&gt;</ph> property setting of all the body parts.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>However, you should set the protection level of each body part to the actual minimum protection level required.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Consider the class in the following code example.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In this example, the <ph id="ph1">`recordID`</ph> header is not protected, <ph id="ph2">`patientName`</ph> is <ph id="ph3">`signed`</ph>, and <ph id="ph4">`SSN`</ph> is encrypted and signed.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>At least one body part, <ph id="ph1">`medicalHistory`</ph>, has <ph id="ph2">&lt;xref:System.Net.Security.ProtectionLevel&gt;</ph> applied, and thus the entire message body is encrypted and signed, even though the comments and diagnosis body parts specify lower protection levels.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>SOAP Action</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>SOAP and related Web services standards define a property called <ph id="ph1">`Action`</ph> that can be present for every SOAP message sent.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The operation's <ph id="ph1">&lt;xref:System.ServiceModel.OperationContractAttribute.Action%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A?displayProperty=fullName&gt;</ph> properties control the value of this property.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>SOAP Header Attributes</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The SOAP standard defines the following attributes that may exist on a header:</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Actor/Role`</ph> (<ph id="ph2">`Actor`</ph> in SOAP 1.1, <ph id="ph3">`Role`</ph> in SOAP 1.2)</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Actor`</ph> or <ph id="ph2">`Role`</ph> attribute specifies the Uniform Resource Identifier (URI) of the node for which a given header is intended.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MustUnderstand`</ph> attribute specifies whether the node processing the header must understand it.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Relay`</ph> attribute specifies whether the header is to be relayed to downstream nodes.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does not perform any processing of these attributes on incoming messages, except for the <ph id="ph2">`MustUnderstand`</ph> attribute, as specified in the "Message Contract Versioning" section later in this topic.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>However, it allows you to read and write these attributes as necessary, as in the following description.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>When sending a message, these attributes are not emitted by default.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>You can change this in two ways.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>First, you may statically set the attributes to any desired values by changing the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderAttribute.MustUnderstand%2A?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.ServiceModel.MessageHeaderAttribute.Relay%2A?displayProperty=fullName&gt;</ph> properties, as shown in the following code example.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>(Note that there is no <ph id="ph1">`Role`</ph> property; setting the <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderAttribute.Actor%2A&gt;</ph> property emits the <ph id="ph3">`Role`</ph> attribute if you are using SOAP 1.2).</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The second way to control these attributes is dynamically, through code.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>You can achieve this by wrapping the desired header type in the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> type (be sure not to confuse this type with the non-generic version) and by using the type together with the <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Then, you can use properties on the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> to set the SOAP attributes, as shown in the following code example.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>If you use both the dynamic and the static control mechanisms, the static settings are used as a default but can later be overridden by using the dynamic mechanism, as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Creating repeated headers with dynamic attribute control is allowed, as shown in the following code.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>On the receiving side, reading these SOAP attributes can only be done if the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> class is used for the header in the type.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Examine the <ph id="ph1">`Actor`</ph>, <ph id="ph2">`Relay`</ph>, or <ph id="ph3">`MustUnderstand`</ph> properties of a header of the <ph id="ph4">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> type to discover the attribute settings on the received message.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>When a message is received and then sent back, the SOAP attribute settings only go round-trip for headers of the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeader%601&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Order of SOAP Body Parts</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In some circumstances, you may need to control the order of the body parts.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The order of the body elements is alphabetical by default, but can be controlled by the <ph id="ph1">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This property has the same semantics as the <ph id="ph1">&lt;xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A?displayProperty=fullName&gt;</ph> property, except for the behavior in inheritance scenarios (in message contracts, base type body members are not sorted before the derived type body members).</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph><bpt id="p1">[</bpt>Data Member Order<ept id="p1">](../../../../docs/framework/wcf/feature-details/data-member-order.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In the following example, <ph id="ph1">`amount`</ph> would normally come first because it is first alphabetically.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A&gt;</ph> property puts it into the third position.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Message Contract Versioning</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Occasionally, you may need to change message contracts.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For example, a new version of your application may add an extra header to a message.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Then, when sending from the new version to the old, the system must deal with an extra header, as well as a missing header when going in the other direction.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following rules apply for versioning headers:</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> does not object to the missing headers—the corresponding members are left at their default values.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> also ignores unexpected extra headers.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is if the extra header has a <ph id="ph1">`MustUnderstand`</ph> attribute set to <ph id="ph2">`true`</ph> in the incoming SOAP message—in this case, an exception is thrown because a header that must be understood cannot be processed.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Message bodies have similar versioning rules—both missing and additional message body parts are ignored.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Inheritance Considerations</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>A message contract type can inherit from another type, as long as the base type also has a message contract.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>When creating or accessing a message using a message contract type that inherits from other message contract types, the following rules apply:</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>All of the message headers in the inheritance hierarchy are collected together to form the full set of headers for the message.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>All of the message body parts in the inheritance hierarchy are collected together to form the full message body.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The body parts are ordered according to the usual ordering rules (by <ph id="ph1">&lt;xref:System.ServiceModel.MessageBodyMemberAttribute.Order%2A?displayProperty=fullName&gt;</ph> property and then alphabetical), with no relevance to their place in the inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Using message contract inheritance where message body parts occur at multiple levels of the inheritance tree is strongly discouraged.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>If a base class and a derived class define a header or a body part with the same name, the member from the base-most class is used to store the value of that header or body part.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Consider the classes in the following code example.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`PatientRecord`</ph> class describes a message with one header called <ph id="ph2">`ID`</ph>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The header corresponds to the <ph id="ph1">`personID`</ph> and not the <ph id="ph2">`patientID`</ph> member, because the base-most member is chosen.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Thus, the <ph id="ph1">`patientID`</ph> field is useless in this case.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The body of the message contains the <ph id="ph1">`diagnosis`</ph> element followed by the <ph id="ph2">`patientName`</ph> element, because that is the alphabetical order.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Notice that the example shows a pattern that is strongly discouraged: both the base and the derived message contracts have message body parts.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>WSDL Considerations</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>When generating a Web Services Description Language (WSDL) contract from a service that uses message contracts, it is important to remember that not all message contract features are reflected in the resulting WSDL.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Consider the following points:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>WSDL cannot express the concept of an array of headers.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>When creating messages with an array of headers using the <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph>, the resulting WSDL reflects only one header instead of the array.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The resulting WSDL document may not reflect some protection-level information.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The message type generated in the WSDL has the same name as the class name of the message contract type.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>When using the same message contract in multiple operations, multiple message types are generated in the WSDL document.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The names are made unique by adding the numbers "2", "3", and so on, for subsequent uses.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>When importing back the WSDL, multiple message contract types are created and are identical except for their names.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>SOAP Encoding Considerations</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> allows you to use the legacy SOAP encoding style of XML, however, its use is not recommended.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>When using this style (by setting the <ph id="ph1">`Use`</ph> property to <ph id="ph2">`Encoded`</ph> on the <ph id="ph3">&lt;xref:System.ServiceModel.XmlSerializerFormatAttribute?displayProperty=fullName&gt;</ph> applied to the service contract), the following additional considerations apply:</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The message headers are not supported; this means that the attribute <ph id="ph1">&lt;xref:System.ServiceModel.MessageHeaderAttribute&gt;</ph> and the array attribute <ph id="ph2">&lt;xref:System.ServiceModel.MessageHeaderArrayAttribute&gt;</ph> are incompatible with SOAP encoding.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>If the message contract is not wrapped, that is, if the property <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A&gt;</ph> is set to <ph id="ph2">`false`</ph>, the message contract can have only one body part.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The name of the wrapper element for the request message contract must match the operation name.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">`WrapperName`</ph> property of the message contract for this.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The name of the wrapper element for the response message contract must be the same as the name of the operation suffixed by 'Response'.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A&gt;</ph> property of the message contract for this.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>SOAP encoding preserves object references.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For example, consider the following code.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>After serializing the message using SOAP encoding, <ph id="ph1">`changedFrom`</ph> and <ph id="ph2">`changedTo`</ph> do not contain their own copies of <ph id="ph3">`p`</ph>, but instead point to the copy inside the <ph id="ph4">`changedBy`</ph> element.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Every message header and message body part is serialized independently of the others.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Therefore, the same namespaces can be declared again for each header and body part.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>To improve performance, especially in terms of the size of the message on the wire, consolidate multiple headers and body parts into a single header or body part.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>For example, instead of the following code:</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Use this code.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Event-based Asynchronous and Message Contracts</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The design guidelines for the event-based asynchronous model state that if more than one value is returned, one value is returned as the <ph id="ph1">`Result`</ph> property and the others are returned as properties on the <ph id="ph2">&lt;xref:System.EventArgs&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>One result of this is that if a client imports metadata using the event-based asynchronous command options and the operation returns more than one value, the default <ph id="ph1">&lt;xref:System.EventArgs&gt;</ph> object returns one value as the <ph id="ph2">`Result`</ph> property and the remainder are properties of the <ph id="ph3">&lt;xref:System.EventArgs&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>If you want to receive the message object as the <ph id="ph1">`Result`</ph> property and have the returned values as properties on that object, use the <ph id="ph2">`/messageContract`</ph> command option.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>This generates a signature that returns the response message as the <ph id="ph1">`Result`</ph> property on the <ph id="ph2">&lt;xref:System.EventArgs&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>All internal return values are then properties of the response message object.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Using Data Contracts<ept id="p1">](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Designing and Implementing Services<ept id="p1">](../../../../docs/framework/wcf/designing-and-implementing-services.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>