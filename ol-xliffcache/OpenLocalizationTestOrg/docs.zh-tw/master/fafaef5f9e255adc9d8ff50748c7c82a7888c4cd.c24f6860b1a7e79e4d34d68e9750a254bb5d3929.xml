{"content":"---\ntitle: \"Chunking Channel\"\nms.date: \"03/30/2017\"\nms.assetid: e4d53379-b37c-4b19-8726-9cc914d5d39f\n---\n# Chunking Channel\nWhen sending large messages using Windows Communication Foundation (WCF), it is often desirable to limit the amount of memory used to buffer those messages. One possible solution is to stream the message body (assuming the bulk of the data is in the body). However some protocols require buffering of the entire message. Reliable messaging and security are two such examples. Another possible solution is to divide up the large message into smaller messages called chunks, send those chunks one chunk at a time, and reconstitute the large message on the receiving side. The application itself could do this chunking and de-chunking or it could use a custom channel to do it. The chunking channel sample shows how a custom protocol or layered channel can be used to do chunking and de-chunking of arbitrarily large messages.  \n  \n Chunking should always be employed only after the entire message to be sent has been constructed. A chunking channel should always be layered below a security channel and a reliable session channel.  \n  \n> [!NOTE]\n>  The setup procedure and build instructions for this sample are located at the end of this topic.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Channels\\ChunkingChannel`  \n  \n## Chunking Channel Assumptions and Limitations  \n  \n### Message Structure  \n The chunking channel assumes the following message structure for messages to be chunked:  \n  \n```xml  \n<soap:Envelope ...>  \n  <!-- headers -->  \n  <soap:Body>  \n    <operationElement>  \n      <paramElement>data to be chunked</paramElement>  \n    </operationElement>  \n  </soap:Body>  \n</soap:Envelope>  \n```  \n  \n When using the ServiceModel, contract operations that have 1 input parameter comply with this shape of message for their input message. Similarly, contract operations that have 1 output parameter or return value comply with this shape of message for their output message. The following are examples of such operations:  \n  \n```  \n[ServiceContract]  \ninterface ITestService  \n{  \n    [OperationContract]  \n    Stream EchoStream(Stream stream);  \n  \n    [OperationContract]  \n    Stream DownloadStream();  \n  \n    [OperationContract(IsOneWay = true)]  \n    void UploadStream(Stream stream);  \n}  \n```  \n  \n### Sessions  \n The chunking channel requires messages to be delivered exactly once, in ordered delivery of messages (chunks). This means the underlying channel stack must be sessionful. Sessions can be provided by the transport (for example, TCP transport) or by a sessionful protocol channel (for example, ReliableSession channel).  \n  \n### Asynchronous Send and Receive  \n Asynchronous send and receive methods are not implemented in this version of the chunking channel sample.  \n  \n## Chunking Protocol  \n The chunking channel defines a protocol that indicates the start and end of a series of chunks as well as the sequence number of each chunk. The following three example messages demonstrate the start, chunk and end messages with comments that describe the key aspects of each.  \n  \n### Start Message  \n  \n```xml  \n<s:Envelope xmlns:a=\"http://www.w3.org/2005/08/addressing\"   \n            xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\">  \n  <s:Header>  \n<!--Original message action is replaced with a chunking-specific action. -->  \n    <a:Action s:mustUnderstand=\"1\">http://samples.microsoft.com/chunkingAction</a:Action>  \n<!--  \nOriginal message is assigned a unique id that is transmitted   \nin a MessageId header. Note that this is different from the WS-Addressing MessageId header.  \n-->  \n    <MessageId s:mustUnderstand=\"1\" xmlns=\"http://samples.microsoft.com/chunking\">  \n53f183ee-04aa-44a0-b8d3-e45224563109  \n</MessageId>  \n<!--  \nChunkingStart header signals the start of a chunked message.  \n-->  \n    <ChunkingStart s:mustUnderstand=\"1\" i:nil=\"true\" xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://samples.microsoft.com/chunking\" />  \n<!--  \nOriginal message action is transmitted in OriginalAction.  \nThis is required to re-create the original message on the other side.  \n-->  \n    <OriginalAction xmlns=\"http://samples.microsoft.com/chunking\">  \nhttp://tempuri.org/ITestService/EchoStream  \n    </OriginalAction>  \n   <!--  \n    All original message headers are included here.  \n   -->  \n  </s:Header>  \n  <s:Body>  \n<!--  \nChunking assumes this structure of Body content:  \n<element>  \n  <childelement>large data to be chunked<childelement>  \n</element>  \nThe start message contains just <element> and <childelement> without  \nthe data to be chunked.  \n-->  \n    <EchoStream xmlns=\"http://tempuri.org/\">  \n      <stream />  \n    </EchoStream>  \n  </s:Body>  \n</s:Envelope>  \n```  \n  \n### Chunk Message  \n  \n```xml  \n<s:Envelope   \n  xmlns:a=\"http://www.w3.org/2005/08/addressing\"   \n  xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\">  \n  <s:Header>  \n   <!--  \n    All chunking protocol messages have this action.  \n   -->  \n    <a:Action s:mustUnderstand=\"1\">  \n      http://samples.microsoft.com/chunkingAction  \n    </a:Action>  \n<!--  \nSame as MessageId in the start message. The GUID indicates which original message this chunk belongs to.  \n-->  \n    <MessageId s:mustUnderstand=\"1\"   \n               xmlns=\"http://samples.microsoft.com/chunking\">  \n      53f183ee-04aa-44a0-b8d3-e45224563109  \n    </MessageId>  \n<!--  \nThe sequence number of the chunk.  \nThis number restarts at 1 with each new sequence of chunks.  \n-->  \n    <ChunkNumber s:mustUnderstand=\"1\"   \n                 xmlns=\"http://samples.microsoft.com/chunking\">  \n      1096  \n    </ChunkNumber>  \n  </s:Header>  \n  <s:Body>  \n<!--  \nThe chunked data is wrapped in a chunk element.  \nThe encoding of this data (and the entire message)   \ndepends on the encoder used. The chunking channel does not mandate an encoding.  \n-->  \n    <chunk xmlns=\"http://samples.microsoft.com/chunking\">  \nkfSr2QcBlkHTvQ==  \n    </chunk>  \n  </s:Body>  \n</s:Envelope>  \n```  \n  \n### End Message  \n  \n```xml  \n<s:Envelope xmlns:a=\"http://www.w3.org/2005/08/addressing\"   \n            xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\">  \n  <s:Header>  \n    <a:Action s:mustUnderstand=\"1\">  \n      http://samples.microsoft.com/chunkingAction  \n    </a:Action>  \n<!--  \nSame as MessageId in the start message. The GUID indicates which original message this chunk belongs to.  \n-->  \n    <MessageId s:mustUnderstand=\"1\"   \n               xmlns=\"http://samples.microsoft.com/chunking\">  \n      53f183ee-04aa-44a0-b8d3-e45224563109  \n    </MessageId>  \n<!--  \nChunkingEnd header signals the end of a chunk sequence.  \n-->  \n    <ChunkingEnd s:mustUnderstand=\"1\" i:nil=\"true\"   \n                 xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\"   \n                 xmlns=\"http://samples.microsoft.com/chunking\" />  \n<!--  \nChunkingEnd messages have a sequence number.  \n-->  \n    <ChunkNumber s:mustUnderstand=\"1\"   \n                 xmlns=\"http://samples.microsoft.com/chunking\">  \n      79  \n    </ChunkNumber>  \n  </s:Header>  \n  <s:Body>  \n<!--  \nThe ChunkingEnd message has the same <element><childelement> structure  \nas the ChunkingStart message.  \n-->  \n    <EchoStream xmlns=\"http://tempuri.org/\">  \n      <stream />  \n    </EchoStream>  \n  </s:Body>  \n</s:Envelope>  \n```  \n  \n## Chunking Channel Architecture  \n The chunking channel is an `IDuplexSessionChannel` that, at a high level, follows the typical channel architecture. There is a `ChunkingBindingElement` that can build a `ChunkingChannelFactory` and a `ChunkingChannelListener`. The `ChunkingChannelFactory` creates instances of `ChunkingChannel` when it is asked to. The `ChunkingChannelListener` creates instances of `ChunkingChannel` when a new inner channel is accepted. The `ChunkingChannel` itself is responsible for sending and receiving messages.  \n  \n At the next level down, `ChunkingChannel` relies on several components to implement the chunking protocol. On the send side, the channel uses a custom <xref:System.Xml.XmlDictionaryWriter> called `ChunkingWriter` that does the actual chunking. `ChunkingWriter` uses the inner channel directly to send chunks. Using a custom `XmlDictionaryWriter` allows us to send out chunks as the large body of the original message is being written. This means we do not buffer the entire original message.  \n  \n ![Chunking Channel](../../../../docs/framework/wcf/samples/media/chunkingchannel1.gif \"ChunkingChannel1\")  \n  \n On the receive side, `ChunkingChannel` pulls messages from the inner channel and hands them to a custom <xref:System.Xml.XmlDictionaryReader> called `ChunkingReader`, which reconstitutes the original message from the incoming chunks. `ChunkingChannel` wraps this `ChunkingReader` in a custom `Message` implementation called `ChunkingMessage` and returns this message to the layer above. This combination of `ChunkingReader` and `ChunkingMessage` allows us to de-chunk the original message body as it is being read by the layer above instead of having to buffer the entire original message body. `ChunkingReader` has a queue where it buffers incoming chunks up to a maximum configurable number of buffered chunks. When this maximum limit is reached, the reader waits for messages to be drained from the queue by the layer above (that is, by just reading from the original message body) or until the maximum receive timeout is reached.  \n  \n ![Chunking Channel](../../../../docs/framework/wcf/samples/media/chunkingchannel2.gif \"ChunkingChannel2\")  \n  \n## Chunking Programming Model  \n Service developers can specify which messages are to be chunked by applying the `ChunkingBehavior` attribute to operations within the contract. The attribute exposes an `AppliesTo` property that allows the developer to specify whether chunking applies to the input message, the output message or both. The following example shows the usage of `ChunkingBehavior` attribute:  \n  \n```  \n[ServiceContract]  \ninterface ITestService  \n{  \n    [OperationContract]  \n    [ChunkingBehavior(ChunkingAppliesTo.Both)]  \n    Stream EchoStream(Stream stream);  \n  \n    [OperationContract]  \n    [ChunkingBehavior(ChunkingAppliesTo.OutMessage)]  \n    Stream DownloadStream();  \n  \n    [OperationContract(IsOneWay=true)]  \n    [ChunkingBehavior(ChunkingAppliesTo.InMessage)]  \n    void UploadStream(Stream stream);  \n  \n}  \n```  \n  \n From this programming model, the `ChunkingBindingElement` compiles a list of action URIs that identify messages to be chunked. The action of each outgoing message is compared against this list to determine if the message should be chunked or sent directly.  \n  \n## Implementing the Send Operation  \n At a high level, the Send operation first checks whether the outgoing message must be chunked and, if not, sends the message directly using the inner channel.  \n  \n If the message must be chunked, Send creates a new `ChunkingWriter` and calls `WriteBodyContents` on the outgoing message passing it this `ChunkingWriter`. The `ChunkingWriter` then does the message chunking (including copying original message headers to the start chunk message) and sends chunks using the inner channel.  \n  \n A few details worth noting:  \n  \n-   Send first calls `ThrowIfDisposedOrNotOpened` to ensure the `CommunicationState` is opened.  \n  \n-   Sending is synchronized so that only one message can be sent at a time for each session. There is a `ManualResetEvent` named `sendingDone` that is reset when a chunked message is being sent. Once the end chunk message is sent, this event is set. The Send method waits for this event to be set before it tries to send the outgoing message.  \n  \n-   Send locks the `CommunicationObject.ThisLock` to prevent synchronized state changes while sending. See the <xref:System.ServiceModel.Channels.CommunicationObject> documentation for more information about <xref:System.ServiceModel.Channels.CommunicationObject> states and state machine.  \n  \n-   The timeout passed to Send is used as the timeout for the entire send operation which includes sending all of the chunks.  \n  \n-   The custom <xref:System.Xml.XmlDictionaryWriter> design was chosen to avoid buffering the entire original message body. If we were to get an <xref:System.Xml.XmlDictionaryReader> on the body using `message.GetReaderAtBodyContents` the entire body would be buffered. Instead, we have a custom  <xref:System.Xml.XmlDictionaryWriter> that is passed to `message.WriteBodyContents`. As the message calls WriteBase64 on the writer, the writer packages up chunks into messages and sends them using the inner channel. WriteBase64 blocks until the chunk is sent.  \n  \n## Implementing the Receive Operation  \n At a high level, the Receive operation first checks that the incoming message is not `null` and that its action is the `ChunkingAction`. If it does not meet both criteria, the message is returned unchanged from Receive. Otherwise, Receive creates a new `ChunkingReader` and a new `ChunkingMessage` wrapped around it (by calling `GetNewChunkingMessage`). Before returning that new `ChunkingMessage`, Receive uses a threadpool thread to execute `ReceiveChunkLoop`, which calls `innerChannel.Receive` in a loop and hands off chunks to the `ChunkingReader` until the end chunk message is received or the receive timeout is hit.  \n  \n A few details worth noting:  \n  \n-   Like Send, Receive first calls `ThrowIfDisposedOrNotOepned` to ensure the `CommunicationState` is Opened.  \n  \n-   Receive is also synchronized so that only one message can be received at a time from the session. This is especially important because once a start chunk message is received, all subsequent received messages are expected to be chunks within this new chunk sequence until an end chunk message is received. Receive cannot pull messages from the inner channel until all chunks that belong to the message currently being de-chunked are received. To accomplish this, Receive uses a `ManualResetEvent` named `currentMessageCompleted`, which is set when the end chunk message is received and reset when a new start chunk message is received.  \n  \n-   Unlike Send, Receive does not prevent synchronized state transitions while receiving. For example, Close can be called while receiving and waits until the pending receive of the original message is completed or the specified timeout value is reached.  \n  \n-   The timeout passed to Receive is used as the timeout for the entire receive operation, which includes receiving all of the chunks.  \n  \n-   If the layer that consumes the message is consuming the message body at a rate lower than the rate of incoming chunk messages, the `ChunkingReader` buffers those incoming chunks up to the limit specified by `ChunkingBindingElement.MaxBufferedChunks`. Once that limit is reached, no more chunks are pulled from the lower layer until either a buffered chunk is consumed or the receive timeout is reached.  \n  \n## CommunicationObject Overrides  \n  \n### OnOpen  \n `OnOpen` calls `innerChannel.Open` to open the inner channel.  \n  \n### OnClose  \n `OnClose` first sets `stopReceive` to `true` to signal the pending `ReceiveChunkLoop` to stop. It then waits for the `receiveStopped` <xref:System.Threading.ManualResetEvent>, which is set when `ReceiveChunkLoop` stops. Assuming the `ReceiveChunkLoop` stops within the specified timeout, `OnClose` calls `innerChannel.Close` with the remaining timeout.  \n  \n### OnAbort  \n `OnAbort` calls `innerChannel.Abort` to abort the inner channel. If there is a pending `ReceiveChunkLoop` it gets an exception from the pending `innerChannel.Receive` call.  \n  \n### OnFaulted  \n The `ChunkingChannel` does not require special behavior when the channel is faulted so `OnFaulted` is not overridden.  \n  \n## Implementing Channel Factory  \n The `ChunkingChannelFactory` is responsible for creating instances of `ChunkingDuplexSessionChannel` and for cascading state transitions to the inner channel factory.  \n  \n `OnCreateChannel` uses the inner channel factory to create an `IDuplexSessionChannel` inner channel. It then creates a new `ChunkingDuplexSessionChannel` passing it this inner channel along with the list of message actions to be chunked and the maximum number of chunks to buffer upon receive. The list of message actions to be chunked and the maximum number of chunks to buffer are two parameters passed to `ChunkingChannelFactory` in its constructor. The section on `ChunkingBindingElement` describes where these values come from.  \n  \n The `OnOpen`, `OnClose`, `OnAbort` and their asynchronous equivalents call the corresponding state transition method on the inner channel factory.  \n  \n## Implementing Channel Listener  \n The `ChunkingChannelListener` is a wrapper around an inner channel listener. Its main function, besides delegate calls to that inner channel listener, is to wrap new `ChunkingDuplexSessionChannels` around channels accepted from the inner channel listener. This is done in `OnAcceptChannel` and `OnEndAcceptChannel`. The newly created `ChunkingDuplexSessionChannel` is passed the inner channel along with the other parameters previously described.  \n  \n## Implementing Binding Element and Binding  \n `ChunkingBindingElement` is responsible for creating the `ChunkingChannelFactory` and `ChunkingChannelListener`. The `ChunkingBindingElement` checks whether T in `CanBuildChannelFactory`\\<T> and `CanBuildChannelListener`\\<T> is of type `IDuplexSessionChannel` (the only channel supported by the chunking channel) and that the other binding elements in the binding support this channel type.  \n  \n `BuildChannelFactory`\\<T> first checks that the requested channel type can be built and then gets a list of message actions to be chunked. For more information, see the following section. It then creates a new `ChunkingChannelFactory` passing it the inner channel factory (as returned from `context.BuildInnerChannelFactory<IDuplexSessionChannel>`), the list of message actions, and the maximum number of chunks to buffer. The maximum number of chunks comes from a property called `MaxBufferedChunks` exposed by the `ChunkingBindingElement`.  \n  \n `BuildChannelListener<T>` has a similar implementation for creating `ChunkingChannelListener` and passing it the inner channel listener.  \n  \n There is an example binding included in this sample named `TcpChunkingBinding`. This binding consists of two binding elements: `TcpTransportBindingElement` and `ChunkingBindingElement`. In addition to exposing the `MaxBufferedChunks` property, the binding also sets some of the `TcpTransportBindingElement` properties such as `MaxReceivedMessageSize` (sets it to `ChunkingUtils.ChunkSize` + 100KB bytes for headers).  \n  \n `TcpChunkingBinding` also implements `IBindingRuntimePreferences` and returns true from the `ReceiveSynchronously` method indicating that only the synchronous Receive calls are implemented.  \n  \n### Determining Which Messages To Chunk  \n The chunking channel chunks only the messages identified through the `ChunkingBehavior` attribute. The `ChunkingBehavior` class implements `IOperationBehavior` and is implemented by calling the `AddBindingParameter` method. In this method, the `ChunkingBehavior` examines the value of its `AppliesTo` property (`InMessage`, `OutMessage` or both) to determine which messages should be chunked. It then gets the action of each of those messages (from the Messages collection on `OperationDescription`) and adds it to a string collection contained within an instance of `ChunkingBindingParameter`. It then adds this `ChunkingBindingParameter` to the provided `BindingParameterCollection`.  \n  \n This `BindingParameterCollection` is passed inside the `BindingContext` to each binding element in the binding when that binding element builds the channel factory or the channel listener. The `ChunkingBindingElement`'s implementation of `BuildChannelFactory<T>` and `BuildChannelListener<T>` pull this `ChunkingBindingParameter` out of the `BindingContext’`s `BindingParameterCollection`. The collection of actions contained within the `ChunkingBindingParameter` is then passed to the `ChunkingChannelFactory` or `ChunkingChannelListener`, which in turn passes it to the `ChunkingDuplexSessionChannel`.  \n  \n## Running the Sample  \n  \n#### To set up, build, and run the sample  \n  \n1.  Install [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 4.0 using the following command.  \n  \n    ```  \n    %windir%\\Microsoft.NET\\Framework\\v4.0.XXXXX\\aspnet_regiis.exe /i /enable  \n    ```  \n  \n2.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n3.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n4.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n5.  Run Service.exe first, then run Client.exe and watch both console windows for output.  \n  \n When running the sample, the following output is expected.  \n  \n Client:  \n  \n```  \nPress enter when service is available  \n  \n > Sent chunk 1 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 2 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 3 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 4 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 5 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 6 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 7 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 8 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 9 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 10 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 1 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 2 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 3 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 4 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 5 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 6 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 7 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 8 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 9 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n < Received chunk 10 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n```  \n  \n Server:  \n  \n```  \nService started, press enter to exit  \n < Received chunk 1 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 2 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 3 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 4 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 5 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 6 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 7 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 8 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 9 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n < Received chunk 10 of message 867c1fd1-d39e-4be1-bc7b-32066d7ced10  \n > Sent chunk 1 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 2 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 3 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 4 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 5 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 6 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 7 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 8 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 9 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n > Sent chunk 10 of message 5b226ad5-c088-4988-b737-6a565e0563dd  \n```  \n","nodes":[{"pos":[4,100],"embed":true,"restype":"x-metadata","content":"title: \"Chunking Channel\"\nms.date: \"03/30/2017\"\nms.assetid: e4d53379-b37c-4b19-8726-9cc914d5d39f","nodes":[{"content":"Chunking Channel","nodes":[{"pos":[0,16],"content":"Chunking Channel","nodes":[{"content":"Chunking Channel","pos":[0,16]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[107,123],"content":"Chunking Channel","linkify":"Chunking Channel","nodes":[{"content":"Chunking Channel","pos":[0,16]}]},{"content":"When sending large messages using Windows Communication Foundation (WCF), it is often desirable to limit the amount of memory used to buffer those messages.","pos":[124,280]},{"content":"One possible solution is to stream the message body (assuming the bulk of the data is in the body).","pos":[281,380]},{"content":"However some protocols require buffering of the entire message.","pos":[381,444]},{"content":"Reliable messaging and security are two such examples.","pos":[445,499]},{"content":"Another possible solution is to divide up the large message into smaller messages called chunks, send those chunks one chunk at a time, and reconstitute the large message on the receiving side.","pos":[500,693]},{"content":"The application itself could do this chunking and de-chunking or it could use a custom channel to do it.","pos":[694,798]},{"content":"The chunking channel sample shows how a custom protocol or layered channel can be used to do chunking and de-chunking of arbitrarily large messages.","pos":[799,947]},{"content":"Chunking should always be employed only after the entire message to be sent has been constructed.","pos":[954,1051]},{"content":"A chunking channel should always be layered below a security channel and a reliable session channel.","pos":[1052,1152]},{"pos":[1160,1267],"content":"[!NOTE]\n The setup procedure and build instructions for this sample are located at the end of this topic.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this topic.","pos":[9,105]}]},{"pos":[1275,1407],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":"The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[14,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[0,53]},{"content":"Check for the following (default) directory before continuing.","pos":[54,116]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id=\"ph1\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[1461,1771],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[1772,1822]},{"pos":[1917,1961],"content":"Chunking Channel Assumptions and Limitations","linkify":"Chunking Channel Assumptions and Limitations","nodes":[{"content":"Chunking Channel Assumptions and Limitations","pos":[0,44]}]},{"pos":[1971,1988],"content":"Message Structure","linkify":"Message Structure","nodes":[{"content":"Message Structure","pos":[0,17]}]},{"content":"The chunking channel assumes the following message structure for messages to be chunked:","pos":[1992,2080]},{"content":"When using the ServiceModel, contract operations that have 1 input parameter comply with this shape of message for their input message.","pos":[2307,2442]},{"content":"Similarly, contract operations that have 1 output parameter or return value comply with this shape of message for their output message.","pos":[2443,2578]},{"content":"The following are examples of such operations:","pos":[2579,2625]},{"pos":[2915,2923],"content":"Sessions","linkify":"Sessions","nodes":[{"content":"Sessions","pos":[0,8]}]},{"content":"The chunking channel requires messages to be delivered exactly once, in ordered delivery of messages (chunks).","pos":[2927,3037]},{"content":"This means the underlying channel stack must be sessionful.","pos":[3038,3097]},{"content":"Sessions can be provided by the transport (for example, TCP transport) or by a sessionful protocol channel (for example, ReliableSession channel).","pos":[3098,3244]},{"pos":[3254,3283],"content":"Asynchronous Send and Receive","linkify":"Asynchronous Send and Receive","nodes":[{"content":"Asynchronous Send and Receive","pos":[0,29]}]},{"content":"Asynchronous send and receive methods are not implemented in this version of the chunking channel sample.","pos":[3287,3392]},{"pos":[3401,3418],"content":"Chunking Protocol","linkify":"Chunking Protocol","nodes":[{"content":"Chunking Protocol","pos":[0,17]}]},{"content":"The chunking channel defines a protocol that indicates the start and end of a series of chunks as well as the sequence number of each chunk.","pos":[3422,3562]},{"content":"The following three example messages demonstrate the start, chunk and end messages with comments that describe the key aspects of each.","pos":[3563,3698]},{"pos":[3708,3721],"content":"Start Message","linkify":"Start Message","nodes":[{"content":"Start Message","pos":[0,13]}]},{"pos":[5348,5361],"content":"Chunk Message","linkify":"Chunk Message","nodes":[{"content":"Chunk Message","pos":[0,13]}]},{"pos":[6599,6610],"content":"End Message","linkify":"End Message","nodes":[{"content":"End Message","pos":[0,11]}]},{"pos":[7901,7930],"content":"Chunking Channel Architecture","linkify":"Chunking Channel Architecture","nodes":[{"content":"Chunking Channel Architecture","pos":[0,29]}]},{"content":"The chunking channel is an <ph id=\"ph1\">`IDuplexSessionChannel`</ph> that, at a high level, follows the typical channel architecture.","pos":[7934,8049],"source":"The chunking channel is an `IDuplexSessionChannel` that, at a high level, follows the typical channel architecture."},{"content":"There is a <ph id=\"ph1\">`ChunkingBindingElement`</ph> that can build a <ph id=\"ph2\">`ChunkingChannelFactory`</ph> and a <ph id=\"ph3\">`ChunkingChannelListener`</ph>.","pos":[8050,8160],"source":" There is a `ChunkingBindingElement` that can build a `ChunkingChannelFactory` and a `ChunkingChannelListener`."},{"content":"The <ph id=\"ph1\">`ChunkingChannelFactory`</ph> creates instances of <ph id=\"ph2\">`ChunkingChannel`</ph> when it is asked to.","pos":[8161,8249],"source":" The `ChunkingChannelFactory` creates instances of `ChunkingChannel` when it is asked to."},{"content":"The <ph id=\"ph1\">`ChunkingChannelListener`</ph> creates instances of <ph id=\"ph2\">`ChunkingChannel`</ph> when a new inner channel is accepted.","pos":[8250,8356],"source":" The `ChunkingChannelListener` creates instances of `ChunkingChannel` when a new inner channel is accepted."},{"content":"The <ph id=\"ph1\">`ChunkingChannel`</ph> itself is responsible for sending and receiving messages.","pos":[8357,8436],"source":" The `ChunkingChannel` itself is responsible for sending and receiving messages."},{"content":"At the next level down, <ph id=\"ph1\">`ChunkingChannel`</ph> relies on several components to implement the chunking protocol.","pos":[8443,8549],"source":"At the next level down, `ChunkingChannel` relies on several components to implement the chunking protocol."},{"content":"On the send side, the channel uses a custom <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph> called <ph id=\"ph2\">`ChunkingWriter`</ph> that does the actual chunking.","pos":[8550,8686],"source":" On the send side, the channel uses a custom <xref:System.Xml.XmlDictionaryWriter> called `ChunkingWriter` that does the actual chunking."},{"content":"<ph id=\"ph1\">`ChunkingWriter`</ph> uses the inner channel directly to send chunks.","pos":[8687,8751],"source":"`ChunkingWriter` uses the inner channel directly to send chunks."},{"content":"Using a custom <ph id=\"ph1\">`XmlDictionaryWriter`</ph> allows us to send out chunks as the large body of the original message is being written.","pos":[8752,8877],"source":" Using a custom `XmlDictionaryWriter` allows us to send out chunks as the large body of the original message is being written."},{"content":"This means we do not buffer the entire original message.","pos":[8878,8934]},{"pos":[8941,9046],"content":"<bpt id=\"p1\">![</bpt>Chunking Channel<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/samples/media/chunkingchannel1.gif \"</bpt>ChunkingChannel1<ept id=\"p2\">\")</ept>","source":"![Chunking Channel](../../../../docs/framework/wcf/samples/media/chunkingchannel1.gif \"ChunkingChannel1\")"},{"content":"On the receive side, <ph id=\"ph1\">`ChunkingChannel`</ph> pulls messages from the inner channel and hands them to a custom <ph id=\"ph2\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> called <ph id=\"ph3\">`ChunkingReader`</ph>, which reconstitutes the original message from the incoming chunks.","pos":[9053,9286],"source":"On the receive side, `ChunkingChannel` pulls messages from the inner channel and hands them to a custom <xref:System.Xml.XmlDictionaryReader> called `ChunkingReader`, which reconstitutes the original message from the incoming chunks."},{"content":"<ph id=\"ph1\">`ChunkingChannel`</ph> wraps this <ph id=\"ph2\">`ChunkingReader`</ph> in a custom <ph id=\"ph3\">`Message`</ph> implementation called <ph id=\"ph4\">`ChunkingMessage`</ph> and returns this message to the layer above.","pos":[9287,9439],"source":"`ChunkingChannel` wraps this `ChunkingReader` in a custom `Message` implementation called `ChunkingMessage` and returns this message to the layer above."},{"content":"This combination of <ph id=\"ph1\">`ChunkingReader`</ph> and <ph id=\"ph2\">`ChunkingMessage`</ph> allows us to de-chunk the original message body as it is being read by the layer above instead of having to buffer the entire original message body.","pos":[9440,9647],"source":" This combination of `ChunkingReader` and `ChunkingMessage` allows us to de-chunk the original message body as it is being read by the layer above instead of having to buffer the entire original message body."},{"content":"<ph id=\"ph1\">`ChunkingReader`</ph> has a queue where it buffers incoming chunks up to a maximum configurable number of buffered chunks.","pos":[9648,9765],"source":"`ChunkingReader` has a queue where it buffers incoming chunks up to a maximum configurable number of buffered chunks."},{"content":"When this maximum limit is reached, the reader waits for messages to be drained from the queue by the layer above (that is, by just reading from the original message body) or until the maximum receive timeout is reached.","pos":[9766,9986]},{"pos":[9993,10098],"content":"<bpt id=\"p1\">![</bpt>Chunking Channel<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/samples/media/chunkingchannel2.gif \"</bpt>ChunkingChannel2<ept id=\"p2\">\")</ept>","source":"![Chunking Channel](../../../../docs/framework/wcf/samples/media/chunkingchannel2.gif \"ChunkingChannel2\")"},{"pos":[10107,10133],"content":"Chunking Programming Model","linkify":"Chunking Programming Model","nodes":[{"content":"Chunking Programming Model","pos":[0,26]}]},{"content":"Service developers can specify which messages are to be chunked by applying the <ph id=\"ph1\">`ChunkingBehavior`</ph> attribute to operations within the contract.","pos":[10137,10280],"source":"Service developers can specify which messages are to be chunked by applying the `ChunkingBehavior` attribute to operations within the contract."},{"content":"The attribute exposes an <ph id=\"ph1\">`AppliesTo`</ph> property that allows the developer to specify whether chunking applies to the input message, the output message or both.","pos":[10281,10438],"source":" The attribute exposes an `AppliesTo` property that allows the developer to specify whether chunking applies to the input message, the output message or both."},{"content":"The following example shows the usage of <ph id=\"ph1\">`ChunkingBehavior`</ph> attribute:","pos":[10439,10509],"source":" The following example shows the usage of `ChunkingBehavior` attribute:"},{"content":"From this programming model, the <ph id=\"ph1\">`ChunkingBindingElement`</ph> compiles a list of action URIs that identify messages to be chunked.","pos":[10955,11081],"source":"From this programming model, the `ChunkingBindingElement` compiles a list of action URIs that identify messages to be chunked."},{"content":"The action of each outgoing message is compared against this list to determine if the message should be chunked or sent directly.","pos":[11082,11211]},{"pos":[11220,11251],"content":"Implementing the Send Operation","linkify":"Implementing the Send Operation","nodes":[{"content":"Implementing the Send Operation","pos":[0,31]}]},{"content":"At a high level, the Send operation first checks whether the outgoing message must be chunked and, if not, sends the message directly using the inner channel.","pos":[11255,11413]},{"content":"If the message must be chunked, Send creates a new <ph id=\"ph1\">`ChunkingWriter`</ph> and calls <ph id=\"ph2\">`WriteBodyContents`</ph> on the outgoing message passing it this <ph id=\"ph3\">`ChunkingWriter`</ph>.","pos":[11420,11575],"source":"If the message must be chunked, Send creates a new `ChunkingWriter` and calls `WriteBodyContents` on the outgoing message passing it this `ChunkingWriter`."},{"content":"The <ph id=\"ph1\">`ChunkingWriter`</ph> then does the message chunking (including copying original message headers to the start chunk message) and sends chunks using the inner channel.","pos":[11576,11741],"source":" The `ChunkingWriter` then does the message chunking (including copying original message headers to the start chunk message) and sends chunks using the inner channel."},{"content":"A few details worth noting:","pos":[11748,11775]},{"pos":[11785,11876],"content":"Send first calls <ph id=\"ph1\">`ThrowIfDisposedOrNotOpened`</ph> to ensure the <ph id=\"ph2\">`CommunicationState`</ph> is opened.","source":"Send first calls `ThrowIfDisposedOrNotOpened` to ensure the `CommunicationState` is opened."},{"content":"Sending is synchronized so that only one message can be sent at a time for each session.","pos":[11886,11974]},{"content":"There is a <ph id=\"ph1\">`ManualResetEvent`</ph> named <ph id=\"ph2\">`sendingDone`</ph> that is reset when a chunked message is being sent.","pos":[11975,12076],"source":" There is a `ManualResetEvent` named `sendingDone` that is reset when a chunked message is being sent."},{"content":"Once the end chunk message is sent, this event is set.","pos":[12077,12131]},{"content":"The Send method waits for this event to be set before it tries to send the outgoing message.","pos":[12132,12224]},{"content":"Send locks the <ph id=\"ph1\">`CommunicationObject.ThisLock`</ph> to prevent synchronized state changes while sending.","pos":[12234,12332],"source":"Send locks the `CommunicationObject.ThisLock` to prevent synchronized state changes while sending."},{"content":"See the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CommunicationObject&gt;</ph> documentation for more information about <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.CommunicationObject&gt;</ph> states and state machine.","pos":[12333,12519],"source":" See the <xref:System.ServiceModel.Channels.CommunicationObject> documentation for more information about <xref:System.ServiceModel.Channels.CommunicationObject> states and state machine."},{"content":"The timeout passed to Send is used as the timeout for the entire send operation which includes sending all of the chunks.","pos":[12529,12650]},{"content":"The custom <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph> design was chosen to avoid buffering the entire original message body.","pos":[12660,12779],"source":"The custom <xref:System.Xml.XmlDictionaryWriter> design was chosen to avoid buffering the entire original message body."},{"content":"If we were to get an <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryReader&gt;</ph> on the body using <ph id=\"ph2\">`message.GetReaderAtBodyContents`</ph> the entire body would be buffered.","pos":[12780,12925],"source":" If we were to get an <xref:System.Xml.XmlDictionaryReader> on the body using `message.GetReaderAtBodyContents` the entire body would be buffered."},{"content":"Instead, we have a custom  <ph id=\"ph1\">&lt;xref:System.Xml.XmlDictionaryWriter&gt;</ph> that is passed to <ph id=\"ph2\">`message.WriteBodyContents`</ph>.","pos":[12926,13037],"source":" Instead, we have a custom  <xref:System.Xml.XmlDictionaryWriter> that is passed to `message.WriteBodyContents`."},{"content":"As the message calls WriteBase64 on the writer, the writer packages up chunks into messages and sends them using the inner channel.","pos":[13038,13169]},{"content":"WriteBase64 blocks until the chunk is sent.","pos":[13170,13213]},{"pos":[13222,13256],"content":"Implementing the Receive Operation","linkify":"Implementing the Receive Operation","nodes":[{"content":"Implementing the Receive Operation","pos":[0,34]}]},{"content":"At a high level, the Receive operation first checks that the incoming message is not <ph id=\"ph1\">`null`</ph> and that its action is the <ph id=\"ph2\">`ChunkingAction`</ph>.","pos":[13260,13396],"source":"At a high level, the Receive operation first checks that the incoming message is not `null` and that its action is the `ChunkingAction`."},{"content":"If it does not meet both criteria, the message is returned unchanged from Receive.","pos":[13397,13479]},{"content":"Otherwise, Receive creates a new <ph id=\"ph1\">`ChunkingReader`</ph> and a new <ph id=\"ph2\">`ChunkingMessage`</ph> wrapped around it (by calling <ph id=\"ph3\">`GetNewChunkingMessage`</ph>).","pos":[13480,13613],"source":" Otherwise, Receive creates a new `ChunkingReader` and a new `ChunkingMessage` wrapped around it (by calling `GetNewChunkingMessage`)."},{"content":"Before returning that new <ph id=\"ph1\">`ChunkingMessage`</ph>, Receive uses a threadpool thread to execute <ph id=\"ph2\">`ReceiveChunkLoop`</ph>, which calls <ph id=\"ph3\">`innerChannel.Receive`</ph> in a loop and hands off chunks to the <ph id=\"ph4\">`ChunkingReader`</ph> until the end chunk message is received or the receive timeout is hit.","pos":[13614,13883],"source":" Before returning that new `ChunkingMessage`, Receive uses a threadpool thread to execute `ReceiveChunkLoop`, which calls `innerChannel.Receive` in a loop and hands off chunks to the `ChunkingReader` until the end chunk message is received or the receive timeout is hit."},{"content":"A few details worth noting:","pos":[13890,13917]},{"pos":[13927,14032],"content":"Like Send, Receive first calls <ph id=\"ph1\">`ThrowIfDisposedOrNotOepned`</ph> to ensure the <ph id=\"ph2\">`CommunicationState`</ph> is Opened.","source":"Like Send, Receive first calls `ThrowIfDisposedOrNotOepned` to ensure the `CommunicationState` is Opened."},{"content":"Receive is also synchronized so that only one message can be received at a time from the session.","pos":[14042,14139]},{"content":"This is especially important because once a start chunk message is received, all subsequent received messages are expected to be chunks within this new chunk sequence until an end chunk message is received.","pos":[14140,14346]},{"content":"Receive cannot pull messages from the inner channel until all chunks that belong to the message currently being de-chunked are received.","pos":[14347,14483]},{"content":"To accomplish this, Receive uses a <ph id=\"ph1\">`ManualResetEvent`</ph> named <ph id=\"ph2\">`currentMessageCompleted`</ph>, which is set when the end chunk message is received and reset when a new start chunk message is received.","pos":[14484,14676],"source":" To accomplish this, Receive uses a `ManualResetEvent` named `currentMessageCompleted`, which is set when the end chunk message is received and reset when a new start chunk message is received."},{"content":"Unlike Send, Receive does not prevent synchronized state transitions while receiving.","pos":[14686,14771]},{"content":"For example, Close can be called while receiving and waits until the pending receive of the original message is completed or the specified timeout value is reached.","pos":[14772,14936]},{"content":"The timeout passed to Receive is used as the timeout for the entire receive operation, which includes receiving all of the chunks.","pos":[14946,15076]},{"content":"If the layer that consumes the message is consuming the message body at a rate lower than the rate of incoming chunk messages, the <ph id=\"ph1\">`ChunkingReader`</ph> buffers those incoming chunks up to the limit specified by <ph id=\"ph2\">`ChunkingBindingElement.MaxBufferedChunks`</ph>.","pos":[15086,15336],"source":"If the layer that consumes the message is consuming the message body at a rate lower than the rate of incoming chunk messages, the `ChunkingReader` buffers those incoming chunks up to the limit specified by `ChunkingBindingElement.MaxBufferedChunks`."},{"content":"Once that limit is reached, no more chunks are pulled from the lower layer until either a buffered chunk is consumed or the receive timeout is reached.","pos":[15337,15488]},{"pos":[15497,15526],"content":"CommunicationObject Overrides","linkify":"CommunicationObject Overrides","nodes":[{"content":"CommunicationObject Overrides","pos":[0,29]}]},{"pos":[15536,15542],"content":"OnOpen","linkify":"OnOpen","nodes":[{"content":"OnOpen","pos":[0,6]}]},{"pos":[15546,15607],"content":"<ph id=\"ph1\">`OnOpen`</ph> calls <ph id=\"ph2\">`innerChannel.Open`</ph> to open the inner channel.","source":"`OnOpen` calls `innerChannel.Open` to open the inner channel."},{"pos":[15617,15624],"content":"OnClose","linkify":"OnClose","nodes":[{"content":"OnClose","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`OnClose`</ph> first sets <ph id=\"ph2\">`stopReceive`</ph> to <ph id=\"ph3\">`true`</ph> to signal the pending <ph id=\"ph4\">`ReceiveChunkLoop`</ph> to stop.","pos":[15628,15722],"source":"`OnClose` first sets `stopReceive` to `true` to signal the pending `ReceiveChunkLoop` to stop."},{"content":"It then waits for the <ph id=\"ph1\">`receiveStopped`</ph> <ph id=\"ph2\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>, which is set when <ph id=\"ph3\">`ReceiveChunkLoop`</ph> stops.","pos":[15723,15847],"source":" It then waits for the `receiveStopped` <xref:System.Threading.ManualResetEvent>, which is set when `ReceiveChunkLoop` stops."},{"content":"Assuming the <ph id=\"ph1\">`ReceiveChunkLoop`</ph> stops within the specified timeout, <ph id=\"ph2\">`OnClose`</ph> calls <ph id=\"ph3\">`innerChannel.Close`</ph> with the remaining timeout.","pos":[15848,15980],"source":" Assuming the `ReceiveChunkLoop` stops within the specified timeout, `OnClose` calls `innerChannel.Close` with the remaining timeout."},{"pos":[15990,15997],"content":"OnAbort","linkify":"OnAbort","nodes":[{"content":"OnAbort","pos":[0,7]}]},{"content":"<ph id=\"ph1\">`OnAbort`</ph> calls <ph id=\"ph2\">`innerChannel.Abort`</ph> to abort the inner channel.","pos":[16001,16065],"source":"`OnAbort` calls `innerChannel.Abort` to abort the inner channel."},{"content":"If there is a pending <ph id=\"ph1\">`ReceiveChunkLoop`</ph> it gets an exception from the pending <ph id=\"ph2\">`innerChannel.Receive`</ph> call.","pos":[16066,16173],"source":" If there is a pending `ReceiveChunkLoop` it gets an exception from the pending `innerChannel.Receive` call."},{"pos":[16183,16192],"content":"OnFaulted","linkify":"OnFaulted","nodes":[{"content":"OnFaulted","pos":[0,9]}]},{"pos":[16196,16313],"content":"The <ph id=\"ph1\">`ChunkingChannel`</ph> does not require special behavior when the channel is faulted so <ph id=\"ph2\">`OnFaulted`</ph> is not overridden.","source":"The `ChunkingChannel` does not require special behavior when the channel is faulted so `OnFaulted` is not overridden."},{"pos":[16322,16350],"content":"Implementing Channel Factory","linkify":"Implementing Channel Factory","nodes":[{"content":"Implementing Channel Factory","pos":[0,28]}]},{"pos":[16354,16520],"content":"The <ph id=\"ph1\">`ChunkingChannelFactory`</ph> is responsible for creating instances of <ph id=\"ph2\">`ChunkingDuplexSessionChannel`</ph> and for cascading state transitions to the inner channel factory.","source":"The `ChunkingChannelFactory` is responsible for creating instances of `ChunkingDuplexSessionChannel` and for cascading state transitions to the inner channel factory."},{"content":"<ph id=\"ph1\">`OnCreateChannel`</ph> uses the inner channel factory to create an <ph id=\"ph2\">`IDuplexSessionChannel`</ph> inner channel.","pos":[16527,16627],"source":"`OnCreateChannel` uses the inner channel factory to create an `IDuplexSessionChannel` inner channel."},{"content":"It then creates a new <ph id=\"ph1\">`ChunkingDuplexSessionChannel`</ph> passing it this inner channel along with the list of message actions to be chunked and the maximum number of chunks to buffer upon receive.","pos":[16628,16820],"source":" It then creates a new `ChunkingDuplexSessionChannel` passing it this inner channel along with the list of message actions to be chunked and the maximum number of chunks to buffer upon receive."},{"content":"The list of message actions to be chunked and the maximum number of chunks to buffer are two parameters passed to <ph id=\"ph1\">`ChunkingChannelFactory`</ph> in its constructor.","pos":[16821,16979],"source":" The list of message actions to be chunked and the maximum number of chunks to buffer are two parameters passed to `ChunkingChannelFactory` in its constructor."},{"content":"The section on <ph id=\"ph1\">`ChunkingBindingElement`</ph> describes where these values come from.","pos":[16980,17059],"source":" The section on `ChunkingBindingElement` describes where these values come from."},{"pos":[17066,17212],"content":"The <ph id=\"ph1\">`OnOpen`</ph>, <ph id=\"ph2\">`OnClose`</ph>, <ph id=\"ph3\">`OnAbort`</ph> and their asynchronous equivalents call the corresponding state transition method on the inner channel factory.","source":"The `OnOpen`, `OnClose`, `OnAbort` and their asynchronous equivalents call the corresponding state transition method on the inner channel factory."},{"pos":[17221,17250],"content":"Implementing Channel Listener","linkify":"Implementing Channel Listener","nodes":[{"content":"Implementing Channel Listener","pos":[0,29]}]},{"content":"The <ph id=\"ph1\">`ChunkingChannelListener`</ph> is a wrapper around an inner channel listener.","pos":[17254,17330],"source":"The `ChunkingChannelListener` is a wrapper around an inner channel listener."},{"content":"Its main function, besides delegate calls to that inner channel listener, is to wrap new <ph id=\"ph1\">`ChunkingDuplexSessionChannels`</ph> around channels accepted from the inner channel listener.","pos":[17331,17509],"source":" Its main function, besides delegate calls to that inner channel listener, is to wrap new `ChunkingDuplexSessionChannels` around channels accepted from the inner channel listener."},{"content":"This is done in <ph id=\"ph1\">`OnAcceptChannel`</ph> and <ph id=\"ph2\">`OnEndAcceptChannel`</ph>.","pos":[17510,17569],"source":" This is done in `OnAcceptChannel` and `OnEndAcceptChannel`."},{"content":"The newly created <ph id=\"ph1\">`ChunkingDuplexSessionChannel`</ph> is passed the inner channel along with the other parameters previously described.","pos":[17570,17700],"source":" The newly created `ChunkingDuplexSessionChannel` is passed the inner channel along with the other parameters previously described."},{"pos":[17709,17749],"content":"Implementing Binding Element and Binding","linkify":"Implementing Binding Element and Binding","nodes":[{"content":"Implementing Binding Element and Binding","pos":[0,40]}]},{"content":"<ph id=\"ph1\">`ChunkingBindingElement`</ph> is responsible for creating the <ph id=\"ph2\">`ChunkingChannelFactory`</ph> and <ph id=\"ph3\">`ChunkingChannelListener`</ph>.","pos":[17753,17865],"source":"`ChunkingBindingElement` is responsible for creating the `ChunkingChannelFactory` and `ChunkingChannelListener`."},{"content":"The <ph id=\"ph1\">`ChunkingBindingElement`</ph> checks whether T in <ph id=\"ph2\">`CanBuildChannelFactory`</ph><ph id=\"ph3\">\\&lt;</ph>T&gt; and <ph id=\"ph4\">`CanBuildChannelListener`</ph><ph id=\"ph5\">\\&lt;</ph>T&gt; is of type <ph id=\"ph6\">`IDuplexSessionChannel`</ph> (the only channel supported by the chunking channel) and that the other binding elements in the binding support this channel type.","pos":[17866,18143],"source":" The `ChunkingBindingElement` checks whether T in `CanBuildChannelFactory`\\<T> and `CanBuildChannelListener`\\<T> is of type `IDuplexSessionChannel` (the only channel supported by the chunking channel) and that the other binding elements in the binding support this channel type."},{"content":"<ph id=\"ph1\">`BuildChannelFactory`</ph><ph id=\"ph2\">\\&lt;</ph>T&gt; first checks that the requested channel type can be built and then gets a list of message actions to be chunked.","pos":[18150,18288],"source":"`BuildChannelFactory`\\<T> first checks that the requested channel type can be built and then gets a list of message actions to be chunked."},{"content":"For more information, see the following section.","pos":[18289,18337]},{"content":"It then creates a new <ph id=\"ph1\">`ChunkingChannelFactory`</ph> passing it the inner channel factory (as returned from <ph id=\"ph2\">`context.BuildInnerChannelFactory&lt;IDuplexSessionChannel&gt;`</ph>), the list of message actions, and the maximum number of chunks to buffer.","pos":[18338,18572],"source":" It then creates a new `ChunkingChannelFactory` passing it the inner channel factory (as returned from `context.BuildInnerChannelFactory<IDuplexSessionChannel>`), the list of message actions, and the maximum number of chunks to buffer."},{"content":"The maximum number of chunks comes from a property called <ph id=\"ph1\">`MaxBufferedChunks`</ph> exposed by the <ph id=\"ph2\">`ChunkingBindingElement`</ph>.","pos":[18573,18691],"source":" The maximum number of chunks comes from a property called `MaxBufferedChunks` exposed by the `ChunkingBindingElement`."},{"pos":[18698,18834],"content":"<ph id=\"ph1\">`BuildChannelListener&lt;T&gt;`</ph> has a similar implementation for creating <ph id=\"ph2\">`ChunkingChannelListener`</ph> and passing it the inner channel listener.","source":"`BuildChannelListener<T>` has a similar implementation for creating `ChunkingChannelListener` and passing it the inner channel listener."},{"content":"There is an example binding included in this sample named <ph id=\"ph1\">`TcpChunkingBinding`</ph>.","pos":[18841,18920],"source":"There is an example binding included in this sample named `TcpChunkingBinding`."},{"content":"This binding consists of two binding elements: <ph id=\"ph1\">`TcpTransportBindingElement`</ph> and <ph id=\"ph2\">`ChunkingBindingElement`</ph>.","pos":[18921,19026],"source":" This binding consists of two binding elements: `TcpTransportBindingElement` and `ChunkingBindingElement`."},{"content":"In addition to exposing the <ph id=\"ph1\">`MaxBufferedChunks`</ph> property, the binding also sets some of the <ph id=\"ph2\">`TcpTransportBindingElement`</ph> properties such as <ph id=\"ph3\">`MaxReceivedMessageSize`</ph> (sets it to <ph id=\"ph4\">`ChunkingUtils.ChunkSize`</ph> + 100KB bytes for headers).","pos":[19027,19257],"source":" In addition to exposing the `MaxBufferedChunks` property, the binding also sets some of the `TcpTransportBindingElement` properties such as `MaxReceivedMessageSize` (sets it to `ChunkingUtils.ChunkSize` + 100KB bytes for headers)."},{"pos":[19264,19453],"content":"<ph id=\"ph1\">`TcpChunkingBinding`</ph> also implements <ph id=\"ph2\">`IBindingRuntimePreferences`</ph> and returns true from the <ph id=\"ph3\">`ReceiveSynchronously`</ph> method indicating that only the synchronous Receive calls are implemented.","source":"`TcpChunkingBinding` also implements `IBindingRuntimePreferences` and returns true from the `ReceiveSynchronously` method indicating that only the synchronous Receive calls are implemented."},{"pos":[19463,19498],"content":"Determining Which Messages To Chunk","linkify":"Determining Which Messages To Chunk","nodes":[{"content":"Determining Which Messages To Chunk","pos":[0,35]}]},{"content":"The chunking channel chunks only the messages identified through the <ph id=\"ph1\">`ChunkingBehavior`</ph> attribute.","pos":[19502,19600],"source":"The chunking channel chunks only the messages identified through the `ChunkingBehavior` attribute."},{"content":"The <ph id=\"ph1\">`ChunkingBehavior`</ph> class implements <ph id=\"ph2\">`IOperationBehavior`</ph> and is implemented by calling the <ph id=\"ph3\">`AddBindingParameter`</ph> method.","pos":[19601,19725],"source":" The `ChunkingBehavior` class implements `IOperationBehavior` and is implemented by calling the `AddBindingParameter` method."},{"content":"In this method, the <ph id=\"ph1\">`ChunkingBehavior`</ph> examines the value of its <ph id=\"ph2\">`AppliesTo`</ph> property (<ph id=\"ph3\">`InMessage`</ph>, <ph id=\"ph4\">`OutMessage`</ph> or both) to determine which messages should be chunked.","pos":[19726,19894],"source":" In this method, the `ChunkingBehavior` examines the value of its `AppliesTo` property (`InMessage`, `OutMessage` or both) to determine which messages should be chunked."},{"content":"It then gets the action of each of those messages (from the Messages collection on <ph id=\"ph1\">`OperationDescription`</ph>) and adds it to a string collection contained within an instance of <ph id=\"ph2\">`ChunkingBindingParameter`</ph>.","pos":[19895,20096],"source":" It then gets the action of each of those messages (from the Messages collection on `OperationDescription`) and adds it to a string collection contained within an instance of `ChunkingBindingParameter`."},{"content":"It then adds this <ph id=\"ph1\">`ChunkingBindingParameter`</ph> to the provided <ph id=\"ph2\">`BindingParameterCollection`</ph>.","pos":[20097,20187],"source":" It then adds this `ChunkingBindingParameter` to the provided `BindingParameterCollection`."},{"content":"This <ph id=\"ph1\">`BindingParameterCollection`</ph> is passed inside the <ph id=\"ph2\">`BindingContext`</ph> to each binding element in the binding when that binding element builds the channel factory or the channel listener.","pos":[20194,20382],"source":"This `BindingParameterCollection` is passed inside the `BindingContext` to each binding element in the binding when that binding element builds the channel factory or the channel listener."},{"content":"The <ph id=\"ph1\">`ChunkingBindingElement`</ph>'s implementation of <ph id=\"ph2\">`BuildChannelFactory&lt;T&gt;`</ph> and <ph id=\"ph3\">`BuildChannelListener&lt;T&gt;`</ph> pull this <ph id=\"ph4\">`ChunkingBindingParameter`</ph> out of the <ph id=\"ph5\">`BindingContext’`</ph>s <ph id=\"ph6\">`BindingParameterCollection`</ph>.","pos":[20383,20583],"source":" The `ChunkingBindingElement`'s implementation of `BuildChannelFactory<T>` and `BuildChannelListener<T>` pull this `ChunkingBindingParameter` out of the `BindingContext’`s `BindingParameterCollection`."},{"content":"The collection of actions contained within the <ph id=\"ph1\">`ChunkingBindingParameter`</ph> is then passed to the <ph id=\"ph2\">`ChunkingChannelFactory`</ph> or <ph id=\"ph3\">`ChunkingChannelListener`</ph>, which in turn passes it to the <ph id=\"ph4\">`ChunkingDuplexSessionChannel`</ph>.","pos":[20584,20797],"source":" The collection of actions contained within the `ChunkingBindingParameter` is then passed to the `ChunkingChannelFactory` or `ChunkingChannelListener`, which in turn passes it to the `ChunkingDuplexSessionChannel`."},{"pos":[20806,20824],"content":"Running the Sample","linkify":"Running the Sample","nodes":[{"content":"Running the Sample","pos":[0,18]}]},{"pos":[20835,20871],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[20881,20979],"content":"Install <ph id=\"ph1\">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> 4.0 using the following command.","source":"Install [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 4.0 using the following command."},{"pos":[21091,21290],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[21300,21470],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[21480,21688],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"content":"Run Service.exe first, then run Client.exe and watch both console windows for output.","pos":[21698,21783]},{"content":"When running the sample, the following output is expected.","pos":[21790,21848]},{"content":"Client:","pos":[21855,21862]},{"content":"Server:","pos":[23289,23296]}]}