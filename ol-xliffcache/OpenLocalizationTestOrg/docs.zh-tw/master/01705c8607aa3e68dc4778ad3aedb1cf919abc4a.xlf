<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">01705c8607aa3e68dc4778ad3aedb1cf919abc4a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\visual-basic\programming-guide\concepts\linq\programming-with-nodes.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fa49bea11a38bfe0139cfa5880df90038cfcb175</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">25f662c4ac837ff60c67e236762eba69a9dc8aa1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Programming with Nodes (Visual Basic) | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Programming with Nodes (Visual Basic)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> developers who need to write programs such as an XML editor, a transform system, or a report writer often need to write programs that work at a finer level of granularity than elements and attributes.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>They often need to work at the node level, manipulating text nodes, processing instructions, and comments.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This topic provides some details about programming at the node level.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Node Details</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>There are a number of details of programming that a programmer working at the node level should know.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Parent Property of Children Nodes of XDocument is Set to Null</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;</ph> property contains the parent <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, not the parent node.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Child nodes of <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> have no parent <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Their parent is the document, so the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Parent%2A&gt;</ph> property for those nodes is set to null.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Adjacent Text Nodes are Possible</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In a number of XML programming models, adjacent text nodes are always merged.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is sometimes called normalization of text nodes.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> does not normalize text nodes.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you add two text nodes to the same element, it will result in adjacent text nodes.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>However, if you add content specified as a string rather than as an <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> node, <ph id="ph2">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> might merge the string with an adjacent text node.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Empty Text Nodes are Possible</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In some XML programming models, text nodes are guaranteed to not contain the empty string.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The reasoning is that such a text node has no impact on serialization of the XML.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>However, for the same reason that adjacent text nodes are possible, if you remove the text from a text node by setting its value to the empty string, the text node itself will not be deleted.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>An Empty Text Node Impacts Serialization</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If an element contains only a child text node that is empty, it is serialized with the long tag syntax: <ph id="ph1">`&lt;Child&gt;&lt;/Child&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If an element contains no child nodes whatsoever, it is serialized with the short tag syntax: <ph id="ph1">`&lt;Child /&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Namespaces are Attributes in the LINQ to XML Tree</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Even though namespace declarations have identical syntax to attributes, in some programming interfaces, such as XSLT and XPath, namespace declarations are not considered to be attributes.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, in <ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, namespaces are stored as <ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> objects in the XML tree.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you iterate through the attributes for an element that contains a namespace declaration, you will see the namespace declaration as one of the items in the returned collection.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A&gt;</ph> property indicates whether an attribute is a namespace declaration.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>XPath Axis Methods Do Not Return Child White Space of XDocument</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> allows for child text nodes of an <ph id="ph2">&lt;xref:System.Xml.Linq.XDocument&gt;</ph>, as long as the text nodes contain only white space.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>However, the XPath object model does not include white space as child nodes of a document, so when you iterate through the children of an <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> using the <ph id="ph2">&lt;xref:System.Xml.Linq.XContainer.Nodes%2A&gt;</ph> axis, white space text nodes will be returned.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>However, when you iterate through the children of an <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> using the XPath axis methods, white space text nodes will not be returned.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>XDeclaration Objects are not Nodes</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>When you iterate through the children nodes of an <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph>, you will not see the XML declaration object.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>It is a property of the document, not a child node of it.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This example produces the following output:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Advanced LINQ to XML Programming (Visual Basic)<ept id="p1">](../../../../visual-basic/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>