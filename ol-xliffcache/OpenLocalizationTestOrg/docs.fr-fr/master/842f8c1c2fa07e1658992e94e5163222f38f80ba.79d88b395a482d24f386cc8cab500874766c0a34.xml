{"content":"---\ntitle: \"Statically Compiled Queries (LINQ to XML) (C#)\"\nms.date: 07/20/2015\nms.assetid: 3bf558fe-0705-479d-86d4-00188f5fcf9c\n---\n# Statically Compiled Queries (LINQ to XML) (C#)\nOne of the most important performance benefits LINQ to XML, as opposed to <xref:System.Xml.XmlDocument>, is that queries in LINQ to XML are statically compiled, whereas XPath queries must be interpreted at run time. This feature is built in to LINQ to XML, so you do not have to perform extra steps to take advantage of it, but it is helpful to understand the distinction when choosing between the two technologies. This topic explains the difference.  \n  \n## Statically Compiled Queries vs. XPath  \n The following example shows how to get the descendant elements with a specified name, and with an attribute with a specified value.  \n  \n The following is the equivalent XPath expression:  \n  \n```  \n//Address[@Type='Shipping']  \n```  \n  \n```csharp  \nXDocument po = XDocument.Load(\"PurchaseOrders.xml\");  \n  \nIEnumerable<XElement> list1 =  \n    from el in po.Descendants(\"Address\")  \n    where (string)el.Attribute(\"Type\") == \"Shipping\"  \n    select el;  \n  \nforeach (XElement el in list1)  \n    Console.WriteLine(el);  \n```  \n  \n The query expression in this example is re-written by the compiler to method-based query syntax. The following example, which is written in method-based query syntax, produces the same results as the previous one:  \n  \n```csharp  \nXDocument po = XDocument.Load(\"PurchaseOrders.xml\");  \n  \nIEnumerable<XElement> list1 =  \n    po  \n    .Descendants(\"Address\")  \n    .Where(el => (string)el.Attribute(\"Type\") == \"Shipping\");  \n  \nforeach (XElement el in list1)  \n    Console.WriteLine(el);  \n```  \n  \n The <xref:System.Linq.Enumerable.Where%2A> method is an extension method. For more information, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md). Because <xref:System.Linq.Enumerable.Where%2A> is an extension method, the query above is compiled as though it were written as follows:  \n  \n```csharp  \nXDocument po = XDocument.Load(\"PurchaseOrders.xml\");  \n  \nIEnumerable<XElement> list1 =  \n    System.Linq.Enumerable.Where(  \n        po.Descendants(\"Address\"),  \n        el => (string)el.Attribute(\"Type\") == \"Shipping\");  \n  \nforeach (XElement el in list1)  \n    Console.WriteLine(el);  \n```  \n  \n This example produces exactly the same results as the previous two examples. This illustrates the fact that queries are effectively compiled into statically linked method calls. This, combined with the deferred execution semantics of iterators, improves performance. For more information about the deferred execution semantics of iterators, see [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).  \n  \n> [!NOTE]\n>  These examples are representative of the code that the compiler might write. The actual implementation might differ slightly from these examples, but the performance will be the same or similar to these examples.  \n  \n## Executing XPath Expressions with XmlDocument  \n The following example uses <xref:System.Xml.XmlDocument> to accomplish the same results as the previous examples:  \n  \n```csharp  \nXmlReader reader = XmlReader.Create(\"PurchaseOrders.xml\");  \nXmlDocument doc = new XmlDocument();  \ndoc.Load(reader);  \nXmlNodeList nl = doc.SelectNodes(\".//Address[@Type='Shipping']\");  \nforeach (XmlNode n in nl)  \n    Console.WriteLine(n.OuterXml);  \nreader.Close();  \n```  \n  \n This query returns the same output as the examples that use LINQ to XML; the only difference is that LINQ to XML indents the printed XML, whereas <xref:System.Xml.XmlDocument> does not.  \n  \n However, the <xref:System.Xml.XmlDocument> approach generally does not perform as well as LINQ to XML, because the <xref:System.Xml.XmlNode.SelectNodes%2A> method must do the following internally every time it is called:  \n  \n-   It parses the string that contains the XPath expression, breaking the string into tokens.  \n  \n-   It validates the tokens to make sure that the XPath expression is valid.  \n  \n-   It translates the expression into an internal expression tree.  \n  \n-   It iterates through the nodes, appropriately selecting the nodes for the result set based on the evaluation of the expression.  \n  \n This is significantly more than the work done by the corresponding LINQ to XML query. The specific performance difference varies for different types of queries, but in general LINQ to XML queries do less work, and therefore perform better, than evaluating XPath expressions using <xref:System.Xml.XmlDocument>.  \n  \n## See also\n\n- [Performance (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)\n","nodes":[{"pos":[4,128],"embed":true,"restype":"x-metadata","content":"title: \"Statically Compiled Queries (LINQ to XML) (C#)\"\nms.date: 07/20/2015\nms.assetid: 3bf558fe-0705-479d-86d4-00188f5fcf9c","nodes":[{"content":"Statically Compiled Queries (LINQ to XML) (C#)","nodes":[{"pos":[0,46],"content":"Statically Compiled Queries (LINQ to XML) (C#)","nodes":[{"content":"Statically Compiled Queries (LINQ to XML) (C#)","pos":[0,46]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[135,181],"content":"Statically Compiled Queries (LINQ to XML) (C#)","linkify":"Statically Compiled Queries (LINQ to XML) (C#)","nodes":[{"content":"Statically Compiled Queries (LINQ to XML) (C#)","pos":[0,46]}]},{"content":"One of the most important performance benefits LINQ to XML, as opposed to <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph>, is that queries in LINQ to XML are statically compiled, whereas XPath queries must be interpreted at run time.","pos":[182,397],"source":"One of the most important performance benefits LINQ to XML, as opposed to <xref:System.Xml.XmlDocument>, is that queries in LINQ to XML are statically compiled, whereas XPath queries must be interpreted at run time."},{"content":"This feature is built in to LINQ to XML, so you do not have to perform extra steps to take advantage of it, but it is helpful to understand the distinction when choosing between the two technologies.","pos":[398,597]},{"content":"This topic explains the difference.","pos":[598,633]},{"pos":[642,679],"content":"Statically Compiled Queries vs. XPath","linkify":"Statically Compiled Queries vs. XPath","nodes":[{"content":"Statically Compiled Queries vs. XPath","pos":[0,37]}]},{"content":"The following example shows how to get the descendant elements with a specified name, and with an attribute with a specified value.","pos":[683,814]},{"content":"The following is the equivalent XPath expression:","pos":[821,870]},{"content":"The query expression in this example is re-written by the compiler to method-based query syntax.","pos":[1213,1309]},{"content":"The following example, which is written in method-based query syntax, produces the same results as the previous one:","pos":[1310,1426]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> method is an extension method.","pos":[1712,1785],"source":"The <xref:System.Linq.Enumerable.Where%2A> method is an extension method."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Extension Methods<ept id=\"p1\">](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)</ept>.","pos":[1786,1911],"source":" For more information, see [Extension Methods](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)."},{"content":"Because <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.Where%2A&gt;</ph> is an extension method, the query above is compiled as though it were written as follows:","pos":[1912,2048],"source":" Because <xref:System.Linq.Enumerable.Where%2A> is an extension method, the query above is compiled as though it were written as follows:"},{"content":"This example produces exactly the same results as the previous two examples.","pos":[2365,2441]},{"content":"This illustrates the fact that queries are effectively compiled into statically linked method calls.","pos":[2442,2542]},{"content":"This, combined with the deferred execution semantics of iterators, improves performance.","pos":[2543,2631]},{"content":"For more information about the deferred execution semantics of iterators, see <bpt id=\"p1\">[</bpt>Deferred Execution and Lazy Evaluation in LINQ to XML (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)</ept>.","pos":[2632,2880],"source":" For more information about the deferred execution semantics of iterators, see [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)."},{"pos":[2888,3111],"content":"[!NOTE]\n These examples are representative of the code that the compiler might write. The actual implementation might differ slightly from these examples, but the performance will be the same or similar to these examples.","leadings":["","> "],"nodes":[{"content":"These examples are representative of the code that the compiler might write. The actual implementation might differ slightly from these examples, but the performance will be the same or similar to these examples.","pos":[9,221],"nodes":[{"content":"These examples are representative of the code that the compiler might write.","pos":[0,76]},{"content":"The actual implementation might differ slightly from these examples, but the performance will be the same or similar to these examples.","pos":[77,212]}]}]},{"pos":[3120,3164],"content":"Executing XPath Expressions with XmlDocument","linkify":"Executing XPath Expressions with XmlDocument","nodes":[{"content":"Executing XPath Expressions with XmlDocument","pos":[0,44]}]},{"pos":[3168,3281],"content":"The following example uses <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph> to accomplish the same results as the previous examples:","source":"The following example uses <xref:System.Xml.XmlDocument> to accomplish the same results as the previous examples:"},{"pos":[3580,3765],"content":"This query returns the same output as the examples that use LINQ to XML; the only difference is that LINQ to XML indents the printed XML, whereas <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph> does not.","source":"This query returns the same output as the examples that use LINQ to XML; the only difference is that LINQ to XML indents the printed XML, whereas <xref:System.Xml.XmlDocument> does not."},{"pos":[3772,3992],"content":"However, the <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph> approach generally does not perform as well as LINQ to XML, because the <ph id=\"ph2\">&lt;xref:System.Xml.XmlNode.SelectNodes%2A&gt;</ph> method must do the following internally every time it is called:","source":"However, the <xref:System.Xml.XmlDocument> approach generally does not perform as well as LINQ to XML, because the <xref:System.Xml.XmlNode.SelectNodes%2A> method must do the following internally every time it is called:"},{"content":"It parses the string that contains the XPath expression, breaking the string into tokens.","pos":[4002,4091]},{"content":"It validates the tokens to make sure that the XPath expression is valid.","pos":[4101,4173]},{"content":"It translates the expression into an internal expression tree.","pos":[4183,4245]},{"content":"It iterates through the nodes, appropriately selecting the nodes for the result set based on the evaluation of the expression.","pos":[4255,4381]},{"content":"This is significantly more than the work done by the corresponding LINQ to XML query.","pos":[4388,4473]},{"content":"The specific performance difference varies for different types of queries, but in general LINQ to XML queries do less work, and therefore perform better, than evaluating XPath expressions using <ph id=\"ph1\">&lt;xref:System.Xml.XmlDocument&gt;</ph>.","pos":[4474,4698],"source":" The specific performance difference varies for different types of queries, but in general LINQ to XML queries do less work, and therefore perform better, than evaluating XPath expressions using <xref:System.Xml.XmlDocument>."},{"pos":[4707,4715],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4719,4830],"content":"<bpt id=\"p1\">[</bpt>Performance (LINQ to XML) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)</ept>","source":"[Performance (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/performance-linq-to-xml.md)"}]}