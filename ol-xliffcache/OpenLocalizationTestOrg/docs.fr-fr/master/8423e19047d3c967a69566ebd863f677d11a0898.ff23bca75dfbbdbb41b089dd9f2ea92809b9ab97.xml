{"content":"---\ntitle: Executing Expression Trees\ndescription: Executing Expression Trees\nkeywords: .NET, .NET Core\nauthor: BillWagner\nms.author: wiwagn\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 109e0ac5-2a9c-48b4-ac68-9b6219cdbccf\n---\n\n# Executing Expression Trees\n\n[Previous -- Framework Types Supporting Expression Trees](expression-classes.md)\n\nAn *expression tree* is a data structure that represents some code.\nIt is not compiled and executable code. If you want to execute\nthe .NET code that is represented by an expression tree, you must\nconvert it into executable IL instructions. \n## Lambda Expressions to Functions\nYou can convert any LambdaExpression, or any type derived from\nLambdaExpression into executable IL. Other expression types\ncannot be directly converted into code. This restriction has\nlittle effect in practice. Lambda expressions are the only\ntypes of expressions that you would want to execute by converting\nto executable intermediate language (IL). (Think about what it would mean\nto directly execute a `ConstantExpression`. Would it mean\nanything useful?) Any expression tree that is a `LamdbaExpression`,\nor a type derived from `LambdaExpression` can be converted to IL.\nThe expression type `Expression<TDelegate>`\nis the only concrete example in the .NET Core libraries. It's used\nto represent an expression that maps to any delegate type. Because\nthis type maps to a delegate type, .NET can examine\nthe expression, and generate IL for an appropriate delegate that\nmatches the signature of the lambda expression. \n\nIn most cases, this creates a simple mapping between an expression,\nand its corresponding delegate. For example, an expression tree that\nis represented by `Expression<Func<int>>` would be converted to a delegate\nof the type `Func<int>`. For a lambda expression with any return type\nand argument list, there exists a delegate type that is the target type\nfor the executable code represented by that lamdba expression.\n\nThe `LamdbaExpression` type contains `Compile` and `CompileToMethod`\nmembers that you would use to convert an expression tree to executable\ncode. The `Compile` method creates a delegate. The `ConmpileToMethod`\nmethod updates a `MethodBuilder` object with the IL that represents\nthe compiled output of the expression tree. Note that `CompileToMethod`\nis only available on the full desktop framework, not on the \n.NET Core framework.\n\nOptionally, you can also provide a `DebugInfoGenerator` that will\nreceive the symbol debugging information for the generated delegate\nobject. This enables you to convert the expression tree into a\ndelegate object, and have full debugging information about the\ngenerated delegate.\n\nYou would convert an expression into a delegate using the following\ncode:\n\n```csharp\nExpression<Func<int>> add = () => 1 + 2;\nvar func = add.Compile(); // Create Delegate\nvar answer = func(); // Invoke Delegate\nConsole.WriteLine(answer);\n```\n\nNotice that the delegate type is based on the expression type. You must\nknow the return type and the argument list if you want to use the\ndelegate object in a strongly typed manner. The `LambdaExpression.Compile()`\nmethod returns the `Delegate` type. You will have to cast it to the correct\ndelegate type to have any compile-time tools check the argument list of\nreturn type.\n\n## Execution and Lifetimes\n\nYou execute the code by invoking the delegate created when\nyou called `LamdbaExpression.Compile()`. You can see this above where\n`add.Compile()` returns a delegate. Invoking that delegate, by calling\n`func()` executes the code.\n\nThat delegate represents the code in the expression tree. You can\nretain the handle to that delegate and invoke it later. You don't need\nto compile the expression tree each time you want to execute the code\nit represents. (Remember that expression trees are immutable, and\ncompiling the same expression tree later will create a delegate that\nexecutes the same code.)\n\nI will caution you against trying to create any more sophisticated\ncaching mechanisms to increase performance by avoiding unnecessary\ncompile calls. Comparing two arbitrary expression trees to determine\nif they represent the same algorithm will also be time consuming to\nexecute. You'll likely\nfind that the compute time you save avoiding any extra calls to\n`LambdaExpression.Compile()` will be more than consumed by the time executing\ncode that determines of two different expression trees result in\nthe same executable code.\n\n## Caveats\n\nCompiling a lambda expression to a delegate and invoking that delegate\nis one of the simplest operations you can perform with an expression\ntree. However, even with this simple operation, there are caveats\nyou must be aware of. \n\nLambda Expressions create closures over any local variables that are\nreferenced in the expression. You must guarantee that any variables\nthat would be part of the delegate are usable at the location where\nyou call `Compile`, and when you execute the resulting delegate.\n\nIn general, the compiler will ensure that this is true. However,\nif your expression accesses a variable that implements `IDisposable`,\nit's possible that your code might dispose of the object while it\nis still held by the expression tree.\n\nFor example, this code works fine, because `int` does not implement\n`IDisposable`:\n\n```csharp\nprivate static Func<int, int> CreateBoundFunc()\n{\n    var constant = 5; // constant is captured by the expression tree\n    Expression<Func<int, int>> expression = (b) => constant + b;\n    var rVal = expression.Compile();\n    return rVal;\n}\n```\n\nThe delegate has captured a reference to the local variable `constant`.\nThat variable is accessed at any time later, when the function returned\nby `CreateBoundFunc` executes.\n\nHowever, consider this (rather contrived) class that implements\n`IDisposable`:\n\n```csharp\npublic class Resource : IDisposable\n{\n    private bool isDisposed = false;\n    public int Argument\n    {\n        get\n        {\n            if (!isDisposed)\n                return 5;\n            else throw new ObjectDisposedException(\"Resource\");\n        }\n    }\n\n    public void Dispose()\n    {\n        isDisposed = true;\n    }\n}\n```\n\nIf you use it in an expression as shown below, you'll get an\n`ObjectDisposedException` when you execute the code referenced\nby the `Resource.Argument` property:\n\n```csharp\nprivate static Func<int, int> CreateBoundResource()\n{\n    using (var constant = new Resource()) // constant is captured by the expression tree\n    {\n        Expression<Func<int, int>> expression = (b) => constant.Argument + b;\n        var rVal = expression.Compile();\n        return rVal;\n    }\n}\n```\n\nThe delegate returned from this method has closed over the `constant` object,\nwhich has been disposed of. (It's been disposed, because it was declared in a\n`using` statement.) \n\nNow, when you execute the delegate returned from this method, you'll have a\n`ObjecctDisposedException` thrown at the point of execution.\n\nIt does seem strange to have a runtime error representing a compile-time\nconstruct, but that's the world we enter when we work with\nexpression trees.\n\nThere are a lot of permutations of this problem, so it's hard\nto offer general guidance to avoid it. Be careful about accessing\nlocal variables when defining expressions, and be careful about\naccessing state in the current object (represented by `this`) when\ncreating an expression tree that can be returned by a public API.\n\nThe code in your expression may reference methods or properties in\nother assemblies. That assembly must be accessible when the expression\nis defined, and when it is compiled, and when the resulting delegate\nis invoked. You'll be met with a `ReferencedAssemblyNotFoundException`\nin cases where it is not present.\n\n## Summary\n\nExpression Trees that represent lambda expressions can be compiled\nto create a delegate that you can execute. This provides one\nmechanism to execute the code represented by an expression tree.\n\nThe Expression Tree does represent the code that would execute for\nany given construct you create. As long as the environment where\nyou compile and execute the code matches the environment where you\ncreate the expression, everything works as expected. When that\ndoesn't happen, the errors are very predictable, and they will\nbe caught in your first tests of any code using the expression\ntrees.\n\n[Next -- Interpreting Expressions](expression-trees-interpreting.md)\n","nodes":[{"pos":[11,37],"content":"Executing Expression Trees","needQuote":true,"needEscape":true,"nodes":[{"content":"Executing Expression Trees","pos":[0,26]}]},{"pos":[51,77],"content":"Executing Expression Trees","needQuote":true,"needEscape":true,"nodes":[{"content":"Executing Expression Trees","pos":[0,26]}]},{"pos":[88,103],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[298,324],"content":"Executing Expression Trees","linkify":"Executing Expression Trees","nodes":[{"content":"Executing Expression Trees","pos":[0,26]}]},{"pos":[326,406],"content":"<bpt id=\"p1\">[</bpt>Previous -- Framework Types Supporting Expression Trees<ept id=\"p1\">](expression-classes.md)</ept>","source":"[Previous -- Framework Types Supporting Expression Trees](expression-classes.md)"},{"content":"An <bpt id=\"p1\">*</bpt>expression tree<ept id=\"p1\">*</ept> is a data structure that represents some code.","pos":[408,475],"source":"An *expression tree* is a data structure that represents some code."},{"content":"It is not compiled and executable code.","pos":[476,515],"source":"\nIt is not compiled and executable code."},{"content":"If you want to execute the .NET code that is represented by an expression tree, you must convert it into executable IL instructions.","pos":[516,648],"source":" If you want to execute\nthe .NET code that is represented by an expression tree, you must\nconvert it into executable IL instructions."},{"pos":[653,684],"content":"Lambda Expressions to Functions","linkify":"Lambda Expressions to Functions","nodes":[{"content":"Lambda Expressions to Functions","pos":[0,31]}]},{"content":"You can convert any LambdaExpression, or any type derived from LambdaExpression into executable IL.","pos":[685,784],"source":"You can convert any LambdaExpression, or any type derived from\nLambdaExpression into executable IL."},{"content":"Other expression types cannot be directly converted into code.","pos":[785,847],"source":" Other expression types\ncannot be directly converted into code."},{"content":"This restriction has little effect in practice.","pos":[848,895],"source":" This restriction has\nlittle effect in practice."},{"content":"Lambda expressions are the only types of expressions that you would want to execute by converting to executable intermediate language (IL).","pos":[896,1035],"source":" Lambda expressions are the only\ntypes of expressions that you would want to execute by converting\nto executable intermediate language (IL)."},{"content":"(Think about what it would mean to directly execute a <ph id=\"ph1\">`ConstantExpression`</ph>.","pos":[1036,1111],"source":" (Think about what it would mean\nto directly execute a `ConstantExpression`."},{"content":"Would it mean anything useful?) Any expression tree that is a <ph id=\"ph1\">`LamdbaExpression`</ph>, or a type derived from <ph id=\"ph2\">`LambdaExpression`</ph> can be converted to IL.","pos":[1112,1259],"source":" Would it mean\nanything useful?) Any expression tree that is a `LamdbaExpression`,\nor a type derived from `LambdaExpression` can be converted to IL."},{"content":"The expression type <ph id=\"ph1\">`Expression&lt;TDelegate&gt;`</ph> is the only concrete example in the .NET Core libraries.","pos":[1260,1360],"source":"\nThe expression type `Expression<TDelegate>`\nis the only concrete example in the .NET Core libraries."},{"content":"It's used to represent an expression that maps to any delegate type.","pos":[1361,1429],"source":" It's used\nto represent an expression that maps to any delegate type."},{"content":"Because this type maps to a delegate type, .NET can examine the expression, and generate IL for an appropriate delegate that matches the signature of the lambda expression.","pos":[1430,1602],"source":" Because\nthis type maps to a delegate type, .NET can examine\nthe expression, and generate IL for an appropriate delegate that\nmatches the signature of the lambda expression."},{"content":"In most cases, this creates a simple mapping between an expression, and its corresponding delegate.","pos":[1605,1704],"source":"In most cases, this creates a simple mapping between an expression,\nand its corresponding delegate."},{"content":"For example, an expression tree that is represented by <ph id=\"ph1\">`Expression&lt;Func&lt;int&gt;&gt;`</ph> would be converted to a delegate of the type <ph id=\"ph2\">`Func&lt;int&gt;`</ph>.","pos":[1705,1841],"source":" For example, an expression tree that\nis represented by `Expression<Func<int>>` would be converted to a delegate\nof the type `Func<int>`."},{"content":"For a lambda expression with any return type and argument list, there exists a delegate type that is the target type for the executable code represented by that lamdba expression.","pos":[1842,2021],"source":" For a lambda expression with any return type\nand argument list, there exists a delegate type that is the target type\nfor the executable code represented by that lamdba expression."},{"content":"The <ph id=\"ph1\">`LamdbaExpression`</ph> type contains <ph id=\"ph2\">`Compile`</ph> and <ph id=\"ph3\">`CompileToMethod`</ph> members that you would use to convert an expression tree to executable code.","pos":[2023,2168],"source":"The `LamdbaExpression` type contains `Compile` and `CompileToMethod`\nmembers that you would use to convert an expression tree to executable\ncode."},{"content":"The <ph id=\"ph1\">`Compile`</ph> method creates a delegate.","pos":[2169,2209],"source":" The `Compile` method creates a delegate."},{"content":"The <ph id=\"ph1\">`ConmpileToMethod`</ph> method updates a <ph id=\"ph2\">`MethodBuilder`</ph> object with the IL that represents the compiled output of the expression tree.","pos":[2210,2344],"source":" The `ConmpileToMethod`\nmethod updates a `MethodBuilder` object with the IL that represents\nthe compiled output of the expression tree."},{"content":"Note that <ph id=\"ph1\">`CompileToMethod`</ph> is only available on the full desktop framework, not on the .NET Core framework.","pos":[2345,2454],"source":" Note that `CompileToMethod`\nis only available on the full desktop framework, not on the \n.NET Core framework."},{"content":"Optionally, you can also provide a <ph id=\"ph1\">`DebugInfoGenerator`</ph> that will receive the symbol debugging information for the generated delegate object.","pos":[2456,2597],"source":"Optionally, you can also provide a `DebugInfoGenerator` that will\nreceive the symbol debugging information for the generated delegate\nobject."},{"content":"This enables you to convert the expression tree into a delegate object, and have full debugging information about the generated delegate.","pos":[2598,2735],"source":" This enables you to convert the expression tree into a\ndelegate object, and have full debugging information about the\ngenerated delegate."},{"pos":[2737,2810],"content":"You would convert an expression into a delegate using the following code:","source":"You would convert an expression into a delegate using the following\ncode:"},{"content":"Notice that the delegate type is based on the expression type.","pos":[2980,3042]},{"content":"You must know the return type and the argument list if you want to use the delegate object in a strongly typed manner.","pos":[3043,3161],"source":" You must\nknow the return type and the argument list if you want to use the\ndelegate object in a strongly typed manner."},{"content":"The <ph id=\"ph1\">`LambdaExpression.Compile()`</ph> method returns the <ph id=\"ph2\">`Delegate`</ph> type.","pos":[3162,3230],"source":" The `LambdaExpression.Compile()`\nmethod returns the `Delegate` type."},{"content":"You will have to cast it to the correct delegate type to have any compile-time tools check the argument list of return type.","pos":[3231,3355],"source":" You will have to cast it to the correct\ndelegate type to have any compile-time tools check the argument list of\nreturn type."},{"pos":[3360,3383],"content":"Execution and Lifetimes","linkify":"Execution and Lifetimes","nodes":[{"content":"Execution and Lifetimes","pos":[0,23]}]},{"content":"You execute the code by invoking the delegate created when you called <ph id=\"ph1\">`LamdbaExpression.Compile()`</ph>.","pos":[3385,3484],"source":"You execute the code by invoking the delegate created when\nyou called `LamdbaExpression.Compile()`."},{"content":"You can see this above where <ph id=\"ph1\">`add.Compile()`</ph> returns a delegate.","pos":[3485,3549],"source":" You can see this above where\n`add.Compile()` returns a delegate."},{"content":"Invoking that delegate, by calling <ph id=\"ph1\">`func()`</ph> executes the code.","pos":[3550,3612],"source":" Invoking that delegate, by calling\n`func()` executes the code."},{"content":"That delegate represents the code in the expression tree.","pos":[3614,3671]},{"content":"You can retain the handle to that delegate and invoke it later.","pos":[3672,3735],"source":" You can\nretain the handle to that delegate and invoke it later."},{"content":"You don't need to compile the expression tree each time you want to execute the code it represents.","pos":[3736,3835],"source":" You don't need\nto compile the expression tree each time you want to execute the code\nit represents."},{"content":"(Remember that expression trees are immutable, and compiling the same expression tree later will create a delegate that executes the same code.)","pos":[3836,3980],"source":" (Remember that expression trees are immutable, and\ncompiling the same expression tree later will create a delegate that\nexecutes the same code.)"},{"content":"I will caution you against trying to create any more sophisticated caching mechanisms to increase performance by avoiding unnecessary compile calls.","pos":[3982,4130],"source":"I will caution you against trying to create any more sophisticated\ncaching mechanisms to increase performance by avoiding unnecessary\ncompile calls."},{"content":"Comparing two arbitrary expression trees to determine if they represent the same algorithm will also be time consuming to execute.","pos":[4131,4261],"source":" Comparing two arbitrary expression trees to determine\nif they represent the same algorithm will also be time consuming to\nexecute."},{"content":"You'll likely find that the compute time you save avoiding any extra calls to <ph id=\"ph1\">`LambdaExpression.Compile()`</ph> will be more than consumed by the time executing code that determines of two different expression trees result in the same executable code.","pos":[4262,4508],"source":" You'll likely\nfind that the compute time you save avoiding any extra calls to\n`LambdaExpression.Compile()` will be more than consumed by the time executing\ncode that determines of two different expression trees result in\nthe same executable code."},{"pos":[4513,4520],"content":"Caveats","linkify":"Caveats","nodes":[{"content":"Caveats","pos":[0,7]}]},{"content":"Compiling a lambda expression to a delegate and invoking that delegate is one of the simplest operations you can perform with an expression tree.","pos":[4522,4667],"source":"Compiling a lambda expression to a delegate and invoking that delegate\nis one of the simplest operations you can perform with an expression\ntree."},{"content":"However, even with this simple operation, there are caveats you must be aware of.","pos":[4668,4749],"source":" However, even with this simple operation, there are caveats\nyou must be aware of."},{"content":"Lambda Expressions create closures over any local variables that are referenced in the expression.","pos":[4752,4850],"source":"Lambda Expressions create closures over any local variables that are\nreferenced in the expression."},{"content":"You must guarantee that any variables that would be part of the delegate are usable at the location where you call <ph id=\"ph1\">`Compile`</ph>, and when you execute the resulting delegate.","pos":[4851,5021],"source":" You must guarantee that any variables\nthat would be part of the delegate are usable at the location where\nyou call `Compile`, and when you execute the resulting delegate."},{"content":"In general, the compiler will ensure that this is true.","pos":[5023,5078]},{"content":"However, if your expression accesses a variable that implements <ph id=\"ph1\">`IDisposable`</ph>, it's possible that your code might dispose of the object while it is still held by the expression tree.","pos":[5079,5261],"source":" However,\nif your expression accesses a variable that implements `IDisposable`,\nit's possible that your code might dispose of the object while it\nis still held by the expression tree."},{"pos":[5263,5345],"content":"For example, this code works fine, because <ph id=\"ph1\">`int`</ph> does not implement <ph id=\"ph2\">`IDisposable`</ph>:","source":"For example, this code works fine, because `int` does not implement\n`IDisposable`:"},{"content":"The delegate has captured a reference to the local variable <ph id=\"ph1\">`constant`</ph>.","pos":[5602,5673],"source":"The delegate has captured a reference to the local variable `constant`."},{"content":"That variable is accessed at any time later, when the function returned by <ph id=\"ph1\">`CreateBoundFunc`</ph> executes.","pos":[5674,5776],"source":"\nThat variable is accessed at any time later, when the function returned\nby `CreateBoundFunc` executes."},{"pos":[5778,5856],"content":"However, consider this (rather contrived) class that implements <ph id=\"ph1\">`IDisposable`</ph>:","source":"However, consider this (rather contrived) class that implements\n`IDisposable`:"},{"pos":[6203,6363],"content":"If you use it in an expression as shown below, you'll get an <ph id=\"ph1\">`ObjectDisposedException`</ph> when you execute the code referenced by the <ph id=\"ph2\">`Resource.Argument`</ph> property:","source":"If you use it in an expression as shown below, you'll get an\n`ObjectDisposedException` when you execute the code referenced\nby the `Resource.Argument` property:"},{"content":"The delegate returned from this method has closed over the <ph id=\"ph1\">`constant`</ph> object, which has been disposed of.","pos":[6677,6782],"source":"The delegate returned from this method has closed over the `constant` object,\nwhich has been disposed of."},{"content":"(It's been disposed, because it was declared in a <ph id=\"ph1\">`using`</ph> statement.)","pos":[6783,6852],"source":" (It's been disposed, because it was declared in a\n`using` statement.)"},{"pos":[6855,6991],"content":"Now, when you execute the delegate returned from this method, you'll have a <ph id=\"ph1\">`ObjecctDisposedException`</ph> thrown at the point of execution.","source":"Now, when you execute the delegate returned from this method, you'll have a\n`ObjecctDisposedException` thrown at the point of execution."},{"pos":[6993,7142],"content":"It does seem strange to have a runtime error representing a compile-time construct, but that's the world we enter when we work with expression trees.","source":"It does seem strange to have a runtime error representing a compile-time\nconstruct, but that's the world we enter when we work with\nexpression trees."},{"content":"There are a lot of permutations of this problem, so it's hard to offer general guidance to avoid it.","pos":[7144,7244],"source":"There are a lot of permutations of this problem, so it's hard\nto offer general guidance to avoid it."},{"content":"Be careful about accessing local variables when defining expressions, and be careful about accessing state in the current object (represented by <ph id=\"ph1\">`this`</ph>) when creating an expression tree that can be returned by a public API.","pos":[7245,7468],"source":" Be careful about accessing\nlocal variables when defining expressions, and be careful about\naccessing state in the current object (represented by `this`) when\ncreating an expression tree that can be returned by a public API."},{"content":"The code in your expression may reference methods or properties in other assemblies.","pos":[7470,7554],"source":"The code in your expression may reference methods or properties in\nother assemblies."},{"content":"That assembly must be accessible when the expression is defined, and when it is compiled, and when the resulting delegate is invoked.","pos":[7555,7688],"source":" That assembly must be accessible when the expression\nis defined, and when it is compiled, and when the resulting delegate\nis invoked."},{"content":"You'll be met with a <ph id=\"ph1\">`ReferencedAssemblyNotFoundException`</ph> in cases where it is not present.","pos":[7689,7781],"source":" You'll be met with a `ReferencedAssemblyNotFoundException`\nin cases where it is not present."},{"pos":[7786,7793],"content":"Summary","linkify":"Summary","nodes":[{"content":"Summary","pos":[0,7]}]},{"content":"Expression Trees that represent lambda expressions can be compiled to create a delegate that you can execute.","pos":[7795,7904],"source":"Expression Trees that represent lambda expressions can be compiled\nto create a delegate that you can execute."},{"content":"This provides one mechanism to execute the code represented by an expression tree.","pos":[7905,7987],"source":" This provides one\nmechanism to execute the code represented by an expression tree."},{"content":"The Expression Tree does represent the code that would execute for any given construct you create.","pos":[7989,8087],"source":"The Expression Tree does represent the code that would execute for\nany given construct you create."},{"content":"As long as the environment where you compile and execute the code matches the environment where you create the expression, everything works as expected.","pos":[8088,8240],"source":" As long as the environment where\nyou compile and execute the code matches the environment where you\ncreate the expression, everything works as expected."},{"content":"When that doesn't happen, the errors are very predictable, and they will be caught in your first tests of any code using the expression trees.","pos":[8241,8383],"source":" When that\ndoesn't happen, the errors are very predictable, and they will\nbe caught in your first tests of any code using the expression\ntrees."},{"pos":[8385,8453],"content":"<bpt id=\"p1\">[</bpt>Next -- Interpreting Expressions<ept id=\"p1\">](expression-trees-interpreting.md)</ept>","source":"[Next -- Interpreting Expressions](expression-trees-interpreting.md)"}]}