{"content":"---\ntitle: What's New in C# 6 | C# Guide\ndescription: Learn the new features in C# Version 6    \nkeywords: .NET, .NET Core\nauthor: BillWagner\n\nms.date: 09/22/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 4d879f69-f889-4d3f-a781-75194e143400\n---\n\n# What's New in C# 6\n\nThe 6.0 release of C# contained many features that improve\nproductivity for developers. Features in this release include:\n\n* [Read-only Auto-properties](#read-only-auto-properties):\n    - You can create read-only auto-properties that can be set only in constructors.\n* [Auto-Property Initializers](#auto-property-initializers):\n    - You can write initialization expressions to set the initial value of an auto-property.\n* [Expression-bodied function members](#expression-bodied-function-members):\n    - You can author one-line methods using lambda expressions.\n* [using static](#using-static):\n    - You can import all the methods of a single class into the current namespace.\n* [Null - conditional operators](#null-conditional-operators):\n    - You can concisely and safely access members of an object while still checking for null with the null conditional operator.\n* [String Interpolation](#string-interpolation):\n    - You can write string formatting expressions using inline expressions instead of positional arguments.\n* [Exception filters](#exception-filters):\n    - You can catch expressions based on properties of the exception or other program state. \n* [nameof Expressions](#nameof-expressions):\n    - You can let the compiler generate string representations of symbols.\n* [await in catch and finally blocks](#await-in-catch-and-finally-blocks):\n    - You can use `await` expressions in locations that previously disallowed them.\n* [index initializers](#index-initializers):\n    - You can author initialization expressions for associative containers as well as sequence containers.\n* [Extension methods for collection initializers](#extension-add-methods-in-collection-initializers):\n    - Collection initializers can rely on accessible extension methods, in addition to member methods.\n* [Improved overload resolution](#improved-overload-resolution):\n    - Some constructs that previously generated ambiguous method calls now resolve correctly.\n\nThe overall effect of these features is that you write more concise code\nthat is also more readable. The syntax contains less ceremony for many\ncommon practices. It's easier to see the design intent with less\nceremony. Learn these features well, and you'll be more productive,\nwrite more readable code, and concentrate more on your core features\nthan on the constructs of the language.\n\nThe remainder of this topic provides details on each of these features.\n\n## Auto-Property enhancements \n\nThe syntax for automatically implemented properties (usually referred to as 'auto-properties')\nmade it very easy to create properties\nthat had simple get and set accessors:\n\n[!code-csharp[ClassicAutoProperty](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicAutoProperty)]\n\nHowever, this simple syntax limited the kinds of designs you could support using\nauto-properties. C# 6 improves the auto-properties capabilities so that you can use\nthem in more scenarios. You won't need to fall back on the more verbose syntax of\ndeclaring and manipulating the backing field by hand so often.\n\nThe new syntax addresses scenarios for read only properties, and for initializing\nthe variable storage behind an auto-property.\n\n### Read-only auto-properties\n\n*Read-only auto-properties* provide a more concise syntax to create\nimmutable types. The closest you could get to immutable types\nin earlier versions of C# was to declare private setters:\n\n[!code-csharp[ClassicReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicReadOnlyAutoProperty)]\n \nUsing this syntax, the compiler doesn't ensure that the type really is immutable. It only\nenforces that the `FirstName` and `LastName` properties are not modified from any\ncode outside the class.\n\nRead-only auto-properties enable true read-only behavior. You declare the auto-property\nwith only a get accessor:\n\n[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]\n\nThe `FirstName` and `LastName` properties can be set only in the body of a constructor:\n\n[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]\n\nTrying to set `LastName` in another method generates a `CS0200` compilation error:\n\n```csharp\npublic class Student\n{\n    public string LastName { get;  }\n\n    public void ChangeName(string newLastName)\n    {\n        // Generates CS 0200: Property or indexer cannot be assigned to -- it is read only\n        LastName = newLastName;\n    }\n}\n```\n\nThis feature enables true language support for creating immutable types and using\nthe more concise and convenient auto-property syntax.\n\n### Auto-Property Initializers\n\n*Auto-Property Initializers* let you declare the initial value for\nan auto-property as part of the property declaration.  In earlier versions,\nthese properties would need to have setters and you would need\nto use that setter to initialize the data storage used by the backing\nfield. Consider this class for a student that contains the name and a\nlist of the student's grades:\n\n[!code-csharp[Construction](../../../samples/snippets/csharp/new-in-6/oldcode.cs#Construction)]\n \nAs this class grows, you may include other constructors. Each constructor\nneeds to initialize this field, or you'll introduce errors.\n\nC# 6 enables you to assign an initial value for the storage used by an\nauto-property in the auto-property declaration:\n\n[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]\n\nThe `Grades` member is initialized where it is declared. That makes it\neasier to perform the initialization exactly once. The initialization\nis part of the property declaration, making it easier to equate the\nstorage allocation with public interface for `Student` objects.\n\nProperty Initializers can be used with read/write properties as well\nas read only properties, as shown here.\n\n[!code-csharp[ReadWriteInitialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadWriteInitialization)]\n\n## Expression-bodied function members\n\nThe body of a lot of members that we write consist of only one statement\nthat can be represented as an expression. You can reduce that syntax by\nwriting an expression-bodied member instead. It works for methods and\nread-only properties.\" For example, an override of `ToString()` is often\na great candidate:\n\n[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]\n\nYou can also use expression-bodied members in read only properties as well:\n\n[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]\n\n## using static\n\nThe *using static* enhancement enables you to import the static methods\nof a single class. Previously, the `using` statement imported all types\nin a namespace. \n\nOften we use a class' static methods throughout our code. Repeatedly\ntyping the class name can obscure the meaning of your code. A common\nexample is when you write classes that perform many numeric calculations.\nYour code will be littered with @System.Math.Sin, @System.Math.Sqrt and other calls\nto different methods in the @System.Math class. The new `using static` syntax can make these\nclasses much cleaner to read. You specify the class you're using:\n\n[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]\n\nAnd now, you can use any static method in the @System.Math class without\nqualifying the @System.Math class. The @System.Math class is a great use case for\nthis feature because it does not contain any\ninstance methods. You can also use `using static` to import a\nclass' static methods for a class that has both static\nand instance methods. One of the most useful examples is @System.String:\n\n[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]\n\n> [!NOTE]\n> You must use the fully qualified class name, `System.String`\n> in a static using statement. \n> You cannot use the `string` keyword instead. \n\nYou can now call static methods defined in the @System.String class without\nqualifying those methods as members of that class:\n\n[!code-csharp[UsingStaticString](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticString)]\n\nThe `static using` feature and extension methods interact in\ninteresting ways, and the language design included some rules\nthat specifically address those interactions. The goal is to\nminimize any chances of breaking changes in existing codebases,\nincluding yours.\n\nExtension methods are only in scope when called using the\nextension method invocation syntax, not when called as a static method.\nYou'll often see this in LINQ queries. You can import the LINQ pattern\nby importing @System.Linq.Enumerable. \n\n[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]\n\nThis imports all the methods in the @System.Linq.Enumerable class.\nHowever, the extension methods are only in scope when called as extension\nmethods. They are not in scope if they are called using the static method\nsyntax:\n\n[!code-csharp[UsingStaticLinqMethod](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticLinkMethod)]\n\nThis decision is because extension methods are typically called using\nextension method invocation expressions. In the rare case where they are\ncalled using the static method call syntax it is to resolve ambiguity.\nRequiring the class name as part of the invocation seems wise.\n\nThere's one last feature of `static using`. The `static using` directive\nalso imports any nested types. That enables you to reference any nested\ntypes without qualification.\n\n## Null-conditional operators\n\nNull values complicate code. You need to check every access\nof variables to ensure you are not dereferencing `null`. The\n*null conditional operator* makes those checks much easier\nand fluid.\n\nSimply replace the member access `.` with `?.`:\n\n[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]\n\nIn the preceding example, the variable `first` is assigned `null` if the person object\nis `null`. Otherwise, it gets assigned the value of the `FirstName` property. Most importantly,\nthe `?.` means that this line of code does not generate a `NullReferenceException` when\nthe `person` variable is `null`. Instead, it short-circuits and produces `null`.\n\nAlso, note that this expression returns a `string`, regardless of the value of `person`.\nIn the case of short circuiting, the `null` value returned is typed to match the full\nexpression.\n\nYou can often use this construct with the *null coalescing* operator to assign\ndefault values when one of the properties are `null`:\n\n[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]\n\nThe right hand side operand of the `?.` operator is not limited to properties or fields.\nYou can also use it to conditionally invoke methods. The most common use of member functions\n with the null conditional operator is to safely invoke delegates\n(or event handlers) that may be `null`.  You'll do this by calling the delegate's `Invoke` method\nusing the `?.` operator to access the member. You can see an example in the  \n[delegate patterns](../delegates-patterns.md#handling-null-delegates) topic.\n\nThe rules of the `?.` operator ensure that the left-hand side of the operator is\nevaluated only once. This is important and enables many idioms, including the\nexample using event handlers. Let's start with the event handler usage. In previous\nversions of C#, you were encouraged to write code like this:\n\n```csharp\nvar handler = this.SomethingHappened;\nif (handler != null)\n    handler(this, eventArgs);\n```\n\nThis was preferred over a simpler syntax:\n\n```csharp\n// Not recommended\nif (this.SomethingHappened != null)\n    this.SomethingHappened(this, eventArgs);\n```\n\n> [!IMPORTANT]\n> The preceding example introduces a race condition. The `SomethingHappened`\n> event may have subscribers when checked against `null`, and those subscribers\n> may have been removed before the event is raised. That would cause \n> a @System.NullReferenceException to be thrown.\n\nIn this second version, the `SomethingHappened` event handler might\nbe non-null when tested, but if other code removes a handler,\nit could still be null when the event handler was called.\n\nThe compiler generates code for the `?.` operator that ensures\nthe left side (`this.SomethingHappened`) of the `?.` expression is evaluated once, and the result\nis cached:\n\n```csharp\n// preferred in C# 6:\nthis.SomethingHappened?.Invoke(this, eventArgs);\n```\n\nEnsuring that the left side is evaluated only once also enables you\nto use any expression, including method calls, on the left side of the\n`?.` Even if these have side-effects, they are evaluated once, so the\nside effects occur only once. You can see an example in our content\non [events](../events-overview.md#language-support-for-events).\n\n## String Interpolation\n\nC# 6 contains new syntax for composing strings from a format string\nand expressions that can be evaluated to produce other string values.\n\nTraditionally, you needed to use positional parameters in a method\nlike `string.Format`:\n\n[!code-csharp[stringFormat](../../../samples/snippets/csharp/new-in-6/oldcode.cs#stringFormat)]\n\nWith C# 6, the new string interpolation feature enables you to embed\nthe expressions in the format string. Simple preface the string with\n`$`:\n\n[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]\n\nThis initial example used variable expressions for the substituted\nexpressions. You can expand on this syntax to use any expression. For\nexample, you could compute a student's grade point average as part of\nthe interpolation:\n\n[!code-csharp[stringInterpolationExpression](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationExpression)]\n\nRunning the preceding example, you would find that the output for `Grades.Average()`\nmight have more decimal places than you would like. The string interpolation\nsyntax supports all the format strings available using earlier formatting\nmethods. You add the format strings inside the braces. Add a `:` following\nthe expression to format:\n\n[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]\n\nThe preceding line of code will format the value for `Grades.Average()` as\na floating-point number with two decimal places.\n\nThe `:` is always interpreted as the separator between the expression\nbeing formatted and the format string. This can introduce problems when\nyour expression uses a `:` in another way, such as a conditional operator:\n\n```csharp\npublic string GetGradePointPercentages() =>\n    $\"Name: {LastName}, {FirstName}. G.P.A: {Grades.Any() ? Grades.Average() : double.NaN:F2}\";\n```\n\nIn the preceding example, the `:` is parsed as the beginning of the format string, not part\nof the conditional operator. In all cases where this happens, you can\nsurround the expression with parentheses to force the compiler to interpret\nthe expression as you intend:\n\n[!code-csharp[stringInterpolationConditional](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationConditional)]\n\nThere aren't any limitations on the expressions you can place between\nthe braces. You can execute a complex LINQ query inside an interpolated\nstring to perform computations and display the result:\n\n[!code-csharp[stringInterpolationLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationLinq)]\n\nYou can see from this sample that you can even nest a string interpolation\nexpression inside another string interpolation expression. This example\nis very likely more complex than you would want in production code.\nRather, it is illustrative of the breadth of the feature. Any C# expression\ncan be placed between the curly braces of an interpolated string.\n\n### String interpolation and specific cultures\n\nAll the examples shown in the preceding section will format the strings using the current\nculture and language on the machine where the code executes. Often you\nmay need to format the string produced using a specific culture.\nThe object produced from a string interpolation is a type that has an\nimplicit conversion to either @System.String or @System.FormattableString.\n\nThe @System.FormattableString type contains the format string, and the results\nof evaluating the arguments before converting them to strings. You can\nuse public methods of @System.FormattableString to specify the culture when\nformatting a string. For example, the following will produce a string\nusing German as the language and culture. (It will use the ',' character\nfor the decimal separator,\nand the '.' character as the thousands separator.)\n\n```csharp\nFormattableString str = @\"Average grade is {s.Grades.Average()}\";\nvar gradeStr = string.Format(null, \n    System.Globalization.CultureInfo.CreateSpecificCulture(\"de-de\"),\n    str.GetFormat(), str.GetArguments());\n```\n\n> [!NOTE]\n> The preceding example is not supported in .NET Core version 1.0.1. It is\n> only supported in the .NET Framework.\n\nIn general, string interpolation expressions produce strings as their\noutput. However, when you want greater control over the culture used to\nformat the string, you can specify a specific output.  If this is a capability\nyou often need, you can create convenience methods, as extension methods,\nto enable easy formatting with specific cultures.\n\n## Exception Filters\n\nAnother new feature in C# 6 is *exception filters*. Exception Filters\nare clauses that determine when a given catch clause should be applied.\nIf the expression used for an exception filter evaluates to `true`, the\ncatch clause performs its normal processing on an exception. If the\nexpression evaluates to `false`, then the `catch` clause is skipped.\n\nOne use is to examine information about an exception to determine if a\n`catch` clause can process the exception:\n\n[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]\n\nThe code generated by exception filters provides better information about\nan exception that is thrown and not processed. Before exception filters\nwere added to the language, you would need to create code like the following:\n\n[!code-csharp[ExceptionFilterOld](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilterOld)]\n\nThe point where the exception is thrown changes between these two examples.\nIn the previous code, where a `throw` clause is used, any stack trace\nanalysis or examination of crash dumps will show that the exception was\nthrown from the `throw` statement in your catch clause. The actual exception\nobject will contain the original call stack, but all other information\nabout any variables in the call stack between this throw point and the\nlocation of the original throw point has been lost. \n\nContrast that with how the code using an exception filter is processed:\nthe exception filter expression evaluates to `false`. Therefore, execution never\nenters the `catch` clause. Because the `catch` clause does not execute,\nno stack unwinding takes place. That means the original\nthrow location is preserved for any debugging activities that would take\nplace later.\n\nWhenever you need to evaluate fields or properties of an exception, instead\nof relying solely on the exception type, use an exception filter to\npreserve more debugging information.\n\nAnother recommended pattern with exception filters is to use them for\nlogging routines. This usage also leverages the manner in which the exception\nthrow point is preserved when an exception filter evaluates to `false`.\n\nA logging method would be a method whose argument is the exception that\nunconditionally returns `false`:\n\n[!code-csharp[ExceptionFilterLogging](../../../samples/snippets/csharp/new-in-6/ExceptionFilterHelpers.cs#ExceptionFilterLogging)]\n\nWhenever you want to log an exception, you can add a catch clause, and\nuse this method as the exception filter:\n\n[!code-csharp[LogException](../../../samples/snippets/csharp/new-in-6/program.cs#LogException)]\n\nThe exceptions are never caught, because the `LogException` method always\nreturns `false`. That always false exception filter means that you can\nplace this logging handler before any other exception handlers:\n\n[!code-csharp[LogExceptionRecovery](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionRecovery)]\n\nThe preceding example highlights a very important facet of exception filters.\nThe exception filters enable scenarios where a more general exception\ncatch clause may appear before a more specific one. It's also possible\nto have the same exception type appear in multiple catch clauses:\n\n[!code-csharp[HandleNotChanged](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#HandleNotChanged)]\n\nAnother recommended pattern helps prevent catch clauses from processing\nexceptions when a debugger is attached. This technique enables you to\nrun an application with the debugger, and stop execution when an exception\nis thrown.\n\nIn your code, add an exception filter so that any recovery code executes\nonly when a debugger is not attached:\n\n[!code-csharp[LogExceptionDebugger](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionDebugger)]\n\nAfter adding this in code, you set your debugger to break on all unhandled\nexceptions. Run the program under the debugger, and the debugger breaks\nwhenever `PerformFailingOperation()` throws a `RecoverableException`.\nThe debugger breaks your program, because the catch clause won't be executed\ndue to the false-returning exception filter.\n\n## `nameof` Expressions\n\nThe `nameof` expression evaluates to the name of a symbol. It's a great\nway to get tools working whenever you need the name of a variable,\na property, or a member field.\n\nOne of the most common uses for `nameof` is to provide the name of a symbol\nthat caused an exception:\n\n[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]\n\nAnother use is with XAML based applications that implement the `INotifyPropertyChanged`\ninterface:\n\n[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]\n\nThe advantage of using the `nameof` operator over a constant string is\nthat tools can understand the symbol. If you use refactoring tools to\nrename the symbol, it will rename it in the `nameof` expression. Constant\nstrings don't have that advantage. Try it yourself in your favorite editor:\nrename a variable, and any `nameof` expressions will update as well.\n\nThe `nameof` expression produces the unqualified name of its argument\n(`LastName` in the previous examples) even if you use the fully qualified\nname for the argument:\n\n[!code-csharp[QualifiedNameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#QualifiedNameofNotify)]\n\nThis `nameof` expression produces `FirstName`, not `UXComponents.ViewModel.FirstName`.\n\n## Await in Catch and Finally blocks\n\nC# 5 had several limitations around where you could place `await` expressions.\nOne of those has been removed in C# 6. You can now use `await` in `catch`\nor `finally` expressions. \n\nThe addition of await expressions in catch and finally blocks may appear\nto complicate how those are processed. Let's add an example to discuss\nhow this appears. In any async method, you can use an await expression\nin a finally clause.\n\nWith C# 6, you can also await in catch expressions. This is most often\nused with logging scenarios:\n\n[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]\n\nThe implementation details for adding `await` support inside `catch`\nand `finally` clauses ensures that the behavior is consistent with the\nbehavior for synchronous code. When code executed in a `catch` or `finally`\nclause throws, execution looks for a suitable `catch` clause in the next\nsurrounding block. If there was a current exception, that exception is\nlost. The same happens with awaited expressions in `catch` and `finally`\nclauses: a suitable `catch` is searched for, and the current exception,\nif any, is lost.  \n\n> [!NOTE]\n> This behavior is the reason it's recommended to write `catch` and `finally`\n> clauses carefully, to avoid introducing new exceptions.\n\n## Index Initializers\n\n*Index Initializers* is one of two features that make collection\ninitializers more consistent. In earlier releases of C#, you could use\n*collection initializers* only with sequence style collections:\n\n[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#ListInitializer)]\n\nNow, you can also use them with @System.Collections.Generic.Dictionary collections and similar types:\n\n[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]\n\nThis feature means that associative containers can be initialized using\nsyntax similar to what's been in place for sequence containers for several\nversions.\n\n### Extension `Add` methods in collection initializers\n\nAnother feature that makes collection initialization easier is the ability\nto use an *extension method* for the `Add` method. This feature was\nadded for parity with Visual Basic. \n\nThe feature is most useful when you have a custom collection class that\nhas a method with a different name to semantically add new items.\n\nFor example, consider a collection of students like this:\n\n[!code-csharp[Enrollment](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)]\n\nThe `Enroll` method adds a student. But it doesn't follow the `Add` pattern.\nIn previous versions of C#, you could not use collection initializers with an\n`Enrollment` object:\n\n[!code-csharp[InitializeEnrollment](../../../samples/snippets/csharp/new-in-6/classList.cs#InitializeEnrollment)]\n\nNow you can, but only if you create an extension method that maps `Add` to\n`Enroll`:\n\n[!code-csharp[ExtensionAdd](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAdd)]\n\nWhat you are doing with this feature is to map whatever method adds\nitems to a collection to a method named `Add` by creating an\nextension method: \n\n[!code-csharp[Enrollment](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)]\n[!code-csharp[ExtensionAddSample](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAddSample)]\n\n## Improved overload resolution\n\nThis last feature is one you probably won't notice. There were constructs\nwhere the previous version of the C# compiler may have found some method\ncalls involving lambda expressions ambiguous. Consider this method:\n\n[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]\n\nIn earlier versions of C#, calling that method using the method group\nsyntax would fail:\n\n[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]\n \nThe earlier compiler could not distinguish correctly between `Task.Run(Action)`\nand `Task.Run(Func<Task>())`. In previous versions, you'd need to use\na lambda expression as an argument:\n\n[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]\n\nThe C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is\na better choice.\n","nodes":[{"pos":[4,292],"embed":true,"restype":"x-metadata","content":"title: What's New in C# 6 | C# Guide\ndescription: Learn the new features in C# Version 6    \nkeywords: .NET, .NET Core\nauthor: BillWagner\n\nms.date: 09/22/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: 4d879f69-f889-4d3f-a781-75194e143400","nodes":[{"content":"What's New in C# 6 | C# Guide","nodes":[{"pos":[0,29],"content":"What's New in C# 6 | C# Guide","nodes":[{"content":"What's New in C# 6 | C# Guide","pos":[0,29]}]}],"path":["title"]},{"content":"Learn the new features in C# Version 6","nodes":[{"pos":[0,38],"content":"Learn the new features in C# Version 6","nodes":[{"content":"Learn the new features in C# Version 6","pos":[0,38]}]}],"path":["description"]},{"content":".NET, .NET Core","nodes":[{"pos":[0,15],"content":".NET, .NET Core","nodes":[{"content":".NET, .NET Core","pos":[0,15]}]}],"path":["keywords"]}],"yml":true},{"pos":[300,318],"content":"What's New in C# 6","linkify":"What's New in C# 6","nodes":[{"content":"What's New in C# 6","pos":[0,18]}]},{"content":"The 6.0 release of C# contained many features that improve productivity for developers.","pos":[320,407],"source":"The 6.0 release of C# contained many features that improve\nproductivity for developers."},{"content":"Features in this release include:","pos":[408,441]},{"pos":[445,501],"content":"<bpt id=\"p1\">[</bpt>Read-only Auto-properties<ept id=\"p1\">](#read-only-auto-properties)</ept>:","source":"[Read-only Auto-properties](#read-only-auto-properties):"},{"content":"You can create read-only auto-properties that can be set only in constructors.","pos":[508,586]},{"pos":[589,647],"content":"<bpt id=\"p1\">[</bpt>Auto-Property Initializers<ept id=\"p1\">](#auto-property-initializers)</ept>:","source":"[Auto-Property Initializers](#auto-property-initializers):"},{"content":"You can write initialization expressions to set the initial value of an auto-property.","pos":[654,740]},{"pos":[743,817],"content":"<bpt id=\"p1\">[</bpt>Expression-bodied function members<ept id=\"p1\">](#expression-bodied-function-members)</ept>:","source":"[Expression-bodied function members](#expression-bodied-function-members):"},{"content":"You can author one-line methods using lambda expressions.","pos":[824,881]},{"pos":[884,914],"content":"<bpt id=\"p1\">[</bpt>using static<ept id=\"p1\">](#using-static)</ept>:","source":"[using static](#using-static):"},{"content":"You can import all the methods of a single class into the current namespace.","pos":[921,997]},{"pos":[1000,1060],"content":"<bpt id=\"p1\">[</bpt>Null - conditional operators<ept id=\"p1\">](#null-conditional-operators)</ept>:","source":"[Null - conditional operators](#null-conditional-operators):"},{"content":"You can concisely and safely access members of an object while still checking for null with the null conditional operator.","pos":[1067,1189]},{"pos":[1192,1238],"content":"<bpt id=\"p1\">[</bpt>String Interpolation<ept id=\"p1\">](#string-interpolation)</ept>:","source":"[String Interpolation](#string-interpolation):"},{"content":"You can write string formatting expressions using inline expressions instead of positional arguments.","pos":[1245,1346]},{"pos":[1349,1389],"content":"<bpt id=\"p1\">[</bpt>Exception filters<ept id=\"p1\">](#exception-filters)</ept>:","source":"[Exception filters](#exception-filters):"},{"content":"You can catch expressions based on properties of the exception or other program state.","pos":[1396,1482]},{"pos":[1486,1528],"content":"<bpt id=\"p1\">[</bpt>nameof Expressions<ept id=\"p1\">](#nameof-expressions)</ept>:","source":"[nameof Expressions](#nameof-expressions):"},{"content":"You can let the compiler generate string representations of symbols.","pos":[1535,1603]},{"pos":[1606,1678],"content":"<bpt id=\"p1\">[</bpt>await in catch and finally blocks<ept id=\"p1\">](#await-in-catch-and-finally-blocks)</ept>:","source":"[await in catch and finally blocks](#await-in-catch-and-finally-blocks):"},{"pos":[1685,1762],"content":"You can use <ph id=\"ph1\">`await`</ph> expressions in locations that previously disallowed them.","source":"You can use `await` expressions in locations that previously disallowed them."},{"pos":[1765,1807],"content":"<bpt id=\"p1\">[</bpt>index initializers<ept id=\"p1\">](#index-initializers)</ept>:","source":"[index initializers](#index-initializers):"},{"content":"You can author initialization expressions for associative containers as well as sequence containers.","pos":[1814,1914]},{"pos":[1917,2016],"content":"<bpt id=\"p1\">[</bpt>Extension methods for collection initializers<ept id=\"p1\">](#extension-add-methods-in-collection-initializers)</ept>:","source":"[Extension methods for collection initializers](#extension-add-methods-in-collection-initializers):"},{"content":"Collection initializers can rely on accessible extension methods, in addition to member methods.","pos":[2023,2119]},{"pos":[2122,2184],"content":"<bpt id=\"p1\">[</bpt>Improved overload resolution<ept id=\"p1\">](#improved-overload-resolution)</ept>:","source":"[Improved overload resolution](#improved-overload-resolution):"},{"content":"Some constructs that previously generated ambiguous method calls now resolve correctly.","pos":[2191,2278]},{"content":"The overall effect of these features is that you write more concise code that is also more readable.","pos":[2280,2380],"source":"The overall effect of these features is that you write more concise code\nthat is also more readable."},{"content":"The syntax contains less ceremony for many common practices.","pos":[2381,2441],"source":" The syntax contains less ceremony for many\ncommon practices."},{"content":"It's easier to see the design intent with less ceremony.","pos":[2442,2498],"source":" It's easier to see the design intent with less\nceremony."},{"content":"Learn these features well, and you'll be more productive, write more readable code, and concentrate more on your core features than on the constructs of the language.","pos":[2499,2665],"source":" Learn these features well, and you'll be more productive,\nwrite more readable code, and concentrate more on your core features\nthan on the constructs of the language."},{"content":"The remainder of this topic provides details on each of these features.","pos":[2667,2738]},{"pos":[2743,2769],"content":"Auto-Property enhancements","linkify":"Auto-Property enhancements","nodes":[{"content":"Auto-Property enhancements","pos":[0,26]}]},{"pos":[2772,2944],"content":"The syntax for automatically implemented properties (usually referred to as 'auto-properties') made it very easy to create properties that had simple get and set accessors:","source":"The syntax for automatically implemented properties (usually referred to as 'auto-properties')\nmade it very easy to create properties\nthat had simple get and set accessors:"},{"pos":[2946,3055],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ClassicAutoProperty<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicAutoProperty)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ClassicAutoProperty](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicAutoProperty)]"},{"content":"However, this simple syntax limited the kinds of designs you could support using auto-properties.","pos":[3057,3154],"source":"However, this simple syntax limited the kinds of designs you could support using\nauto-properties."},{"content":"C# 6 improves the auto-properties capabilities so that you can use them in more scenarios.","pos":[3155,3245],"source":" C# 6 improves the auto-properties capabilities so that you can use\nthem in more scenarios."},{"content":"You won't need to fall back on the more verbose syntax of declaring and manipulating the backing field by hand so often.","pos":[3246,3366],"source":" You won't need to fall back on the more verbose syntax of\ndeclaring and manipulating the backing field by hand so often."},{"pos":[3368,3495],"content":"The new syntax addresses scenarios for read only properties, and for initializing the variable storage behind an auto-property.","source":"The new syntax addresses scenarios for read only properties, and for initializing\nthe variable storage behind an auto-property."},{"pos":[3501,3526],"content":"Read-only auto-properties","linkify":"Read-only auto-properties","nodes":[{"content":"Read-only auto-properties","pos":[0,25]}]},{"content":"<bpt id=\"p1\">*</bpt>Read-only auto-properties<ept id=\"p1\">*</ept> provide a more concise syntax to create immutable types.","pos":[3528,3612],"source":"*Read-only auto-properties* provide a more concise syntax to create\nimmutable types."},{"content":"The closest you could get to immutable types in earlier versions of C# was to declare private setters:","pos":[3613,3715],"source":" The closest you could get to immutable types\nin earlier versions of C# was to declare private setters:"},{"pos":[3717,3842],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ClassicReadOnlyAutoProperty<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicReadOnlyAutoProperty)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ClassicReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicReadOnlyAutoProperty)]"},{"content":"Using this syntax, the compiler doesn't ensure that the type really is immutable.","pos":[3845,3926]},{"content":"It only enforces that the <ph id=\"ph1\">`FirstName`</ph> and <ph id=\"ph2\">`LastName`</ph> properties are not modified from any code outside the class.","pos":[3927,4040],"source":" It only\nenforces that the `FirstName` and `LastName` properties are not modified from any\ncode outside the class."},{"content":"Read-only auto-properties enable true read-only behavior.","pos":[4042,4099]},{"content":"You declare the auto-property with only a get accessor:","pos":[4100,4155],"source":" You declare the auto-property\nwith only a get accessor:"},{"pos":[4157,4268],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ReadOnlyAutoProperty<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]"},{"pos":[4270,4357],"content":"The <ph id=\"ph1\">`FirstName`</ph> and <ph id=\"ph2\">`LastName`</ph> properties can be set only in the body of a constructor:","source":"The `FirstName` and `LastName` properties can be set only in the body of a constructor:"},{"pos":[4359,4492],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ReadOnlyAutoPropertyConstructor<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]"},{"pos":[4494,4576],"content":"Trying to set <ph id=\"ph1\">`LastName`</ph> in another method generates a <ph id=\"ph2\">`CS0200`</ph> compilation error:","source":"Trying to set `LastName` in another method generates a `CS0200` compilation error:"},{"pos":[4838,4973],"content":"This feature enables true language support for creating immutable types and using the more concise and convenient auto-property syntax.","source":"This feature enables true language support for creating immutable types and using\nthe more concise and convenient auto-property syntax."},{"pos":[4979,5005],"content":"Auto-Property Initializers","linkify":"Auto-Property Initializers","nodes":[{"content":"Auto-Property Initializers","pos":[0,26]}]},{"content":"<bpt id=\"p1\">*</bpt>Auto-Property Initializers<ept id=\"p1\">*</ept> let you declare the initial value for an auto-property as part of the property declaration.","pos":[5007,5127],"source":"*Auto-Property Initializers* let you declare the initial value for\nan auto-property as part of the property declaration."},{"content":"In earlier versions, these properties would need to have setters and you would need to use that setter to initialize the data storage used by the backing field.","pos":[5129,5289],"source":"  In earlier versions,\nthese properties would need to have setters and you would need\nto use that setter to initialize the data storage used by the backing\nfield."},{"content":"Consider this class for a student that contains the name and a list of the student's grades:","pos":[5290,5382],"source":" Consider this class for a student that contains the name and a\nlist of the student's grades:"},{"pos":[5384,5479],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Construction<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#Construction)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Construction](../../../samples/snippets/csharp/new-in-6/oldcode.cs#Construction)]"},{"content":"As this class grows, you may include other constructors.","pos":[5482,5538]},{"content":"Each constructor needs to initialize this field, or you'll introduce errors.","pos":[5539,5615],"source":" Each constructor\nneeds to initialize this field, or you'll introduce errors."},{"pos":[5617,5735],"content":"C# 6 enables you to assign an initial value for the storage used by an auto-property in the auto-property declaration:","source":"C# 6 enables you to assign an initial value for the storage used by an\nauto-property in the auto-property declaration:"},{"pos":[5737,5836],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Initialization<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]"},{"content":"The <ph id=\"ph1\">`Grades`</ph> member is initialized where it is declared.","pos":[5838,5894],"source":"The `Grades` member is initialized where it is declared."},{"content":"That makes it easier to perform the initialization exactly once.","pos":[5895,5959],"source":" That makes it\neasier to perform the initialization exactly once."},{"content":"The initialization is part of the property declaration, making it easier to equate the storage allocation with public interface for <ph id=\"ph1\">`Student`</ph> objects.","pos":[5960,6110],"source":" The initialization\nis part of the property declaration, making it easier to equate the\nstorage allocation with public interface for `Student` objects."},{"pos":[6112,6220],"content":"Property Initializers can be used with read/write properties as well as read only properties, as shown here.","source":"Property Initializers can be used with read/write properties as well\nas read only properties, as shown here."},{"pos":[6222,6339],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ReadWriteInitialization<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadWriteInitialization)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ReadWriteInitialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadWriteInitialization)]"},{"pos":[6344,6378],"content":"Expression-bodied function members","linkify":"Expression-bodied function members","nodes":[{"content":"Expression-bodied function members","pos":[0,34]}]},{"content":"The body of a lot of members that we write consist of only one statement that can be represented as an expression.","pos":[6380,6494],"source":"The body of a lot of members that we write consist of only one statement\nthat can be represented as an expression."},{"content":"You can reduce that syntax by writing an expression-bodied member instead.","pos":[6495,6569],"source":" You can reduce that syntax by\nwriting an expression-bodied member instead."},{"content":"It works for methods and read-only properties.\"","pos":[6570,6617],"source":" It works for methods and\nread-only properties.\""},{"content":"For example, an override of <ph id=\"ph1\">`ToString()`</ph> is often a great candidate:","pos":[6618,6686],"source":" For example, an override of `ToString()` is often\na great candidate:"},{"pos":[6688,6807],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ToStringExpressionMember<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]"},{"content":"You can also use expression-bodied members in read only properties as well:","pos":[6809,6884]},{"pos":[6886,7005],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>FullNameExpressionMember<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]"},{"pos":[7010,7022],"content":"using static","linkify":"using static","nodes":[{"content":"using static","pos":[0,12]}]},{"content":"The <bpt id=\"p1\">*</bpt>using static<ept id=\"p1\">*</ept> enhancement enables you to import the static methods of a single class.","pos":[7024,7114],"source":"The *using static* enhancement enables you to import the static methods\nof a single class."},{"content":"Previously, the <ph id=\"ph1\">`using`</ph> statement imported all types in a namespace.","pos":[7115,7183],"source":" Previously, the `using` statement imported all types\nin a namespace."},{"content":"Often we use a class' static methods throughout our code.","pos":[7186,7243]},{"content":"Repeatedly typing the class name can obscure the meaning of your code.","pos":[7244,7314],"source":" Repeatedly\ntyping the class name can obscure the meaning of your code."},{"content":"A common example is when you write classes that perform many numeric calculations.","pos":[7315,7397],"source":" A common\nexample is when you write classes that perform many numeric calculations."},{"content":"Your code will be littered with <ph id=\"ph1\">@System.Math.Sin</ph>, <ph id=\"ph2\">@System.Math.Sqrt</ph> and other calls to different methods in the <ph id=\"ph3\">@System.Math</ph> class.","pos":[7398,7529],"source":"\nYour code will be littered with @System.Math.Sin, @System.Math.Sqrt and other calls\nto different methods in the @System.Math class."},{"content":"The new <ph id=\"ph1\">`using static`</ph> syntax can make these classes much cleaner to read.","pos":[7530,7604],"source":" The new `using static` syntax can make these\nclasses much cleaner to read."},{"content":"You specify the class you're using:","pos":[7605,7640]},{"pos":[7642,7743],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UsingStaticMath<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]"},{"content":"And now, you can use any static method in the <ph id=\"ph1\">@System.Math</ph> class without qualifying the <ph id=\"ph2\">@System.Math</ph> class.","pos":[7745,7852],"source":"And now, you can use any static method in the @System.Math class without\nqualifying the @System.Math class."},{"content":"The <ph id=\"ph1\">@System.Math</ph> class is a great use case for this feature because it does not contain any instance methods.","pos":[7853,7962],"source":" The @System.Math class is a great use case for\nthis feature because it does not contain any\ninstance methods."},{"content":"You can also use <ph id=\"ph1\">`using static`</ph> to import a class' static methods for a class that has both static and instance methods.","pos":[7963,8083],"source":" You can also use `using static` to import a\nclass' static methods for a class that has both static\nand instance methods."},{"content":"One of the most useful examples is <ph id=\"ph1\">@System.String:</ph>","pos":[8084,8134],"source":" One of the most useful examples is @System.String:"},{"pos":[8136,8229],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UsingStatic<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]"},{"pos":[8233,8382],"content":"[!NOTE]\nYou must use the fully qualified class name, `System.String`\nin a static using statement. \nYou cannot use the `string` keyword instead.","leadings":["","> ","> ","> "],"nodes":[{"content":"You must use the fully qualified class name, `System.String`\nin a static using statement. \nYou cannot use the `string` keyword instead.","pos":[8,143],"nodes":[{"content":"You must use the fully qualified class name, <ph id=\"ph1\">`System.String`</ph> in a static using statement.","pos":[0,89],"source":"You must use the fully qualified class name, `System.String`\nin a static using statement."},{"content":"You cannot use the <ph id=\"ph1\">`string`</ph> keyword instead.","pos":[90,135],"source":" \nYou cannot use the `string` keyword instead."}]}]},{"pos":[8385,8511],"content":"You can now call static methods defined in the <ph id=\"ph1\">@System.String</ph> class without qualifying those methods as members of that class:","source":"You can now call static methods defined in the @System.String class without\nqualifying those methods as members of that class:"},{"pos":[8513,8618],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UsingStaticString<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticString)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UsingStaticString](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticString)]"},{"content":"The <ph id=\"ph1\">`static using`</ph> feature and extension methods interact in interesting ways, and the language design included some rules that specifically address those interactions.","pos":[8620,8788],"source":"The `static using` feature and extension methods interact in\ninteresting ways, and the language design included some rules\nthat specifically address those interactions."},{"content":"The goal is to minimize any chances of breaking changes in existing codebases, including yours.","pos":[8789,8884],"source":" The goal is to\nminimize any chances of breaking changes in existing codebases,\nincluding yours."},{"content":"Extension methods are only in scope when called using the extension method invocation syntax, not when called as a static method.","pos":[8886,9015],"source":"Extension methods are only in scope when called using the\nextension method invocation syntax, not when called as a static method."},{"content":"You'll often see this in LINQ queries.","pos":[9016,9054],"source":"\nYou'll often see this in LINQ queries."},{"content":"You can import the LINQ pattern by importing <ph id=\"ph1\">@System.Linq.Enumerable</ph>.","pos":[9055,9124],"source":" You can import the LINQ pattern\nby importing @System.Linq.Enumerable."},{"pos":[9127,9228],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UsingStaticLinq<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]"},{"content":"This imports all the methods in the <ph id=\"ph1\">@System.Linq.Enumerable</ph> class.","pos":[9230,9296],"source":"This imports all the methods in the @System.Linq.Enumerable class."},{"content":"However, the extension methods are only in scope when called as extension methods.","pos":[9297,9379],"source":"\nHowever, the extension methods are only in scope when called as extension\nmethods."},{"content":"They are not in scope if they are called using the static method syntax:","pos":[9380,9452],"source":" They are not in scope if they are called using the static method\nsyntax:"},{"pos":[9454,9567],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>UsingStaticLinqMethod<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticLinkMethod)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[UsingStaticLinqMethod](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticLinkMethod)]"},{"content":"This decision is because extension methods are typically called using extension method invocation expressions.","pos":[9569,9679],"source":"This decision is because extension methods are typically called using\nextension method invocation expressions."},{"content":"In the rare case where they are called using the static method call syntax it is to resolve ambiguity.","pos":[9680,9782],"source":" In the rare case where they are\ncalled using the static method call syntax it is to resolve ambiguity."},{"content":"Requiring the class name as part of the invocation seems wise.","pos":[9783,9845],"source":"\nRequiring the class name as part of the invocation seems wise."},{"content":"There's one last feature of <ph id=\"ph1\">`static using`</ph>.","pos":[9847,9890],"source":"There's one last feature of `static using`."},{"content":"The <ph id=\"ph1\">`static using`</ph> directive also imports any nested types.","pos":[9891,9950],"source":" The `static using` directive\nalso imports any nested types."},{"content":"That enables you to reference any nested types without qualification.","pos":[9951,10020],"source":" That enables you to reference any nested\ntypes without qualification."},{"pos":[10025,10051],"content":"Null-conditional operators","linkify":"Null-conditional operators","nodes":[{"content":"Null-conditional operators","pos":[0,26]}]},{"content":"Null values complicate code.","pos":[10053,10081]},{"content":"You need to check every access of variables to ensure you are not dereferencing <ph id=\"ph1\">`null`</ph>.","pos":[10082,10169],"source":" You need to check every access\nof variables to ensure you are not dereferencing `null`."},{"content":"The <bpt id=\"p1\">*</bpt>null conditional operator<ept id=\"p1\">*</ept> makes those checks much easier and fluid.","pos":[10170,10243],"source":" The\n*null conditional operator* makes those checks much easier\nand fluid."},{"pos":[10245,10292],"content":"Simply replace the member access <ph id=\"ph1\">`.`</ph> with <ph id=\"ph2\">`?.`</ph>:","source":"Simply replace the member access `.` with `?.`:"},{"pos":[10294,10395],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>NullConditional<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]"},{"content":"In the preceding example, the variable <ph id=\"ph1\">`first`</ph> is assigned <ph id=\"ph2\">`null`</ph> if the person object is <ph id=\"ph3\">`null`</ph>.","pos":[10397,10494],"source":"In the preceding example, the variable `first` is assigned `null` if the person object\nis `null`."},{"content":"Otherwise, it gets assigned the value of the <ph id=\"ph1\">`FirstName`</ph> property.","pos":[10495,10561],"source":" Otherwise, it gets assigned the value of the `FirstName` property."},{"content":"Most importantly, the <ph id=\"ph1\">`?.`</ph> means that this line of code does not generate a <ph id=\"ph2\">`NullReferenceException`</ph> when the <ph id=\"ph3\">`person`</ph> variable is <ph id=\"ph4\">`null`</ph>.","pos":[10562,10700],"source":" Most importantly,\nthe `?.` means that this line of code does not generate a `NullReferenceException` when\nthe `person` variable is `null`."},{"content":"Instead, it short-circuits and produces <ph id=\"ph1\">`null`</ph>.","pos":[10701,10748],"source":" Instead, it short-circuits and produces `null`."},{"content":"Also, note that this expression returns a <ph id=\"ph1\">`string`</ph>, regardless of the value of <ph id=\"ph2\">`person`</ph>.","pos":[10750,10838],"source":"Also, note that this expression returns a `string`, regardless of the value of `person`."},{"content":"In the case of short circuiting, the <ph id=\"ph1\">`null`</ph> value returned is typed to match the full expression.","pos":[10839,10936],"source":"\nIn the case of short circuiting, the `null` value returned is typed to match the full\nexpression."},{"pos":[10938,11070],"content":"You can often use this construct with the <bpt id=\"p1\">*</bpt>null coalescing<ept id=\"p1\">*</ept> operator to assign default values when one of the properties are <ph id=\"ph1\">`null`</ph>:","source":"You can often use this construct with the *null coalescing* operator to assign\ndefault values when one of the properties are `null`:"},{"pos":[11072,11171],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>NullCoalescing<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]"},{"content":"The right hand side operand of the <ph id=\"ph1\">`?.`</ph> operator is not limited to properties or fields.","pos":[11173,11261],"source":"The right hand side operand of the `?.` operator is not limited to properties or fields."},{"content":"You can also use it to conditionally invoke methods.","pos":[11262,11314],"source":"\nYou can also use it to conditionally invoke methods."},{"content":"The most common use of member functions with the null conditional operator is to safely invoke delegates (or event handlers) that may be <ph id=\"ph1\">`null`</ph>.","pos":[11315,11460],"source":" The most common use of member functions\n with the null conditional operator is to safely invoke delegates\n(or event handlers) that may be `null`."},{"content":"You'll do this by calling the delegate's <ph id=\"ph1\">`Invoke`</ph> method using the <ph id=\"ph2\">`?.`</ph> operator to access the member.","pos":[11462,11564],"source":"  You'll do this by calling the delegate's `Invoke` method\nusing the `?.` operator to access the member."},{"content":"You can see an example in the","pos":[11565,11594]},{"content":"<bpt id=\"p1\">[</bpt>delegate patterns<ept id=\"p1\">](../delegates-patterns.md#handling-null-delegates)</ept> topic.","pos":[11597,11673],"source":"[delegate patterns](../delegates-patterns.md#handling-null-delegates) topic."},{"content":"The rules of the <ph id=\"ph1\">`?.`</ph> operator ensure that the left-hand side of the operator is evaluated only once.","pos":[11675,11776],"source":"The rules of the `?.` operator ensure that the left-hand side of the operator is\nevaluated only once."},{"content":"This is important and enables many idioms, including the example using event handlers.","pos":[11777,11863],"source":" This is important and enables many idioms, including the\nexample using event handlers."},{"content":"Let's start with the event handler usage.","pos":[11864,11905]},{"content":"In previous versions of C#, you were encouraged to write code like this:","pos":[11906,11978],"source":" In previous\nversions of C#, you were encouraged to write code like this:"},{"content":"This was preferred over a simpler syntax:","pos":[12084,12125]},{"pos":[12244,12532],"content":"[!IMPORTANT]\nThe preceding example introduces a race condition. The `SomethingHappened`\nevent may have subscribers when checked against `null`, and those subscribers\nmay have been removed before the event is raised. That would cause \na @System.NullReferenceException to be thrown.","leadings":["","> ","> ","> ","> "],"nodes":[{"content":"The preceding example introduces a race condition. The `SomethingHappened`\nevent may have subscribers when checked against `null`, and those subscribers\nmay have been removed before the event is raised. That would cause \na @System.NullReferenceException to be thrown.","pos":[13,280],"nodes":[{"content":"The preceding example introduces a race condition.","pos":[0,50]},{"content":"The <ph id=\"ph1\">`SomethingHappened`</ph> event may have subscribers when checked against <ph id=\"ph2\">`null`</ph>, and those subscribers may have been removed before the event is raised.","pos":[51,202],"source":" The `SomethingHappened`\nevent may have subscribers when checked against `null`, and those subscribers\nmay have been removed before the event is raised."},{"content":"That would cause a <ph id=\"ph1\">@System.NullReferenceException</ph> to be thrown.","pos":[203,267],"source":" That would cause \na @System.NullReferenceException to be thrown."}]}]},{"pos":[12534,12721],"content":"In this second version, the <ph id=\"ph1\">`SomethingHappened`</ph> event handler might be non-null when tested, but if other code removes a handler, it could still be null when the event handler was called.","source":"In this second version, the `SomethingHappened` event handler might\nbe non-null when tested, but if other code removes a handler,\nit could still be null when the event handler was called."},{"pos":[12723,12894],"content":"The compiler generates code for the <ph id=\"ph1\">`?.`</ph> operator that ensures the left side (<ph id=\"ph2\">`this.SomethingHappened`</ph>) of the <ph id=\"ph3\">`?.`</ph> expression is evaluated once, and the result is cached:","source":"The compiler generates code for the `?.` operator that ensures\nthe left side (`this.SomethingHappened`) of the `?.` expression is evaluated once, and the result\nis cached:"},{"content":"Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the <ph id=\"ph1\">`?.`</ph> Even if these have side-effects, they are evaluated once, so the side effects occur only once.","pos":[12982,13220],"source":"Ensuring that the left side is evaluated only once also enables you\nto use any expression, including method calls, on the left side of the\n`?.` Even if these have side-effects, they are evaluated once, so the\nside effects occur only once."},{"content":"You can see an example in our content on <bpt id=\"p1\">[</bpt>events<ept id=\"p1\">](../events-overview.md#language-support-for-events)</ept>.","pos":[13221,13322],"source":" You can see an example in our content\non [events](../events-overview.md#language-support-for-events)."},{"pos":[13327,13347],"content":"String Interpolation","linkify":"String Interpolation","nodes":[{"content":"String Interpolation","pos":[0,20]}]},{"pos":[13349,13486],"content":"C# 6 contains new syntax for composing strings from a format string and expressions that can be evaluated to produce other string values.","source":"C# 6 contains new syntax for composing strings from a format string\nand expressions that can be evaluated to produce other string values."},{"pos":[13488,13576],"content":"Traditionally, you needed to use positional parameters in a method like <ph id=\"ph1\">`string.Format`</ph>:","source":"Traditionally, you needed to use positional parameters in a method\nlike `string.Format`:"},{"pos":[13578,13673],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>stringFormat<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/oldcode.cs#stringFormat)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[stringFormat](../../../samples/snippets/csharp/new-in-6/oldcode.cs#stringFormat)]"},{"content":"With C# 6, the new string interpolation feature enables you to embed the expressions in the format string.","pos":[13675,13781],"source":"With C# 6, the new string interpolation feature enables you to embed\nthe expressions in the format string."},{"content":"Simple preface the string with <ph id=\"ph1\">`$`</ph>:","pos":[13782,13817],"source":" Simple preface the string with\n`$`:"},{"pos":[13819,13933],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>stringInterpolation<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]"},{"content":"This initial example used variable expressions for the substituted expressions.","pos":[13935,14014],"source":"This initial example used variable expressions for the substituted\nexpressions."},{"content":"You can expand on this syntax to use any expression.","pos":[14015,14067]},{"content":"For example, you could compute a student's grade point average as part of the interpolation:","pos":[14068,14160],"source":" For\nexample, you could compute a student's grade point average as part of\nthe interpolation:"},{"pos":[14162,14291],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>stringInterpolationExpression<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationExpression)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[stringInterpolationExpression](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationExpression)]"},{"content":"Running the preceding example, you would find that the output for <ph id=\"ph1\">`Grades.Average()`</ph> might have more decimal places than you would like.","pos":[14293,14429],"source":"Running the preceding example, you would find that the output for `Grades.Average()`\nmight have more decimal places than you would like."},{"content":"The string interpolation syntax supports all the format strings available using earlier formatting methods.","pos":[14430,14537],"source":" The string interpolation\nsyntax supports all the format strings available using earlier formatting\nmethods."},{"content":"You add the format strings inside the braces.","pos":[14538,14583]},{"content":"Add a <ph id=\"ph1\">`:`</ph> following the expression to format:","pos":[14584,14629],"source":" Add a `:` following\nthe expression to format:"},{"pos":[14631,14752],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>stringInterpolationFormat<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]"},{"pos":[14754,14877],"content":"The preceding line of code will format the value for <ph id=\"ph1\">`Grades.Average()`</ph> as a floating-point number with two decimal places.","source":"The preceding line of code will format the value for `Grades.Average()` as\na floating-point number with two decimal places."},{"content":"The <ph id=\"ph1\">`:`</ph> is always interpreted as the separator between the expression being formatted and the format string.","pos":[14879,14987],"source":"The `:` is always interpreted as the separator between the expression\nbeing formatted and the format string."},{"content":"This can introduce problems when your expression uses a <ph id=\"ph1\">`:`</ph> in another way, such as a conditional operator:","pos":[14988,15095],"source":" This can introduce problems when\nyour expression uses a `:` in another way, such as a conditional operator:"},{"content":"In the preceding example, the <ph id=\"ph1\">`:`</ph> is parsed as the beginning of the format string, not part of the conditional operator.","pos":[15252,15372],"source":"In the preceding example, the `:` is parsed as the beginning of the format string, not part\nof the conditional operator."},{"content":"In all cases where this happens, you can surround the expression with parentheses to force the compiler to interpret the expression as you intend:","pos":[15373,15519],"source":" In all cases where this happens, you can\nsurround the expression with parentheses to force the compiler to interpret\nthe expression as you intend:"},{"pos":[15521,15652],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>stringInterpolationConditional<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationConditional)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[stringInterpolationConditional](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationConditional)]"},{"content":"There aren't any limitations on the expressions you can place between the braces.","pos":[15654,15735],"source":"There aren't any limitations on the expressions you can place between\nthe braces."},{"content":"You can execute a complex LINQ query inside an interpolated string to perform computations and display the result:","pos":[15736,15850],"source":" You can execute a complex LINQ query inside an interpolated\nstring to perform computations and display the result:"},{"pos":[15852,15969],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>stringInterpolationLinq<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationLinq)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[stringInterpolationLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationLinq)]"},{"content":"You can see from this sample that you can even nest a string interpolation expression inside another string interpolation expression.","pos":[15971,16104],"source":"You can see from this sample that you can even nest a string interpolation\nexpression inside another string interpolation expression."},{"content":"This example is very likely more complex than you would want in production code.","pos":[16105,16185],"source":" This example\nis very likely more complex than you would want in production code."},{"content":"Rather, it is illustrative of the breadth of the feature.","pos":[16186,16243],"source":"\nRather, it is illustrative of the breadth of the feature."},{"content":"Any C# expression can be placed between the curly braces of an interpolated string.","pos":[16244,16327],"source":" Any C# expression\ncan be placed between the curly braces of an interpolated string."},{"pos":[16333,16375],"content":"String interpolation and specific cultures","linkify":"String interpolation and specific cultures","nodes":[{"content":"String interpolation and specific cultures","pos":[0,42]}]},{"content":"All the examples shown in the preceding section will format the strings using the current culture and language on the machine where the code executes.","pos":[16377,16527],"source":"All the examples shown in the preceding section will format the strings using the current\nculture and language on the machine where the code executes."},{"content":"Often you may need to format the string produced using a specific culture.","pos":[16528,16602],"source":" Often you\nmay need to format the string produced using a specific culture."},{"content":"The object produced from a string interpolation is a type that has an implicit conversion to either <ph id=\"ph1\">@System.String</ph> or <ph id=\"ph2\">@System.FormattableString</ph>.","pos":[16603,16747],"source":"\nThe object produced from a string interpolation is a type that has an\nimplicit conversion to either @System.String or @System.FormattableString."},{"content":"The <ph id=\"ph1\">@System.FormattableString</ph> type contains the format string, and the results of evaluating the arguments before converting them to strings.","pos":[16749,16890],"source":"The @System.FormattableString type contains the format string, and the results\nof evaluating the arguments before converting them to strings."},{"content":"You can use public methods of <ph id=\"ph1\">@System.FormattableString</ph> to specify the culture when formatting a string.","pos":[16891,16995],"source":" You can\nuse public methods of @System.FormattableString to specify the culture when\nformatting a string."},{"content":"For example, the following will produce a string using German as the language and culture.","pos":[16996,17086],"source":" For example, the following will produce a string\nusing German as the language and culture."},{"content":"(It will use the ',' character for the decimal separator, and the '.' character as the thousands separator.)","pos":[17087,17195],"source":" (It will use the ',' character\nfor the decimal separator,\nand the '.' character as the thousands separator.)"},{"pos":[17427,17549],"content":"[!NOTE]\nThe preceding example is not supported in .NET Core version 1.0.1. It is\nonly supported in the .NET Framework.","leadings":["","> ","> "],"nodes":[{"content":"The preceding example is not supported in .NET Core version 1.0.1. It is\nonly supported in the .NET Framework.","pos":[8,118],"nodes":[{"content":"The preceding example is not supported in .NET Core version 1.0.1.","pos":[0,66]},{"content":"It is only supported in the .NET Framework.","pos":[67,110],"source":" It is\nonly supported in the .NET Framework."}]}]},{"content":"In general, string interpolation expressions produce strings as their output.","pos":[17551,17628],"source":"In general, string interpolation expressions produce strings as their\noutput."},{"content":"However, when you want greater control over the culture used to format the string, you can specify a specific output.","pos":[17629,17746],"source":" However, when you want greater control over the culture used to\nformat the string, you can specify a specific output."},{"content":"If this is a capability you often need, you can create convenience methods, as extension methods, to enable easy formatting with specific cultures.","pos":[17748,17895],"source":"  If this is a capability\nyou often need, you can create convenience methods, as extension methods,\nto enable easy formatting with specific cultures."},{"pos":[17900,17917],"content":"Exception Filters","linkify":"Exception Filters","nodes":[{"content":"Exception Filters","pos":[0,17]}]},{"content":"Another new feature in C# 6 is <bpt id=\"p1\">*</bpt>exception filters<ept id=\"p1\">*</ept>.","pos":[17919,17970],"source":"Another new feature in C# 6 is *exception filters*."},{"content":"Exception Filters are clauses that determine when a given catch clause should be applied.","pos":[17971,18060],"source":" Exception Filters\nare clauses that determine when a given catch clause should be applied."},{"content":"If the expression used for an exception filter evaluates to <ph id=\"ph1\">`true`</ph>, the catch clause performs its normal processing on an exception.","pos":[18061,18193],"source":"\nIf the expression used for an exception filter evaluates to `true`, the\ncatch clause performs its normal processing on an exception."},{"content":"If the expression evaluates to <ph id=\"ph1\">`false`</ph>, then the <ph id=\"ph2\">`catch`</ph> clause is skipped.","pos":[18194,18269],"source":" If the\nexpression evaluates to `false`, then the `catch` clause is skipped."},{"pos":[18271,18383],"content":"One use is to examine information about an exception to determine if a <ph id=\"ph1\">`catch`</ph> clause can process the exception:","source":"One use is to examine information about an exception to determine if a\n`catch` clause can process the exception:"},{"pos":[18385,18492],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExceptionFilter<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]"},{"content":"The code generated by exception filters provides better information about an exception that is thrown and not processed.","pos":[18494,18614],"source":"The code generated by exception filters provides better information about\nan exception that is thrown and not processed."},{"content":"Before exception filters were added to the language, you would need to create code like the following:","pos":[18615,18717],"source":" Before exception filters\nwere added to the language, you would need to create code like the following:"},{"pos":[18719,18832],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExceptionFilterOld<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilterOld)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ExceptionFilterOld](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilterOld)]"},{"content":"The point where the exception is thrown changes between these two examples.","pos":[18834,18909]},{"content":"In the previous code, where a <ph id=\"ph1\">`throw`</ph> clause is used, any stack trace analysis or examination of crash dumps will show that the exception was thrown from the <ph id=\"ph2\">`throw`</ph> statement in your catch clause.","pos":[18910,19107],"source":"\nIn the previous code, where a `throw` clause is used, any stack trace\nanalysis or examination of crash dumps will show that the exception was\nthrown from the `throw` statement in your catch clause."},{"content":"The actual exception object will contain the original call stack, but all other information about any variables in the call stack between this throw point and the location of the original throw point has been lost.","pos":[19108,19322],"source":" The actual exception\nobject will contain the original call stack, but all other information\nabout any variables in the call stack between this throw point and the\nlocation of the original throw point has been lost."},{"content":"Contrast that with how the code using an exception filter is processed: the exception filter expression evaluates to <ph id=\"ph1\">`false`</ph>.","pos":[19325,19450],"source":"Contrast that with how the code using an exception filter is processed:\nthe exception filter expression evaluates to `false`."},{"content":"Therefore, execution never enters the <ph id=\"ph1\">`catch`</ph> clause.","pos":[19451,19504],"source":" Therefore, execution never\nenters the `catch` clause."},{"content":"Because the <ph id=\"ph1\">`catch`</ph> clause does not execute, no stack unwinding takes place.","pos":[19505,19581],"source":" Because the `catch` clause does not execute,\nno stack unwinding takes place."},{"content":"That means the original throw location is preserved for any debugging activities that would take place later.","pos":[19582,19691],"source":" That means the original\nthrow location is preserved for any debugging activities that would take\nplace later."},{"pos":[19693,19873],"content":"Whenever you need to evaluate fields or properties of an exception, instead of relying solely on the exception type, use an exception filter to preserve more debugging information.","source":"Whenever you need to evaluate fields or properties of an exception, instead\nof relying solely on the exception type, use an exception filter to\npreserve more debugging information."},{"content":"Another recommended pattern with exception filters is to use them for logging routines.","pos":[19875,19962],"source":"Another recommended pattern with exception filters is to use them for\nlogging routines."},{"content":"This usage also leverages the manner in which the exception throw point is preserved when an exception filter evaluates to <ph id=\"ph1\">`false`</ph>.","pos":[19963,20094],"source":" This usage also leverages the manner in which the exception\nthrow point is preserved when an exception filter evaluates to `false`."},{"pos":[20096,20200],"content":"A logging method would be a method whose argument is the exception that unconditionally returns <ph id=\"ph1\">`false`</ph>:","source":"A logging method would be a method whose argument is the exception that\nunconditionally returns `false`:"},{"pos":[20202,20332],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExceptionFilterLogging<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/ExceptionFilterHelpers.cs#ExceptionFilterLogging)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ExceptionFilterLogging](../../../samples/snippets/csharp/new-in-6/ExceptionFilterHelpers.cs#ExceptionFilterLogging)]"},{"pos":[20334,20445],"content":"Whenever you want to log an exception, you can add a catch clause, and use this method as the exception filter:","source":"Whenever you want to log an exception, you can add a catch clause, and\nuse this method as the exception filter:"},{"pos":[20447,20542],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>LogException<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/program.cs#LogException)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[LogException](../../../samples/snippets/csharp/new-in-6/program.cs#LogException)]"},{"content":"The exceptions are never caught, because the <ph id=\"ph1\">`LogException`</ph> method always returns <ph id=\"ph2\">`false`</ph>.","pos":[20544,20634],"source":"The exceptions are never caught, because the `LogException` method always\nreturns `false`."},{"content":"That always false exception filter means that you can place this logging handler before any other exception handlers:","pos":[20635,20752],"source":" That always false exception filter means that you can\nplace this logging handler before any other exception handlers:"},{"pos":[20754,20865],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>LogExceptionRecovery<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionRecovery)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[LogExceptionRecovery](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionRecovery)]"},{"content":"The preceding example highlights a very important facet of exception filters.","pos":[20867,20944]},{"content":"The exception filters enable scenarios where a more general exception catch clause may appear before a more specific one.","pos":[20945,21066],"source":"\nThe exception filters enable scenarios where a more general exception\ncatch clause may appear before a more specific one."},{"content":"It's also possible to have the same exception type appear in multiple catch clauses:","pos":[21067,21151],"source":" It's also possible\nto have the same exception type appear in multiple catch clauses:"},{"pos":[21153,21262],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>HandleNotChanged<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#HandleNotChanged)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[HandleNotChanged](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#HandleNotChanged)]"},{"content":"Another recommended pattern helps prevent catch clauses from processing exceptions when a debugger is attached.","pos":[21264,21375],"source":"Another recommended pattern helps prevent catch clauses from processing\nexceptions when a debugger is attached."},{"content":"This technique enables you to run an application with the debugger, and stop execution when an exception is thrown.","pos":[21376,21491],"source":" This technique enables you to\nrun an application with the debugger, and stop execution when an exception\nis thrown."},{"pos":[21493,21603],"content":"In your code, add an exception filter so that any recovery code executes only when a debugger is not attached:","source":"In your code, add an exception filter so that any recovery code executes\nonly when a debugger is not attached:"},{"pos":[21605,21716],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>LogExceptionDebugger<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionDebugger)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[LogExceptionDebugger](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionDebugger)]"},{"content":"After adding this in code, you set your debugger to break on all unhandled exceptions.","pos":[21718,21804],"source":"After adding this in code, you set your debugger to break on all unhandled\nexceptions."},{"content":"Run the program under the debugger, and the debugger breaks whenever <ph id=\"ph1\">`PerformFailingOperation()`</ph> throws a <ph id=\"ph2\">`RecoverableException`</ph>.","pos":[21805,21934],"source":" Run the program under the debugger, and the debugger breaks\nwhenever `PerformFailingOperation()` throws a `RecoverableException`."},{"content":"The debugger breaks your program, because the catch clause won't be executed due to the false-returning exception filter.","pos":[21935,22056],"source":"\nThe debugger breaks your program, because the catch clause won't be executed\ndue to the false-returning exception filter."},{"pos":[22061,22081],"content":"<ph id=\"ph1\">`nameof`</ph> Expressions","linkify":"`nameof` Expressions","source":"`nameof` Expressions"},{"content":"The <ph id=\"ph1\">`nameof`</ph> expression evaluates to the name of a symbol.","pos":[22083,22141],"source":"The `nameof` expression evaluates to the name of a symbol."},{"content":"It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.","pos":[22142,22252],"source":" It's a great\nway to get tools working whenever you need the name of a variable,\na property, or a member field."},{"pos":[22254,22355],"content":"One of the most common uses for <ph id=\"ph1\">`nameof`</ph> is to provide the name of a symbol that caused an exception:","source":"One of the most common uses for `nameof` is to provide the name of a symbol\nthat caused an exception:"},{"pos":[22357,22451],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>nameof<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]"},{"pos":[22453,22551],"content":"Another use is with XAML based applications that implement the <ph id=\"ph1\">`INotifyPropertyChanged`</ph> interface:","source":"Another use is with XAML based applications that implement the `INotifyPropertyChanged`\ninterface:"},{"pos":[22553,22650],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>nameofNotify<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]"},{"content":"The advantage of using the <ph id=\"ph1\">`nameof`</ph> operator over a constant string is that tools can understand the symbol.","pos":[22652,22760],"source":"The advantage of using the `nameof` operator over a constant string is\nthat tools can understand the symbol."},{"content":"If you use refactoring tools to rename the symbol, it will rename it in the <ph id=\"ph1\">`nameof`</ph> expression.","pos":[22761,22857],"source":" If you use refactoring tools to\nrename the symbol, it will rename it in the `nameof` expression."},{"content":"Constant strings don't have that advantage.","pos":[22858,22901],"source":" Constant\nstrings don't have that advantage."},{"content":"Try it yourself in your favorite editor: rename a variable, and any <ph id=\"ph1\">`nameof`</ph> expressions will update as well.","pos":[22902,23011],"source":" Try it yourself in your favorite editor:\nrename a variable, and any `nameof` expressions will update as well."},{"pos":[23013,23179],"content":"The <ph id=\"ph1\">`nameof`</ph> expression produces the unqualified name of its argument (<ph id=\"ph2\">`LastName`</ph> in the previous examples) even if you use the fully qualified name for the argument:","source":"The `nameof` expression produces the unqualified name of its argument\n(`LastName` in the previous examples) even if you use the fully qualified\nname for the argument:"},{"pos":[23181,23296],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>QualifiedNameofNotify<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#QualifiedNameofNotify)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[QualifiedNameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#QualifiedNameofNotify)]"},{"pos":[23298,23384],"content":"This <ph id=\"ph1\">`nameof`</ph> expression produces <ph id=\"ph2\">`FirstName`</ph>, not <ph id=\"ph3\">`UXComponents.ViewModel.FirstName`</ph>.","source":"This `nameof` expression produces `FirstName`, not `UXComponents.ViewModel.FirstName`."},{"pos":[23389,23422],"content":"Await in Catch and Finally blocks","linkify":"Await in Catch and Finally blocks","nodes":[{"content":"Await in Catch and Finally blocks","pos":[0,33]}]},{"content":"C# 5 had several limitations around where you could place <ph id=\"ph1\">`await`</ph> expressions.","pos":[23424,23502],"source":"C# 5 had several limitations around where you could place `await` expressions."},{"content":"One of those has been removed in C# 6.","pos":[23503,23541],"source":"\nOne of those has been removed in C# 6."},{"content":"You can now use <ph id=\"ph1\">`await`</ph> in <ph id=\"ph2\">`catch`</ph> or <ph id=\"ph3\">`finally`</ph> expressions.","pos":[23542,23602],"source":" You can now use `await` in `catch`\nor `finally` expressions."},{"content":"The addition of await expressions in catch and finally blocks may appear to complicate how those are processed.","pos":[23605,23716],"source":"The addition of await expressions in catch and finally blocks may appear\nto complicate how those are processed."},{"content":"Let's add an example to discuss how this appears.","pos":[23717,23766],"source":" Let's add an example to discuss\nhow this appears."},{"content":"In any async method, you can use an await expression in a finally clause.","pos":[23767,23840],"source":" In any async method, you can use an await expression\nin a finally clause."},{"content":"With C# 6, you can also await in catch expressions.","pos":[23842,23893]},{"content":"This is most often used with logging scenarios:","pos":[23894,23941],"source":" This is most often\nused with logging scenarios:"},{"pos":[23943,24044],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>AwaitFinally<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]"},{"content":"The implementation details for adding <ph id=\"ph1\">`await`</ph> support inside <ph id=\"ph2\">`catch`</ph> and <ph id=\"ph3\">`finally`</ph> clauses ensures that the behavior is consistent with the behavior for synchronous code.","pos":[24046,24216],"source":"The implementation details for adding `await` support inside `catch`\nand `finally` clauses ensures that the behavior is consistent with the\nbehavior for synchronous code."},{"content":"When code executed in a <ph id=\"ph1\">`catch`</ph> or <ph id=\"ph2\">`finally`</ph> clause throws, execution looks for a suitable <ph id=\"ph3\">`catch`</ph> clause in the next surrounding block.","pos":[24217,24353],"source":" When code executed in a `catch` or `finally`\nclause throws, execution looks for a suitable `catch` clause in the next\nsurrounding block."},{"content":"If there was a current exception, that exception is lost.","pos":[24354,24411],"source":" If there was a current exception, that exception is\nlost."},{"content":"The same happens with awaited expressions in <ph id=\"ph1\">`catch`</ph> and <ph id=\"ph2\">`finally`</ph> clauses: a suitable <ph id=\"ph3\">`catch`</ph> is searched for, and the current exception, if any, is lost.","pos":[24412,24567],"source":" The same happens with awaited expressions in `catch` and `finally`\nclauses: a suitable `catch` is searched for, and the current exception,\nif any, is lost."},{"pos":[24573,24716],"content":"[!NOTE]\nThis behavior is the reason it's recommended to write `catch` and `finally`\nclauses carefully, to avoid introducing new exceptions.","leadings":["","> ","> "],"nodes":[{"content":"This behavior is the reason it's recommended to write <ph id=\"ph1\">`catch`</ph> and <ph id=\"ph2\">`finally`</ph> clauses carefully, to avoid introducing new exceptions.","pos":[8,139],"source":"This behavior is the reason it's recommended to write `catch` and `finally`\nclauses carefully, to avoid introducing new exceptions."}]},{"pos":[24721,24739],"content":"Index Initializers","linkify":"Index Initializers","nodes":[{"content":"Index Initializers","pos":[0,18]}]},{"content":"<bpt id=\"p1\">*</bpt>Index Initializers<ept id=\"p1\">*</ept> is one of two features that make collection initializers more consistent.","pos":[24741,24835],"source":"*Index Initializers* is one of two features that make collection\ninitializers more consistent."},{"content":"In earlier releases of C#, you could use <bpt id=\"p1\">*</bpt>collection initializers<ept id=\"p1\">*</ept> only with sequence style collections:","pos":[24836,24940],"source":" In earlier releases of C#, you could use\n*collection initializers* only with sequence style collections:"},{"pos":[24942,25048],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ListInitializer<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/initializers.cs#ListInitializer)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#ListInitializer)]"},{"content":"Now, you can also use them with <ph id=\"ph1\">@System.Collections.Generic.Dictionary</ph> collections and similar types:","pos":[25050,25151],"source":"Now, you can also use them with @System.Collections.Generic.Dictionary collections and similar types:"},{"pos":[25153,25271],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>DictionaryInitializer<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]"},{"pos":[25273,25429],"content":"This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.","source":"This feature means that associative containers can be initialized using\nsyntax similar to what's been in place for sequence containers for several\nversions."},{"pos":[25435,25485],"content":"Extension <ph id=\"ph1\">`Add`</ph> methods in collection initializers","linkify":"Extension `Add` methods in collection initializers","source":"Extension `Add` methods in collection initializers"},{"content":"Another feature that makes collection initialization easier is the ability to use an <bpt id=\"p1\">*</bpt>extension method<ept id=\"p1\">*</ept> for the <ph id=\"ph1\">`Add`</ph> method.","pos":[25487,25612],"source":"Another feature that makes collection initialization easier is the ability\nto use an *extension method* for the `Add` method."},{"content":"This feature was added for parity with Visual Basic.","pos":[25613,25665],"source":" This feature was\nadded for parity with Visual Basic."},{"pos":[25668,25805],"content":"The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.","source":"The feature is most useful when you have a custom collection class that\nhas a method with a different name to semantically add new items."},{"content":"For example, consider a collection of students like this:","pos":[25807,25864]},{"pos":[25866,25960],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Enrollment<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Enrollment](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)]"},{"content":"The <ph id=\"ph1\">`Enroll`</ph> method adds a student.","pos":[25962,25997],"source":"The `Enroll` method adds a student."},{"content":"But it doesn't follow the <ph id=\"ph1\">`Add`</ph> pattern.","pos":[25998,26038],"source":" But it doesn't follow the `Add` pattern."},{"content":"In previous versions of C#, you could not use collection initializers with an <ph id=\"ph1\">`Enrollment`</ph> object:","pos":[26039,26137],"source":"\nIn previous versions of C#, you could not use collection initializers with an\n`Enrollment` object:"},{"pos":[26139,26252],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>InitializeEnrollment<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/classList.cs#InitializeEnrollment)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[InitializeEnrollment](../../../samples/snippets/csharp/new-in-6/classList.cs#InitializeEnrollment)]"},{"pos":[26254,26338],"content":"Now you can, but only if you create an extension method that maps <ph id=\"ph1\">`Add`</ph> to <ph id=\"ph2\">`Enroll`</ph>:","source":"Now you can, but only if you create an extension method that maps `Add` to\n`Enroll`:"},{"pos":[26340,26437],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExtensionAdd<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAdd)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[ExtensionAdd](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAdd)]"},{"pos":[26439,26585],"content":"What you are doing with this feature is to map whatever method adds items to a collection to a method named <ph id=\"ph1\">`Add`</ph> by creating an extension method:","source":"What you are doing with this feature is to map whatever method adds\nitems to a collection to a method named `Add` by creating an\nextension method:"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Enrollment<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)</ept><ept id=\"p1\">]</ept>","pos":[26588,26682],"source":"[!code-csharp[Enrollment](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)]"},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>ExtensionAddSample<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAddSample)</ept><ept id=\"p1\">]</ept>","pos":[26683,26792],"source":"[!code-csharp[ExtensionAddSample](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAddSample)]"},{"pos":[26797,26825],"content":"Improved overload resolution","linkify":"Improved overload resolution","nodes":[{"content":"Improved overload resolution","pos":[0,28]}]},{"content":"This last feature is one you probably won't notice.","pos":[26827,26878]},{"content":"There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.","pos":[26879,27019],"source":" There were constructs\nwhere the previous version of the C# compiler may have found some method\ncalls involving lambda expressions ambiguous."},{"content":"Consider this method:","pos":[27020,27041]},{"pos":[27043,27138],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>AsyncMethod<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]"},{"pos":[27140,27228],"content":"In earlier versions of C#, calling that method using the method group syntax would fail:","source":"In earlier versions of C#, calling that method using the method group\nsyntax would fail:"},{"pos":[27230,27325],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>MethodGroup<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]"},{"content":"The earlier compiler could not distinguish correctly between <ph id=\"ph1\">`Task.Run(Action)`</ph> and <ph id=\"ph2\">`Task.Run(Func&lt;Task&gt;())`</ph>.","pos":[27328,27437],"source":"The earlier compiler could not distinguish correctly between `Task.Run(Action)`\nand `Task.Run(Func<Task>())`."},{"content":"In previous versions, you'd need to use a lambda expression as an argument:","pos":[27438,27513],"source":" In previous versions, you'd need to use\na lambda expression as an argument:"},{"pos":[27515,27600],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Lambda<ept id=\"p2\">](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]"},{"pos":[27602,27690],"content":"The C# 6 compiler correctly determines that <ph id=\"ph1\">`Task.Run(Func&lt;Task&gt;())`</ph> is a better choice.","source":"The C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is\na better choice."}]}