{"content":"---\ntitle: Pattern Matching - C# Guide\ndescription: Learn about pattern matching expressions in C#\nms.date: 01/24/2017\nms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b\n---\n\n# Pattern Matching\n\nPatterns test that a value has a certain *shape*, and can *extract*\ninformation from the value when it has the matching shape. Pattern\nmatching provides more concise syntax for algorithms you already use\ntoday. You already create pattern matching algorithms using existing\nsyntax. You write `if` or `switch` statements that test values. Then,\nwhen those statements match, you extract and use information from that\nvalue. The new syntax elements are extensions to statements you are already\nfamiliar with: `is` and `switch`. These new extensions combine testing\na value and extracting that information.\n\nIn this topic, we'll look at the new syntax to show you how it enables\nreadable, concise code. Pattern matching enables idioms where data and\nthe code are separated, unlike object oriented designs where data \nand the methods that manipulate them are tightly coupled.\n\nTo illustrate these new idioms, let's work with structures that represent\ngeometric shapes using pattern matching statements. You are probably\nfamiliar with building class hierarchies and creating\n[virtual methods and overridden methods](methods.md#inherited) to\ncustomize object behavior based on the runtime type of the object.\n\nThose techniques aren't possible for data that isn't structured in a class\nhierarchy. When data and methods are separate, you need other tools. The new\n*pattern matching* constructs enable cleaner syntax to examine data\nand manipulate control flow based on any condition of that data. You already\nwrite `if` statements and `switch` that test a variable's value. You write `is`\nstatements that test a variable's type. *Pattern matching* adds new capabilities\nto those statements.\n\nIn this topic, you'll build a method  that computes the area of\ndifferent geometric shapes. But, you'll do it without resorting to object\noriented techniques and building a class hierarchy for the different shapes.\nYou'll use *pattern matching* instead.\nAs you go through this sample, contrast this code with how it would\nbe structured as an object hierarchy. When the data you must\nquery and manipulate is not a class hierarchy, pattern matching enables\nvery elegant designs.\n\nRather than starting with an abstract shape definition and adding different\nspecific shape classes, let's start instead with simple data only definitions\nfor each of the geometric shapes:\n\n[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions \"Shape definitions\")]\n\nFrom these structures, let's write a method that computes the area\nof some shape.\n\n## The `is` type pattern expression\n\nBefore C# 7.0, you'd need to test each type in a series of `if` and `is`\nstatements:\n\n[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression \"Classic type pattern using is\")]\n\nThat code above is a classic expression of the *type pattern*: You're testing a variable\nto determine its type and taking a different action based on that type.\n\nThis code becomes simpler using extensions to the `is` expression to assign\na variable if the test succeeds:\n\n[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression \"is pattern expression\")]\n\nIn this updated version, the `is` expression both tests the variable and assigns\nit to a new variable of the proper type. Also, notice that this version includes\nthe `Rectangle` type, which is a `struct`. The new `is` expression works with\nvalue types as well as reference types.\n\nLanguage rules for pattern matching expressions help you avoid misusing\nthe results of a match expression. In the example above, the variables `s`,\n `c`, and `r` are only in scope and definitely assigned when the respective\npattern match expressions have `true` results. If you try to use either\nvariable in another location, your code generates compiler errors.\n\nLet's examine both of those rules in detail, beginning with scope. The variable\n`c` is in scope only in the `else` branch of the first `if` statement. The variable\n`s` is in scope in the method `ComputeAreaModernIs`. That's because each \nbranch of an `if` statement establishes a separate scope for variables. However, the `if` statement\nitself does not. That means variables declared in the `if` statement are in the\nsame scope as the `if` statement (the method in this case.) This behavior is not\nspecific to pattern matching, but is the defined behavior for variable scopes \nand `if` and `else` statements.\n\nThe variables `c` and `s` are assigned when the respective `if` statements are true\nbecause of the definitely assigned when true mechanism.\n\n> [!TIP]\n> The samples in this topic use the recommended construct where\n> a pattern match `is` expression definitely assigns the match\n> variable in the `true` branch of the `if` statement.\n> You could reverse the logic by saying `if (!(shape is Square s))`\n> and the variable `s` would be definitely assigned only in the\n> `false` branch. While this is valid C#, it is not recommended\n> because it is more confusing to follow the logic.\n\nThese rules mean that you are unlikely to accidentally access the result\nof a pattern match expression when that pattern was not met.\n\n## Using pattern matching `switch` statements\n\nAs time goes on, you may need to support other shape types. As the number\nof conditions you are testing grows, you'll find that using the `is` pattern\nmatching expressions can become cumbersome. In addition to requiring `if`\nstatements on each type you want to check, the `is` expressions are limited\nto testing if the input matches a single type. In this case, you'll find that the `switch` pattern\nmatching expressions becomes a better choice. \n\nThe traditional `switch`\nstatement was a pattern expression: it supported the constant pattern.\nYou could compare a variable to any constant used in a `case` statement:\n\n[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch \"Classic switch statement\")]\n\nThe only pattern supported by the `switch` statement was the constant\npattern. It was further limited to numeric types and the `string` type.\nThose restrictions have been removed, and you can now write a `switch`\nstatement using the type pattern:\n\n[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern \"Compute with `switch` expression\")]\n\nThe pattern matching `switch` statement uses familiar syntax to developers\nwho have used the traditional C-style `switch` statement. Each `case` is evaluated\nand the code beneath the condition that matches the input variable is\nexecuted. Code execution cannot \"fall through\" from one case expression\nto the next; the syntax of the `case` statement requires that each `case`\nend with a `break`, `return`, or `goto`.\n\n> [!NOTE]\n> The `goto` statements to jump to another label are valid only\n> for the constant pattern (the classic switch statement).\n\nThere are important new rules governing the `switch` statement. The restrictions\non the type of the variable in the `switch` expression have been removed.\nAny type, such as `object` in this example, may be used. The case expressions\nare no longer limited to constant values. Removing that limitation means\nthat reordering `switch` sections may change a program's behavior.\n\nWhen limited to constant values, no more than one `case`\nlabel could match the value of the `switch` expression. Combine that with the \nrule that every `switch` section must not fall through to the next section, and \nit followed that the\n`switch` sections could be rearranged in any order without affecting behavior.\nNow, with more generalized `switch` expressions, the order of each section\nmatters. The `switch` expressions are evaluated in textual order. Execution\ntransfers to the first `switch` label that matches the `switch` expression.  \nNote that the `default` case will only be executed if no other\ncase labels match. The `default` case is evaluated last, regardless\nof its textual order. If there is no `default` case, and none of the\nother `case` statements match, execution continues at the statement\nfollowing the `switch` statement. None of the `case` labels code is\nexecuted.\n\n## `when` clauses in `case` expressions\n\nYou can make special cases for those shapes that have 0 area by using\na `when` clause on the `case` label. A square with a side length of 0, or\na circle with a radius of 0 has a 0 area. You specify that condition\nusing a `when` clause on the `case` label:  \n\n[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes \"Compute shapes with 0 area\")]\n\nThis change demonstrates a few important points about the new syntax. First,\nmultiple `case` labels can be applied to one `switch` section. The statement\nblock is executed when any of those labels is `true`. In this instance,\nif the `switch` expression is either a circle or a square with 0 area, the\nmethod returns the constant 0.\n\nThis example introduces two different variables in the two `case` labels\nfor the first `switch` block. Notice that the statements in this `switch` block\ndo not use either the variables `c` (for the circle) or `s` (for the square).\nNeither of those variables is definitely assigned in this `switch` block.\nIf either of these cases match, clearly one of the variables has been assigned.\nHowever, it is impossible to tell *which* has been assigned at compile-time,\nbecause either case could match at runtime. For that reason,\nmost times when you use multiple `case` labels for the same block, you won't\nintroduce a new variable in the `case` statement, or you will only use the\nvariable in the `when` clause.\n\nHaving added those shapes with 0 area, let's add a couple more shape types:\na rectangle and a triangle:\n\n[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle \"Add rectangle and triangle\")]\n\n This set of changes adds `case` labels for the degenerate case, and labels\n and blocks for each of the new shapes. \n\nFinally, you can add a `null` case to ensure the argument is not `null`:\n\n[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase \"Add null case\")]\n\nThe special behavior for the `null` pattern is interesting because the constant\n`null` in the pattern does not have a type but can be converted to any reference\ntype or nullable type. Rather than convert a `null` to any type, the language\ndefines that a `null` value will not match any type pattern, regardless of the\ncompile-time type of the variable. This behavior makes the new `switch` based\ntype pattern consistent with the `is` statement: `is` statements always return `false` when\nthe value being checked is `null`. It's also simpler: once you have\nchecked the type, you don't need an additional null check. You can see that from\nthe fact that there are no null checks in any of the case blocks of the samples above:\nthey are not necessary, since matching the type pattern guarantees a non-null value.\n\n## `var` declarations in `case` expressions\n\nThe introduction of `var` as one of the match expressions introduces new\nrules to the pattern match.\n\nThe first rule is that the `var` declaration\nfollows the normal type inference rules: The type is inferred to be the\nstatic type of the switch expression. From that rule, the type always\nmatches.\n\nThe second rule is that a `var` declaration does not have the null check\nthat other type pattern expressions include. That means the variable\nmay be null, and a null check is necessary in that case.\n\nThose two rules mean that in many instances, a `var` declaration\nin a `case` expression matches the same conditions as a `default` expression.\nBecause any non-default case is preferred to the `default` case, the `default`\ncase will never execute.\n\n> [!NOTE]\n> The compiler does not emit a warning in those cases where a `default` case\n> has been written but will never execute. This is consistent with current\n> `switch` statement behavior where all possible cases have been listed.\n\nThe third rule introduces uses where a `var` case may be useful. Imagine\nthat you are doing a pattern match where the input is a string and you are\nsearching for known command values. You might write something like:\n\n[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression \"use a var case expression to filter white space\")]\n\nThe `var` case matches `null`, the empty string, or any string that contains\nonly white space. Notice that the preceding code uses the `?.` operator to\nensure that it does not accidentally throw a <xref:System.NullReferenceException>. The `default` case handles any other string values that are not understood by this command parser.\n\nThis is one example where you may want to consider\na `var` case expression that is distinct from a `default` expression.\n\n## Conclusions\n\n*Pattern Matching constructs* enable you to easily manage control flow\namong different variables and types that are not related by an inheritance\nhierarchy. You can also control logic to use any condition you test on\nthe variable. It enables patterns and idioms that you'll need more often\nas you build more distributed applications, where data and the methods that\nmanipulate that data are separate. You'll notice that the shape structs\nused in this sample do not contain any methods, just read-only properties.\nPattern Matching works with any data type. You write expressions that examine\nthe object, and make control flow decisions based on those conditions.\n\nCompare the code from this sample with the design that would follow from\ncreating a class hierarchy for an abstract `Shape` and specific derived\nshapes each with their own implementation of a virtual method to calculate\nthe area. You'll often find that pattern matching expressions can be a very\nuseful tool when you are working with data and want to separate the data\nstorage concerns from the behavior concerns.\n","nodes":[{"pos":[4,167],"embed":true,"restype":"x-metadata","content":"title: Pattern Matching - C# Guide\ndescription: Learn about pattern matching expressions in C#\nms.date: 01/24/2017\nms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b","nodes":[{"content":"Pattern Matching - C# Guide","nodes":[{"pos":[0,27],"content":"Pattern Matching - C# Guide","nodes":[{"content":"Pattern Matching - C# Guide","pos":[0,27]}]}],"path":["title"],"nosxs":false},{"content":"Learn about pattern matching expressions in C#","nodes":[{"pos":[0,46],"content":"Learn about pattern matching expressions in C#","nodes":[{"content":"Learn about pattern matching expressions in C#","pos":[0,46]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[175,191],"content":"Pattern Matching","linkify":"Pattern Matching","nodes":[{"content":"Pattern Matching","pos":[0,16]}]},{"content":"Patterns test that a value has a certain <bpt id=\"p1\">*</bpt>shape<ept id=\"p1\">*</ept>, and can <bpt id=\"p2\">*</bpt>extract<ept id=\"p2\">*</ept> information from the value when it has the matching shape.","pos":[193,319],"source":"Patterns test that a value has a certain *shape*, and can *extract*\ninformation from the value when it has the matching shape."},{"content":"Pattern matching provides more concise syntax for algorithms you already use today.","pos":[320,403],"source":" Pattern\nmatching provides more concise syntax for algorithms you already use\ntoday."},{"content":"You already create pattern matching algorithms using existing syntax.","pos":[404,473],"source":" You already create pattern matching algorithms using existing\nsyntax."},{"content":"You write <ph id=\"ph1\">`if`</ph> or <ph id=\"ph2\">`switch`</ph> statements that test values.","pos":[474,529],"source":" You write `if` or `switch` statements that test values."},{"content":"Then, when those statements match, you extract and use information from that value.","pos":[530,613],"source":" Then,\nwhen those statements match, you extract and use information from that\nvalue."},{"content":"The new syntax elements are extensions to statements you are already familiar with: <ph id=\"ph1\">`is`</ph> and <ph id=\"ph2\">`switch`</ph>.","pos":[614,716],"source":" The new syntax elements are extensions to statements you are already\nfamiliar with: `is` and `switch`."},{"content":"These new extensions combine testing a value and extracting that information.","pos":[717,794],"source":" These new extensions combine testing\na value and extracting that information."},{"content":"In this topic, we'll look at the new syntax to show you how it enables readable, concise code.","pos":[796,890],"source":"In this topic, we'll look at the new syntax to show you how it enables\nreadable, concise code."},{"content":"Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.","pos":[891,1062],"source":" Pattern matching enables idioms where data and\nthe code are separated, unlike object oriented designs where data \nand the methods that manipulate them are tightly coupled."},{"content":"To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.","pos":[1064,1189],"source":"To illustrate these new idioms, let's work with structures that represent\ngeometric shapes using pattern matching statements."},{"content":"You are probably familiar with building class hierarchies and creating <bpt id=\"p1\">[</bpt>virtual methods and overridden methods<ept id=\"p1\">](methods.md#inherited)</ept> to customize object behavior based on the runtime type of the object.","pos":[1190,1393],"source":" You are probably\nfamiliar with building class hierarchies and creating\n[virtual methods and overridden methods](methods.md#inherited) to\ncustomize object behavior based on the runtime type of the object."},{"content":"Those techniques aren't possible for data that isn't structured in a class hierarchy.","pos":[1395,1480],"source":"Those techniques aren't possible for data that isn't structured in a class\nhierarchy."},{"content":"When data and methods are separate, you need other tools.","pos":[1481,1538]},{"content":"The new <bpt id=\"p1\">*</bpt>pattern matching<ept id=\"p1\">*</ept> constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.","pos":[1539,1679],"source":" The new\n*pattern matching* constructs enable cleaner syntax to examine data\nand manipulate control flow based on any condition of that data."},{"content":"You already write <ph id=\"ph1\">`if`</ph> statements and <ph id=\"ph2\">`switch`</ph> that test a variable's value.","pos":[1680,1756],"source":" You already\nwrite `if` statements and `switch` that test a variable's value."},{"content":"You write <ph id=\"ph1\">`is`</ph> statements that test a variable's type.","pos":[1757,1811],"source":" You write `is`\nstatements that test a variable's type."},{"content":"<bpt id=\"p1\">*</bpt>Pattern matching<ept id=\"p1\">*</ept> adds new capabilities to those statements.","pos":[1812,1873],"source":"*Pattern matching* adds new capabilities\nto those statements."},{"content":"In this topic, you'll build a method  that computes the area of different geometric shapes.","pos":[1875,1966],"source":"In this topic, you'll build a method  that computes the area of\ndifferent geometric shapes."},{"content":"But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.","pos":[1967,2089],"source":" But, you'll do it without resorting to object\noriented techniques and building a class hierarchy for the different shapes."},{"content":"You'll use <bpt id=\"p1\">*</bpt>pattern matching<ept id=\"p1\">*</ept> instead.","pos":[2090,2128],"source":"\nYou'll use *pattern matching* instead."},{"content":"As you go through this sample, contrast this code with how it would be structured as an object hierarchy.","pos":[2129,2234],"source":"\nAs you go through this sample, contrast this code with how it would\nbe structured as an object hierarchy."},{"content":"When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.","pos":[2235,2351],"source":" When the data you must\nquery and manipulate is not a class hierarchy, pattern matching enables\nvery elegant designs."},{"pos":[2353,2540],"content":"Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:","source":"Rather than starting with an abstract shape definition and adding different\nspecific shape classes, let's start instead with simple data only definitions\nfor each of the geometric shapes:"},{"pos":[2664,2745],"content":"From these structures, let's write a method that computes the area of some shape.","source":"From these structures, let's write a method that computes the area\nof some shape."},{"pos":[2750,2782],"content":"The <ph id=\"ph1\">`is`</ph> type pattern expression","linkify":"The `is` type pattern expression","source":"The `is` type pattern expression"},{"pos":[2784,2868],"content":"Before C# 7.0, you'd need to test each type in a series of <ph id=\"ph1\">`if`</ph> and <ph id=\"ph2\">`is`</ph> statements:","source":"Before C# 7.0, you'd need to test each type in a series of `if` and `is`\nstatements:"},{"pos":[3022,3182],"content":"That code above is a classic expression of the <bpt id=\"p1\">*</bpt>type pattern<ept id=\"p1\">*</ept>: You're testing a variable to determine its type and taking a different action based on that type.","source":"That code above is a classic expression of the *type pattern*: You're testing a variable\nto determine its type and taking a different action based on that type."},{"pos":[3184,3292],"content":"This code becomes simpler using extensions to the <ph id=\"ph1\">`is`</ph> expression to assign a variable if the test succeeds:","source":"This code becomes simpler using extensions to the `is` expression to assign\na variable if the test succeeds:"},{"content":"In this updated version, the <ph id=\"ph1\">`is`</ph> expression both tests the variable and assigns it to a new variable of the proper type.","pos":[3438,3559],"source":"In this updated version, the `is` expression both tests the variable and assigns\nit to a new variable of the proper type."},{"content":"Also, notice that this version includes the <ph id=\"ph1\">`Rectangle`</ph> type, which is a <ph id=\"ph2\">`struct`</ph>.","pos":[3560,3642],"source":" Also, notice that this version includes\nthe `Rectangle` type, which is a `struct`."},{"content":"The new <ph id=\"ph1\">`is`</ph> expression works with value types as well as reference types.","pos":[3643,3717],"source":" The new `is` expression works with\nvalue types as well as reference types."},{"content":"Language rules for pattern matching expressions help you avoid misusing the results of a match expression.","pos":[3719,3825],"source":"Language rules for pattern matching expressions help you avoid misusing\nthe results of a match expression."},{"content":"In the example above, the variables <ph id=\"ph1\">`s`</ph>, <ph id=\"ph2\">`c`</ph>, and <ph id=\"ph3\">`r`</ph> are only in scope and definitely assigned when the respective pattern match expressions have <ph id=\"ph4\">`true`</ph> results.","pos":[3826,3989],"source":" In the example above, the variables `s`,\n `c`, and `r` are only in scope and definitely assigned when the respective\npattern match expressions have `true` results."},{"content":"If you try to use either variable in another location, your code generates compiler errors.","pos":[3990,4081],"source":" If you try to use either\nvariable in another location, your code generates compiler errors."},{"content":"Let's examine both of those rules in detail, beginning with scope.","pos":[4083,4149]},{"content":"The variable <ph id=\"ph1\">`c`</ph> is in scope only in the <ph id=\"ph2\">`else`</ph> branch of the first <ph id=\"ph3\">`if`</ph> statement.","pos":[4150,4233],"source":" The variable\n`c` is in scope only in the `else` branch of the first `if` statement."},{"content":"The variable <ph id=\"ph1\">`s`</ph> is in scope in the method <ph id=\"ph2\">`ComputeAreaModernIs`</ph>.","pos":[4234,4299],"source":" The variable\n`s` is in scope in the method `ComputeAreaModernIs`."},{"content":"That's because each branch of an <ph id=\"ph1\">`if`</ph> statement establishes a separate scope for variables.","pos":[4300,4392],"source":" That's because each \nbranch of an `if` statement establishes a separate scope for variables."},{"content":"However, the <ph id=\"ph1\">`if`</ph> statement itself does not.","pos":[4393,4437],"source":" However, the `if` statement\nitself does not."},{"content":"That means variables declared in the <ph id=\"ph1\">`if`</ph> statement are in the same scope as the <ph id=\"ph2\">`if`</ph> statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and <ph id=\"ph3\">`if`</ph> and <ph id=\"ph4\">`else`</ph> statements.","pos":[4438,4692],"source":" That means variables declared in the `if` statement are in the\nsame scope as the `if` statement (the method in this case.) This behavior is not\nspecific to pattern matching, but is the defined behavior for variable scopes \nand `if` and `else` statements."},{"pos":[4694,4833],"content":"The variables <ph id=\"ph1\">`c`</ph> and <ph id=\"ph2\">`s`</ph> are assigned when the respective <ph id=\"ph3\">`if`</ph> statements are true because of the definitely assigned when true mechanism.","source":"The variables `c` and `s` are assigned when the respective `if` statements are true\nbecause of the definitely assigned when true mechanism."},{"pos":[4837,5273],"content":"[!TIP]\nThe samples in this topic use the recommended construct where\na pattern match `is` expression definitely assigns the match\nvariable in the `true` branch of the `if` statement.\nYou could reverse the logic by saying `if (!(shape is Square s))`\nand the variable `s` would be definitely assigned only in the\n`false` branch. While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic.","leadings":["","> ","> ","> ","> ","> ","> ","> "],"nodes":[{"content":"The samples in this topic use the recommended construct where\na pattern match `is` expression definitely assigns the match\nvariable in the `true` branch of the `if` statement.\nYou could reverse the logic by saying `if (!(shape is Square s))`\nand the variable `s` would be definitely assigned only in the\n`false` branch. While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic.","pos":[7,422],"nodes":[{"content":"The samples in this topic use the recommended construct where a pattern match <ph id=\"ph1\">`is`</ph> expression definitely assigns the match variable in the <ph id=\"ph2\">`true`</ph> branch of the <ph id=\"ph3\">`if`</ph> statement.","pos":[0,175],"source":"The samples in this topic use the recommended construct where\na pattern match `is` expression definitely assigns the match\nvariable in the `true` branch of the `if` statement."},{"content":"You could reverse the logic by saying <ph id=\"ph1\">`if (!(shape is Square s))`</ph> and the variable <ph id=\"ph2\">`s`</ph> would be definitely assigned only in the <ph id=\"ph3\">`false`</ph> branch.","pos":[176,319],"source":"\nYou could reverse the logic by saying `if (!(shape is Square s))`\nand the variable `s` would be definitely assigned only in the\n`false` branch."},{"content":"While this is valid C#, it is not recommended because it is more confusing to follow the logic.","pos":[320,415],"source":" While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic."}]}]},{"pos":[5275,5408],"content":"These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.","source":"These rules mean that you are unlikely to accidentally access the result\nof a pattern match expression when that pattern was not met."},{"pos":[5413,5455],"content":"Using pattern matching <ph id=\"ph1\">`switch`</ph> statements","linkify":"Using pattern matching `switch` statements","source":"Using pattern matching `switch` statements"},{"content":"As time goes on, you may need to support other shape types.","pos":[5457,5516]},{"content":"As the number of conditions you are testing grows, you'll find that using the <ph id=\"ph1\">`is`</ph> pattern matching expressions can become cumbersome.","pos":[5517,5651],"source":" As the number\nof conditions you are testing grows, you'll find that using the `is` pattern\nmatching expressions can become cumbersome."},{"content":"In addition to requiring <ph id=\"ph1\">`if`</ph> statements on each type you want to check, the <ph id=\"ph2\">`is`</ph> expressions are limited to testing if the input matches a single type.","pos":[5652,5804],"source":" In addition to requiring `if`\nstatements on each type you want to check, the `is` expressions are limited\nto testing if the input matches a single type."},{"content":"In this case, you'll find that the <ph id=\"ph1\">`switch`</ph> pattern matching expressions becomes a better choice.","pos":[5805,5902],"source":" In this case, you'll find that the `switch` pattern\nmatching expressions becomes a better choice."},{"content":"The traditional <ph id=\"ph1\">`switch`</ph> statement was a pattern expression: it supported the constant pattern.","pos":[5905,6000],"source":"The traditional `switch`\nstatement was a pattern expression: it supported the constant pattern."},{"content":"You could compare a variable to any constant used in a <ph id=\"ph1\">`case`</ph> statement:","pos":[6001,6073],"source":"\nYou could compare a variable to any constant used in a `case` statement:"},{"content":"The only pattern supported by the <ph id=\"ph1\">`switch`</ph> statement was the constant pattern.","pos":[6210,6288],"source":"The only pattern supported by the `switch` statement was the constant\npattern."},{"content":"It was further limited to numeric types and the <ph id=\"ph1\">`string`</ph> type.","pos":[6289,6351],"source":" It was further limited to numeric types and the `string` type."},{"content":"Those restrictions have been removed, and you can now write a <ph id=\"ph1\">`switch`</ph> statement using the type pattern:","pos":[6352,6456],"source":"\nThose restrictions have been removed, and you can now write a `switch`\nstatement using the type pattern:"},{"content":"The pattern matching <ph id=\"ph1\">`switch`</ph> statement uses familiar syntax to developers who have used the traditional C-style <ph id=\"ph2\">`switch`</ph> statement.","pos":[6611,6743],"source":"The pattern matching `switch` statement uses familiar syntax to developers\nwho have used the traditional C-style `switch` statement."},{"content":"Each <ph id=\"ph1\">`case`</ph> is evaluated and the code beneath the condition that matches the input variable is executed.","pos":[6744,6848],"source":" Each `case` is evaluated\nand the code beneath the condition that matches the input variable is\nexecuted."},{"content":"Code execution cannot \"fall through\" from one case expression to the next; the syntax of the <ph id=\"ph1\">`case`</ph> statement requires that each <ph id=\"ph2\">`case`</ph> end with a <ph id=\"ph3\">`break`</ph>, <ph id=\"ph4\">`return`</ph>, or <ph id=\"ph5\">`goto`</ph>.","pos":[6849,7025],"source":" Code execution cannot \"fall through\" from one case expression\nto the next; the syntax of the `case` statement requires that each `case`\nend with a `break`, `return`, or `goto`."},{"pos":[7029,7159],"content":"[!NOTE]\nThe `goto` statements to jump to another label are valid only\nfor the constant pattern (the classic switch statement).","leadings":["","> ","> "],"nodes":[{"content":"The <ph id=\"ph1\">`goto`</ph> statements to jump to another label are valid only for the constant pattern (the classic switch statement).","pos":[8,126],"source":"The `goto` statements to jump to another label are valid only\nfor the constant pattern (the classic switch statement)."}]},{"content":"There are important new rules governing the <ph id=\"ph1\">`switch`</ph> statement.","pos":[7161,7224],"source":"There are important new rules governing the `switch` statement."},{"content":"The restrictions on the type of the variable in the <ph id=\"ph1\">`switch`</ph> expression have been removed.","pos":[7225,7315],"source":" The restrictions\non the type of the variable in the `switch` expression have been removed."},{"content":"Any type, such as <ph id=\"ph1\">`object`</ph> in this example, may be used.","pos":[7316,7372],"source":"\nAny type, such as `object` in this example, may be used."},{"content":"The case expressions are no longer limited to constant values.","pos":[7373,7435],"source":" The case expressions\nare no longer limited to constant values."},{"content":"Removing that limitation means that reordering <ph id=\"ph1\">`switch`</ph> sections may change a program's behavior.","pos":[7436,7533],"source":" Removing that limitation means\nthat reordering `switch` sections may change a program's behavior."},{"content":"When limited to constant values, no more than one <ph id=\"ph1\">`case`</ph> label could match the value of the <ph id=\"ph2\">`switch`</ph> expression.","pos":[7535,7647],"source":"When limited to constant values, no more than one `case`\nlabel could match the value of the `switch` expression."},{"content":"Combine that with the rule that every <ph id=\"ph1\">`switch`</ph> section must not fall through to the next section, and it followed that the <ph id=\"ph2\">`switch`</ph> sections could be rearranged in any order without affecting behavior.","pos":[7648,7851],"source":" Combine that with the \nrule that every `switch` section must not fall through to the next section, and \nit followed that the\n`switch` sections could be rearranged in any order without affecting behavior."},{"content":"Now, with more generalized <ph id=\"ph1\">`switch`</ph> expressions, the order of each section matters.","pos":[7852,7935],"source":"\nNow, with more generalized `switch` expressions, the order of each section\nmatters."},{"content":"The <ph id=\"ph1\">`switch`</ph> expressions are evaluated in textual order.","pos":[7936,7992],"source":" The `switch` expressions are evaluated in textual order."},{"content":"Execution transfers to the first <ph id=\"ph1\">`switch`</ph> label that matches the <ph id=\"ph2\">`switch`</ph> expression.","pos":[7993,8078],"source":" Execution\ntransfers to the first `switch` label that matches the `switch` expression."},{"content":"Note that the <ph id=\"ph1\">`default`</ph> case will only be executed if no other case labels match.","pos":[8081,8162],"source":"Note that the `default` case will only be executed if no other\ncase labels match."},{"content":"The <ph id=\"ph1\">`default`</ph> case is evaluated last, regardless of its textual order.","pos":[8163,8233],"source":" The `default` case is evaluated last, regardless\nof its textual order."},{"content":"If there is no <ph id=\"ph1\">`default`</ph> case, and none of the other <ph id=\"ph2\">`case`</ph> statements match, execution continues at the statement following the <ph id=\"ph3\">`switch`</ph> statement.","pos":[8234,8382],"source":" If there is no `default` case, and none of the\nother `case` statements match, execution continues at the statement\nfollowing the `switch` statement."},{"content":"None of the <ph id=\"ph1\">`case`</ph> labels code is executed.","pos":[8383,8426],"source":" None of the `case` labels code is\nexecuted."},{"pos":[8431,8467],"content":"<ph id=\"ph1\">`when`</ph> clauses in <ph id=\"ph2\">`case`</ph> expressions","linkify":"`when` clauses in `case` expressions","source":"`when` clauses in `case` expressions"},{"content":"You can make special cases for those shapes that have 0 area by using a <ph id=\"ph1\">`when`</ph> clause on the <ph id=\"ph2\">`case`</ph> label.","pos":[8469,8575],"source":"You can make special cases for those shapes that have 0 area by using\na `when` clause on the `case` label."},{"content":"A square with a side length of 0, or a circle with a radius of 0 has a 0 area.","pos":[8576,8654],"source":" A square with a side length of 0, or\na circle with a radius of 0 has a 0 area."},{"content":"You specify that condition using a <ph id=\"ph1\">`when`</ph> clause on the <ph id=\"ph2\">`case`</ph> label:","pos":[8655,8724],"source":" You specify that condition\nusing a `when` clause on the `case` label:"},{"content":"This change demonstrates a few important points about the new syntax.","pos":[8885,8954]},{"content":"First, multiple <ph id=\"ph1\">`case`</ph> labels can be applied to one <ph id=\"ph2\">`switch`</ph> section.","pos":[8955,9024],"source":" First,\nmultiple `case` labels can be applied to one `switch` section."},{"content":"The statement block is executed when any of those labels is <ph id=\"ph1\">`true`</ph>.","pos":[9025,9092],"source":" The statement\nblock is executed when any of those labels is `true`."},{"content":"In this instance, if the <ph id=\"ph1\">`switch`</ph> expression is either a circle or a square with 0 area, the method returns the constant 0.","pos":[9093,9216],"source":" In this instance,\nif the `switch` expression is either a circle or a square with 0 area, the\nmethod returns the constant 0."},{"content":"This example introduces two different variables in the two <ph id=\"ph1\">`case`</ph> labels for the first <ph id=\"ph2\">`switch`</ph> block.","pos":[9218,9320],"source":"This example introduces two different variables in the two `case` labels\nfor the first `switch` block."},{"content":"Notice that the statements in this <ph id=\"ph1\">`switch`</ph> block do not use either the variables <ph id=\"ph2\">`c`</ph> (for the circle) or <ph id=\"ph3\">`s`</ph> (for the square).","pos":[9321,9448],"source":" Notice that the statements in this `switch` block\ndo not use either the variables `c` (for the circle) or `s` (for the square)."},{"content":"Neither of those variables is definitely assigned in this <ph id=\"ph1\">`switch`</ph> block.","pos":[9449,9522],"source":"\nNeither of those variables is definitely assigned in this `switch` block."},{"content":"If either of these cases match, clearly one of the variables has been assigned.","pos":[9523,9602],"source":"\nIf either of these cases match, clearly one of the variables has been assigned."},{"content":"However, it is impossible to tell <bpt id=\"p1\">*</bpt>which<ept id=\"p1\">*</ept> has been assigned at compile-time, because either case could match at runtime.","pos":[9603,9723],"source":"\nHowever, it is impossible to tell *which* has been assigned at compile-time,\nbecause either case could match at runtime."},{"content":"For that reason, most times when you use multiple <ph id=\"ph1\">`case`</ph> labels for the same block, you won't introduce a new variable in the <ph id=\"ph2\">`case`</ph> statement, or you will only use the variable in the <ph id=\"ph3\">`when`</ph> clause.","pos":[9724,9923],"source":" For that reason,\nmost times when you use multiple `case` labels for the same block, you won't\nintroduce a new variable in the `case` statement, or you will only use the\nvariable in the `when` clause."},{"pos":[9925,10028],"content":"Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:","source":"Having added those shapes with 0 area, let's add a couple more shape types:\na rectangle and a triangle:"},{"pos":[10188,10302],"content":"This set of changes adds <ph id=\"ph1\">`case`</ph> labels for the degenerate case, and labels and blocks for each of the new shapes.","source":"This set of changes adds `case` labels for the degenerate case, and labels\n and blocks for each of the new shapes."},{"pos":[10305,10377],"content":"Finally, you can add a <ph id=\"ph1\">`null`</ph> case to ensure the argument is not <ph id=\"ph2\">`null`</ph>:","source":"Finally, you can add a `null` case to ensure the argument is not `null`:"},{"content":"The special behavior for the <ph id=\"ph1\">`null`</ph> pattern is interesting because the constant <ph id=\"ph2\">`null`</ph> in the pattern does not have a type but can be converted to any reference type or nullable type.","pos":[10493,10676],"source":"The special behavior for the `null` pattern is interesting because the constant\n`null` in the pattern does not have a type but can be converted to any reference\ntype or nullable type."},{"content":"Rather than convert a <ph id=\"ph1\">`null`</ph> to any type, the language defines that a <ph id=\"ph2\">`null`</ph> value will not match any type pattern, regardless of the compile-time type of the variable.","pos":[10677,10845],"source":" Rather than convert a `null` to any type, the language\ndefines that a `null` value will not match any type pattern, regardless of the\ncompile-time type of the variable."},{"content":"This behavior makes the new <ph id=\"ph1\">`switch`</ph> based type pattern consistent with the <ph id=\"ph2\">`is`</ph> statement: <ph id=\"ph3\">`is`</ph> statements always return <ph id=\"ph4\">`false`</ph> when the value being checked is <ph id=\"ph5\">`null`</ph>.","pos":[10846,11015],"source":" This behavior makes the new `switch` based\ntype pattern consistent with the `is` statement: `is` statements always return `false` when\nthe value being checked is `null`."},{"content":"It's also simpler: once you have checked the type, you don't need an additional null check.","pos":[11016,11107],"source":" It's also simpler: once you have\nchecked the type, you don't need an additional null check."},{"content":"You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.","pos":[11108,11301],"source":" You can see that from\nthe fact that there are no null checks in any of the case blocks of the samples above:\nthey are not necessary, since matching the type pattern guarantees a non-null value."},{"pos":[11306,11346],"content":"<ph id=\"ph1\">`var`</ph> declarations in <ph id=\"ph2\">`case`</ph> expressions","linkify":"`var` declarations in `case` expressions","source":"`var` declarations in `case` expressions"},{"pos":[11348,11448],"content":"The introduction of <ph id=\"ph1\">`var`</ph> as one of the match expressions introduces new rules to the pattern match.","source":"The introduction of `var` as one of the match expressions introduces new\nrules to the pattern match."},{"content":"The first rule is that the <ph id=\"ph1\">`var`</ph> declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.","pos":[11450,11604],"source":"The first rule is that the `var` declaration\nfollows the normal type inference rules: The type is inferred to be the\nstatic type of the switch expression."},{"content":"From that rule, the type always matches.","pos":[11605,11645],"source":" From that rule, the type always\nmatches."},{"content":"The second rule is that a <ph id=\"ph1\">`var`</ph> declaration does not have the null check that other type pattern expressions include.","pos":[11647,11764],"source":"The second rule is that a `var` declaration does not have the null check\nthat other type pattern expressions include."},{"content":"That means the variable may be null, and a null check is necessary in that case.","pos":[11765,11845],"source":" That means the variable\nmay be null, and a null check is necessary in that case."},{"content":"Those two rules mean that in many instances, a <ph id=\"ph1\">`var`</ph> declaration in a <ph id=\"ph2\">`case`</ph> expression matches the same conditions as a <ph id=\"ph3\">`default`</ph> expression.","pos":[11847,11989],"source":"Those two rules mean that in many instances, a `var` declaration\nin a `case` expression matches the same conditions as a `default` expression."},{"content":"Because any non-default case is preferred to the <ph id=\"ph1\">`default`</ph> case, the <ph id=\"ph2\">`default`</ph> case will never execute.","pos":[11990,12093],"source":"\nBecause any non-default case is preferred to the `default` case, the `default`\ncase will never execute."},{"pos":[12097,12329],"content":"[!NOTE]\nThe compiler does not emit a warning in those cases where a `default` case\nhas been written but will never execute. This is consistent with current\n`switch` statement behavior where all possible cases have been listed.","leadings":["","> ","> ","> "],"nodes":[{"content":"The compiler does not emit a warning in those cases where a `default` case\nhas been written but will never execute. This is consistent with current\n`switch` statement behavior where all possible cases have been listed.","pos":[8,226],"nodes":[{"content":"The compiler does not emit a warning in those cases where a <ph id=\"ph1\">`default`</ph> case has been written but will never execute.","pos":[0,115],"source":"The compiler does not emit a warning in those cases where a `default` case\nhas been written but will never execute."},{"content":"This is consistent with current <ph id=\"ph1\">`switch`</ph> statement behavior where all possible cases have been listed.","pos":[116,218],"source":" This is consistent with current\n`switch` statement behavior where all possible cases have been listed."}]}]},{"content":"The third rule introduces uses where a <ph id=\"ph1\">`var`</ph> case may be useful.","pos":[12331,12395],"source":"The third rule introduces uses where a `var` case may be useful."},{"content":"Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.","pos":[12396,12514],"source":" Imagine\nthat you are doing a pattern match where the input is a string and you are\nsearching for known command values."},{"content":"You might write something like:","pos":[12515,12546]},{"content":"The <ph id=\"ph1\">`var`</ph> case matches <ph id=\"ph2\">`null`</ph>, the empty string, or any string that contains only white space.","pos":[12700,12794],"source":"The `var` case matches `null`, the empty string, or any string that contains\nonly white space."},{"content":"Notice that the preceding code uses the <ph id=\"ph1\">`?.`</ph> operator to ensure that it does not accidentally throw a <ph id=\"ph2\">&lt;xref:System.NullReferenceException&gt;</ph>.","pos":[12795,12934],"source":" Notice that the preceding code uses the `?.` operator to\nensure that it does not accidentally throw a <xref:System.NullReferenceException>."},{"content":"The <ph id=\"ph1\">`default`</ph> case handles any other string values that are not understood by this command parser.","pos":[12935,13033],"source":" The `default` case handles any other string values that are not understood by this command parser."},{"pos":[13035,13155],"content":"This is one example where you may want to consider a <ph id=\"ph1\">`var`</ph> case expression that is distinct from a <ph id=\"ph2\">`default`</ph> expression.","source":"This is one example where you may want to consider\na `var` case expression that is distinct from a `default` expression."},{"pos":[13160,13171],"content":"Conclusions","linkify":"Conclusions","nodes":[{"content":"Conclusions","pos":[0,11]}]},{"content":"<bpt id=\"p1\">*</bpt>Pattern Matching constructs<ept id=\"p1\">*</ept> enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.","pos":[13173,13329],"source":"*Pattern Matching constructs* enable you to easily manage control flow\namong different variables and types that are not related by an inheritance\nhierarchy."},{"content":"You can also control logic to use any condition you test on the variable.","pos":[13330,13403],"source":" You can also control logic to use any condition you test on\nthe variable."},{"content":"It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.","pos":[13404,13573],"source":" It enables patterns and idioms that you'll need more often\nas you build more distributed applications, where data and the methods that\nmanipulate that data are separate."},{"content":"You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.","pos":[13574,13685],"source":" You'll notice that the shape structs\nused in this sample do not contain any methods, just read-only properties."},{"content":"Pattern Matching works with any data type.","pos":[13686,13728],"source":"\nPattern Matching works with any data type."},{"content":"You write expressions that examine the object, and make control flow decisions based on those conditions.","pos":[13729,13834],"source":" You write expressions that examine\nthe object, and make control flow decisions based on those conditions."},{"content":"Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract <ph id=\"ph1\">`Shape`</ph> and specific derived shapes each with their own implementation of a virtual method to calculate the area.","pos":[13836,14065],"source":"Compare the code from this sample with the design that would follow from\ncreating a class hierarchy for an abstract `Shape` and specific derived\nshapes each with their own implementation of a virtual method to calculate\nthe area."},{"content":"You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.","pos":[14066,14249],"source":" You'll often find that pattern matching expressions can be a very\nuseful tool when you are working with data and want to separate the data\nstorage concerns from the behavior concerns."}]}