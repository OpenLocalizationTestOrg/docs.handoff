{"content":"---\ntitle: \"Passing Structures | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\ndev_langs: \n  - \"VB\"\n  - \"CSharp\"\n  - \"C++\"\n  - \"jsharp\"\nhelpviewer_keywords: \n  - \"platform invoke, calling unmanaged functions\"\nms.assetid: 9b92ac73-32b7-4e1b-862e-6d8d950cf169\ncaps.latest.revision: 16\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\nmanager: \"wpickett\"\n---\n# Passing Structures\nMany unmanaged functions expect you to pass, as a parameter to the function, members of structures (user-defined types in Visual Basic) or members of classes that are defined in managed code. When passing structures or classes to unmanaged code using platform invoke, you must provide additional information to preserve the original layout and alignment. This topic introduces the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, which you use to define formatted types. For managed structures and classes, you can select from several predictable layout behaviors supplied by the **LayoutKind** enumeration.  \n  \n Central to the concepts presented in this topic is an important difference between structure and class types. Structures are value types and classes are reference types â€” classes always provide at least one level of memory indirection (a pointer to a value). This difference is important because unmanaged functions often demand indirection, as shown by the signatures in the first column of the following table. The managed structure and class declarations in the remaining columns show the degree to which you can adjust the level of indirection in your declaration.Declarations are provided for both Visual Basic and Visual C#.  \n  \n|Unmanaged signature|Managed declaration: <br />no indirection<br />`Structure MyType`<br />`struct MyType;`|Managed declaration: <br />one level of indirection<br />`Class MyType`<br />`class MyType;`|  \n|-------------------------|---------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|  \n|`DoWork(MyType x);`<br /><br /> Demands zero levels of indirection.|`DoWork(ByVal x As MyType)` <br /> `DoWork(MyType x)`<br /><br /> Adds zero levels of indirection.|Not possible because there is already one level of indirection.|  \n|`DoWork(MyType* x);`<br /><br /> Demands one level of indirection.|`DoWork(ByRef x As MyType)` <br /> `DoWork(ref MyType x)`<br /><br /> Adds one level of indirection.|`DoWork(ByVal x As MyType)` <br /> `DoWork(MyType x)`<br /><br /> Adds zero levels of indirection.|  \n|`DoWork(MyType** x);`<br /><br /> Demands two levels of indirection.|Not possible because **ByRef** **ByRef** or `ref` `ref` cannot be used.|`DoWork(ByRef x As MyType)` <br /> `DoWork(ref MyType x)`<br /><br /> Adds one level of indirection.|  \n  \n The table describes the following guidelines for platform invoke declarations:  \n  \n-   Use a structure passed by value when the unmanaged function demands no indirection.  \n  \n-   Use either a structure passed by reference or a class passed by value when the unmanaged function demands one level of indirection.  \n  \n-   Use a class passed by reference when the unmanaged function demands two levels of indirection.  \n  \n## Declaring and Passing Structures  \n The following example shows how to define the `Point` and `Rect` structures in managed code, and pass the types as parameter to the **PtInRect** function in the User32.dll file. **PtInRect** has the following unmanaged signature:  \n  \n```  \nBOOL PtInRect(const RECT *lprc, POINT pt);  \n```  \n  \n Notice that you must pass the Rect structure by reference, since the function expects a pointer to a RECT type.  \n  \n```vb  \nImports System.Runtime.InteropServices  \n  \n<StructLayout(LayoutKind.Sequential)> Public Structure Point  \n    Public x As Integer  \n    Public y As Integer  \nEnd Structure  \n  \nPublic Structure <StructLayout(LayoutKind.Explicit)> Rect  \n    <FieldOffset(0)> Public left As Integer  \n    <FieldOffset(4)> Public top As Integer  \n    <FieldOffset(8)> Public right As Integer  \n    <FieldOffset(12)> Public bottom As Integer  \nEnd Structure  \n  \nClass Win32API      \n    Declare Auto Function PtInRect Lib \"user32.dll\" _  \n    (ByRef r As Rect, p As Point) As Boolean  \nEnd Class  \n  \n```  \n  \n```csharp  \nusing System.Runtime.InteropServices;  \n  \n[StructLayout(LayoutKind.Sequential)]  \npublic struct Point {  \n    public int x;  \n    public int y;  \n}     \n  \n[StructLayout(LayoutKind.Explicit)]  \npublic struct Rect {  \n    [FieldOffset(0)] public int left;  \n    [FieldOffset(4)] public int top;  \n    [FieldOffset(8)] public int right;  \n    [FieldOffset(12)] public int bottom;  \n}     \n  \nclass Win32API {  \n    [DllImport(\"User32.dll\")]  \n    public static extern bool PtInRect(ref Rect r, Point p);  \n}  \n```  \n  \n## Declaring and Passing Classes  \n You can pass members of a class to an unmanaged DLL function, as long as the class has a fixed member layout. The following example demonstrates how to pass members of the `MySystemTime` class, which are defined in sequential order, to the **GetSystemTime** in the User32.dll file. **GetSystemTime** has the following unmanaged signature:  \n  \n```  \nvoid GetSystemTime(SYSTEMTIME* SystemTime);  \n```  \n  \n Unlike value types, classes always have at least one level of indirection.  \n  \n```vb  \nImports System  \nImports System.Runtime.InteropServices  \nImports Microsoft.VisualBasic  \n  \n<StructLayout(LayoutKind.Sequential)> Public Class MySystemTime  \n    Public wYear As Short  \n    Public wMonth As Short  \n    Public wDayOfWeek As Short   \n    Public wDay As Short  \n    Public wHour As Short  \n    Public wMinute As Short  \n    Public wSecond As Short  \n    Public wMiliseconds As Short  \nEnd Class  \n  \nPublic Class Win32  \n    Declare Auto Sub GetSystemTime Lib \"Kernel32.dll\"(sysTime _  \n        As MySystemTime)  \n    Declare Auto Function MessageBox Lib \"User32.dll\"(hWnd As IntPtr, _  \n        txt As String, caption As String, Typ As Integer) As Integer  \nEnd Class  \n  \nPublic Class TestPlatformInvoke      \n    Public Shared Sub Main()  \n        Dim sysTime As New MySystemTime()  \n        Win32.GetSystemTime(sysTime)  \n  \n        Dim dt As String  \n        dt = \"System time is:\" & ControlChars.CrLf & _  \n              \"Year: \" & sysTime.wYear & _  \n              ControlChars.CrLf & \"Month: \" & sysTime.wMonth & _  \n              ControlChars.CrLf & \"DayOfWeek: \" & sysTime.wDayOfWeek & _  \n              ControlChars.CrLf & \"Day: \" & sysTime.wDay  \n        Win32.MessageBox(IntPtr.Zero, dt, \"Platform Invoke Sample\", 0)        \n    End Sub  \nEnd Class  \n  \n```  \n  \n```csharp  \n[StructLayout(LayoutKind.Sequential)]  \npublic class MySystemTime {  \n    public ushort wYear;   \n    public ushort wMonth;  \n    public ushort wDayOfWeek;   \n    public ushort wDay;   \n    public ushort wHour;   \n    public ushort wMinute;   \n    public ushort wSecond;   \n    public ushort wMilliseconds;   \n}  \nclass Win32API {  \n    [DllImport(\"Kernel32.dll\")]  \n    public static extern void GetSystemTime(MySystemTime st);  \n  \n    [DllImport(\"user32.dll\", CharSet=CharSet.Auto)]  \n     public static extern int MessageBox(IntPtr hWnd,  \n         string text, string caption, int options);  \n}  \n  \npublic class TestPlatformInvoke  \n{  \n    public static void Main()  \n    {  \n        MySystemTime sysTime = new MySystemTime();  \n        Win32API.GetSystemTime(sysTime);  \n  \n        string dt;  \n        dt = \"System time is: \\n\" +  \n              \"Year: \" + sysTime.wYear + \"\\n\" +  \n              \"Month: \" + sysTime.wMonth + \"\\n\" +  \n              \"DayOfWeek: \" + sysTime.wDayOfWeek + \"\\n\" +  \n              \"Day: \" + sysTime.wDay;  \n        Win32API.MessageBox(IntPtr.Zero, dt, \"Platform Invoke Sample\", 0);  \n    }  \n}  \n```  \n  \n## See Also  \n [Calling a DLL Function](../../../docs/framework/interop/calling-a-dll-function.md)   \n <xref:System.Runtime.InteropServices.StructLayoutAttribute>   \n <xref:System.Runtime.InteropServices.StructLayoutAttribute>   \n <xref:System.Runtime.InteropServices.FieldOffsetAttribute>\n","nodes":[{"pos":[12,47],"content":"Passing Structures | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Passing Structures | Microsoft Docs","pos":[0,35]}]},{"pos":[481,499],"content":"Passing Structures","linkify":"Passing Structures","nodes":[{"content":"Passing Structures","pos":[0,18]}]},{"content":"Many unmanaged functions expect you to pass, as a parameter to the function, members of structures (user-defined types in Visual Basic) or members of classes that are defined in managed code.","pos":[500,691]},{"content":"When passing structures or classes to unmanaged code using platform invoke, you must provide additional information to preserve the original layout and alignment.","pos":[692,854]},{"content":"This topic introduces the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, which you use to define formatted types.","pos":[855,992],"source":" This topic introduces the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, which you use to define formatted types."},{"content":"For managed structures and classes, you can select from several predictable layout behaviors supplied by the <bpt id=\"p1\">**</bpt>LayoutKind<ept id=\"p1\">**</ept> enumeration.","pos":[993,1129],"source":" For managed structures and classes, you can select from several predictable layout behaviors supplied by the **LayoutKind** enumeration."},{"content":"Central to the concepts presented in this topic is an important difference between structure and class types.","pos":[1136,1245]},{"content":"Structures are value types and classes are reference types â€” classes always provide at least one level of memory indirection (a pointer to a value).","pos":[1246,1394]},{"content":"This difference is important because unmanaged functions often demand indirection, as shown by the signatures in the first column of the following table.","pos":[1395,1548]},{"content":"The managed structure and class declarations in the remaining columns show the degree to which you can adjust the level of indirection in your declaration.Declarations are provided for both Visual Basic and Visual C#.","pos":[1549,1766]},{"content":"Unmanaged signature","pos":[1773,1792]},{"content":"Managed declaration:","pos":[1793,1813]},{"content":"no indirection","pos":[1820,1834]},{"content":"Managed declaration:","pos":[1881,1901]},{"content":"one level of indirection","pos":[1908,1932]},{"content":"Demands zero levels of indirection.","pos":[2209,2244]},{"content":"Adds zero levels of indirection.","pos":[2311,2343]},{"content":"Not possible because there is already one level of indirection.","pos":[2344,2407]},{"content":"Demands one level of indirection.","pos":[2445,2478]},{"content":"Adds one level of indirection.","pos":[2549,2579]},{"content":"Adds zero levels of indirection.","pos":[2646,2678]},{"content":"Demands two levels of indirection.","pos":[2717,2751]},{"pos":[2752,2823],"content":"Not possible because <bpt id=\"p1\">**</bpt>ByRef<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>ByRef<ept id=\"p2\">**</ept> or <ph id=\"ph1\">`ref`</ph> <ph id=\"ph2\">`ref`</ph> cannot be used.","source":"Not possible because **ByRef** **ByRef** or `ref` `ref` cannot be used."},{"content":"Adds one level of indirection.","pos":[2894,2924]},{"content":"The table describes the following guidelines for platform invoke declarations:","pos":[2932,3010]},{"content":"Use a structure passed by value when the unmanaged function demands no indirection.","pos":[3020,3103]},{"content":"Use either a structure passed by reference or a class passed by value when the unmanaged function demands one level of indirection.","pos":[3113,3244]},{"content":"Use a class passed by reference when the unmanaged function demands two levels of indirection.","pos":[3254,3348]},{"pos":[3357,3389],"content":"Declaring and Passing Structures","linkify":"Declaring and Passing Structures","nodes":[{"content":"Declaring and Passing Structures","pos":[0,32]}]},{"content":"The following example shows how to define the <ph id=\"ph1\">`Point`</ph> and <ph id=\"ph2\">`Rect`</ph> structures in managed code, and pass the types as parameter to the <bpt id=\"p1\">**</bpt>PtInRect<ept id=\"p1\">**</ept> function in the User32.dll file.","pos":[3393,3570],"source":"The following example shows how to define the `Point` and `Rect` structures in managed code, and pass the types as parameter to the **PtInRect** function in the User32.dll file."},{"content":"<bpt id=\"p1\">**</bpt>PtInRect<ept id=\"p1\">**</ept> has the following unmanaged signature:","pos":[3571,3622],"source":"**PtInRect** has the following unmanaged signature:"},{"content":"Notice that you must pass the Rect structure by reference, since the function expects a pointer to a RECT type.","pos":[3689,3800]},{"pos":[4939,4968],"content":"Declaring and Passing Classes","linkify":"Declaring and Passing Classes","nodes":[{"content":"Declaring and Passing Classes","pos":[0,29]}]},{"content":"You can pass members of a class to an unmanaged DLL function, as long as the class has a fixed member layout.","pos":[4972,5081]},{"content":"The following example demonstrates how to pass members of the <ph id=\"ph1\">`MySystemTime`</ph> class, which are defined in sequential order, to the <bpt id=\"p1\">**</bpt>GetSystemTime<ept id=\"p1\">**</ept> in the User32.dll file.","pos":[5082,5253],"source":" The following example demonstrates how to pass members of the `MySystemTime` class, which are defined in sequential order, to the **GetSystemTime** in the User32.dll file."},{"content":"<bpt id=\"p1\">**</bpt>GetSystemTime<ept id=\"p1\">**</ept> has the following unmanaged signature:","pos":[5254,5310],"source":"**GetSystemTime** has the following unmanaged signature:"},{"content":"Unlike value types, classes always have at least one level of indirection.","pos":[5378,5452]},{"pos":[7913,7921],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Calling a DLL Function<ept id=\"p1\">](../../../docs/framework/interop/calling-a-dll-function.md)</ept><ph id=\"ph1\"> </ph>","pos":[7925,8009],"source":"[Calling a DLL Function](../../../docs/framework/interop/calling-a-dll-function.md) "},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>","pos":[8013,8072],"source":" <xref:System.Runtime.InteropServices.StructLayoutAttribute> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>","pos":[8077,8136],"source":" <xref:System.Runtime.InteropServices.StructLayoutAttribute> "},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph>","pos":[8141,8199],"source":" <xref:System.Runtime.InteropServices.FieldOffsetAttribute>"}]}