<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="httpcookiesession.md" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">001f509e08780ec2d9776bcd6aed109ca0ff36a5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\samples\httpcookiesession.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">20a0dcba3a6ae2fe0db8e81276decb56bb67b782</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a50ef3e64adcbc22cbf68af920cd0f2fb5cbd292</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>HttpCookieSession</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>HttpCookieSession</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This sample demonstrates how to build a custom protocol channel to use HTTP cookies for session management.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This channel enables communication between Windows Communication Foundation (WCF) services and ASMX clients or between WCF clients and ASMX services.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When a client calls a Web method in an ASMX Web service that is session-based, the <ph id="ph1">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> engine does the following:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Generates a unique ID (session ID).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Generates the session object and associates it with the unique ID.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Adds the unique ID to a Set-Cookie HTTP response header and sends it to the client.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Identifies the client on subsequent calls based on the session ID it sends to it.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The client includes this session ID in its subsequent requests to the server.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The server uses the session ID from the client to load the appropriate session object for the current HTTP context.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The samples may already be installed on your machine.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Check for the following (default) directory before continuing.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If this directory does not exist, go to <bpt id="p1">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id="p1">](https://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all Windows Communication Foundation (WCF) and <ph id="ph1">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This sample is located in the following directory.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>HttpCookieSession Channel Message Exchange Pattern</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This sample enables sessions for ASMX-like scenarios.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>At the bottom of our channel stack, we have the HTTP transport that supports <ph id="ph1">&lt;xref:System.ServiceModel.Channels.IRequestChannel&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It is the job of the channel to provide sessions to the higher levels of the channel stack.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The sample implements two channels, (<ph id="ph1">&lt;xref:System.ServiceModel.Channels.IRequestSessionChannel&gt;</ph> and <ph id="ph2">&lt;xref:System.ServiceModel.Channels.IReplySessionChannel&gt;</ph>) that support sessions.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Service Channel</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The sample provides a service channel in the <ph id="ph1">`HttpCookieReplySessionChannelListener`</ph> class.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This class implements the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.IChannelListener&gt;</ph> interface and converts the <ph id="ph2">&lt;xref:System.ServiceModel.Channels.IReplyChannel&gt;</ph> channel from lower in the channel stack to a <ph id="ph3">&lt;xref:System.ServiceModel.Channels.IReplySessionChannel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This process can be divided into the following parts:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When the channel listener is opened, it accepts an inner channel from its inner listener.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Because the inner listener is a datagram listener and the lifetime of an accepted channel is decoupled from the lifetime of the listener, we can close the inner listener and only hold on to the inner channel</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When the open process completes, we set up a message loop to receive messages from the inner channel.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>When a message arrives, the service channel examines the session identifier and de-multiplexes to the appropriate session channel.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The channel listener maintains a dictionary that maps the session identifiers to the session channel instances.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`HttpCookieReplySessionChannel`</ph> class implements <ph id="ph2">&lt;xref:System.ServiceModel.Channels.IReplySessionChannel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Higher levels of the channel stack call the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> method to read requests for this session.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Each session channel has a private message queue that is populated by the service channel.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In the case when someone calls the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A&gt;</ph> method and there are no messages in the message queue, the channel waits for a specified amount of time before shutting itself down.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This cleans up the session channels created for non-WCF clients.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>We use the <ph id="ph1">`channelMapping`</ph> to track the <ph id="ph2">`ReplySessionChannels`</ph>, and we do not close our underlying <ph id="ph3">`innerChannel`</ph> until all the accepted channels have been closed.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This way <ph id="ph1">`HttpCookieReplySessionChannel`</ph> can exist beyond the lifetime of <ph id="ph2">`HttpCookieReplySessionChannelListener`</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>We also do not have to worry about the listener getting garbage collected underneath us because the accepted channels keep a reference to their listener through the <ph id="ph1">`OnClosed`</ph> callback.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Client channel</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The corresponding client channel is in the <ph id="ph1">`HttpCookieSessionChannelFactory`</ph> class.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>During channel creation, the channel factory wraps the inner request channel with an <ph id="ph1">`HttpCookieRequestSessionChannel`</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`HttpCookieRequestSessionChannel`</ph> class forwards the calls to the underlying request channel.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>When the client closes the proxy, <ph id="ph1">`HttpCookieRequestSessionChannel`</ph> sends a message to the service that indicates that the channel is being closed.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Thus, the service channel stack can gracefully shutdown the session channel that is in use.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Binding and Binding Element</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>After creating the service and client channels, the next step is to integrate them into the WCF runtime.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Channels are exposed to WCF through bindings and binding elements.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A binding consists of one or many binding elements.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>WCF offers several system-defined bindings; for example, BasicHttpBinding or WSHttpBinding.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`HttpCookieSessionBindingElement`</ph> class contains the implementation for the binding element.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It overrides the channel listener and channel factory creation methods to do the necessary channel listener or channel factory instantiations.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The sample uses policy assertions for the service description.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This allows the sample to publish its channel requirements to other clients that can consume the service.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, this binding element publishes policy assertions to let potential clients know that it supports sessions.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Because the sample enables the <ph id="ph1">`ExchangeTerminateMessage`</ph> property in the binding element configuration, it adds the necessary assertions to show that the service supports an extra message exchange action to terminate the session conversation.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Clients can then use this action.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following WSDL code shows the policy assertions created from the <ph id="ph1">`HttpCookieSessionBindingElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`HttpCookieSessionBinding`</ph> class is a system-provided binding that uses the binding element described previously.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Adding the Channel to the Configuration System</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The sample provides two classes that expose the sample channel through configuration.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The first is a <ph id="ph1">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> for the <ph id="ph2">`HttpCookieSessionBindingElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The bulk of the implementation is delegated to the <ph id="ph1">`HttpCookieSessionBindingConfigurationElement`</ph>, which derives from <ph id="ph2">&lt;xref:System.ServiceModel.Configuration.StandardBindingElement&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`HttpCookieSessionBindingConfigurationElement`</ph> has properties that correspond to the properties on <ph id="ph2">`HttpCookieSessionBindingElement`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Binding Element Extension Section</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The section <ph id="ph1">`HttpCookieSessionBindingElementSection`</ph> is a <ph id="ph2">&lt;xref:System.ServiceModel.Configuration.BindingElementExtensionElement&gt;</ph> that exposes <ph id="ph3">`HttpCookieSessionBindingElement`</ph> to the configuration system.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>With a few overrides the configuration section name, the type of the binding element and how to create the binding element are defined.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>We can then register the extension section in a configuration file as follows:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Test Code</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Test code for using this sample transport is available in the Client and Service directories.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>It consists of two testsâ€”one test uses a binding with <ph id="ph1">`allowCookies`</ph> set to <ph id="ph2">`true`</ph> on the client.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The second test enables explicit shutdown (using the terminate message exchange) on the binding.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When you run the sample, you should see the following output:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>To set up, build, and run the sample</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Install <ph id="ph1">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]</ph> 4.0 using the following command.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Ensure that you have performed the <bpt id="p1">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>To build the solution, follow the instructions in <bpt id="p1">[</bpt>Building the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id="p1">[</bpt>Running the Windows Communication Foundation Samples<ept id="p1">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>