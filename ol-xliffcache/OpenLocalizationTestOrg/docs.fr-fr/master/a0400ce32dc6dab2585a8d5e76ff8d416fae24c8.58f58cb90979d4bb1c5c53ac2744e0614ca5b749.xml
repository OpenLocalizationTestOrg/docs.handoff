{"content":"---\ntitle: \"WPF Graphics Rendering Overview\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"graphics [WPF], rendering\"\n  - \"rendering graphics [WPF]\"\nms.assetid: 6dec9657-4d8c-4e46-8c54-40fb80008265\n---\n# WPF Graphics Rendering Overview\nThis topic provides an overview of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual layer. It focuses on the role of the <xref:System.Windows.Media.Visual> class for rendering support in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] model.  \n\n<a name=\"role_of_visual_object\"></a>   \n## Role of the Visual Object  \n The <xref:System.Windows.Media.Visual> class is the basic abstraction from which every <xref:System.Windows.FrameworkElement> object derives. It also serves as the entry point for writing new controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], and in many ways can be thought of as the window handle (HWND) in the Win32 application model.  \n  \n The <xref:System.Windows.Media.Visual> object is a core [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] object, whose primary role is to provide rendering support. User interface controls, such as <xref:System.Windows.Controls.Button> and <xref:System.Windows.Controls.TextBox>, derive from the <xref:System.Windows.Media.Visual> class, and use it for persisting their rendering data. The <xref:System.Windows.Media.Visual> object provides support for:  \n  \n-   Output display: Rendering the persisted, serialized drawing content of a visual.  \n  \n-   Transformations: Performing transformations on a visual.  \n  \n-   Clipping: Providing clipping region support for a visual.  \n  \n-   Hit testing: Determining whether a coordinate or geometry is contained within the bounds of a visual.  \n  \n-   Bounding box calculations: Determining the bounding rectangle of a visual.  \n  \n However, the <xref:System.Windows.Media.Visual> object does not include support for non-rendering features, such as:  \n  \n-   Event handling  \n  \n-   Layout  \n  \n-   Styles  \n  \n-   Data binding  \n  \n-   Globalization  \n  \n <xref:System.Windows.Media.Visual> is exposed as a public abstract class from which child classes must be derived. The following illustration shows the hierarchy of the visual objects that are exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  \n  \n ![Diagram of classes derived from the Visual object](./media/wpf-graphics-rendering-overview/classes-derived-visual-object.png)    \n  \n### DrawingVisual Class  \n The <xref:System.Windows.Media.DrawingVisual> is a lightweight drawing class that is used to render shapes, images, or text. This class is considered lightweight because it does not provide layout or event handling, which improves its runtime performance. For this reason, drawings are ideal for backgrounds and clip art. The <xref:System.Windows.Media.DrawingVisual> can be used to create a custom visual object. For more information, see [Using DrawingVisual Objects](using-drawingvisual-objects.md).  \n  \n### Viewport3DVisual Class  \n The <xref:System.Windows.Media.Media3D.Viewport3DVisual> provides a bridge between 2D <xref:System.Windows.Media.Visual> and <xref:System.Windows.Media.Media3D.Visual3D> objects. The <xref:System.Windows.Media.Media3D.Visual3D> class is the base class for all 3D visual elements. The <xref:System.Windows.Media.Media3D.Viewport3DVisual> requires that you define a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A> value and a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A> value. The camera allows you to view the scene. The viewport establishes where the projection maps onto the 2D surface. For more information on 3D in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [3-D Graphics Overview](3-d-graphics-overview.md).  \n  \n### ContainerVisual Class  \n The <xref:System.Windows.Media.ContainerVisual> class is used as a container for a collection of <xref:System.Windows.Media.Visual> objects. The <xref:System.Windows.Media.DrawingVisual> class derives from the <xref:System.Windows.Media.ContainerVisual> class, allowing it to contain a collection of visual objects.  \n  \n### Drawing Content in Visual Objects  \n A <xref:System.Windows.Media.Visual> object stores its render data as a **vector graphics instruction list**. Each item in the instruction list represents a low-level set of graphics data and associated resources in a serialized format. There are four different types of render data that can contain drawing content.  \n  \n|Drawing content type|Description|  \n|--------------------------|-----------------|  \n|Vector graphics|Represents vector graphics data, and any associated <xref:System.Windows.Media.Brush> and <xref:System.Windows.Media.Pen> information.|  \n|Image|Represents an image within a region defined by a <xref:System.Windows.Rect>.|  \n|Glyph|Represents a drawing that renders a <xref:System.Windows.Media.GlyphRun>, which is a sequence of glyphs from a specified font resource. This is how text is represented.|  \n|Video|Represents a drawing that renders video.|  \n  \n The <xref:System.Windows.Media.DrawingContext> allows you to populate a <xref:System.Windows.Media.Visual> with visual content. When you use a <xref:System.Windows.Media.DrawingContext> object's draw commands, you are actually storing a set of render data that will later be used by the graphics system; you are not drawing to the screen in real-time.  \n  \n When you create a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, such as a <xref:System.Windows.Controls.Button>, the control implicitly generates render data for drawing itself. For example, setting the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the <xref:System.Windows.Controls.Button> causes the control to store a rendering representation of a glyph.  \n  \n A <xref:System.Windows.Media.Visual> describes its content as one or more <xref:System.Windows.Media.Drawing> objects contained within a <xref:System.Windows.Media.DrawingGroup>. A <xref:System.Windows.Media.DrawingGroup> also describes opacity masks, transforms, bitmap effects, and other operations that are applied to its contents. <xref:System.Windows.Media.DrawingGroup> operations are applied in the following order when content is rendered: <xref:System.Windows.Media.DrawingGroup.OpacityMask%2A>, <xref:System.Windows.Media.DrawingGroup.Opacity%2A>, <xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A>, <xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A>, <xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A>, and then <xref:System.Windows.Media.DrawingGroup.Transform%2A>.  \n  \n The following illustration shows the order in which <xref:System.Windows.Media.DrawingGroup> operations are applied during the rendering sequence.  \n  \n ![DrawingGroup order of operations](./media/graphcismm-drawinggroup-order.png \"graphcismm_drawinggroup_order\")  \nOrder of DrawingGroup operations  \n  \n For more information, see [Drawing Objects Overview](drawing-objects-overview.md).  \n  \n#### Drawing Content at the Visual Layer  \n You never directly instantiate a <xref:System.Windows.Media.DrawingContext>; you can, however, acquire a drawing context from certain methods, such as <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> and <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>. The following example retrieves a <xref:System.Windows.Media.DrawingContext> from a <xref:System.Windows.Media.DrawingVisual> and uses it to draw a rectangle.  \n  \n [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]\n [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  \n  \n#### Enumerating Drawing Content at the Visual Layer  \n In addition to their other uses, <xref:System.Windows.Media.Drawing> objects also provide an object model for enumerating the contents of a <xref:System.Windows.Media.Visual>.  \n  \n> [!NOTE]\n>  When you are enumerating the contents of the visual, you are retrieving <xref:System.Windows.Media.Drawing> objects, and not the underlying representation of the render data as a vector graphics instruction list.  \n  \n The following example uses the <xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A> method to retrieve the <xref:System.Windows.Media.DrawingGroup> value of a <xref:System.Windows.Media.Visual> and enumerate it.  \n  \n [!code-csharp[DrawingMiscSnippets_snip#GraphicsMMRetrieveDrawings](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingMiscSnippets_snip/CSharp/EnumerateDrawingsExample.xaml.cs#graphicsmmretrievedrawings)]  \n  \n<a name=\"how_visual_objects_are_used_to_build_controls\"></a>   \n## How Visual Objects are Used to Build Controls  \n Many of the objects in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are composed of other visual objects, meaning they can contain varying hierarchies of descendant objects. Many of the user interface elements in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], such as controls, are composed of multiple visual objects, representing different types of rendering elements. For example, the <xref:System.Windows.Controls.Button> control can contain a number of other objects, including <xref:Microsoft.Windows.Themes.ClassicBorderDecorator>, <xref:System.Windows.Controls.ContentPresenter>, and <xref:System.Windows.Controls.TextBlock>.  \n  \n The following code shows a <xref:System.Windows.Controls.Button> control defined in markup.  \n  \n [!code-xaml[VisualsOverview#VisualsOverviewSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet1)]  \n  \n If you were to enumerate the visual objects that comprise the default <xref:System.Windows.Controls.Button> control, you would find the hierarchy of visual objects illustrated below:  \n  \n ![Diagram of visual tree hierarchy](./media/wpf-graphics-rendering-overview/visual-object-diagram.gif) \n  \n The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element. The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing a border and a background for the <xref:System.Windows.Controls.Button>. The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>. In this case, since you are displaying text, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.TextBlock> element. The fact that the <xref:System.Windows.Controls.Button> control uses a <xref:System.Windows.Controls.ContentPresenter> means that the content could be represented by other elements, such as an <xref:System.Windows.Controls.Image> or a geometry, such as an <xref:System.Windows.Media.EllipseGeometry>.  \n  \n### Control Templates  \n The key to the expansion of a control into a hierarchy of controls is the <xref:System.Windows.Controls.ControlTemplate>. A control template specifies the default visual hierarchy for a control. When you explicitly reference a control, you implicitly reference its visual hierarchy. You can override the default values for a control template to create a customized visual appearance for a control. For example, you could modify the background color value of the <xref:System.Windows.Controls.Button> control so that it uses a linear gradient color value instead of a solid color value. For more information, see [Button Styles and Templates](../controls/button-styles-and-templates.md).  \n  \n A user interface element, such as a <xref:System.Windows.Controls.Button> control, contains several vector graphics instruction lists that describe the entire rendering definition of a control. The following code shows a <xref:System.Windows.Controls.Button> control defined in markup.  \n  \n [!code-xaml[VisualsOverview#VisualsOverviewSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet2)]  \n  \n If you were to enumerate the visual objects and vector graphics instruction lists that comprise the <xref:System.Windows.Controls.Button> control, you would find the hierarchy of objects illustrated below:  \n  \n ![Diagram of visual tree and rendering data](./media/wpf-graphics-rendering-overview/visual-tree-rendering-data.png)  \n  \n The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element. The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing all the discrete graphic elements that make up the border and background of a button. The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>. In this case, since you are displaying an image, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.Image> element.  \n  \n There are a number of points to note about the hierarchy of visual objects and vector graphics instruction lists:  \n  \n-   The ordering in the hierarchy represents the rendering order of the drawing information. From the root visual element, child elements are traversed, left to right, top to bottom. If an element has visual child elements, they are traversed before the element’s siblings.  \n  \n-   Non-leaf node elements in the hierarchy, such as <xref:System.Windows.Controls.ContentPresenter>, are used to contain child elements—they do not contain instruction lists.  \n  \n-   If a visual element contains both a vector graphics instruction list and visual children, the instruction list in the parent visual element is rendered before drawings in any of the visual child objects.  \n  \n-   The items in the vector graphics instruction list are rendered left to right.  \n  \n<a name=\"visual_tree\"></a>   \n## Visual Tree  \n The visual tree contains all visual elements used in an application's user interface. Since a visual element contains persisted drawing information, you can think of the visual tree as a scene graph, containing all the rendering information needed to compose the output to the display device. This tree is the accumulation of all visual elements created directly by the application, whether in code or in markup. The visual tree also contains all visual elements created by the template expansion of elements such as controls and data objects.  \n  \n The following code shows a <xref:System.Windows.Controls.StackPanel> element defined in markup.  \n  \n [!code-xaml[VisualsOverview#VisualsOverviewSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet3)]  \n  \n If you were to enumerate the visual objects that comprise the <xref:System.Windows.Controls.StackPanel> element in the markup example, you would find the hierarchy of visual objects illustrated below:  \n  \n ![Diagram of visual tree hierarchy](./media/wpf-graphics-rendering-overview/visual-tree-hierarchy.gif)  \n  \n### Rendering Order  \n The visual tree determines the rendering order of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual and drawing objects. The order of traversal starts with the root visual, which is the top-most node in the visual tree. The root visual’s children are then traversed, left to right. If a visual has children, its children are traversed before the visual’s siblings. This means that the content of a child visual is rendered in front of the visual's own content.  \n  \n ![Diagram of the visual tree rendering order](./media/wpf-graphics-rendering-overview/visual-tree-rendering-order.gif) \n  \n### Root Visual  \n The **root visual** is the top-most element in a visual tree hierarchy. In most applications, the base class of the root visual is either <xref:System.Windows.Window> or <xref:System.Windows.Navigation.NavigationWindow>. However, if you were hosting visual objects in a Win32 application, the root visual would be the top-most visual you were hosting in the Win32 window. For more information, see [Tutorial: Hosting Visual Objects in a Win32 Application](tutorial-hosting-visual-objects-in-a-win32-application.md).  \n  \n### Relationship to the Logical Tree  \n The logical tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] represents the elements of an application at run time. Although you do not manipulate this tree directly, this view of the application is useful for understanding property inheritance and event routing. Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>. In many cases, the logical tree maps very closely to an application's markup definitions. The following code shows a <xref:System.Windows.Controls.DockPanel> element defined in markup.  \n  \n [!code-xaml[VisualsOverview#VisualsOverviewSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml#visualsoverviewsnippet5)]  \n  \n If you were to enumerate the logical objects that comprise the <xref:System.Windows.Controls.DockPanel> element in the markup example, you would find the hierarchy of logical objects illustrated below:  \n  \n ![Tree diagram](./media/tree1-wcp.gif \"Tree1_wcp\")  \nDiagram of logical tree  \n  \n Both the visual tree and logical tree are synchronized with the current set of application elements, reflecting any addition, deletion, or modification of elements. However, the trees present different views of the application. Unlike the visual tree, the logical tree does not expand a control's <xref:System.Windows.Controls.ContentPresenter> element. This means there is not a direct one-to-one correspondence between a logical tree and a visual tree for the same set of objects. In fact, invoking the **LogicalTreeHelper** object's <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> method and the **VisualTreeHelper** object's <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method using the same element as a parameter yields differing results.  \n  \n For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md).  \n  \n### Viewing the Visual Tree with XamlPad  \n The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tool, XamlPad, provides an option for viewing and exploring the visual tree that corresponds to the currently defined [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] content. Click the **Show Visual Tree** button on the menu bar to display the visual tree. The following illustrates the expansion of [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] content into visual tree nodes in the **Visual Tree Explorer** panel of XamlPad:  \n  \n ![Visual Tree Explorer panel in XamlPad](./media/wpf-graphics-rendering-overview/visual-tree-explorer.png)  \n\n Notice how the <xref:System.Windows.Controls.Label>, <xref:System.Windows.Controls.TextBox>, and <xref:System.Windows.Controls.Button> controls each display a separate visual object hierarchy in the **Visual Tree Explorer** panel of XamlPad. This is because [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have a <xref:System.Windows.Controls.ControlTemplate> that contains the visual tree of that control. When you explicitly reference a control, you implicitly reference its visual hierarchy.  \n  \n### Profiling Visual Performance  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides a suite of performance profiling tools that allow you to analyze the run-time behavior of your application and determine the types of performance optimizations you can apply. The Visual Profiler tool provides a rich, graphical view of performance data by mapping directly to the application's visual tree. In this screenshot, the **CPU Usage** section of the Visual Profiler gives you a precise breakdown of an object's use of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] services, such as rendering and layout.  \n  \n ![Visual Profiler display output](./media/wpfperf-visualprofiler-04.png \"WPFPerf_VisualProfiler_04\")  \nVisual Profiler display output  \n  \n<a name=\"visual_rendering_behavior\"></a>   \n## Visual Rendering Behavior  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] introduces several features that affect the rendering behavior of visual objects: retained mode graphics, vector graphics, and device independent graphics.  \n  \n### Retained Mode Graphics  \n One of the keys to understanding the role of the Visual object is to understand the difference between **immediate mode** and **retained mode** graphics systems. A standard Win32 application based on GDI or GDI+ uses an immediate mode graphics system. This means that the application is responsible for repainting the portion of the client area that is invalidated, due to an action such as a window being resized, or an object changing its visual appearance.  \n  \n ![Diagram of Win32 rendering sequence](./media/wpf-graphics-rendering-overview/win32-rendering-squence.png)  \n  \n In contrast, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a retained mode system. This means application objects that have a visual appearance define a set of serialized drawing data. Once the drawing data is defined, the system is responsible thereafter for responding to all repaint requests for rendering the application objects. Even at run time, you can modify or create application objects, and still rely on the system for responding to paint requests. The power in a retained mode graphics system is that drawing information is always persisted in a serialized state by the application, but rendering responsibility left to the system. The following diagram shows how the application relies on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] for responding to paint requests.  \n  \n ![Diagram of WPF rendering sequence](./media/wpf-graphics-rendering-overview/wpf-rendering-sequence.png)  \n\n#### Intelligent Redrawing  \n One of the biggest benefits in using retained mode graphics is that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can efficiently optimize what needs to be redrawn in the application. Even if you have a complex scene with varying levels of opacity, you generally do not need to write special-purpose code to optimize redrawing. Compare this with Win32 programming in which you can spend a great deal of effort in optimizing your application by minimizing the amount of redrawing in the update region. See [Redrawing in the Update Region](/windows/desktop/gdi/redrawing-in-the-update-region) for an example of the type of complexity involved in optimizing redrawing in Win32 applications.  \n  \n### Vector Graphics  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses **vector graphics** as its rendering data format. Vector graphics—which include Scalable Vector Graphics (SVG), Windows metafiles (.wmf), and TrueType fonts—store rendering data and transmit it as a list of instructions that describe how to recreate an image using graphics primitives. For example, TrueType fonts are outline fonts that describe a set of lines, curves, and commands, rather than an array of pixels. One of the key benefits of vector graphics is the ability to scale to any size and resolution.  \n  \n Unlike vector graphics, bitmap graphics store rendering data as a pixel-by-pixel representation of an image, pre-rendered for a specific resolution. One of the key differences between bitmap and vector graphic formats is fidelity to the original source image. For example, when the size of a source image is modified, bitmap graphics systems stretch the image, whereas vector graphics systems scale the image, preserving the image fidelity.  \n  \n The following illustration shows a source image that has been resized by 300%. Notice the distortions that appear when the source image is stretched as a bitmap graphics image rather than scaled as a vector graphics image.  \n  \n ![Differences between raster and vector graphics](./media/wpf-graphics-rendering-overview/raster-vector-differences.png)  \n  \n The following markup shows two <xref:System.Windows.Shapes.Path> elements defined. The second element uses a <xref:System.Windows.Media.ScaleTransform> to resize the drawing instructions of the first element by 300%. Notice that the drawing instructions in the <xref:System.Windows.Shapes.Path> elements remain unchanged.  \n  \n [!code-xaml[VectorGraphicsSnippets#VectorGraphicsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/VectorGraphicsSnippets/CS/PageOne.xaml#vectorgraphicssnippet1)]  \n  \n### About Resolution and Device-Independent Graphics  \n There are two system factors that determine the size of text and graphics on your screen: resolution and DPI. Resolution describes the number of pixels that appear on the screen. As the resolution gets higher, pixels get smaller, causing graphics and text to appear smaller. A graphic displayed on a monitor set to 1024 x 768 will appear much smaller when the resolution is changed to 1600 x 1200.  \n  \n The other system setting, DPI, describes the size of a screen inch in pixels. Most [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] systems have a DPI of 96, which means a screen inch is 96 pixels. Increasing the DPI setting makes the screen inch larger; decreasing the DPI makes the screen inch smaller. This means that a screen inch isn't the same size as a real-world inch; on most systems, it's probably not. As you increase the DPI, DPI-aware graphics and text become larger because you've increased the size of the screen inch. Increasing the DPI can make text easier to read, especially at high resolutions.  \n  \n Not all applications are DPI-aware: some use hardware pixels as the primary unit of measurement; changing the system DPI has no effect on these applications. Many other applications use DPI-aware units to describe font sizes, but use pixels to describe everything else. Making the DPI too small or too large can cause layout problems for these applications, because the applications' text scales with the system's DPI setting, but the applications' UI does not. This problem has been eliminated for applications developed using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  \n  \n [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] supports automatic scaling by using the device independent pixel as its primary unit of measurement, instead of hardware pixels; graphics and text scale properly without any extra work from the application developer. The following illustration shows an example of how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] text and graphics are appear at different DPI settings.  \n  \n ![Graphics and text at different DPI settings](./media/graphicsmm-dpi-setting-examples.png \"graphicsmm_dpi_setting_examples\")  \nGraphics and text at different DPI settings  \n  \n<a name=\"visualtreehelper_class\"></a>   \n## VisualTreeHelper Class  \n The <xref:System.Windows.Media.VisualTreeHelper> class is a static helper class that provides low-level functionality for programming at the visual object level, which is useful in very specific scenarios, such as developing high-performance custom controls. In most case, the higher-level [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework objects, such as <xref:System.Windows.Controls.Canvas> and <xref:System.Windows.Controls.TextBlock>, offer greater flexibility and ease of use.  \n  \n### Hit Testing  \n The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for hit testing on visual objects when the default hit test support does not meet your needs. You can use the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> methods in the <xref:System.Windows.Media.VisualTreeHelper> class to determine whether a geometry or point coordinate value is within the boundary of a given object, such as a control or graphic element. For example, you could use hit testing to determine whether a mouse click within the bounding rectangle of an object falls within the geometry of a circle You can also choose to override the default implementation of hit testing to perform your own custom hit test calculations.  \n  \n For more information on hit testing, see [Hit Testing in the Visual Layer](hit-testing-in-the-visual-layer.md).  \n  \n### Enumerating the Visual Tree  \n The <xref:System.Windows.Media.VisualTreeHelper> class provides functionality for enumerating the members of a visual tree. To retrieve a parent, call the <xref:System.Windows.Media.VisualTreeHelper.GetParent%2A> method. To retrieve a child, or direct descendant, of a visual object, call the <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method. This method returns a child <xref:System.Windows.Media.Visual> of the parent at the specified index.  \n  \n The following example shows how to enumerate all the descendants of a visual object, which is a technique you might want to use if you were interested in serializing all the rendering information of a visual object hierarchy.  \n  \n [!code-csharp[VisualsOverview#101](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#101)]\n [!code-vb[VisualsOverview#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#101)]  \n  \n In most cases, the logical tree is a more useful representation of the elements in a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application. Although you do not modify the logical tree directly, this view of the application is useful for understanding property inheritance and event routing. Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>. For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md).  \n  \n The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for returning the bounding rectangle of visual objects. You can return the bounding rectangle of a visual object by calling <xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A>. You can return the bounding rectangle of all the descendants of a visual object, including the visual object itself, by calling <xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A>. The following code shows how you would calculate the bounding rectangle of a visual object and all its descendants.  \n  \n [!code-csharp[VisualsOverview#102](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualsOverview/CSharp/Window1.xaml.cs#102)]\n [!code-vb[VisualsOverview#102](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualsOverview/visualbasic/window1.xaml.vb#102)]  \n  \n## See also\n\n- <xref:System.Windows.Media.Visual>\n- <xref:System.Windows.Media.VisualTreeHelper>\n- <xref:System.Windows.Media.DrawingVisual>\n- [2D Graphics and Imaging](../advanced/optimizing-performance-2d-graphics-and-imaging.md)\n- [Hit Testing in the Visual Layer](hit-testing-in-the-visual-layer.md)\n- [Using DrawingVisual Objects](using-drawingvisual-objects.md)\n- [Tutorial: Hosting Visual Objects in a Win32 Application](tutorial-hosting-visual-objects-in-a-win32-application.md)\n- [Optimizing WPF Application Performance](../advanced/optimizing-wpf-application-performance.md)\n","nodes":[{"pos":[4,234],"embed":true,"restype":"x-metadata","content":"title: \"WPF Graphics Rendering Overview\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"graphics [WPF], rendering\"\n  - \"rendering graphics [WPF]\"\nms.assetid: 6dec9657-4d8c-4e46-8c54-40fb80008265","nodes":[{"content":"WPF Graphics Rendering Overview","nodes":[{"pos":[0,31],"content":"WPF Graphics Rendering Overview","nodes":[{"content":"WPF Graphics Rendering Overview","pos":[0,31]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[241,272],"content":"WPF Graphics Rendering Overview","linkify":"WPF Graphics Rendering Overview","nodes":[{"content":"WPF Graphics Rendering Overview","pos":[0,31]}]},{"content":"This topic provides an overview of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> visual layer.","pos":[273,407],"source":"This topic provides an overview of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual layer."},{"content":"It focuses on the role of the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> class for rendering support in the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> model.","pos":[408,596],"source":" It focuses on the role of the <xref:System.Windows.Media.Visual> class for rendering support in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] model."},{"pos":[643,668],"content":"Role of the Visual Object","linkify":"Role of the Visual Object","nodes":[{"content":"Role of the Visual Object","pos":[0,25]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> class is the basic abstraction from which every <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> object derives.","pos":[672,813],"source":"The <xref:System.Windows.Media.Visual> class is the basic abstraction from which every <xref:System.Windows.FrameworkElement> object derives."},{"content":"It also serves as the entry point for writing new controls in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, and in many ways can be thought of as the window handle (HWND) in the Win32 application model.","pos":[814,1053],"source":" It also serves as the entry point for writing new controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], and in many ways can be thought of as the window handle (HWND) in the Win32 application model."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> object is a core <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> object, whose primary role is to provide rendering support.","pos":[1060,1257],"source":"The <xref:System.Windows.Media.Visual> object is a core [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] object, whose primary role is to provide rendering support."},{"content":"User interface controls, such as <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, derive from the <ph id=\"ph3\">&lt;xref:System.Windows.Media.Visual&gt;</ph> class, and use it for persisting their rendering data.","pos":[1258,1478],"source":" User interface controls, such as <xref:System.Windows.Controls.Button> and <xref:System.Windows.Controls.TextBox>, derive from the <xref:System.Windows.Media.Visual> class, and use it for persisting their rendering data."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> object provides support for:","pos":[1479,1546],"source":" The <xref:System.Windows.Media.Visual> object provides support for:"},{"content":"Output display: Rendering the persisted, serialized drawing content of a visual.","pos":[1556,1636]},{"content":"Transformations: Performing transformations on a visual.","pos":[1646,1702]},{"content":"Clipping: Providing clipping region support for a visual.","pos":[1712,1769]},{"content":"Hit testing: Determining whether a coordinate or geometry is contained within the bounds of a visual.","pos":[1779,1880]},{"content":"Bounding box calculations: Determining the bounding rectangle of a visual.","pos":[1890,1964]},{"pos":[1971,2087],"content":"However, the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> object does not include support for non-rendering features, such as:","source":"However, the <xref:System.Windows.Media.Visual> object does not include support for non-rendering features, such as:"},{"content":"Event handling","pos":[2097,2111]},{"content":"Layout","pos":[2121,2127]},{"content":"Styles","pos":[2137,2143]},{"content":"Data binding","pos":[2153,2165]},{"content":"Globalization","pos":[2175,2188]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> is exposed as a public abstract class from which child classes must be derived.","pos":[2195,2309],"source":"<xref:System.Windows.Media.Visual> is exposed as a public abstract class from which child classes must be derived."},{"content":"The following illustration shows the hierarchy of the visual objects that are exposed in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[2310,2481],"source":" The following illustration shows the hierarchy of the visual objects that are exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"content":"Diagram of classes derived from the Visual object","pos":[2490,2539]},{"pos":[2627,2646],"content":"DrawingVisual Class","linkify":"DrawingVisual Class","nodes":[{"content":"DrawingVisual Class","pos":[0,19]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> is a lightweight drawing class that is used to render shapes, images, or text.","pos":[2650,2774],"source":"The <xref:System.Windows.Media.DrawingVisual> is a lightweight drawing class that is used to render shapes, images, or text."},{"content":"This class is considered lightweight because it does not provide layout or event handling, which improves its runtime performance.","pos":[2775,2905]},{"content":"For this reason, drawings are ideal for backgrounds and clip art.","pos":[2906,2971]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> can be used to create a custom visual object.","pos":[2972,3063],"source":" The <xref:System.Windows.Media.DrawingVisual> can be used to create a custom visual object."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Using DrawingVisual Objects<ept id=\"p1\">](using-drawingvisual-objects.md)</ept>.","pos":[3064,3152],"source":" For more information, see [Using DrawingVisual Objects](using-drawingvisual-objects.md)."},{"pos":[3162,3184],"content":"Viewport3DVisual Class","linkify":"Viewport3DVisual Class","nodes":[{"content":"Viewport3DVisual Class","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual&gt;</ph> provides a bridge between 2D <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Media.Media3D.Visual3D&gt;</ph> objects.","pos":[3188,3366],"source":"The <xref:System.Windows.Media.Media3D.Viewport3DVisual> provides a bridge between 2D <xref:System.Windows.Media.Visual> and <xref:System.Windows.Media.Media3D.Visual3D> objects."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Media3D.Visual3D&gt;</ph> class is the base class for all 3D visual elements.","pos":[3367,3467],"source":" The <xref:System.Windows.Media.Media3D.Visual3D> class is the base class for all 3D visual elements."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual&gt;</ph> requires that you define a <ph id=\"ph2\">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A&gt;</ph> value and a <ph id=\"ph3\">&lt;xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A&gt;</ph> value.","pos":[3468,3698],"source":" The <xref:System.Windows.Media.Media3D.Viewport3DVisual> requires that you define a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Camera%2A> value and a <xref:System.Windows.Media.Media3D.Viewport3DVisual.Viewport%2A> value."},{"content":"The camera allows you to view the scene.","pos":[3699,3739]},{"content":"The viewport establishes where the projection maps onto the 2D surface.","pos":[3740,3811]},{"content":"For more information on 3D in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>3-D Graphics Overview<ept id=\"p1\">](3-d-graphics-overview.md)</ept>.","pos":[3812,3979],"source":" For more information on 3D in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [3-D Graphics Overview](3-d-graphics-overview.md)."},{"pos":[3989,4010],"content":"ContainerVisual Class","linkify":"ContainerVisual Class","nodes":[{"content":"ContainerVisual Class","pos":[0,21]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.ContainerVisual&gt;</ph> class is used as a container for a collection of <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> objects.","pos":[4014,4154],"source":"The <xref:System.Windows.Media.ContainerVisual> class is used as a container for a collection of <xref:System.Windows.Media.Visual> objects."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> class derives from the <ph id=\"ph2\">&lt;xref:System.Windows.Media.ContainerVisual&gt;</ph> class, allowing it to contain a collection of visual objects.","pos":[4155,4329],"source":" The <xref:System.Windows.Media.DrawingVisual> class derives from the <xref:System.Windows.Media.ContainerVisual> class, allowing it to contain a collection of visual objects."},{"pos":[4339,4372],"content":"Drawing Content in Visual Objects","linkify":"Drawing Content in Visual Objects","nodes":[{"content":"Drawing Content in Visual Objects","pos":[0,33]}]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> object stores its render data as a <bpt id=\"p1\">**</bpt>vector graphics instruction list<ept id=\"p1\">**</ept>.","pos":[4376,4485],"source":"A <xref:System.Windows.Media.Visual> object stores its render data as a **vector graphics instruction list**."},{"content":"Each item in the instruction list represents a low-level set of graphics data and associated resources in a serialized format.","pos":[4486,4612]},{"content":"There are four different types of render data that can contain drawing content.","pos":[4613,4692]},{"content":"Drawing content type","pos":[4699,4719]},{"content":"Description","pos":[4720,4731]},{"content":"Vector graphics","pos":[4785,4800]},{"pos":[4801,4935],"content":"Represents vector graphics data, and any associated <ph id=\"ph1\">&lt;xref:System.Windows.Media.Brush&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.Pen&gt;</ph> information.","source":"Represents vector graphics data, and any associated <xref:System.Windows.Media.Brush> and <xref:System.Windows.Media.Pen> information."},{"content":"Image","pos":[4940,4945]},{"pos":[4946,5022],"content":"Represents an image within a region defined by a <ph id=\"ph1\">&lt;xref:System.Windows.Rect&gt;</ph>.","source":"Represents an image within a region defined by a <xref:System.Windows.Rect>."},{"content":"Glyph","pos":[5027,5032]},{"content":"Represents a drawing that renders a <ph id=\"ph1\">&lt;xref:System.Windows.Media.GlyphRun&gt;</ph>, which is a sequence of glyphs from a specified font resource.","pos":[5033,5168],"source":"Represents a drawing that renders a <xref:System.Windows.Media.GlyphRun>, which is a sequence of glyphs from a specified font resource."},{"content":"This is how text is represented.","pos":[5169,5201]},{"content":"Video","pos":[5206,5211]},{"content":"Represents a drawing that renders video.","pos":[5212,5252]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> allows you to populate a <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> with visual content.","pos":[5260,5387],"source":"The <xref:System.Windows.Media.DrawingContext> allows you to populate a <xref:System.Windows.Media.Visual> with visual content."},{"content":"When you use a <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> object's draw commands, you are actually storing a set of render data that will later be used by the graphics system; you are not drawing to the screen in real-time.","pos":[5388,5611],"source":" When you use a <xref:System.Windows.Media.DrawingContext> object's draw commands, you are actually storing a set of render data that will later be used by the graphics system; you are not drawing to the screen in real-time."},{"content":"When you create a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> control, such as a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph>, the control implicitly generates render data for drawing itself.","pos":[5618,5840],"source":"When you create a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, such as a <xref:System.Windows.Controls.Button>, the control implicitly generates render data for drawing itself."},{"content":"For example, setting the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph> causes the control to store a rendering representation of a glyph.","pos":[5841,6043],"source":" For example, setting the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the <xref:System.Windows.Controls.Button> causes the control to store a rendering representation of a glyph."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> describes its content as one or more <ph id=\"ph2\">&lt;xref:System.Windows.Media.Drawing&gt;</ph> objects contained within a <ph id=\"ph3\">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph>.","pos":[6050,6228],"source":"A <xref:System.Windows.Media.Visual> describes its content as one or more <xref:System.Windows.Media.Drawing> objects contained within a <xref:System.Windows.Media.DrawingGroup>."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> also describes opacity masks, transforms, bitmap effects, and other operations that are applied to its contents.","pos":[6229,6384],"source":" A <xref:System.Windows.Media.DrawingGroup> also describes opacity masks, transforms, bitmap effects, and other operations that are applied to its contents."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> operations are applied in the following order when content is rendered: <ph id=\"ph2\">&lt;xref:System.Windows.Media.DrawingGroup.OpacityMask%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.Media.DrawingGroup.Opacity%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A&gt;</ph>, and then <ph id=\"ph7\">&lt;xref:System.Windows.Media.DrawingGroup.Transform%2A&gt;</ph>.","pos":[6385,6845],"source":"<xref:System.Windows.Media.DrawingGroup> operations are applied in the following order when content is rendered: <xref:System.Windows.Media.DrawingGroup.OpacityMask%2A>, <xref:System.Windows.Media.DrawingGroup.Opacity%2A>, <xref:System.Windows.Media.DrawingGroup.BitmapEffect%2A>, <xref:System.Windows.Media.DrawingGroup.ClipGeometry%2A>, <xref:System.Windows.Media.DrawingGroup.GuidelineSet%2A>, and then <xref:System.Windows.Media.DrawingGroup.Transform%2A>."},{"pos":[6852,6998],"content":"The following illustration shows the order in which <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> operations are applied during the rendering sequence.","source":"The following illustration shows the order in which <xref:System.Windows.Media.DrawingGroup> operations are applied during the rendering sequence."},{"content":"<bpt id=\"p1\">![</bpt>DrawingGroup order of operations<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/graphcismm-drawinggroup-order.png \"</bpt>graphcismm_drawinggroup_order<ept id=\"p2\">\")</ept>","pos":[7005,7115],"source":"![DrawingGroup order of operations](./media/graphcismm-drawinggroup-order.png \"graphcismm_drawinggroup_order\")"},{"content":"Order of DrawingGroup operations","pos":[7118,7150]},{"pos":[7157,7239],"content":"For more information, see <bpt id=\"p1\">[</bpt>Drawing Objects Overview<ept id=\"p1\">](drawing-objects-overview.md)</ept>.","source":"For more information, see [Drawing Objects Overview](drawing-objects-overview.md)."},{"pos":[7250,7285],"content":"Drawing Content at the Visual Layer","linkify":"Drawing Content at the Visual Layer","nodes":[{"content":"Drawing Content at the Visual Layer","pos":[0,35]}]},{"content":"You never directly instantiate a <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph>; you can, however, acquire a drawing context from certain methods, such as <ph id=\"ph2\">&lt;xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType&gt;</ph>.","pos":[7289,7607],"source":"You never directly instantiate a <xref:System.Windows.Media.DrawingContext>; you can, however, acquire a drawing context from certain methods, such as <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> and <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>."},{"content":"The following example retrieves a <ph id=\"ph1\">&lt;xref:System.Windows.Media.DrawingContext&gt;</ph> from a <ph id=\"ph2\">&lt;xref:System.Windows.Media.DrawingVisual&gt;</ph> and uses it to draw a rectangle.","pos":[7608,7766],"source":" The following example retrieves a <xref:System.Windows.Media.DrawingContext> from a <xref:System.Windows.Media.DrawingVisual> and uses it to draw a rectangle."},{"pos":[8050,8097],"content":"Enumerating Drawing Content at the Visual Layer","linkify":"Enumerating Drawing Content at the Visual Layer","nodes":[{"content":"Enumerating Drawing Content at the Visual Layer","pos":[0,47]}]},{"pos":[8101,8276],"content":"In addition to their other uses, <ph id=\"ph1\">&lt;xref:System.Windows.Media.Drawing&gt;</ph> objects also provide an object model for enumerating the contents of a <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph>.","source":"In addition to their other uses, <xref:System.Windows.Media.Drawing> objects also provide an object model for enumerating the contents of a <xref:System.Windows.Media.Visual>."},{"pos":[8284,8507],"content":"[!NOTE]\n When you are enumerating the contents of the visual, you are retrieving <xref:System.Windows.Media.Drawing> objects, and not the underlying representation of the render data as a vector graphics instruction list.","leadings":["","> "],"nodes":[{"content":"When you are enumerating the contents of the visual, you are retrieving <ph id=\"ph1\">&lt;xref:System.Windows.Media.Drawing&gt;</ph> objects, and not the underlying representation of the render data as a vector graphics instruction list.","pos":[9,221],"source":"When you are enumerating the contents of the visual, you are retrieving <xref:System.Windows.Media.Drawing> objects, and not the underlying representation of the render data as a vector graphics instruction list."}]},{"pos":[8514,8731],"content":"The following example uses the <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A&gt;</ph> method to retrieve the <ph id=\"ph2\">&lt;xref:System.Windows.Media.DrawingGroup&gt;</ph> value of a <ph id=\"ph3\">&lt;xref:System.Windows.Media.Visual&gt;</ph> and enumerate it.","source":"The following example uses the <xref:System.Windows.Media.VisualTreeHelper.GetDrawing%2A> method to retrieve the <xref:System.Windows.Media.DrawingGroup> value of a <xref:System.Windows.Media.Visual> and enumerate it."},{"pos":[9013,9058],"content":"How Visual Objects are Used to Build Controls","linkify":"How Visual Objects are Used to Build Controls","nodes":[{"content":"How Visual Objects are Used to Build Controls","pos":[0,45]}]},{"content":"Many of the objects in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> are composed of other visual objects, meaning they can contain varying hierarchies of descendant objects.","pos":[9062,9272],"source":"Many of the objects in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are composed of other visual objects, meaning they can contain varying hierarchies of descendant objects."},{"content":"Many of the user interface elements in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, such as controls, are composed of multiple visual objects, representing different types of rendering elements.","pos":[9273,9505],"source":" Many of the user interface elements in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], such as controls, are composed of multiple visual objects, representing different types of rendering elements."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control can contain a number of other objects, including <ph id=\"ph2\">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>.","pos":[9506,9768],"source":" For example, the <xref:System.Windows.Controls.Button> control can contain a number of other objects, including <xref:Microsoft.Windows.Themes.ClassicBorderDecorator>, <xref:System.Windows.Controls.ContentPresenter>, and <xref:System.Windows.Controls.TextBlock>."},{"pos":[9775,9866],"content":"The following code shows a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control defined in markup.","source":"The following code shows a <xref:System.Windows.Controls.Button> control defined in markup."},{"pos":[10036,10218],"content":"If you were to enumerate the visual objects that comprise the default <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control, you would find the hierarchy of visual objects illustrated below:","source":"If you were to enumerate the visual objects that comprise the default <xref:System.Windows.Controls.Button> control, you would find the hierarchy of visual objects illustrated below:"},{"content":"Diagram of visual tree hierarchy","pos":[10227,10259]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control contains a <ph id=\"ph2\">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element, which in turn, contains a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element.","pos":[10333,10540],"source":"The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element is responsible for drawing a border and a background for the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","pos":[10541,10707],"source":" The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing a border and a background for the <xref:System.Windows.Controls.Button>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element is responsible for displaying the contents of the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","pos":[10708,10856],"source":" The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>."},{"content":"In this case, since you are displaying text, the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element contains a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph> element.","pos":[10857,11022],"source":" In this case, since you are displaying text, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.TextBlock> element."},{"content":"The fact that the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control uses a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> means that the content could be represented by other elements, such as an <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Image&gt;</ph> or a geometry, such as an <ph id=\"ph4\">&lt;xref:System.Windows.Media.EllipseGeometry&gt;</ph>.","pos":[11023,11323],"source":" The fact that the <xref:System.Windows.Controls.Button> control uses a <xref:System.Windows.Controls.ContentPresenter> means that the content could be represented by other elements, such as an <xref:System.Windows.Controls.Image> or a geometry, such as an <xref:System.Windows.Media.EllipseGeometry>."},{"pos":[11333,11350],"content":"Control Templates","linkify":"Control Templates","nodes":[{"content":"Control Templates","pos":[0,17]}]},{"content":"The key to the expansion of a control into a hierarchy of controls is the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph>.","pos":[11354,11475],"source":"The key to the expansion of a control into a hierarchy of controls is the <xref:System.Windows.Controls.ControlTemplate>."},{"content":"A control template specifies the default visual hierarchy for a control.","pos":[11476,11548]},{"content":"When you explicitly reference a control, you implicitly reference its visual hierarchy.","pos":[11549,11636]},{"content":"You can override the default values for a control template to create a customized visual appearance for a control.","pos":[11637,11751]},{"content":"For example, you could modify the background color value of the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control so that it uses a linear gradient color value instead of a solid color value.","pos":[11752,11939],"source":" For example, you could modify the background color value of the <xref:System.Windows.Controls.Button> control so that it uses a linear gradient color value instead of a solid color value."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Button Styles and Templates<ept id=\"p1\">](../controls/button-styles-and-templates.md)</ept>.","pos":[11940,12040],"source":" For more information, see [Button Styles and Templates](../controls/button-styles-and-templates.md)."},{"content":"A user interface element, such as a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control, contains several vector graphics instruction lists that describe the entire rendering definition of a control.","pos":[12047,12240],"source":"A user interface element, such as a <xref:System.Windows.Controls.Button> control, contains several vector graphics instruction lists that describe the entire rendering definition of a control."},{"content":"The following code shows a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control defined in markup.","pos":[12241,12332],"source":" The following code shows a <xref:System.Windows.Controls.Button> control defined in markup."},{"pos":[12502,12707],"content":"If you were to enumerate the visual objects and vector graphics instruction lists that comprise the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control, you would find the hierarchy of objects illustrated below:","source":"If you were to enumerate the visual objects and vector graphics instruction lists that comprise the <xref:System.Windows.Controls.Button> control, you would find the hierarchy of objects illustrated below:"},{"content":"Diagram of visual tree and rendering data","pos":[12716,12757]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control contains a <ph id=\"ph2\">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element, which in turn, contains a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element.","pos":[12837,13044],"source":"The <xref:System.Windows.Controls.Button> control contains a <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element, which in turn, contains a <xref:System.Windows.Controls.ContentPresenter> element."},{"content":"The <ph id=\"ph1\">&lt;xref:Microsoft.Windows.Themes.ClassicBorderDecorator&gt;</ph> element is responsible for drawing all the discrete graphic elements that make up the border and background of a button.","pos":[13045,13224],"source":" The <xref:Microsoft.Windows.Themes.ClassicBorderDecorator> element is responsible for drawing all the discrete graphic elements that make up the border and background of a button."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element is responsible for displaying the contents of the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","pos":[13225,13373],"source":" The <xref:System.Windows.Controls.ContentPresenter> element is responsible for displaying the contents of the <xref:System.Windows.Controls.Button>."},{"content":"In this case, since you are displaying an image, the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element contains a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Image&gt;</ph> element.","pos":[13374,13539],"source":" In this case, since you are displaying an image, the <xref:System.Windows.Controls.ContentPresenter> element contains a <xref:System.Windows.Controls.Image> element."},{"content":"There are a number of points to note about the hierarchy of visual objects and vector graphics instruction lists:","pos":[13546,13659]},{"content":"The ordering in the hierarchy represents the rendering order of the drawing information.","pos":[13669,13757]},{"content":"From the root visual element, child elements are traversed, left to right, top to bottom.","pos":[13758,13847]},{"content":"If an element has visual child elements, they are traversed before the element’s siblings.","pos":[13848,13938]},{"pos":[13948,14119],"content":"Non-leaf node elements in the hierarchy, such as <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph>, are used to contain child elements—they do not contain instruction lists.","source":"Non-leaf node elements in the hierarchy, such as <xref:System.Windows.Controls.ContentPresenter>, are used to contain child elements—they do not contain instruction lists."},{"content":"If a visual element contains both a vector graphics instruction list and visual children, the instruction list in the parent visual element is rendered before drawings in any of the visual child objects.","pos":[14129,14332]},{"content":"The items in the vector graphics instruction list are rendered left to right.","pos":[14342,14419]},{"pos":[14458,14469],"content":"Visual Tree","linkify":"Visual Tree","nodes":[{"content":"Visual Tree","pos":[0,11]}]},{"content":"The visual tree contains all visual elements used in an application's user interface.","pos":[14473,14558]},{"content":"Since a visual element contains persisted drawing information, you can think of the visual tree as a scene graph, containing all the rendering information needed to compose the output to the display device.","pos":[14559,14765]},{"content":"This tree is the accumulation of all visual elements created directly by the application, whether in code or in markup.","pos":[14766,14885]},{"content":"The visual tree also contains all visual elements created by the template expansion of elements such as controls and data objects.","pos":[14886,15016]},{"pos":[15023,15118],"content":"The following code shows a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> element defined in markup.","source":"The following code shows a <xref:System.Windows.Controls.StackPanel> element defined in markup."},{"pos":[15288,15488],"content":"If you were to enumerate the visual objects that comprise the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> element in the markup example, you would find the hierarchy of visual objects illustrated below:","source":"If you were to enumerate the visual objects that comprise the <xref:System.Windows.Controls.StackPanel> element in the markup example, you would find the hierarchy of visual objects illustrated below:"},{"content":"Diagram of visual tree hierarchy","pos":[15497,15529]},{"pos":[15607,15622],"content":"Rendering Order","linkify":"Rendering Order","nodes":[{"content":"Rendering Order","pos":[0,15]}]},{"content":"The visual tree determines the rendering order of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> visual and drawing objects.","pos":[15626,15785],"source":"The visual tree determines the rendering order of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual and drawing objects."},{"content":"The order of traversal starts with the root visual, which is the top-most node in the visual tree.","pos":[15786,15884]},{"content":"The root visual’s children are then traversed, left to right.","pos":[15885,15946]},{"content":"If a visual has children, its children are traversed before the visual’s siblings.","pos":[15947,16029]},{"content":"This means that the content of a child visual is rendered in front of the visual's own content.","pos":[16030,16125]},{"content":"Diagram of the visual tree rendering order","pos":[16134,16176]},{"pos":[16259,16270],"content":"Root Visual","linkify":"Root Visual","nodes":[{"content":"Root Visual","pos":[0,11]}]},{"content":"The <bpt id=\"p1\">**</bpt>root visual<ept id=\"p1\">**</ept> is the top-most element in a visual tree hierarchy.","pos":[16274,16345],"source":"The **root visual** is the top-most element in a visual tree hierarchy."},{"content":"In most applications, the base class of the root visual is either <ph id=\"ph1\">&lt;xref:System.Windows.Window&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.Navigation.NavigationWindow&gt;</ph>.","pos":[16346,16494],"source":" In most applications, the base class of the root visual is either <xref:System.Windows.Window> or <xref:System.Windows.Navigation.NavigationWindow>."},{"content":"However, if you were hosting visual objects in a Win32 application, the root visual would be the top-most visual you were hosting in the Win32 window.","pos":[16495,16645]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Tutorial: Hosting Visual Objects in a Win32 Application<ept id=\"p1\">](tutorial-hosting-visual-objects-in-a-win32-application.md)</ept>.","pos":[16646,16789],"source":" For more information, see [Tutorial: Hosting Visual Objects in a Win32 Application](tutorial-hosting-visual-objects-in-a-win32-application.md)."},{"pos":[16799,16831],"content":"Relationship to the Logical Tree","linkify":"Relationship to the Logical Tree","nodes":[{"content":"Relationship to the Logical Tree","pos":[0,32]}]},{"content":"The logical tree in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> represents the elements of an application at run time.","pos":[16835,16991],"source":"The logical tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] represents the elements of an application at run time."},{"content":"Although you do not manipulate this tree directly, this view of the application is useful for understanding property inheritance and event routing.","pos":[16992,17139]},{"content":"Unlike the visual tree, the logical tree can represent non-visual data objects, such as <ph id=\"ph1\">&lt;xref:System.Windows.Documents.ListItem&gt;</ph>.","pos":[17140,17269],"source":" Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>."},{"content":"In many cases, the logical tree maps very closely to an application's markup definitions.","pos":[17270,17359]},{"content":"The following code shows a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> element defined in markup.","pos":[17360,17454],"source":" The following code shows a <xref:System.Windows.Controls.DockPanel> element defined in markup."},{"pos":[17624,17825],"content":"If you were to enumerate the logical objects that comprise the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph> element in the markup example, you would find the hierarchy of logical objects illustrated below:","source":"If you were to enumerate the logical objects that comprise the <xref:System.Windows.Controls.DockPanel> element in the markup example, you would find the hierarchy of logical objects illustrated below:"},{"content":"<bpt id=\"p1\">![</bpt>Tree diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/tree1-wcp.gif \"</bpt>Tree1_wcp<ept id=\"p2\">\")</ept>","pos":[17832,17882],"source":"![Tree diagram](./media/tree1-wcp.gif \"Tree1_wcp\")"},{"content":"Diagram of logical tree","pos":[17885,17908]},{"content":"Both the visual tree and logical tree are synchronized with the current set of application elements, reflecting any addition, deletion, or modification of elements.","pos":[17915,18079]},{"content":"However, the trees present different views of the application.","pos":[18080,18142]},{"content":"Unlike the visual tree, the logical tree does not expand a control's <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentPresenter&gt;</ph> element.","pos":[18143,18268],"source":" Unlike the visual tree, the logical tree does not expand a control's <xref:System.Windows.Controls.ContentPresenter> element."},{"content":"This means there is not a direct one-to-one correspondence between a logical tree and a visual tree for the same set of objects.","pos":[18269,18397]},{"content":"In fact, invoking the <bpt id=\"p1\">**</bpt>LogicalTreeHelper<ept id=\"p1\">**</ept> object's <ph id=\"ph1\">&lt;xref:System.Windows.LogicalTreeHelper.GetChildren%2A&gt;</ph> method and the <bpt id=\"p2\">**</bpt>VisualTreeHelper<ept id=\"p2\">**</ept> object's <ph id=\"ph2\">&lt;xref:System.Windows.Media.VisualTreeHelper.GetChild%2A&gt;</ph> method using the same element as a parameter yields differing results.","pos":[18398,18678],"source":" In fact, invoking the **LogicalTreeHelper** object's <xref:System.Windows.LogicalTreeHelper.GetChildren%2A> method and the **VisualTreeHelper** object's <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method using the same element as a parameter yields differing results."},{"pos":[18685,18775],"content":"For more information on the logical tree, see <bpt id=\"p1\">[</bpt>Trees in WPF<ept id=\"p1\">](../advanced/trees-in-wpf.md)</ept>.","source":"For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md)."},{"pos":[18785,18821],"content":"Viewing the Visual Tree with XamlPad","linkify":"Viewing the Visual Tree with XamlPad","nodes":[{"content":"Viewing the Visual Tree with XamlPad","pos":[0,36]}]},{"content":"The <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> tool, XamlPad, provides an option for viewing and exploring the visual tree that corresponds to the currently defined <ph id=\"ph2\">[!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)]</ph> content.","pos":[18825,19117],"source":"The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tool, XamlPad, provides an option for viewing and exploring the visual tree that corresponds to the currently defined [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] content."},{"content":"Click the <bpt id=\"p1\">**</bpt>Show Visual Tree<ept id=\"p1\">**</ept> button on the menu bar to display the visual tree.","pos":[19118,19199],"source":" Click the **Show Visual Tree** button on the menu bar to display the visual tree."},{"content":"The following illustrates the expansion of <ph id=\"ph1\">[!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)]</ph> content into visual tree nodes in the <bpt id=\"p1\">**</bpt>Visual Tree Explorer<ept id=\"p1\">**</ept> panel of XamlPad:","pos":[19200,19403],"source":" The following illustrates the expansion of [!INCLUDE[TLA#tla_titlexaml](../../../../includes/tlasharptla-titlexaml-md.md)] content into visual tree nodes in the **Visual Tree Explorer** panel of XamlPad:"},{"content":"Visual Tree Explorer panel in XamlPad","pos":[19412,19449]},{"content":"Notice how the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Label&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Button&gt;</ph> controls each display a separate visual object hierarchy in the <bpt id=\"p1\">**</bpt>Visual Tree Explorer<ept id=\"p1\">**</ept> panel of XamlPad.","pos":[19521,19762],"source":"Notice how the <xref:System.Windows.Controls.Label>, <xref:System.Windows.Controls.TextBox>, and <xref:System.Windows.Controls.Button> controls each display a separate visual object hierarchy in the **Visual Tree Explorer** panel of XamlPad."},{"content":"This is because <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> controls have a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> that contains the visual tree of that control.","pos":[19763,19970],"source":" This is because [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have a <xref:System.Windows.Controls.ControlTemplate> that contains the visual tree of that control."},{"content":"When you explicitly reference a control, you implicitly reference its visual hierarchy.","pos":[19971,20058]},{"pos":[20068,20096],"content":"Profiling Visual Performance","linkify":"Profiling Visual Performance","nodes":[{"content":"Profiling Visual Performance","pos":[0,28]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> provides a suite of performance profiling tools that allow you to analyze the run-time behavior of your application and determine the types of performance optimizations you can apply.","pos":[20100,20365],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides a suite of performance profiling tools that allow you to analyze the run-time behavior of your application and determine the types of performance optimizations you can apply."},{"content":"The Visual Profiler tool provides a rich, graphical view of performance data by mapping directly to the application's visual tree.","pos":[20366,20496]},{"content":"In this screenshot, the <bpt id=\"p1\">**</bpt>CPU Usage<ept id=\"p1\">**</ept> section of the Visual Profiler gives you a precise breakdown of an object's use of <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> services, such as rendering and layout.","pos":[20497,20739],"source":" In this screenshot, the **CPU Usage** section of the Visual Profiler gives you a precise breakdown of an object's use of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] services, such as rendering and layout."},{"content":"<bpt id=\"p1\">![</bpt>Visual Profiler display output<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/wpfperf-visualprofiler-04.png \"</bpt>WPFPerf_VisualProfiler_04<ept id=\"p2\">\")</ept>","pos":[20746,20846],"source":"![Visual Profiler display output](./media/wpfperf-visualprofiler-04.png \"WPFPerf_VisualProfiler_04\")"},{"content":"Visual Profiler display output","pos":[20849,20879]},{"pos":[20932,20957],"content":"Visual Rendering Behavior","linkify":"Visual Rendering Behavior","nodes":[{"content":"Visual Rendering Behavior","pos":[0,25]}]},{"pos":[20961,21198],"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> introduces several features that affect the rendering behavior of visual objects: retained mode graphics, vector graphics, and device independent graphics.","source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] introduces several features that affect the rendering behavior of visual objects: retained mode graphics, vector graphics, and device independent graphics."},{"pos":[21208,21230],"content":"Retained Mode Graphics","linkify":"Retained Mode Graphics","nodes":[{"content":"Retained Mode Graphics","pos":[0,22]}]},{"content":"One of the keys to understanding the role of the Visual object is to understand the difference between <bpt id=\"p1\">**</bpt>immediate mode<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>retained mode<ept id=\"p2\">**</ept> graphics systems.","pos":[21234,21395],"source":"One of the keys to understanding the role of the Visual object is to understand the difference between **immediate mode** and **retained mode** graphics systems."},{"content":"A standard Win32 application based on GDI or GDI+ uses an immediate mode graphics system.","pos":[21396,21485]},{"content":"This means that the application is responsible for repainting the portion of the client area that is invalidated, due to an action such as a window being resized, or an object changing its visual appearance.","pos":[21486,21693]},{"content":"Diagram of Win32 rendering sequence","pos":[21702,21737]},{"content":"In contrast, <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> uses a retained mode system.","pos":[21814,21937],"source":"In contrast, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a retained mode system."},{"content":"This means application objects that have a visual appearance define a set of serialized drawing data.","pos":[21938,22039]},{"content":"Once the drawing data is defined, the system is responsible thereafter for responding to all repaint requests for rendering the application objects.","pos":[22040,22188]},{"content":"Even at run time, you can modify or create application objects, and still rely on the system for responding to paint requests.","pos":[22189,22315]},{"content":"The power in a retained mode graphics system is that drawing information is always persisted in a serialized state by the application, but rendering responsibility left to the system.","pos":[22316,22499]},{"content":"The following diagram shows how the application relies on <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> for responding to paint requests.","pos":[22500,22673],"source":" The following diagram shows how the application relies on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] for responding to paint requests."},{"content":"Diagram of WPF rendering sequence","pos":[22682,22715]},{"pos":[22793,22814],"content":"Intelligent Redrawing","linkify":"Intelligent Redrawing","nodes":[{"content":"Intelligent Redrawing","pos":[0,21]}]},{"content":"One of the biggest benefits in using retained mode graphics is that <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> can efficiently optimize what needs to be redrawn in the application.","pos":[22818,23037],"source":"One of the biggest benefits in using retained mode graphics is that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can efficiently optimize what needs to be redrawn in the application."},{"content":"Even if you have a complex scene with varying levels of opacity, you generally do not need to write special-purpose code to optimize redrawing.","pos":[23038,23181]},{"content":"Compare this with Win32 programming in which you can spend a great deal of effort in optimizing your application by minimizing the amount of redrawing in the update region.","pos":[23182,23354]},{"content":"See <bpt id=\"p1\">[</bpt>Redrawing in the Update Region<ept id=\"p1\">](/windows/desktop/gdi/redrawing-in-the-update-region)</ept> for an example of the type of complexity involved in optimizing redrawing in Win32 applications.","pos":[23355,23541],"source":" See [Redrawing in the Update Region](/windows/desktop/gdi/redrawing-in-the-update-region) for an example of the type of complexity involved in optimizing redrawing in Win32 applications."},{"pos":[23551,23566],"content":"Vector Graphics","linkify":"Vector Graphics","nodes":[{"content":"Vector Graphics","pos":[0,15]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> uses <bpt id=\"p1\">**</bpt>vector graphics<ept id=\"p1\">**</ept> as its rendering data format.","pos":[23570,23706],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses **vector graphics** as its rendering data format."},{"content":"Vector graphics—which include Scalable Vector Graphics (SVG), Windows metafiles (.wmf), and TrueType fonts—store rendering data and transmit it as a list of instructions that describe how to recreate an image using graphics primitives.","pos":[23707,23942]},{"content":"For example, TrueType fonts are outline fonts that describe a set of lines, curves, and commands, rather than an array of pixels.","pos":[23943,24072]},{"content":"One of the key benefits of vector graphics is the ability to scale to any size and resolution.","pos":[24073,24167]},{"content":"Unlike vector graphics, bitmap graphics store rendering data as a pixel-by-pixel representation of an image, pre-rendered for a specific resolution.","pos":[24174,24322]},{"content":"One of the key differences between bitmap and vector graphic formats is fidelity to the original source image.","pos":[24323,24433]},{"content":"For example, when the size of a source image is modified, bitmap graphics systems stretch the image, whereas vector graphics systems scale the image, preserving the image fidelity.","pos":[24434,24614]},{"content":"The following illustration shows a source image that has been resized by 300%.","pos":[24621,24699]},{"content":"Notice the distortions that appear when the source image is stretched as a bitmap graphics image rather than scaled as a vector graphics image.","pos":[24700,24843]},{"content":"Differences between raster and vector graphics","pos":[24852,24898]},{"content":"The following markup shows two <ph id=\"ph1\">&lt;xref:System.Windows.Shapes.Path&gt;</ph> elements defined.","pos":[24977,25059],"source":"The following markup shows two <xref:System.Windows.Shapes.Path> elements defined."},{"content":"The second element uses a <ph id=\"ph1\">&lt;xref:System.Windows.Media.ScaleTransform&gt;</ph> to resize the drawing instructions of the first element by 300%.","pos":[25060,25193],"source":" The second element uses a <xref:System.Windows.Media.ScaleTransform> to resize the drawing instructions of the first element by 300%."},{"content":"Notice that the drawing instructions in the <ph id=\"ph1\">&lt;xref:System.Windows.Shapes.Path&gt;</ph> elements remain unchanged.","pos":[25194,25298],"source":" Notice that the drawing instructions in the <xref:System.Windows.Shapes.Path> elements remain unchanged."},{"pos":[25479,25527],"content":"About Resolution and Device-Independent Graphics","linkify":"About Resolution and Device-Independent Graphics","nodes":[{"content":"About Resolution and Device-Independent Graphics","pos":[0,48]}]},{"content":"There are two system factors that determine the size of text and graphics on your screen: resolution and DPI.","pos":[25531,25640]},{"content":"Resolution describes the number of pixels that appear on the screen.","pos":[25641,25709]},{"content":"As the resolution gets higher, pixels get smaller, causing graphics and text to appear smaller.","pos":[25710,25805]},{"content":"A graphic displayed on a monitor set to 1024 x 768 will appear much smaller when the resolution is changed to 1600 x 1200.","pos":[25806,25928]},{"content":"The other system setting, DPI, describes the size of a screen inch in pixels.","pos":[25935,26012]},{"content":"Most <ph id=\"ph1\">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]</ph> systems have a DPI of 96, which means a screen inch is 96 pixels.","pos":[26013,26155],"source":" Most [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] systems have a DPI of 96, which means a screen inch is 96 pixels."},{"content":"Increasing the DPI setting makes the screen inch larger; decreasing the DPI makes the screen inch smaller.","pos":[26156,26262]},{"content":"This means that a screen inch isn't the same size as a real-world inch; on most systems, it's probably not.","pos":[26263,26370]},{"content":"As you increase the DPI, DPI-aware graphics and text become larger because you've increased the size of the screen inch.","pos":[26371,26491]},{"content":"Increasing the DPI can make text easier to read, especially at high resolutions.","pos":[26492,26572]},{"content":"Not all applications are DPI-aware: some use hardware pixels as the primary unit of measurement; changing the system DPI has no effect on these applications.","pos":[26579,26736]},{"content":"Many other applications use DPI-aware units to describe font sizes, but use pixels to describe everything else.","pos":[26737,26848]},{"content":"Making the DPI too small or too large can cause layout problems for these applications, because the applications' text scales with the system's DPI setting, but the applications' UI does not.","pos":[26849,27040]},{"content":"This problem has been eliminated for applications developed using <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[27041,27189],"source":" This problem has been eliminated for applications developed using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> supports automatic scaling by using the device independent pixel as its primary unit of measurement, instead of hardware pixels; graphics and text scale properly without any extra work from the application developer.","pos":[27196,27494],"source":"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] supports automatic scaling by using the device independent pixel as its primary unit of measurement, instead of hardware pixels; graphics and text scale properly without any extra work from the application developer."},{"content":"The following illustration shows an example of how <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> text and graphics are appear at different DPI settings.","pos":[27495,27683],"source":" The following illustration shows an example of how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] text and graphics are appear at different DPI settings."},{"content":"<bpt id=\"p1\">![</bpt>Graphics and text at different DPI settings<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/graphicsmm-dpi-setting-examples.png \"</bpt>graphicsmm_dpi_setting_examples<ept id=\"p2\">\")</ept>","pos":[27690,27815],"source":"![Graphics and text at different DPI settings](./media/graphicsmm-dpi-setting-examples.png \"graphicsmm_dpi_setting_examples\")"},{"content":"Graphics and text at different DPI settings","pos":[27818,27861]},{"pos":[27911,27933],"content":"VisualTreeHelper Class","linkify":"VisualTreeHelper Class","nodes":[{"content":"VisualTreeHelper Class","pos":[0,22]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class is a static helper class that provides low-level functionality for programming at the visual object level, which is useful in very specific scenarios, such as developing high-performance custom controls.","pos":[27937,28195],"source":"The <xref:System.Windows.Media.VisualTreeHelper> class is a static helper class that provides low-level functionality for programming at the visual object level, which is useful in very specific scenarios, such as developing high-performance custom controls."},{"content":"In most case, the higher-level <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> framework objects, such as <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, offer greater flexibility and ease of use.","pos":[28196,28462],"source":" In most case, the higher-level [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework objects, such as <xref:System.Windows.Controls.Canvas> and <xref:System.Windows.Controls.TextBlock>, offer greater flexibility and ease of use."},{"pos":[28472,28483],"content":"Hit Testing","linkify":"Hit Testing","nodes":[{"content":"Hit Testing","pos":[0,11]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class provides methods for hit testing on visual objects when the default hit test support does not meet your needs.","pos":[28487,28652],"source":"The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for hit testing on visual objects when the default hit test support does not meet your needs."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper.HitTest%2A&gt;</ph> methods in the <ph id=\"ph2\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class to determine whether a geometry or point coordinate value is within the boundary of a given object, such as a control or graphic element.","pos":[28653,28928],"source":" You can use the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> methods in the <xref:System.Windows.Media.VisualTreeHelper> class to determine whether a geometry or point coordinate value is within the boundary of a given object, such as a control or graphic element."},{"content":"For example, you could use hit testing to determine whether a mouse click within the bounding rectangle of an object falls within the geometry of a circle You can also choose to override the default implementation of hit testing to perform your own custom hit test calculations.","pos":[28929,29207]},{"pos":[29214,29325],"content":"For more information on hit testing, see <bpt id=\"p1\">[</bpt>Hit Testing in the Visual Layer<ept id=\"p1\">](hit-testing-in-the-visual-layer.md)</ept>.","source":"For more information on hit testing, see [Hit Testing in the Visual Layer](hit-testing-in-the-visual-layer.md)."},{"pos":[29335,29362],"content":"Enumerating the Visual Tree","linkify":"Enumerating the Visual Tree","nodes":[{"content":"Enumerating the Visual Tree","pos":[0,27]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class provides functionality for enumerating the members of a visual tree.","pos":[29366,29489],"source":"The <xref:System.Windows.Media.VisualTreeHelper> class provides functionality for enumerating the members of a visual tree."},{"content":"To retrieve a parent, call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper.GetParent%2A&gt;</ph> method.","pos":[29490,29586],"source":" To retrieve a parent, call the <xref:System.Windows.Media.VisualTreeHelper.GetParent%2A> method."},{"content":"To retrieve a child, or direct descendant, of a visual object, call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper.GetChild%2A&gt;</ph> method.","pos":[29587,29723],"source":" To retrieve a child, or direct descendant, of a visual object, call the <xref:System.Windows.Media.VisualTreeHelper.GetChild%2A> method."},{"content":"This method returns a child <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> of the parent at the specified index.","pos":[29724,29824],"source":" This method returns a child <xref:System.Windows.Media.Visual> of the parent at the specified index."},{"content":"The following example shows how to enumerate all the descendants of a visual object, which is a technique you might want to use if you were interested in serializing all the rendering information of a visual object hierarchy.","pos":[29831,30056]},{"content":"In most cases, the logical tree is a more useful representation of the elements in a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application.","pos":[30320,30499],"source":"In most cases, the logical tree is a more useful representation of the elements in a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application."},{"content":"Although you do not modify the logical tree directly, this view of the application is useful for understanding property inheritance and event routing.","pos":[30500,30650]},{"content":"Unlike the visual tree, the logical tree can represent non-visual data objects, such as <ph id=\"ph1\">&lt;xref:System.Windows.Documents.ListItem&gt;</ph>.","pos":[30651,30780],"source":" Unlike the visual tree, the logical tree can represent non-visual data objects, such as <xref:System.Windows.Documents.ListItem>."},{"content":"For more information on the logical tree, see <bpt id=\"p1\">[</bpt>Trees in WPF<ept id=\"p1\">](../advanced/trees-in-wpf.md)</ept>.","pos":[30781,30871],"source":" For more information on the logical tree, see [Trees in WPF](../advanced/trees-in-wpf.md)."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class provides methods for returning the bounding rectangle of visual objects.","pos":[30878,31005],"source":"The <xref:System.Windows.Media.VisualTreeHelper> class provides methods for returning the bounding rectangle of visual objects."},{"content":"You can return the bounding rectangle of a visual object by calling <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A&gt;</ph>.","pos":[31006,31139],"source":" You can return the bounding rectangle of a visual object by calling <xref:System.Windows.Media.VisualTreeHelper.GetContentBounds%2A>."},{"content":"You can return the bounding rectangle of all the descendants of a visual object, including the visual object itself, by calling <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A&gt;</ph>.","pos":[31140,31336],"source":" You can return the bounding rectangle of all the descendants of a visual object, including the visual object itself, by calling <xref:System.Windows.Media.VisualTreeHelper.GetDescendantBounds%2A>."},{"content":"The following code shows how you would calculate the bounding rectangle of a visual object and all its descendants.","pos":[31337,31452]},{"pos":[31718,31726],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[31858,31946],"content":"<bpt id=\"p1\">[</bpt>2D Graphics and Imaging<ept id=\"p1\">](../advanced/optimizing-performance-2d-graphics-and-imaging.md)</ept>","source":"[2D Graphics and Imaging](../advanced/optimizing-performance-2d-graphics-and-imaging.md)"},{"pos":[31949,32018],"content":"<bpt id=\"p1\">[</bpt>Hit Testing in the Visual Layer<ept id=\"p1\">](hit-testing-in-the-visual-layer.md)</ept>","source":"[Hit Testing in the Visual Layer](hit-testing-in-the-visual-layer.md)"},{"pos":[32021,32082],"content":"<bpt id=\"p1\">[</bpt>Using DrawingVisual Objects<ept id=\"p1\">](using-drawingvisual-objects.md)</ept>","source":"[Using DrawingVisual Objects](using-drawingvisual-objects.md)"},{"pos":[32085,32201],"content":"<bpt id=\"p1\">[</bpt>Tutorial: Hosting Visual Objects in a Win32 Application<ept id=\"p1\">](tutorial-hosting-visual-objects-in-a-win32-application.md)</ept>","source":"[Tutorial: Hosting Visual Objects in a Win32 Application](tutorial-hosting-visual-objects-in-a-win32-application.md)"},{"pos":[32204,32299],"content":"<bpt id=\"p1\">[</bpt>Optimizing WPF Application Performance<ept id=\"p1\">](../advanced/optimizing-wpf-application-performance.md)</ept>","source":"[Optimizing WPF Application Performance](../advanced/optimizing-wpf-application-performance.md)"}]}