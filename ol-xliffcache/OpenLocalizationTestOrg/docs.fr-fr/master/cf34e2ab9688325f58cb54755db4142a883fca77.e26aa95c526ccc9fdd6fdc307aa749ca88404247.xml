{"content":"---\ntitle: Work with the .NET Compiler Platform SDK semantic model\ndescription: This overview provides an understanding of the type you use to understand and manipulate the semantic model of your code.\nms.date: 10/15/2017\nms.custom: mvc\n---\n\n# Work with semantics\n\n[Syntax trees](work-with-syntax.md) represent the lexical and syntactic structure of source code. Although this information alone is enough to describe all the declarations and logic in the source, it is not enough information to identify what is being referenced. A name\nmay represent:\n\n- a type\n- a field\n- a method\n- a local variable\n\nAlthough each of these is uniquely different, determining which one an identifier actually refers to often requires a deep understanding of the language rules. \n\nThere are program elements represented in source code, and programs can also refer to previously compiled libraries, packaged in assembly files. Although no source code, and therefore no syntax nodes or trees, are available for assemblies, programs can still refer to elements inside them.\n\nFor those tasks, you need the **Semantic model**.\n\nIn addition to a syntactic model of the source code, a semantic model encapsulates the language rules, giving you an easy way to correctly match identifiers with the correct program element being referenced.\n\n## Compilation\n\nA compilation is a representation of everything needed to compile a C# or Visual Basic program, which includes all the assembly references, compiler options, and source files. \n\nBecause all this information is in one place, the elements contained in the source code can be described in more detail. The compilation represents each declared type, member, or variable as a symbol. The compilation contains a variety of methods that help you find and relate the symbols that have either been declared in the source code or imported as metadata from an assembly.\n\nSimilar to syntax trees, compilations are immutable. After you create a compilation, it cannot be changed by you or anyone else you might be sharing it with. However, you can create a new compilation from an existing compilation, specifying a change as you do so. For example, you might create a compilation that is the same in every way as an existing compilation, except it may include an additional source file or assembly reference.\n\n## Symbols\n\nA symbol represents a distinct element declared by the source code or imported from an assembly as metadata. Every namespace, type, method, property, field, event, parameter, or local variable is represented by a symbol. \n\nA variety of methods and properties on the <xref:Microsoft.CodeAnalysis.Compilation> type help you find symbols. For example, you can find a symbol for a declared type by its common metadata name. You can also access the entire symbol table as a tree of symbols rooted by the global namespace.\n\nSymbols also contain additional information that the compiler determines from the source or metadata, such as other referenced symbols. Each kind of symbol is represented by a separate interface derived from <xref:Microsoft.CodeAnalysis.ISymbol>, each with its own methods and properties detailing the information the compiler has gathered. Many of these properties directly reference other symbols. For example, the <xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> property\ntells you the actual type symbol that the method declaration references.\n\nSymbols present a common representation of namespaces, types, and members, between source code and metadata. For example, a method that was declared in source code and a method that was imported from metadata are both represented by an <xref:Microsoft.CodeAnalysis.IMethodSymbol> with the same properties.\n\nSymbols are similar in concept to the CLR type system as represented by the <xref:System.Reflection> API, yet they are richer in that they model more than just types. Namespaces, local variables, and labels are all symbols. In addition, symbols are a representation of language concepts, not CLR concepts. There is a lot of overlap, but there are many meaningful distinctions as well. For instance, an iterator method in C# or Visual Basic is a single symbol. However, when the iterator method is translated to CLR metadata, it is a type and multiple methods.\n\n## Semantic model\n\nA semantic model represents all the semantic information for a single source file. You can use it to discover the following: \n\n* The symbols referenced at a specific location in source.\n* The resultant type of any expression.\n* All diagnostics, which are errors and warnings.\n* How variables flow in and out of regions of source.\n* The answers to more speculative questions.\n","nodes":[{"pos":[4,236],"embed":true,"restype":"x-metadata","content":"title: Work with the .NET Compiler Platform SDK semantic model\ndescription: This overview provides an understanding of the type you use to understand and manipulate the semantic model of your code.\nms.date: 10/15/2017\nms.custom: mvc","nodes":[{"content":"Work with the .NET Compiler Platform SDK semantic model","nodes":[{"pos":[0,55],"content":"Work with the .NET Compiler Platform SDK semantic model","nodes":[{"content":"Work with the .NET Compiler Platform SDK semantic model","pos":[0,55]}]}],"path":["title"],"nosxs":false},{"content":"This overview provides an understanding of the type you use to understand and manipulate the semantic model of your code.","nodes":[{"pos":[0,121],"content":"This overview provides an understanding of the type you use to understand and manipulate the semantic model of your code.","nodes":[{"content":"This overview provides an understanding of the type you use to understand and manipulate the semantic model of your code.","pos":[0,121]}]}],"path":["description"],"nosxs":false}],"yml":true},{"pos":[244,263],"content":"Work with semantics","linkify":"Work with semantics","nodes":[{"content":"Work with semantics","pos":[0,19]}]},{"content":"<bpt id=\"p1\">[</bpt>Syntax trees<ept id=\"p1\">](work-with-syntax.md)</ept> represent the lexical and syntactic structure of source code.","pos":[265,362],"source":"[Syntax trees](work-with-syntax.md) represent the lexical and syntactic structure of source code."},{"content":"Although this information alone is enough to describe all the declarations and logic in the source, it is not enough information to identify what is being referenced.","pos":[363,529]},{"content":"A name may represent:","pos":[530,551],"source":" A name\nmay represent:"},{"content":"a type","pos":[555,561]},{"content":"a field","pos":[564,571]},{"content":"a method","pos":[574,582]},{"content":"a local variable","pos":[585,601]},{"content":"Although each of these is uniquely different, determining which one an identifier actually refers to often requires a deep understanding of the language rules.","pos":[603,762]},{"content":"There are program elements represented in source code, and programs can also refer to previously compiled libraries, packaged in assembly files.","pos":[765,909]},{"content":"Although no source code, and therefore no syntax nodes or trees, are available for assemblies, programs can still refer to elements inside them.","pos":[910,1054]},{"pos":[1056,1105],"content":"For those tasks, you need the <bpt id=\"p1\">**</bpt>Semantic model<ept id=\"p1\">**</ept>.","source":"For those tasks, you need the **Semantic model**."},{"content":"In addition to a syntactic model of the source code, a semantic model encapsulates the language rules, giving you an easy way to correctly match identifiers with the correct program element being referenced.","pos":[1107,1314]},{"pos":[1319,1330],"content":"Compilation","linkify":"Compilation","nodes":[{"content":"Compilation","pos":[0,11]}]},{"content":"A compilation is a representation of everything needed to compile a C# or Visual Basic program, which includes all the assembly references, compiler options, and source files.","pos":[1332,1507]},{"content":"Because all this information is in one place, the elements contained in the source code can be described in more detail.","pos":[1510,1630]},{"content":"The compilation represents each declared type, member, or variable as a symbol.","pos":[1631,1710]},{"content":"The compilation contains a variety of methods that help you find and relate the symbols that have either been declared in the source code or imported as metadata from an assembly.","pos":[1711,1890]},{"content":"Similar to syntax trees, compilations are immutable.","pos":[1892,1944]},{"content":"After you create a compilation, it cannot be changed by you or anyone else you might be sharing it with.","pos":[1945,2049]},{"content":"However, you can create a new compilation from an existing compilation, specifying a change as you do so.","pos":[2050,2155]},{"content":"For example, you might create a compilation that is the same in every way as an existing compilation, except it may include an additional source file or assembly reference.","pos":[2156,2328]},{"pos":[2333,2340],"content":"Symbols","linkify":"Symbols","nodes":[{"content":"Symbols","pos":[0,7]}]},{"content":"A symbol represents a distinct element declared by the source code or imported from an assembly as metadata.","pos":[2342,2450]},{"content":"Every namespace, type, method, property, field, event, parameter, or local variable is represented by a symbol.","pos":[2451,2562]},{"content":"A variety of methods and properties on the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.Compilation&gt;</ph> type help you find symbols.","pos":[2565,2677],"source":"A variety of methods and properties on the <xref:Microsoft.CodeAnalysis.Compilation> type help you find symbols."},{"content":"For example, you can find a symbol for a declared type by its common metadata name.","pos":[2678,2761]},{"content":"You can also access the entire symbol table as a tree of symbols rooted by the global namespace.","pos":[2762,2858]},{"content":"Symbols also contain additional information that the compiler determines from the source or metadata, such as other referenced symbols.","pos":[2860,2995]},{"content":"Each kind of symbol is represented by a separate interface derived from <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.ISymbol&gt;</ph>, each with its own methods and properties detailing the information the compiler has gathered.","pos":[2996,3200],"source":" Each kind of symbol is represented by a separate interface derived from <xref:Microsoft.CodeAnalysis.ISymbol>, each with its own methods and properties detailing the information the compiler has gathered."},{"content":"Many of these properties directly reference other symbols.","pos":[3201,3259]},{"content":"For example, the <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType&gt;</ph> property tells you the actual type symbol that the method declaration references.","pos":[3260,3442],"source":" For example, the <xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> property\ntells you the actual type symbol that the method declaration references."},{"content":"Symbols present a common representation of namespaces, types, and members, between source code and metadata.","pos":[3444,3552]},{"content":"For example, a method that was declared in source code and a method that was imported from metadata are both represented by an <ph id=\"ph1\">&lt;xref:Microsoft.CodeAnalysis.IMethodSymbol&gt;</ph> with the same properties.","pos":[3553,3749],"source":" For example, a method that was declared in source code and a method that was imported from metadata are both represented by an <xref:Microsoft.CodeAnalysis.IMethodSymbol> with the same properties."},{"content":"Symbols are similar in concept to the CLR type system as represented by the <ph id=\"ph1\">&lt;xref:System.Reflection&gt;</ph> API, yet they are richer in that they model more than just types.","pos":[3751,3917],"source":"Symbols are similar in concept to the CLR type system as represented by the <xref:System.Reflection> API, yet they are richer in that they model more than just types."},{"content":"Namespaces, local variables, and labels are all symbols.","pos":[3918,3974]},{"content":"In addition, symbols are a representation of language concepts, not CLR concepts.","pos":[3975,4056]},{"content":"There is a lot of overlap, but there are many meaningful distinctions as well.","pos":[4057,4135]},{"content":"For instance, an iterator method in C# or Visual Basic is a single symbol.","pos":[4136,4210]},{"content":"However, when the iterator method is translated to CLR metadata, it is a type and multiple methods.","pos":[4211,4310]},{"pos":[4315,4329],"content":"Semantic model","linkify":"Semantic model","nodes":[{"content":"Semantic model","pos":[0,14]}]},{"content":"A semantic model represents all the semantic information for a single source file.","pos":[4331,4413]},{"content":"You can use it to discover the following:","pos":[4414,4455]},{"content":"The symbols referenced at a specific location in source.","pos":[4460,4516]},{"content":"The resultant type of any expression.","pos":[4519,4556]},{"content":"All diagnostics, which are errors and warnings.","pos":[4559,4606]},{"content":"How variables flow in and out of regions of source.","pos":[4609,4660]},{"content":"The answers to more speculative questions.","pos":[4663,4705]}]}