{"content":"---\ntitle: \"Mixed Declarative Code-Imperative Code Bugs (LINQ to XML) (C#)\"\nms.date: 07/20/2015\nms.assetid: fada62d0-0680-4e73-945a-2b00d7a507af\n---\n# Mixed Declarative Code/Imperative Code Bugs (LINQ to XML) (C#)\n[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] contains various methods that allow you to modify an XML tree directly. You can add elements, delete elements, change the contents of an element, add attributes, and so on. This programming interface is described in [Modifying XML Trees (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md). If you are iterating through one of the axes, such as <xref:System.Xml.Linq.XContainer.Elements%2A>, and you are modifying the XML tree as you iterate through the axis, you can end up with some strange bugs.  \n  \n This problem is sometimes known as \"The Halloween Problem\".  \n  \n## Definition of the Problem  \n When you write some code using LINQ that iterates through a collection, you are writing code in a declarative style. It is more akin to describing *what* you want, rather that *how* you want to get it done. If you write code that 1) gets the first element, 2) tests it for some condition, 3) modifies it, and 4) puts it back into the list, then this would be imperative code. You are telling the computer *how* to do what you want done.  \n  \n Mixing these styles of code in the same operation is what leads to problems. Consider the following:  \n  \n Suppose you have a linked list with three items in it (a, b, and c):  \n  \n `a -> b -> c`  \n  \n Now, suppose that you want to move through the linked list, adding three new items (a', b', and c'). You want the resulting linked list to look like this:  \n  \n `a -> a' -> b -> b' -> c -> c'`  \n  \n So you write code that iterates through the list, and for every item, adds a new item right after it. What happens is that your code will first see the `a` element, and insert `a'` after it. Now, your code will move to the next node in the list, which is now `a'`! It happily adds a new item to the list, `a''`.  \n  \n How would you solve this in the real world? Well, you might make a copy of the original linked list, and create a completely new list. Or if you are writing purely imperative code, you might find the first item, add the new item, and then advance twice in the linked list, advancing over the element that you just added.  \n  \n## Adding While Iterating  \n For example, suppose you want to write some code that for every element in a tree, you want to create a duplicate element:  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"A\", \"1\"),  \n    new XElement(\"B\", \"2\"),  \n    new XElement(\"C\", \"3\")  \n);  \nforeach (XElement e in root.Elements())  \n    root.Add(new XElement(e.Name, (string)e));  \n```  \n  \n This code goes into an infinite loop. The `foreach` statement iterates through the `Elements()` axis, adding new elements to the `doc` element. It ends up iterating also through the elements it just added. And because it allocates new objects with every iteration of the loop, it will eventually consume all available memory.  \n  \n You can fix this problem by pulling the collection into memory using the <xref:System.Linq.Enumerable.ToList%2A> standard query operator, as follows:  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"A\", \"1\"),  \n    new XElement(\"B\", \"2\"),  \n    new XElement(\"C\", \"3\")  \n);  \nforeach (XElement e in root.Elements().ToList())  \n    root.Add(new XElement(e.Name, (string)e));  \nConsole.WriteLine(root);  \n```  \n  \n Now the code works. The resulting XML tree is the following:  \n  \n```xml  \n<Root>  \n  <A>1</A>  \n  <B>2</B>  \n  <C>3</C>  \n  <A>1</A>  \n  <B>2</B>  \n  <C>3</C>  \n</Root>  \n```  \n  \n## Deleting While Iterating  \n If you want to delete all nodes at a certain level, you might be tempted to write code like the following:  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"A\", \"1\"),  \n    new XElement(\"B\", \"2\"),  \n    new XElement(\"C\", \"3\")  \n);  \nforeach (XElement e in root.Elements())  \n    e.Remove();  \nConsole.WriteLine(root);  \n```  \n  \n However, this does not do what you want. In this situation, after you have removed the first element, A, it is removed from the XML tree contained in root, and the code in the Elements method that is doing the iterating cannot find the next element.  \n  \n The preceding code produces the following output:  \n  \n```xml  \n<Root>  \n  <B>2</B>  \n  <C>3</C>  \n</Root>  \n```  \n  \n The solution again is to call <xref:System.Linq.Enumerable.ToList%2A> to materialize the collection, as follows:  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"A\", \"1\"),  \n    new XElement(\"B\", \"2\"),  \n    new XElement(\"C\", \"3\")  \n);  \nforeach (XElement e in root.Elements().ToList())  \n    e.Remove();  \nConsole.WriteLine(root);  \n```  \n  \n This produces the following output:  \n  \n```xml  \n<Root />  \n```  \n  \n Alternatively, you can eliminate the iteration altogether by calling <xref:System.Xml.Linq.XElement.RemoveAll%2A> on the parent element:  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"A\", \"1\"),  \n    new XElement(\"B\", \"2\"),  \n    new XElement(\"C\", \"3\")  \n);  \nroot.RemoveAll();  \nConsole.WriteLine(root);  \n```  \n  \n## Why Can't LINQ Automatically Handle This?  \n One approach would be to always bring everything into memory instead of doing lazy evaluation. However, it would be very expensive in terms of performance and memory use. In fact, if LINQ and (LINQ to XML) were to take this approach, it would fail in real-world situations.  \n  \n Another possible approach would be to put in some sort of transaction syntax into LINQ, and have the compiler attempt to analyze the code and determine if any particular collection needed to be materialized. However, attempting to determine all code that has side-effects is incredibly complex. Consider the following code:  \n  \n```csharp  \nvar z =  \n    from e in root.Elements()  \n    where TestSomeCondition(e)  \n    select DoMyProjection(e);  \n```  \n  \n Such analysis code would need to analyze the methods TestSomeCondition and DoMyProjection, and all methods that those methods called, to determine if any code had side-effects. But the analysis code could not just look for any code that had side-effects. It would need to select for just the code that had side-effects on the child elements of `root` in this situation.  \n  \n LINQ to XML does not attempt to do any such analysis.  \n  \n It is up to you to avoid these problems.  \n  \n## Guidance  \n First, do not mix declarative and imperative code.  \n  \n Even if you know exactly the semantics of your collections and the semantics of the methods that modify the XML tree, if you write some clever code that avoids these categories of problems, your code will need to be maintained by other developers in the future, and they may not be as clear on the issues. If you mix declarative and imperative coding styles, your code will be more brittle.  \n  \n If you write code that materializes a collection so that these problems are avoided, note it with comments as appropriate in your code, so that maintenance programmers will understand the issue.  \n  \n Second, if performance and other considerations allow, use only declarative code. Don't modify your existing XML tree. Generate a new one.  \n  \n```csharp  \nXElement root = new XElement(\"Root\",  \n    new XElement(\"A\", \"1\"),  \n    new XElement(\"B\", \"2\"),  \n    new XElement(\"C\", \"3\")  \n);  \nXElement newRoot = new XElement(\"Root\",  \n    root.Elements(),  \n    root.Elements()  \n);  \nConsole.WriteLine(newRoot);  \n```  \n  \n## See also\n\n- [Advanced LINQ to XML Programming (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)\n","nodes":[{"pos":[4,144],"embed":true,"restype":"x-metadata","content":"title: \"Mixed Declarative Code-Imperative Code Bugs (LINQ to XML) (C#)\"\nms.date: 07/20/2015\nms.assetid: fada62d0-0680-4e73-945a-2b00d7a507af","nodes":[{"content":"Mixed Declarative Code-Imperative Code Bugs (LINQ to XML) (C#)","nodes":[{"pos":[0,62],"content":"Mixed Declarative Code-Imperative Code Bugs (LINQ to XML) (C#)","nodes":[{"content":"Mixed Declarative Code-Imperative Code Bugs (LINQ to XML) (C#)","pos":[0,62]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[151,213],"content":"Mixed Declarative Code/Imperative Code Bugs (LINQ to XML) (C#)","linkify":"Mixed Declarative Code/Imperative Code Bugs (LINQ to XML) (C#)","nodes":[{"content":"Mixed Declarative Code/Imperative Code Bugs (LINQ to XML) (C#)","pos":[0,62]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> contains various methods that allow you to modify an XML tree directly.","pos":[214,339],"source":"[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] contains various methods that allow you to modify an XML tree directly."},{"content":"You can add elements, delete elements, change the contents of an element, add attributes, and so on.","pos":[340,440]},{"content":"This programming interface is described in <bpt id=\"p1\">[</bpt>Modifying XML Trees (LINQ to XML) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md)</ept>.","pos":[441,612],"source":" This programming interface is described in [Modifying XML Trees (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/modifying-xml-trees-linq-to-xml.md)."},{"content":"If you are iterating through one of the axes, such as <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XContainer.Elements%2A&gt;</ph>, and you are modifying the XML tree as you iterate through the axis, you can end up with some strange bugs.","pos":[613,820],"source":" If you are iterating through one of the axes, such as <xref:System.Xml.Linq.XContainer.Elements%2A>, and you are modifying the XML tree as you iterate through the axis, you can end up with some strange bugs."},{"content":"This problem is sometimes known as \"The Halloween Problem\".","pos":[827,886]},{"pos":[895,920],"content":"Definition of the Problem","linkify":"Definition of the Problem","nodes":[{"content":"Definition of the Problem","pos":[0,25]}]},{"content":"When you write some code using LINQ that iterates through a collection, you are writing code in a declarative style.","pos":[924,1040]},{"content":"It is more akin to describing <bpt id=\"p1\">*</bpt>what<ept id=\"p1\">*</ept> you want, rather that <bpt id=\"p2\">*</bpt>how<ept id=\"p2\">*</ept> you want to get it done.","pos":[1041,1130],"source":" It is more akin to describing *what* you want, rather that *how* you want to get it done."},{"content":"If you write code that 1) gets the first element, 2) tests it for some condition, 3) modifies it, and 4) puts it back into the list, then this would be imperative code.","pos":[1131,1299]},{"content":"You are telling the computer <bpt id=\"p1\">*</bpt>how<ept id=\"p1\">*</ept> to do what you want done.","pos":[1300,1360],"source":" You are telling the computer *how* to do what you want done."},{"content":"Mixing these styles of code in the same operation is what leads to problems.","pos":[1367,1443]},{"content":"Consider the following:","pos":[1444,1467]},{"content":"Suppose you have a linked list with three items in it (a, b, and c):","pos":[1474,1542]},{"content":"Now, suppose that you want to move through the linked list, adding three new items (a', b', and c').","pos":[1569,1669]},{"content":"You want the resulting linked list to look like this:","pos":[1670,1723]},{"content":"So you write code that iterates through the list, and for every item, adds a new item right after it.","pos":[1768,1869]},{"content":"What happens is that your code will first see the <ph id=\"ph1\">`a`</ph> element, and insert <ph id=\"ph2\">`a'`</ph> after it.","pos":[1870,1958],"source":" What happens is that your code will first see the `a` element, and insert `a'` after it."},{"content":"Now, your code will move to the next node in the list, which is now <ph id=\"ph1\">`a'`</ph>!","pos":[1959,2032],"source":" Now, your code will move to the next node in the list, which is now `a'`!"},{"content":"It happily adds a new item to the list, <ph id=\"ph1\">`a''`</ph>.","pos":[2033,2079],"source":" It happily adds a new item to the list, `a''`."},{"content":"How would you solve this in the real world?","pos":[2086,2129]},{"content":"Well, you might make a copy of the original linked list, and create a completely new list.","pos":[2130,2220]},{"content":"Or if you are writing purely imperative code, you might find the first item, add the new item, and then advance twice in the linked list, advancing over the element that you just added.","pos":[2221,2406]},{"pos":[2415,2437],"content":"Adding While Iterating","linkify":"Adding While Iterating","nodes":[{"content":"Adding While Iterating","pos":[0,22]}]},{"content":"For example, suppose you want to write some code that for every element in a tree, you want to create a duplicate element:","pos":[2441,2563]},{"content":"This code goes into an infinite loop.","pos":[2815,2852]},{"content":"The <ph id=\"ph1\">`foreach`</ph> statement iterates through the <ph id=\"ph2\">`Elements()`</ph> axis, adding new elements to the <ph id=\"ph3\">`doc`</ph> element.","pos":[2853,2958],"source":" The `foreach` statement iterates through the `Elements()` axis, adding new elements to the `doc` element."},{"content":"It ends up iterating also through the elements it just added.","pos":[2959,3020]},{"content":"And because it allocates new objects with every iteration of the loop, it will eventually consume all available memory.","pos":[3021,3140]},{"pos":[3147,3296],"content":"You can fix this problem by pulling the collection into memory using the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> standard query operator, as follows:","source":"You can fix this problem by pulling the collection into memory using the <xref:System.Linq.Enumerable.ToList%2A> standard query operator, as follows:"},{"content":"Now the code works.","pos":[3584,3603]},{"content":"The resulting XML tree is the following:","pos":[3604,3644]},{"pos":[3768,3792],"content":"Deleting While Iterating","linkify":"Deleting While Iterating","nodes":[{"content":"Deleting While Iterating","pos":[0,24]}]},{"content":"If you want to delete all nodes at a certain level, you might be tempted to write code like the following:","pos":[3796,3902]},{"content":"However, this does not do what you want.","pos":[4150,4190]},{"content":"In this situation, after you have removed the first element, A, it is removed from the XML tree contained in root, and the code in the Elements method that is doing the iterating cannot find the next element.","pos":[4191,4399]},{"content":"The preceding code produces the following output:","pos":[4406,4455]},{"pos":[4525,4637],"content":"The solution again is to call <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> to materialize the collection, as follows:","source":"The solution again is to call <xref:System.Linq.Enumerable.ToList%2A> to materialize the collection, as follows:"},{"content":"This produces the following output:","pos":[4894,4929]},{"pos":[4965,5101],"content":"Alternatively, you can eliminate the iteration altogether by calling <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XElement.RemoveAll%2A&gt;</ph> on the parent element:","source":"Alternatively, you can eliminate the iteration altogether by calling <xref:System.Xml.Linq.XElement.RemoveAll%2A> on the parent element:"},{"pos":[5311,5352],"content":"Why Can't LINQ Automatically Handle This?","linkify":"Why Can't LINQ Automatically Handle This?","nodes":[{"content":"Why Can't LINQ Automatically Handle This?","pos":[0,41]}]},{"content":"One approach would be to always bring everything into memory instead of doing lazy evaluation.","pos":[5356,5450]},{"content":"However, it would be very expensive in terms of performance and memory use.","pos":[5451,5526]},{"content":"In fact, if LINQ and (LINQ to XML) were to take this approach, it would fail in real-world situations.","pos":[5527,5629]},{"content":"Another possible approach would be to put in some sort of transaction syntax into LINQ, and have the compiler attempt to analyze the code and determine if any particular collection needed to be materialized.","pos":[5636,5843]},{"content":"However, attempting to determine all code that has side-effects is incredibly complex.","pos":[5844,5930]},{"content":"Consider the following code:","pos":[5931,5959]},{"content":"Such analysis code would need to analyze the methods TestSomeCondition and DoMyProjection, and all methods that those methods called, to determine if any code had side-effects.","pos":[6094,6270]},{"content":"But the analysis code could not just look for any code that had side-effects.","pos":[6271,6348]},{"content":"It would need to select for just the code that had side-effects on the child elements of <ph id=\"ph1\">`root`</ph> in this situation.","pos":[6349,6463],"source":" It would need to select for just the code that had side-effects on the child elements of `root` in this situation."},{"content":"LINQ to XML does not attempt to do any such analysis.","pos":[6470,6523]},{"content":"It is up to you to avoid these problems.","pos":[6530,6570]},{"pos":[6579,6587],"content":"Guidance","linkify":"Guidance","nodes":[{"content":"Guidance","pos":[0,8]}]},{"content":"First, do not mix declarative and imperative code.","pos":[6591,6641]},{"content":"Even if you know exactly the semantics of your collections and the semantics of the methods that modify the XML tree, if you write some clever code that avoids these categories of problems, your code will need to be maintained by other developers in the future, and they may not be as clear on the issues.","pos":[6648,6953]},{"content":"If you mix declarative and imperative coding styles, your code will be more brittle.","pos":[6954,7038]},{"content":"If you write code that materializes a collection so that these problems are avoided, note it with comments as appropriate in your code, so that maintenance programmers will understand the issue.","pos":[7045,7239]},{"content":"Second, if performance and other considerations allow, use only declarative code.","pos":[7246,7327]},{"content":"Don't modify your existing XML tree.","pos":[7328,7364]},{"content":"Generate a new one.","pos":[7365,7384]},{"pos":[7669,7677],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7681,7808],"content":"<bpt id=\"p1\">[</bpt>Advanced LINQ to XML Programming (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)</ept>","source":"[Advanced LINQ to XML Programming (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-linq-to-xml-programming.md)"}]}