{"content":"---\ntitle: \"nameof (C# and Visual Basic Reference) | Microsoft Docs\"\nms.date: \"2017-03-03\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"nameof_CSharpKeyword\"\n  - \"nameof\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 33601bf3-cc2c-4496-846d-f9679bccf2a7\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# nameof (C# and Visual Basic Reference)\n\nUsed to obtain the simple (unqualified) string name of a variable, type, or member.  \n\nWhen reporting errors in code, hooking up model-view-controller (MVC) links, firing property changed events, etc., you often want to capture the string name of a method.  Using `nameof` helps keep your code valid when renaming definitions.  Before, you had to use string literals to refer to definitions, which is brittle when renaming code elements because tools do not know to check these string literals.  \n  \n A `nameof` expression has this form:  \n  \n```csharp  \nif (x == null) throw new ArgumentNullException(nameof(x));  \nWriteLine(nameof(person.Address.ZipCode)); // prints \"ZipCode\"  \n  \n```  \n  \n## Key Use Cases  \n These examples show the key use cases for `nameof`.  \n  \n Validate parameters:  \n ```csharp  \nvoid f(string s) {  \n    if (s == null) throw new ArgumentNullException(nameof(s));  \n}  \n  \n```  \n  \n MVC Action links:  \n ```html  \n<%= Html.ActionLink(\"Sign up\",  \n             @typeof(UserController),  \n             @nameof(UserController.SignUp))  \n%>  \n  \n```  \n  \n INotifyPropertyChanged:  \n ```csharp  \nint p {  \n    get { return this.p; }  \n    set { this.p = value; PropertyChanged(this, new PropertyChangedEventArgs(nameof(this.p)); } // nameof(p) works too  \n}  \n  \n```  \n  \n XAML dependency property:  \n ```csharp  \npublic static DependencyProperty AgeProperty = DependencyProperty.Register(nameof(Age), typeof(int), typeof(C));  \n  \n```  \n  \n Logging:  \n ```csharp  \nvoid f(int i) {  \n    Log(nameof(f), \"method entry\");  \n}  \n  \n```  \n  \n Attributes:  \n ```csharp  \n[DebuggerDisplay(\"={\" + nameof(GetString) + \"()}\")]  \nclass C {  \n    string GetString() { }  \n}  \n```  \n  \n## Examples  \n Some C# examples:  \n  \n```csharp  \nusing Stuff = Some.Cool.Functionality  \nclass C {  \n    static int Method1 (string x, int y) {}  \n    static int Method1 (string x, string y) {}  \n    int Method2 (int z) {}  \n    string f<T>() => nameof(T);  \n}  \n  \nvar c = new C()  \n  \nnameof(C) -> \"C\"  \nnameof(C.Method1) -> \"Method1\"   \nnameof(C.Method2) -> \"Method2\"  \nnameof(c.Method1) -> \"Method1\"   \nnameof(c.Method2) -> \"Method2\"  \nnameof(z) -> \"z\" // inside of Method2 ok, inside Method1 is a compiler error  \nnameof(Stuff) = \"Stuff\"  \nnameof(T) -> \"T\" // works inside of method but not in attributes on the method  \nnameof(f) -> \"f\"  \nnameof(f<T>) -> syntax error  \nnameof(f<>) -> syntax error  \nnameof(Method2()) -> error \"This expression does not have a name\"  \n  \n```  \n  \n Many of the above samples apply to Visual Basic.  Here are some specific Visual Basic examples:  \n  \n```vb  \nNameOf(a!Foo) -> ' error  \"This expression does not have a name\"  \nNameOf(dict(\"Foo\")) -> ' error  \"This expression does not have a name\": default property access  \nNameOf(dict.Item(\"Foo\")) -> ' error  \"This expression does not have a name\"  \nNameOf(arr(2)) -> ' error  \"This expression does not have a name\": array element index  \nDim x = Nothing   \nNameOf(x.ToString(2)) -> ' error  \"This expression does not have a name\"  \nDim o = Nothing  \nNameOf(o.Equals) -> ' result \"Equals\".  Warning: \"Access of static member of instance; instance will not be evaluated\"  \n  \n```  \n  \n## Remarks  \n The argument to `nameof` must be a simple name, qualified name, member access, base access with a specified member, or this access with a specified member.  The argument expression identifies a code definition, but it is never evaluated.  \n  \n Because the argument needs to be an expression syntactically, there are many things disallowed that are not useful to list.  The following are worth mentioning that produce errors: predefined types (for example, `int` or `void`), nullable types (`Point?`), array types (`Customer[,]`), pointer types (`Buffer*`), qualified alias (`A::B`), and unbound generic types (`Dictionary<,>`), preprocessing symbols (`DEBUG`), and labels (`loop:`).  \n  \n If you need to get the fully-qualified name, you can use the `typeof` expression along with `nameof`.  For example:\n```csharp  \nclass C {\n    void f(int i) {  \n        Log($\"{typeof(C)}.{nameof(f)}\", \"method entry\");  \n    }\n}\n  \n``` \n\n Unfortunately `typeof` is not a constant expression like `nameof`, so `typeof` cannot be used in conjunction with `nameof` in all the same places as `nameof`.  For example, the following would cause a CS0182 compile error:\n ```csharp  \n[DebuggerDisplay(\"={\" + typeof(C) + nameof(GetString) + \"()}\")]  \nclass C {  \n    string GetString() { }  \n}  \n```    \n In the examples you see that you can use a type name and access an instance method name.  You do not need to have an instance of the type, as required in evaluated expressions.  Using the type name can be very convenient in some situations, and since you are just referring to the name and not using instance data, you do not need to contrive an instance variable or expression.  \n  \n You can reference the members of a class in attribute expressions on the class.  \n  \n There is no way to get a signatures information such as \"`Method1 (str, str)`\".  One way to do that is to use an Expression, `Expression e = () => A.B.Method1(\"s1\", \"s2\")`, and pull the MemberInfo from the resulting expression tree.  \n  \n## Language Specifications  \n [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec_md.md)]  \n  \n For more information, see the [Visual Basic Language Reference](../../../visual-basic/language-reference/index.md).  \n  \n## See Also  \n [C# Reference](../../../csharp/language-reference/index.md)   \n [C# Programming Guide](../../../csharp/programming-guide/index.md)   \n [typeof](../../../csharp/language-reference/keywords/typeof.md)   \n [Visual Basic Language Reference](../../../visual-basic/language-reference/index.md)   \n [Visual Basic Programming Guide](../../../visual-basic/programming-guide/index.md)\n","nodes":[{"pos":[4,536],"nodes":[{"content":"nameof (C# and Visual Basic Reference) | Microsoft Docs","nodes":[{"pos":[0,55],"content":"nameof (C# and Visual Basic Reference) | Microsoft Docs","nodes":[{"content":"nameof (C# and Visual Basic Reference) | Microsoft Docs","pos":[0,55]}]}],"pos":[6,64],"yaml":true}],"content":"title: \"nameof (C# and Visual Basic Reference) | Microsoft Docs\"\nms.date: \"2017-03-03\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\nf1_keywords: \n  - \"nameof_CSharpKeyword\"\n  - \"nameof\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 33601bf3-cc2c-4496-846d-f9679bccf2a7\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"","yamlblock":true},{"pos":[543,581],"content":"nameof (C# and Visual Basic Reference)","linkify":"nameof (C# and Visual Basic Reference)","nodes":[{"content":"nameof (C# and Visual Basic Reference)","pos":[0,38]}]},{"content":"Used to obtain the simple (unqualified) string name of a variable, type, or member.","pos":[583,666]},{"content":"When reporting errors in code, hooking up model-view-controller (MVC) links, firing property changed events, etc., you often want to capture the string name of a method.","pos":[670,839]},{"content":"Using <ph id=\"ph1\">`nameof`</ph> helps keep your code valid when renaming definitions.","pos":[841,909],"source":"  Using `nameof` helps keep your code valid when renaming definitions."},{"content":"Before, you had to use string literals to refer to definitions, which is brittle when renaming code elements because tools do not know to check these string literals.","pos":[911,1077]},{"pos":[1084,1120],"content":"A <ph id=\"ph1\">`nameof`</ph> expression has this form:","source":"A `nameof` expression has this form:"},{"pos":[1279,1292],"content":"Key Use Cases","linkify":"Key Use Cases","nodes":[{"content":"Key Use Cases","pos":[0,13]}]},{"pos":[1296,1347],"content":"These examples show the key use cases for <ph id=\"ph1\">`nameof`</ph>.","source":"These examples show the key use cases for `nameof`."},{"content":"Validate parameters:","pos":[1354,1374]},{"content":"MVC Action links:","pos":[1493,1510]},{"content":"INotifyPropertyChanged:","pos":[1662,1685]},{"content":"XAML dependency property:","pos":[1878,1903]},{"content":"Logging:","pos":[2047,2055]},{"content":"Attributes:","pos":[2144,2155]},{"pos":[2282,2290],"content":"Examples","linkify":"Examples","nodes":[{"content":"Examples","pos":[0,8]}]},{"content":"Some C# examples:","pos":[2294,2311]},{"content":"Many of the above samples apply to Visual Basic.","pos":[3067,3115]},{"content":"Here are some specific Visual Basic examples:","pos":[3117,3162]},{"pos":[3756,3763],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"The argument to <ph id=\"ph1\">`nameof`</ph> must be a simple name, qualified name, member access, base access with a specified member, or this access with a specified member.","pos":[3767,3922],"source":"The argument to `nameof` must be a simple name, qualified name, member access, base access with a specified member, or this access with a specified member."},{"content":"The argument expression identifies a code definition, but it is never evaluated.","pos":[3924,4004]},{"content":"Because the argument needs to be an expression syntactically, there are many things disallowed that are not useful to list.","pos":[4011,4134]},{"content":"The following are worth mentioning that produce errors: predefined types (for example, <ph id=\"ph1\">`int`</ph> or <ph id=\"ph2\">`void`</ph>), nullable types (<ph id=\"ph3\">`Point?`</ph>), array types (<ph id=\"ph4\">`Customer[,]`</ph>), pointer types (<ph id=\"ph5\">`Buffer*`</ph>), qualified alias (<ph id=\"ph6\">`A::B`</ph>), and unbound generic types (<ph id=\"ph7\">`Dictionary&lt;,&gt;`</ph>), preprocessing symbols (<ph id=\"ph8\">`DEBUG`</ph>), and labels (<ph id=\"ph9\">`loop:`</ph>).","pos":[4136,4449],"source":"  The following are worth mentioning that produce errors: predefined types (for example, `int` or `void`), nullable types (`Point?`), array types (`Customer[,]`), pointer types (`Buffer*`), qualified alias (`A::B`), and unbound generic types (`Dictionary<,>`), preprocessing symbols (`DEBUG`), and labels (`loop:`)."},{"content":"If you need to get the fully-qualified name, you can use the <ph id=\"ph1\">`typeof`</ph> expression along with <ph id=\"ph2\">`nameof`</ph>.","pos":[4456,4557],"source":"If you need to get the fully-qualified name, you can use the `typeof` expression along with `nameof`."},{"content":"For example:","pos":[4559,4571]},{"content":"Unfortunately <ph id=\"ph1\">`typeof`</ph> is not a constant expression like <ph id=\"ph2\">`nameof`</ph>, so <ph id=\"ph3\">`typeof`</ph> cannot be used in conjunction with <ph id=\"ph4\">`nameof`</ph> in all the same places as <ph id=\"ph5\">`nameof`</ph>.","pos":[4693,4851],"source":"Unfortunately `typeof` is not a constant expression like `nameof`, so `typeof` cannot be used in conjunction with `nameof` in all the same places as `nameof`."},{"content":"For example, the following would cause a CS0182 compile error:","pos":[4853,4915]},{"content":"In the examples you see that you can use a type name and access an instance method name.","pos":[5049,5137]},{"content":"You do not need to have an instance of the type, as required in evaluated expressions.","pos":[5139,5225]},{"content":"Using the type name can be very convenient in some situations, and since you are just referring to the name and not using instance data, you do not need to contrive an instance variable or expression.","pos":[5227,5427]},{"content":"You can reference the members of a class in attribute expressions on the class.","pos":[5434,5513]},{"content":"There is no way to get a signatures information such as \"<ph id=\"ph1\">`Method1 (str, str)`</ph>\".","pos":[5520,5599],"source":"There is no way to get a signatures information such as \"`Method1 (str, str)`\"."},{"content":"One way to do that is to use an Expression, <ph id=\"ph1\">`Expression e = () =&gt; A.B.Method1(\"s1\", \"s2\")`</ph>, and pull the MemberInfo from the resulting expression tree.","pos":[5601,5752],"source":"  One way to do that is to use an Expression, `Expression e = () => A.B.Method1(\"s1\", \"s2\")`, and pull the MemberInfo from the resulting expression tree."},{"pos":[5761,5784],"content":"Language Specifications","linkify":"Language Specifications","nodes":[{"content":"Language Specifications","pos":[0,23]}]},{"pos":[5896,6011],"content":"For more information, see the <bpt id=\"p1\">[</bpt>Visual Basic Language Reference<ept id=\"p1\">](../../../visual-basic/language-reference/index.md)</ept>.","source":"For more information, see the [Visual Basic Language Reference](../../../visual-basic/language-reference/index.md)."},{"pos":[6020,6028],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[6032,6092],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Programming Guide<ept id=\"p1\">](../../../csharp/programming-guide/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[6096,6163],"source":"[C# Programming Guide](../../../csharp/programming-guide/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>typeof<ept id=\"p1\">](../../../csharp/language-reference/keywords/typeof.md)</ept><ph id=\"ph1\"> </ph>","pos":[6167,6231],"source":"[typeof](../../../csharp/language-reference/keywords/typeof.md) "},{"content":"<bpt id=\"p1\">[</bpt>Visual Basic Language Reference<ept id=\"p1\">](../../../visual-basic/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[6235,6320],"source":"[Visual Basic Language Reference](../../../visual-basic/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Visual Basic Programming Guide<ept id=\"p1\">](../../../visual-basic/programming-guide/index.md)</ept>","pos":[6324,6406],"source":"[Visual Basic Programming Guide](../../../visual-basic/programming-guide/index.md)"}]}