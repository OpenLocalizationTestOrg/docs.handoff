{"content":"---\ntitle: Structs | C# Guide\ndescription: Learn about the struct type and how you create them\nkeywords: .NET, .NET Core, C#\nauthor: BillWagner\nms.author: wiwagn\nms.date: 10/12/2016\nms.topic: article\nms.prod: .net\nms.technology: devlang-csharp\nms.devlang: csharp\nms.assetid: a7094b8c-7229-4b6f-82fc-824d0ea0ec40\n---\n\n# Structs\nA *struct* is a value type. When a struct is created, the variable to which the struct is assigned holds the struct's actual data. When the struct is assigned to a new variable, it is copied. The new variable and the original variable therefore contain two separate copies of the same data. Changes made to one copy do not affect the other copy.\n\nValue type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared. There is no separate heap allocation or garbage collection overhead for value-type variables.  \n  \nThere are two categories of value types: [struct](./language-reference/keywords/struct.md) and [enum](./language-reference/keywords/enum.md).  \n  \nThe built-in numeric types are structs, and they have properties and methods that you can access:  \n  \n[!code-csharp[Static Method](../../samples/snippets/csharp/concepts/structs/static-method.cs)]\n  \nBut you declare and assign values to them as if they were simple non-aggregate types:  \n  \n[!code-csharp[Assign Values](../../samples/snippets/csharp/concepts/structs/assign-value.cs)] \n  \nValue types are *sealed*, which means, for example, that you cannot derive a type from @System.Int32, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from @System.ValueType. However, a struct can implement one or more interfaces. You can cast a struct type to an interface type; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap. Boxing operations occur when you pass a value type to a method that takes an @System.Object as an input parameter. For more information, see [Boxing and Unboxing](./programming-guide/types/boxing-and-unboxing.md ).  \n  \nYou use the [struct](./language-reference/keywords/struct.md) keyword to create your own custom value types. Typically, a struct is used as a container for a small set of related variables, as shown in the following example:  \n  \n[!code-csharp[Struct Keyword](../../samples/snippets/csharp/concepts/structs/struct-keyword.cs)]  \n  \nFor more information about value types in the .NET Framework, see [Common Type System](../standard/common-type-system.md).  \n    \nStructs share most of the same syntax as classes, although structs are more limited than classes:  \n  \n-   Within a struct declaration, fields cannot be initialized unless they are declared as `const` or `static`.  \n  \n-   A struct cannot declare a default constructor (a constructor without parameters) or a finalizer.  \n  \n-   Structs are copied on assignment. When a struct is assigned to a new variable, all the data is copied, and any modification to the new copy does not change the data for the original copy. This is important to remember when working with collections of value types such as Dictionary<string, myStruct>.  \n  \n-   Structs are value types and classes are reference types.  \n  \n-   Unlike classes, structs can be instantiated without using a `new` operator.  \n  \n-   Structs can declare constructors that have parameters.  \n  \n-   A struct cannot inherit from another struct or class, and it cannot be the base of a class. All structs inherit directly from @System.ValueType, which inherits from @System.Object.  \n  \n-   A struct can implement interfaces.\n\n## Literal values  \nIn C#, literal values receive a type from the compiler. You can specify how a numeric literal should be typed by appending a letter to the end of the number. For example, to specify that the value 4.56 should be treated as a float, append an \"f\" or \"F\" after the number: `4.56f`. If no letter is appended, the compiler will infer the `double` type for the literal. For more information about which types can be specified with letter suffixes, see the reference pages for individual types in [Value Types](./language-reference/keywords/value-types.md).  \n  \nBecause literals are typed, and all types derive ultimately from @System.Object, you can write and compile code such as the following:  \n  \n[!code-csharp[Literal Values](../../samples/snippets/csharp/concepts/structs/literals.cs)]\n\nThe last two examples demonstrate language features introduced in C# 7.0. The first allows you to use an underscore character as a *digit separator* inside numeric literals. You can put them wherever you want between digits to improve readability. They have no effect on the value.\n\nThe second demonstrates *binary literals*, which allow you to specify bit patterns directly instead of using hexadecimal notation.\n\n## Nullable types  \nOrdinary value types cannot have a value of [null](./language-reference/keywords/null.md). However, you can create nullable value types by affixing a **?** after the type. For example, **int?** is an **int** type that can also have the value [null](./language-reference/keywords/null.md). In the CTS, nullable types are instances of the generic struct type @System.Nullable%601. Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null. For more information, see [Nullable Types (C# Programming Guide)](./programming-guide/nullable-types/index.md).\n\n## See also\n[Classes](classes.md)\n\n[Basic Types](basic-types.md)","nodes":[{"pos":[11,29],"content":"Structs | C# Guide","needQuote":true,"needEscape":true,"nodes":[{"content":"Structs | C# Guide","pos":[0,18]}]},{"pos":[43,94],"content":"Learn about the struct type and how you create them","needQuote":true,"needEscape":true,"nodes":[{"content":"Learn about the struct type and how you create them","pos":[0,51]}]},{"pos":[105,124],"content":".NET, .NET Core, C#","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core, C#","pos":[0,19]}]},{"pos":[319,326],"content":"Structs","linkify":"Structs","nodes":[{"content":"Structs","pos":[0,7]}]},{"content":"A <bpt id=\"p1\">*</bpt>struct<ept id=\"p1\">*</ept> is a value type.","pos":[327,354],"source":"A *struct* is a value type."},{"content":"When a struct is created, the variable to which the struct is assigned holds the struct's actual data.","pos":[355,457]},{"content":"When the struct is assigned to a new variable, it is copied.","pos":[458,518]},{"content":"The new variable and the original variable therefore contain two separate copies of the same data.","pos":[519,617]},{"content":"Changes made to one copy do not affect the other copy.","pos":[618,672]},{"content":"Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.","pos":[674,819]},{"content":"There is no separate heap allocation or garbage collection overhead for value-type variables.","pos":[820,913]},{"pos":[919,1060],"content":"There are two categories of value types: <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](./language-reference/keywords/struct.md)</ept> and <bpt id=\"p2\">[</bpt>enum<ept id=\"p2\">](./language-reference/keywords/enum.md)</ept>.","source":"There are two categories of value types: [struct](./language-reference/keywords/struct.md) and [enum](./language-reference/keywords/enum.md)."},{"content":"The built-in numeric types are structs, and they have properties and methods that you can access:","pos":[1066,1163]},{"pos":[1169,1263],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Static Method<ept id=\"p2\">](../../samples/snippets/csharp/concepts/structs/static-method.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Static Method](../../samples/snippets/csharp/concepts/structs/static-method.cs)]"},{"content":"But you declare and assign values to them as if they were simple non-aggregate types:","pos":[1267,1352]},{"pos":[1358,1451],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Assign Values<ept id=\"p2\">](../../samples/snippets/csharp/concepts/structs/assign-value.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Assign Values](../../samples/snippets/csharp/concepts/structs/assign-value.cs)]"},{"content":"Value types are <bpt id=\"p1\">*</bpt>sealed<ept id=\"p1\">*</ept>, which means, for example, that you cannot derive a type from <ph id=\"ph1\">@System.Int32</ph>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <ph id=\"ph2\">@System.ValueType</ph>.","pos":[1456,1695],"source":"Value types are *sealed*, which means, for example, that you cannot derive a type from @System.Int32, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from @System.ValueType."},{"content":"However, a struct can implement one or more interfaces.","pos":[1696,1751]},{"content":"You can cast a struct type to an interface type; this causes a <bpt id=\"p1\">*</bpt>boxing<ept id=\"p1\">*</ept> operation to wrap the struct inside a reference type object on the managed heap.","pos":[1752,1904],"source":" You can cast a struct type to an interface type; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap."},{"content":"Boxing operations occur when you pass a value type to a method that takes an <ph id=\"ph1\">@System.Object</ph> as an input parameter.","pos":[1905,2019],"source":" Boxing operations occur when you pass a value type to a method that takes an @System.Object as an input parameter."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Boxing and Unboxing<ept id=\"p1\">](./programming-guide/types/boxing-and-unboxing.md )</ept>.","pos":[2020,2119],"source":" For more information, see [Boxing and Unboxing](./programming-guide/types/boxing-and-unboxing.md )."},{"content":"You use the <bpt id=\"p1\">[</bpt>struct<ept id=\"p1\">](./language-reference/keywords/struct.md)</ept> keyword to create your own custom value types.","pos":[2125,2233],"source":"You use the [struct](./language-reference/keywords/struct.md) keyword to create your own custom value types."},{"content":"Typically, a struct is used as a container for a small set of related variables, as shown in the following example:","pos":[2234,2349]},{"pos":[2355,2451],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Struct Keyword<ept id=\"p2\">](../../samples/snippets/csharp/concepts/structs/struct-keyword.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Struct Keyword](../../samples/snippets/csharp/concepts/structs/struct-keyword.cs)]"},{"pos":[2457,2579],"content":"For more information about value types in the .NET Framework, see <bpt id=\"p1\">[</bpt>Common Type System<ept id=\"p1\">](../standard/common-type-system.md)</ept>.","source":"For more information about value types in the .NET Framework, see [Common Type System](../standard/common-type-system.md)."},{"content":"Structs share most of the same syntax as classes, although structs are more limited than classes:","pos":[2587,2684]},{"pos":[2694,2800],"content":"Within a struct declaration, fields cannot be initialized unless they are declared as <ph id=\"ph1\">`const`</ph> or <ph id=\"ph2\">`static`</ph>.","source":"Within a struct declaration, fields cannot be initialized unless they are declared as `const` or `static`."},{"content":"A struct cannot declare a default constructor (a constructor without parameters) or a finalizer.","pos":[2810,2906]},{"content":"Structs are copied on assignment.","pos":[2916,2949]},{"content":"When a struct is assigned to a new variable, all the data is copied, and any modification to the new copy does not change the data for the original copy.","pos":[2950,3103]},{"content":"This is important to remember when working with collections of value types such as Dictionary&lt;string, myStruct&gt;.","pos":[3104,3216],"source":" This is important to remember when working with collections of value types such as Dictionary<string, myStruct>."},{"content":"Structs are value types and classes are reference types.","pos":[3226,3282]},{"pos":[3292,3367],"content":"Unlike classes, structs can be instantiated without using a <ph id=\"ph1\">`new`</ph> operator.","source":"Unlike classes, structs can be instantiated without using a `new` operator."},{"content":"Structs can declare constructors that have parameters.","pos":[3377,3431]},{"content":"A struct cannot inherit from another struct or class, and it cannot be the base of a class.","pos":[3441,3532]},{"content":"All structs inherit directly from <ph id=\"ph1\">@System.ValueType</ph>, which inherits from <ph id=\"ph2\">@System.Object</ph>.","pos":[3533,3621],"source":" All structs inherit directly from @System.ValueType, which inherits from @System.Object."},{"content":"A struct can implement interfaces.","pos":[3631,3665]},{"pos":[3670,3684],"content":"Literal values","linkify":"Literal values","nodes":[{"content":"Literal values","pos":[0,14]}]},{"content":"In C#, literal values receive a type from the compiler.","pos":[3687,3742]},{"content":"You can specify how a numeric literal should be typed by appending a letter to the end of the number.","pos":[3743,3844]},{"content":"For example, to specify that the value 4.56 should be treated as a float, append an \"f\" or \"F\" after the number: <ph id=\"ph1\">`4.56f`</ph>.","pos":[3845,3966],"source":" For example, to specify that the value 4.56 should be treated as a float, append an \"f\" or \"F\" after the number: `4.56f`."},{"content":"If no letter is appended, the compiler will infer the <ph id=\"ph1\">`double`</ph> type for the literal.","pos":[3967,4051],"source":" If no letter is appended, the compiler will infer the `double` type for the literal."},{"content":"For more information about which types can be specified with letter suffixes, see the reference pages for individual types in <bpt id=\"p1\">[</bpt>Value Types<ept id=\"p1\">](./language-reference/keywords/value-types.md)</ept>.","pos":[4052,4238],"source":" For more information about which types can be specified with letter suffixes, see the reference pages for individual types in [Value Types](./language-reference/keywords/value-types.md)."},{"content":"Because literals are typed, and all types derive ultimately from <ph id=\"ph1\">@System.Object</ph>, you can write and compile code such as the following:","pos":[4244,4378],"source":"Because literals are typed, and all types derive ultimately from @System.Object, you can write and compile code such as the following:"},{"pos":[4384,4474],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Literal Values<ept id=\"p2\">](../../samples/snippets/csharp/concepts/structs/literals.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[Literal Values](../../samples/snippets/csharp/concepts/structs/literals.cs)]"},{"content":"The last two examples demonstrate language features introduced in C# 7.0.","pos":[4476,4549]},{"content":"The first allows you to use an underscore character as a <bpt id=\"p1\">*</bpt>digit separator<ept id=\"p1\">*</ept> inside numeric literals.","pos":[4550,4649],"source":" The first allows you to use an underscore character as a *digit separator* inside numeric literals."},{"content":"You can put them wherever you want between digits to improve readability.","pos":[4650,4723]},{"content":"They have no effect on the value.","pos":[4724,4757]},{"pos":[4759,4889],"content":"The second demonstrates <bpt id=\"p1\">*</bpt>binary literals<ept id=\"p1\">*</ept>, which allow you to specify bit patterns directly instead of using hexadecimal notation.","source":"The second demonstrates *binary literals*, which allow you to specify bit patterns directly instead of using hexadecimal notation."},{"pos":[4894,4908],"content":"Nullable types","linkify":"Nullable types","nodes":[{"content":"Nullable types","pos":[0,14]}]},{"content":"Ordinary value types cannot have a value of <bpt id=\"p1\">[</bpt>null<ept id=\"p1\">](./language-reference/keywords/null.md)</ept>.","pos":[4911,5001],"source":"Ordinary value types cannot have a value of [null](./language-reference/keywords/null.md)."},{"content":"However, you can create nullable value types by affixing a <bpt id=\"p1\">**</bpt>?<ept id=\"p1\">**</ept>","pos":[5002,5066],"source":" However, you can create nullable value types by affixing a **?**"},{"content":"after the type.","pos":[5067,5082]},{"content":"For example, <bpt id=\"p1\">**</bpt>int?<ept id=\"p1\">**</ept> is an <bpt id=\"p2\">**</bpt>int<ept id=\"p2\">**</ept> type that can also have the value <bpt id=\"p3\">[</bpt>null<ept id=\"p3\">](./language-reference/keywords/null.md)</ept>.","pos":[5083,5199],"source":" For example, **int?** is an **int** type that can also have the value [null](./language-reference/keywords/null.md)."},{"content":"In the CTS, nullable types are instances of the generic struct type <ph id=\"ph1\">@System.Nullable</ph>%601.","pos":[5200,5289],"source":" In the CTS, nullable types are instances of the generic struct type @System.Nullable%601."},{"content":"Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null.","pos":[5290,5413]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Nullable Types (C# Programming Guide)<ept id=\"p1\">](./programming-guide/nullable-types/index.md)</ept>.","pos":[5414,5525],"source":" For more information, see [Nullable Types (C# Programming Guide)](./programming-guide/nullable-types/index.md)."},{"pos":[5530,5538],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5539,5560],"content":"<bpt id=\"p1\">[</bpt>Classes<ept id=\"p1\">](classes.md)</ept>","source":"[Classes](classes.md)"},{"pos":[5562,5591],"content":"<bpt id=\"p1\">[</bpt>Basic Types<ept id=\"p1\">](basic-types.md)</ept>","source":"[Basic Types](basic-types.md)"}]}