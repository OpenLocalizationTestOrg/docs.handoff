<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="arithmetic-operators.md" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">192acf6fea0c6014aaf092077f8deaa844dfd2ec</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\language-reference\operators\arithmetic-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3520304cd17e8b6803d68b7c856eda080ed9a0b3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">222812c04b322028afe5f5494e009c94429735c3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Arithmetic operators - C# Reference</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Learn about C# operators that perform multiplication, division, remainder, addition, and subtraction operations with numeric types.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Arithmetic operators (C# Reference)</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The following operators perform arithmetic operations with numeric types:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Unary <bpt id="p1">[</bpt><ph id="ph1">`++`</ph> (increment)<ept id="p1">](#increment-operator-)</ept>, <bpt id="p2">[</bpt><ph id="ph2">`--`</ph> (decrement)<ept id="p2">](#decrement-operator---)</ept>, <bpt id="p3">[</bpt><ph id="ph3">`+`</ph> (plus)<ept id="p3">](#unary-plus-and-minus-operators)</ept>, and <bpt id="p4">[</bpt><ph id="ph4">`-`</ph> (minus)<ept id="p4">](#unary-plus-and-minus-operators)</ept> operators.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Binary <bpt id="p1">[</bpt><ph id="ph1">`*`</ph> (multiplication)<ept id="p1">](#multiplication-operator-)</ept>, <bpt id="p2">[</bpt><ph id="ph2">`/`</ph> (division)<ept id="p2">](#division-operator-)</ept>, <bpt id="p3">[</bpt><ph id="ph3">`%`</ph> (remainder)<ept id="p3">](#remainder-operator-)</ept>, <bpt id="p4">[</bpt><ph id="ph4">`+`</ph> (addition)<ept id="p4">](#addition-operator-)</ept>, and <bpt id="p5">[</bpt><ph id="ph5">`-`</ph> (subtraction)<ept id="p5">](#subtraction-operator--)</ept> operators.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Those operators support all <bpt id="p1">[</bpt>integral<ept id="p1">](../keywords/integral-types-table.md)</ept> and <bpt id="p2">[</bpt>floating-point<ept id="p2">](../keywords/floating-point-types-table.md)</ept> numeric types.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Increment operator ++</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The unary increment operator <ph id="ph1">`++`</ph> increments its operand by 1.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The operand must be a variable, a <bpt id="p1">[</bpt>property<ept id="p1">](../../programming-guide/classes-and-structs/properties.md)</ept> access, or an <bpt id="p2">[</bpt>indexer<ept id="p2">](../../../csharp/programming-guide/indexers/index.md)</ept> access.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The increment operator is supported in two forms: the postfix increment operator, <ph id="ph1">`x++`</ph>, and the prefix increment operator, <ph id="ph2">`++x`</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Postfix increment operator</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The result of <ph id="ph1">`x++`</ph> is the value of <ph id="ph2">`x`</ph> <bpt id="p1">*</bpt>before<ept id="p1">*</ept> the operation, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Prefix increment operator</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The result of <ph id="ph1">`++x`</ph> is the value of <ph id="ph2">`x`</ph> <bpt id="p1">*</bpt>after<ept id="p1">*</ept> the operation, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Decrement operator --</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The unary decrement operator <ph id="ph1">`--`</ph> decrements its operand by 1.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The operand must be a variable, a <bpt id="p1">[</bpt>property<ept id="p1">](../../programming-guide/classes-and-structs/properties.md)</ept> access, or an <bpt id="p2">[</bpt>indexer<ept id="p2">](../../../csharp/programming-guide/indexers/index.md)</ept> access.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The decrement operator is supported in two forms: the postfix decrement operator, <ph id="ph1">`x--`</ph>, and the prefix decrement operator, <ph id="ph2">`--x`</ph>.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Postfix decrement operator</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The result of <ph id="ph1">`x--`</ph> is the value of <ph id="ph2">`x`</ph> <bpt id="p1">*</bpt>before<ept id="p1">*</ept> the operation, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Prefix decrement operator</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The result of <ph id="ph1">`--x`</ph> is the value of <ph id="ph2">`x`</ph> <bpt id="p1">*</bpt>after<ept id="p1">*</ept> the operation, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Unary plus and minus operators</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The unary <ph id="ph1">`+`</ph> operator returns the value of its operand.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The unary <ph id="ph1">`-`</ph> operator computes the numeric negation of its operand.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The unary <ph id="ph1">`-`</ph> operator doesn't support the <bpt id="p1">[</bpt>ulong<ept id="p1">](../keywords/ulong.md)</ept> type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Multiplication operator *</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The multiplication operator <ph id="ph1">`*`</ph> computes the product of its operands:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The unary <ph id="ph1">`*`</ph> operator is a <bpt id="p1">[</bpt>pointer indirection operator<ept id="p1">](multiplication-operator.md#pointer-indirection-operator)</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Division operator /</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The division operator <ph id="ph1">`/`</ph> divides its first operand by its second operand.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Integer division</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For the operands of integer types, the result of the <ph id="ph1">`/`</ph> operator is of an integer type and equals the quotient of the two operands rounded towards zero:</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To obtain the quotient of the two operands as a floating-point number, use the <ph id="ph1">`float`</ph>, <ph id="ph2">`double`</ph>, or <ph id="ph3">`decimal`</ph> type:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Floating-point division</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For the <ph id="ph1">`float`</ph>, <ph id="ph2">`double`</ph>, and <ph id="ph3">`decimal`</ph> types, the result of the <ph id="ph4">`/`</ph> operator is the quotient of the two operands:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If one of the operands is <ph id="ph1">`decimal`</ph>, another operand can be neither <ph id="ph2">`float`</ph> nor <ph id="ph3">`double`</ph>, because neither <ph id="ph4">`float`</ph> nor <ph id="ph5">`double`</ph> is implicitly convertible to <ph id="ph6">`decimal`</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You must explicitly convert the <ph id="ph1">`float`</ph> or <ph id="ph2">`double`</ph> operand to the <ph id="ph3">`decimal`</ph> type.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more information about implicit conversions between numeric types, see <bpt id="p1">[</bpt>Implicit numeric conversions table<ept id="p1">](../keywords/implicit-numeric-conversions-table.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Remainder operator %</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The remainder operator <ph id="ph1">`%`</ph> computes the remainder after dividing its first operand by its second operand.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Integer remainder</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For the operands of integer types, the result of <ph id="ph1">`a % b`</ph> is the value produced by <ph id="ph2">`a - (a / b) * b`</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The sign of the non-zero remainder is the same as that of the first operand, as the following example shows:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Use the <ph id="ph1">&lt;xref:System.Math.DivRem%2A?displayProperty=nameWithType&gt;</ph> method to compute both integer division and remainder results.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Floating-point remainder</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For the <ph id="ph1">`float`</ph> and <ph id="ph2">`double`</ph> operands, the result of <ph id="ph3">`x % y`</ph> for the finite <ph id="ph4">`x`</ph> and <ph id="ph5">`y`</ph> is the value <ph id="ph6">`z`</ph> such that</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The sign of <ph id="ph1">`z`</ph>, if non-zero, is the same as the sign of <ph id="ph2">`x`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The absolute value of <ph id="ph1">`z`</ph> is the value produced by <ph id="ph2">`|x| - n * |y|`</ph> where <ph id="ph3">`n`</ph> is the largest possible integer that is less than or equal to <ph id="ph4">`|x| / |y|`</ph> and <ph id="ph5">`|x|`</ph> and <ph id="ph6">`|y|`</ph> are the absolute values of <ph id="ph7">`x`</ph> and <ph id="ph8">`y`</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This method of computing the remainder is analogous to that used for integer operands, but differs from the IEEE 754.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you need the remainder operation that complies with the IEEE 754, use the <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A?displayProperty=nameWithType&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For information about the behavior of the <ph id="ph1">`%`</ph> operator with non-finite operands, see the <bpt id="p1">[</bpt>Remainder operator<ept id="p1">](~/_csharplang/spec/expressions.md#remainder-operator)</ept> section of the <bpt id="p2">[</bpt>C# language specification<ept id="p2">](~/_csharplang/spec/introduction.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For the <ph id="ph1">`decimal`</ph> operands, the remainder operator <ph id="ph2">`%`</ph> is equivalent to the <bpt id="p1">[</bpt>remainder operator<ept id="p1">](&lt;xref:System.Decimal.op_Modulus(System.Decimal,System.Decimal)&gt;)</ept> of the <ph id="ph3">&lt;xref:System.Decimal?displayProperty=nameWithType&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the behavior of the remainder operator with floating-point operands:</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Addition operator +</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The addition operator <ph id="ph1">`+`</ph> computes the sum of its operands:</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You also can use the <ph id="ph1">`+`</ph> operator for string concatenation and delegate combination.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt><ph id="ph1">`+`</ph> operator<ept id="p1">](addition-operator.md)</ept> article.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Subtraction operator -</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The subtraction operator <ph id="ph1">`-`</ph> subtracts its second operand from its first operand:</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You also can use the <ph id="ph1">`-`</ph> operator for delegate removal.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt><ph id="ph1">`-`</ph> operator<ept id="p1">](subtraction-operator.md)</ept> article.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following list orders arithmetic operators starting from the highest precedence to the lowest:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Postfix increment <ph id="ph1">`x++`</ph> and decrement <ph id="ph2">`x--`</ph> operators.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Prefix increment <ph id="ph1">`++x`</ph> and decrement <ph id="ph2">`--x`</ph> and unary <ph id="ph3">`+`</ph> and <ph id="ph4">`-`</ph> operators.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Multiplicative <ph id="ph1">`*`</ph>, <ph id="ph2">`/`</ph>, and <ph id="ph3">`%`</ph> operators.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Additive <ph id="ph1">`+`</ph> and <ph id="ph2">`-`</ph> operators.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators are left-associative.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>That is, operators with the same precedence level are evaluated from left to right.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Use parentheses, <ph id="ph1">`()`</ph>, to change the order of evaluation imposed by operator precedence and associativity.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>For the complete list of C# operators ordered by precedence level, see <bpt id="p1">[</bpt>C# operators<ept id="p1">](index.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Compound assignment</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For a binary operator <ph id="ph1">`op`</ph>, a compound assignment expression of the form</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>except that <ph id="ph1">`x`</ph> is only evaluated once.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the usage of compound assignment with arithmetic operators:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>You also use the <ph id="ph1">`+=`</ph> and <ph id="ph2">`-=`</ph> operators to subscribe to and unsubscribe from <bpt id="p1">[</bpt>events<ept id="p1">](../keywords/event.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>How to: subscribe to and unsubscribe from events<ept id="p1">](../../programming-guide/events/how-to-subscribe-to-and-unsubscribe-from-events.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Arithmetic overflow and division by zero</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>When the result of an arithmetic operation is outside the range of possible finite values of the involved numeric type, the behavior of an arithmetic operator depends on the type of its operands.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Integer arithmetic overflow</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Integer division by zero always throws a <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In case of integer arithmetic overflow, an overflow checking context, which can be <bpt id="p1">[</bpt>checked or unchecked<ept id="p1">](../keywords/checked-and-unchecked.md)</ept>, controls the resulting behavior:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In a checked context, if overflow happens in a constant expression, a compile-time error occurs.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Otherwise, when the operation is performed at run time, an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In an unchecked context, the result is truncated by discarding any high-order bits that don't fit in the destination type.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Along with the <bpt id="p1">[</bpt>checked and unchecked<ept id="p1">](../keywords/checked-and-unchecked.md)</ept> statements, you can use the <ph id="ph1">`checked`</ph> and <ph id="ph2">`unchecked`</ph> operators to control the overflow checking context, in which an expression is evaluated:</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>By default, arithmetic operations occur in an <bpt id="p1">*</bpt>unchecked<ept id="p1">*</ept> context.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic overflow</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Arithmetic operations with the <ph id="ph1">`float`</ph> and <ph id="ph2">`double`</ph> types never throw an exception.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The result of arithmetic operations with those types can be one of special values that represent infinity and not-a-number:</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For the operands of the <ph id="ph1">`decimal`</ph> type, arithmetic overflow always throws an <ph id="ph2">&lt;xref:System.OverflowException&gt;</ph> and division by zero always throws a <ph id="ph3">&lt;xref:System.DivideByZeroException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Round-off errors</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Because of general limitations of the floating-point representation of real numbers and floating-point arithmetic, the round-off errors might occur in calculations with floating-point types.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>That is, the produced result of an expression might differ from the expected mathematical result.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following example demonstrates several such cases:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For more information, see remarks at <bpt id="p1">[</bpt>System.Double<ept id="p1">](/dotnet/api/system.double#remarks)</ept>, <bpt id="p2">[</bpt>System.Single<ept id="p2">](/dotnet/api/system.single#remarks)</ept>, or <bpt id="p3">[</bpt>System.Decimal<ept id="p3">](/dotnet/api/system.decimal#remarks)</ept> reference pages.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Operator overloadability</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>User-defined types can <bpt id="p1">[</bpt>overload<ept id="p1">](../keywords/operator.md)</ept> the unary (<ph id="ph1">`++`</ph>, <ph id="ph2">`--`</ph>, <ph id="ph3">`+`</ph>, and <ph id="ph4">`-`</ph>) and binary (<ph id="ph5">`*`</ph>, <ph id="ph6">`/`</ph>, <ph id="ph7">`%`</ph>, <ph id="ph8">`+`</ph>, and <ph id="ph9">`-`</ph>) arithmetic operators.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>When a binary operator is overloaded, the corresponding compound assignment operator is also implicitly overloaded.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A user-defined type cannot explicitly overload a compound assignment operator.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>C# language specification</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For more information, see the following sections of the <bpt id="p1">[</bpt>C# language specification<ept id="p1">](~/_csharplang/spec/introduction.md)</ept>:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Postfix increment and decrement operators<ept id="p1">](~/_csharplang/spec/expressions.md#postfix-increment-and-decrement-operators)</ept></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Prefix increment and decrement operators<ept id="p1">](~/_csharplang/spec/expressions.md#prefix-increment-and-decrement-operators)</ept></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unary plus operator<ept id="p1">](~/_csharplang/spec/expressions.md#unary-plus-operator)</ept></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Unary minus operator<ept id="p1">](~/_csharplang/spec/expressions.md#unary-minus-operator)</ept></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Multiplication operator<ept id="p1">](~/_csharplang/spec/expressions.md#multiplication-operator)</ept></source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Division operator<ept id="p1">](~/_csharplang/spec/expressions.md#division-operator)</ept></source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Remainder operator<ept id="p1">](~/_csharplang/spec/expressions.md#remainder-operator)</ept></source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Addition operator<ept id="p1">](~/_csharplang/spec/expressions.md#addition-operator)</ept></source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Subtraction operator<ept id="p1">](~/_csharplang/spec/expressions.md#subtraction-operator)</ept></source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Compound assignment<ept id="p1">](~/_csharplang/spec/expressions.md#compound-assignment)</ept></source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>The checked and unchecked operators<ept id="p1">](~/_csharplang/spec/expressions.md#the-checked-and-unchecked-operators)</ept></source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Reference<ept id="p1">](../index.md)</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../programming-guide/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Operators<ept id="p1">](index.md)</ept></source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Numerics in .NET<ept id="p1">](../../../standard/numerics.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>