{"content":"---\ntitle: \"Interfaces (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Visual Basic code, interfaces\"\n  - \"interfaces [Visual Basic], Visual Basic\"\n  - \"interfaces\"\n  - \"interfaces [Visual Basic]\"\nms.assetid: 61b06674-12c9-430b-be68-cc67ecee1f5b\n---\n# Interfaces (Visual Basic)\n*Interfaces* define the properties, methods, and events that classes can implement. Interfaces allow you to define features as small groups of closely related properties, methods, and events; this reduces compatibility problems because you can develop enhanced implementations for your interfaces without jeopardizing existing code. You can add new features at any time by developing additional interfaces and implementations.  \n  \n There are several other reasons why you might want to use interfaces instead of class inheritance:  \n  \n-   Interfaces are better suited to situations in which your applications require many possibly unrelated object types to provide certain functionality.  \n  \n-   Interfaces are more flexible than base classes because you can define a single implementation that can implement multiple interfaces.  \n  \n-   Interfaces are better in situations in which you do not have to inherit implementation from a base class.  \n  \n-   Interfaces are useful when you cannot use class inheritance. For example, structures cannot inherit from classes, but they can implement interfaces.  \n  \n## Declaring Interfaces  \n Interface definitions are enclosed within the `Interface` and `End Interface` statements. Following the `Interface` statement, you can add an optional `Inherits` statement that lists one or more inherited interfaces. The `Inherits` statements must precede all other statements in the declaration except comments. The remaining statements in the interface definition should be `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure`, and `Enum` statements. Interfaces cannot contain any implementation code or statements associated with implementation code, such as `End Sub` or `End Property`.  \n  \n In a namespace, interface statements are `Friend` by default, but they can also be explicitly declared as `Public` or `Friend`. Interfaces defined within classes, modules, interfaces, and structures are `Public` by default, but they can also be explicitly declared as `Public`, `Friend`, `Protected`, or `Private`.  \n  \n> [!NOTE]\n>  The `Shadows` keyword can be applied to all interface members. The `Overloads` keyword can be applied to `Sub`, `Function`, and `Property` statements declared in an interface definition. In addition, `Property` statements can have the `Default`, `ReadOnly`, or `WriteOnly` modifiers. None of the other modifiers—`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`, or `Overridable`—are allowed. For more information, see [Declaration Contexts and Default Access Levels](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).  \n  \n For example, the following code defines an interface with one function, one property, and one event.  \n  \n [!code-vb[VbVbalrOOP#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#17)]  \n  \n## Implementing Interfaces  \n The Visual Basic reserved word `Implements` is used in two ways. The `Implements` statement signifies that a class or structure implements an interface. The `Implements` keyword signifies that a class member or structure member implements a specific interface member.  \n  \n### Implements Statement  \n If a class or structure implements one or more interfaces, it must include the `Implements` statement immediately after the `Class` or `Structure` statement. The `Implements` statement requires a comma-separated list of interfaces to be implemented by a class. The class or structure must implement all interface members using the `Implements` keyword.  \n  \n### Implements Keyword  \n The `Implements` keyword requires a comma-separated list of interface members to be implemented. Generally, only a single interface member is specified, but you can specify multiple members. The specification of an interface member consists of the interface name, which must be specified in an implements statement within the class; a period; and the name of the member function, property, or event to be implemented. The name of a member that implements an interface member can use any legal identifier, and it is not limited to the `InterfaceName_MethodName` convention used in earlier versions of Visual Basic.  \n  \n For example, the following code shows how to declare a subroutine named `Sub1` that implements a method of an interface:  \n  \n [!code-vb[VbVbalrOOP#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#69)]  \n  \n The parameter types and return types of the implementing member must match the interface property or member declaration in the interface. The most common way to implement an element of an interface is with a member that has the same name as the interface, as shown in the previous example.  \n  \n To declare the implementation of an interface method, you can use any attributes that are legal on instance method declarations, including `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default`, and `Static`. The `Shared` attribute is not legal since it defines a class rather than an instance method.  \n  \n Using `Implements`, you can also write a single method that implements multiple methods defined in an interface, as in the following example:  \n  \n [!code-vb[VbVbalrOOP#70](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#70)]  \n  \n You can use a private member to implement an interface member. When a private member implements a member of an interface, that member becomes available by way of the interface even though it is not available directly on object variables for the class.  \n  \n### Interface Implementation Examples  \n Classes that implement an interface must implement all its properties, methods, and events.  \n  \n The following example defines two interfaces. The second interface, `Interface2`, inherits `Interface1` and defines an additional property and method.  \n  \n [!code-vb[VbVbalrOOP#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#39)]  \n  \n The next example implements `Interface1`, the interface defined in the previous example:  \n  \n [!code-vb[VbVbalrOOP#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#40)]  \n  \n The final example implements `Interface2`, including a method inherited from `Interface1`:  \n  \n [!code-vb[VbVbalrOOP#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#41)]  \n  \n You can implement a readonly property with a readwrite property (that is, you do not have to declare it readonly in the implementing class).  Implementing an interface promises to implement at least the members that the interface declares, but you can offer more functionality, such as allowing your property to be writable.  \n  \n## Related Topics  \n  \n|Title|Description|  \n|-----------|-----------------|  \n|[Walkthrough: Creating and Implementing Interfaces](../../../../visual-basic/programming-guide/language-features/interfaces/walkthrough-creating-and-implementing-interfaces.md)|Provides a detailed procedure that takes you through the process of defining and implementing your own interface.|  \n|[Variance in Generic Interfaces](../../concepts/covariance-contravariance/variance-in-generic-interfaces.md)|Discusses covariance and contravariance in generic interfaces and provides a list of variant generic interfaces in the .NET Framework.|\n","nodes":[{"pos":[4,260],"embed":true,"restype":"x-metadata","content":"title: \"Interfaces (Visual Basic)\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"Visual Basic code, interfaces\"\n  - \"interfaces [Visual Basic], Visual Basic\"\n  - \"interfaces\"\n  - \"interfaces [Visual Basic]\"\nms.assetid: 61b06674-12c9-430b-be68-cc67ecee1f5b","nodes":[{"content":"Interfaces (Visual Basic)","nodes":[{"pos":[0,25],"content":"Interfaces (Visual Basic)","nodes":[{"content":"Interfaces (Visual Basic)","pos":[0,25]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[267,292],"content":"Interfaces (Visual Basic)","linkify":"Interfaces (Visual Basic)","nodes":[{"content":"Interfaces (Visual Basic)","pos":[0,25]}]},{"content":"<bpt id=\"p1\">*</bpt>Interfaces<ept id=\"p1\">*</ept> define the properties, methods, and events that classes can implement.","pos":[293,376],"source":"*Interfaces* define the properties, methods, and events that classes can implement."},{"content":"Interfaces allow you to define features as small groups of closely related properties, methods, and events; this reduces compatibility problems because you can develop enhanced implementations for your interfaces without jeopardizing existing code.","pos":[377,625]},{"content":"You can add new features at any time by developing additional interfaces and implementations.","pos":[626,719]},{"content":"There are several other reasons why you might want to use interfaces instead of class inheritance:","pos":[726,824]},{"content":"Interfaces are better suited to situations in which your applications require many possibly unrelated object types to provide certain functionality.","pos":[834,982]},{"content":"Interfaces are more flexible than base classes because you can define a single implementation that can implement multiple interfaces.","pos":[992,1125]},{"content":"Interfaces are better in situations in which you do not have to inherit implementation from a base class.","pos":[1135,1240]},{"content":"Interfaces are useful when you cannot use class inheritance.","pos":[1250,1310]},{"content":"For example, structures cannot inherit from classes, but they can implement interfaces.","pos":[1311,1398]},{"pos":[1407,1427],"content":"Declaring Interfaces","linkify":"Declaring Interfaces","nodes":[{"content":"Declaring Interfaces","pos":[0,20]}]},{"content":"Interface definitions are enclosed within the <ph id=\"ph1\">`Interface`</ph> and <ph id=\"ph2\">`End Interface`</ph> statements.","pos":[1431,1520],"source":"Interface definitions are enclosed within the `Interface` and `End Interface` statements."},{"content":"Following the <ph id=\"ph1\">`Interface`</ph> statement, you can add an optional <ph id=\"ph2\">`Inherits`</ph> statement that lists one or more inherited interfaces.","pos":[1521,1647],"source":" Following the `Interface` statement, you can add an optional `Inherits` statement that lists one or more inherited interfaces."},{"content":"The <ph id=\"ph1\">`Inherits`</ph> statements must precede all other statements in the declaration except comments.","pos":[1648,1743],"source":" The `Inherits` statements must precede all other statements in the declaration except comments."},{"content":"The remaining statements in the interface definition should be <ph id=\"ph1\">`Event`</ph>, <ph id=\"ph2\">`Sub`</ph>, <ph id=\"ph3\">`Function`</ph>, <ph id=\"ph4\">`Property`</ph>, <ph id=\"ph5\">`Interface`</ph>, <ph id=\"ph6\">`Class`</ph>, <ph id=\"ph7\">`Structure`</ph>, and <ph id=\"ph8\">`Enum`</ph> statements.","pos":[1744,1904],"source":" The remaining statements in the interface definition should be `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure`, and `Enum` statements."},{"content":"Interfaces cannot contain any implementation code or statements associated with implementation code, such as <ph id=\"ph1\">`End Sub`</ph> or <ph id=\"ph2\">`End Property`</ph>.","pos":[1905,2042],"source":" Interfaces cannot contain any implementation code or statements associated with implementation code, such as `End Sub` or `End Property`."},{"content":"In a namespace, interface statements are <ph id=\"ph1\">`Friend`</ph> by default, but they can also be explicitly declared as <ph id=\"ph2\">`Public`</ph> or <ph id=\"ph3\">`Friend`</ph>.","pos":[2049,2176],"source":"In a namespace, interface statements are `Friend` by default, but they can also be explicitly declared as `Public` or `Friend`."},{"content":"Interfaces defined within classes, modules, interfaces, and structures are <ph id=\"ph1\">`Public`</ph> by default, but they can also be explicitly declared as <ph id=\"ph2\">`Public`</ph>, <ph id=\"ph3\">`Friend`</ph>, <ph id=\"ph4\">`Protected`</ph>, or <ph id=\"ph5\">`Private`</ph>.","pos":[2177,2363],"source":" Interfaces defined within classes, modules, interfaces, and structures are `Public` by default, but they can also be explicitly declared as `Public`, `Friend`, `Protected`, or `Private`."},{"pos":[2371,2988],"content":"[!NOTE]\n The `Shadows` keyword can be applied to all interface members. The `Overloads` keyword can be applied to `Sub`, `Function`, and `Property` statements declared in an interface definition. In addition, `Property` statements can have the `Default`, `ReadOnly`, or `WriteOnly` modifiers. None of the other modifiers—`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`, or `Overridable`—are allowed. For more information, see [Declaration Contexts and Default Access Levels](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).","leadings":["","> "],"nodes":[{"content":"The `Shadows` keyword can be applied to all interface members. The `Overloads` keyword can be applied to `Sub`, `Function`, and `Property` statements declared in an interface definition. In addition, `Property` statements can have the `Default`, `ReadOnly`, or `WriteOnly` modifiers. None of the other modifiers—`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`, or `Overridable`—are allowed. For more information, see [Declaration Contexts and Default Access Levels](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).","pos":[9,615],"nodes":[{"content":"The <ph id=\"ph1\">`Shadows`</ph> keyword can be applied to all interface members.","pos":[0,62],"source":"The `Shadows` keyword can be applied to all interface members."},{"content":"The <ph id=\"ph1\">`Overloads`</ph> keyword can be applied to <ph id=\"ph2\">`Sub`</ph>, <ph id=\"ph3\">`Function`</ph>, and <ph id=\"ph4\">`Property`</ph> statements declared in an interface definition.","pos":[63,186],"source":" The `Overloads` keyword can be applied to `Sub`, `Function`, and `Property` statements declared in an interface definition."},{"content":"In addition, <ph id=\"ph1\">`Property`</ph> statements can have the <ph id=\"ph2\">`Default`</ph>, <ph id=\"ph3\">`ReadOnly`</ph>, or <ph id=\"ph4\">`WriteOnly`</ph> modifiers.","pos":[187,283],"source":" In addition, `Property` statements can have the `Default`, `ReadOnly`, or `WriteOnly` modifiers."},{"content":"None of the other modifiers—<ph id=\"ph1\">`Public`</ph>, <ph id=\"ph2\">`Private`</ph>, <ph id=\"ph3\">`Friend`</ph>, <ph id=\"ph4\">`Protected`</ph>, <ph id=\"ph5\">`Shared`</ph>, <ph id=\"ph6\">`Overrides`</ph>, <ph id=\"ph7\">`MustOverride`</ph>, or <ph id=\"ph8\">`Overridable`</ph>—are allowed.","pos":[284,424],"source":" None of the other modifiers—`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`, or `Overridable`—are allowed."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Declaration Contexts and Default Access Levels<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md)</ept>.","pos":[425,606],"source":" For more information, see [Declaration Contexts and Default Access Levels](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md)."}]}]},{"content":"For example, the following code defines an interface with one function, one property, and one event.","pos":[2995,3095]},{"pos":[3213,3236],"content":"Implementing Interfaces","linkify":"Implementing Interfaces","nodes":[{"content":"Implementing Interfaces","pos":[0,23]}]},{"content":"The Visual Basic reserved word <ph id=\"ph1\">`Implements`</ph> is used in two ways.","pos":[3240,3304],"source":"The Visual Basic reserved word `Implements` is used in two ways."},{"content":"The <ph id=\"ph1\">`Implements`</ph> statement signifies that a class or structure implements an interface.","pos":[3305,3392],"source":" The `Implements` statement signifies that a class or structure implements an interface."},{"content":"The <ph id=\"ph1\">`Implements`</ph> keyword signifies that a class member or structure member implements a specific interface member.","pos":[3393,3507],"source":" The `Implements` keyword signifies that a class member or structure member implements a specific interface member."},{"pos":[3517,3537],"content":"Implements Statement","linkify":"Implements Statement","nodes":[{"content":"Implements Statement","pos":[0,20]}]},{"content":"If a class or structure implements one or more interfaces, it must include the <ph id=\"ph1\">`Implements`</ph> statement immediately after the <ph id=\"ph2\">`Class`</ph> or <ph id=\"ph3\">`Structure`</ph> statement.","pos":[3541,3698],"source":"If a class or structure implements one or more interfaces, it must include the `Implements` statement immediately after the `Class` or `Structure` statement."},{"content":"The <ph id=\"ph1\">`Implements`</ph> statement requires a comma-separated list of interfaces to be implemented by a class.","pos":[3699,3801],"source":" The `Implements` statement requires a comma-separated list of interfaces to be implemented by a class."},{"content":"The class or structure must implement all interface members using the <ph id=\"ph1\">`Implements`</ph> keyword.","pos":[3802,3893],"source":" The class or structure must implement all interface members using the `Implements` keyword."},{"pos":[3903,3921],"content":"Implements Keyword","linkify":"Implements Keyword","nodes":[{"content":"Implements Keyword","pos":[0,18]}]},{"content":"The <ph id=\"ph1\">`Implements`</ph> keyword requires a comma-separated list of interface members to be implemented.","pos":[3925,4021],"source":"The `Implements` keyword requires a comma-separated list of interface members to be implemented."},{"content":"Generally, only a single interface member is specified, but you can specify multiple members.","pos":[4022,4115]},{"content":"The specification of an interface member consists of the interface name, which must be specified in an implements statement within the class; a period; and the name of the member function, property, or event to be implemented.","pos":[4116,4342]},{"content":"The name of a member that implements an interface member can use any legal identifier, and it is not limited to the <ph id=\"ph1\">`InterfaceName_MethodName`</ph> convention used in earlier versions of Visual Basic.","pos":[4343,4538],"source":" The name of a member that implements an interface member can use any legal identifier, and it is not limited to the `InterfaceName_MethodName` convention used in earlier versions of Visual Basic."},{"pos":[4545,4665],"content":"For example, the following code shows how to declare a subroutine named <ph id=\"ph1\">`Sub1`</ph> that implements a method of an interface:","source":"For example, the following code shows how to declare a subroutine named `Sub1` that implements a method of an interface:"},{"content":"The parameter types and return types of the implementing member must match the interface property or member declaration in the interface.","pos":[4781,4918]},{"content":"The most common way to implement an element of an interface is with a member that has the same name as the interface, as shown in the previous example.","pos":[4919,5070]},{"content":"To declare the implementation of an interface method, you can use any attributes that are legal on instance method declarations, including <ph id=\"ph1\">`Overloads`</ph>, <ph id=\"ph2\">`Overrides`</ph>, <ph id=\"ph3\">`Overridable`</ph>, <ph id=\"ph4\">`Public`</ph>, <ph id=\"ph5\">`Private`</ph>, <ph id=\"ph6\">`Protected`</ph>, <ph id=\"ph7\">`Friend`</ph>, <ph id=\"ph8\">`Protected Friend`</ph>, <ph id=\"ph9\">`MustOverride`</ph>, <ph id=\"ph10\">`Default`</ph>, and <ph id=\"ph11\">`Static`</ph>.","pos":[5077,5361],"source":"To declare the implementation of an interface method, you can use any attributes that are legal on instance method declarations, including `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default`, and `Static`."},{"content":"The <ph id=\"ph1\">`Shared`</ph> attribute is not legal since it defines a class rather than an instance method.","pos":[5362,5454],"source":" The `Shared` attribute is not legal since it defines a class rather than an instance method."},{"pos":[5461,5602],"content":"Using <ph id=\"ph1\">`Implements`</ph>, you can also write a single method that implements multiple methods defined in an interface, as in the following example:","source":"Using `Implements`, you can also write a single method that implements multiple methods defined in an interface, as in the following example:"},{"content":"You can use a private member to implement an interface member.","pos":[5718,5780]},{"content":"When a private member implements a member of an interface, that member becomes available by way of the interface even though it is not available directly on object variables for the class.","pos":[5781,5969]},{"pos":[5979,6012],"content":"Interface Implementation Examples","linkify":"Interface Implementation Examples","nodes":[{"content":"Interface Implementation Examples","pos":[0,33]}]},{"content":"Classes that implement an interface must implement all its properties, methods, and events.","pos":[6016,6107]},{"content":"The following example defines two interfaces.","pos":[6114,6159]},{"content":"The second interface, <ph id=\"ph1\">`Interface2`</ph>, inherits <ph id=\"ph2\">`Interface1`</ph> and defines an additional property and method.","pos":[6160,6264],"source":" The second interface, `Interface2`, inherits `Interface1` and defines an additional property and method."},{"pos":[6380,6468],"content":"The next example implements <ph id=\"ph1\">`Interface1`</ph>, the interface defined in the previous example:","source":"The next example implements `Interface1`, the interface defined in the previous example:"},{"pos":[6584,6674],"content":"The final example implements <ph id=\"ph1\">`Interface2`</ph>, including a method inherited from <ph id=\"ph2\">`Interface1`</ph>:","source":"The final example implements `Interface2`, including a method inherited from `Interface1`:"},{"content":"You can implement a readonly property with a readwrite property (that is, you do not have to declare it readonly in the implementing class).","pos":[6790,6930]},{"content":"Implementing an interface promises to implement at least the members that the interface declares, but you can offer more functionality, such as allowing your property to be writable.","pos":[6932,7114]},{"pos":[7123,7137],"content":"Related Topics","linkify":"Related Topics","nodes":[{"content":"Related Topics","pos":[0,14]}]},{"content":"Title","pos":[7144,7149]},{"content":"Description","pos":[7150,7161]},{"pos":[7200,7376],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Creating and Implementing Interfaces<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/interfaces/walkthrough-creating-and-implementing-interfaces.md)</ept>","source":"[Walkthrough: Creating and Implementing Interfaces](../../../../visual-basic/programming-guide/language-features/interfaces/walkthrough-creating-and-implementing-interfaces.md)"},{"content":"Provides a detailed procedure that takes you through the process of defining and implementing your own interface.","pos":[7377,7490]},{"pos":[7495,7603],"content":"<bpt id=\"p1\">[</bpt>Variance in Generic Interfaces<ept id=\"p1\">](../../concepts/covariance-contravariance/variance-in-generic-interfaces.md)</ept>","source":"[Variance in Generic Interfaces](../../concepts/covariance-contravariance/variance-in-generic-interfaces.md)"},{"content":"Discusses covariance and contravariance in generic interfaces and provides a list of variant generic interfaces in the .NET Framework.","pos":[7604,7738]}]}