{"content":"---\ntitle: \"using static Directive (C# Reference) | Microsoft Docs\"\nms.date: \"2017-03-10\"\nms.prod: .net\nms.technology: \n  - \"devlang-csharp\"\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nhelpviewer_keywords: \n  - \"using static directive [C#]\"\nms.assetid: 8b8f9e34-c75e-469b-ba85-6f2eb4090314\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\ntranslation.priority.ht: \n  - \"cs-cz\"\n  - \"de-de\"\n  - \"es-es\"\n  - \"fr-fr\"\n  - \"it-it\"\n  - \"ja-jp\"\n  - \"ko-kr\"\n  - \"pl-pl\"\n  - \"pt-br\"\n  - \"ru-ru\"\n  - \"tr-tr\"\n  - \"zh-cn\"\n  - \"zh-tw\"\n---\n# using static Directive (C# Reference)\n\nThe `using static` directive designates a type whose static members you can access without specifying a type name. Its syntax is:\n\n```csharp\nusing static <fully-qualified-type-name>\n```\n\nwhere *fully-qualified-type-name* is the name of the type whose static members can be referenced without specifying a type name. If you do not provide a fully qualified type name (the full namespace name along with the type name), C# generates compiler error CS0246: \"The type or namespace name '<type-name>' could not be found.\"\n\nThe `using static` directive applies to any type that has static members, even if it also has instance members. However, instance members can only be invoked through the type instance.\n\nThe `using static` directive was introduced in C# 6.\n\n## Remarks\n \nOrdinarily, when you call a static member, you provide the type name along with the member name. Repeatedly entering the same type name to invoke members of the type can result in verbose, obscure code. For example, the following definition of a `Circle` class references a number of members of the @System.Math class.\n  \n[!code-cs[using-static#1](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static1.cs#1)]\n\nBy eliminating the need to explicitly reference the @System.Math class each time a member is referenced, the `using static` directive produces much cleaner code:\n\n[!code-cs[using-static#2](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static2.cs#1)]\n\n`using static` imports only accessible static members and nested types declared in the specified type.  Inherited members are not imported.  You can import from any named type with a using static directive, including Visual Basic modules.  If F# top-level functions appear in metadata as static members of a named type whose name is a valid C# identifier, then the F# functions can be imported.  \n  \n `using static` makes extension methods declared in the specified type available for extension method lookup.  However, the names of the extension methods are not imported into scope for unqualified reference in code.  \n  \n Methods with the same name imported from different types by different `using static` directives in the same compilation unit or namespace form a method group.  Overload resolution within these method groups follows normal C# rules.  \n  \n## Example\n\nThe following example uses the `using static` directive to make the static members of the @System.Console, @System.Math, and @System.String classes available without having to specify their type name.\n\n[!code-cs[using-static#3](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static3.cs)]\n\nIn the example, the `using static` directive could also have been applied to the @System.Double type. This would have made it possible to call the @System.Double.TryParse(System.String,System.Double@) method without specifying a type name. However, this creates less readable code, since it becomes necessary to check the `using static` statements to determine which numeric type's `TryParse` method is called.\n\n## See also\n\n[using directive](using-directive.md)   \n[C# Reference](../../../csharp/language-reference/index.md)   \n[C# Keywords](../../../csharp/language-reference/keywords/index.md)   \n[Using Namespaces](../../../csharp/programming-guide/namespaces/using-namespaces.md)   \n[Namespace Keywords](../../../csharp/language-reference/keywords/namespace-keywords.md)   \n[Namespaces](../../../csharp/programming-guide/namespaces/index.md)   \n","nodes":[{"pos":[12,66],"content":"using static Directive (C# Reference) | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"using static Directive (C# Reference) | Microsoft Docs","pos":[0,54]}]},{"pos":[519,556],"content":"using static Directive (C# Reference)","linkify":"using static Directive (C# Reference)","nodes":[{"content":"using static Directive (C# Reference)","pos":[0,37]}]},{"content":"The <ph id=\"ph1\">`using static`</ph> directive designates a type whose static members you can access without specifying a type name.","pos":[558,672],"source":"The `using static` directive designates a type whose static members you can access without specifying a type name."},{"content":"Its syntax is:","pos":[673,687]},{"content":"where <bpt id=\"p1\">*</bpt>fully-qualified-type-name<ept id=\"p1\">*</ept> is the name of the type whose static members can be referenced without specifying a type name.","pos":[745,873],"source":"where *fully-qualified-type-name* is the name of the type whose static members can be referenced without specifying a type name."},{"content":"If you do not provide a fully qualified type name (the full namespace name along with the type name), C# generates compiler error CS0246: \"The type or namespace name '&lt;type-name&gt;' could not be found.\"","pos":[874,1074],"source":" If you do not provide a fully qualified type name (the full namespace name along with the type name), C# generates compiler error CS0246: \"The type or namespace name '<type-name>' could not be found.\""},{"content":"The <ph id=\"ph1\">`using static`</ph> directive applies to any type that has static members, even if it also has instance members.","pos":[1076,1187],"source":"The `using static` directive applies to any type that has static members, even if it also has instance members."},{"content":"However, instance members can only be invoked through the type instance.","pos":[1188,1260]},{"pos":[1262,1314],"content":"The <ph id=\"ph1\">`using static`</ph> directive was introduced in C# 6.","source":"The `using static` directive was introduced in C# 6."},{"pos":[1319,1326],"content":"Remarks","linkify":"Remarks","nodes":[{"content":"Remarks","pos":[0,7]}]},{"content":"Ordinarily, when you call a static member, you provide the type name along with the member name.","pos":[1329,1425]},{"content":"Repeatedly entering the same type name to invoke members of the type can result in verbose, obscure code.","pos":[1426,1531]},{"content":"For example, the following definition of a <ph id=\"ph1\">`Circle`</ph> class references a number of members of the <ph id=\"ph2\">@System.Math</ph> class.","pos":[1532,1647],"source":" For example, the following definition of a `Circle` class references a number of members of the @System.Math class."},{"pos":[1651,1767],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>using-static#1<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static1.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[using-static#1](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static1.cs#1)]"},{"pos":[1769,1930],"content":"By eliminating the need to explicitly reference the <ph id=\"ph1\">@System.Math</ph> class each time a member is referenced, the <ph id=\"ph2\">`using static`</ph> directive produces much cleaner code:","source":"By eliminating the need to explicitly reference the @System.Math class each time a member is referenced, the `using static` directive produces much cleaner code:"},{"pos":[1932,2048],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>using-static#2<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static2.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[using-static#2](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static2.cs#1)]"},{"content":"<ph id=\"ph1\">`using static`</ph> imports only accessible static members and nested types declared in the specified type.","pos":[2050,2152],"source":"`using static` imports only accessible static members and nested types declared in the specified type."},{"content":"Inherited members are not imported.","pos":[2154,2189]},{"content":"You can import from any named type with a using static directive, including Visual Basic modules.","pos":[2191,2288]},{"content":"If F# top-level functions appear in metadata as static members of a named type whose name is a valid C# identifier, then the F# functions can be imported.","pos":[2290,2444]},{"content":"<ph id=\"ph1\">`using static`</ph> makes extension methods declared in the specified type available for extension method lookup.","pos":[2451,2559],"source":"`using static` makes extension methods declared in the specified type available for extension method lookup."},{"content":"However, the names of the extension methods are not imported into scope for unqualified reference in code.","pos":[2561,2667]},{"content":"Methods with the same name imported from different types by different <ph id=\"ph1\">`using static`</ph> directives in the same compilation unit or namespace form a method group.","pos":[2674,2832],"source":"Methods with the same name imported from different types by different `using static` directives in the same compilation unit or namespace form a method group."},{"content":"Overload resolution within these method groups follows normal C# rules.","pos":[2834,2905]},{"pos":[2914,2921],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[2923,3123],"content":"The following example uses the <ph id=\"ph1\">`using static`</ph> directive to make the static members of the <ph id=\"ph2\">@System.Console</ph>, <ph id=\"ph3\">@System.Math</ph>, and <ph id=\"ph4\">@System.String</ph> classes available without having to specify their type name.","source":"The following example uses the `using static` directive to make the static members of the @System.Console, @System.Math, and @System.String classes available without having to specify their type name."},{"pos":[3125,3239],"content":"<bpt id=\"p1\">[!code-cs</bpt><bpt id=\"p2\">[</bpt>using-static#3<ept id=\"p2\">](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static3.cs)</ept><ept id=\"p1\">]</ept>","source":"[!code-cs[using-static#3](../../../../samples/snippets/csharp/language-reference/keywords/using/using-static3.cs)]"},{"content":"In the example, the <ph id=\"ph1\">`using static`</ph> directive could also have been applied to the <ph id=\"ph2\">@System.Double</ph> type.","pos":[3241,3342],"source":"In the example, the `using static` directive could also have been applied to the @System.Double type."},{"content":"This would have made it possible to call the <ph id=\"ph1\">@System.Double.TryParse</ph>(System.String,System.Double@) method without specifying a type name.","pos":[3343,3480],"source":" This would have made it possible to call the @System.Double.TryParse(System.String,System.Double@) method without specifying a type name."},{"content":"However, this creates less readable code, since it becomes necessary to check the <ph id=\"ph1\">`using static`</ph> statements to determine which numeric type's <ph id=\"ph2\">`TryParse`</ph> method is called.","pos":[3481,3651],"source":" However, this creates less readable code, since it becomes necessary to check the `using static` statements to determine which numeric type's `TryParse` method is called."},{"pos":[3656,3664],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>using directive<ept id=\"p1\">](using-directive.md)</ept><ph id=\"ph1\"> </ph>","pos":[3666,3704],"source":"[using directive](using-directive.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Reference<ept id=\"p1\">](../../../csharp/language-reference/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[3707,3767],"source":"[C# Reference](../../../csharp/language-reference/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>C# Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/index.md)</ept><ph id=\"ph1\"> </ph>","pos":[3770,3838],"source":"[C# Keywords](../../../csharp/language-reference/keywords/index.md) "},{"content":"<bpt id=\"p1\">[</bpt>Using Namespaces<ept id=\"p1\">](../../../csharp/programming-guide/namespaces/using-namespaces.md)</ept><ph id=\"ph1\"> </ph>","pos":[3841,3926],"source":"[Using Namespaces](../../../csharp/programming-guide/namespaces/using-namespaces.md) "},{"content":"<bpt id=\"p1\">[</bpt>Namespace Keywords<ept id=\"p1\">](../../../csharp/language-reference/keywords/namespace-keywords.md)</ept><ph id=\"ph1\"> </ph>","pos":[3929,4017],"source":"[Namespace Keywords](../../../csharp/language-reference/keywords/namespace-keywords.md) "},{"content":"<bpt id=\"p1\">[</bpt>Namespaces<ept id=\"p1\">](../../../csharp/programming-guide/namespaces/index.md)</ept>","pos":[4020,4087],"source":"[Namespaces](../../../csharp/programming-guide/namespaces/index.md)"}]}