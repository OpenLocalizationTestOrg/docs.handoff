{"content":"---\ntitle: \"How to: Write a LINQ to XML Axis Method (C#)\"\nms.date: 07/20/2015\nms.assetid: 50aef06b-1d22-4718-a18a-21237e26d7c1\n---\n# How to: Write a LINQ to XML Axis Method (C#)\nYou can write your own axis methods to retrieve collections from an XML tree. One of the best ways to do this is to write an extension method that returns a collection of elements or attributes. You can write your extension method to return specific subsets of elements or attributes, based on the requirements of your application.  \n  \n## Example  \n The following example uses two extension methods. The first extension method, `GetXPath`, operates on <xref:System.Xml.Linq.XObject>, and returns an XPath expression that when evaluated will return the node or attribute. The second extension method, `Find`, operates on <xref:System.Xml.Linq.XElement>. It returns a collection of <xref:System.Xml.Linq.XAttribute> objects and <xref:System.Xml.Linq.XElement> objects that contain some specified text.  \n  \n This example uses the following XML document: [Sample XML File: Multiple Purchase Orders (LINQ to XML)](../../../../csharp/programming-guide/concepts/linq/sample-xml-file-multiple-purchase-orders-linq-to-xml.md).  \n  \n```csharp  \npublic static class MyExtensions  \n{  \n    private static string GetQName(XElement xe)  \n    {  \n        string prefix = xe.GetPrefixOfNamespace(xe.Name.Namespace);  \n        if (xe.Name.Namespace == XNamespace.None || prefix == null)  \n            return xe.Name.LocalName.ToString();  \n        else  \n            return prefix + \":\" + xe.Name.LocalName.ToString();  \n    }  \n  \n    private static string GetQName(XAttribute xa)  \n    {  \n        string prefix =  \n            xa.Parent.GetPrefixOfNamespace(xa.Name.Namespace);  \n        if (xa.Name.Namespace == XNamespace.None || prefix == null)  \n            return xa.Name.ToString();  \n        else  \n            return prefix + \":\" + xa.Name.LocalName;  \n    }  \n  \n    private static string NameWithPredicate(XElement el)  \n    {  \n        if (el.Parent != null && el.Parent.Elements(el.Name).Count() != 1)  \n            return GetQName(el) + \"[\" +   \n                (el.ElementsBeforeSelf(el.Name).Count() + 1) + \"]\";  \n        else  \n            return GetQName(el);  \n    }  \n  \n    public static string StrCat<T>(this IEnumerable<T> source,  \n        string separator)  \n    {  \n        return source.Aggregate(new StringBuilder(),  \n                   (sb, i) => sb  \n                       .Append(i.ToString())  \n                       .Append(separator),  \n                   s => s.ToString());  \n    }  \n  \n    public static string GetXPath(this XObject xobj)  \n    {  \n        if (xobj.Parent == null)  \n        {  \n            XDocument doc = xobj as XDocument;  \n            if (doc != null)  \n                return \".\";  \n            XElement el = xobj as XElement;  \n            if (el != null)  \n                return \"/\" + NameWithPredicate(el);  \n            // the XPath data model does not include white space text nodes  \n            // that are children of a document, so this method returns null.  \n            XText xt = xobj as XText;  \n            if (xt != null)  \n                return null;  \n            XComment com = xobj as XComment;  \n            if (com != null)  \n                return  \n                    \"/\" +  \n                    (  \n                        com  \n                        .Document  \n                        .Nodes()  \n                        .OfType<XComment>()  \n                        .Count() != 1 ?  \n                        \"comment()[\" +  \n                        (com  \n                        .NodesBeforeSelf()  \n                        .OfType<XComment>()  \n                        .Count() + 1) +  \n                        \"]\" :  \n                        \"comment()\"  \n                    );  \n            XProcessingInstruction pi = xobj as XProcessingInstruction;  \n            if (pi != null)  \n                return  \n                    \"/\" +  \n                    (  \n                        pi.Document.Nodes()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() != 1 ?  \n                        \"processing-instruction()[\" +  \n                        (pi  \n                        .NodesBeforeSelf()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() + 1) +  \n                        \"]\" :  \n                        \"processing-instruction()\"  \n                    );  \n            return null;  \n        }  \n        else  \n        {  \n            XElement el = xobj as XElement;  \n            if (el != null)  \n            {  \n                return  \n                    \"/\" +  \n                    el  \n                    .Ancestors()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    NameWithPredicate(el);  \n            }  \n            XAttribute at = xobj as XAttribute;  \n            if (at != null)  \n                return  \n                    \"/\" +  \n                    at  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    \"@\" + GetQName(at);  \n            XComment com = xobj as XComment;  \n            if (com != null)  \n                return  \n                    \"/\" +  \n                    com  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        com  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XComment>()  \n                        .Count() != 1 ?  \n                        \"comment()[\" +  \n                        (com  \n                        .NodesBeforeSelf()  \n                        .OfType<XComment>()  \n                        .Count() + 1) + \"]\" :  \n                        \"comment()\"  \n                    );  \n            XCData cd = xobj as XCData;  \n            if (cd != null)  \n                return  \n                    \"/\" +  \n                    cd  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        cd  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XText>()  \n                        .Count() != 1 ?  \n                        \"text()[\" +  \n                        (cd  \n                        .NodesBeforeSelf()  \n                        .OfType<XText>()  \n                        .Count() + 1) + \"]\" :  \n                        \"text()\"  \n                    );  \n            XText tx = xobj as XText;  \n            if (tx != null)  \n                return  \n                    \"/\" +  \n                    tx  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        tx  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XText>()  \n                        .Count() != 1 ?  \n                        \"text()[\" +  \n                        (tx  \n                        .NodesBeforeSelf()  \n                        .OfType<XText>()  \n                        .Count() + 1) + \"]\" :  \n                        \"text()\"  \n                    );  \n            XProcessingInstruction pi = xobj as XProcessingInstruction;  \n            if (pi != null)  \n                return  \n                    \"/\" +  \n                    pi  \n                    .Parent  \n                    .AncestorsAndSelf()  \n                    .InDocumentOrder()  \n                    .Select(e => NameWithPredicate(e))  \n                    .StrCat(\"/\") +  \n                    (  \n                        pi  \n                        .Parent  \n                        .Nodes()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() != 1 ?  \n                        \"processing-instruction()[\" +  \n                        (pi  \n                        .NodesBeforeSelf()  \n                        .OfType<XProcessingInstruction>()  \n                        .Count() + 1) + \"]\" :  \n                        \"processing-instruction()\"  \n                    );  \n            return null;  \n        }  \n    }  \n  \n    public static IEnumerable<XObject> Find(this XElement source, string value)  \n    {  \n        if (source.Attributes().Any())  \n        {  \n            foreach (XAttribute att in source.Attributes())  \n            {  \n                string contents = (string)att;  \n                if (contents.Contains(value))  \n                    yield return att;  \n            }  \n        }  \n        if (source.Elements().Any())  \n        {  \n            foreach (XElement child in source.Elements())  \n                foreach (XObject s in child.Find(value))  \n                    yield return s;  \n        }  \n        else  \n        {  \n            string contents = (string)source;  \n            if (contents.Contains(value))  \n                yield return source;  \n        }  \n    }  \n}  \n  \nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        XElement purchaseOrders = XElement.Load(\"PurchaseOrders.xml\");  \n  \n        IEnumerable<XObject> subset =  \n            from xobj in purchaseOrders.Find(\"1999\")  \n            select xobj;  \n  \n        foreach (XObject obj in subset)  \n        {  \n            Console.WriteLine(obj.GetXPath());  \n            if (obj.GetType() == typeof(XElement))  \n                Console.WriteLine(((XElement)obj).Value);  \n            else if (obj.GetType() == typeof(XAttribute))  \n                Console.WriteLine(((XAttribute)obj).Value);  \n        }  \n    }  \n}  \n```  \n  \n This code produces the following output:  \n  \n```  \n/PurchaseOrders/PurchaseOrder[1]/@OrderDate  \n1999-10-20  \n/PurchaseOrders/PurchaseOrder[1]/Items/Item[2]/ShipDate  \n1999-05-21  \n/PurchaseOrders/PurchaseOrder[2]/@OrderDate  \n1999-10-22  \n/PurchaseOrders/PurchaseOrder[3]/@OrderDate  \n1999-10-22  \n```  \n  \n## See also\n\n- [Advanced Query Techniques (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)\n","nodes":[{"pos":[4,126],"embed":true,"restype":"x-metadata","content":"title: \"How to: Write a LINQ to XML Axis Method (C#)\"\nms.date: 07/20/2015\nms.assetid: 50aef06b-1d22-4718-a18a-21237e26d7c1","nodes":[{"content":"How to: Write a LINQ to XML Axis Method (C#)","nodes":[{"pos":[0,44],"content":"How to: Write a LINQ to XML Axis Method (C#)","nodes":[{"content":"How to: Write a LINQ to XML Axis Method (C#)","pos":[0,44]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[133,177],"content":"How to: Write a LINQ to XML Axis Method (C#)","linkify":"How to: Write a LINQ to XML Axis Method (C#)","nodes":[{"content":"How to: Write a LINQ to XML Axis Method (C#)","pos":[0,44]}]},{"content":"You can write your own axis methods to retrieve collections from an XML tree.","pos":[178,255]},{"content":"One of the best ways to do this is to write an extension method that returns a collection of elements or attributes.","pos":[256,372]},{"content":"You can write your extension method to return specific subsets of elements or attributes, based on the requirements of your application.","pos":[373,509]},{"pos":[518,525],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example uses two extension methods.","pos":[529,578]},{"content":"The first extension method, <ph id=\"ph1\">`GetXPath`</ph>, operates on <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XObject&gt;</ph>, and returns an XPath expression that when evaluated will return the node or attribute.","pos":[579,749],"source":" The first extension method, `GetXPath`, operates on <xref:System.Xml.Linq.XObject>, and returns an XPath expression that when evaluated will return the node or attribute."},{"content":"The second extension method, <ph id=\"ph1\">`Find`</ph>, operates on <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.","pos":[750,831],"source":" The second extension method, `Find`, operates on <xref:System.Xml.Linq.XElement>."},{"content":"It returns a collection of <ph id=\"ph1\">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> objects and <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XElement&gt;</ph> objects that contain some specified text.","pos":[832,978],"source":" It returns a collection of <xref:System.Xml.Linq.XAttribute> objects and <xref:System.Xml.Linq.XElement> objects that contain some specified text."},{"pos":[985,1197],"content":"This example uses the following XML document: <bpt id=\"p1\">[</bpt>Sample XML File: Multiple Purchase Orders (LINQ to XML)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/sample-xml-file-multiple-purchase-orders-linq-to-xml.md)</ept>.","source":"This example uses the following XML document: [Sample XML File: Multiple Purchase Orders (LINQ to XML)](../../../../csharp/programming-guide/concepts/linq/sample-xml-file-multiple-purchase-orders-linq-to-xml.md)."},{"content":"This code produces the following output:","pos":[10302,10342]},{"pos":[10614,10622],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[10626,10765],"content":"<bpt id=\"p1\">[</bpt>Advanced Query Techniques (LINQ to XML) (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)</ept>","source":"[Advanced Query Techniques (LINQ to XML) (C#)](../../../../csharp/programming-guide/concepts/linq/advanced-query-techniques-linq-to-xml.md)"}]}