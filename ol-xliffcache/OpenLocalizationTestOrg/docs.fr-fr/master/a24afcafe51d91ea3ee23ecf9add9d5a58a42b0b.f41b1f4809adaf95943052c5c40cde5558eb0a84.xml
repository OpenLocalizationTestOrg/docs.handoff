{"content":"---\ntitle: \"Custom Dependency Properties | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"implementing, wrappers\"\n  - \"registering properties\"\n  - \"properties, metadata\"\n  - \"metadata, for properties\"\n  - \"custom dependency properties\"\n  - \"properties, registering\"\n  - \"wrappers, implementing\"\n  - \"dependency properties, custom\"\nms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f\ncaps.latest.revision: 25\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Custom Dependency Properties\nThis topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.  \n  \n\n  \n<a name=\"prerequisites\"></a>   \n## Prerequisites  \n This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) topic. In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.  \n  \n<a name=\"whatis\"></a>   \n## What Is a Dependency Property?  \n You can enable what would otherwise be a [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property. Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field. Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties. For more information about dependency properties and some of the terminology and conventions used for describing them in this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)], see [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).  \n  \n<a name=\"example_dp\"></a>   \n## Examples of Dependency Properties  \n Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others. Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class. This is the identifier for the dependency property. The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it. For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>. The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.  \n  \n As mentioned in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties because of the \"wrapper\" implementation. Therefore, from code, you can get or set dependency properties by calling [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] accessors that define the wrappers in the same manner that you would use other [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties. As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system. Rather, the existing implementation of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately. If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.  \n  \n<a name=\"backing_with_dp\"></a>   \n## When Should You Implement a Dependency Property?  \n When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property. Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs. Sometimes, the typical technique of backing your property with a private field is adequate. However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:  \n  \n-   You want your property to be settable in a style. For more information, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).  \n  \n-   You want your property to support data binding. For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../../../../docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  \n  \n-   You want your property to be settable with a dynamic resource reference. For more information, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).  \n  \n-   You want to inherit a property value automatically from a parent element in the element tree. In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] access. For more information, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  \n  \n-   You want your property to be animatable. For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).  \n  \n-   You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles. By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed. A related concept is property value coercion. For more information, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  \n  \n-   You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element. Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.  \n  \n-   You want properties of a custom control to receive [!INCLUDE[vs_orcas_long](../../../../includes/vs-orcas-long-md.md)] [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)] support, such as **Properties** window editing. For more information, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).  \n  \n When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property. Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes. For more information about overriding metadata on existing properties, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).  \n  \n<a name=\"checklist\"></a>   \n## Checklist for Defining a Dependency Property  \n Defining a dependency property consists of four distinct concepts. These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:  \n  \n-   (Optional) Create property metadata for the dependency property.  \n  \n-   Register the property name with the property system, specifying an owner type and the type of the property value. Also specify the property metadata, if used.  \n  \n-   Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.  \n  \n-   Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] \"wrapper\" property whose name matches the name of the dependency property. Implement the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] \"wrapper\" property's `get` and `set` accessors to connect with the dependency property that backs it.  \n  \n<a name=\"registering\"></a>   \n### Registering the Property with the Property System  \n In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations. These operations might be internal operations, or your own code calling property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]. To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions). The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value. The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class. This field becomes the identifier for your dependency property.  \n  \n [!code-csharp[WPFAquariumSln#RegisterAG](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]\n [!code-vb[WPFAquariumSln#RegisterAG](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]  \n  \n<a name=\"nameconventions\"></a>   \n### Dependency Property Name Conventions  \n There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.  \n  \n The dependency property itself will have a basic name, \"AquariumGraphic\" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>. That name must be unique within each registering type. Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again. However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).  \n  \n When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`. This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.  \n  \n> [!NOTE]\n>  Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor. This approach might make sense if you need more than one line of code to initialize the dependency property.  \n  \n<a name=\"wrapper1\"></a>   \n### Implementing the \"Wrapper\"  \n Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).  \n  \n In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively. The reason for this is discussed in the topic [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).  \n  \n All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.  \n  \n [!code-csharp[WPFAquariumSln#AGWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]\n [!code-vb[WPFAquariumSln#AGWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]  \n  \n Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property. If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:  \n  \n-   Certain aspects of styles and templates will not work.  \n  \n-   Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.  \n  \n-   The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values. For more information, see [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).  \n  \n<a name=\"metadata\"></a>   \n### Property Metadata for a New Dependency Property  \n When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics. Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>. Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property. The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.  \n  \n If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class. The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination. If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>. Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).  \n  \n For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property. These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.  \n  \n#### Setting Appropriate Metadata Flags  \n  \n-   If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions>, <xref:System.Windows.FrameworkPropertyMetadataOptions>, <xref:System.Windows.FrameworkPropertyMetadataOptions>.  \n  \n    -   <xref:System.Windows.FrameworkPropertyMetadataOptions> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent. For example, a \"Width\" property should have this flag set.  \n  \n    -   <xref:System.Windows.FrameworkPropertyMetadataOptions> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed. For example, an \"Alignment\" property should have this flag set.  \n  \n    -   <xref:System.Windows.FrameworkPropertyMetadataOptions> indicates that some other change has occurred that will not affect layout and measure, but does require another render. An example would be a property that changes a color of an existing element, such as \"Background\".  \n  \n    -   These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks. For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.  \n  \n-   Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above. An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph. Use <xref:System.Windows.FrameworkPropertyMetadataOptions> or <xref:System.Windows.FrameworkPropertyMetadataOptions> to identify similar cases in your own properties.  \n  \n-   By default, dependency properties support data binding. You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.  \n  \n-   By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode>. You can always change the binding to be <xref:System.Windows.Data.BindingMode> per binding instance; for details, see [Specify the Direction of the Binding](../../../../docs/framework/wpf/data/how-to-specify-the-direction-of-the-binding.md). But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode> binding mode by default. An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=fullName>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style. The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls. Another example property that binds <xref:System.Windows.Data.BindingMode> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName>.  \n  \n-   You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions> flag. Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it. An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation. By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also. Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements. <xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../../../../docs/framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md). Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  \n  \n-   Set the <xref:System.Windows.FrameworkPropertyMetadataOptions> flag to indicate if your dependency property should be detected or used by navigation journaling services. An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.  \n  \n<a name=\"RODP\"></a>   \n## Read-Only Dependency Properties  \n You can define a dependency property that is read-only. However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier. For more information, see [Read-Only Dependency Properties](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md).  \n  \n<a name=\"CTDP\"></a>   \n## Collection-Type Dependency Properties  \n Collection-type dependency properties have some additional implementation issues to consider. For details, see [Collection-Type Dependency Properties](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md).  \n  \n<a name=\"SecurityC\"></a>   \n## Dependency Property Security Considerations  \n Dependency properties should be declared as public properties. Dependency property identifier fields should be declared as public static fields. Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]. Even a protected identifier field is potentially accessible because of metadata reporting or value determination [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>. For more information, see [Dependency Property Security](../../../../docs/framework/wpf/advanced/dependency-property-security.md).  \n  \n<a name=\"DPCtor\"></a>   \n## Dependency Properties and Class Constructors  \n There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods. This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed. When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally. These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services. Overriding the methods enables derived classes to participate in value determination. To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern. For details, see [Safe Constructor Patterns for DependencyObjects](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md).  \n  \n## See Also  \n [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   \n [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)   \n [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md)   \n [Collection-Type Dependency Properties](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md)   \n [Dependency Property Security](../../../../docs/framework/wpf/advanced/dependency-property-security.md)   \n [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)   \n [Safe Constructor Patterns for DependencyObjects](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)","nodes":[{"pos":[4,626],"embed":true,"restype":"x-metadata","content":"title: \"Custom Dependency Properties | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-wpf\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"implementing, wrappers\"\n  - \"registering properties\"\n  - \"properties, metadata\"\n  - \"metadata, for properties\"\n  - \"custom dependency properties\"\n  - \"properties, registering\"\n  - \"wrappers, implementing\"\n  - \"dependency properties, custom\"\nms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f\ncaps.latest.revision: 25\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"","nodes":[{"content":"Custom Dependency Properties | Microsoft Docs","nodes":[{"pos":[0,45],"content":"Custom Dependency Properties | Microsoft Docs","nodes":[{"content":"Custom Dependency Properties | Microsoft Docs","pos":[0,45]}]}],"path":["title"]}],"yml":true},{"pos":[633,661],"content":"Custom Dependency Properties","linkify":"Custom Dependency Properties","nodes":[{"content":"Custom Dependency Properties","pos":[0,28]}]},{"pos":[662,1024],"content":"This topic describes the reasons that <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.","source":"This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property."},{"pos":[1069,1082],"content":"Prerequisites","linkify":"Prerequisites","nodes":[{"content":"Prerequisites","pos":[0,13]}]},{"content":"This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> classes, and have read the <bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept> topic.","pos":[1086,1442],"source":"This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) topic."},{"content":"In order to follow the examples in this topic, you should also understand <ph id=\"ph1\">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph> and know how to write <ph id=\"ph2\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications.","pos":[1443,1704],"source":" In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications."},{"pos":[1738,1768],"content":"What Is a Dependency Property?","linkify":"What Is a Dependency Property?","nodes":[{"content":"What Is a Dependency Property?","pos":[0,30]}]},{"content":"You can enable what would otherwise be a <ph id=\"ph1\">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.","pos":[1772,2012],"source":"You can enable what would otherwise be a [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property."},{"content":"Dependency properties are properties that are registered with the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system by calling the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method (or <ph id=\"ph3\">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph>), and that are backed by a <ph id=\"ph4\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier field.","pos":[2013,2402],"source":" Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field."},{"content":"Dependency properties can be used only by <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, but <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject&gt;</ph> is quite high in the <ph id=\"ph3\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> class hierarchy, so the majority of classes available in <ph id=\"ph4\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> can support dependency properties.","pos":[2403,2810],"source":" Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties."},{"content":"For more information about dependency properties and some of the terminology and conventions used for describing them in this <ph id=\"ph1\">[!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]</ph>, see <bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.","pos":[2811,3120],"source":" For more information about dependency properties and some of the terminology and conventions used for describing them in this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)], see [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)."},{"pos":[3158,3191],"content":"Examples of Dependency Properties","linkify":"Examples of Dependency Properties","nodes":[{"content":"Examples of Dependency Properties","pos":[0,33]}]},{"content":"Examples of dependency properties that are implemented on <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> classes include the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> property, the <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> property, and the <ph id=\"ph4\">&lt;xref:System.Windows.Controls.TextBox.Text%2A&gt;</ph> property, among many others.","pos":[3195,3563],"source":"Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others."},{"content":"Each dependency property exposed by a class has a corresponding public static field of type <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> exposed on that same class.","pos":[3564,3724],"source":" Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class."},{"content":"This is the identifier for the dependency property.","pos":[3725,3776]},{"content":"The identifier is named using a convention: the name of the dependency property with the string <ph id=\"ph1\">`Property`</ph> appended to it.","pos":[3777,3899],"source":" The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it."},{"content":"For example, the corresponding <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier field for the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Control.Background%2A&gt;</ph> property is <ph id=\"ph3\">&lt;xref:System.Windows.Controls.Control.BackgroundProperty&gt;</ph>.","pos":[3900,4120],"source":" For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>."},{"content":"The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>.","pos":[4121,4372],"source":" The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>."},{"content":"As mentioned in the <bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>, all dependency properties in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> (except most attached properties) are also <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> properties because of the \"wrapper\" implementation.","pos":[4379,4783],"source":"As mentioned in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties because of the \"wrapper\" implementation."},{"content":"Therefore, from code, you can get or set dependency properties by calling <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> accessors that define the wrappers in the same manner that you would use other <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> properties.","pos":[4784,5088],"source":" Therefore, from code, you can get or set dependency properties by calling [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] accessors that define the wrappers in the same manner that you would use other [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties."},{"content":"As a consumer of established dependency properties, you do not typically use the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> methods <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>, which are the connection point to the underlying property system.","pos":[5089,5389],"source":" As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system."},{"content":"Rather, the existing implementation of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> properties will have already called <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> within the <ph id=\"ph4\">`get`</ph> and <ph id=\"ph5\">`set`</ph> wrapper implementations of the property, using the identifier field appropriately.","pos":[5390,5754],"source":" Rather, the existing implementation of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately."},{"content":"If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.","pos":[5755,5873]},{"pos":[5916,5964],"content":"When Should You Implement a Dependency Property?","linkify":"When Should You Implement a Dependency Property?","nodes":[{"content":"When Should You Implement a Dependency Property?","pos":[0,48]}]},{"content":"When you implement a property on a class, so long as your class derives from <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph>, you have the option to back your property with a <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier and thus to make it a dependency property.","pos":[5968,6228],"source":"When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property."},{"content":"Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.","pos":[6229,6354]},{"content":"Sometimes, the typical technique of backing your property with a private field is adequate.","pos":[6355,6446]},{"content":"However, you should implement your property as a dependency property whenever you want your property to support one or more of the following <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> capabilities:","pos":[6447,6683],"source":" However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:"},{"content":"You want your property to be settable in a style.","pos":[6693,6742]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Styling and Templating<ept id=\"p1\">](../../../../docs/framework/wpf/controls/styling-and-templating.md)</ept>.","pos":[6743,6861],"source":" For more information, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md)."},{"content":"You want your property to support data binding.","pos":[6871,6918]},{"content":"For more information about data binding dependency properties, see <bpt id=\"p1\">[</bpt>Bind the Properties of Two Controls<ept id=\"p1\">](../../../../docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.","pos":[6919,7107],"source":" For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../../../../docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)."},{"content":"You want your property to be settable with a dynamic resource reference.","pos":[7117,7189]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>XAML Resources<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-resources.md)</ept>.","pos":[7190,7292],"source":" For more information, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md)."},{"content":"You want to inherit a property value automatically from a parent element in the element tree.","pos":[7302,7395]},{"content":"In this case, register with the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, even if you also create a property wrapper for <ph id=\"ph2\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> access.","pos":[7396,7621],"source":" In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] access."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Property Value Inheritance<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.","pos":[7622,7748],"source":" For more information, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)."},{"content":"You want your property to be animatable.","pos":[7758,7798]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Animation Overview<ept id=\"p1\">](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.","pos":[7799,7920],"source":" For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)."},{"content":"You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.","pos":[7930,8128]},{"content":"By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.","pos":[8129,8313]},{"content":"A related concept is property value coercion.","pos":[8314,8359]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Dependency Property Callbacks and Validation<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.","pos":[8360,8522],"source":" For more information, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)."},{"content":"You want to use established metadata conventions that are also used by <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.","pos":[8532,8821],"source":"You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element."},{"content":"Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.","pos":[8822,8963]},{"content":"You want properties of a custom control to receive <ph id=\"ph1\">[!INCLUDE[vs_orcas_long](../../../../includes/vs-orcas-long-md.md)]</ph> <ph id=\"ph2\">[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]</ph> support, such as <bpt id=\"p1\">**</bpt>Properties<ept id=\"p1\">**</ept> window editing.","pos":[8973,9231],"source":"You want properties of a custom control to receive [!INCLUDE[vs_orcas_long](../../../../includes/vs-orcas-long-md.md)] [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)] support, such as **Properties** window editing."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Control Authoring Overview<ept id=\"p1\">](../../../../docs/framework/wpf/controls/control-authoring-overview.md)</ept>.","pos":[9232,9358],"source":" For more information, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md)."},{"content":"When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.","pos":[9365,9576]},{"content":"Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> dependency properties and classes.","pos":[9577,9830],"source":" Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes."},{"content":"For more information about overriding metadata on existing properties, see <bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)</ept>.","pos":[9831,10010],"source":" For more information about overriding metadata on existing properties, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)."},{"pos":[10047,10091],"content":"Checklist for Defining a Dependency Property","linkify":"Checklist for Defining a Dependency Property","nodes":[{"content":"Checklist for Defining a Dependency Property","pos":[0,44]}]},{"content":"Defining a dependency property consists of four distinct concepts.","pos":[10095,10161]},{"content":"These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:","pos":[10162,10312]},{"content":"(Optional) Create property metadata for the dependency property.","pos":[10322,10386]},{"content":"Register the property name with the property system, specifying an owner type and the type of the property value.","pos":[10396,10509]},{"content":"Also specify the property metadata, if used.","pos":[10510,10554]},{"pos":[10564,10683],"content":"Define a <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier as a <ph id=\"ph2\">`public`</ph> <ph id=\"ph3\">`static`</ph> <ph id=\"ph4\">`readonly`</ph> field on the owner type.","source":"Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type."},{"content":"Define a <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> \"wrapper\" property whose name matches the name of the dependency property.","pos":[10693,10846],"source":"Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] \"wrapper\" property whose name matches the name of the dependency property."},{"content":"Implement the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</ph> \"wrapper\" property's <ph id=\"ph2\">`get`</ph> and <ph id=\"ph3\">`set`</ph> accessors to connect with the dependency property that backs it.","pos":[10847,11032],"source":" Implement the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] \"wrapper\" property's `get` and `set` accessors to connect with the dependency property that backs it."},{"pos":[11072,11121],"content":"Registering the Property with the Property System","linkify":"Registering the Property with the Property System","nodes":[{"content":"Registering the Property with the Property System","pos":[0,49]}]},{"content":"In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.","pos":[11125,11360]},{"content":"These operations might be internal operations, or your own code calling property system <ph id=\"ph1\">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph>.","pos":[11361,11537],"source":" These operations might be internal operations, or your own code calling property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]."},{"content":"To register the property, you call the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method within the body of your class (inside the class, but outside of any member definitions).","pos":[11538,11725],"source":" To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions)."},{"content":"The identifier field is also provided by the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method call, as the return value.","pos":[11726,11857],"source":" The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value."},{"content":"The reason that the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call is done outside of other member definitions is because you use this return value to assign and create a <ph id=\"ph2\">`public`</ph> <ph id=\"ph3\">`static`</ph> <ph id=\"ph4\">`readonly`</ph> field of type <ph id=\"ph5\">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as part of your class.","pos":[11858,12146],"source":" The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class."},{"content":"This field becomes the identifier for your dependency property.","pos":[12147,12210]},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>WPFAquariumSln#RegisterAG<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)</ept><ept id=\"p1\">]</ept>","pos":[12217,12373],"source":"[!code-csharp[WPFAquariumSln#RegisterAG](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>WPFAquariumSln#RegisterAG<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)</ept><ept id=\"p1\">]</ept>","pos":[12375,12537],"source":"[!code-vb[WPFAquariumSln#RegisterAG](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]"},{"pos":[12581,12617],"content":"Dependency Property Name Conventions","linkify":"Dependency Property Name Conventions","nodes":[{"content":"Dependency Property Name Conventions","pos":[0,36]}]},{"content":"There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.","pos":[12621,12752]},{"content":"The dependency property itself will have a basic name, \"AquariumGraphic\" as in this example, which is given as the first parameter of <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>.","pos":[12759,12946],"source":"The dependency property itself will have a basic name, \"AquariumGraphic\" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>."},{"content":"That name must be unique within each registering type.","pos":[12947,13001]},{"content":"Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.","pos":[13002,13169]},{"content":"However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see <bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)</ept>.","pos":[13170,13427],"source":" However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)."},{"content":"When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix <ph id=\"ph1\">`Property`</ph>.","pos":[13434,13565],"source":"When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`."},{"content":"This field is your identifier for the dependency property, and it will be used later as an input for the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by <ph id=\"ph3\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> processors.","pos":[13566,14038],"source":" This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors."},{"pos":[14046,14336],"content":"[!NOTE]\n Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor. This approach might make sense if you need more than one line of code to initialize the dependency property.","leadings":["","> "],"nodes":[{"content":"Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor. This approach might make sense if you need more than one line of code to initialize the dependency property.","pos":[9,288],"nodes":[{"content":"Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.","pos":[0,170]},{"content":"This approach might make sense if you need more than one line of code to initialize the dependency property.","pos":[171,279]}]}]},{"pos":[14373,14399],"content":"Implementing the \"Wrapper\"","linkify":"Implementing the \"Wrapper\"","nodes":[{"content":"Implementing the \"Wrapper\"","pos":[0,26]}]},{"pos":[14403,14680],"content":"Your wrapper implementation should call <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> in the <ph id=\"ph2\">`get`</ph> implementation, and <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> in the <ph id=\"ph4\">`set`</ph> implementation (the original registration call and field are shown here too for clarity).","source":"Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity)."},{"content":"In all but exceptional circumstances, your wrapper implementations should perform only the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> actions, respectively.","pos":[14687,14906],"source":"In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively."},{"content":"The reason for this is discussed in the topic <bpt id=\"p1\">[</bpt>XAML Loading and Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)</ept>.","pos":[14907,15077],"source":" The reason for this is discussed in the topic [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)."},{"pos":[15084,15513],"content":"All existing public dependency properties that are provided on the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.","source":"All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata."},{"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>WPFAquariumSln#AGWithWrapper<ept id=\"p2\">](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)</ept><ept id=\"p1\">]</ept>","pos":[15520,15682],"source":"[!code-csharp[WPFAquariumSln#AGWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]"},{"content":"<bpt id=\"p1\">[!code-vb</bpt><bpt id=\"p2\">[</bpt>WPFAquariumSln#AGWithWrapper<ept id=\"p2\">](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)</ept><ept id=\"p1\">]</ept>","pos":[15684,15852],"source":"[!code-vb[WPFAquariumSln#AGWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]"},{"content":"Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call that registered the property.","pos":[15859,16073],"source":"Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property."},{"content":"If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:","pos":[16074,16222]},{"content":"Certain aspects of styles and templates will not work.","pos":[16232,16286]},{"pos":[16296,16522],"content":"Most tools and designers must rely on the naming conventions to properly serialize <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, or to provide designer environment assistance at a per-property level.","source":"Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level."},{"content":"The current implementation of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.","pos":[16532,16828],"source":"The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>XAML Loading and Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)</ept>.","pos":[16829,16979],"source":" For more information, see [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)."},{"pos":[17016,17063],"content":"Property Metadata for a New Dependency Property","linkify":"Property Metadata for a New Dependency Property","nodes":[{"content":"Property Metadata for a New Dependency Property","pos":[0,47]}]},{"content":"When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.","pos":[17067,17216]},{"content":"Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>.","pos":[17217,17387],"source":" Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>."},{"content":"Other signatures of <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> allow you to specify the metadata that you want as you register the property.","pos":[17388,17538],"source":" Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property."},{"content":"The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.","pos":[17539,17683]},{"content":"If you are creating a dependency property that exists on a derived class of <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, you can use the more specialized metadata class <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> rather than the base <ph id=\"ph3\">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> class.","pos":[17690,17968],"source":"If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class."},{"content":"The constructor for the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> class has several signatures where you can specify various metadata characteristics in combination.","pos":[17969,18140],"source":" The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination."},{"content":"If you want to specify the default value only, use the signature that takes a single parameter of type <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","pos":[18141,18265],"source":" If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>."},{"content":"Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the <ph id=\"ph1\">`propertyType`</ph> parameter in the <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call).","pos":[18266,18500],"source":" Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call)."},{"content":"For <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, you can also specify metadata option flags for your property.","pos":[18507,18621],"source":"For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property."},{"content":"These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.","pos":[18622,18811]},{"pos":[18822,18856],"content":"Setting Appropriate Metadata Flags","linkify":"Setting Appropriate Metadata Flags","nodes":[{"content":"Setting Appropriate Metadata Flags","pos":[0,34]}]},{"pos":[18866,19289],"content":"If your property (or changes in its value) affects the <ph id=\"ph1\">[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]</ph>, and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>.","source":"If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions>, <xref:System.Windows.FrameworkPropertyMetadataOptions>, <xref:System.Windows.FrameworkPropertyMetadataOptions>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> indicates that a change to this property requires a change to <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> rendering where the containing object might require more or less space within the parent.","pos":[19303,19577],"source":"<xref:System.Windows.FrameworkPropertyMetadataOptions> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent."},{"content":"For example, a \"Width\" property should have this flag set.","pos":[19578,19636]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> indicates that a change to this property requires a change to <ph id=\"ph2\">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</ph> rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.","pos":[19650,19978],"source":"<xref:System.Windows.FrameworkPropertyMetadataOptions> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed."},{"content":"For example, an \"Alignment\" property should have this flag set.","pos":[19979,20042]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> indicates that some other change has occurred that will not affect layout and measure, but does require another render.","pos":[20056,20230],"source":"<xref:System.Windows.FrameworkPropertyMetadataOptions> indicates that some other change has occurred that will not affect layout and measure, but does require another render."},{"content":"An example would be a property that changes a color of an existing element, such as \"Background\".","pos":[20231,20328]},{"content":"These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.","pos":[20342,20472]},{"content":"For instance, you might have an <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> callback that will call <ph id=\"ph2\">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph> if any property of the instance reports a value change and has <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> as <ph id=\"ph4\">`true`</ph> in its metadata.","pos":[20473,20797],"source":" For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata."},{"content":"Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.","pos":[20807,20968]},{"content":"An example is the <ph id=\"ph1\">&lt;xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A&gt;</ph> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.","pos":[20969,21202],"source":" An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph."},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> to identify similar cases in your own properties.","pos":[21203,21369],"source":" Use <xref:System.Windows.FrameworkPropertyMetadataOptions> or <xref:System.Windows.FrameworkPropertyMetadataOptions> to identify similar cases in your own properties."},{"content":"By default, dependency properties support data binding.","pos":[21379,21434]},{"content":"You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.","pos":[21435,21626]},{"content":"By default, data binding <ph id=\"ph1\">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> for dependency properties defaults to <ph id=\"ph2\">&lt;xref:System.Windows.Data.BindingMode&gt;</ph>.","pos":[21636,21781],"source":"By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode>."},{"content":"You can always change the binding to be <ph id=\"ph1\">&lt;xref:System.Windows.Data.BindingMode&gt;</ph> per binding instance; for details, see <bpt id=\"p1\">[</bpt>Specify the Direction of the Binding<ept id=\"p1\">](../../../../docs/framework/wpf/data/how-to-specify-the-direction-of-the-binding.md)</ept>.","pos":[21782,22023],"source":" You can always change the binding to be <xref:System.Windows.Data.BindingMode> per binding instance; for details, see [Specify the Direction of the Binding](../../../../docs/framework/wpf/data/how-to-specify-the-direction-of-the-binding.md)."},{"content":"But as the dependency property author, you can choose to make the property use <ph id=\"ph1\">&lt;xref:System.Windows.Data.BindingMode&gt;</ph> binding mode by default.","pos":[22024,22166],"source":" But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode> binding mode by default."},{"content":"An example of an existing dependency property is <ph id=\"ph1\">&lt;xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=fullName&gt;</ph>; the scenario for this property is that the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A&gt;</ph> setting logic and the compositing of <ph id=\"ph3\">&lt;xref:System.Windows.Controls.MenuItem&gt;</ph> interact with the default theme style.","pos":[22167,22514],"source":" An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=fullName>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A&gt;</ph> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.","pos":[22515,22713],"source":" The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls."},{"content":"Another example property that binds <ph id=\"ph1\">&lt;xref:System.Windows.Data.BindingMode&gt;</ph> by default is <ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName&gt;</ph>.","pos":[22714,22875],"source":" Another example property that binds <xref:System.Windows.Data.BindingMode> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName>."},{"content":"You can also enable property inheritance in a custom dependency property by setting the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag.","pos":[22885,23033],"source":"You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions> flag."},{"content":"Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.","pos":[23034,23272]},{"content":"An example inheritable property is <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph>, which is used for binding operations to enable the important master-detail scenario for data presentation.","pos":[23273,23469],"source":" An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation."},{"content":"By making <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> inheritable, any child elements inherit that data context also.","pos":[23470,23597],"source":" By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also."},{"content":"Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.","pos":[23598,23777]},{"content":"<ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see <bpt id=\"p1\">[</bpt>Use the Master-Detail Pattern with Hierarchical Data<ept id=\"p1\">](../../../../docs/framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)</ept>.","pos":[23778,24153],"source":" <xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../../../../docs/framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)."},{"content":"Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see <bpt id=\"p1\">[</bpt>Property Value Inheritance<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.","pos":[24154,24372],"source":" Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)."},{"content":"Set the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag to indicate if your dependency property should be detected or used by navigation journaling services.","pos":[24382,24551],"source":"Set the <xref:System.Windows.FrameworkPropertyMetadataOptions> flag to indicate if your dependency property should be detected or used by navigation journaling services."},{"content":"An example is the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A&gt;</ph> property; any item selected in a selection control should be persisted when the journaling history is navigated.","pos":[24552,24750],"source":" An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated."},{"pos":[24782,24813],"content":"Read-Only Dependency Properties","linkify":"Read-Only Dependency Properties","nodes":[{"content":"Read-Only Dependency Properties","pos":[0,31]}]},{"content":"You can define a dependency property that is read-only.","pos":[24817,24872]},{"content":"However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.","pos":[24873,25066]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Read-Only Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.","pos":[25067,25203],"source":" For more information, see [Read-Only Dependency Properties](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md)."},{"pos":[25235,25272],"content":"Collection-Type Dependency Properties","linkify":"Collection-Type Dependency Properties","nodes":[{"content":"Collection-Type Dependency Properties","pos":[0,37]}]},{"content":"Collection-type dependency properties have some additional implementation issues to consider.","pos":[25276,25369]},{"content":"For details, see <bpt id=\"p1\">[</bpt>Collection-Type Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md)</ept>.","pos":[25370,25509],"source":" For details, see [Collection-Type Dependency Properties](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md)."},{"pos":[25546,25589],"content":"Dependency Property Security Considerations","linkify":"Dependency Property Security Considerations","nodes":[{"content":"Dependency Property Security Considerations","pos":[0,43]}]},{"content":"Dependency properties should be declared as public properties.","pos":[25593,25655]},{"content":"Dependency property identifier fields should be declared as public static fields.","pos":[25656,25737]},{"content":"Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system <ph id=\"ph1\">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph>.","pos":[25738,26006],"source":" Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]."},{"content":"Even a protected identifier field is potentially accessible because of metadata reporting or value determination <ph id=\"ph1\">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph> that are part of the property system, such as <ph id=\"ph2\">&lt;xref:System.Windows.LocalValueEnumerator&gt;</ph>.","pos":[26007,26297],"source":" Even a protected identifier field is potentially accessible because of metadata reporting or value determination [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Dependency Property Security<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-security.md)</ept>.","pos":[26298,26428],"source":" For more information, see [Dependency Property Security](../../../../docs/framework/wpf/advanced/dependency-property-security.md)."},{"pos":[26462,26506],"content":"Dependency Properties and Class Constructors","linkify":"Dependency Properties and Class Constructors","nodes":[{"content":"Dependency Properties and Class Constructors","pos":[0,44]}]},{"content":"There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.","pos":[26510,26677]},{"content":"This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.","pos":[26678,26923]},{"content":"When you derive from any class that already derives from <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph>, you should be aware that the property system itself calls and exposes virtual methods internally.","pos":[26924,27118],"source":" When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally."},{"content":"These virtual methods are part of the <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system services.","pos":[27119,27264],"source":" These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services."},{"content":"Overriding the methods enables derived classes to participate in value determination.","pos":[27265,27350]},{"content":"To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.","pos":[27351,27538]},{"content":"For details, see <bpt id=\"p1\">[</bpt>Safe Constructor Patterns for DependencyObjects<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)</ept>.","pos":[27539,27698],"source":" For details, see [Safe Constructor Patterns for DependencyObjects](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)."},{"pos":[27707,27715],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<bpt id=\"p1\">[</bpt>Dependency Properties Overview<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept><ph id=\"ph1\"> </ph>","pos":[27719,27827],"source":"[Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) "},{"content":"<bpt id=\"p1\">[</bpt>Dependency Property Metadata<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)</ept><ph id=\"ph1\"> </ph>","pos":[27831,27935],"source":"[Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) "},{"content":"<bpt id=\"p1\">[</bpt>Control Authoring Overview<ept id=\"p1\">](../../../../docs/framework/wpf/controls/control-authoring-overview.md)</ept><ph id=\"ph1\"> </ph>","pos":[27939,28039],"source":"[Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md) "},{"content":"<bpt id=\"p1\">[</bpt>Collection-Type Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md)</ept><ph id=\"ph1\"> </ph>","pos":[28043,28165],"source":"[Collection-Type Dependency Properties](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md) "},{"content":"<bpt id=\"p1\">[</bpt>Dependency Property Security<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/dependency-property-security.md)</ept><ph id=\"ph1\"> </ph>","pos":[28169,28273],"source":"[Dependency Property Security](../../../../docs/framework/wpf/advanced/dependency-property-security.md) "},{"content":"<bpt id=\"p1\">[</bpt>XAML Loading and Dependency Properties<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)</ept><ph id=\"ph1\"> </ph>","pos":[28277,28401],"source":"[XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md) "},{"content":"<bpt id=\"p1\">[</bpt>Safe Constructor Patterns for DependencyObjects<ept id=\"p1\">](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)</ept>","pos":[28405,28546],"source":"[Safe Constructor Patterns for DependencyObjects](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)"}]}