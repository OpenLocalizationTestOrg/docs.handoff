{"content":"---\ntitle: \"Trees in WPF\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"logical tree [WPF]\"\n  - \"element tree [WPF]\"\n  - \"visual tree [WPF]\"\nms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649\n---\n# Trees in WPF\nIn many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] also uses several tree structure metaphors to define relationships between program elements. For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM. WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>. The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features. This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.  \n\n<a name=\"element_tree\"></a>   \n## Trees in WPF  \n The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree. If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup. If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree. The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.  \n  \n Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology. Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  \n  \n> [!NOTE]\n>  Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph. In practice, there are relationships between objects at run time where the tree metaphor will break down. Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.  \n  \n<a name=\"logical_tree\"></a>   \n## The Logical Tree  \n In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements. For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property. By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value. Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value. Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>. For a code example, see [How to: Add an Element Dynamically](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  \n  \n In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.  \n  \n [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  \n  \n If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items. But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`. It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed. Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`. This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.  \n  \n However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates. For example, consider the <xref:System.Windows.Controls.Button>. The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`. But there is more to this button in the run-time object tree. In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied. The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree). To find the template visuals, you would instead need to examine the visual tree.  \n  \n For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](xaml-syntax-in-detail.md) or [XAML Overview (WPF)](xaml-overview-wpf.md).  \n  \n<a name=\"tree_property_inheritance_event_routing\"></a>   \n### The Purpose of the Logical Tree  \n The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible. Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded. Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.  \n  \n In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key. The logical tree is used for resource lookup when both the logical tree and the visual tree are present. For more information on resource dictionaries and lookup, see [XAML Resources](xaml-resources.md).  \n  \n<a name=\"composition\"></a>   \n### Composition of the Logical Tree  \n The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>. However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>. For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.  \n  \n<a name=\"override_logical_tree\"></a>   \n### Overriding the Logical Tree  \n Advanced control authors can override the logical tree by overriding several [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that define how a general object or content model adds or removes objects within the logical tree. For an example of how to override the logical tree, see [Override the Logical Tree](how-to-override-the-logical-tree.md).  \n  \n<a name=\"pvi\"></a>   \n### Property Value Inheritance  \n Property value inheritance operates through a hybrid tree. The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class. Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree. However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree. Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree. In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior. The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time. For more information, see [Property Value Inheritance](property-value-inheritance.md).  \n  \n<a name=\"two_trees\"></a>   \n## The Visual Tree  \n In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class. When you write a template for a control, you are defining or redefining the visual tree that applies for that control. The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons. One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree. This subtlety of routed event behavior might not be immediately apparent unless you are a control author. Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.  \n  \n<a name=\"trees_content\"></a>   \n## Trees, Content Elements, and Content Hosts  \n Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation. In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant. Usually such an object is a <xref:System.Windows.FrameworkElement>. You can conceptualize that the content host is somewhat like a \"browser\" for the content and chooses how to display that content within the screen region that the host controls. When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree. Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree. This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.  \n  \n<a name=\"tree_traversal\"></a>   \n## Tree Traversal  \n The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal. In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on. Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.  \n  \n The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>. The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario. For more information, see [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md).  \n  \n> [!NOTE]\n>  Sometimes it is necessary to examine the visual tree of an applied template. You should be careful when using this technique. Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.  \n  \n<a name=\"routes\"></a>   \n## Routes for Routed Events as a \"Tree\"  \n As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations. The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event. The event route concept does not have a directly supporting helper class that could be used to \"walk\" the event route independently of raising an event that actually routes. There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.  \n  \n<a name=\"resourcesandtrees\"></a>   \n## Resource Dictionaries and Trees  \n Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree. Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree. In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.  \n  \n However, resource lookup can also extend beyond the immediate logical tree. For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys. Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic. For more information on resource dictionaries and the lookup logic, see [XAML Resources](xaml-resources.md).  \n  \n## See also\n\n- [Input Overview](input-overview.md)\n- [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md)\n- [Routed Events Overview](routed-events-overview.md)\n- [Initialization for Object Elements Not in an Object Tree](initialization-for-object-elements-not-in-an-object-tree.md)\n- [WPF Architecture](wpf-architecture.md)\n","nodes":[{"pos":[4,192],"embed":true,"restype":"x-metadata","content":"title: \"Trees in WPF\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"logical tree [WPF]\"\n  - \"element tree [WPF]\"\n  - \"visual tree [WPF]\"\nms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649","nodes":[{"content":"Trees in WPF","nodes":[{"pos":[0,12],"content":"Trees in WPF","nodes":[{"content":"Trees in WPF","pos":[0,12]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[199,211],"content":"Trees in WPF","linkify":"Trees in WPF","nodes":[{"content":"Trees in WPF","pos":[0,12]}]},{"content":"In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.","pos":[212,412]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> also uses several tree structure metaphors to define relationships between program elements.","pos":[413,585],"source":"[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] also uses several tree structure metaphors to define relationships between program elements."},{"content":"For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.","pos":[586,913]},{"content":"WPF exposes two helper classes that provide a tree metaphor view, <ph id=\"ph1\">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>.","pos":[914,1069],"source":" WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>."},{"content":"The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.","pos":[1070,1243]},{"content":"This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <ph id=\"ph1\">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>s.","pos":[1244,1484],"source":" This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s."},{"pos":[1522,1534],"content":"Trees in WPF","linkify":"Trees in WPF","nodes":[{"content":"Trees in WPF","pos":[0,12]}]},{"content":"The most complete tree structure in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> is the object tree.","pos":[1538,1675],"source":"The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree."},{"content":"If you define an application page in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> and then load the <ph id=\"ph2\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph>, the tree structure is created based on the nesting relationships of the elements in the markup.","pos":[1676,1971],"source":" If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup."},{"content":"If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.","pos":[1972,2184]},{"content":"In <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph>, there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.","pos":[2185,2418],"source":" In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree."},{"content":"The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> subsystems and affect choices you make in markup or code.","pos":[2419,2702],"source":" The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code."},{"content":"Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.","pos":[2709,2904]},{"content":"Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[2905,3119],"source":" Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"pos":[3127,3550],"content":"[!NOTE]\n Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph. In practice, there are relationships between objects at run time where the tree metaphor will break down. Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.","leadings":["","> "],"nodes":[{"content":"Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph. In practice, there are relationships between objects at run time where the tree metaphor will break down. Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.","pos":[9,421],"nodes":[{"content":"Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.","pos":[0,123]},{"content":"In practice, there are relationships between objects at run time where the tree metaphor will break down.","pos":[124,229]},{"content":"Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.","pos":[230,412]}]}]},{"pos":[3590,3606],"content":"The Logical Tree","linkify":"The Logical Tree","nodes":[{"content":"The Logical Tree","pos":[0,16]}]},{"content":"In <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, you add content to UI elements by setting properties of the objects that back those elements.","pos":[3610,3789],"source":"In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements."},{"content":"For example, you add items to a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> control by manipulating its <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> property.","pos":[3790,3951],"source":" For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property."},{"content":"By doing this, you are placing items into the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ItemCollection&gt;</ph> that is the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> property value.","pos":[3952,4124],"source":" By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value."},{"content":"Similarly, to add objects to a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph>, you manipulate its <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Panel.Children%2A&gt;</ph> property value.","pos":[4125,4281],"source":" Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value."},{"content":"Here, you are adding objects to the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.UIElementCollection&gt;</ph>.","pos":[4282,4369],"source":" Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>."},{"content":"For a code example, see <bpt id=\"p1\">[</bpt>How to: Add an Element Dynamically<ept id=\"p1\">](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))</ept>.","pos":[4370,4520],"source":" For a code example, see [How to: Add an Element Dynamically](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))."},{"pos":[4527,4947],"content":"In <ph id=\"ph1\">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph>, when you place list items in a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> or controls or other UI elements in a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.DockPanel&gt;</ph>, you also use the <ph id=\"ph4\">&lt;xref:System.Windows.Controls.ItemsControl.Items%2A&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Windows.Controls.Panel.Children%2A&gt;</ph> properties, either explicitly or implicitly, as in the following example.","source":"In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example."},{"content":"If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for <ph id=\"ph1\">`&lt;ListBox.Items&gt;`</ph> and the other implicit items.","pos":[5079,5352],"source":"If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items."},{"content":"But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include <ph id=\"ph1\">`ListBox.Items`</ph>.","pos":[5353,5505],"source":" But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`."},{"content":"It does however have a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> property named <ph id=\"ph2\">`Items`</ph> that contains a <ph id=\"ph3\">&lt;xref:System.Windows.Controls.ItemCollection&gt;</ph>, and that <ph id=\"ph4\">&lt;xref:System.Windows.Controls.ItemCollection&gt;</ph> is initialized but empty when the <ph id=\"ph5\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> XAML is processed.","pos":[5506,5800],"source":" It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed."},{"content":"Then, each child object element that exists as content for the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> is added to the <ph id=\"ph2\">&lt;xref:System.Windows.Controls.ItemCollection&gt;</ph> by parser calls to <ph id=\"ph3\">`ItemCollection.Add`</ph>.","pos":[5801,6005],"source":" Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`."},{"content":"This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.","pos":[6006,6149]},{"content":"However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.","pos":[6156,6367]},{"content":"For example, consider the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph>.","pos":[6368,6432],"source":" For example, consider the <xref:System.Windows.Controls.Button>."},{"content":"The logical tree reports the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> object and also its string <ph id=\"ph2\">`Content`</ph>.","pos":[6433,6537],"source":" The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`."},{"content":"But there is more to this button in the run-time object tree.","pos":[6538,6599]},{"content":"In particular, the button only appears on screen the way it does because a specific <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control template was applied.","pos":[6600,6751],"source":" In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied."},{"content":"The visuals that come from an applied template (such as the template-defined <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Border&gt;</ph> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).","pos":[6752,7092],"source":" The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree)."},{"content":"To find the template visuals, you would instead need to examine the visual tree.","pos":[7093,7173]},{"pos":[7180,7454],"content":"For more information about how <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> syntax maps to the created object graph, and implicit syntax in XAML, see <bpt id=\"p1\">[</bpt>XAML Syntax In Detail<ept id=\"p1\">](xaml-syntax-in-detail.md)</ept> or <bpt id=\"p2\">[</bpt>XAML Overview (WPF)<ept id=\"p2\">](xaml-overview-wpf.md)</ept>.","source":"For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](xaml-syntax-in-detail.md) or [XAML Overview (WPF)](xaml-overview-wpf.md)."},{"pos":[7522,7553],"content":"The Purpose of the Logical Tree","linkify":"The Purpose of the Logical Tree","nodes":[{"content":"The Purpose of the Logical Tree","pos":[0,31]}]},{"content":"The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.","pos":[7557,7704]},{"content":"Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.","pos":[7705,7832]},{"content":"Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.","pos":[7833,8053]},{"content":"In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement.Resources%2A&gt;</ph> collections on the initial requesting object, and then continuing up the logical tree and checking each <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> (or <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>) for another <ph id=\"ph4\">`Resources`</ph> value that contains a <ph id=\"ph5\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>, possibly containing that key.","pos":[8060,8541],"source":"In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key."},{"content":"The logical tree is used for resource lookup when both the logical tree and the visual tree are present.","pos":[8542,8646]},{"content":"For more information on resource dictionaries and lookup, see <bpt id=\"p1\">[</bpt>XAML Resources<ept id=\"p1\">](xaml-resources.md)</ept>.","pos":[8647,8745],"source":" For more information on resource dictionaries and lookup, see [XAML Resources](xaml-resources.md)."},{"pos":[8785,8816],"content":"Composition of the Logical Tree","linkify":"Composition of the Logical Tree","nodes":[{"content":"Composition of the Logical Tree","pos":[0,31]}]},{"content":"The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.","pos":[8820,9062],"source":"The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>."},{"content":"However, as you can see if you actually use the <ph id=\"ph1\">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> API, the logical tree sometimes contains nodes that are not either <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.","pos":[9063,9306],"source":" However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>."},{"content":"For instance, the logical tree reports the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.TextBlock.Text%2A&gt;</ph> value of a <ph id=\"ph2\">&lt;xref:System.Windows.Controls.TextBlock&gt;</ph>, which is a string.","pos":[9307,9470],"source":" For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string."},{"pos":[9520,9547],"content":"Overriding the Logical Tree","linkify":"Overriding the Logical Tree","nodes":[{"content":"Overriding the Logical Tree","pos":[0,27]}]},{"content":"Advanced control authors can override the logical tree by overriding several <ph id=\"ph1\">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph> that define how a general object or content model adds or removes objects within the logical tree.","pos":[9551,9814],"source":"Advanced control authors can override the logical tree by overriding several [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that define how a general object or content model adds or removes objects within the logical tree."},{"content":"For an example of how to override the logical tree, see <bpt id=\"p1\">[</bpt>Override the Logical Tree<ept id=\"p1\">](how-to-override-the-logical-tree.md)</ept>.","pos":[9815,9936],"source":" For an example of how to override the logical tree, see [Override the Logical Tree](how-to-override-the-logical-tree.md)."},{"pos":[9968,9994],"content":"Property Value Inheritance","linkify":"Property Value Inheritance","nodes":[{"content":"Property Value Inheritance","pos":[0,26]}]},{"content":"Property value inheritance operates through a hybrid tree.","pos":[9998,10056]},{"content":"The actual metadata that contains the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> property that enables property inheritance is the WPF framework-level <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> class.","pos":[10057,10279],"source":" The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class."},{"content":"Therefore, both the parent that holds the original value and the child object that inherits that value must both be <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, and they must both be part of some logical tree.","pos":[10280,10533],"source":" Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree."},{"content":"However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.","pos":[10534,10717]},{"content":"Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.","pos":[10718,10944]},{"content":"In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.","pos":[10945,11221]},{"content":"The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.","pos":[11222,11349]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Property Value Inheritance<ept id=\"p1\">](property-value-inheritance.md)</ept>.","pos":[11350,11436],"source":" For more information, see [Property Value Inheritance](property-value-inheritance.md)."},{"pos":[11473,11488],"content":"The Visual Tree","linkify":"The Visual Tree","nodes":[{"content":"The Visual Tree","pos":[0,15]}]},{"content":"In addition to the concept of the logical tree, there is also the concept of the visual tree in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>.","pos":[11492,11670],"source":"In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]."},{"content":"The visual tree describes the structure of visual objects, as represented by the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Visual&gt;</ph> base class.","pos":[11671,11798],"source":" The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class."},{"content":"When you write a template for a control, you are defining or redefining the visual tree that applies for that control.","pos":[11799,11917]},{"content":"The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.","pos":[11918,12051]},{"content":"One exposure of the visual tree as part of conventional <ph id=\"ph1\">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.","pos":[12052,12312],"source":" One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree."},{"content":"This subtlety of routed event behavior might not be immediately apparent unless you are a control author.","pos":[12313,12418]},{"content":"Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.","pos":[12419,12563]},{"pos":[12604,12646],"content":"Trees, Content Elements, and Content Hosts","linkify":"Trees, Content Elements, and Content Hosts","nodes":[{"content":"Trees, Content Elements, and Content Hosts","pos":[0,42]}]},{"content":"Content elements (classes that derive from <ph id=\"ph1\">&lt;xref:System.Windows.ContentElement&gt;</ph>) are not part of the visual tree; they do not inherit from <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> and do not have a visual representation.","pos":[12650,12864],"source":"Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation."},{"content":"In order to appear in a UI at all, a <ph id=\"ph1\">&lt;xref:System.Windows.ContentElement&gt;</ph> must be hosted in a content host that is both a <ph id=\"ph2\">&lt;xref:System.Windows.Media.Visual&gt;</ph> and a logical tree participant.","pos":[12865,13053],"source":" In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant."},{"content":"Usually such an object is a <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.","pos":[13054,13121],"source":" Usually such an object is a <xref:System.Windows.FrameworkElement>."},{"content":"You can conceptualize that the content host is somewhat like a \"browser\" for the content and chooses how to display that content within the screen region that the host controls.","pos":[13122,13299]},{"content":"When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.","pos":[13300,13442]},{"content":"Generally, the <ph id=\"ph1\">&lt;xref:System.Windows.FrameworkElement&gt;</ph> host class includes implementation code that adds any hosted <ph id=\"ph2\">&lt;xref:System.Windows.ContentElement&gt;</ph> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.","pos":[13443,13727],"source":" Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree."},{"content":"This is necessary so that a <ph id=\"ph1\">&lt;xref:System.Windows.ContentElement&gt;</ph> can source a routed event that routes to any element other than itself.","pos":[13728,13864],"source":" This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself."},{"pos":[13906,13920],"content":"Tree Traversal","linkify":"Tree Traversal","nodes":[{"content":"Tree Traversal","pos":[0,14]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph> class provides the <ph id=\"ph2\">&lt;xref:System.Windows.LogicalTreeHelper.GetChildren%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Windows.LogicalTreeHelper.GetParent%2A&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> methods for logical tree traversal.","pos":[13924,14195],"source":"The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal."},{"content":"In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as <ph id=\"ph1\">`Add`</ph>, an indexer, and so on.","pos":[14196,14459],"source":" In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on."},{"content":"Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Windows.Controls.Panel&gt;</ph> where collection properties are already defined, and who intend to provide their own collection property support.","pos":[14460,14789],"source":" Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support."},{"content":"The visual tree also supports a helper class for visual tree traversal, <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>.","pos":[14796,14913],"source":"The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>."},{"content":"The visual tree is not exposed as conveniently through control-specific properties, so the <ph id=\"ph1\">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.","pos":[14914,15158],"source":" The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>WPF Graphics Rendering Overview<ept id=\"p1\">](../graphics-multimedia/wpf-graphics-rendering-overview.md)</ept>.","pos":[15159,15278],"source":" For more information, see [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md)."},{"pos":[15286,15741],"content":"[!NOTE]\n Sometimes it is necessary to examine the visual tree of an applied template. You should be careful when using this technique. Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.","leadings":["","> "],"nodes":[{"content":"Sometimes it is necessary to examine the visual tree of an applied template. You should be careful when using this technique. Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.","pos":[9,453],"nodes":[{"content":"Sometimes it is necessary to examine the visual tree of an applied template.","pos":[0,76]},{"content":"You should be careful when using this technique.","pos":[77,125]},{"content":"Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Control.Template%2A&gt;</ph> property on instances, and even the end user can influence the applied template by changing the system theme.","pos":[126,444],"source":" Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme."}]}]},{"pos":[15775,15811],"content":"Routes for Routed Events as a \"Tree\"","linkify":"Routes for Routed Events as a \"Tree\"","nodes":[{"content":"Routes for Routed Events as a \"Tree\"","pos":[0,36]}]},{"content":"As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.","pos":[15815,15992]},{"content":"The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.","pos":[15993,16136]},{"content":"The event route concept does not have a directly supporting helper class that could be used to \"walk\" the event route independently of raising an event that actually routes.","pos":[16137,16310]},{"content":"There is a class that represents the route, <ph id=\"ph1\">&lt;xref:System.Windows.EventRoute&gt;</ph>, but the methods of that class are generally for internal use only.","pos":[16311,16455],"source":" There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only."},{"pos":[16500,16531],"content":"Resource Dictionaries and Trees","linkify":"Resource Dictionaries and Trees","nodes":[{"content":"Resource Dictionaries and Trees","pos":[0,31]}]},{"content":"Resource dictionary lookup for all <ph id=\"ph1\">`Resources`</ph> defined in a page traverses basically the logical tree.","pos":[16535,16637],"source":"Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree."},{"content":"Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.","pos":[16638,16814]},{"content":"In WPF, only logical tree nodes can have a <ph id=\"ph1\">`Resources`</ph> property that contains a <ph id=\"ph2\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <ph id=\"ph3\">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.","pos":[16815,17073],"source":" In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>."},{"content":"However, resource lookup can also extend beyond the immediate logical tree.","pos":[17080,17155]},{"content":"For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.","pos":[17156,17361]},{"content":"Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.","pos":[17362,17486]},{"content":"For more information on resource dictionaries and the lookup logic, see <bpt id=\"p1\">[</bpt>XAML Resources<ept id=\"p1\">](xaml-resources.md)</ept>.","pos":[17487,17595],"source":" For more information on resource dictionaries and the lookup logic, see [XAML Resources](xaml-resources.md)."},{"pos":[17604,17612],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[17616,17651],"content":"<bpt id=\"p1\">[</bpt>Input Overview<ept id=\"p1\">](input-overview.md)</ept>","source":"[Input Overview](input-overview.md)"},{"pos":[17654,17746],"content":"<bpt id=\"p1\">[</bpt>WPF Graphics Rendering Overview<ept id=\"p1\">](../graphics-multimedia/wpf-graphics-rendering-overview.md)</ept>","source":"[WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md)"},{"pos":[17749,17800],"content":"<bpt id=\"p1\">[</bpt>Routed Events Overview<ept id=\"p1\">](routed-events-overview.md)</ept>","source":"[Routed Events Overview](routed-events-overview.md)"},{"pos":[17803,17922],"content":"<bpt id=\"p1\">[</bpt>Initialization for Object Elements Not in an Object Tree<ept id=\"p1\">](initialization-for-object-elements-not-in-an-object-tree.md)</ept>","source":"[Initialization for Object Elements Not in an Object Tree](initialization-for-object-elements-not-in-an-object-tree.md)"},{"pos":[17925,17964],"content":"<bpt id=\"p1\">[</bpt>WPF Architecture<ept id=\"p1\">](wpf-architecture.md)</ept>","source":"[WPF Architecture](wpf-architecture.md)"}]}