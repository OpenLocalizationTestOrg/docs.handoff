{"content":"---\ntitle: \"WPF and Direct3D9 Interoperation\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"cpp\"\nhelpviewer_keywords: \n  - \"WPF [WPF], creating Direct3D9 content\"\n  - \"Direct3D9 [WPF interoperability], creating Direct3D9 content\"\nms.assetid: 1b14b823-69c4-4e8d-99e4-f6dade58f89a\n---\n# WPF and Direct3D9 Interoperation\nYou can include Direct3D9 content in a Windows Presentation Foundation (WPF) application. This topic describes how to create Direct3D9 content so that it efficiently interoperates with WPF.  \n  \n> [!NOTE]\n>  When using Direct3D9 content in WPF, you also need to think about performance. For more information about how to optimize for performance, see [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md).  \n  \n## Display Buffers  \n The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*. The back buffer is your Direct3D9 surface. Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method.  \n  \n The following illustration shows the relationship between the back buffer and the front buffer.  \n  \n ![D3DImage display buffers](./media/d3dimage-buffers.png \"D3DImage_buffers\")  \n  \n## Direct3D9 Device Creation  \n To render Direct3D9 content, you must create a Direct3D9 device. There are two Direct3D9 objects that you can use to create a device, `IDirect3D9` and `IDirect3D9Ex`. Use these objects to create `IDirect3DDevice9` and `IDirect3DDevice9Ex` devices, respectively.  \n  \n Create a device by calling one of the following methods.  \n  \n-   `IDirect3D9 * Direct3DCreate9(UINT SDKVersion);`  \n  \n-   `HRESULT Direct3DCreate9Ex(UINT SDKVersion, IDirect3D9Ex **ppD3D);`  \n  \n On Windows Vista or later operating system, use the `Direct3DCreate9Ex` method with a display that is configured to use the Windows Display Driver Model (WDDM). Use the `Direct3DCreate9` method on any other platform.  \n  \n### Availability of the Direct3DCreate9Ex method  \n The d3d9.dll has the `Direct3DCreate9Ex` method only on Windows Vista or later operating system. If you directly link the function on Windows XP, your application fails to load. To determine whether the `Direct3DCreate9Ex` method is supported, load the DLL and look for the proc address. The following code shows how to test for the `Direct3DCreate9Ex` method. For a full code example, see [Walkthrough: Creating Direct3D9 Content for Hosting in WPF](walkthrough-creating-direct3d9-content-for-hosting-in-wpf.md).  \n  \n [!code-cpp[System.Windows.Interop.D3DImage#RendererManager_EnsureD3DObjects](~/samples/snippets/cpp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/cpp/renderermanager.cpp#renderermanager_ensured3dobjects)]  \n  \n### HWND Creation  \n Creating a device requires an HWND. In general, you create a dummy HWND for Direct3D9 to use. The following code example shows how to create a dummy HWND.  \n  \n [!code-cpp[System.Windows.Interop.D3DImage#RendererManager_EnsureHWND](~/samples/snippets/cpp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/cpp/renderermanager.cpp#renderermanager_ensurehwnd)]  \n  \n### Present Parameters  \n Creating a device also requires a `D3DPRESENT_PARAMETERS` struct, but only a few parameters are important. These parameters are chosen to minimize the memory footprint.  \n  \n Set the `BackBufferHeight` and `BackBufferWidth` fields to 1. Setting them to 0 causes them to be set to the dimensions of the HWND.  \n  \n Always set the `D3DCREATE_MULTITHREADED` and `D3DCREATE_FPU_PRESERVE` flags to prevent corrupting memory used by Direct3D9 and to prevent Direct3D9 from changing FPU settings.  \n  \n The following code shows how to initialize the `D3DPRESENT_PARAMETERS` struct.  \n  \n [!code-cpp[System.Windows.Interop.D3DImage#Renderer_Init](~/samples/snippets/cpp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/cpp/renderer.cpp#renderer_init)]  \n  \n## Creating the Back Buffer Render Target  \n To display Direct3D9 content in a <xref:System.Windows.Interop.D3DImage>, you create a Direct3D9 surface and assign it by calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.  \n  \n### Verifying Adapter Support  \n Before creating a surface, verify that all adapters support the surface properties you require. Even if you render to only one adapter, the WPF window may be displayed on any adapter in the system. You should always write Direct3D9 code that handles multi-adapter configurations, and you should check all adapters for support, because WPF might move the surface among the available adapters.  \n  \n The following code example shows how to check all adapters on the system for Direct3D9 support.  \n  \n [!code-cpp[System.Windows.Interop.D3DImage#RendererManager_TestSurfaceSettings](~/samples/snippets/cpp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/cpp/renderermanager.cpp#renderermanager_testsurfacesettings)]  \n  \n### Creating the Surface  \n Before creating a surface, verify that the device capabilities support good performance on the target operating system. For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md).  \n  \n When you have verified device capabilities, you can create the surface. The following code example shows how to create the render target.  \n  \n [!code-cpp[System.Windows.Interop.D3DImage#Renderer_CreateSurface](~/samples/snippets/cpp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/cpp/renderer.cpp#renderer_createsurface)]  \n  \n### WDDM  \n On Windows Vista and later operating systems, which are configured to use the WDDM, you can create a render target texture and pass the level 0 surface to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method. This approach is not recommended on Windows XP, because you cannot create a lockable render target texture and performance will be reduced.  \n  \n## Handling Device State  \n The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*. The back buffer is your Direct3D surface.  Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware. Occasionally, the front buffer becomes unavailable. This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities. When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.  How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering. The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.  \n  \n When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed. When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface. To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  \n  \n When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.  \n  \n When software rendering is enabled, there may be situations where the user’s device becomes unavailable, but the rendering system retains a reference to the Direct3D surface. To check whether a Direct3D9 device is unavailable, call the `TestCooperativeLevel` method. To check a Direct3D9Ex devices call the `CheckDeviceState` method, because the `TestCooperativeLevel` method is deprecated and always returns success. If the user device has become unavailable, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer.  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.  \n  \n Call the `Reset` method to recover from an invalid device only if you implement multi-adapter support. Otherwise, release all Direct3D9 interfaces and re-create them completely. If the adapter layout has changed, Direct3D9 objects created before the change are not updated.  \n  \n## Handling Resizing  \n If a <xref:System.Windows.Interop.D3DImage> is displayed at a resolution other than its native size, it is scaled according to the current <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A>, except that <xref:System.Windows.Media.Effects.SamplingMode.Bilinear> is substituted for <xref:System.Windows.Media.BitmapScalingMode.Fant>.  \n  \n If you require higher fidelity, you must create a new surface when the container of the <xref:System.Windows.Interop.D3DImage> changes size.  \n  \n There are three possible approaches to handle resizing.  \n  \n-   Participate in the layout system and create a new surface when the size changes. Do not create too many surfaces, because you may exhaust or fragment video memory.  \n  \n-   Wait until a resize event has not occurred for a fixed period of time to create the new surface.  \n  \n-   Create a <xref:System.Windows.Threading.DispatcherTimer> that checks the container dimensions several times per second.  \n  \n## Multi-monitor Optimization  \n Significantly reduced performance can result when the rendering system moves a <xref:System.Windows.Interop.D3DImage> to another monitor.  \n  \n On WDDM, as long as the monitors are on the same video card and you use `Direct3DCreate9Ex`, there is no reduction in performance. If the monitors are on separate video cards, performance is reduced. On Windows XP, performance is always reduced.  \n  \n When the <xref:System.Windows.Interop.D3DImage> moves to another monitor, you can create a new surface on the corresponding adapter to restore good performance.  \n  \n To avoid the performance penalty, write code specifically for the multi-monitor case. The following list shows one way to write multi-monitor code.  \n  \n1.  Find a point of the <xref:System.Windows.Interop.D3DImage> in screen space with the `Visual.ProjectToScreen` method.  \n  \n2.  Use the `MonitorFromPoint` GDI method to find the monitor that is displaying the point.  \n  \n3.  Use the `IDirect3D9::GetAdapterMonitor` method to find which Direct3D9 adapter the monitor is on.  \n  \n4.  If the adapter is not the same as the adapter with the back buffer, create a new back buffer on the new monitor and assign it to the <xref:System.Windows.Interop.D3DImage> back buffer.  \n  \n> [!NOTE]\n>  If the <xref:System.Windows.Interop.D3DImage> straddles monitors, performance will be slow, except in the case of WDDM and `IDirect3D9Ex` on the same adapter. There is no way to improve performance in this situation.  \n  \n The following code example shows how to find the current monitor.  \n  \n [!code-cpp[System.Windows.Interop.D3DImage#RendererManager_SetAdapter](~/samples/snippets/cpp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/cpp/renderermanager.cpp#renderermanager_setadapter)]  \n  \n Update the monitor when the <xref:System.Windows.Interop.D3DImage> container's size or position changes, or update the monitor by using a `DispatcherTimer` that updates a few times per second.  \n  \n## WPF Software Rendering  \n WPF renders synchronously on the UI thread in software in the following situations.  \n  \n-   Printing  \n  \n-   <xref:System.Windows.Media.Effects.BitmapEffect>  \n  \n-   <xref:System.Windows.Media.Imaging.RenderTargetBitmap>  \n  \n When one of these situations occurs, the rendering system calls the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to copy the hardware buffer to software. The default implementation calls the `GetRenderTargetData` method with your surface. Because this call occurs outside of the Lock/Unlock pattern, it may fail. In this case, the `CopyBackBuffer` method returns `null` and no image is displayed.  \n  \n You can override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method, call the base implementation, and if it returns `null`, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource>.  \n  \n You can also implement your own software rendering instead of calling the base implementation.  \n  \n> [!NOTE]\n>  If WPF is rendering completely in software, <xref:System.Windows.Interop.D3DImage> is not shown because WPF does not have a front buffer.  \n  \n## See also\n\n- <xref:System.Windows.Interop.D3DImage>\n- [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md)\n- [Walkthrough: Creating Direct3D9 Content for Hosting in WPF](walkthrough-creating-direct3d9-content-for-hosting-in-wpf.md)\n- [Walkthrough: Hosting Direct3D9 Content in WPF](walkthrough-hosting-direct3d9-content-in-wpf.md)\n","nodes":[{"pos":[4,271],"embed":true,"restype":"x-metadata","content":"title: \"WPF and Direct3D9 Interoperation\"\nms.date: \"03/30/2017\"\ndev_langs: \n  - \"cpp\"\nhelpviewer_keywords: \n  - \"WPF [WPF], creating Direct3D9 content\"\n  - \"Direct3D9 [WPF interoperability], creating Direct3D9 content\"\nms.assetid: 1b14b823-69c4-4e8d-99e4-f6dade58f89a","nodes":[{"content":"WPF and Direct3D9 Interoperation","nodes":[{"pos":[0,32],"content":"WPF and Direct3D9 Interoperation","nodes":[{"content":"WPF and Direct3D9 Interoperation","pos":[0,32]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[278,310],"content":"WPF and Direct3D9 Interoperation","linkify":"WPF and Direct3D9 Interoperation","nodes":[{"content":"WPF and Direct3D9 Interoperation","pos":[0,32]}]},{"content":"You can include Direct3D9 content in a Windows Presentation Foundation (WPF) application.","pos":[311,400]},{"content":"This topic describes how to create Direct3D9 content so that it efficiently interoperates with WPF.","pos":[401,500]},{"pos":[508,800],"content":"[!NOTE]\n When using Direct3D9 content in WPF, you also need to think about performance. For more information about how to optimize for performance, see [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md).","leadings":["","> "],"nodes":[{"content":"When using Direct3D9 content in WPF, you also need to think about performance. For more information about how to optimize for performance, see [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md).","pos":[9,290],"nodes":[{"content":"When using Direct3D9 content in WPF, you also need to think about performance.","pos":[0,78]},{"content":"For more information about how to optimize for performance, see <bpt id=\"p1\">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id=\"p1\">](performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.","pos":[79,281],"source":" For more information about how to optimize for performance, see [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md)."}]}]},{"pos":[809,824],"content":"Display Buffers","linkify":"Display Buffers","nodes":[{"content":"Display Buffers","pos":[0,15]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class manages two display buffers, which are called the <bpt id=\"p1\">*</bpt>back buffer<ept id=\"p1\">*</ept> and the <bpt id=\"p2\">*</bpt>front buffer<ept id=\"p2\">*</ept>.","pos":[828,964],"source":"The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*."},{"content":"The back buffer is your Direct3D9 surface.","pos":[965,1007]},{"content":"Changes to the back buffer are copied forward to the front buffer when you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method.","pos":[1008,1148],"source":" Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method."},{"content":"The following illustration shows the relationship between the back buffer and the front buffer.","pos":[1155,1250]},{"pos":[1257,1333],"content":"<bpt id=\"p1\">![</bpt>D3DImage display buffers<ept id=\"p1\">]</ept><bpt id=\"p2\">(./media/d3dimage-buffers.png \"</bpt>D3DImage_buffers<ept id=\"p2\">\")</ept>","source":"![D3DImage display buffers](./media/d3dimage-buffers.png \"D3DImage_buffers\")"},{"pos":[1342,1367],"content":"Direct3D9 Device Creation","linkify":"Direct3D9 Device Creation","nodes":[{"content":"Direct3D9 Device Creation","pos":[0,25]}]},{"content":"To render Direct3D9 content, you must create a Direct3D9 device.","pos":[1371,1435]},{"content":"There are two Direct3D9 objects that you can use to create a device, <ph id=\"ph1\">`IDirect3D9`</ph> and <ph id=\"ph2\">`IDirect3D9Ex`</ph>.","pos":[1436,1537],"source":" There are two Direct3D9 objects that you can use to create a device, `IDirect3D9` and `IDirect3D9Ex`."},{"content":"Use these objects to create <ph id=\"ph1\">`IDirect3DDevice9`</ph> and <ph id=\"ph2\">`IDirect3DDevice9Ex`</ph> devices, respectively.","pos":[1538,1632],"source":" Use these objects to create `IDirect3DDevice9` and `IDirect3DDevice9Ex` devices, respectively."},{"content":"Create a device by calling one of the following methods.","pos":[1639,1695]},{"content":"On Windows Vista or later operating system, use the <ph id=\"ph1\">`Direct3DCreate9Ex`</ph> method with a display that is configured to use the Windows Display Driver Model (WDDM).","pos":[1837,1997],"source":"On Windows Vista or later operating system, use the `Direct3DCreate9Ex` method with a display that is configured to use the Windows Display Driver Model (WDDM)."},{"content":"Use the <ph id=\"ph1\">`Direct3DCreate9`</ph> method on any other platform.","pos":[1998,2053],"source":" Use the `Direct3DCreate9` method on any other platform."},{"pos":[2063,2107],"content":"Availability of the Direct3DCreate9Ex method","linkify":"Availability of the Direct3DCreate9Ex method","nodes":[{"content":"Availability of the Direct3DCreate9Ex method","pos":[0,44]}]},{"content":"The d3d9.dll has the <ph id=\"ph1\">`Direct3DCreate9Ex`</ph> method only on Windows Vista or later operating system.","pos":[2111,2207],"source":"The d3d9.dll has the `Direct3DCreate9Ex` method only on Windows Vista or later operating system."},{"content":"If you directly link the function on Windows XP, your application fails to load.","pos":[2208,2288]},{"content":"To determine whether the <ph id=\"ph1\">`Direct3DCreate9Ex`</ph> method is supported, load the DLL and look for the proc address.","pos":[2289,2398],"source":" To determine whether the `Direct3DCreate9Ex` method is supported, load the DLL and look for the proc address."},{"content":"The following code shows how to test for the <ph id=\"ph1\">`Direct3DCreate9Ex`</ph> method.","pos":[2399,2471],"source":" The following code shows how to test for the `Direct3DCreate9Ex` method."},{"content":"For a full code example, see <bpt id=\"p1\">[</bpt>Walkthrough: Creating Direct3D9 Content for Hosting in WPF<ept id=\"p1\">](walkthrough-creating-direct3d9-content-for-hosting-in-wpf.md)</ept>.","pos":[2472,2624],"source":" For a full code example, see [Walkthrough: Creating Direct3D9 Content for Hosting in WPF](walkthrough-creating-direct3d9-content-for-hosting-in-wpf.md)."},{"pos":[2847,2860],"content":"HWND Creation","linkify":"HWND Creation","nodes":[{"content":"HWND Creation","pos":[0,13]}]},{"content":"Creating a device requires an HWND.","pos":[2864,2899]},{"content":"In general, you create a dummy HWND for Direct3D9 to use.","pos":[2900,2957]},{"content":"The following code example shows how to create a dummy HWND.","pos":[2958,3018]},{"pos":[3229,3247],"content":"Present Parameters","linkify":"Present Parameters","nodes":[{"content":"Present Parameters","pos":[0,18]}]},{"content":"Creating a device also requires a <ph id=\"ph1\">`D3DPRESENT_PARAMETERS`</ph> struct, but only a few parameters are important.","pos":[3251,3357],"source":"Creating a device also requires a `D3DPRESENT_PARAMETERS` struct, but only a few parameters are important."},{"content":"These parameters are chosen to minimize the memory footprint.","pos":[3358,3419]},{"content":"Set the <ph id=\"ph1\">`BackBufferHeight`</ph> and <ph id=\"ph2\">`BackBufferWidth`</ph> fields to 1.","pos":[3426,3487],"source":"Set the `BackBufferHeight` and `BackBufferWidth` fields to 1."},{"content":"Setting them to 0 causes them to be set to the dimensions of the HWND.","pos":[3488,3558]},{"pos":[3565,3740],"content":"Always set the <ph id=\"ph1\">`D3DCREATE_MULTITHREADED`</ph> and <ph id=\"ph2\">`D3DCREATE_FPU_PRESERVE`</ph> flags to prevent corrupting memory used by Direct3D9 and to prevent Direct3D9 from changing FPU settings.","source":"Always set the `D3DCREATE_MULTITHREADED` and `D3DCREATE_FPU_PRESERVE` flags to prevent corrupting memory used by Direct3D9 and to prevent Direct3D9 from changing FPU settings."},{"pos":[3747,3825],"content":"The following code shows how to initialize the <ph id=\"ph1\">`D3DPRESENT_PARAMETERS`</ph> struct.","source":"The following code shows how to initialize the `D3DPRESENT_PARAMETERS` struct."},{"pos":[4002,4040],"content":"Creating the Back Buffer Render Target","linkify":"Creating the Back Buffer Render Target","nodes":[{"content":"Creating the Back Buffer Render Target","pos":[0,38]}]},{"pos":[4044,4241],"content":"To display Direct3D9 content in a <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph>, you create a Direct3D9 surface and assign it by calling the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.","source":"To display Direct3D9 content in a <xref:System.Windows.Interop.D3DImage>, you create a Direct3D9 surface and assign it by calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method."},{"pos":[4251,4276],"content":"Verifying Adapter Support","linkify":"Verifying Adapter Support","nodes":[{"content":"Verifying Adapter Support","pos":[0,25]}]},{"content":"Before creating a surface, verify that all adapters support the surface properties you require.","pos":[4280,4375]},{"content":"Even if you render to only one adapter, the WPF window may be displayed on any adapter in the system.","pos":[4376,4477]},{"content":"You should always write Direct3D9 code that handles multi-adapter configurations, and you should check all adapters for support, because WPF might move the surface among the available adapters.","pos":[4478,4671]},{"content":"The following code example shows how to check all adapters on the system for Direct3D9 support.","pos":[4678,4773]},{"pos":[5002,5022],"content":"Creating the Surface","linkify":"Creating the Surface","nodes":[{"content":"Creating the Surface","pos":[0,20]}]},{"content":"Before creating a surface, verify that the device capabilities support good performance on the target operating system.","pos":[5026,5145]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id=\"p1\">](performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>.","pos":[5146,5310],"source":" For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md)."},{"content":"When you have verified device capabilities, you can create the surface.","pos":[5317,5388]},{"content":"The following code example shows how to create the render target.","pos":[5389,5454]},{"pos":[5650,5654],"content":"WDDM","linkify":"WDDM","nodes":[{"content":"WDDM","pos":[0,4]}]},{"content":"On Windows Vista and later operating systems, which are configured to use the WDDM, you can create a render target texture and pass the level 0 surface to the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method.","pos":[5658,5880],"source":"On Windows Vista and later operating systems, which are configured to use the WDDM, you can create a render target texture and pass the level 0 surface to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method."},{"content":"This approach is not recommended on Windows XP, because you cannot create a lockable render target texture and performance will be reduced.","pos":[5881,6020]},{"pos":[6029,6050],"content":"Handling Device State","linkify":"Handling Device State","nodes":[{"content":"Handling Device State","pos":[0,21]}]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> class manages two display buffers, which are called the <bpt id=\"p1\">*</bpt>back buffer<ept id=\"p1\">*</ept> and the <bpt id=\"p2\">*</bpt>front buffer<ept id=\"p2\">*</ept>.","pos":[6054,6190],"source":"The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*."},{"content":"The back buffer is your Direct3D surface.","pos":[6191,6232]},{"content":"Changes to the back buffer are copied forward to the front buffer when you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.Unlock%2A&gt;</ph> method, where it is displayed on the hardware.","pos":[6234,6413],"source":"  Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware."},{"content":"Occasionally, the front buffer becomes unavailable.","pos":[6414,6465]},{"content":"This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.","pos":[6466,6613]},{"content":"When this occurs, your WPF application is notified by handling the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event.","pos":[6614,6756],"source":" When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event."},{"content":"How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.","pos":[6758,6898]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.","pos":[6899,7065],"source":" The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering."},{"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29&gt;</ph> overload or call the <ph id=\"ph2\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id=\"ph3\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph4\">`false`</ph>, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.","pos":[7072,7553],"source":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed."},{"content":"When the front buffer is available again, the rendering system raises the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to notify your WPF application.","pos":[7554,7734],"source":" When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application."},{"content":"You can create an event handler for the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged&gt;</ph> event to restart rendering again with a valid Direct3D surface.","pos":[7736,7908],"source":"  You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface."},{"content":"To restart rendering, you must call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph>.","pos":[7909,8001],"source":" To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>."},{"pos":[8008,8454],"content":"When you call the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> overload with the <ph id=\"ph2\">`enableSoftwareFallback`</ph> parameter set to <ph id=\"ph3\">`true`</ph>, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <ph id=\"ph4\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> when the front buffer is available again.","source":"When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again."},{"content":"When software rendering is enabled, there may be situations where the user’s device becomes unavailable, but the rendering system retains a reference to the Direct3D surface.","pos":[8461,8635]},{"content":"To check whether a Direct3D9 device is unavailable, call the <ph id=\"ph1\">`TestCooperativeLevel`</ph> method.","pos":[8636,8727],"source":" To check whether a Direct3D9 device is unavailable, call the `TestCooperativeLevel` method."},{"content":"To check a Direct3D9Ex devices call the <ph id=\"ph1\">`CheckDeviceState`</ph> method, because the <ph id=\"ph2\">`TestCooperativeLevel`</ph> method is deprecated and always returns success.","pos":[8728,8878],"source":" To check a Direct3D9Ex devices call the `CheckDeviceState` method, because the `TestCooperativeLevel` method is deprecated and always returns success."},{"content":"If the user device has become unavailable, call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> to release WPF’s reference to the back buffer.","pos":[8879,9029],"source":" If the user device has become unavailable, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF’s reference to the back buffer."},{"content":"If you need to reset your device, call <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> with the <ph id=\"ph2\">`backBuffer`</ph> parameter set to <ph id=\"ph3\">`null`</ph>, and then call <ph id=\"ph4\">&lt;xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A&gt;</ph> again with <ph id=\"ph5\">`backBuffer`</ph> set to a valid Direct3D surface.","pos":[9031,9299],"source":"  If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface."},{"content":"Call the <ph id=\"ph1\">`Reset`</ph> method to recover from an invalid device only if you implement multi-adapter support.","pos":[9306,9408],"source":"Call the `Reset` method to recover from an invalid device only if you implement multi-adapter support."},{"content":"Otherwise, release all Direct3D9 interfaces and re-create them completely.","pos":[9409,9483]},{"content":"If the adapter layout has changed, Direct3D9 objects created before the change are not updated.","pos":[9484,9579]},{"pos":[9588,9605],"content":"Handling Resizing","linkify":"Handling Resizing","nodes":[{"content":"Handling Resizing","pos":[0,17]}]},{"pos":[9609,9952],"content":"If a <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is displayed at a resolution other than its native size, it is scaled according to the current <ph id=\"ph2\">&lt;xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A&gt;</ph>, except that <ph id=\"ph3\">&lt;xref:System.Windows.Media.Effects.SamplingMode.Bilinear&gt;</ph> is substituted for <ph id=\"ph4\">&lt;xref:System.Windows.Media.BitmapScalingMode.Fant&gt;</ph>.","source":"If a <xref:System.Windows.Interop.D3DImage> is displayed at a resolution other than its native size, it is scaled according to the current <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A>, except that <xref:System.Windows.Media.Effects.SamplingMode.Bilinear> is substituted for <xref:System.Windows.Media.BitmapScalingMode.Fant>."},{"pos":[9959,10099],"content":"If you require higher fidelity, you must create a new surface when the container of the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> changes size.","source":"If you require higher fidelity, you must create a new surface when the container of the <xref:System.Windows.Interop.D3DImage> changes size."},{"content":"There are three possible approaches to handle resizing.","pos":[10106,10161]},{"content":"Participate in the layout system and create a new surface when the size changes.","pos":[10171,10251]},{"content":"Do not create too many surfaces, because you may exhaust or fragment video memory.","pos":[10252,10334]},{"content":"Wait until a resize event has not occurred for a fixed period of time to create the new surface.","pos":[10344,10440]},{"pos":[10450,10569],"content":"Create a <ph id=\"ph1\">&lt;xref:System.Windows.Threading.DispatcherTimer&gt;</ph> that checks the container dimensions several times per second.","source":"Create a <xref:System.Windows.Threading.DispatcherTimer> that checks the container dimensions several times per second."},{"pos":[10578,10604],"content":"Multi-monitor Optimization","linkify":"Multi-monitor Optimization","nodes":[{"content":"Multi-monitor Optimization","pos":[0,26]}]},{"pos":[10608,10745],"content":"Significantly reduced performance can result when the rendering system moves a <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> to another monitor.","source":"Significantly reduced performance can result when the rendering system moves a <xref:System.Windows.Interop.D3DImage> to another monitor."},{"content":"On WDDM, as long as the monitors are on the same video card and you use <ph id=\"ph1\">`Direct3DCreate9Ex`</ph>, there is no reduction in performance.","pos":[10752,10882],"source":"On WDDM, as long as the monitors are on the same video card and you use `Direct3DCreate9Ex`, there is no reduction in performance."},{"content":"If the monitors are on separate video cards, performance is reduced.","pos":[10883,10951]},{"content":"On Windows XP, performance is always reduced.","pos":[10952,10997]},{"pos":[11004,11164],"content":"When the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> moves to another monitor, you can create a new surface on the corresponding adapter to restore good performance.","source":"When the <xref:System.Windows.Interop.D3DImage> moves to another monitor, you can create a new surface on the corresponding adapter to restore good performance."},{"content":"To avoid the performance penalty, write code specifically for the multi-monitor case.","pos":[11171,11256]},{"content":"The following list shows one way to write multi-monitor code.","pos":[11257,11318]},{"pos":[11328,11444],"content":"Find a point of the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> in screen space with the <ph id=\"ph2\">`Visual.ProjectToScreen`</ph> method.","source":"Find a point of the <xref:System.Windows.Interop.D3DImage> in screen space with the `Visual.ProjectToScreen` method."},{"pos":[11454,11541],"content":"Use the <ph id=\"ph1\">`MonitorFromPoint`</ph> GDI method to find the monitor that is displaying the point.","source":"Use the `MonitorFromPoint` GDI method to find the monitor that is displaying the point."},{"pos":[11551,11648],"content":"Use the <ph id=\"ph1\">`IDirect3D9::GetAdapterMonitor`</ph> method to find which Direct3D9 adapter the monitor is on.","source":"Use the `IDirect3D9::GetAdapterMonitor` method to find which Direct3D9 adapter the monitor is on."},{"pos":[11658,11842],"content":"If the adapter is not the same as the adapter with the back buffer, create a new back buffer on the new monitor and assign it to the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> back buffer.","source":"If the adapter is not the same as the adapter with the back buffer, create a new back buffer on the new monitor and assign it to the <xref:System.Windows.Interop.D3DImage> back buffer."},{"pos":[11850,12077],"content":"[!NOTE]\n If the <xref:System.Windows.Interop.D3DImage> straddles monitors, performance will be slow, except in the case of WDDM and `IDirect3D9Ex` on the same adapter. There is no way to improve performance in this situation.","leadings":["","> "],"nodes":[{"content":"If the <xref:System.Windows.Interop.D3DImage> straddles monitors, performance will be slow, except in the case of WDDM and `IDirect3D9Ex` on the same adapter. There is no way to improve performance in this situation.","pos":[9,225],"nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> straddles monitors, performance will be slow, except in the case of WDDM and <ph id=\"ph2\">`IDirect3D9Ex`</ph> on the same adapter.","pos":[0,158],"source":"If the <xref:System.Windows.Interop.D3DImage> straddles monitors, performance will be slow, except in the case of WDDM and `IDirect3D9Ex` on the same adapter."},{"content":"There is no way to improve performance in this situation.","pos":[159,216]}]}]},{"content":"The following code example shows how to find the current monitor.","pos":[12084,12149]},{"pos":[12357,12549],"content":"Update the monitor when the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> container's size or position changes, or update the monitor by using a <ph id=\"ph2\">`DispatcherTimer`</ph> that updates a few times per second.","source":"Update the monitor when the <xref:System.Windows.Interop.D3DImage> container's size or position changes, or update the monitor by using a `DispatcherTimer` that updates a few times per second."},{"pos":[12558,12580],"content":"WPF Software Rendering","linkify":"WPF Software Rendering","nodes":[{"content":"WPF Software Rendering","pos":[0,22]}]},{"content":"WPF renders synchronously on the UI thread in software in the following situations.","pos":[12584,12667]},{"content":"Printing","pos":[12677,12685]},{"content":"When one of these situations occurs, the rendering system calls the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> method to copy the hardware buffer to software.","pos":[12814,12986],"source":"When one of these situations occurs, the rendering system calls the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to copy the hardware buffer to software."},{"content":"The default implementation calls the <ph id=\"ph1\">`GetRenderTargetData`</ph> method with your surface.","pos":[12987,13071],"source":" The default implementation calls the `GetRenderTargetData` method with your surface."},{"content":"Because this call occurs outside of the Lock/Unlock pattern, it may fail.","pos":[13072,13145]},{"content":"In this case, the <ph id=\"ph1\">`CopyBackBuffer`</ph> method returns <ph id=\"ph2\">`null`</ph> and no image is displayed.","pos":[13146,13229],"source":" In this case, the `CopyBackBuffer` method returns `null` and no image is displayed."},{"pos":[13236,13456],"content":"You can override the <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A&gt;</ph> method, call the base implementation, and if it returns <ph id=\"ph2\">`null`</ph>, you can return a placeholder <ph id=\"ph3\">&lt;xref:System.Windows.Media.Imaging.BitmapSource&gt;</ph>.","source":"You can override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method, call the base implementation, and if it returns `null`, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource>."},{"content":"You can also implement your own software rendering instead of calling the base implementation.","pos":[13463,13557]},{"pos":[13565,13713],"content":"[!NOTE]\n If WPF is rendering completely in software, <xref:System.Windows.Interop.D3DImage> is not shown because WPF does not have a front buffer.","leadings":["","> "],"nodes":[{"content":"If WPF is rendering completely in software, <ph id=\"ph1\">&lt;xref:System.Windows.Interop.D3DImage&gt;</ph> is not shown because WPF does not have a front buffer.","pos":[9,146],"source":"If WPF is rendering completely in software, <xref:System.Windows.Interop.D3DImage> is not shown because WPF does not have a front buffer."}]},{"pos":[13722,13730],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13775,13912],"content":"<bpt id=\"p1\">[</bpt>Performance Considerations for Direct3D9 and WPF Interoperability<ept id=\"p1\">](performance-considerations-for-direct3d9-and-wpf-interoperability.md)</ept>","source":"[Performance Considerations for Direct3D9 and WPF Interoperability](performance-considerations-for-direct3d9-and-wpf-interoperability.md)"},{"pos":[13915,14037],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Creating Direct3D9 Content for Hosting in WPF<ept id=\"p1\">](walkthrough-creating-direct3d9-content-for-hosting-in-wpf.md)</ept>","source":"[Walkthrough: Creating Direct3D9 Content for Hosting in WPF](walkthrough-creating-direct3d9-content-for-hosting-in-wpf.md)"},{"pos":[14040,14136],"content":"<bpt id=\"p1\">[</bpt>Walkthrough: Hosting Direct3D9 Content in WPF<ept id=\"p1\">](walkthrough-hosting-direct3d9-content-in-wpf.md)</ept>","source":"[Walkthrough: Hosting Direct3D9 Content in WPF](walkthrough-hosting-direct3d9-content-in-wpf.md)"}]}