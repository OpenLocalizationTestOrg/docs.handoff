{"content":"---\ntitle: \"Barrier\"\nms.date: \"09/14/2018\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"synchronization primitives, Barrier\"\nms.assetid: 613a8bc7-6a28-4795-bd6c-1abd9050478f\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# Barrier\n\nA <xref:System.Threading.Barrier?displayProperty=nameWithType> is a synchronization primitive that enables multiple threads (known as *participants*) to work concurrently on an algorithm in phases. Each participant executes until it reaches the barrier point in the code. The barrier represents the end of one phase of work. When a participant reaches the barrier, it blocks until all participants have reached the same barrier. After all participants have reached the barrier, you can optionally invoke a post-phase action. This post-phase action can be used to perform actions by a single thread while all other threads are still blocked. After the action has been executed, the participants are all unblocked.  \n  \n The following code snippet shows a basic barrier pattern.  \n  \n [!code-csharp[CDS_Barrier#02](../../../samples/snippets/csharp/VS_Snippets_Misc/cds_barrier/cs/barrier.cs#02)]\n [!code-vb[CDS_Barrier#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cds_barrier/vb/barrier_vb.vb#02)]  \n  \n For a complete example, see [How to: synchronize concurrent operations with a Barrier](how-to-synchronize-concurrent-operations-with-a-barrier.md).  \n  \n## Adding and removing participants\n\n When you create a <xref:System.Threading.Barrier> instance, specify the number of participants. You can also add or remove participants dynamically at any time. For example, if one participant solves its part of the problem, you can store the result, stop execution on that thread, and call <xref:System.Threading.Barrier.RemoveParticipant%2A?displayProperty=nameWithType> to decrement the number of participants in the barrier. When you add a participant by calling <xref:System.Threading.Barrier.AddParticipant%2A?displayProperty=nameWithType>, the return value specifies the current phase number, which may be useful in order to initialize the work of the new participant.  \n  \n## Broken barriers\n\n Deadlocks can occur if one participant fails to reach the barrier. To avoid these deadlocks, use the overloads of the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method to specify a time-out period and a cancellation token. These overloads return a Boolean value that every participant can check before it continues to the next phase.  \n  \n## Post-phase exceptions\n\n If the post-phase delegate throws an exception, it is wrapped in a <xref:System.Threading.BarrierPostPhaseException> object which is then propagated to all participants.  \n  \n## Barrier versus ContinueWhenAll\n\n Barriers are especially useful when the threads are performing multiple phases in loops. If your code requires only one or two phases of work, consider whether to use <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objects with any kind of implicit join, including:  \n  \n-   <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType>  \n  \n-   <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType>  \n  \n-   <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>  \n  \n-   <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>  \n  \n For more information, see [Chaining Tasks by Using Continuation Tasks](../parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  \n  \n## See also\n\n- [Threading objects and features](threading-objects-and-features.md)\n- [How to: synchronize concurrent operations with a Barrier](how-to-synchronize-concurrent-operations-with-a-barrier.md)\n","nodes":[{"pos":[4,260],"embed":true,"restype":"x-metadata","content":"title: \"Barrier\"\nms.date: \"09/14/2018\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"synchronization primitives, Barrier\"\nms.assetid: 613a8bc7-6a28-4795-bd6c-1abd9050478f\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"Barrier","nodes":[{"pos":[0,7],"content":"Barrier","nodes":[{"content":"Barrier","pos":[0,7]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[267,274],"content":"Barrier","linkify":"Barrier","nodes":[{"content":"Barrier","pos":[0,7]}]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.Barrier?displayProperty=nameWithType&gt;</ph> is a synchronization primitive that enables multiple threads (known as <bpt id=\"p1\">*</bpt>participants<ept id=\"p1\">*</ept>) to work concurrently on an algorithm in phases.","pos":[276,473],"source":"A <xref:System.Threading.Barrier?displayProperty=nameWithType> is a synchronization primitive that enables multiple threads (known as *participants*) to work concurrently on an algorithm in phases."},{"content":"Each participant executes until it reaches the barrier point in the code.","pos":[474,547]},{"content":"The barrier represents the end of one phase of work.","pos":[548,600]},{"content":"When a participant reaches the barrier, it blocks until all participants have reached the same barrier.","pos":[601,704]},{"content":"After all participants have reached the barrier, you can optionally invoke a post-phase action.","pos":[705,800]},{"content":"This post-phase action can be used to perform actions by a single thread while all other threads are still blocked.","pos":[801,916]},{"content":"After the action has been executed, the participants are all unblocked.","pos":[917,988]},{"content":"The following code snippet shows a basic barrier pattern.","pos":[995,1052]},{"pos":[1292,1439],"content":"For a complete example, see <bpt id=\"p1\">[</bpt>How to: synchronize concurrent operations with a Barrier<ept id=\"p1\">](how-to-synchronize-concurrent-operations-with-a-barrier.md)</ept>.","source":"For a complete example, see [How to: synchronize concurrent operations with a Barrier](how-to-synchronize-concurrent-operations-with-a-barrier.md)."},{"pos":[1448,1480],"content":"Adding and removing participants","linkify":"Adding and removing participants","nodes":[{"content":"Adding and removing participants","pos":[0,32]}]},{"content":"When you create a <ph id=\"ph1\">&lt;xref:System.Threading.Barrier&gt;</ph> instance, specify the number of participants.","pos":[1483,1578],"source":"When you create a <xref:System.Threading.Barrier> instance, specify the number of participants."},{"content":"You can also add or remove participants dynamically at any time.","pos":[1579,1643]},{"content":"For example, if one participant solves its part of the problem, you can store the result, stop execution on that thread, and call <ph id=\"ph1\">&lt;xref:System.Threading.Barrier.RemoveParticipant%2A?displayProperty=nameWithType&gt;</ph> to decrement the number of participants in the barrier.","pos":[1644,1911],"source":" For example, if one participant solves its part of the problem, you can store the result, stop execution on that thread, and call <xref:System.Threading.Barrier.RemoveParticipant%2A?displayProperty=nameWithType> to decrement the number of participants in the barrier."},{"content":"When you add a participant by calling <ph id=\"ph1\">&lt;xref:System.Threading.Barrier.AddParticipant%2A?displayProperty=nameWithType&gt;</ph>, the return value specifies the current phase number, which may be useful in order to initialize the work of the new participant.","pos":[1912,2158],"source":" When you add a participant by calling <xref:System.Threading.Barrier.AddParticipant%2A?displayProperty=nameWithType>, the return value specifies the current phase number, which may be useful in order to initialize the work of the new participant."},{"pos":[2167,2182],"content":"Broken barriers","linkify":"Broken barriers","nodes":[{"content":"Broken barriers","pos":[0,15]}]},{"content":"Deadlocks can occur if one participant fails to reach the barrier.","pos":[2185,2251]},{"content":"To avoid these deadlocks, use the overloads of the <ph id=\"ph1\">&lt;xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> method to specify a time-out period and a cancellation token.","pos":[2252,2442],"source":" To avoid these deadlocks, use the overloads of the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method to specify a time-out period and a cancellation token."},{"content":"These overloads return a Boolean value that every participant can check before it continues to the next phase.","pos":[2443,2553]},{"pos":[2562,2583],"content":"Post-phase exceptions","linkify":"Post-phase exceptions","nodes":[{"content":"Post-phase exceptions","pos":[0,21]}]},{"pos":[2586,2755],"content":"If the post-phase delegate throws an exception, it is wrapped in a <ph id=\"ph1\">&lt;xref:System.Threading.BarrierPostPhaseException&gt;</ph> object which is then propagated to all participants.","source":"If the post-phase delegate throws an exception, it is wrapped in a <xref:System.Threading.BarrierPostPhaseException> object which is then propagated to all participants."},{"pos":[2764,2794],"content":"Barrier versus ContinueWhenAll","linkify":"Barrier versus ContinueWhenAll","nodes":[{"content":"Barrier versus ContinueWhenAll","pos":[0,30]}]},{"content":"Barriers are especially useful when the threads are performing multiple phases in loops.","pos":[2797,2885]},{"content":"If your code requires only one or two phases of work, consider whether to use <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task?displayProperty=nameWithType&gt;</ph> objects with any kind of implicit join, including:","pos":[2886,3078],"source":" If your code requires only one or two phases of work, consider whether to use <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> objects with any kind of implicit join, including:"},{"pos":[3443,3585],"content":"For more information, see <bpt id=\"p1\">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id=\"p1\">](../parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.","source":"For more information, see [Chaining Tasks by Using Continuation Tasks](../parallel-programming/chaining-tasks-by-using-continuation-tasks.md)."},{"pos":[3594,3602],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[3606,3673],"content":"<bpt id=\"p1\">[</bpt>Threading objects and features<ept id=\"p1\">](threading-objects-and-features.md)</ept>","source":"[Threading objects and features](threading-objects-and-features.md)"},{"pos":[3676,3794],"content":"<bpt id=\"p1\">[</bpt>How to: synchronize concurrent operations with a Barrier<ept id=\"p1\">](how-to-synchronize-concurrent-operations-with-a-barrier.md)</ept>","source":"[How to: synchronize concurrent operations with a Barrier](how-to-synchronize-concurrent-operations-with-a-barrier.md)"}]}