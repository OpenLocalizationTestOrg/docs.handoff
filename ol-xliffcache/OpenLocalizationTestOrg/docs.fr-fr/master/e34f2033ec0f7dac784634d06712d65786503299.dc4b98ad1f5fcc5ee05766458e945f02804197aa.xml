{"content":"---\ntitle: \"Queues Overview\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"queues [WCF], MSMQ integration\"\nms.assetid: b8757992-ffce-40ad-9e9b-3243f6d0fce1\n---\n# Queues Overview\nThis section introduces the general and core concepts behind queued communication. Subsequent sections go into details about how the queuing concepts described here are manifested in Windows Communication Foundation (WCF).  \n  \n## Basic Queuing Concepts  \n When designing a distributed application, choosing the right transport for communication between services and clients is important. Several factors affect the kind of transport to use. One important factor—isolation between the service, the client, and the transport—determines use of a queued transport or a direct transport, such as TCP or HTTP. Due to the nature of direct transports such as TCP and HTTP, communication stops altogether if the service or the client stop functioning or if the network fails. The service, the client, and the network must be running at the same time for the application to work. Queued transports provide isolation, which means that if the service or client fail or if communication links between them fail, the client and service can continue to function.  \n  \n Queues provide reliable communication even with failures in the communicating parties or the network. Queues capture and deliver messages exchanged between the communicating parties. Queues are typically backed by some kind of a store, which can be volatile or durable. Queues store messages from a client on behalf of a service and later forward these messages to the service. The indirection queues provide ensured isolation of failure by either party, thus making it the preferred communication mechanism for high-availability systems and disconnected services. The indirection comes with the cost of high latency. *Latency* is the time delay between the time the client sends a message and the time the service receives it. This means that once a message is sent, you do not know when that message may be processed. Most queued applications cope with high latency. The following illustration shows a conceptual model of queued communication.  \n  \n ![Model of queued communication](../../../../docs/framework/wcf/feature-details/media/qconceptual-figure1c.gif \"QConceptual-Figure1c\")  \n  \n Queued communication conceptual model  \n  \n In reality, the queue is a distributed concept. As such, they can be local to either party or remote to both parties. Typically, the queue is local to the service. In this configuration, the client cannot depend on connectivity to the remote queue to be constantly available. Similarly, the queue must be available independent of the availability of the service reading from the queue. A queue manager manages a collection of queues. It is responsible for accepting messages sent to its queues from other queue managers. It is also responsible for managing connectivity to remote queues and transferring messages to those remote queues. To ensure availability of queues despite client or service application failures, the queue manager is typically run as an external service.  \n  \n When a client sends a message to a queue, it addresses the message to the target queue, which is the queue managed by the service's queue manager. The queue manager on the client sends the message to a transmission (or outgoing) queue. The transmission queue is a queue on the client queue manager that stores messages for transmission to the target queue. The queue manager then finds a path to the queue manager that owns the target queue and transfers the message to it. To ensure reliable communication, the queue managers implement a reliable transfer protocol to prevent data loss. The destination queue manager accepts messages addressed to the target queues it owns and stores the messages. The service makes requests to read from the target queue, at which time the queue manager then delivers the message to the destination application. The following illustration shows communication between the four parties.  \n  \n ![Queued Application Diagram](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg \"Distributed-Queue-Figure\")  \n  \n Queued communication in a typical deployment scenario  \n  \n Thus, the queue manager provides the required isolation so that the sender and receiver can independently fail without affecting actual communication. The benefit of extra indirection that queues provide also enables multiple application instances to read from the same queue, so that farming work among the nodes achieves higher throughput. Therefore, it is not uncommon to see queues being used to achieve higher scale and throughput requirements.  \n  \n## Queues and Transactions  \n Transactions allow you to group a set of operations together so that if one operation fails, all of the operations fail. An example of how to use transactions is when a person uses an ATM to transfer $1,000 from his savings account to his checking account. This entails the following operations:  \n  \n-   Withdrawing $1,000 from the savings account.  \n  \n-   Depositing $1,000 into the checking account.  \n  \n If the first operation succeeds and $1,000 is withdrawn from the savings account but the second operation fails, the $1,000 is lost because it has already been withdrawn from the savings account. To keep the accounts in a valid state, if one operation fails, both operations must fail.  \n  \n In transactional messaging, messages can be sent to the queue and received from the queue under a transaction. Thus, if a message is sent in a transaction and the transaction is rolled back, then the outcome is as if the message had never been sent to the queue. Similarly if a message is received in a transaction and the transaction is rolled back, then the outcome is as if the message had never been received. The message remains in the queue to be read.  \n  \n Because of high latency, when you send a message you have no way of knowing how long it takes to reach its target queue, nor do you know how long it takes for the service to process the message. Because of this, you do not want to use a single transaction to send the message, receive the message, and then process the message. This creates a transaction that is not committed for an indeterminate amount of time. When a client and service communicate through a queue using a transaction, two transactions are involved: one on the client and one on the service. The following illustration shows the transaction boundaries in typical queued communication.  \n  \n ![Queue with transactions](../../../../docs/framework/wcf/feature-details/media/qwithtransactions-figure3.gif \"QWithTransactions-Figure3\")  \n  \n Queued communication showing separate transactions for capture and delivery  \n  \n The client transaction processes and sends the message. When the transaction is committed, the message is in the transmission queue. On the service, the transaction reads the message from the target queue, processes the message, and then commits the transaction. If an error occurs during the processing, the message is rolled back and placed in the target queue.  \n  \n## Asynchronous Communication Using Queues  \n Queues provide an asynchronous means of communication. Applications that send messages using queues cannot wait for the message to be received and processed by the receiver because of high latency introduced by the queue manager. Messages can remain in the queue for a far longer time than the application intended. To avoid this, the application can specify a Time-To-Live value on the message. This value specifies how long the message should remain in the transmission queue. If this time value is exceeded, and the message still has not been sent to the target queue, the message can be transferred to a dead-letter queue.  \n  \n When the sender sends a message, the return from the send operation implies that the message only made it to the transmission queue on the sender. As such, if there is a failure in getting the message to the target queue, the sending application cannot know about it immediately. To take note of such failures, the failed message is transferred to a dead-letter queue.  \n  \n Any error, such as a message failing to reach the target queue or the Time-To-Live expiring, must be processed separately. It is not uncommon, therefore, for queued applications to write two sets of logic:  \n  \n-   The normal client and service logic of sending and receiving messages.  \n  \n-   Compensation logic to handle messages from the failed transmission or delivery.  \n  \n The following sections discuss these concepts.  \n  \n## Dead-Letter Queue Programming  \n Dead-letter queues contain messages that failed to reach the target queue for various reasons. The reasons can range from expired messages to connectivity issues preventing transfer of the message to the target queue.  \n  \n Typically, an application can read messages from a system-wide dead-letter queue, determine what went wrong, and take appropriate action, such as correcting the errors and resending the message or taking note of it.  \n  \n## Poison Message Queue Programming  \n After a message makes it to the target queue, the service may repeatedly fail to process the message. For example, an application reading a message from the queue under a transaction and updating a database may find the database temporarily disconnected. In this case, the transaction is rolled back, a new transaction is created, and the message is reread from the queue. A second attempt may succeed or fail. In some cases, depending on the cause of the error, the message may repeatedly fail delivery to the application. In this case, the message is deemed as \"poison.\" Such messages are moved to a poison queue that can be read by a poison-handling application.  \n  \n## See also\n\n- [Queuing in WCF](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)\n- [Sessions and Queues](../../../../docs/framework/wcf/samples/sessions-and-queues.md)\n- [Dead Letter Queues](../../../../docs/framework/wcf/samples/dead-letter-queues.md)\n- [Volatile Queued Communication](../../../../docs/framework/wcf/samples/volatile-queued-communication.md)\n- [Windows Communication Foundation to Message Queuing](../../../../docs/framework/wcf/samples/wcf-to-message-queuing.md)\n- [Installing Message Queuing (MSMQ)](../../../../docs/framework/wcf/samples/installing-message-queuing-msmq.md)\n- [Message Queuing to Windows Communication Foundation](../../../../docs/framework/wcf/samples/message-queuing-to-wcf.md)\n- [Message Security over Message Queuing](../../../../docs/framework/wcf/samples/message-security-over-message-queuing.md)\n","nodes":[{"pos":[4,158],"embed":true,"restype":"x-metadata","content":"title: \"Queues Overview\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"queues [WCF], MSMQ integration\"\nms.assetid: b8757992-ffce-40ad-9e9b-3243f6d0fce1","nodes":[{"content":"Queues Overview","nodes":[{"pos":[0,15],"content":"Queues Overview","nodes":[{"content":"Queues Overview","pos":[0,15]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[165,180],"content":"Queues Overview","linkify":"Queues Overview","nodes":[{"content":"Queues Overview","pos":[0,15]}]},{"content":"This section introduces the general and core concepts behind queued communication.","pos":[181,263]},{"content":"Subsequent sections go into details about how the queuing concepts described here are manifested in Windows Communication Foundation (WCF).","pos":[264,403]},{"pos":[412,434],"content":"Basic Queuing Concepts","linkify":"Basic Queuing Concepts","nodes":[{"content":"Basic Queuing Concepts","pos":[0,22]}]},{"content":"When designing a distributed application, choosing the right transport for communication between services and clients is important.","pos":[438,569]},{"content":"Several factors affect the kind of transport to use.","pos":[570,622]},{"content":"One important factor—isolation between the service, the client, and the transport—determines use of a queued transport or a direct transport, such as TCP or HTTP.","pos":[623,785]},{"content":"Due to the nature of direct transports such as TCP and HTTP, communication stops altogether if the service or the client stop functioning or if the network fails.","pos":[786,948]},{"content":"The service, the client, and the network must be running at the same time for the application to work.","pos":[949,1051]},{"content":"Queued transports provide isolation, which means that if the service or client fail or if communication links between them fail, the client and service can continue to function.","pos":[1052,1229]},{"content":"Queues provide reliable communication even with failures in the communicating parties or the network.","pos":[1236,1337]},{"content":"Queues capture and deliver messages exchanged between the communicating parties.","pos":[1338,1418]},{"content":"Queues are typically backed by some kind of a store, which can be volatile or durable.","pos":[1419,1505]},{"content":"Queues store messages from a client on behalf of a service and later forward these messages to the service.","pos":[1506,1613]},{"content":"The indirection queues provide ensured isolation of failure by either party, thus making it the preferred communication mechanism for high-availability systems and disconnected services.","pos":[1614,1800]},{"content":"The indirection comes with the cost of high latency.","pos":[1801,1853]},{"content":"<bpt id=\"p1\">*</bpt>Latency<ept id=\"p1\">*</ept> is the time delay between the time the client sends a message and the time the service receives it.","pos":[1854,1963],"source":"*Latency* is the time delay between the time the client sends a message and the time the service receives it."},{"content":"This means that once a message is sent, you do not know when that message may be processed.","pos":[1964,2055]},{"content":"Most queued applications cope with high latency.","pos":[2056,2104]},{"content":"The following illustration shows a conceptual model of queued communication.","pos":[2105,2181]},{"pos":[2188,2322],"content":"<bpt id=\"p1\">![</bpt>Model of queued communication<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/feature-details/media/qconceptual-figure1c.gif \"</bpt>QConceptual-Figure1c<ept id=\"p2\">\")</ept>","source":"![Model of queued communication](../../../../docs/framework/wcf/feature-details/media/qconceptual-figure1c.gif \"QConceptual-Figure1c\")"},{"content":"Queued communication conceptual model","pos":[2329,2366]},{"content":"In reality, the queue is a distributed concept.","pos":[2373,2420]},{"content":"As such, they can be local to either party or remote to both parties.","pos":[2421,2490]},{"content":"Typically, the queue is local to the service.","pos":[2491,2536]},{"content":"In this configuration, the client cannot depend on connectivity to the remote queue to be constantly available.","pos":[2537,2648]},{"content":"Similarly, the queue must be available independent of the availability of the service reading from the queue.","pos":[2649,2758]},{"content":"A queue manager manages a collection of queues.","pos":[2759,2806]},{"content":"It is responsible for accepting messages sent to its queues from other queue managers.","pos":[2807,2893]},{"content":"It is also responsible for managing connectivity to remote queues and transferring messages to those remote queues.","pos":[2894,3009]},{"content":"To ensure availability of queues despite client or service application failures, the queue manager is typically run as an external service.","pos":[3010,3149]},{"content":"When a client sends a message to a queue, it addresses the message to the target queue, which is the queue managed by the service's queue manager.","pos":[3156,3302]},{"content":"The queue manager on the client sends the message to a transmission (or outgoing) queue.","pos":[3303,3391]},{"content":"The transmission queue is a queue on the client queue manager that stores messages for transmission to the target queue.","pos":[3392,3512]},{"content":"The queue manager then finds a path to the queue manager that owns the target queue and transfers the message to it.","pos":[3513,3629]},{"content":"To ensure reliable communication, the queue managers implement a reliable transfer protocol to prevent data loss.","pos":[3630,3743]},{"content":"The destination queue manager accepts messages addressed to the target queues it owns and stores the messages.","pos":[3744,3854]},{"content":"The service makes requests to read from the target queue, at which time the queue manager then delivers the message to the destination application.","pos":[3855,4002]},{"content":"The following illustration shows communication between the four parties.","pos":[4003,4075]},{"pos":[4082,4221],"content":"<bpt id=\"p1\">![</bpt>Queued Application Diagram<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg \"</bpt>Distributed-Queue-Figure<ept id=\"p2\">\")</ept>","source":"![Queued Application Diagram](../../../../docs/framework/wcf/feature-details/media/distributed-queue-figure.jpg \"Distributed-Queue-Figure\")"},{"content":"Queued communication in a typical deployment scenario","pos":[4228,4281]},{"content":"Thus, the queue manager provides the required isolation so that the sender and receiver can independently fail without affecting actual communication.","pos":[4288,4438]},{"content":"The benefit of extra indirection that queues provide also enables multiple application instances to read from the same queue, so that farming work among the nodes achieves higher throughput.","pos":[4439,4629]},{"content":"Therefore, it is not uncommon to see queues being used to achieve higher scale and throughput requirements.","pos":[4630,4737]},{"pos":[4746,4769],"content":"Queues and Transactions","linkify":"Queues and Transactions","nodes":[{"content":"Queues and Transactions","pos":[0,23]}]},{"content":"Transactions allow you to group a set of operations together so that if one operation fails, all of the operations fail.","pos":[4773,4893]},{"content":"An example of how to use transactions is when a person uses an ATM to transfer $1,000 from his savings account to his checking account.","pos":[4894,5029]},{"content":"This entails the following operations:","pos":[5030,5068]},{"content":"Withdrawing $1,000 from the savings account.","pos":[5078,5122]},{"content":"Depositing $1,000 into the checking account.","pos":[5132,5176]},{"content":"If the first operation succeeds and $1,000 is withdrawn from the savings account but the second operation fails, the $1,000 is lost because it has already been withdrawn from the savings account.","pos":[5183,5378]},{"content":"To keep the accounts in a valid state, if one operation fails, both operations must fail.","pos":[5379,5468]},{"content":"In transactional messaging, messages can be sent to the queue and received from the queue under a transaction.","pos":[5475,5585]},{"content":"Thus, if a message is sent in a transaction and the transaction is rolled back, then the outcome is as if the message had never been sent to the queue.","pos":[5586,5737]},{"content":"Similarly if a message is received in a transaction and the transaction is rolled back, then the outcome is as if the message had never been received.","pos":[5738,5888]},{"content":"The message remains in the queue to be read.","pos":[5889,5933]},{"content":"Because of high latency, when you send a message you have no way of knowing how long it takes to reach its target queue, nor do you know how long it takes for the service to process the message.","pos":[5940,6134]},{"content":"Because of this, you do not want to use a single transaction to send the message, receive the message, and then process the message.","pos":[6135,6267]},{"content":"This creates a transaction that is not committed for an indeterminate amount of time.","pos":[6268,6353]},{"content":"When a client and service communicate through a queue using a transaction, two transactions are involved: one on the client and one on the service.","pos":[6354,6501]},{"content":"The following illustration shows the transaction boundaries in typical queued communication.","pos":[6502,6594]},{"pos":[6601,6739],"content":"<bpt id=\"p1\">![</bpt>Queue with transactions<ept id=\"p1\">]</ept><bpt id=\"p2\">(../../../../docs/framework/wcf/feature-details/media/qwithtransactions-figure3.gif \"</bpt>QWithTransactions-Figure3<ept id=\"p2\">\")</ept>","source":"![Queue with transactions](../../../../docs/framework/wcf/feature-details/media/qwithtransactions-figure3.gif \"QWithTransactions-Figure3\")"},{"content":"Queued communication showing separate transactions for capture and delivery","pos":[6746,6821]},{"content":"The client transaction processes and sends the message.","pos":[6828,6883]},{"content":"When the transaction is committed, the message is in the transmission queue.","pos":[6884,6960]},{"content":"On the service, the transaction reads the message from the target queue, processes the message, and then commits the transaction.","pos":[6961,7090]},{"content":"If an error occurs during the processing, the message is rolled back and placed in the target queue.","pos":[7091,7191]},{"pos":[7200,7239],"content":"Asynchronous Communication Using Queues","linkify":"Asynchronous Communication Using Queues","nodes":[{"content":"Asynchronous Communication Using Queues","pos":[0,39]}]},{"content":"Queues provide an asynchronous means of communication.","pos":[7243,7297]},{"content":"Applications that send messages using queues cannot wait for the message to be received and processed by the receiver because of high latency introduced by the queue manager.","pos":[7298,7472]},{"content":"Messages can remain in the queue for a far longer time than the application intended.","pos":[7473,7558]},{"content":"To avoid this, the application can specify a Time-To-Live value on the message.","pos":[7559,7638]},{"content":"This value specifies how long the message should remain in the transmission queue.","pos":[7639,7721]},{"content":"If this time value is exceeded, and the message still has not been sent to the target queue, the message can be transferred to a dead-letter queue.","pos":[7722,7869]},{"content":"When the sender sends a message, the return from the send operation implies that the message only made it to the transmission queue on the sender.","pos":[7876,8022]},{"content":"As such, if there is a failure in getting the message to the target queue, the sending application cannot know about it immediately.","pos":[8023,8155]},{"content":"To take note of such failures, the failed message is transferred to a dead-letter queue.","pos":[8156,8244]},{"content":"Any error, such as a message failing to reach the target queue or the Time-To-Live expiring, must be processed separately.","pos":[8251,8373]},{"content":"It is not uncommon, therefore, for queued applications to write two sets of logic:","pos":[8374,8456]},{"content":"The normal client and service logic of sending and receiving messages.","pos":[8466,8536]},{"content":"Compensation logic to handle messages from the failed transmission or delivery.","pos":[8546,8625]},{"content":"The following sections discuss these concepts.","pos":[8632,8678]},{"pos":[8687,8716],"content":"Dead-Letter Queue Programming","linkify":"Dead-Letter Queue Programming","nodes":[{"content":"Dead-Letter Queue Programming","pos":[0,29]}]},{"content":"Dead-letter queues contain messages that failed to reach the target queue for various reasons.","pos":[8720,8814]},{"content":"The reasons can range from expired messages to connectivity issues preventing transfer of the message to the target queue.","pos":[8815,8937]},{"content":"Typically, an application can read messages from a system-wide dead-letter queue, determine what went wrong, and take appropriate action, such as correcting the errors and resending the message or taking note of it.","pos":[8944,9159]},{"pos":[9168,9200],"content":"Poison Message Queue Programming","linkify":"Poison Message Queue Programming","nodes":[{"content":"Poison Message Queue Programming","pos":[0,32]}]},{"content":"After a message makes it to the target queue, the service may repeatedly fail to process the message.","pos":[9204,9305]},{"content":"For example, an application reading a message from the queue under a transaction and updating a database may find the database temporarily disconnected.","pos":[9306,9458]},{"content":"In this case, the transaction is rolled back, a new transaction is created, and the message is reread from the queue.","pos":[9459,9576]},{"content":"A second attempt may succeed or fail.","pos":[9577,9614]},{"content":"In some cases, depending on the cause of the error, the message may repeatedly fail delivery to the application.","pos":[9615,9727]},{"content":"In this case, the message is deemed as \"poison.\"","pos":[9728,9776]},{"content":"Such messages are moved to a poison queue that can be read by a poison-handling application.","pos":[9777,9869]},{"pos":[9878,9886],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9890,9972],"content":"<bpt id=\"p1\">[</bpt>Queuing in WCF<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)</ept>","source":"[Queuing in WCF](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)"},{"pos":[9975,10059],"content":"<bpt id=\"p1\">[</bpt>Sessions and Queues<ept id=\"p1\">](../../../../docs/framework/wcf/samples/sessions-and-queues.md)</ept>","source":"[Sessions and Queues](../../../../docs/framework/wcf/samples/sessions-and-queues.md)"},{"pos":[10062,10144],"content":"<bpt id=\"p1\">[</bpt>Dead Letter Queues<ept id=\"p1\">](../../../../docs/framework/wcf/samples/dead-letter-queues.md)</ept>","source":"[Dead Letter Queues](../../../../docs/framework/wcf/samples/dead-letter-queues.md)"},{"pos":[10147,10251],"content":"<bpt id=\"p1\">[</bpt>Volatile Queued Communication<ept id=\"p1\">](../../../../docs/framework/wcf/samples/volatile-queued-communication.md)</ept>","source":"[Volatile Queued Communication](../../../../docs/framework/wcf/samples/volatile-queued-communication.md)"},{"pos":[10254,10373],"content":"<bpt id=\"p1\">[</bpt>Windows Communication Foundation to Message Queuing<ept id=\"p1\">](../../../../docs/framework/wcf/samples/wcf-to-message-queuing.md)</ept>","source":"[Windows Communication Foundation to Message Queuing](../../../../docs/framework/wcf/samples/wcf-to-message-queuing.md)"},{"pos":[10376,10486],"content":"<bpt id=\"p1\">[</bpt>Installing Message Queuing (MSMQ)<ept id=\"p1\">](../../../../docs/framework/wcf/samples/installing-message-queuing-msmq.md)</ept>","source":"[Installing Message Queuing (MSMQ)](../../../../docs/framework/wcf/samples/installing-message-queuing-msmq.md)"},{"pos":[10489,10608],"content":"<bpt id=\"p1\">[</bpt>Message Queuing to Windows Communication Foundation<ept id=\"p1\">](../../../../docs/framework/wcf/samples/message-queuing-to-wcf.md)</ept>","source":"[Message Queuing to Windows Communication Foundation](../../../../docs/framework/wcf/samples/message-queuing-to-wcf.md)"},{"pos":[10611,10731],"content":"<bpt id=\"p1\">[</bpt>Message Security over Message Queuing<ept id=\"p1\">](../../../../docs/framework/wcf/samples/message-security-over-message-queuing.md)</ept>","source":"[Message Security over Message Queuing](../../../../docs/framework/wcf/samples/message-security-over-message-queuing.md)"}]}