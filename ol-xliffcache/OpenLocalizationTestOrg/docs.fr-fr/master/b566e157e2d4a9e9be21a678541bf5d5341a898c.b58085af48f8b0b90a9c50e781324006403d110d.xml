{"content":"---\ntitle: \"Inline Styles and Templates\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"inline templates [WPF]\"\n  - \"styles [WPF], inline\"\n  - \"templates [WPF], inline\"\n  - \"inline styles [WPF]\"\nms.assetid: 69a1a3f9-acb5-4e2c-9c43-2e376c055ac4\n---\n# Inline Styles and Templates\n[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides <xref:System.Windows.Style> objects and template objects (<xref:System.Windows.FrameworkTemplate> subclasses) as a way to define the visual appearance of an element in resources, so that they can be used multiple times. For this reason, attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] that take the types <xref:System.Windows.Style> and <xref:System.Windows.FrameworkTemplate> almost always make resource references to existing styles and templates rather than define new ones inline.  \n  \n## Limitations of Inline Styles and Templates  \n In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], style and template properties can technically be set in one of two ways. You can use attribute syntax to reference a style that was defined within a resource, for example `<`*object*`Style=\"{StaticResource`*myResourceKey*`}\" .../>`. Or you can use property element syntax to define a style inline, for instance:  \n  \n `<` *object* `>`  \n  \n `<` *object* `.Style>`  \n  \n `<` `Style`  `.../>`  \n  \n `</` *object* `.Style>`  \n  \n `</` *object* `>`  \n  \n The attribute usage is much more common. A style that is defined inline and not defined in resources is necessarily scoped to the containing element only, and cannot be re-used as easily because it has no resource key. In general a resource-defined style is more versatile and useful, and is more in keeping with the general [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] programming model principle of separating program logic in code from design in markup.  \n  \n Usually there is no reason to set a style or template inline, even if you only intend to use that style or template in that location. Most elements that can take a style or template also support a content property and a content model. If you are only using whatever logical tree you create through styling or templating once, it would be even easier to just fill that content property with the equivalent child elements in direct markup. This would bypass the style and template mechanisms altogether.  \n  \n Other syntaxes enabled by markup extensions that return an object are also possible for styles and templates. Two such extensions that have possible scenarios include [TemplateBinding](templatebinding-markup-extension.md) and <xref:System.Windows.Data.Binding>.  \n  \n## See also\n\n- [Styling and Templating](../controls/styling-and-templating.md)\n","nodes":[{"pos":[4,245],"embed":true,"restype":"x-metadata","content":"title: \"Inline Styles and Templates\"\nms.date: \"03/30/2017\"\nhelpviewer_keywords: \n  - \"inline templates [WPF]\"\n  - \"styles [WPF], inline\"\n  - \"templates [WPF], inline\"\n  - \"inline styles [WPF]\"\nms.assetid: 69a1a3f9-acb5-4e2c-9c43-2e376c055ac4","nodes":[{"content":"Inline Styles and Templates","nodes":[{"pos":[0,27],"content":"Inline Styles and Templates","nodes":[{"content":"Inline Styles and Templates","pos":[0,27]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[252,279],"content":"Inline Styles and Templates","linkify":"Inline Styles and Templates","nodes":[{"content":"Inline Styles and Templates","pos":[0,27]}]},{"content":"<ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> provides <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph> objects and template objects (<ph id=\"ph3\">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> subclasses) as a way to define the visual appearance of an element in resources, so that they can be used multiple times.","pos":[280,588],"source":"[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides <xref:System.Windows.Style> objects and template objects (<xref:System.Windows.FrameworkTemplate> subclasses) as a way to define the visual appearance of an element in resources, so that they can be used multiple times."},{"content":"For this reason, attributes in <ph id=\"ph1\">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> that take the types <ph id=\"ph2\">&lt;xref:System.Windows.Style&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> almost always make resource references to existing styles and templates rather than define new ones inline.","pos":[589,891],"source":" For this reason, attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] that take the types <xref:System.Windows.Style> and <xref:System.Windows.FrameworkTemplate> almost always make resource references to existing styles and templates rather than define new ones inline."},{"pos":[900,942],"content":"Limitations of Inline Styles and Templates","linkify":"Limitations of Inline Styles and Templates","nodes":[{"content":"Limitations of Inline Styles and Templates","pos":[0,42]}]},{"content":"In <ph id=\"ph1\">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</ph>, style and template properties can technically be set in one of two ways.","pos":[946,1092],"source":"In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], style and template properties can technically be set in one of two ways."},{"content":"You can use attribute syntax to reference a style that was defined within a resource, for example <ph id=\"ph1\">`&lt;`</ph><bpt id=\"p1\">*</bpt>object<ept id=\"p1\">*</ept><ph id=\"ph2\">`Style=\"{StaticResource`</ph><bpt id=\"p2\">*</bpt>myResourceKey<ept id=\"p2\">*</ept><ph id=\"ph3\">`}\" .../&gt;`</ph>.","pos":[1093,1252],"source":" You can use attribute syntax to reference a style that was defined within a resource, for example `<`*object*`Style=\"{StaticResource`*myResourceKey*`}\" .../>`."},{"content":"Or you can use property element syntax to define a style inline, for instance:","pos":[1253,1331]},{"pos":[1338,1354],"content":"<ph id=\"ph1\">`&lt;`</ph> <bpt id=\"p1\">*</bpt>object<ept id=\"p1\">*</ept> <ph id=\"ph2\">`&gt;`</ph>","source":"`<` *object* `>`"},{"pos":[1361,1383],"content":"<ph id=\"ph1\">`&lt;`</ph> <bpt id=\"p1\">*</bpt>object<ept id=\"p1\">*</ept> <ph id=\"ph2\">`.Style&gt;`</ph>","source":"`<` *object* `.Style>`"},{"pos":[1390,1410],"content":"<ph id=\"ph1\">`&lt;`</ph> <ph id=\"ph2\">`Style`</ph>  <ph id=\"ph3\">`.../&gt;`</ph>","source":"`<` `Style`  `.../>`"},{"pos":[1417,1440],"content":"<ph id=\"ph1\">`&lt;/`</ph> <bpt id=\"p1\">*</bpt>object<ept id=\"p1\">*</ept> <ph id=\"ph2\">`.Style&gt;`</ph>","source":"`</` *object* `.Style>`"},{"pos":[1447,1464],"content":"<ph id=\"ph1\">`&lt;/`</ph> <bpt id=\"p1\">*</bpt>object<ept id=\"p1\">*</ept> <ph id=\"ph2\">`&gt;`</ph>","source":"`</` *object* `>`"},{"content":"The attribute usage is much more common.","pos":[1471,1511]},{"content":"A style that is defined inline and not defined in resources is necessarily scoped to the containing element only, and cannot be re-used as easily because it has no resource key.","pos":[1512,1689]},{"content":"In general a resource-defined style is more versatile and useful, and is more in keeping with the general <ph id=\"ph1\">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> programming model principle of separating program logic in code from design in markup.","pos":[1690,1962],"source":" In general a resource-defined style is more versatile and useful, and is more in keeping with the general [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] programming model principle of separating program logic in code from design in markup."},{"content":"Usually there is no reason to set a style or template inline, even if you only intend to use that style or template in that location.","pos":[1969,2102]},{"content":"Most elements that can take a style or template also support a content property and a content model.","pos":[2103,2203]},{"content":"If you are only using whatever logical tree you create through styling or templating once, it would be even easier to just fill that content property with the equivalent child elements in direct markup.","pos":[2204,2406]},{"content":"This would bypass the style and template mechanisms altogether.","pos":[2407,2470]},{"content":"Other syntaxes enabled by markup extensions that return an object are also possible for styles and templates.","pos":[2477,2586]},{"content":"Two such extensions that have possible scenarios include <bpt id=\"p1\">[</bpt>TemplateBinding<ept id=\"p1\">](templatebinding-markup-extension.md)</ept> and <ph id=\"ph1\">&lt;xref:System.Windows.Data.Binding&gt;</ph>.","pos":[2587,2738],"source":" Two such extensions that have possible scenarios include [TemplateBinding](templatebinding-markup-extension.md) and <xref:System.Windows.Data.Binding>."},{"pos":[2747,2755],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[2759,2822],"content":"<bpt id=\"p1\">[</bpt>Styling and Templating<ept id=\"p1\">](../controls/styling-and-templating.md)</ept>","source":"[Styling and Templating](../controls/styling-and-templating.md)"}]}