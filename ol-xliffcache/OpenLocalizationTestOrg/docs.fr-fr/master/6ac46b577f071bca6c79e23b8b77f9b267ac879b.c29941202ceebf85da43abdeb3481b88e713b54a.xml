{"content":"---\ntitle: \"Generating SQL from Command Trees - Best Practices\"\nms.date: \"03/30/2017\"\nms.assetid: 71ef6a24-4c4f-4254-af3a-ffc0d855b0a8\n---\n\n# Generating SQL from Command Trees - Best Practices\n\nOutput query command trees closely model queries expressible in SQL. However, there are certain common challenges for provider writers when generating SQL from an output command tree. This topic discusses these challenges. In the next topic, the sample provider shows how to address these challenges.\n\n## Group DbExpression Nodes in a SQL SELECT Statement\n\nA typical SQL statement has a nested structure of the following shape:\n\n```sql\nSELECT …\nFROM …\nWHERE …\nGROUP BY …\nORDER BY …\n```\n\nOne or more clauses may be empty.  A nested SELECT statement could occur in any of the lines.\n\nA possible translation of a query command tree into a SQL SELECT statement would produce one subquery for every relational operator. However, that would lead to unnecessary nested subqueries that would be difficult to read.  On some data stores, the query may perform poorly.\n\nAs an example, consider the following query command tree\n\n```\nProject (\na.x,\n   a = Filter(\n      b.y = 5,\n      b = Scan(\"TableA\")\n   )\n)\n```\n\nAn inefficient translation would produce:\n\n```sql\nSELECT a.x\nFROM (   SELECT *\n         FROM TableA as b\n         WHERE b.y = 5) as a\n```\n\nNote that every relational expression node becomes a new SQL SELECT statement.\n\nTherefore, it is important to aggregate as many expression nodes as possible into a single SQL SELECT statement while preserving correctness.\n\nThe result of such aggregation for the example presented above would be:\n\n```sql\nSELECT b.x\nFROM TableA as b\nWHERE b.y = 5\n```\n\n## Flatten Joins in a SQL SELECT Statement\n\nOne case of aggregating multiple nodes into a single SQL SELECT statement is aggregating multiple join expressions into a single SQL SELECT statement. DbJoinExpression represents a single join between two inputs. However, as part of a single SQL SELECT statement, more than one join can be specified. In that case the joins are performed in the order specified.\n\nLeft spine joins, (joins that appear as a left child of another join) can be more easily flattened into a single SQL SELECT statement. For example, consider the following query command tree:\n\n```\nInnerJoin(\n   a = LeftOuterJoin(\n   b = Extent(\"TableA\")\n   c = Extent(\"TableB\")\n   ON b.y = c.x ),\n   d = Extent(\"TableC\")\n   ON a.b.y = d.z\n)\n```\n\nThis can be correctly translated into:\n\n```sql\nSELECT *\nFROM TableA as b\nLEFT OUTER JOIN TableB as c ON b.y = c.x\nINNER JOIN TableC as d ON b.y = d.z\n```\n\nHowever, non-left spine joins cannot easily be flattened, and you should not try to flatten them. For example, the joins in the following query command tree:\n\n```\nInnerJoin(\n   a = Extent(\"TableA\")\n   b = LeftOuterJoin(\n   c = Extent(\"TableB\")\n   d = Extent(\"TableC\")\n   ON c.y = d.x),\n   ON a.z = b.c.y\n)\n```\n\nWould be translated to a SQL SELECT statement with a sub-query.\n\n```sql\nSELECT *\nFROM TableA as a\nINNER JOIN (SELECT *\n   FROM TableB as c\n   LEFT OUTER JOIN TableC as d\n   ON c.y = d.x) as b\nON b.y = d.z\n```\n\n## Input Alias Redirecting\n\nTo explain input alias redirecting, consider the structure of the relational expressions, such as DbFilterExpression, DbProjectExpression, DbCrossJoinExpression, DbJoinExpression, DbSortExpression, DbGroupByExpression, DbApplyExpression, and DbSkipExpression.\n\nEach of these types has one or more Input properties that describe an input collection, and a binding variable corresponding to each input is used to represent each element of that input during a collection traversal. The binding variable is used when referring to the input element, for example in the Predicate property of a DbFilterExpression or the Projection property of a DbProjectExpression.\n\nWhen aggregating more relational expression nodes into a single SQL SELECT statement, and evaluating an expression that is part of a relational expression (for example part of the Projection property of a DbProjectExpression) the binding variable that it uses may not be the same as the alias of the input, as multiple expression bindings would have to be redirected to a single extent.  This problem is called alias renaming.\n\nConsider the first example in this topic. If doing the naïve translation and translating the Projection a.x (DbPropertyExpression(a, x)), it is correct to translate it into `a.x` because we have aliased the input as \"a\" to match the binding variable.  However, when aggregating both the nodes into a single SQL SELECT statement, you need to translate the same DbPropertyExpression into `b.x`, as the input has been aliased with \"b\".\n\n## Join Alias Flattening\n\nUnlike any other relational expression in an output command tree, the DbJoinExpression outputs a result type that is a row consisting of two columns, each of which corresponds to one of the inputs. When a DbPropertyExpression is built to access a scalar property originating from a join, it is over another DbPropertyExpression.\n\nExamples include \"a.b.y\" in example 2 and \"b.c.y\" in example 3. However in the corresponding SQL statements these are referred as \"b.y\". This re-aliasing is called join alias flattening.\n\n## Column Name and Extent Alias Renaming\n\nIf a SQL SELECT query that has a join has to be completed with a projection, when enumerating all the participating columns from the inputs, a name collision may occur, as more than one input may have the same column name. Use a different name for the column to avoid the collision.\n\nAlso, when flattening joins, participating tables (or subqueries) may have colliding aliases in which case these need to be renamed.\n\n## Avoid SELECT *\n\nDo not use `SELECT *` to select from base tables. The storage model in an [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] application may only include a subset of the columns that are in the database table. In this case, `SELECT *` may produce an incorrect result. Instead, you should specify all participating columns by using the column names from the result type of the participating expressions.\n\n## Reuse of Expressions\n\nExpressions may be reused in the query command tree passed by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]. Do not assume that each expression appears only once in the query command tree.\n\n## Mapping Primitive Types\n\nWhen mapping conceptual (EDM) types to provider types, you should map to the widest type (Int32) so that all possible values fit. Also, avoid mapping to types that cannot be used for many operations, like BLOB types (for example, `ntext` in SQL Server).\n\n## See also\n\n- [SQL Generation](../../../../../docs/framework/data/adonet/ef/sql-generation.md)\n","nodes":[{"pos":[4,134],"embed":true,"restype":"x-metadata","content":"title: \"Generating SQL from Command Trees - Best Practices\"\nms.date: \"03/30/2017\"\nms.assetid: 71ef6a24-4c4f-4254-af3a-ffc0d855b0a8","nodes":[{"content":"Generating SQL from Command Trees - Best Practices","nodes":[{"pos":[0,50],"content":"Generating SQL from Command Trees - Best Practices","nodes":[{"content":"Generating SQL from Command Trees - Best Practices","pos":[0,50]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[142,192],"content":"Generating SQL from Command Trees - Best Practices","linkify":"Generating SQL from Command Trees - Best Practices","nodes":[{"content":"Generating SQL from Command Trees - Best Practices","pos":[0,50]}]},{"content":"Output query command trees closely model queries expressible in SQL.","pos":[194,262]},{"content":"However, there are certain common challenges for provider writers when generating SQL from an output command tree.","pos":[263,377]},{"content":"This topic discusses these challenges.","pos":[378,416]},{"content":"In the next topic, the sample provider shows how to address these challenges.","pos":[417,494]},{"pos":[499,549],"content":"Group DbExpression Nodes in a SQL SELECT Statement","linkify":"Group DbExpression Nodes in a SQL SELECT Statement","nodes":[{"content":"Group DbExpression Nodes in a SQL SELECT Statement","pos":[0,50]}]},{"content":"A typical SQL statement has a nested structure of the following shape:","pos":[551,621]},{"content":"One or more clauses may be empty.","pos":[681,714]},{"content":"A nested SELECT statement could occur in any of the lines.","pos":[716,774]},{"content":"A possible translation of a query command tree into a SQL SELECT statement would produce one subquery for every relational operator.","pos":[776,908]},{"content":"However, that would lead to unnecessary nested subqueries that would be difficult to read.","pos":[909,999]},{"content":"On some data stores, the query may perform poorly.","pos":[1001,1051]},{"content":"As an example, consider the following query command tree","pos":[1053,1109]},{"content":"An inefficient translation would produce:","pos":[1197,1238]},{"content":"Note that every relational expression node becomes a new SQL SELECT statement.","pos":[1336,1414]},{"content":"Therefore, it is important to aggregate as many expression nodes as possible into a single SQL SELECT statement while preserving correctness.","pos":[1416,1557]},{"content":"The result of such aggregation for the example presented above would be:","pos":[1559,1631]},{"pos":[1690,1729],"content":"Flatten Joins in a SQL SELECT Statement","linkify":"Flatten Joins in a SQL SELECT Statement","nodes":[{"content":"Flatten Joins in a SQL SELECT Statement","pos":[0,39]}]},{"content":"One case of aggregating multiple nodes into a single SQL SELECT statement is aggregating multiple join expressions into a single SQL SELECT statement.","pos":[1731,1881]},{"content":"DbJoinExpression represents a single join between two inputs.","pos":[1882,1943]},{"content":"However, as part of a single SQL SELECT statement, more than one join can be specified.","pos":[1944,2031]},{"content":"In that case the joins are performed in the order specified.","pos":[2032,2092]},{"content":"Left spine joins, (joins that appear as a left child of another join) can be more easily flattened into a single SQL SELECT statement.","pos":[2094,2228]},{"content":"For example, consider the following query command tree:","pos":[2229,2284]},{"content":"This can be correctly translated into:","pos":[2439,2477]},{"content":"However, non-left spine joins cannot easily be flattened, and you should not try to flatten them.","pos":[2594,2691]},{"content":"For example, the joins in the following query command tree:","pos":[2692,2751]},{"content":"Would be translated to a SQL SELECT statement with a sub-query.","pos":[2905,2968]},{"pos":[3118,3141],"content":"Input Alias Redirecting","linkify":"Input Alias Redirecting","nodes":[{"content":"Input Alias Redirecting","pos":[0,23]}]},{"content":"To explain input alias redirecting, consider the structure of the relational expressions, such as DbFilterExpression, DbProjectExpression, DbCrossJoinExpression, DbJoinExpression, DbSortExpression, DbGroupByExpression, DbApplyExpression, and DbSkipExpression.","pos":[3143,3402]},{"content":"Each of these types has one or more Input properties that describe an input collection, and a binding variable corresponding to each input is used to represent each element of that input during a collection traversal.","pos":[3404,3621]},{"content":"The binding variable is used when referring to the input element, for example in the Predicate property of a DbFilterExpression or the Projection property of a DbProjectExpression.","pos":[3622,3802]},{"content":"When aggregating more relational expression nodes into a single SQL SELECT statement, and evaluating an expression that is part of a relational expression (for example part of the Projection property of a DbProjectExpression) the binding variable that it uses may not be the same as the alias of the input, as multiple expression bindings would have to be redirected to a single extent.","pos":[3804,4190]},{"content":"This problem is called alias renaming.","pos":[4192,4230]},{"content":"Consider the first example in this topic.","pos":[4232,4273]},{"content":"If doing the naïve translation and translating the Projection a.x (DbPropertyExpression(a, x)), it is correct to translate it into <ph id=\"ph1\">`a.x`</ph> because we have aliased the input as \"a\" to match the binding variable.","pos":[4274,4482],"source":" If doing the naïve translation and translating the Projection a.x (DbPropertyExpression(a, x)), it is correct to translate it into `a.x` because we have aliased the input as \"a\" to match the binding variable."},{"content":"However, when aggregating both the nodes into a single SQL SELECT statement, you need to translate the same DbPropertyExpression into <ph id=\"ph1\">`b.x`</ph>, as the input has been aliased with \"b\".","pos":[4484,4664],"source":"  However, when aggregating both the nodes into a single SQL SELECT statement, you need to translate the same DbPropertyExpression into `b.x`, as the input has been aliased with \"b\"."},{"pos":[4669,4690],"content":"Join Alias Flattening","linkify":"Join Alias Flattening","nodes":[{"content":"Join Alias Flattening","pos":[0,21]}]},{"content":"Unlike any other relational expression in an output command tree, the DbJoinExpression outputs a result type that is a row consisting of two columns, each of which corresponds to one of the inputs.","pos":[4692,4889]},{"content":"When a DbPropertyExpression is built to access a scalar property originating from a join, it is over another DbPropertyExpression.","pos":[4890,5020]},{"content":"Examples include \"a.b.y\" in example 2 and \"b.c.y\" in example 3.","pos":[5022,5085]},{"content":"However in the corresponding SQL statements these are referred as \"b.y\".","pos":[5086,5158]},{"content":"This re-aliasing is called join alias flattening.","pos":[5159,5208]},{"pos":[5213,5250],"content":"Column Name and Extent Alias Renaming","linkify":"Column Name and Extent Alias Renaming","nodes":[{"content":"Column Name and Extent Alias Renaming","pos":[0,37]}]},{"content":"If a SQL SELECT query that has a join has to be completed with a projection, when enumerating all the participating columns from the inputs, a name collision may occur, as more than one input may have the same column name.","pos":[5252,5474]},{"content":"Use a different name for the column to avoid the collision.","pos":[5475,5534]},{"content":"Also, when flattening joins, participating tables (or subqueries) may have colliding aliases in which case these need to be renamed.","pos":[5536,5668]},{"pos":[5673,5687],"content":"Avoid SELECT *","linkify":"Avoid SELECT *","nodes":[{"content":"Avoid SELECT *","pos":[0,14]}]},{"content":"Do not use <ph id=\"ph1\">`SELECT *`</ph> to select from base tables.","pos":[5689,5738],"source":"Do not use `SELECT *` to select from base tables."},{"content":"The storage model in an <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph> application may only include a subset of the columns that are in the database table.","pos":[5739,5910],"source":" The storage model in an [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] application may only include a subset of the columns that are in the database table."},{"content":"In this case, <ph id=\"ph1\">`SELECT *`</ph> may produce an incorrect result.","pos":[5911,5968],"source":" In this case, `SELECT *` may produce an incorrect result."},{"content":"Instead, you should specify all participating columns by using the column names from the result type of the participating expressions.","pos":[5969,6103]},{"pos":[6108,6128],"content":"Reuse of Expressions","linkify":"Reuse of Expressions","nodes":[{"content":"Reuse of Expressions","pos":[0,20]}]},{"content":"Expressions may be reused in the query command tree passed by the <ph id=\"ph1\">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]</ph>.","pos":[6130,6259],"source":"Expressions may be reused in the query command tree passed by the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]."},{"content":"Do not assume that each expression appears only once in the query command tree.","pos":[6260,6339]},{"pos":[6344,6367],"content":"Mapping Primitive Types","linkify":"Mapping Primitive Types","nodes":[{"content":"Mapping Primitive Types","pos":[0,23]}]},{"content":"When mapping conceptual (EDM) types to provider types, you should map to the widest type (Int32) so that all possible values fit.","pos":[6369,6498]},{"content":"Also, avoid mapping to types that cannot be used for many operations, like BLOB types (for example, <ph id=\"ph1\">`ntext`</ph> in SQL Server).","pos":[6499,6622],"source":" Also, avoid mapping to types that cannot be used for many operations, like BLOB types (for example, `ntext` in SQL Server)."},{"pos":[6627,6635],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[6639,6719],"content":"<bpt id=\"p1\">[</bpt>SQL Generation<ept id=\"p1\">](../../../../../docs/framework/data/adonet/ef/sql-generation.md)</ept>","source":"[SQL Generation](../../../../../docs/framework/data/adonet/ef/sql-generation.md)"}]}