{"content":"---\ntitle: \"Durable Instance Context | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net-framework\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"dotnet-clr\"\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nms.assetid: 97bc2994-5a2c-47c7-927a-c4cd273153df\ncaps.latest.revision: 12\nauthor: \"Erikre\"\nms.author: \"erikre\"\nmanager: \"erikre\"\n---\n# Durable Instance Context\nThis sample demonstrates how to customize the [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] runtime to enable durable instance contexts. It uses SQL Server 2005 as its backing store (SQL Server 2005 Express in this case). However, it also provides a way to access custom storage mechanisms.  \n  \n> [!NOTE]\n>  The setup procedure and build instructions for this sample are located at the end of this topic.  \n  \n This sample involves extending both the channel layer and the service model layer of the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]. Therefore it is necessary to understand the underlying concepts before going into the implementation details.  \n  \n Durable instance contexts can be found in the real world scenarios quite often. A shopping cart application for example, has the ability to pause shopping halfway through and continue it on another day. So that when we visit the shopping cart the next day, our original context is restored. It is important to note that the shopping cart application (on the server) does not maintain the shopping cart instance while we are disconnected. Instead, it persists its state into a durable storage media and uses it when constructing a new instance for the restored context. Therefore the service instance that may service for the same context is not the same as the previous instance (that is, it does not have the same memory address).  \n  \n Durable instance context is made possible by a small protocol that exchanges a context ID between the client and service. This context ID is created on the client and transmitted to the service. When the service instance is created, the service runtime tries to load the persisted state that corresponds to this context ID from a persistent storage (by default it is a SQL Server 2005 database). If no state is available the new instance has its default state. The service implementation uses a custom attribute to mark operations that change the state of the service implementation so that the runtime can save the service instance after invoking them.  \n  \n By the previous description, two steps can easily be distinguished to achieve the goal:  \n  \n1.  Change the message that goes on the wire to carry the context ID.  \n  \n2.  Change the service local behavior to implement custom instancing logic.  \n  \n Because the first one in the list affects the messages on the wire it should be implemented as a custom channel and be hooked up to the channel layer. The latter only affects the service local behavior and therefore can be implemented by extending several service extensibility points. In the next few sections, each of these extensions are discussed.  \n  \n## Durable InstanceContext Channel  \n The first thing to look at is a channel layer extension. The first step in writing a custom channel is to decide the communication structure of the channel. As a new wire protocol is being introduced the channel should work with almost any other channel in the channel stack. Therefore it should support all the message exchange patterns. However, the core functionality of the channel is the same regardless of its communication structure. More specifically, from the client it should write the context ID to the messages and from the service it should read this context ID from the messages and pass it to the upper levels. Because of that, a `DurableInstanceContextChannelBase` class is created that acts as the abstract base class for all durable instance context channel implementations. This class contains the common state machine management functions and two protected members to apply and read the context information to and from messages.  \n  \n```  \nclass DurableInstanceContextChannelBase  \n{  \n  //…  \n  protected void ApplyContext(Message message)  \n  {  \n    //…              \n  }  \n  protected string ReadContextId(Message message)  \n  {  \n    //…              \n  }  \n}  \n```  \n  \n These two methods make use of `IContextManager` implementations to write and read the context ID to or from the message. (`IContextManager` is a custom interface used to define the contract for all context managers.) The channel can either include the context ID in a custom SOAP header or in a HTTP cookie header. Each context manager implementation inherits from the `ContextManagerBase` class that contains the common functionality for all context managers. The `GetContextId` method in this class is used to originate the context ID from the client. When a context ID is originated for the first time, this method saves it into a text file whose name is constructed by the remote endpoint address (the invalid file name characters in the typical URIs are replaced with @ characters).  \n  \n Later when the context ID is required for the same remote endpoint, it checks whether an appropriate file exists. If it does, it reads the context ID and returns. Otherwise it returns a newly generated context ID and saves it to a file. With the default configuration, these files are placed in a directory called ContextStore, which resides in the current user’s temp directory. However this location is configurable using the binding element.  \n  \n The mechanism used to transport the context ID is configurable. It could be either written to the HTTP cookie header or to a custom SOAP header. The custom SOAP header approach makes it possible to use this protocol with non-HTTP protocols (for example, TCP or Named Pipes). There are two classes, namely `MessageHeaderContextManager` and `HttpCookieContextManager`, which implement these two options.  \n  \n Both of them write the context ID to the message appropriately. For example, the `MessageHeaderContextManager` class writes it to a SOAP header in the `WriteContext` method.  \n  \n```  \npublic override void WriteContext(Message message)  \n{  \n  string contextId = this.GetContextId();  \n  \n  MessageHeader contextHeader =  \n    MessageHeader.CreateHeader(DurableInstanceContextUtility.HeaderName,  \n      DurableInstanceContextUtility.HeaderNamespace,  \n      contextId,   \n      true);  \n  \n  message.Headers.Add(contextHeader);  \n}   \n```  \n  \n Both the `ApplyContext` and `ReadContextId` methods in the `DurableInstanceContextChannelBase` class invoke the `IContextManager.ReadContext` and `IContextManager.WriteContext`, respectively. However, these context managers are not directly created by the `DurableInstanceContextChannelBase` class. Instead it uses the `ContextManagerFactory` class to do that job.  \n  \n```  \nIContextManager contextManager =  \n                ContextManagerFactory.CreateContextManager(contextType,   \n                this.contextStoreLocation,   \n                this.endpointAddress);  \n```  \n  \n The `ApplyContext` method is invoked by the sending channels. It injects the context ID to the outgoing messages. The `ReadContextId` method is invoked by the receiving channels. This method ensures that the context ID is available in the incoming messages and adds it to the `Properties` collection of the `Message` class. It also throws a `CommunicationException` in case of a failure to read the context ID and thus causes the channel to be aborted.  \n  \n```  \nmessage.Properties.Add(DurableInstanceContextUtility.ContextIdProperty, contextId);  \n```  \n  \n Before proceeding, it is important to understand the usage of the `Properties` collection in the `Message` class. Typically, this `Properties` collection is used when passing data from lower to the upper levels from the channel layer. This way the desired data can be provided to the upper levels in a consistent manner regardless of the protocol details. In other words, the channel layer can send and receive the context ID either as a SOAP header or a HTTP cookie header. But it is not necessary for the upper levels to know about these details because the channel layer makes this information available in the `Properties` collection.  \n  \n Now with the `DurableInstanceContextChannelBase` class in place all ten of the necessary interfaces (IOutputChannel, IInputChannel, IOutputSessionChannel, IInputSessionChannel, IRequestChannel, IReplyChannel, IRequestSessionChannel, IReplySessionChannel, IDuplexChannel, IDuplexSessionChannel) must be implemented. They resemble every available message exchange pattern (datagram, simplex, duplex and their sessionful variants). Each of these implementations inherit the base class previously described and calls `ApplyContext` and `ReadContexId` appropriately. For example, `DurableInstanceContextOutputChannel` - which implements the IOutputChannel interface - calls the `ApplyContext` method from each method that sends the messages.  \n  \n```  \npublic void Send(Message message, TimeSpan timeout)  \n{  \n    // Apply the context information before sending the message.  \n    this.ApplyContext(message);  \n    //…  \n}   \n```  \n  \n On the other hand, `DurableInstanceContextInputChannel` - which implements the `IInputChannel` interface - calls the `ReadContextId` method in each method which receives the messages.  \n  \n```  \npublic Message Receive(TimeSpan timeout)  \n{  \n    //…  \n      ReadContextId(message);  \n      return message;  \n}  \n```  \n  \n Apart from this, these channel implementations delegate the method invocations to the channel below them in the channel stack. However, sessionful variants have a basic logic to make sure that the context ID is sent and is read only for the first message that causes the session to be created.  \n  \n```  \nif (isFirstMessage)  \n{  \n//…  \n    this.ApplyContext(message);  \n    isFirstMessage = false;  \n}  \n```  \n  \n These channel implementations are then added to the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel runtime by the `DurableInstanceContextBindingElement` class and `DurableInstanceContextBindingElementSection` class appropriately. See the [HttpCookieSession](../../../../docs/framework/wcf/samples/httpcookiesession.md) channel sample documentation for more details about binding elements and binding element sections.  \n  \n## Service Model Layer Extensions  \n Now that the context ID has traveled through the channel layer, the service behavior can be implemented to customize the instantiation. In this sample, a storage manager is used to load and save state from or to the persistent store. As explained previously, this sample provides a storage manager that uses SQL Server 2005 as its backing store. However, it is also possible to add custom storage mechanisms to this extension. To do that a public interface is declared, which must be implemented by all storage managers.  \n  \n```  \npublic interface IStorageManager  \n{  \n    object GetInstance(string contextId, Type type);  \n    void SaveInstance(string contextId, object state);  \n}  \n```  \n  \n The `SqlServerStorageManager` class contains the default `IStorageManager` implementation. In its `SaveInstance` method the given object is serialized using the XmlSerializer and is saved to the SQL Server database.  \n  \n```  \nXmlSerializer serializer = new XmlSerializer(state.GetType());  \nstring data;  \n  \nusing (StringWriter writer = new StringWriter(CultureInfo.InvariantCulture))  \n{  \n    serializer.Serialize(writer, state);  \n    data = writer.ToString();  \n}  \n  \nusing (SqlConnection connection = new SqlConnection(GetConnectionString()))  \n{  \n    connection.Open();  \n  \n    string update = @\"UPDATE Instances SET Instance = @instance WHERE ContextId = @contextId\";  \n  \n    using (SqlCommand command = new SqlCommand(update, connection))  \n    {  \n        command.Parameters.Add(\"@instance\", SqlDbType.VarChar, 2147483647).Value = data;  \n        command.Parameters.Add(\"@contextId\", SqlDbType.VarChar, 256).Value = contextId;  \n  \n        int rows = command.ExecuteNonQuery();  \n  \n        if (rows == 0)  \n        {  \n            string insert = @\"INSERT INTO Instances(ContextId, Instance) VALUES(@contextId, @instance)\";  \n            command.CommandText = insert;  \n            command.ExecuteNonQuery();  \n        }  \n    }  \n}  \n```  \n  \n In the `GetInstance` method the serialized data is read for a given context ID and the object constructed from it is returned to the caller.  \n  \n```  \nobject data;  \nusing (SqlConnection connection = new SqlConnection(GetConnectionString()))  \n{  \n    connection.Open();  \n  \n    string select = \"SELECT Instance FROM Instances WHERE ContextId = @contextId\";  \n    using (SqlCommand command = new SqlCommand(select, connection))  \n    {  \n        command.Parameters.Add(\"@contextId\", SqlDbType.VarChar, 256).Value = contextId;  \n        data = command.ExecuteScalar();  \n    }  \n}  \n  \nif (data != null)  \n{  \n    XmlSerializer serializer = new XmlSerializer(type);  \n    using (StringReader reader = new StringReader((string)data))  \n    {  \n        object instance = serializer.Deserialize(reader);  \n        return instance;  \n    }  \n}  \n```  \n  \n Users of these storage managers are not supposed to instantiate them directly. They use the `StorageManagerFactory` class, which abstracts from the storage manager creation details. This class has one static member, `GetStorageManager`, which creates an instance of a given storage manager type. If the type parameter is `null`, this method creates an instance of the default `SqlServerStorageManager` class and returns it. It also validates the given type to make sure that it implements the `IStorageManager` interface.  \n  \n```  \npublic static IStorageManager GetStorageManager(Type storageManagerType)  \n{  \nIStorageManager storageManager = null;  \n  \nif (storageManagerType == null)  \n{  \n    return new SqlServerStorageManager();  \n}  \nelse  \n{  \n    object obj = Activator.CreateInstance(storageManagerType);  \n  \n    // Throw if the specified storage manager type does not  \n    // implement IStorageManager.  \n    if (obj is IStorageManager)  \n    {  \n        storageManager = (IStorageManager)obj;  \n    }  \n    else  \n    {  \n        throw new InvalidOperationException(  \n                  ResourceHelper.GetString(\"ExInvalidStorageManager\"));  \n    }  \n  \n    return storageManager;  \n}                  \n}   \n```  \n  \n The necessary infrastructure to read and write instances from the persistent storage is implemented. Now the necessary steps to change the service behavior have to be taken.  \n  \n As the first step of this process we have to save the context ID, which came through the channel layer to the current InstanceContext. InstanceContext is a runtime component that acts as the link between the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] dispatcher and the service instance. It can be used to provide additional state and behavior to the service instance. This is essential because in sessionful communication the context ID is sent only with the first message.  \n  \n [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] allows extending its InstanceContext runtime component by adding a new state and behavior using its extensible object pattern. The extensible object pattern is used in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] to either extend existing runtime classes with new functionality or to add new state features to an object. There are three interfaces in the extensible object pattern - IExtensibleObject\\<T>, IExtension\\<T>, and IExtensionCollection\\<T>:  \n  \n-   The IExtensibleObject\\<T> interface is implemented by objects that allow extensions that customize their functionality.  \n  \n-   The IExtension\\<T> interface is implemented by objects that are extensions of classes of type T.  \n  \n-   The IExtensionCollection\\<T> interface is a collection of IExtensions that allows for retrieving IExtensions by their type.  \n  \n Therefore an InstanceContextExtension class should be created that implements the IExtension interface and defines the required state to save the context ID. This class also provides the state to hold the storage manager being used. Once the new state is saved, it should not be possible to modify it. Therefore the state is provided and saved to the instance at the time it is being constructed and then only accessible using read-only properties.  \n  \n```  \n// Constructor  \npublic DurableInstanceContextExtension(string contextId,   \n            IStorageManager storageManager)  \n{  \n    this.contextId = contextId;  \n    this.storageManager = storageManager;              \n}  \n  \n// Read only properties  \npublic string ContextId  \n{  \n    get { return this.contextId; }  \n}  \n  \npublic IStorageManager StorageManager  \n{  \n    get { return this.storageManager; }              \n}   \n```  \n  \n The InstanceContextInitializer class implements the IInstanceContextInitializer interface and adds the instance context extension to the Extensions collection of the InstanceContext being constructed.  \n  \n```  \npublic void Initialize(InstanceContext instanceContext, Message message)  \n{  \n    string contextId =   \n  (string)message.Properties[DurableInstanceContextUtility.ContextIdProperty];  \n  \n    DurableInstanceContextExtension extension =  \n                new DurableInstanceContextExtension(contextId,   \n                     storageManager);  \n    instanceContext.Extensions.Add(extension);  \n}  \n```  \n  \n As described earlier the context ID is read from the `Properties` collection of the `Message` class and passed to the constructor of the extension class. This demonstrates how information can be exchanged between the layers in a consistent manner.  \n  \n The next important step is overriding the service instance creation process. [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] allows implementing custom instantiation behaviors and hooking them up to the runtime using the IInstanceProvider interface. The new `InstanceProvider` class is implemented to do that job. In the constructor the service type expected from the instance provider is accepted. Later this is used to create new instances. In the `GetInstance` implementation an instance of a storage manager is created looking for a persisted instance. If it returns `null` then a new instance of the service type is instantiated and returned to the caller.  \n  \n```  \npublic object GetInstance(InstanceContext instanceContext, Message message)  \n{  \n    object instance = null;  \n  \n    DurableInstanceContextExtension extension =  \n    instanceContext.Extensions.Find<DurableInstanceContextExtension>();  \n  \n    string contextId = extension.ContextId;  \n    IStorageManager storageManager = extension.StorageManager;              \n  \n    instance = storageManager.GetInstance(contextId, serviceType);          \n  \n    if (instance == null)  \n    {  \n        instance = Activator.CreateInstance(serviceType);  \n    }  \n  \n    return instance;  \n}  \n```  \n  \n The next important step is to install the `InstanceContextExtension`, `InstanceContextInitializer` and `InstanceProvider` classes into the service model runtime. A custom attribute could be used to mark the service implementation classes to install the behavior. The `DurableInstanceContextAttribute` contains the implementation for this attribute and it implements the `IServiceBehavior` interface to extend the entire service runtime.  \n  \n This class has a property that accepts the type of the storage manager to be used. In this way the implementation enables the users to specify their own `IStorageManager` implementation as parameter of this attribute.  \n  \n In the `ApplyDispatchBehavior` implementation the `InstanceContextMode` of the current `ServiceBehavior` attribute is being verified. If this property is set to Singleton, enabling durable instancing is not possible and an `InvalidOperationException` is thrown to notify the host.  \n  \n```  \nServiceBehaviorAttribute serviceBehavior =  \n    serviceDescription.Behaviors.Find<ServiceBehaviorAttribute>();  \n  \nif (serviceBehavior != null &&  \n     serviceBehavior.InstanceContextMode == InstanceContextMode.Single)  \n{  \n    throw new InvalidOperationException(  \n       ResourceHelper.GetString(\"ExSingeltonInstancingNotSupported\"));  \n}  \n```  \n  \n After this the instances of the storage manager, instance context initializer, and the instance provider are created and installed in the `DispatchRuntime` created for every endpoint.  \n  \n```  \nIStorageManager storageManager =   \n    StorageManagerFactory.GetStorageManager(storageManagerType);  \n  \nInstanceContextInitializer contextInitializer =  \n    new InstanceContextInitializer(storageManager);  \n  \nInstanceProvider instanceProvider =  \n    new InstanceProvider(description.ServiceType);  \n  \nforeach (ChannelDispatcherBase cdb in serviceHostBase.ChannelDispatchers)  \n{  \n    ChannelDispatcher cd = cdb as ChannelDispatcher;  \n  \n    if (cd != null)  \n    {  \n        foreach (EndpointDispatcher ed in cd.Endpoints)  \n        {  \n            ed.DispatchRuntime.InstanceContextInitializers.Add(contextInitializer);  \n            ed.DispatchRuntime.InstanceProvider = instanceProvider;  \n        }  \n    }  \n}  \n```  \n  \n In summary so far, this sample has produced a channel that enabled the custom wire protocol for custom context ID exchange and it also overwrites the default instancing behavior to load the instances from the persistent storage.  \n  \n What is left is a way to save the service instance to the persistent storage. As discussed previously, there is already the required functionality to save the state in an `IStorageManager` implementation. We now must integrate this with the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime. Another attribute is required that is applicable to the methods in the service implementation class. This attribute is supposed to be applied to the methods that change the state of the service instance.  \n  \n The `SaveStateAttribute` class implements this functionality. It also implements `IOperationBehavior` class to modify the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime for each operation. When a method is marked with this attribute, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime invokes the `ApplyBehavior` method while the appropriate `DispatchOperation` is being constructed. In this method implementation there is single line of code:  \n  \n```  \ndispatch.Invoker = new OperationInvoker(dispatch.Invoker);  \n```  \n  \n This instruction creates an instance of `OperationInvoker` type and assigns it to the `Invoker` property of the `DispatchOperation` being constructed. The `OperationInvoker` class is a wrapper for the default operation invoker created for the `DispatchOperation`. This class implements the `IOperationInvoker` interface. In the `Invoke` method implementation the actual method invocation is delegated to the inner operation invoker. However, before returning the results the storage manager in the `InstanceContext` is used to save the service instance.  \n  \n```  \nobject result = innerOperationInvoker.Invoke(instance,  \n    inputs, out outputs);  \n  \n// Save the instance using the storage manager saved in the   \n// current InstanceContext.  \nInstanceContextExtension extension =  \n    OperationContext.Current.InstanceContext.Extensions.Find<InstanceContextExtension>();  \n  \nextension.StorageManager.SaveInstance(extension.ContextId, instance);  \nreturn result;  \n```  \n  \n## Using the Extension  \n Both the channel layer and service model layer extensions are done and they can now be used in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] applications. Services have to add the channel into the channel stack using a custom binding and then mark the service implementation classes with the appropriate attributes.  \n  \n```  \n[DurableInstanceContext]  \n[ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]  \npublic class ShoppingCart : IShoppingCart  \n{  \n//…  \n     [SaveState]  \n     public int AddItem(string item)  \n     {  \n         //…  \n     }  \n//…  \n }  \n```  \n  \n Client applications must add the DurableInstanceContextChannel into the channel stack using a custom binding. To configure the channel declaratively in the configuration file, the binding element section has to be added to the binding element extensions collection.  \n  \n```  \n<system.serviceModel>  \n <extensions>  \n   <bindingElementExtensions>  \n     <add name=\"durableInstanceContext\"  \ntype=\"Microsoft.ServiceModel.Samples.DurableInstanceContextBindingElementSection, DurableInstanceContextExtension, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"/>  \n   </bindingElementExtensions>  \n </extensions>  \n```  \n  \n Now the binding element can be used with a custom binding just like other standard binding elements:  \n  \n```  \n<bindings>  \n <customBinding>  \n   <binding name=\"TextOverHttp\">  \n     <durableInstanceContext contextType=\"HttpCookie\"/>             \n     <reliableSession />  \n     <textMessageEncoding />  \n     <httpTransport />  \n   </binding>  \n </customBinding>  \n</bindings>  \n```  \n  \n## Conclusion  \n This sample showed how to create a custom protocol channel and how to customize the service behavior to enable it.  \n  \n The extension can be further improved by letting users specify the `IStorageManager` implementation using a configuration section. This makes it possible to modify the backing store without recompiling the service code.  \n  \n Furthermore you could try to implement a class (for example, `StateBag`), which encapsulates the state of the instance. That class is responsible for persisting the state whenever it changes. This way you can avoid using the `SaveState` attribute and perform the persisting work more accurately (for example, you could persist the state when the state is actually changed rather than saving it each time when a method with the `SaveState` attribute is called).  \n  \n When you run the sample, the following output is displayed. The client adds two items to its shopping cart and then gets the list of items in its shopping cart from the service. Press ENTER in each console window to shut down the service and client.  \n  \n```  \nEnter the name of the product: apples  \nEnter the name of the product: bananas  \n  \nShopping cart currently contains the following items.  \napples  \nbananas  \nPress ENTER to shut down client  \n```  \n  \n> [!NOTE]\n>  Rebuilding the service overwrites the database file. To observe state preserved across multiple runs of the sample, be sure not to rebuild the sample between runs.  \n  \n#### To set up, build, and run the sample  \n  \n1.  Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md).  \n  \n2.  To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md).  \n  \n3.  To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md).  \n  \n> [!NOTE]\n>  You must be running SQL Server 2005 or SQL Express 2005 to run this sample. If you are running SQL Server 2005, you must modify the configuration of the service's connection string. When running cross-machine, SQL Server is only required on the server machine.  \n  \n> [!IMPORTANT]\n>  The samples may already be installed on your machine. Check for the following (default) directory before continuing.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples`  \n>   \n>  If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](http://go.microsoft.com/fwlink/?LinkId=150780) to download all [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples. This sample is located in the following directory.  \n>   \n>  `<InstallDrive>:\\WF_WCF_Samples\\WCF\\Extensibility\\Instancing\\Durable`  \n  \n## See Also","nodes":[{"pos":[12,53],"content":"Durable Instance Context | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Durable Instance Context | Microsoft Docs","pos":[0,41]}]},{"pos":[352,376],"content":"Durable Instance Context","linkify":"Durable Instance Context","nodes":[{"content":"Durable Instance Context","pos":[0,24]}]},{"content":"This sample demonstrates how to customize the <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> runtime to enable durable instance contexts.","pos":[377,523],"source":"This sample demonstrates how to customize the [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] runtime to enable durable instance contexts."},{"content":"It uses SQL Server 2005 as its backing store (SQL Server 2005 Express in this case).","pos":[524,608]},{"content":"However, it also provides a way to access custom storage mechanisms.","pos":[609,677]},{"pos":[685,792],"content":"[!NOTE]\n The setup procedure and build instructions for this sample are located at the end of this topic.","leadings":["","> "],"nodes":[{"content":"The setup procedure and build instructions for this sample are located at the end of this topic.","pos":[9,105]}]},{"content":"This sample involves extending both the channel layer and the service model layer of the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.","pos":[799,944],"source":"This sample involves extending both the channel layer and the service model layer of the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]."},{"content":"Therefore it is necessary to understand the underlying concepts before going into the implementation details.","pos":[945,1054]},{"content":"Durable instance contexts can be found in the real world scenarios quite often.","pos":[1061,1140]},{"content":"A shopping cart application for example, has the ability to pause shopping halfway through and continue it on another day.","pos":[1141,1263]},{"content":"So that when we visit the shopping cart the next day, our original context is restored.","pos":[1264,1351]},{"content":"It is important to note that the shopping cart application (on the server) does not maintain the shopping cart instance while we are disconnected.","pos":[1352,1498]},{"content":"Instead, it persists its state into a durable storage media and uses it when constructing a new instance for the restored context.","pos":[1499,1629]},{"content":"Therefore the service instance that may service for the same context is not the same as the previous instance (that is, it does not have the same memory address).","pos":[1630,1792]},{"content":"Durable instance context is made possible by a small protocol that exchanges a context ID between the client and service.","pos":[1799,1920]},{"content":"This context ID is created on the client and transmitted to the service.","pos":[1921,1993]},{"content":"When the service instance is created, the service runtime tries to load the persisted state that corresponds to this context ID from a persistent storage (by default it is a SQL Server 2005 database).","pos":[1994,2194]},{"content":"If no state is available the new instance has its default state.","pos":[2195,2259]},{"content":"The service implementation uses a custom attribute to mark operations that change the state of the service implementation so that the runtime can save the service instance after invoking them.","pos":[2260,2452]},{"content":"By the previous description, two steps can easily be distinguished to achieve the goal:","pos":[2459,2546]},{"content":"Change the message that goes on the wire to carry the context ID.","pos":[2556,2621]},{"content":"Change the service local behavior to implement custom instancing logic.","pos":[2631,2702]},{"content":"Because the first one in the list affects the messages on the wire it should be implemented as a custom channel and be hooked up to the channel layer.","pos":[2709,2859]},{"content":"The latter only affects the service local behavior and therefore can be implemented by extending several service extensibility points.","pos":[2860,2994]},{"content":"In the next few sections, each of these extensions are discussed.","pos":[2995,3060]},{"pos":[3069,3100],"content":"Durable InstanceContext Channel","linkify":"Durable InstanceContext Channel","nodes":[{"content":"Durable InstanceContext Channel","pos":[0,31]}]},{"content":"The first thing to look at is a channel layer extension.","pos":[3104,3160]},{"content":"The first step in writing a custom channel is to decide the communication structure of the channel.","pos":[3161,3260]},{"content":"As a new wire protocol is being introduced the channel should work with almost any other channel in the channel stack.","pos":[3261,3379]},{"content":"Therefore it should support all the message exchange patterns.","pos":[3380,3442]},{"content":"However, the core functionality of the channel is the same regardless of its communication structure.","pos":[3443,3544]},{"content":"More specifically, from the client it should write the context ID to the messages and from the service it should read this context ID from the messages and pass it to the upper levels.","pos":[3545,3729]},{"content":"Because of that, a <ph id=\"ph1\">`DurableInstanceContextChannelBase`</ph> class is created that acts as the abstract base class for all durable instance context channel implementations.","pos":[3730,3896],"source":" Because of that, a `DurableInstanceContextChannelBase` class is created that acts as the abstract base class for all durable instance context channel implementations."},{"content":"This class contains the common state machine management functions and two protected members to apply and read the context information to and from messages.","pos":[3897,4052]},{"content":"These two methods make use of <ph id=\"ph1\">`IContextManager`</ph> implementations to write and read the context ID to or from the message.","pos":[4301,4421],"source":"These two methods make use of `IContextManager` implementations to write and read the context ID to or from the message."},{"content":"(<ph id=\"ph1\">`IContextManager`</ph> is a custom interface used to define the contract for all context managers.) The channel can either include the context ID in a custom SOAP header or in a HTTP cookie header.","pos":[4422,4615],"source":" (`IContextManager` is a custom interface used to define the contract for all context managers.) The channel can either include the context ID in a custom SOAP header or in a HTTP cookie header."},{"content":"Each context manager implementation inherits from the <ph id=\"ph1\">`ContextManagerBase`</ph> class that contains the common functionality for all context managers.","pos":[4616,4761],"source":" Each context manager implementation inherits from the `ContextManagerBase` class that contains the common functionality for all context managers."},{"content":"The <ph id=\"ph1\">`GetContextId`</ph> method in this class is used to originate the context ID from the client.","pos":[4762,4854],"source":" The `GetContextId` method in this class is used to originate the context ID from the client."},{"content":"When a context ID is originated for the first time, this method saves it into a text file whose name is constructed by the remote endpoint address (the invalid file name characters in the typical URIs are replaced with @ characters).","pos":[4855,5088]},{"content":"Later when the context ID is required for the same remote endpoint, it checks whether an appropriate file exists.","pos":[5095,5208]},{"content":"If it does, it reads the context ID and returns.","pos":[5209,5257]},{"content":"Otherwise it returns a newly generated context ID and saves it to a file.","pos":[5258,5331]},{"content":"With the default configuration, these files are placed in a directory called ContextStore, which resides in the current user’s temp directory.","pos":[5332,5474]},{"content":"However this location is configurable using the binding element.","pos":[5475,5539]},{"content":"The mechanism used to transport the context ID is configurable.","pos":[5546,5609]},{"content":"It could be either written to the HTTP cookie header or to a custom SOAP header.","pos":[5610,5690]},{"content":"The custom SOAP header approach makes it possible to use this protocol with non-HTTP protocols (for example, TCP or Named Pipes).","pos":[5691,5820]},{"content":"There are two classes, namely <ph id=\"ph1\">`MessageHeaderContextManager`</ph> and <ph id=\"ph2\">`HttpCookieContextManager`</ph>, which implement these two options.","pos":[5821,5947],"source":" There are two classes, namely `MessageHeaderContextManager` and `HttpCookieContextManager`, which implement these two options."},{"content":"Both of them write the context ID to the message appropriately.","pos":[5954,6017]},{"content":"For example, the <ph id=\"ph1\">`MessageHeaderContextManager`</ph> class writes it to a SOAP header in the <ph id=\"ph2\">`WriteContext`</ph> method.","pos":[6018,6127],"source":" For example, the `MessageHeaderContextManager` class writes it to a SOAP header in the `WriteContext` method."},{"content":"Both the <ph id=\"ph1\">`ApplyContext`</ph> and <ph id=\"ph2\">`ReadContextId`</ph> methods in the <ph id=\"ph3\">`DurableInstanceContextChannelBase`</ph> class invoke the <ph id=\"ph4\">`IContextManager.ReadContext`</ph> and <ph id=\"ph5\">`IContextManager.WriteContext`</ph>, respectively.","pos":[6500,6691],"source":"Both the `ApplyContext` and `ReadContextId` methods in the `DurableInstanceContextChannelBase` class invoke the `IContextManager.ReadContext` and `IContextManager.WriteContext`, respectively."},{"content":"However, these context managers are not directly created by the <ph id=\"ph1\">`DurableInstanceContextChannelBase`</ph> class.","pos":[6692,6798],"source":" However, these context managers are not directly created by the `DurableInstanceContextChannelBase` class."},{"content":"Instead it uses the <ph id=\"ph1\">`ContextManagerFactory`</ph> class to do that job.","pos":[6799,6864],"source":" Instead it uses the `ContextManagerFactory` class to do that job."},{"content":"The <ph id=\"ph1\">`ApplyContext`</ph> method is invoked by the sending channels.","pos":[7083,7144],"source":"The `ApplyContext` method is invoked by the sending channels."},{"content":"It injects the context ID to the outgoing messages.","pos":[7145,7196]},{"content":"The <ph id=\"ph1\">`ReadContextId`</ph> method is invoked by the receiving channels.","pos":[7197,7261],"source":" The `ReadContextId` method is invoked by the receiving channels."},{"content":"This method ensures that the context ID is available in the incoming messages and adds it to the <ph id=\"ph1\">`Properties`</ph> collection of the <ph id=\"ph2\">`Message`</ph> class.","pos":[7262,7406],"source":" This method ensures that the context ID is available in the incoming messages and adds it to the `Properties` collection of the `Message` class."},{"content":"It also throws a <ph id=\"ph1\">`CommunicationException`</ph> in case of a failure to read the context ID and thus causes the channel to be aborted.","pos":[7407,7535],"source":" It also throws a `CommunicationException` in case of a failure to read the context ID and thus causes the channel to be aborted."},{"content":"Before proceeding, it is important to understand the usage of the <ph id=\"ph1\">`Properties`</ph> collection in the <ph id=\"ph2\">`Message`</ph> class.","pos":[7643,7756],"source":"Before proceeding, it is important to understand the usage of the `Properties` collection in the `Message` class."},{"content":"Typically, this <ph id=\"ph1\">`Properties`</ph> collection is used when passing data from lower to the upper levels from the channel layer.","pos":[7757,7877],"source":" Typically, this `Properties` collection is used when passing data from lower to the upper levels from the channel layer."},{"content":"This way the desired data can be provided to the upper levels in a consistent manner regardless of the protocol details.","pos":[7878,7998]},{"content":"In other words, the channel layer can send and receive the context ID either as a SOAP header or a HTTP cookie header.","pos":[7999,8117]},{"content":"But it is not necessary for the upper levels to know about these details because the channel layer makes this information available in the <ph id=\"ph1\">`Properties`</ph> collection.","pos":[8118,8281],"source":" But it is not necessary for the upper levels to know about these details because the channel layer makes this information available in the `Properties` collection."},{"content":"Now with the <ph id=\"ph1\">`DurableInstanceContextChannelBase`</ph> class in place all ten of the necessary interfaces (IOutputChannel, IInputChannel, IOutputSessionChannel, IInputSessionChannel, IRequestChannel, IReplyChannel, IRequestSessionChannel, IReplySessionChannel, IDuplexChannel, IDuplexSessionChannel) must be implemented.","pos":[8288,8602],"source":"Now with the `DurableInstanceContextChannelBase` class in place all ten of the necessary interfaces (IOutputChannel, IInputChannel, IOutputSessionChannel, IInputSessionChannel, IRequestChannel, IReplyChannel, IRequestSessionChannel, IReplySessionChannel, IDuplexChannel, IDuplexSessionChannel) must be implemented."},{"content":"They resemble every available message exchange pattern (datagram, simplex, duplex and their sessionful variants).","pos":[8603,8716]},{"content":"Each of these implementations inherit the base class previously described and calls <ph id=\"ph1\">`ApplyContext`</ph> and <ph id=\"ph2\">`ReadContexId`</ph> appropriately.","pos":[8717,8849],"source":" Each of these implementations inherit the base class previously described and calls `ApplyContext` and `ReadContexId` appropriately."},{"content":"For example, <ph id=\"ph1\">`DurableInstanceContextOutputChannel`</ph> - which implements the IOutputChannel interface - calls the <ph id=\"ph2\">`ApplyContext`</ph> method from each method that sends the messages.","pos":[8850,9024],"source":" For example, `DurableInstanceContextOutputChannel` - which implements the IOutputChannel interface - calls the `ApplyContext` method from each method that sends the messages."},{"pos":[9220,9403],"content":"On the other hand, <ph id=\"ph1\">`DurableInstanceContextInputChannel`</ph> - which implements the <ph id=\"ph2\">`IInputChannel`</ph> interface - calls the <ph id=\"ph3\">`ReadContextId`</ph> method in each method which receives the messages.","source":"On the other hand, `DurableInstanceContextInputChannel` - which implements the `IInputChannel` interface - calls the `ReadContextId` method in each method which receives the messages."},{"content":"Apart from this, these channel implementations delegate the method invocations to the channel below them in the channel stack.","pos":[9542,9668]},{"content":"However, sessionful variants have a basic logic to make sure that the context ID is sent and is read only for the first message that causes the session to be created.","pos":[9669,9835]},{"content":"These channel implementations are then added to the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> channel runtime by the <ph id=\"ph2\">`DurableInstanceContextBindingElement`</ph> class and <ph id=\"ph3\">`DurableInstanceContextBindingElementSection`</ph> class appropriately.","pos":[9957,10203],"source":"These channel implementations are then added to the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel runtime by the `DurableInstanceContextBindingElement` class and `DurableInstanceContextBindingElementSection` class appropriately."},{"content":"See the <bpt id=\"p1\">[</bpt>HttpCookieSession<ept id=\"p1\">](../../../../docs/framework/wcf/samples/httpcookiesession.md)</ept> channel sample documentation for more details about binding elements and binding element sections.","pos":[10204,10391],"source":" See the [HttpCookieSession](../../../../docs/framework/wcf/samples/httpcookiesession.md) channel sample documentation for more details about binding elements and binding element sections."},{"pos":[10400,10430],"content":"Service Model Layer Extensions","linkify":"Service Model Layer Extensions","nodes":[{"content":"Service Model Layer Extensions","pos":[0,30]}]},{"content":"Now that the context ID has traveled through the channel layer, the service behavior can be implemented to customize the instantiation.","pos":[10434,10569]},{"content":"In this sample, a storage manager is used to load and save state from or to the persistent store.","pos":[10570,10667]},{"content":"As explained previously, this sample provides a storage manager that uses SQL Server 2005 as its backing store.","pos":[10668,10779]},{"content":"However, it is also possible to add custom storage mechanisms to this extension.","pos":[10780,10860]},{"content":"To do that a public interface is declared, which must be implemented by all storage managers.","pos":[10861,10954]},{"content":"The <ph id=\"ph1\">`SqlServerStorageManager`</ph> class contains the default <ph id=\"ph2\">`IStorageManager`</ph> implementation.","pos":[11131,11221],"source":"The `SqlServerStorageManager` class contains the default `IStorageManager` implementation."},{"content":"In its <ph id=\"ph1\">`SaveInstance`</ph> method the given object is serialized using the XmlSerializer and is saved to the SQL Server database.","pos":[11222,11346],"source":" In its `SaveInstance` method the given object is serialized using the XmlSerializer and is saved to the SQL Server database."},{"pos":[12392,12532],"content":"In the <ph id=\"ph1\">`GetInstance`</ph> method the serialized data is read for a given context ID and the object constructed from it is returned to the caller.","source":"In the `GetInstance` method the serialized data is read for a given context ID and the object constructed from it is returned to the caller."},{"content":"Users of these storage managers are not supposed to instantiate them directly.","pos":[13245,13323]},{"content":"They use the <ph id=\"ph1\">`StorageManagerFactory`</ph> class, which abstracts from the storage manager creation details.","pos":[13324,13426],"source":" They use the `StorageManagerFactory` class, which abstracts from the storage manager creation details."},{"content":"This class has one static member, <ph id=\"ph1\">`GetStorageManager`</ph>, which creates an instance of a given storage manager type.","pos":[13427,13540],"source":" This class has one static member, `GetStorageManager`, which creates an instance of a given storage manager type."},{"content":"If the type parameter is <ph id=\"ph1\">`null`</ph>, this method creates an instance of the default <ph id=\"ph2\">`SqlServerStorageManager`</ph> class and returns it.","pos":[13541,13668],"source":" If the type parameter is `null`, this method creates an instance of the default `SqlServerStorageManager` class and returns it."},{"content":"It also validates the given type to make sure that it implements the <ph id=\"ph1\">`IStorageManager`</ph> interface.","pos":[13669,13766],"source":" It also validates the given type to make sure that it implements the `IStorageManager` interface."},{"content":"The necessary infrastructure to read and write instances from the persistent storage is implemented.","pos":[14478,14578]},{"content":"Now the necessary steps to change the service behavior have to be taken.","pos":[14579,14651]},{"content":"As the first step of this process we have to save the context ID, which came through the channel layer to the current InstanceContext.","pos":[14658,14792]},{"content":"InstanceContext is a runtime component that acts as the link between the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> dispatcher and the service instance.","pos":[14793,14958],"source":" InstanceContext is a runtime component that acts as the link between the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] dispatcher and the service instance."},{"content":"It can be used to provide additional state and behavior to the service instance.","pos":[14959,15039]},{"content":"This is essential because in sessionful communication the context ID is sent only with the first message.","pos":[15040,15145]},{"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> allows extending its InstanceContext runtime component by adding a new state and behavior using its extensible object pattern.","pos":[15152,15334],"source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] allows extending its InstanceContext runtime component by adding a new state and behavior using its extensible object pattern."},{"content":"The extensible object pattern is used in <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> to either extend existing runtime classes with new functionality or to add new state features to an object.","pos":[15335,15539],"source":" The extensible object pattern is used in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] to either extend existing runtime classes with new functionality or to add new state features to an object."},{"content":"There are three interfaces in the extensible object pattern - IExtensibleObject<ph id=\"ph1\">\\&lt;</ph>T&gt;, IExtension<ph id=\"ph2\">\\&lt;</ph>T&gt;, and IExtensionCollection<ph id=\"ph3\">\\&lt;</ph>T&gt;:","pos":[15540,15670],"source":" There are three interfaces in the extensible object pattern - IExtensibleObject\\<T>, IExtension\\<T>, and IExtensionCollection\\<T>:"},{"content":"The IExtensibleObject<ph id=\"ph1\">\\&lt;</ph>T&gt; interface is implemented by objects that allow extensions that customize their functionality.","pos":[15680,15799],"source":"The IExtensibleObject\\<T> interface is implemented by objects that allow extensions that customize their functionality."},{"content":"The IExtension<ph id=\"ph1\">\\&lt;</ph>T&gt; interface is implemented by objects that are extensions of classes of type T.","pos":[15809,15905],"source":"The IExtension\\<T> interface is implemented by objects that are extensions of classes of type T."},{"content":"The IExtensionCollection<ph id=\"ph1\">\\&lt;</ph>T&gt; interface is a collection of IExtensions that allows for retrieving IExtensions by their type.","pos":[15915,16038],"source":"The IExtensionCollection\\<T> interface is a collection of IExtensions that allows for retrieving IExtensions by their type."},{"content":"Therefore an InstanceContextExtension class should be created that implements the IExtension interface and defines the required state to save the context ID.","pos":[16045,16202]},{"content":"This class also provides the state to hold the storage manager being used.","pos":[16203,16277]},{"content":"Once the new state is saved, it should not be possible to modify it.","pos":[16278,16346]},{"content":"Therefore the state is provided and saved to the instance at the time it is being constructed and then only accessible using read-only properties.","pos":[16347,16493]},{"content":"The InstanceContextInitializer class implements the IInstanceContextInitializer interface and adds the instance context extension to the Extensions collection of the InstanceContext being constructed.","pos":[16942,17142]},{"content":"As described earlier the context ID is read from the <ph id=\"ph1\">`Properties`</ph> collection of the <ph id=\"ph2\">`Message`</ph> class and passed to the constructor of the extension class.","pos":[17562,17715],"source":"As described earlier the context ID is read from the `Properties` collection of the `Message` class and passed to the constructor of the extension class."},{"content":"This demonstrates how information can be exchanged between the layers in a consistent manner.","pos":[17716,17809]},{"content":"The next important step is overriding the service instance creation process.","pos":[17816,17892]},{"content":"<ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> allows implementing custom instantiation behaviors and hooking them up to the runtime using the IInstanceProvider interface.","pos":[17893,18073],"source":"[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] allows implementing custom instantiation behaviors and hooking them up to the runtime using the IInstanceProvider interface."},{"content":"The new <ph id=\"ph1\">`InstanceProvider`</ph> class is implemented to do that job.","pos":[18074,18137],"source":" The new `InstanceProvider` class is implemented to do that job."},{"content":"In the constructor the service type expected from the instance provider is accepted.","pos":[18138,18222]},{"content":"Later this is used to create new instances.","pos":[18223,18266]},{"content":"In the <ph id=\"ph1\">`GetInstance`</ph> implementation an instance of a storage manager is created looking for a persisted instance.","pos":[18267,18380],"source":" In the `GetInstance` implementation an instance of a storage manager is created looking for a persisted instance."},{"content":"If it returns <ph id=\"ph1\">`null`</ph> then a new instance of the service type is instantiated and returned to the caller.","pos":[18381,18485],"source":" If it returns `null` then a new instance of the service type is instantiated and returned to the caller."},{"content":"The next important step is to install the <ph id=\"ph1\">`InstanceContextExtension`</ph>, <ph id=\"ph2\">`InstanceContextInitializer`</ph> and <ph id=\"ph3\">`InstanceProvider`</ph> classes into the service model runtime.","pos":[19089,19250],"source":"The next important step is to install the `InstanceContextExtension`, `InstanceContextInitializer` and `InstanceProvider` classes into the service model runtime."},{"content":"A custom attribute could be used to mark the service implementation classes to install the behavior.","pos":[19251,19351]},{"content":"The <ph id=\"ph1\">`DurableInstanceContextAttribute`</ph> contains the implementation for this attribute and it implements the <ph id=\"ph2\">`IServiceBehavior`</ph> interface to extend the entire service runtime.","pos":[19352,19525],"source":" The `DurableInstanceContextAttribute` contains the implementation for this attribute and it implements the `IServiceBehavior` interface to extend the entire service runtime."},{"content":"This class has a property that accepts the type of the storage manager to be used.","pos":[19532,19614]},{"content":"In this way the implementation enables the users to specify their own <ph id=\"ph1\">`IStorageManager`</ph> implementation as parameter of this attribute.","pos":[19615,19749],"source":" In this way the implementation enables the users to specify their own `IStorageManager` implementation as parameter of this attribute."},{"content":"In the <ph id=\"ph1\">`ApplyDispatchBehavior`</ph> implementation the <ph id=\"ph2\">`InstanceContextMode`</ph> of the current <ph id=\"ph3\">`ServiceBehavior`</ph> attribute is being verified.","pos":[19756,19889],"source":"In the `ApplyDispatchBehavior` implementation the `InstanceContextMode` of the current `ServiceBehavior` attribute is being verified."},{"content":"If this property is set to Singleton, enabling durable instancing is not possible and an <ph id=\"ph1\">`InvalidOperationException`</ph> is thrown to notify the host.","pos":[19890,20036],"source":" If this property is set to Singleton, enabling durable instancing is not possible and an `InvalidOperationException` is thrown to notify the host."},{"pos":[20406,20589],"content":"After this the instances of the storage manager, instance context initializer, and the instance provider are created and installed in the <ph id=\"ph1\">`DispatchRuntime`</ph> created for every endpoint.","source":"After this the instances of the storage manager, instance context initializer, and the instance provider are created and installed in the `DispatchRuntime` created for every endpoint."},{"content":"In summary so far, this sample has produced a channel that enabled the custom wire protocol for custom context ID exchange and it also overwrites the default instancing behavior to load the instances from the persistent storage.","pos":[21336,21564]},{"content":"What is left is a way to save the service instance to the persistent storage.","pos":[21571,21648]},{"content":"As discussed previously, there is already the required functionality to save the state in an <ph id=\"ph1\">`IStorageManager`</ph> implementation.","pos":[21649,21775],"source":" As discussed previously, there is already the required functionality to save the state in an `IStorageManager` implementation."},{"content":"We now must integrate this with the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime.","pos":[21776,21876],"source":" We now must integrate this with the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime."},{"content":"Another attribute is required that is applicable to the methods in the service implementation class.","pos":[21877,21977]},{"content":"This attribute is supposed to be applied to the methods that change the state of the service instance.","pos":[21978,22080]},{"content":"The <ph id=\"ph1\">`SaveStateAttribute`</ph> class implements this functionality.","pos":[22087,22148],"source":"The `SaveStateAttribute` class implements this functionality."},{"content":"It also implements <ph id=\"ph1\">`IOperationBehavior`</ph> class to modify the <ph id=\"ph2\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime for each operation.","pos":[22149,22292],"source":" It also implements `IOperationBehavior` class to modify the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime for each operation."},{"content":"When a method is marked with this attribute, the <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> runtime invokes the <ph id=\"ph2\">`ApplyBehavior`</ph> method while the appropriate <ph id=\"ph3\">`DispatchOperation`</ph> is being constructed.","pos":[22293,22504],"source":" When a method is marked with this attribute, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] runtime invokes the `ApplyBehavior` method while the appropriate `DispatchOperation` is being constructed."},{"content":"In this method implementation there is single line of code:","pos":[22505,22564]},{"content":"This instruction creates an instance of <ph id=\"ph1\">`OperationInvoker`</ph> type and assigns it to the <ph id=\"ph2\">`Invoker`</ph> property of the <ph id=\"ph3\">`DispatchOperation`</ph> being constructed.","pos":[22647,22797],"source":"This instruction creates an instance of `OperationInvoker` type and assigns it to the `Invoker` property of the `DispatchOperation` being constructed."},{"content":"The <ph id=\"ph1\">`OperationInvoker`</ph> class is a wrapper for the default operation invoker created for the <ph id=\"ph2\">`DispatchOperation`</ph>.","pos":[22798,22910],"source":" The `OperationInvoker` class is a wrapper for the default operation invoker created for the `DispatchOperation`."},{"content":"This class implements the <ph id=\"ph1\">`IOperationInvoker`</ph> interface.","pos":[22911,22967],"source":" This class implements the `IOperationInvoker` interface."},{"content":"In the <ph id=\"ph1\">`Invoke`</ph> method implementation the actual method invocation is delegated to the inner operation invoker.","pos":[22968,23079],"source":" In the `Invoke` method implementation the actual method invocation is delegated to the inner operation invoker."},{"content":"However, before returning the results the storage manager in the <ph id=\"ph1\">`InstanceContext`</ph> is used to save the service instance.","pos":[23080,23200],"source":" However, before returning the results the storage manager in the `InstanceContext` is used to save the service instance."},{"pos":[23628,23647],"content":"Using the Extension","linkify":"Using the Extension","nodes":[{"content":"Using the Extension","pos":[0,19]}]},{"content":"Both the channel layer and service model layer extensions are done and they can now be used in <ph id=\"ph1\">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> applications.","pos":[23651,23815],"source":"Both the channel layer and service model layer extensions are done and they can now be used in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] applications."},{"content":"Services have to add the channel into the channel stack using a custom binding and then mark the service implementation classes with the appropriate attributes.","pos":[23816,23976]},{"content":"Client applications must add the DurableInstanceContextChannel into the channel stack using a custom binding.","pos":[24253,24362]},{"content":"To configure the channel declaratively in the configuration file, the binding element section has to be added to the binding element extensions collection.","pos":[24363,24518]},{"content":"Now the binding element can be used with a custom binding just like other standard binding elements:","pos":[24878,24978]},{"pos":[25271,25281],"content":"Conclusion","linkify":"Conclusion","nodes":[{"content":"Conclusion","pos":[0,10]}]},{"content":"This sample showed how to create a custom protocol channel and how to customize the service behavior to enable it.","pos":[25285,25399]},{"content":"The extension can be further improved by letting users specify the <ph id=\"ph1\">`IStorageManager`</ph> implementation using a configuration section.","pos":[25406,25536],"source":"The extension can be further improved by letting users specify the `IStorageManager` implementation using a configuration section."},{"content":"This makes it possible to modify the backing store without recompiling the service code.","pos":[25537,25625]},{"content":"Furthermore you could try to implement a class (for example, <ph id=\"ph1\">`StateBag`</ph>), which encapsulates the state of the instance.","pos":[25632,25751],"source":"Furthermore you could try to implement a class (for example, `StateBag`), which encapsulates the state of the instance."},{"content":"That class is responsible for persisting the state whenever it changes.","pos":[25752,25823]},{"content":"This way you can avoid using the <ph id=\"ph1\">`SaveState`</ph> attribute and perform the persisting work more accurately (for example, you could persist the state when the state is actually changed rather than saving it each time when a method with the <ph id=\"ph2\">`SaveState`</ph> attribute is called).","pos":[25824,26092],"source":" This way you can avoid using the `SaveState` attribute and perform the persisting work more accurately (for example, you could persist the state when the state is actually changed rather than saving it each time when a method with the `SaveState` attribute is called)."},{"content":"When you run the sample, the following output is displayed.","pos":[26099,26158]},{"content":"The client adds two items to its shopping cart and then gets the list of items in its shopping cart from the service.","pos":[26159,26276]},{"content":"Press ENTER in each console window to shut down the service and client.","pos":[26277,26348]},{"pos":[26564,26738],"content":"[!NOTE]\n Rebuilding the service overwrites the database file. To observe state preserved across multiple runs of the sample, be sure not to rebuild the sample between runs.","leadings":["","> "],"nodes":[{"content":" Rebuilding the service overwrites the database file. To observe state preserved across multiple runs of the sample, be sure not to rebuild the sample between runs.","pos":[8,172],"nodes":[{"content":"Rebuilding the service overwrites the database file.","pos":[1,53]},{"content":"To observe state preserved across multiple runs of the sample, be sure not to rebuild the sample between runs.","pos":[54,164]}]}]},{"pos":[26749,26785],"content":"To set up, build, and run the sample","linkify":"To set up, build, and run the sample","nodes":[{"content":"To set up, build, and run the sample","pos":[0,36]}]},{"pos":[26795,26994],"content":"Ensure that you have performed the <bpt id=\"p1\">[</bpt>One-Time Setup Procedure for the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)</ept>.","source":"Ensure that you have performed the [One-Time Setup Procedure for the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/one-time-setup-procedure-for-the-wcf-samples.md)."},{"pos":[27004,27174],"content":"To build the solution, follow the instructions in <bpt id=\"p1\">[</bpt>Building the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/building-the-samples.md)</ept>.","source":"To build the solution, follow the instructions in [Building the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/building-the-samples.md)."},{"pos":[27184,27392],"content":"To run the sample in a single- or cross-machine configuration, follow the instructions in <bpt id=\"p1\">[</bpt>Running the Windows Communication Foundation Samples<ept id=\"p1\">](../../../../docs/framework/wcf/samples/running-the-samples.md)</ept>.","source":"To run the sample in a single- or cross-machine configuration, follow the instructions in [Running the Windows Communication Foundation Samples](../../../../docs/framework/wcf/samples/running-the-samples.md)."},{"pos":[27400,27671],"content":"[!NOTE]\n You must be running SQL Server 2005 or SQL Express 2005 to run this sample. If you are running SQL Server 2005, you must modify the configuration of the service's connection string. When running cross-machine, SQL Server is only required on the server machine.","leadings":["","> "],"nodes":[{"content":" You must be running SQL Server 2005 or SQL Express 2005 to run this sample. If you are running SQL Server 2005, you must modify the configuration of the service's connection string. When running cross-machine, SQL Server is only required on the server machine.","pos":[8,269],"nodes":[{"content":"You must be running SQL Server 2005 or SQL Express 2005 to run this sample.","pos":[1,76]},{"content":"If you are running SQL Server 2005, you must modify the configuration of the service's connection string.","pos":[77,182]},{"content":"When running cross-machine, SQL Server is only required on the server machine.","pos":[183,261]}]}]},{"pos":[27679,27811],"content":"[!IMPORTANT]\n The samples may already be installed on your machine. Check for the following (default) directory before continuing.","leadings":["","> "],"nodes":[{"content":" The samples may already be installed on your machine. Check for the following (default) directory before continuing.","pos":[13,130],"nodes":[{"content":"The samples may already be installed on your machine.","pos":[1,54]},{"content":"Check for the following (default) directory before continuing.","pos":[55,117]}]}]},{"content":"If this directory does not exist, go to <bpt id=\"p1\">[</bpt>Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=150780)</ept> to download all <ph id=\"ph1\">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> and <ph id=\"ph2\">[!INCLUDE[wf1](../../../../includes/wf1-md.md)]</ph> samples.","pos":[27865,28191],"source":"If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](http://go.microsoft.com/fwlink/?LinkId=150780) to download all [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples."},{"content":"This sample is located in the following directory.","pos":[28192,28242]},{"pos":[28331,28339],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]}]}