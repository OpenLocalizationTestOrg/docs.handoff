<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-868c4f2" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2af7d112a133e5ead1fb5bb24584394711fceb04</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wpf\advanced\dependency-property-metadata.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">749d774fe23a6e95fb4ecbf913f5a4bf7b17932a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67501f3c76cf269722fb23a324fddb23f1a8307a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Dependency Property Metadata | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Dependency Property Metadata</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general <ph id="ph2">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> characteristics.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on <ph id="ph1">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]</ph> classes, and have read the <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In order to follow the examples in this topic, you should also understand <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</ph> and know how to write <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> applications.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>How Dependency Property Metadata is Used</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This metadata is also accessed frequently by the property system as it processes any given dependency property.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The metadata object for a dependency property can contain the following types of information:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For more information on dependency property callbacks, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more information on this aspect of dependency property metadata, see <bpt id="p1">[</bpt>Framework Property Metadata<ept id="p1">](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Metadata APIs</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The type that reports most of the metadata information used by the property system is the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>(For cases where a property registration does not specify metadata, a default <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> is created with default values for that class.)The registered metadata is returned as <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> when you call the various <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph> overloads that get metadata from a dependency property on a <ph id="ph4">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> adds animation reporting, and <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> provides the WPF framework-level properties mentioned in the previous section.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When dependency properties are registered, they can be registered with these <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> derived classes.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When the metadata is examined, the base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type can potentially be cast to the derived classes so that you can examine the more specific properties.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The property characteristics that can be specified in <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> are sometimes referred to in this documentation as "flags".</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> and then you supply possibly concatenated values of the enumeration to the <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, once constructed, these option characteristics are exposed within a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> as a series of Boolean properties rather than the constructing enumeration value.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The constructor uses the concatenated <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>When to Override Metadata, When to Derive a Class</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A custom dependency property behaves identically to dependency properties defined by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> <ph id="ph2">[!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For more details about custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>One notable characteristic of a dependency property that you cannot override is its value type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Also, you cannot replace an existing <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, because this callback exists in the registration field itself and not within its metadata.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Scenarios for Changing Existing Metadata</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Changing or adding property system callbacks is a more advanced scenario.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more information on this aspect of the property system, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Therefore, validation callbacks cannot be changed by overriding the metadata.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For the specific values to use and more information, see <bpt id="p1">[</bpt>Framework Property Metadata<ept id="p1">](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information that is pertinent to how these options should be set for a newly registered dependency property, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Overriding Metadata</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The reasons for this are explained in more detail in the <bpt id="p1">[</bpt>Metadata<ept id="p1">](#dp_metadata_contents)</ept> section.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For more information including some code examples, see <bpt id="p1">[</bpt>Override Metadata for a Dependency Property<ept id="p1">](../../../../docs/framework/wpf/advanced/how-to-override-metadata-for-a-dependency-property.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Property metadata can be supplied for a dependency property during the registration call (<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can do this by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For an example from the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]</ph>, the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph> class is the type that first registers the <ph id="ph4">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> dependency property.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>But the <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> class overrides metadata for the dependency property to provide its own initial default value, changing it from <ph id="ph2">`false`</ph> to <ph id="ph3">`true`</ph>, and otherwise re-uses the original <ph id="ph4">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>When you override metadata, the different metadata characteristics are either merged or replaced.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> is merged.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you add a new <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph>, that callback is stored in the metadata.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>If you do not specify a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> in the override, the value of <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> is promoted as a reference from the nearest ancestor that specified it in metadata.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The actual property system behavior for <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> is replaced.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you do not specify a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> in the override, the value of <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> comes from the nearest ancestor that specified it in metadata.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> implementations are replaced.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you add a new <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>, that callback is stored in the metadata.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you do not specify a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> in the override, the value of <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is promoted as a reference from the nearest ancestor that specified it in metadata.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The property system behavior is that only the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> in the immediate metadata is invoked.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>No references to other <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> implementations in the hierarchy are retained.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This behavior is implemented by <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;</ph>, and can be overridden on derived metadata classes.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Overriding Attached Property Metadata</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph>, attached properties are implemented as dependency properties.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This means that they also have property metadata, which individual classes can override.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The scoping considerations for an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</ph> are generally that any <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> can have an attached property set on them.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Therefore, any <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If the attached property is set on an instance of your class, those override property metadata characteristics apply.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> property is not relevant for attached properties.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Adding a Class as an Owner of an Existing Dependency Property</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>A class can add itself as an owner of a dependency property that has already been registered, by using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This enables the class to use a dependency property that was originally registered for a different type.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The adding class is typically not a derived class of the type that first registered that dependency property as owner.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The first such member to expose is a dependency property identifier field.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This field should be a <ph id="ph1">`public static readonly`</ph> field of type <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>, which is assigned to the return value of the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The second member to define is the <ph id="ph1">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]</ph> "wrapper" property.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> each time, and can make that call only once in the wrapper itself).</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For more information about implementing a dependency property, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> and <bpt id="p2">[</bpt>Add an Owner Type for a Dependency Property<ept id="p2">](../../../../docs/framework/wpf/advanced/how-to-add-an-owner-type-for-a-dependency-property.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>AddOwner and Attached Properties</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>You can call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> for a dependency property that is defined as an attached property by the owner class.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>You then will expose the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value as a <ph id="ph2">`public static readonly`</ph> field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph></source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph></source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph></source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph></source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Framework Property Metadata<ept id="p1">](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>