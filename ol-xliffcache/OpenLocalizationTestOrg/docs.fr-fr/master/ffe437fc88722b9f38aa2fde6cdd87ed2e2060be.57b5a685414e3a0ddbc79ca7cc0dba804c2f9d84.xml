{"content":"---\ntitle: \"Variance in Generic Interfaces (C#)\"\nms.date: 07/20/2015\nms.assetid: 4828a8f9-48c0-4128-9749-7fcd6bf19a06\n---\n\n# Variance in Generic Interfaces (C#)\n\n.NET Framework 4 introduced variance support for several existing generic interfaces. Variance support enables implicit conversion of classes that implement these interfaces. The following interfaces are now variant:\n\n- <xref:System.Collections.Generic.IEnumerable%601> (T is covariant)\n\n- <xref:System.Collections.Generic.IEnumerator%601> (T is covariant)\n\n- <xref:System.Linq.IQueryable%601> (T is covariant)\n\n- <xref:System.Linq.IGrouping%602> (`TKey` and `TElement` are covariant)\n\n- <xref:System.Collections.Generic.IComparer%601> (T is contravariant)\n\n- <xref:System.Collections.Generic.IEqualityComparer%601> (T is contravariant)\n\n- <xref:System.IComparable%601> (T is contravariant)\n\nCovariance permits a method to have a more derived return type than that defined by the generic type parameter of the interface. To illustrate the covariance feature, consider these generic interfaces: `IEnumerable<Object>` and `IEnumerable<String>`. The `IEnumerable<String>` interface does not inherit the `IEnumerable<Object>` interface. However, the `String` type does inherit the `Object` type, and in some cases you may want to assign objects of these interfaces to each other. This is shown in the following code example.\n\n```csharp\nIEnumerable<String> strings = new List<String>();\nIEnumerable<Object> objects = strings;\n```\n\nIn earlier versions of the .NET Framework, this code causes a compilation error in C# with `Option Strict On`. But now you can use `strings` instead of `objects`, as shown in the previous example, because the <xref:System.Collections.Generic.IEnumerable%601> interface is covariant.\n\nContravariance permits a method to have argument types that are less derived than that specified by the generic parameter of the interface. To illustrate contravariance, assume that you have created a `BaseComparer` class to compare instances of the `BaseClass` class. The `BaseComparer` class implements the `IEqualityComparer<BaseClass>` interface. Because the <xref:System.Collections.Generic.IEqualityComparer%601> interface is now contravariant, you can use `BaseComparer` to compare instances of classes that inherit the `BaseClass` class. This is shown in the following code example.\n\n```csharp\n// Simple hierarchy of classes.\nclass BaseClass { }\nclass DerivedClass : BaseClass { }\n\n// Comparer class.\nclass BaseComparer : IEqualityComparer<BaseClass>\n{\n    public int GetHashCode(BaseClass baseInstance)\n    {\n        return baseInstance.GetHashCode();\n    }\n    public bool Equals(BaseClass x, BaseClass y)\n    {\n        return x == y;\n    }\n}\nclass Program\n{\n    static void Test()\n    {\n        IEqualityComparer<BaseClass> baseComparer = new BaseComparer();\n\n        // Implicit conversion of IEqualityComparer<BaseClass> to\n        // IEqualityComparer<DerivedClass>.\n        IEqualityComparer<DerivedClass> childComparer = baseComparer;\n    }\n}\n```\n\nFor more examples, see [Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md).\n\nVariance in generic interfaces is supported for reference types only. Value types do not support variance. For example, `IEnumerable<int>` cannot be implicitly converted to `IEnumerable<object>`, because integers are represented by a value type.\n\n```csharp\nIEnumerable<int> integers = new List<int>();\n// The following statement generates a compiler error,\n// because int is a value type.\n// IEnumerable<Object> objects = integers;\n```\n\nIt is also important to remember that classes that implement variant interfaces are still invariant. For example, although <xref:System.Collections.Generic.List%601> implements the covariant interface <xref:System.Collections.Generic.IEnumerable%601>, you cannot implicitly convert `List<Object>` to `List<String>`. This is illustrated in the following code example.\n\n```csharp\n// The following line generates a compiler error\n// because classes are invariant.\n// List<Object> list = new List<String>();\n\n// You can use the interface object instead.\nIEnumerable<Object> listObjects = new List<String>();\n```\n\n## See also\n\n- [Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)\n- [Creating Variant Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md)\n- [Generic Interfaces](../../../../standard/generics/interfaces.md)\n- [Variance in Delegates (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)\n","nodes":[{"pos":[4,117],"embed":true,"restype":"x-metadata","content":"title: \"Variance in Generic Interfaces (C#)\"\nms.date: 07/20/2015\nms.assetid: 4828a8f9-48c0-4128-9749-7fcd6bf19a06","nodes":[{"content":"Variance in Generic Interfaces (C#)","nodes":[{"pos":[0,35],"content":"Variance in Generic Interfaces (C#)","nodes":[{"content":"Variance in Generic Interfaces (C#)","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[125,160],"content":"Variance in Generic Interfaces (C#)","linkify":"Variance in Generic Interfaces (C#)","nodes":[{"content":"Variance in Generic Interfaces (C#)","pos":[0,35]}]},{"content":".NET Framework 4 introduced variance support for several existing generic interfaces.","pos":[162,247]},{"content":"Variance support enables implicit conversion of classes that implement these interfaces.","pos":[248,336]},{"content":"The following interfaces are now variant:","pos":[337,378]},{"pos":[382,448],"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> (T is covariant)","source":"<xref:System.Collections.Generic.IEnumerable%601> (T is covariant)"},{"pos":[452,518],"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEnumerator%601&gt;</ph> (T is covariant)","source":"<xref:System.Collections.Generic.IEnumerator%601> (T is covariant)"},{"pos":[522,572],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.IQueryable%601&gt;</ph> (T is covariant)","source":"<xref:System.Linq.IQueryable%601> (T is covariant)"},{"pos":[576,646],"content":"<ph id=\"ph1\">&lt;xref:System.Linq.IGrouping%602&gt;</ph> (<ph id=\"ph2\">`TKey`</ph> and <ph id=\"ph3\">`TElement`</ph> are covariant)","source":"<xref:System.Linq.IGrouping%602> (`TKey` and `TElement` are covariant)"},{"pos":[650,718],"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> (T is contravariant)","source":"<xref:System.Collections.Generic.IComparer%601> (T is contravariant)"},{"pos":[722,798],"content":"<ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> (T is contravariant)","source":"<xref:System.Collections.Generic.IEqualityComparer%601> (T is contravariant)"},{"pos":[802,852],"content":"<ph id=\"ph1\">&lt;xref:System.IComparable%601&gt;</ph> (T is contravariant)","source":"<xref:System.IComparable%601> (T is contravariant)"},{"content":"Covariance permits a method to have a more derived return type than that defined by the generic type parameter of the interface.","pos":[854,982]},{"content":"To illustrate the covariance feature, consider these generic interfaces: <ph id=\"ph1\">`IEnumerable&lt;Object&gt;`</ph> and <ph id=\"ph2\">`IEnumerable&lt;String&gt;`</ph>.","pos":[983,1104],"source":" To illustrate the covariance feature, consider these generic interfaces: `IEnumerable<Object>` and `IEnumerable<String>`."},{"content":"The <ph id=\"ph1\">`IEnumerable&lt;String&gt;`</ph> interface does not inherit the <ph id=\"ph2\">`IEnumerable&lt;Object&gt;`</ph> interface.","pos":[1105,1194],"source":" The `IEnumerable<String>` interface does not inherit the `IEnumerable<Object>` interface."},{"content":"However, the <ph id=\"ph1\">`String`</ph> type does inherit the <ph id=\"ph2\">`Object`</ph> type, and in some cases you may want to assign objects of these interfaces to each other.","pos":[1195,1337],"source":" However, the `String` type does inherit the `Object` type, and in some cases you may want to assign objects of these interfaces to each other."},{"content":"This is shown in the following code example.","pos":[1338,1382]},{"content":"In earlier versions of the .NET Framework, this code causes a compilation error in C# with <ph id=\"ph1\">`Option Strict On`</ph>.","pos":[1488,1598],"source":"In earlier versions of the .NET Framework, this code causes a compilation error in C# with `Option Strict On`."},{"content":"But now you can use <ph id=\"ph1\">`strings`</ph> instead of <ph id=\"ph2\">`objects`</ph>, as shown in the previous example, because the <ph id=\"ph3\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface is covariant.","pos":[1599,1770],"source":" But now you can use `strings` instead of `objects`, as shown in the previous example, because the <xref:System.Collections.Generic.IEnumerable%601> interface is covariant."},{"content":"Contravariance permits a method to have argument types that are less derived than that specified by the generic parameter of the interface.","pos":[1772,1911]},{"content":"To illustrate contravariance, assume that you have created a <ph id=\"ph1\">`BaseComparer`</ph> class to compare instances of the <ph id=\"ph2\">`BaseClass`</ph> class.","pos":[1912,2040],"source":" To illustrate contravariance, assume that you have created a `BaseComparer` class to compare instances of the `BaseClass` class."},{"content":"The <ph id=\"ph1\">`BaseComparer`</ph> class implements the <ph id=\"ph2\">`IEqualityComparer&lt;BaseClass&gt;`</ph> interface.","pos":[2041,2122],"source":" The `BaseComparer` class implements the `IEqualityComparer<BaseClass>` interface."},{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> interface is now contravariant, you can use <ph id=\"ph2\">`BaseComparer`</ph> to compare instances of classes that inherit the <ph id=\"ph3\">`BaseClass`</ph> class.","pos":[2123,2317],"source":" Because the <xref:System.Collections.Generic.IEqualityComparer%601> interface is now contravariant, you can use `BaseComparer` to compare instances of classes that inherit the `BaseClass` class."},{"content":"This is shown in the following code example.","pos":[2318,2362]},{"pos":[3036,3248],"content":"For more examples, see <bpt id=\"p1\">[</bpt>Using Variance in Interfaces for Generic Collections (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)</ept>.","source":"For more examples, see [Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)."},{"content":"Variance in generic interfaces is supported for reference types only.","pos":[3250,3319]},{"content":"Value types do not support variance.","pos":[3320,3356]},{"content":"For example, <ph id=\"ph1\">`IEnumerable&lt;int&gt;`</ph> cannot be implicitly converted to <ph id=\"ph2\">`IEnumerable&lt;object&gt;`</ph>, because integers are represented by a value type.","pos":[3357,3495],"source":" For example, `IEnumerable<int>` cannot be implicitly converted to `IEnumerable<object>`, because integers are represented by a value type."},{"content":"It is also important to remember that classes that implement variant interfaces are still invariant.","pos":[3687,3787]},{"content":"For example, although <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements the covariant interface <ph id=\"ph2\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>, you cannot implicitly convert <ph id=\"ph3\">`List&lt;Object&gt;`</ph> to <ph id=\"ph4\">`List&lt;String&gt;`</ph>.","pos":[3788,4002],"source":" For example, although <xref:System.Collections.Generic.List%601> implements the covariant interface <xref:System.Collections.Generic.IEnumerable%601>, you cannot implicitly convert `List<Object>` to `List<String>`."},{"content":"This is illustrated in the following code example.","pos":[4003,4053]},{"pos":[4299,4307],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[4311,4499],"content":"<bpt id=\"p1\">[</bpt>Using Variance in Interfaces for Generic Collections (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)</ept>","source":"[Using Variance in Interfaces for Generic Collections (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections.md)"},{"pos":[4502,4656],"content":"<bpt id=\"p1\">[</bpt>Creating Variant Generic Interfaces (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md)</ept>","source":"[Creating Variant Generic Interfaces (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md)"},{"pos":[4659,4724],"content":"<bpt id=\"p1\">[</bpt>Generic Interfaces<ept id=\"p1\">](../../../../standard/generics/interfaces.md)</ept>","source":"[Generic Interfaces](../../../../standard/generics/interfaces.md)"},{"pos":[4727,4853],"content":"<bpt id=\"p1\">[</bpt>Variance in Delegates (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)</ept>","source":"[Variance in Delegates (C#)](../../../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)"}]}