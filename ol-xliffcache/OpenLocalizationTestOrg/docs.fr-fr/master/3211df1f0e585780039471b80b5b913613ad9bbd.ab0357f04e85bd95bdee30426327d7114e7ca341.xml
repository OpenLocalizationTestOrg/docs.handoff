{"content":"---\ntitle: \"How to: Make thread-safe calls to Windows Forms controls\"\nms.date: \"02/19/2019\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nf1_keywords:\n  - \"EHInvalidOperation.WinForms.IllegalCrossThreadCall\"\nhelpviewer_keywords:\n  - \"thread safety [Windows Forms], calling controls [Windows Forms]\"\n  - \"calling controls [Windows Forms], thread safety [Windows Forms]\"\n  - \"CheckForIllegalCrossThreadCalls property [Windows Forms]\"\n  - \"Windows Forms controls [Windows Forms], multithreading\"\n  - \"BackgroundWorker class [Windows Forms], examples\"\n  - \"threading [Windows Forms], cross-thread calls\"\n  - \"controls [Windows Forms], multithreading\"\nms.assetid: 138f38b6-1099-4fd5-910c-390b41cbad35\n---\n# How to: Make thread-safe calls to Windows Forms controls\n\nMultithreading can improve the performance of Windows Forms apps, but access to Windows Forms controls isn't inherently thread-safe. Multithreading can expose your code to very serious and complex bugs. Two or more threads manipulating a control can force the control into an inconsistent state and lead to race conditions, deadlocks, and freezes or hangs. If you implement multithreading in your app, be sure to call cross-thread controls in a thread-safe way. For more information, see [Managed threading best practices](../../../standard/threading/managed-threading-best-practices.md). \n\nThere are two ways to safely call a Windows Forms control from a thread that didn't create that control. You can use the <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=fullName> method to call a delegate created in the main thread, which in turn calls the control. Or, you can implement a <xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType>, which uses an event-driven model to separate work done in the background thread from reporting on the results. \n\n## Unsafe cross-thread calls\n\nIt's unsafe to call a control directly from a thread that didn't create it. The following code snippet illustrates an unsafe call to the <xref:System.Windows.Forms.TextBox?displayProperty=nameWithType> control. The `Button1_Click` event handler creates a new `WriteTextUnsafe` thread, which sets the main thread's <xref:System.Windows.Forms.TextBox.Text%2A?displayProperty=nameWithType> property directly. \n\n```csharp\nprivate void Button1_Click(object sender, EventArgs e)\n{\n    thread2 = new Thread(new ThreadStart(WriteTextUnsafe));\n    thread2.Start();\n}\nprivate void WriteTextUnsafe()\n{\n    textBox1.Text = \"This text was set unsafely.\";\n}\n```\n\n```vb\nPrivate Sub Button1_Click(ByVal sender As Object, e As EventArgs) Handles Button1.Click\n    Thread2 = New Thread(New ThreadStart(AddressOf WriteTextUnsafe))\n    Thread2.Start()\nEnd Sub\n\nPrivate Sub WriteTextUnsafe()\n    TextBox1.Text = \"This text was set unsafely.\"\nEnd Sub\n```\n\nThe Visual Studio debugger detects these unsafe thread calls by raising an <xref:System.InvalidOperationException> with the message, **Cross-thread operation not valid. Control \"\" accessed from a thread other than the thread it was created on.** The <xref:System.InvalidOperationException> always occurs for unsafe cross-thread calls during Visual Studio debugging, and may occur at app runtime. You should fix the issue, but you can disable the exception by setting the <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A?displayProperty=nameWithType> property to `false`.\n\n## Safe cross-thread calls \n\nThe following code examples demonstrate two ways to safely call a Windows Forms control from a thread that didn't create it: \n1. The <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=fullName> method, which calls a delegate from the main thread to call the control. \n2. A <xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType> component, which offers an event-driven model. \n\nIn both examples, the background thread sleeps for one second to simulate work being done in that thread. \n\nYou can build and run these examples as .NET Framework apps from the C# or Visual Basic command line. For more information, see [Command-line building with csc.exe](../../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md) or [Build from the command line (Visual Basic)](../../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md). \n\nStarting with .NET Core 3.0, you can also build and run the examples as Windows .NET Core apps from a folder that has a .NET Core Windows Forms *\\<folder name>.csproj* project file. \n\n## Example: Use the Invoke method with a delegate\n\nThe following example demonstrates a pattern for ensuring thread-safe calls to a Windows Forms control. It queries the <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=fullName> property, which compares the control's creating thread ID to the calling thread ID. If the thread IDs are the same, it calls the control directly. If the thread IDs are different, it calls the <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> method with a delegate from the main thread, which makes the actual call to the control.\n\nThe `SafeCallDelegate` enables setting the <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.TextBox.Text%2A> property. The `WriteTextSafe` method queries <xref:System.Windows.Forms.Control.InvokeRequired%2A>. If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `true`, `WriteTextSafe` passes the `SafeCallDelegate` to the <xref:System.Windows.Forms.Control.Invoke%2A> method to make the actual call to the control. If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `false`, `WriteTextSafe` sets the <xref:System.Windows.Forms.TextBox.Text%2A?displayProperty=nameWithType> directly. The `Button1_Click` event handler creates the new thread and runs the `WriteTextSafe` method. \n\n [!code-csharp[ThreadSafeCalls#1](~/samples/snippets/winforms/thread-safe/example1/cs/Form1.cs)]\n [!code-vb[ThreadSafeCalls#1](~/samples/snippets/winforms/thread-safe/example1/vb/Form1.vb)]  \n\n## Example: Use a BackgroundWorker event handler\n\nAn easy way to implement multithreading is with the <xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType> component, which uses an event-driven model. The background thread runs the <xref:System.ComponentModel.BackgroundWorker.DoWork?displayProperty=nameWithType> event, which doesn't interact with the main thread. The main thread runs the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged?displayProperty=nameWithType> and <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted?displayProperty=nameWithType> event handlers, which can call the main thread's controls.\n\nTo make a thread-safe call by using <xref:System.ComponentModel.BackgroundWorker>, create a method in the background thread to do the work, and bind it to the <xref:System.ComponentModel.BackgroundWorker.DoWork> event. Create another method in the main thread to report the results of the background work, and bind it to the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> or <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event. To start the background thread, call <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A?displayProperty=nameWithType>. \n\nThe example uses the <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handler to set the <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.TextBox.Text%2A> property. For an example using the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> event, see <xref:System.ComponentModel.BackgroundWorker>. \n\n [!code-csharp[ThreadSafeCalls#2](~/samples/snippets/winforms/thread-safe/example2/cs/Form1.cs)]\n [!code-vb[ThreadSafeCalls#2](~/samples/snippets/winforms/thread-safe/example2/vb/Form1.vb)]  \n\n## See also\n\n- <xref:System.ComponentModel.BackgroundWorker>\n- [How to: Run an operation in the background](how-to-run-an-operation-in-the-background.md)\n- [How to: Implement a form that uses a background operation](how-to-implement-a-form-that-uses-a-background-operation.md)\n- [Develop custom Windows Forms controls with the .NET Framework](developing-custom-windows-forms-controls.md)\n","nodes":[{"pos":[4,682],"embed":true,"restype":"x-metadata","content":"title: \"How to: Make thread-safe calls to Windows Forms controls\"\nms.date: \"02/19/2019\"\ndev_langs:\n  - \"csharp\"\n  - \"vb\"\nf1_keywords:\n  - \"EHInvalidOperation.WinForms.IllegalCrossThreadCall\"\nhelpviewer_keywords:\n  - \"thread safety [Windows Forms], calling controls [Windows Forms]\"\n  - \"calling controls [Windows Forms], thread safety [Windows Forms]\"\n  - \"CheckForIllegalCrossThreadCalls property [Windows Forms]\"\n  - \"Windows Forms controls [Windows Forms], multithreading\"\n  - \"BackgroundWorker class [Windows Forms], examples\"\n  - \"threading [Windows Forms], cross-thread calls\"\n  - \"controls [Windows Forms], multithreading\"\nms.assetid: 138f38b6-1099-4fd5-910c-390b41cbad35","nodes":[{"content":"How to: Make thread-safe calls to Windows Forms controls","nodes":[{"pos":[0,56],"content":"How to: Make thread-safe calls to Windows Forms controls","nodes":[{"content":"How to: Make thread-safe calls to Windows Forms controls","pos":[0,56]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[689,745],"content":"How to: Make thread-safe calls to Windows Forms controls","linkify":"How to: Make thread-safe calls to Windows Forms controls","nodes":[{"content":"How to: Make thread-safe calls to Windows Forms controls","pos":[0,56]}]},{"content":"Multithreading can improve the performance of Windows Forms apps, but access to Windows Forms controls isn't inherently thread-safe.","pos":[747,879]},{"content":"Multithreading can expose your code to very serious and complex bugs.","pos":[880,949]},{"content":"Two or more threads manipulating a control can force the control into an inconsistent state and lead to race conditions, deadlocks, and freezes or hangs.","pos":[950,1103]},{"content":"If you implement multithreading in your app, be sure to call cross-thread controls in a thread-safe way.","pos":[1104,1208]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Managed threading best practices<ept id=\"p1\">](../../../standard/threading/managed-threading-best-practices.md)</ept>.","pos":[1209,1335],"source":" For more information, see [Managed threading best practices](../../../standard/threading/managed-threading-best-practices.md)."},{"content":"There are two ways to safely call a Windows Forms control from a thread that didn't create that control.","pos":[1338,1442]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=fullName&gt;</ph> method to call a delegate created in the main thread, which in turn calls the control.","pos":[1443,1616],"source":" You can use the <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=fullName> method to call a delegate created in the main thread, which in turn calls the control."},{"content":"Or, you can implement a <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType&gt;</ph>, which uses an event-driven model to separate work done in the background thread from reporting on the results.","pos":[1617,1827],"source":" Or, you can implement a <xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType>, which uses an event-driven model to separate work done in the background thread from reporting on the results."},{"pos":[1833,1858],"content":"Unsafe cross-thread calls","linkify":"Unsafe cross-thread calls","nodes":[{"content":"Unsafe cross-thread calls","pos":[0,25]}]},{"content":"It's unsafe to call a control directly from a thread that didn't create it.","pos":[1860,1935]},{"content":"The following code snippet illustrates an unsafe call to the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.TextBox?displayProperty=nameWithType&gt;</ph> control.","pos":[1936,2070],"source":" The following code snippet illustrates an unsafe call to the <xref:System.Windows.Forms.TextBox?displayProperty=nameWithType> control."},{"content":"The <ph id=\"ph1\">`Button1_Click`</ph> event handler creates a new <ph id=\"ph2\">`WriteTextUnsafe`</ph> thread, which sets the main thread's <ph id=\"ph3\">&lt;xref:System.Windows.Forms.TextBox.Text%2A?displayProperty=nameWithType&gt;</ph> property directly.","pos":[2071,2265],"source":" The `Button1_Click` event handler creates a new `WriteTextUnsafe` thread, which sets the main thread's <xref:System.Windows.Forms.TextBox.Text%2A?displayProperty=nameWithType> property directly."},{"content":"The Visual Studio debugger detects these unsafe thread calls by raising an <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> with the message, <bpt id=\"p1\">**</bpt>Cross-thread operation not valid. Control \"\" accessed from a thread other than the thread it was created on.<ept id=\"p1\">**</ept>","pos":[2794,3039],"source":"The Visual Studio debugger detects these unsafe thread calls by raising an <xref:System.InvalidOperationException> with the message, **Cross-thread operation not valid. Control \"\" accessed from a thread other than the thread it was created on.**"},{"content":"The <ph id=\"ph1\">&lt;xref:System.InvalidOperationException&gt;</ph> always occurs for unsafe cross-thread calls during Visual Studio debugging, and may occur at app runtime.","pos":[3040,3189],"source":" The <xref:System.InvalidOperationException> always occurs for unsafe cross-thread calls during Visual Studio debugging, and may occur at app runtime."},{"content":"You should fix the issue, but you can disable the exception by setting the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A?displayProperty=nameWithType&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","pos":[3190,3385],"source":" You should fix the issue, but you can disable the exception by setting the <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A?displayProperty=nameWithType> property to `false`."},{"pos":[3390,3413],"content":"Safe cross-thread calls","linkify":"Safe cross-thread calls","nodes":[{"content":"Safe cross-thread calls","pos":[0,23]}]},{"content":"The following code examples demonstrate two ways to safely call a Windows Forms control from a thread that didn't create it:","pos":[3416,3540]},{"pos":[3545,3692],"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=fullName&gt;</ph> method, which calls a delegate from the main thread to call the control.","source":"The <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=fullName> method, which calls a delegate from the main thread to call the control."},{"pos":[3697,3820],"content":"A <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType&gt;</ph> component, which offers an event-driven model.","source":"A <xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType> component, which offers an event-driven model."},{"content":"In both examples, the background thread sleeps for one second to simulate work being done in that thread.","pos":[3823,3928]},{"content":"You can build and run these examples as .NET Framework apps from the C# or Visual Basic command line.","pos":[3931,4032]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Command-line building with csc.exe<ept id=\"p1\">](../../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md)</ept> or <bpt id=\"p2\">[</bpt>Build from the command line (Visual Basic)<ept id=\"p2\">](../../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md)</ept>.","pos":[4033,4324],"source":" For more information, see [Command-line building with csc.exe](../../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md) or [Build from the command line (Visual Basic)](../../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md)."},{"pos":[4327,4508],"content":"Starting with .NET Core 3.0, you can also build and run the examples as Windows .NET Core apps from a folder that has a .NET Core Windows Forms <bpt id=\"p1\">*</bpt><ph id=\"ph1\">\\&lt;</ph>folder name&gt;.csproj<ept id=\"p1\">*</ept> project file.","source":"Starting with .NET Core 3.0, you can also build and run the examples as Windows .NET Core apps from a folder that has a .NET Core Windows Forms *\\<folder name>.csproj* project file."},{"pos":[4514,4560],"content":"Example: Use the Invoke method with a delegate","linkify":"Example: Use the Invoke method with a delegate","nodes":[{"content":"Example: Use the Invoke method with a delegate","pos":[0,46]}]},{"content":"The following example demonstrates a pattern for ensuring thread-safe calls to a Windows Forms control.","pos":[4562,4665]},{"content":"It queries the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=fullName&gt;</ph> property, which compares the control's creating thread ID to the calling thread ID.","pos":[4666,4843],"source":" It queries the <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=fullName> property, which compares the control's creating thread ID to the calling thread ID."},{"content":"If the thread IDs are the same, it calls the control directly.","pos":[4844,4906]},{"content":"If the thread IDs are different, it calls the <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType&gt;</ph> method with a delegate from the main thread, which makes the actual call to the control.","pos":[4907,5116],"source":" If the thread IDs are different, it calls the <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> method with a delegate from the main thread, which makes the actual call to the control."},{"content":"The <ph id=\"ph1\">`SafeCallDelegate`</ph> enables setting the <ph id=\"ph2\">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control's <ph id=\"ph3\">&lt;xref:System.Windows.Forms.TextBox.Text%2A&gt;</ph> property.","pos":[5118,5260],"source":"The `SafeCallDelegate` enables setting the <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.TextBox.Text%2A> property."},{"content":"The <ph id=\"ph1\">`WriteTextSafe`</ph> method queries <ph id=\"ph2\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph>.","pos":[5261,5350],"source":" The `WriteTextSafe` method queries <xref:System.Windows.Forms.Control.InvokeRequired%2A>."},{"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph> returns <ph id=\"ph2\">`true`</ph>, <ph id=\"ph3\">`WriteTextSafe`</ph> passes the <ph id=\"ph4\">`SafeCallDelegate`</ph> to the <ph id=\"ph5\">&lt;xref:System.Windows.Forms.Control.Invoke%2A&gt;</ph> method to make the actual call to the control.","pos":[5351,5569],"source":" If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `true`, `WriteTextSafe` passes the `SafeCallDelegate` to the <xref:System.Windows.Forms.Control.Invoke%2A> method to make the actual call to the control."},{"content":"If <ph id=\"ph1\">&lt;xref:System.Windows.Forms.Control.InvokeRequired%2A&gt;</ph> returns <ph id=\"ph2\">`false`</ph>, <ph id=\"ph3\">`WriteTextSafe`</ph> sets the <ph id=\"ph4\">&lt;xref:System.Windows.Forms.TextBox.Text%2A?displayProperty=nameWithType&gt;</ph> directly.","pos":[5570,5751],"source":" If <xref:System.Windows.Forms.Control.InvokeRequired%2A> returns `false`, `WriteTextSafe` sets the <xref:System.Windows.Forms.TextBox.Text%2A?displayProperty=nameWithType> directly."},{"content":"The <ph id=\"ph1\">`Button1_Click`</ph> event handler creates the new thread and runs the <ph id=\"ph2\">`WriteTextSafe`</ph> method.","pos":[5752,5845],"source":" The `Button1_Click` event handler creates the new thread and runs the `WriteTextSafe` method."},{"pos":[6044,6089],"content":"Example: Use a BackgroundWorker event handler","linkify":"Example: Use a BackgroundWorker event handler","nodes":[{"content":"Example: Use a BackgroundWorker event handler","pos":[0,45]}]},{"content":"An easy way to implement multithreading is with the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType&gt;</ph> component, which uses an event-driven model.","pos":[6091,6262],"source":"An easy way to implement multithreading is with the <xref:System.ComponentModel.BackgroundWorker?displayProperty=nameWithType> component, which uses an event-driven model."},{"content":"The background thread runs the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.DoWork?displayProperty=nameWithType&gt;</ph> event, which doesn't interact with the main thread.","pos":[6263,6427],"source":" The background thread runs the <xref:System.ComponentModel.BackgroundWorker.DoWork?displayProperty=nameWithType> event, which doesn't interact with the main thread."},{"content":"The main thread runs the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.ProgressChanged?displayProperty=nameWithType&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted?displayProperty=nameWithType&gt;</ph> event handlers, which can call the main thread's controls.","pos":[6428,6700],"source":" The main thread runs the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged?displayProperty=nameWithType> and <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted?displayProperty=nameWithType> event handlers, which can call the main thread's controls."},{"content":"To make a thread-safe call by using <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>, create a method in the background thread to do the work, and bind it to the <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker.DoWork&gt;</ph> event.","pos":[6702,6920],"source":"To make a thread-safe call by using <xref:System.ComponentModel.BackgroundWorker>, create a method in the background thread to do the work, and bind it to the <xref:System.ComponentModel.BackgroundWorker.DoWork> event."},{"content":"Create another method in the main thread to report the results of the background work, and bind it to the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.ProgressChanged&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event.","pos":[6921,7163],"source":" Create another method in the main thread to report the results of the background work, and bind it to the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> or <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event."},{"content":"To start the background thread, call <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A?displayProperty=nameWithType&gt;</ph>.","pos":[7164,7294],"source":" To start the background thread, call <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A?displayProperty=nameWithType>."},{"content":"The example uses the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted&gt;</ph> event handler to set the <ph id=\"ph2\">&lt;xref:System.Windows.Forms.TextBox&gt;</ph> control's <ph id=\"ph3\">&lt;xref:System.Windows.Forms.TextBox.Text%2A&gt;</ph> property.","pos":[7297,7507],"source":"The example uses the <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> event handler to set the <xref:System.Windows.Forms.TextBox> control's <xref:System.Windows.Forms.TextBox.Text%2A> property."},{"content":"For an example using the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker.ProgressChanged&gt;</ph> event, see <ph id=\"ph2\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>.","pos":[7508,7652],"source":" For an example using the <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> event, see <xref:System.ComponentModel.BackgroundWorker>."},{"pos":[7851,7859],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[7911,8001],"content":"<bpt id=\"p1\">[</bpt>How to: Run an operation in the background<ept id=\"p1\">](how-to-run-an-operation-in-the-background.md)</ept>","source":"[How to: Run an operation in the background](how-to-run-an-operation-in-the-background.md)"},{"pos":[8004,8124],"content":"<bpt id=\"p1\">[</bpt>How to: Implement a form that uses a background operation<ept id=\"p1\">](how-to-implement-a-form-that-uses-a-background-operation.md)</ept>","source":"[How to: Implement a form that uses a background operation](how-to-implement-a-form-that-uses-a-background-operation.md)"},{"pos":[8127,8235],"content":"<bpt id=\"p1\">[</bpt>Develop custom Windows Forms controls with the .NET Framework<ept id=\"p1\">](developing-custom-windows-forms-controls.md)</ept>","source":"[Develop custom Windows Forms controls with the .NET Framework](developing-custom-windows-forms-controls.md)"}]}