{"content":"---\ntitle: \"Choosing a Message Encoder\"\nms.date: \"03/30/2017\"\nms.assetid: 2204d82d-d962-4922-a79e-c9a231604f19\n---\n# Choosing a Message Encoder\nThis topic discusses criteria for choosing among the message encoders that are included in Windows Communication Foundation (WCF): binary, text, and Message Transmission Optimization Mechanism (MTOM).  \n  \n In WCF, you specify how to transfer data across a network between endpoints by means of a *binding*, which is made up of a sequence of *binding elements*. A message encoder is represented by a message encoding binding element in the binding stack. A binding includes optional protocol binding elements, such as a security binding element or reliable messaging binding element, a required message encoding binding element, and a required transport binding element.  \n  \n The message encoding binding element sits below the optional protocol binding elements and above the required transport binding element. On the outgoing side, a message encoder serializes the outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport. On the incoming side, a message encoder receives the serialized form of a <xref:System.ServiceModel.Channels.Message> from the transport and passes it to the higher protocol layer, if present, or to the application, if not.  \n  \n When connecting to a pre-existing client or server, you may not have a choice about using a particular message encoding since you need to encode your messages in a way that the other side is expecting. However, if you are writing an WCF service, you can expose your service through multiple endpoints, each using a different message encoding. This allows clients to choose the best encoding for talking to your service over the endpoint that is best for them, as well as giving your clients the flexibility to choose the encoding that is best for them. Using multiple endpoints also allows you to combine the advantages of different message encodings with other binding elements.  \n  \n## System-Provided Encoders  \n WCF includes three message encoders, which are represented by the following three classes:  \n  \n-   <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>, the text message encoder, supports both plain XML encoding and SOAP encoding. The plain XML encoding mode of the text message encoder is called \"plain old XML\" (POX) to distinguish it from text-based SOAP encoding. To enable POX, set the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement.MessageVersion%2A> property to <xref:System.ServiceModel.Channels.MessageVersion.None%2A>. Use the text message encoder to interoperate with non-WCF endpoints.  \n  \n-   <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>, the binary message encoder, uses a compact binary format and is optimized for WCF to WCF communication, and hence is not interoperable. This is also the most performant encoder of all the encoders WCF provides.  \n  \n-   <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>, the binding element, specifies the character encoding and message versioning for messages using MTOM encoding. MTOM is an efficient technology for transmitting binary data in WCF messages. The MTOM encoder attempts to create a balance between efficiency and interoperability. The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text. In terms of efficiency, among the encoders WCF provides, MTOM is in-between text (the slowest) and binary (the fastest).  \n  \n## How to Choose a Message Encoder  \n The following table describes common factors used to choose a message encoder. Prioritize the factors that are important for your application, and then choose the message encoders that work best with these factors. Be sure to consider any additional factors not listed in this table and any custom message encoders that may be required in your application.  \n  \n|Factor|Description|Encoders that support this factor|  \n|------------|-----------------|---------------------------------------|  \n|Supported Character Sets|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> and <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> support only the UTF8 and UTF16 Unicode (*big-endian* and *little-endian*) encodings. If other encodings are required, such as UTF7 or ASCII, a custom encoder must be used. For a sample custom encoder, see [Custom Message Encoder](https://go.microsoft.com/fwlink/?LinkId=119857).|Text|  \n|Inspection|Inspection is the ability to examine messages during transmission. Text encodings, either with or without the use of SOAP, allow messages to be inspected and analyzed by many applications without the use of specialized tools. Note that the use of transfer security, at either the message or transport level, affects your ability to inspect messages. Confidentiality protects a message from being examined and integrity protects a message from being modified.|Text|  \n|Reliability|Reliability is the resiliency of an encoder to transmission errors. Reliability can also be provided at the message, transport, or application layer. All of the standard WCF encoders assume that another layer is providing reliability. The encoder has little ability to recover from a transmission error.|None|  \n|Simplicity|Simplicity represents the ease with which you can create encoders and decoders for an encoding specification. Text encodings are particularly advantageous for simplicity, and the POX text encoding has the additional advantage of not requiring support for processing SOAP.|Text (POX)|  \n|Size|The encoding determines the amount of overhead imposed on content. The size of encoded messages is directly related to the maximum throughput of service operations. Binary encodings are generally more compact than text encodings. When message size is at a premium, consider also compressing the message contents during encoding. However, compression adds processing costs for both the message sender and receiver.|Binary|  \n|Streaming|Streaming allows applications to begin processing a message before the entire message has arrived. Effectively using streaming requires that the important data for a message be available at the beginning of the message so that the receiving application is not required to wait for it to arrive. Moreover, applications that use streamed transfer must organize data in the message incrementally so that the content does not have forward dependencies. In many cases, you must compromise between streaming content and having the smallest possible transfer size for that content.|None|  \n|3rd Party Tool Support|Support areas for an encoding include development and diagnosis. Third-party developers have made a large investment in libraries and toolkits for handling messages encoded in the POX format.|Text (POX)|  \n|Interoperability|This factor refers to the ability of a WCF encoder to interoperate with non-WCF services.|Text<br /><br /> MTOM (partial)|  \n  \nNote: When using the Binary Encoder, using the IgnoreWhitespace setting when creating a XMLReader will have no effect.  For example, if you do the following inside a service operation:  \n\n```csharp\npublic void OperationContract(XElement input)\n{\n    Console.WriteLine(\"{0}\", input.Value);\n    int counter = 0;\n    var xreader = input.CreateReader();\n    var reader = XmlReader.Create(xreader, new XmlReaderSettings() { IgnoreWhitespace = true });\n    while (reader.Read())\n    {\n        counter++;\n    }\n\n    Console.WriteLine(\"Read {0} lines with reader\", counter);\n}\n```  \n  \nThe IgnoreWhitespace setting is ignored.  \n  \n## Compression and the Binary Encoder\n\nBeginning with WCF 4.5 the WCF binary encoder adds support for compression. This enables you to use the gzip/deflate algorithm for sending compressed messages from a WCF client and also respond with compressed messages from a self-hosted WCF service. This feature enables compression on both the HTTP and TCP transports. An IIS hosted WCF service can always be enabled for sending compressed responses by configuring the IIS host server. The type of compression is configured with the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.CompressionFormat%2A?displayProperty=nameWithType> property. This property is set to one of the <xref:System.ServiceModel.Channels.CompressionFormat?displayProperty=nameWithType> enum values:\n\n- <xref:System.ServiceModel.Channels.CompressionFormat.Deflate>\n- <xref:System.ServiceModel.Channels.CompressionFormat.GZip>\n- <xref:System.ServiceModel.Channels.CompressionFormat.None>\n  \nSince this property is only exposed on the binaryMessageEncodingBindingElement, you will need to create a custom binding like the following to use this feature:\n\n ```xml\n <customBinding>\n   <binding name=\"BinaryCompressionBinding\">\n     <binaryMessageEncoding compressionFormat =\"GZip\" />\n     <httpTransport />\n  </binding>\n</customBinding>\n ```\n\nBoth the client and the service need to agree to send and receive compressed messages and therefore the compressionFormat property must be configured on the binaryMessageEncoding element on both client and service. A ProtocolException is thrown if either the service or client is not configured for compression but the other side is.Enabling compression should be carefully considered. Compression is mostly useful if network bandwidth is a bottleneck. In the case where the CPU is the bottleneck, compression will decrease throughput. Appropriate testing must be done in a simulated environment to find out if this benefits the application  \n  \n## See also\n\n- [Bindings](../../../../docs/framework/wcf/feature-details/bindings.md)\n","nodes":[{"pos":[4,110],"embed":true,"restype":"x-metadata","content":"title: \"Choosing a Message Encoder\"\nms.date: \"03/30/2017\"\nms.assetid: 2204d82d-d962-4922-a79e-c9a231604f19","nodes":[{"content":"Choosing a Message Encoder","nodes":[{"pos":[0,26],"content":"Choosing a Message Encoder","nodes":[{"content":"Choosing a Message Encoder","pos":[0,26]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[117,143],"content":"Choosing a Message Encoder","linkify":"Choosing a Message Encoder","nodes":[{"content":"Choosing a Message Encoder","pos":[0,26]}]},{"content":"This topic discusses criteria for choosing among the message encoders that are included in Windows Communication Foundation (WCF): binary, text, and Message Transmission Optimization Mechanism (MTOM).","pos":[144,344]},{"content":"In WCF, you specify how to transfer data across a network between endpoints by means of a <bpt id=\"p1\">*</bpt>binding<ept id=\"p1\">*</ept>, which is made up of a sequence of <bpt id=\"p2\">*</bpt>binding elements<ept id=\"p2\">*</ept>.","pos":[351,505],"source":"In WCF, you specify how to transfer data across a network between endpoints by means of a *binding*, which is made up of a sequence of *binding elements*."},{"content":"A message encoder is represented by a message encoding binding element in the binding stack.","pos":[506,598]},{"content":"A binding includes optional protocol binding elements, such as a security binding element or reliable messaging binding element, a required message encoding binding element, and a required transport binding element.","pos":[599,814]},{"content":"The message encoding binding element sits below the optional protocol binding elements and above the required transport binding element.","pos":[821,957]},{"content":"On the outgoing side, a message encoder serializes the outgoing <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> and passes it to the transport.","pos":[958,1097],"source":" On the outgoing side, a message encoder serializes the outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport."},{"content":"On the incoming side, a message encoder receives the serialized form of a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> from the transport and passes it to the higher protocol layer, if present, or to the application, if not.","pos":[1098,1321],"source":" On the incoming side, a message encoder receives the serialized form of a <xref:System.ServiceModel.Channels.Message> from the transport and passes it to the higher protocol layer, if present, or to the application, if not."},{"content":"When connecting to a pre-existing client or server, you may not have a choice about using a particular message encoding since you need to encode your messages in a way that the other side is expecting.","pos":[1328,1529]},{"content":"However, if you are writing an WCF service, you can expose your service through multiple endpoints, each using a different message encoding.","pos":[1530,1670]},{"content":"This allows clients to choose the best encoding for talking to your service over the endpoint that is best for them, as well as giving your clients the flexibility to choose the encoding that is best for them.","pos":[1671,1880]},{"content":"Using multiple endpoints also allows you to combine the advantages of different message encodings with other binding elements.","pos":[1881,2007]},{"pos":[2016,2040],"content":"System-Provided Encoders","linkify":"System-Provided Encoders","nodes":[{"content":"System-Provided Encoders","pos":[0,24]}]},{"content":"WCF includes three message encoders, which are represented by the following three classes:","pos":[2044,2134]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement&gt;</ph>, the text message encoder, supports both plain XML encoding and SOAP encoding.","pos":[2144,2292],"source":"<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>, the text message encoder, supports both plain XML encoding and SOAP encoding."},{"content":"The plain XML encoding mode of the text message encoder is called \"plain old XML\" (POX) to distinguish it from text-based SOAP encoding.","pos":[2293,2429]},{"content":"To enable POX, set the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement.MessageVersion%2A&gt;</ph> property to <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MessageVersion.None%2A&gt;</ph>.","pos":[2430,2612],"source":" To enable POX, set the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement.MessageVersion%2A> property to <xref:System.ServiceModel.Channels.MessageVersion.None%2A>."},{"content":"Use the text message encoder to interoperate with non-WCF endpoints.","pos":[2613,2681]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement&gt;</ph>, the binary message encoder, uses a compact binary format and is optimized for WCF to WCF communication, and hence is not interoperable.","pos":[2691,2899],"source":"<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>, the binary message encoder, uses a compact binary format and is optimized for WCF to WCF communication, and hence is not interoperable."},{"content":"This is also the most performant encoder of all the encoders WCF provides.","pos":[2900,2974]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement&gt;</ph>, the binding element, specifies the character encoding and message versioning for messages using MTOM encoding.","pos":[2984,3165],"source":"<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>, the binding element, specifies the character encoding and message versioning for messages using MTOM encoding."},{"content":"MTOM is an efficient technology for transmitting binary data in WCF messages.","pos":[3166,3243]},{"content":"The MTOM encoder attempts to create a balance between efficiency and interoperability.","pos":[3244,3330]},{"content":"The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.","pos":[3331,3482]},{"content":"In terms of efficiency, among the encoders WCF provides, MTOM is in-between text (the slowest) and binary (the fastest).","pos":[3483,3603]},{"pos":[3612,3643],"content":"How to Choose a Message Encoder","linkify":"How to Choose a Message Encoder","nodes":[{"content":"How to Choose a Message Encoder","pos":[0,31]}]},{"content":"The following table describes common factors used to choose a message encoder.","pos":[3647,3725]},{"content":"Prioritize the factors that are important for your application, and then choose the message encoders that work best with these factors.","pos":[3726,3861]},{"content":"Be sure to consider any additional factors not listed in this table and any custom message encoders that may be required in your application.","pos":[3862,4003]},{"content":"Factor","pos":[4010,4016]},{"content":"Description","pos":[4017,4028]},{"content":"Encoders that support this factor","pos":[4029,4062]},{"content":"Supported Character Sets","pos":[4142,4166]},{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement&gt;</ph> support only the UTF8 and UTF16 Unicode (<bpt id=\"p1\">*</bpt>big-endian<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>little-endian<ept id=\"p2\">*</ept>) encodings.","pos":[4167,4396],"source":"<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> and <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> support only the UTF8 and UTF16 Unicode (*big-endian* and *little-endian*) encodings."},{"content":"If other encodings are required, such as UTF7 or ASCII, a custom encoder must be used.","pos":[4397,4483]},{"content":"For a sample custom encoder, see <bpt id=\"p1\">[</bpt>Custom Message Encoder<ept id=\"p1\">](https://go.microsoft.com/fwlink/?LinkId=119857)</ept>.","pos":[4484,4590],"source":" For a sample custom encoder, see [Custom Message Encoder](https://go.microsoft.com/fwlink/?LinkId=119857)."},{"content":"Text","pos":[4591,4595]},{"content":"Inspection","pos":[4600,4610]},{"content":"Inspection is the ability to examine messages during transmission.","pos":[4611,4677]},{"content":"Text encodings, either with or without the use of SOAP, allow messages to be inspected and analyzed by many applications without the use of specialized tools.","pos":[4678,4836]},{"content":"Note that the use of transfer security, at either the message or transport level, affects your ability to inspect messages.","pos":[4837,4960]},{"content":"Confidentiality protects a message from being examined and integrity protects a message from being modified.","pos":[4961,5069]},{"content":"Text","pos":[5070,5074]},{"content":"Reliability","pos":[5079,5090]},{"content":"Reliability is the resiliency of an encoder to transmission errors.","pos":[5091,5158]},{"content":"Reliability can also be provided at the message, transport, or application layer.","pos":[5159,5240]},{"content":"All of the standard WCF encoders assume that another layer is providing reliability.","pos":[5241,5325]},{"content":"The encoder has little ability to recover from a transmission error.","pos":[5326,5394]},{"content":"None","pos":[5395,5399]},{"content":"Simplicity","pos":[5404,5414]},{"content":"Simplicity represents the ease with which you can create encoders and decoders for an encoding specification.","pos":[5415,5524]},{"content":"Text encodings are particularly advantageous for simplicity, and the POX text encoding has the additional advantage of not requiring support for processing SOAP.","pos":[5525,5686]},{"content":"Text (POX)","pos":[5687,5697]},{"content":"Size","pos":[5702,5706]},{"content":"The encoding determines the amount of overhead imposed on content.","pos":[5707,5773]},{"content":"The size of encoded messages is directly related to the maximum throughput of service operations.","pos":[5774,5871]},{"content":"Binary encodings are generally more compact than text encodings.","pos":[5872,5936]},{"content":"When message size is at a premium, consider also compressing the message contents during encoding.","pos":[5937,6035]},{"content":"However, compression adds processing costs for both the message sender and receiver.","pos":[6036,6120]},{"content":"Binary","pos":[6121,6127]},{"content":"Streaming","pos":[6132,6141]},{"content":"Streaming allows applications to begin processing a message before the entire message has arrived.","pos":[6142,6240]},{"content":"Effectively using streaming requires that the important data for a message be available at the beginning of the message so that the receiving application is not required to wait for it to arrive.","pos":[6241,6436]},{"content":"Moreover, applications that use streamed transfer must organize data in the message incrementally so that the content does not have forward dependencies.","pos":[6437,6590]},{"content":"In many cases, you must compromise between streaming content and having the smallest possible transfer size for that content.","pos":[6591,6716]},{"content":"None","pos":[6717,6721]},{"content":"3rd Party Tool Support","pos":[6726,6748]},{"content":"Support areas for an encoding include development and diagnosis.","pos":[6749,6813]},{"content":"Third-party developers have made a large investment in libraries and toolkits for handling messages encoded in the POX format.","pos":[6814,6940]},{"content":"Text (POX)","pos":[6941,6951]},{"content":"Interoperability","pos":[6956,6972]},{"content":"This factor refers to the ability of a WCF encoder to interoperate with non-WCF services.","pos":[6973,7062]},{"content":"Text","pos":[7063,7067]},{"content":"MTOM (partial)","pos":[7080,7094]},{"content":"Note: When using the Binary Encoder, using the IgnoreWhitespace setting when creating a XMLReader will have no effect.","pos":[7101,7219]},{"content":"For example, if you do the following inside a service operation:","pos":[7221,7285]},{"content":"The IgnoreWhitespace setting is ignored.","pos":[7679,7719]},{"pos":[7728,7762],"content":"Compression and the Binary Encoder","linkify":"Compression and the Binary Encoder","nodes":[{"content":"Compression and the Binary Encoder","pos":[0,34]}]},{"content":"Beginning with WCF 4.5 the WCF binary encoder adds support for compression.","pos":[7764,7839]},{"content":"This enables you to use the gzip/deflate algorithm for sending compressed messages from a WCF client and also respond with compressed messages from a self-hosted WCF service.","pos":[7840,8014]},{"content":"This feature enables compression on both the HTTP and TCP transports.","pos":[8015,8084]},{"content":"An IIS hosted WCF service can always be enabled for sending compressed responses by configuring the IIS host server.","pos":[8085,8201]},{"content":"The type of compression is configured with the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.CompressionFormat%2A?displayProperty=nameWithType&gt;</ph> property.","pos":[8202,8380],"source":" The type of compression is configured with the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.CompressionFormat%2A?displayProperty=nameWithType> property."},{"content":"This property is set to one of the <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.CompressionFormat?displayProperty=nameWithType&gt;</ph> enum values:","pos":[8381,8511],"source":" This property is set to one of the <xref:System.ServiceModel.Channels.CompressionFormat?displayProperty=nameWithType> enum values:"},{"content":"Since this property is only exposed on the binaryMessageEncodingBindingElement, you will need to create a custom binding like the following to use this feature:","pos":[8702,8862]},{"content":"Both the client and the service need to agree to send and receive compressed messages and therefore the compressionFormat property must be configured on the binaryMessageEncoding element on both client and service.","pos":[9050,9264]},{"content":"A ProtocolException is thrown if either the service or client is not configured for compression but the other side is.Enabling compression should be carefully considered.","pos":[9265,9435]},{"content":"Compression is mostly useful if network bandwidth is a bottleneck.","pos":[9436,9502]},{"content":"In the case where the CPU is the bottleneck, compression will decrease throughput.","pos":[9503,9585]},{"content":"Appropriate testing must be done in a simulated environment to find out if this benefits the application","pos":[9586,9690]},{"pos":[9699,9707],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[9711,9781],"content":"<bpt id=\"p1\">[</bpt>Bindings<ept id=\"p1\">](../../../../docs/framework/wcf/feature-details/bindings.md)</ept>","source":"[Bindings](../../../../docs/framework/wcf/feature-details/bindings.md)"}]}