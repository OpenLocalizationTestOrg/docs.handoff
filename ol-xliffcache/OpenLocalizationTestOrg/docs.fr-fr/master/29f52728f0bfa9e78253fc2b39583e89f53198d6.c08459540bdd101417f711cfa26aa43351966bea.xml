{"content":"---\ntitle: \"How to: Iterate Through a Directory Tree - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"iterating through folders [C#]\"\n  - \"file iteration [C#]\"\nms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7\n---\n# How to: Iterate Through a Directory Tree (C# Programming Guide)\nThe phrase \"iterate a directory tree\" means to access each file in each nested subdirectory under a specified root folder, to any depth. You do not necessarily have to open each file. You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.  \n  \n> [!NOTE]\n>  In Windows, the terms \"directory\" and \"folder\" are used interchangeably. Most documentation and user interface text uses the term \"folder,\" but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term \"directory.\"  \n  \n In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag. This flag returns all the nested subdirectories that match the specified pattern. The following example shows how to use this flag.  \n  \n```csharp  \nroot.GetDirectories(\"*.*\", System.IO.SearchOption.AllDirectories);  \n```  \n  \n The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories. The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method. If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.  \n  \n When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*). If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself. The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.  \n  \n Another option is whether to use recursion or a stack-based traversal. The examples later in this document show both approaches.  \n  \n If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.  \n  \n> [!NOTE]\n>  NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*. The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point. This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other. In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files. If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.  \n  \n## Example  \n The following example shows how to walk a directory tree by using recursion. The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.  \n  \n The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only. You should modify this code to meet your specific requirements. See the comments in the code for more information.  \n  \n [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  \n  \n## Example  \n The following example shows how to iterate through files and folders in a directory tree without using recursion. This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.  \n  \n The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only. You should modify this code to meet your specific requirements. See the comments in the code for more information.  \n  \n [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  \n  \n It is generally too time-consuming to test every folder to determine whether your application has permission to open it. Therefore, the code example just encloses that part of the operation in a `try/catch` block. You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again. As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.  \n  \n If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file. You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.  \n  \n## Robust Programming  \n Robust file iteration code must take into account many complexities of the file system. For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).  \n  \n## See also\n\n- <xref:System.IO>\n- [LINQ and File Directories](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)\n- [File System and the Registry (C# Programming Guide)](../../../csharp/programming-guide/file-system/index.md)\n","nodes":[{"pos":[4,250],"embed":true,"restype":"x-metadata","content":"title: \"How to: Iterate Through a Directory Tree - C# Programming Guide\"\nms.custom: seodec18\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"iterating through folders [C#]\"\n  - \"file iteration [C#]\"\nms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7","nodes":[{"content":"How to: Iterate Through a Directory Tree - C# Programming Guide","nodes":[{"pos":[0,63],"content":"How to: Iterate Through a Directory Tree - C# Programming Guide","nodes":[{"content":"How to: Iterate Through a Directory Tree - C# Programming Guide","pos":[0,63]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[257,320],"content":"How to: Iterate Through a Directory Tree (C# Programming Guide)","linkify":"How to: Iterate Through a Directory Tree (C# Programming Guide)","nodes":[{"content":"How to: Iterate Through a Directory Tree (C# Programming Guide)","pos":[0,63]}]},{"content":"The phrase \"iterate a directory tree\" means to access each file in each nested subdirectory under a specified root folder, to any depth.","pos":[321,457]},{"content":"You do not necessarily have to open each file.","pos":[458,504]},{"content":"You can just retrieve the name of the file or subdirectory as a <ph id=\"ph1\">`string`</ph>, or you can retrieve additional information in the form of a <ph id=\"ph2\">&lt;xref:System.IO.FileInfo?displayProperty=nameWithType&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.IO.DirectoryInfo?displayProperty=nameWithType&gt;</ph> object.","pos":[505,764],"source":" You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object."},{"pos":[772,1025],"content":"[!NOTE]\n In Windows, the terms \"directory\" and \"folder\" are used interchangeably. Most documentation and user interface text uses the term \"folder,\" but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term \"directory.\"","leadings":["","> "],"nodes":[{"content":"In Windows, the terms \"directory\" and \"folder\" are used interchangeably. Most documentation and user interface text uses the term \"folder,\" but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term \"directory.\"","pos":[9,251],"nodes":[{"content":"In Windows, the terms \"directory\" and \"folder\" are used interchangeably.","pos":[0,72]},{"content":"Most documentation and user interface text uses the term \"folder,\" but the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> class library uses the term \"directory.\"","pos":[73,242],"source":" Most documentation and user interface text uses the term \"folder,\" but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term \"directory.\""}]}]},{"content":"In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the <ph id=\"ph1\">`System.IO.SearchOption.AllDirectories`</ph> flag.","pos":[1032,1222],"source":"In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag."},{"content":"This flag returns all the nested subdirectories that match the specified pattern.","pos":[1223,1304]},{"content":"The following example shows how to use this flag.","pos":[1305,1354]},{"content":"The weakness in this approach is that if any one of the subdirectories under the specified root causes a <ph id=\"ph1\">&lt;xref:System.IO.DirectoryNotFoundException&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.UnauthorizedAccessException&gt;</ph>, the whole method fails and returns no directories.","pos":[1451,1696],"source":"The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories."},{"content":"The same is true when you use the <ph id=\"ph1\">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> method.","pos":[1697,1781],"source":" The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method."},{"content":"If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.","pos":[1782,1923]},{"content":"When you manually walk a directory tree, you can handle the subdirectories first (<bpt id=\"p1\">*</bpt>pre-order traversal<ept id=\"p1\">*</ept>), or the files first (<bpt id=\"p2\">*</bpt>post-order traversal<ept id=\"p2\">*</ept>).","pos":[1930,2080],"source":"When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*)."},{"content":"If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.","pos":[2081,2243]},{"content":"The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.","pos":[2244,2372]},{"content":"Another option is whether to use recursion or a stack-based traversal.","pos":[2379,2449]},{"content":"The examples later in this document show both approaches.","pos":[2450,2507]},{"content":"If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.","pos":[2514,2717]},{"pos":[2725,3448],"content":"[!NOTE]\n NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*. The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point. This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other. In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files. If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.","leadings":["","> "],"nodes":[{"content":"NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*. The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point. This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other. In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files. If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.","pos":[9,721],"nodes":[{"content":"NTFS file systems can contain <bpt id=\"p1\">*</bpt>reparse points<ept id=\"p1\">*</ept> in the form of <bpt id=\"p2\">*</bpt>junction points<ept id=\"p2\">*</ept>, <bpt id=\"p3\">*</bpt>symbolic links<ept id=\"p3\">*</ept>, and <bpt id=\"p4\">*</bpt>hard links<ept id=\"p4\">*</ept>.","pos":[0,116],"source":"NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*."},{"content":"The .NET Framework methods such as <ph id=\"ph1\">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> will not return any subdirectories under a reparse point.","pos":[117,305],"source":" The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point."},{"content":"This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.","pos":[306,422]},{"content":"In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.","pos":[423,565]},{"content":"If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.","pos":[566,712]}]}]},{"pos":[3457,3464],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows how to walk a directory tree by using recursion.","pos":[3468,3544]},{"content":"The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.","pos":[3545,3686]},{"content":"The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.","pos":[3693,3837]},{"content":"You should modify this code to meet your specific requirements.","pos":[3838,3901]},{"content":"See the comments in the code for more information.","pos":[3902,3952]},{"pos":[4091,4098],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following example shows how to iterate through files and folders in a directory tree without using recursion.","pos":[4102,4215]},{"content":"This technique uses the generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Stack%601&gt;</ph> collection type, which is a last in first out (LIFO) stack.","pos":[4216,4351],"source":" This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack."},{"content":"The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.","pos":[4358,4502]},{"content":"You should modify this code to meet your specific requirements.","pos":[4503,4566]},{"content":"See the comments in the code for more information.","pos":[4567,4617]},{"content":"It is generally too time-consuming to test every folder to determine whether your application has permission to open it.","pos":[4754,4874]},{"content":"Therefore, the code example just encloses that part of the operation in a <ph id=\"ph1\">`try/catch`</ph> block.","pos":[4875,4967],"source":" Therefore, the code example just encloses that part of the operation in a `try/catch` block."},{"content":"You can modify the <ph id=\"ph1\">`catch`</ph> block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.","pos":[4968,5110],"source":" You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again."},{"content":"As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.","pos":[5111,5223]},{"content":"If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <ph id=\"ph1\">&lt;xref:System.IO.FileSystemInfo.FullName%2A&gt;</ph> property (of type <ph id=\"ph2\">`string`</ph>) for each file.","pos":[5230,5434],"source":"If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file."},{"content":"You can then use this string to create a new <ph id=\"ph1\">&lt;xref:System.IO.FileInfo&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.IO.DirectoryInfo&gt;</ph> object as necessary, or open any file that requires additional processing.","pos":[5435,5614],"source":" You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing."},{"pos":[5623,5641],"content":"Robust Programming","linkify":"Robust Programming","nodes":[{"content":"Robust Programming","pos":[0,18]}]},{"content":"Robust file iteration code must take into account many complexities of the file system.","pos":[5645,5732]},{"content":"For more information on the Windows file system, see <bpt id=\"p1\">[</bpt>NTFS overview<ept id=\"p1\">](/windows-server/storage/file-server/ntfs-overview)</ept>.","pos":[5733,5853],"source":" For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview)."},{"pos":[5862,5870],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[5893,5998],"content":"<bpt id=\"p1\">[</bpt>LINQ and File Directories<ept id=\"p1\">](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)</ept>","source":"[LINQ and File Directories](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)"},{"pos":[6001,6110],"content":"<bpt id=\"p1\">[</bpt>File System and the Registry (C# Programming Guide)<ept id=\"p1\">](../../../csharp/programming-guide/file-system/index.md)</ept>","source":"[File System and the Registry (C# Programming Guide)](../../../csharp/programming-guide/file-system/index.md)"}]}