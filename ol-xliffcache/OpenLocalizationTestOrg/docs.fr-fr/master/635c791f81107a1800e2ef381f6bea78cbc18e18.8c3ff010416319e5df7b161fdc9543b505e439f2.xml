{"content":"---\ntitle: \"Arithmetic Operators in Visual Basic\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"type safety\"\n  - \"operators [Visual Basic], bitwise\"\n  - \"operators [Visual Basic], bit-shift\"\n  - \"bitwise operators [Visual Basic]\"\n  - \"bit-shift operators [Visual Basic]\"\n  - \"zero, division by zero\"\n  - \"operators [Visual Basic], arithmetic\"\n  - \"division [Visual Basic], by zero\"\n  - \"Visual Basic code, operators\"\n  - \"arithmetic operators [Visual Basic], about arithmetic operators\"\nms.assetid: 325dac7a-ea4f-41d5-8b48-f6e904211569\n---\n# Arithmetic Operators in Visual Basic\nArithmetic operators are used to perform many of the familiar arithmetic operations that involve the calculation of numeric values represented by literals, variables, other expressions, function and property calls, and constants. Also classified with arithmetic operators are the bit-shift operators, which act at the level of the individual bits of the operands and shift their bit patterns to the left or right.  \n  \n## Arithmetic Operations  \n You can add two values in an expression together with the [+ Operator](../../../../visual-basic/language-reference/operators/addition-operator.md), or subtract one from another with the [- Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), as the following example demonstrates.  \n  \n [!code-vb[VbVbalrOperators#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#57)]  \n  \n Negation also uses the [- Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), but with only one operand, as the following example demonstrates.  \n  \n [!code-vb[VbVbalrOperators#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#58)]  \n  \n Multiplication and division use the [* Operator](../../../../visual-basic/language-reference/operators/multiplication-operator.md) and [/ Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md), respectively, as the following example demonstrates.  \n  \n [!code-vb[VbVbalrOperators#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#59)]  \n  \n Exponentiation uses the [^ Operator](../../../../visual-basic/language-reference/operators/exponentiation-operator.md), as the following example demonstrates.  \n  \n [!code-vb[VbVbalrOperators#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#60)]  \n  \n Integer division is carried out using the [\\ Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/integer-division-operator.md). Integer division returns the quotient, that is, the integer that represents the number of times the divisor can divide into the dividend without consideration of any remainder. Both the divisor and the dividend must be integral types (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, and `ULong`) for this operator. All other types must be converted to an integral type first. The following example demonstrates integer division.  \n  \n [!code-vb[VbVbalrOperators#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#61)]  \n  \n Modulus arithmetic is performed using the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md). This operator returns the remainder after dividing the divisor into the dividend an integral number of times. If both divisor and dividend are integral types, the returned value is integral. If divisor and dividend are floating-point types, the returned value is also floating-point. The following example demonstrates this behavior.  \n  \n [!code-vb[VbVbalrOperators#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#62)]  \n  \n [!code-vb[VbVbalrOperators#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#63)]  \n  \n### Attempted Division by Zero  \n Division by zero has different results depending on the data types involved. In integral divisions (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, `ULong`), the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] throws a <xref:System.DivideByZeroException> exception. In division operations on the `Decimal` or `Single` data type, the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] also throws a <xref:System.DivideByZeroException> exception.  \n  \n In floating-point divisions involving the `Double` data type, no exception is thrown, and the result is the class member representing <xref:System.Double.NaN>, <xref:System.Double.PositiveInfinity>, or <xref:System.Double.NegativeInfinity>, depending on the dividend. The following table summarizes the various results of attempting to divide a `Double` value by zero.  \n  \n|Dividend data type|Divisor data type|Dividend value|Result|  \n|---|---|---|---|  \n|`Double`|`Double`|0|<xref:System.Double.NaN> (not a mathematically defined number)|  \n|`Double`|`Double`|> 0|<xref:System.Double.PositiveInfinity>|  \n|`Double`|`Double`|\\< 0|<xref:System.Double.NegativeInfinity>|  \n  \n When you catch a <xref:System.DivideByZeroException> exception, you can use its members to help you handle it. For example, the <xref:System.Exception.Message%2A> property holds the message text for the exception. For more information, see [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md).  \n  \n## Bit-Shift Operations  \n A bit-shift operation performs an arithmetic shift on a bit pattern. The pattern is contained in the operand on the left, while the operand on the right specifies the number of positions to shift the pattern. You can shift the pattern to the right with the [>> Operator](../../../../visual-basic/language-reference/operators/right-shift-operator.md) or to the left with the [<< Operator](../../../../visual-basic/language-reference/operators/left-shift-operator.md).  \n  \n The data type of the pattern operand must be `SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, or `ULong`. The data type of the shift amount operand must be `Integer` or must widen to `Integer`.  \n  \n Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end. The bit positions vacated by a shift are set as follows:  \n  \n-   0 for an arithmetic left shift  \n  \n-   0 for an arithmetic right shift of a positive number  \n  \n-   0 for an arithmetic right shift of an unsigned data type (`Byte`, `UShort`, `UInteger`, `ULong`)  \n  \n-   1 for an arithmetic right shift of a negative number (`SByte`, `Short`, `Integer`, or `Long`)  \n  \n The following example shifts an `Integer` value both left and right.  \n  \n [!code-vb[VbVbalrOperators#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOperators/VB/Class1.vb#64)]  \n  \n Arithmetic shifts never generate overflow exceptions.  \n  \n## Bitwise Operations  \n In addition to being logical operators, `Not`, `Or`, `And`, and `Xor` also perform bitwise arithmetic when used on numeric values. For more information, see \"Bitwise Operations\" in [Logical and Bitwise Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md).  \n  \n## Type Safety  \n Operands should normally be of the same type. For example, if you are doing addition with an `Integer` variable, you should add it to another `Integer` variable, and you should assign the result to a variable of type `Integer` as well.  \n  \n One way to ensure good type-safe coding practice is to use the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md). If you set `Option Strict On`, Visual Basic automatically performs *type-safe* conversions. For example, if you try to add an `Integer` variable to a `Double` variable and assign the value to a `Double` variable, the operation proceeds normally, because an `Integer` value can be converted to `Double` without loss of data. Type-unsafe conversions, on the other hand, cause a compiler error with `Option Strict On`. For example, if you try to add an `Integer` variable to a `Double` variable and assign the value to an `Integer` variable, a compiler error results, because a `Double` variable cannot be implicitly converted to type `Integer`.  \n  \n If you set `Option Strict Off`, however, Visual Basic allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision. For this reason, we recommend that you use `Option Strict On` when writing production code. For more information, see [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md).  \n  \n## See also\n\n- [Arithmetic Operators](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)\n- [Bit Shift Operators](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)\n- [Comparison Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)\n- [Concatenation Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)\n- [Logical and Bitwise Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)\n- [Efficient Combination of Operators](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)\n","nodes":[{"pos":[4,536],"embed":true,"restype":"x-metadata","content":"title: \"Arithmetic Operators in Visual Basic\"\nms.date: 07/20/2015\nhelpviewer_keywords: \n  - \"type safety\"\n  - \"operators [Visual Basic], bitwise\"\n  - \"operators [Visual Basic], bit-shift\"\n  - \"bitwise operators [Visual Basic]\"\n  - \"bit-shift operators [Visual Basic]\"\n  - \"zero, division by zero\"\n  - \"operators [Visual Basic], arithmetic\"\n  - \"division [Visual Basic], by zero\"\n  - \"Visual Basic code, operators\"\n  - \"arithmetic operators [Visual Basic], about arithmetic operators\"\nms.assetid: 325dac7a-ea4f-41d5-8b48-f6e904211569","nodes":[{"content":"Arithmetic Operators in Visual Basic","nodes":[{"pos":[0,36],"content":"Arithmetic Operators in Visual Basic","nodes":[{"content":"Arithmetic Operators in Visual Basic","pos":[0,36]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[543,579],"content":"Arithmetic Operators in Visual Basic","linkify":"Arithmetic Operators in Visual Basic","nodes":[{"content":"Arithmetic Operators in Visual Basic","pos":[0,36]}]},{"content":"Arithmetic operators are used to perform many of the familiar arithmetic operations that involve the calculation of numeric values represented by literals, variables, other expressions, function and property calls, and constants.","pos":[580,809]},{"content":"Also classified with arithmetic operators are the bit-shift operators, which act at the level of the individual bits of the operands and shift their bit patterns to the left or right.","pos":[810,993]},{"pos":[1002,1023],"content":"Arithmetic Operations","linkify":"Arithmetic Operations","nodes":[{"content":"Arithmetic Operations","pos":[0,21]}]},{"pos":[1027,1359],"content":"You can add two values in an expression together with the <bpt id=\"p1\">[</bpt>+ Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/addition-operator.md)</ept>, or subtract one from another with the <bpt id=\"p2\">[</bpt>- Operator (Visual Basic)<ept id=\"p2\">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, as the following example demonstrates.","source":"You can add two values in an expression together with the [+ Operator](../../../../visual-basic/language-reference/operators/addition-operator.md), or subtract one from another with the [- Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), as the following example demonstrates."},{"pos":[1490,1686],"content":"Negation also uses the <bpt id=\"p1\">[</bpt>- Operator (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/subtraction-operator.md)</ept>, but with only one operand, as the following example demonstrates.","source":"Negation also uses the [- Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), but with only one operand, as the following example demonstrates."},{"pos":[1817,2124],"content":"Multiplication and division use the <bpt id=\"p1\">[</bpt>* Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/multiplication-operator.md)</ept> and <bpt id=\"p2\">[</bpt>/ Operator (Visual Basic)<ept id=\"p2\">](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md)</ept>, respectively, as the following example demonstrates.","source":"Multiplication and division use the [* Operator](../../../../visual-basic/language-reference/operators/multiplication-operator.md) and [/ Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md), respectively, as the following example demonstrates."},{"pos":[2255,2413],"content":"Exponentiation uses the <bpt id=\"p1\">[</bpt>^ Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)</ept>, as the following example demonstrates.","source":"Exponentiation uses the [^ Operator](../../../../visual-basic/language-reference/operators/exponentiation-operator.md), as the following example demonstrates."},{"content":"Integer division is carried out using the <bpt id=\"p1\">[</bpt>\\ Operator (Visual Basic)<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/integer-division-operator.md)</ept>.","pos":[2544,2698],"source":"Integer division is carried out using the [\\ Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/integer-division-operator.md)."},{"content":"Integer division returns the quotient, that is, the integer that represents the number of times the divisor can divide into the dividend without consideration of any remainder.","pos":[2699,2875]},{"content":"Both the divisor and the dividend must be integral types (<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Byte`</ph>, <ph id=\"ph3\">`Short`</ph>, <ph id=\"ph4\">`UShort`</ph>, <ph id=\"ph5\">`Integer`</ph>, <ph id=\"ph6\">`UInteger`</ph>, <ph id=\"ph7\">`Long`</ph>, and <ph id=\"ph8\">`ULong`</ph>) for this operator.","pos":[2876,3032],"source":" Both the divisor and the dividend must be integral types (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, and `ULong`) for this operator."},{"content":"All other types must be converted to an integral type first.","pos":[3033,3093]},{"content":"The following example demonstrates integer division.","pos":[3094,3146]},{"content":"Modulus arithmetic is performed using the <bpt id=\"p1\">[</bpt>Mod Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/mod-operator.md)</ept>.","pos":[3277,3405],"source":"Modulus arithmetic is performed using the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md)."},{"content":"This operator returns the remainder after dividing the divisor into the dividend an integral number of times.","pos":[3406,3515]},{"content":"If both divisor and dividend are integral types, the returned value is integral.","pos":[3516,3596]},{"content":"If divisor and dividend are floating-point types, the returned value is also floating-point.","pos":[3597,3689]},{"content":"The following example demonstrates this behavior.","pos":[3690,3739]},{"pos":[3997,4023],"content":"Attempted Division by Zero","linkify":"Attempted Division by Zero","nodes":[{"content":"Attempted Division by Zero","pos":[0,26]}]},{"content":"Division by zero has different results depending on the data types involved.","pos":[4027,4103]},{"content":"In integral divisions (<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Byte`</ph>, <ph id=\"ph3\">`Short`</ph>, <ph id=\"ph4\">`UShort`</ph>, <ph id=\"ph5\">`Integer`</ph>, <ph id=\"ph6\">`UInteger`</ph>, <ph id=\"ph7\">`Long`</ph>, <ph id=\"ph8\">`ULong`</ph>), the <ph id=\"ph9\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> throws a <ph id=\"ph10\">&lt;xref:System.DivideByZeroException&gt;</ph> exception.","pos":[4104,4317],"source":" In integral divisions (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, `ULong`), the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] throws a <xref:System.DivideByZeroException> exception."},{"content":"In division operations on the <ph id=\"ph1\">`Decimal`</ph> or <ph id=\"ph2\">`Single`</ph> data type, the <ph id=\"ph3\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> also throws a <ph id=\"ph4\">&lt;xref:System.DivideByZeroException&gt;</ph> exception.","pos":[4318,4499],"source":" In division operations on the `Decimal` or `Single` data type, the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] also throws a <xref:System.DivideByZeroException> exception."},{"content":"In floating-point divisions involving the <ph id=\"ph1\">`Double`</ph> data type, no exception is thrown, and the result is the class member representing <ph id=\"ph2\">&lt;xref:System.Double.NaN&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Double.PositiveInfinity&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Double.NegativeInfinity&gt;</ph>, depending on the dividend.","pos":[4506,4773],"source":"In floating-point divisions involving the `Double` data type, no exception is thrown, and the result is the class member representing <xref:System.Double.NaN>, <xref:System.Double.PositiveInfinity>, or <xref:System.Double.NegativeInfinity>, depending on the dividend."},{"content":"The following table summarizes the various results of attempting to divide a <ph id=\"ph1\">`Double`</ph> value by zero.","pos":[4774,4874],"source":" The following table summarizes the various results of attempting to divide a `Double` value by zero."},{"content":"Dividend data type","pos":[4881,4899]},{"content":"Divisor data type","pos":[4900,4917]},{"content":"Dividend value","pos":[4918,4932]},{"content":"Result","pos":[4933,4939]},{"content":"0","pos":[4982,4983]},{"pos":[4984,5046],"content":"<ph id=\"ph1\">&lt;xref:System.Double.NaN&gt;</ph> (not a mathematically defined number)","source":"<xref:System.Double.NaN> (not a mathematically defined number)"},{"content":"&gt; 0","pos":[5069,5072],"source":"> 0"},{"content":"<ph id=\"ph1\">\\&lt;</ph> 0","pos":[5133,5137],"source":"\\< 0"},{"content":"When you catch a <ph id=\"ph1\">&lt;xref:System.DivideByZeroException&gt;</ph> exception, you can use its members to help you handle it.","pos":[5183,5293],"source":"When you catch a <xref:System.DivideByZeroException> exception, you can use its members to help you handle it."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.Exception.Message%2A&gt;</ph> property holds the message text for the exception.","pos":[5294,5396],"source":" For example, the <xref:System.Exception.Message%2A> property holds the message text for the exception."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Try...Catch...Finally Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>.","pos":[5397,5544],"source":" For more information, see [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)."},{"pos":[5553,5573],"content":"Bit-Shift Operations","linkify":"Bit-Shift Operations","nodes":[{"content":"Bit-Shift Operations","pos":[0,20]}]},{"content":"A bit-shift operation performs an arithmetic shift on a bit pattern.","pos":[5577,5645]},{"content":"The pattern is contained in the operand on the left, while the operand on the right specifies the number of positions to shift the pattern.","pos":[5646,5785]},{"content":"You can shift the pattern to the right with the <bpt id=\"p1\">[</bpt>&gt;&gt; Operator<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/right-shift-operator.md)</ept> or to the left with the <bpt id=\"p2\">[</bpt>&lt;&lt; Operator<ept id=\"p2\">](../../../../visual-basic/language-reference/operators/left-shift-operator.md)</ept>.","pos":[5786,6043],"source":" You can shift the pattern to the right with the [>> Operator](../../../../visual-basic/language-reference/operators/right-shift-operator.md) or to the left with the [<< Operator](../../../../visual-basic/language-reference/operators/left-shift-operator.md)."},{"content":"The data type of the pattern operand must be <ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Byte`</ph>, <ph id=\"ph3\">`Short`</ph>, <ph id=\"ph4\">`UShort`</ph>, <ph id=\"ph5\">`Integer`</ph>, <ph id=\"ph6\">`UInteger`</ph>, <ph id=\"ph7\">`Long`</ph>, or <ph id=\"ph8\">`ULong`</ph>.","pos":[6050,6173],"source":"The data type of the pattern operand must be `SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, or `ULong`."},{"content":"The data type of the shift amount operand must be <ph id=\"ph1\">`Integer`</ph> or must widen to <ph id=\"ph2\">`Integer`</ph>.","pos":[6174,6261],"source":" The data type of the shift amount operand must be `Integer` or must widen to `Integer`."},{"content":"Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end.","pos":[6268,6397]},{"content":"The bit positions vacated by a shift are set as follows:","pos":[6398,6454]},{"content":"0 for an arithmetic left shift","pos":[6464,6494]},{"content":"0 for an arithmetic right shift of a positive number","pos":[6504,6556]},{"pos":[6566,6662],"content":"0 for an arithmetic right shift of an unsigned data type (<ph id=\"ph1\">`Byte`</ph>, <ph id=\"ph2\">`UShort`</ph>, <ph id=\"ph3\">`UInteger`</ph>, <ph id=\"ph4\">`ULong`</ph>)","source":"0 for an arithmetic right shift of an unsigned data type (`Byte`, `UShort`, `UInteger`, `ULong`)"},{"pos":[6672,6765],"content":"1 for an arithmetic right shift of a negative number (<ph id=\"ph1\">`SByte`</ph>, <ph id=\"ph2\">`Short`</ph>, <ph id=\"ph3\">`Integer`</ph>, or <ph id=\"ph4\">`Long`</ph>)","source":"1 for an arithmetic right shift of a negative number (`SByte`, `Short`, `Integer`, or `Long`)"},{"pos":[6772,6840],"content":"The following example shifts an <ph id=\"ph1\">`Integer`</ph> value both left and right.","source":"The following example shifts an `Integer` value both left and right."},{"content":"Arithmetic shifts never generate overflow exceptions.","pos":[6971,7024]},{"pos":[7033,7051],"content":"Bitwise Operations","linkify":"Bitwise Operations","nodes":[{"content":"Bitwise Operations","pos":[0,18]}]},{"content":"In addition to being logical operators, <ph id=\"ph1\">`Not`</ph>, <ph id=\"ph2\">`Or`</ph>, <ph id=\"ph3\">`And`</ph>, and <ph id=\"ph4\">`Xor`</ph> also perform bitwise arithmetic when used on numeric values.","pos":[7055,7185],"source":"In addition to being logical operators, `Not`, `Or`, `And`, and `Xor` also perform bitwise arithmetic when used on numeric values."},{"content":"For more information, see \"Bitwise Operations\" in <bpt id=\"p1\">[</bpt>Logical and Bitwise Operators in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>.","pos":[7186,7405],"source":" For more information, see \"Bitwise Operations\" in [Logical and Bitwise Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)."},{"pos":[7414,7425],"content":"Type Safety","linkify":"Type Safety","nodes":[{"content":"Type Safety","pos":[0,11]}]},{"content":"Operands should normally be of the same type.","pos":[7429,7474]},{"content":"For example, if you are doing addition with an <ph id=\"ph1\">`Integer`</ph> variable, you should add it to another <ph id=\"ph2\">`Integer`</ph> variable, and you should assign the result to a variable of type <ph id=\"ph3\">`Integer`</ph> as well.","pos":[7475,7664],"source":" For example, if you are doing addition with an `Integer` variable, you should add it to another `Integer` variable, and you should assign the result to a variable of type `Integer` as well."},{"content":"One way to ensure good type-safe coding practice is to use the <bpt id=\"p1\">[</bpt>Option Strict Statement<ept id=\"p1\">](../../../../visual-basic/language-reference/statements/option-strict-statement.md)</ept>.","pos":[7671,7843],"source":"One way to ensure good type-safe coding practice is to use the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md)."},{"content":"If you set <ph id=\"ph1\">`Option Strict On`</ph>, Visual Basic automatically performs <bpt id=\"p1\">*</bpt>type-safe<ept id=\"p1\">*</ept> conversions.","pos":[7844,7935],"source":" If you set `Option Strict On`, Visual Basic automatically performs *type-safe* conversions."},{"content":"For example, if you try to add an <ph id=\"ph1\">`Integer`</ph> variable to a <ph id=\"ph2\">`Double`</ph> variable and assign the value to a <ph id=\"ph3\">`Double`</ph> variable, the operation proceeds normally, because an <ph id=\"ph4\">`Integer`</ph> value can be converted to <ph id=\"ph5\">`Double`</ph> without loss of data.","pos":[7936,8167],"source":" For example, if you try to add an `Integer` variable to a `Double` variable and assign the value to a `Double` variable, the operation proceeds normally, because an `Integer` value can be converted to `Double` without loss of data."},{"content":"Type-unsafe conversions, on the other hand, cause a compiler error with <ph id=\"ph1\">`Option Strict On`</ph>.","pos":[8168,8259],"source":" Type-unsafe conversions, on the other hand, cause a compiler error with `Option Strict On`."},{"content":"For example, if you try to add an <ph id=\"ph1\">`Integer`</ph> variable to a <ph id=\"ph2\">`Double`</ph> variable and assign the value to an <ph id=\"ph3\">`Integer`</ph> variable, a compiler error results, because a <ph id=\"ph4\">`Double`</ph> variable cannot be implicitly converted to type <ph id=\"ph5\">`Integer`</ph>.","pos":[8260,8486],"source":" For example, if you try to add an `Integer` variable to a `Double` variable and assign the value to an `Integer` variable, a compiler error results, because a `Double` variable cannot be implicitly converted to type `Integer`."},{"content":"If you set <ph id=\"ph1\">`Option Strict Off`</ph>, however, Visual Basic allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision.","pos":[8493,8669],"source":"If you set `Option Strict Off`, however, Visual Basic allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision."},{"content":"For this reason, we recommend that you use <ph id=\"ph1\">`Option Strict On`</ph> when writing production code.","pos":[8670,8761],"source":" For this reason, we recommend that you use `Option Strict On` when writing production code."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Widening and Narrowing Conversions<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)</ept>.","pos":[8762,8936],"source":" For more information, see [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)."},{"pos":[8945,8953],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[8957,9058],"content":"<bpt id=\"p1\">[</bpt>Arithmetic Operators<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)</ept>","source":"[Arithmetic Operators](../../../../visual-basic/language-reference/operators/arithmetic-operators.md)"},{"pos":[9061,9160],"content":"<bpt id=\"p1\">[</bpt>Bit Shift Operators<ept id=\"p1\">](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)</ept>","source":"[Bit Shift Operators](../../../../visual-basic/language-reference/operators/bit-shift-operators.md)"},{"pos":[9163,9313],"content":"<bpt id=\"p1\">[</bpt>Comparison Operators in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)</ept>","source":"[Comparison Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md)"},{"pos":[9316,9472],"content":"<bpt id=\"p1\">[</bpt>Concatenation Operators in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)</ept>","source":"[Concatenation Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md)"},{"pos":[9475,9643],"content":"<bpt id=\"p1\">[</bpt>Logical and Bitwise Operators in Visual Basic<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)</ept>","source":"[Logical and Bitwise Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)"},{"pos":[9646,9808],"content":"<bpt id=\"p1\">[</bpt>Efficient Combination of Operators<ept id=\"p1\">](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</ept>","source":"[Efficient Combination of Operators](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)"}]}