{"content":"---\ntitle: \"Comparison of XPath and LINQ to XML2 | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"2015-07-20\"\nms.prod: .net\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: \n  - \"devlang-csharp\"\n\nms.topic: \"article\"\ndev_langs: \n  - \"CSharp\"\nms.assetid: 87d361b1-daa9-4fd4-a53a-cbfa40111ad3\ncaps.latest.revision: 3\nauthor: \"BillWagner\"\nms.author: \"wiwagn\"\n\n---\n# Comparison of XPath and LINQ to XML\nXPath and [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] offer some similar functionality. Both can be used to query an XML tree, returning such results as a collection of elements, a collection of attributes, a collection of nodes, or the value of an element or attribute. However, there are also some differences.  \n  \n## Differences Between XPath and LINQ to XML  \n XPath does not allow projection of new types. It can only return collections of nodes from the tree, whereas [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] can execute a query and project an object graph or an XML tree in a new shape. [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] queries encompass much more functionality and are much more powerful than XPath expressions.  \n  \n XPath expressions exist in isolation within a string. The C# compiler cannot help parse the XPath expression at compile time. By contrast, [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] queries are parsed and compiled by the C# compiler. The compiler is able to catch many query errors.  \n  \n XPath results are not strongly typed. In a number of circumstances, the result of evaluating an XPath expression is an object, and it is up to the developer to determine the proper type and cast the result as necessary. By contrast, the projections from a [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] query are strongly typed.  \n  \n## Result Ordering  \n The XPath 1.0 Recommendation states that a collection that is the result of evaluating an XPath expression is unordered.  \n  \n However, when iterating through a collection returned by a [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] XPath axis method, the nodes in the collection are returned in document order. This is the case even when accessing the XPath axes where predicates are expressed in terms of reverse document order, such as `preceding` and `preceding-sibling`.  \n  \n By contrast, most of the [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] axes return collections in document order, but two of them, <xref:System.Xml.Linq.XNode.Ancestors%2A> and <xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A>, return collections in reverse document order. The following table enumerates the axes, and indicates collection order for each:  \n  \n|LINQ to XML axis|Ordering|  \n|----------------------|--------------|  \n|XContainer.DescendantNodes|Document order|  \n|XContainer.Descendants|Document order|  \n|XContainer.Elements|Document order|  \n|XContainer.Nodes|Document order|  \n|XContainer.NodesAfterSelf|Document order|  \n|XContainer.NodesBeforeSelf|Document order|  \n|XElement.AncestorsAndSelf|Reverse document order|  \n|XElement.Attributes|Document order|  \n|XElement.DescendantNodesAndSelf|Document order|  \n|XElement.DescendantsAndSelf|Document order|  \n|XNode.Ancestors|Reverse document order|  \n|XNode.ElementsAfterSelf|Document order|  \n|XNode.ElementsBeforeSelf|Document order|  \n|XNode.NodesAfterSelf|Document order|  \n|XNode.NodesBeforeSelf|Document order|  \n  \n## Positional Predicates  \n Within an XPath expression, positional predicates are expressed in terms of document order for many axes, but are expressed in reverse document order for reverse axes, which are `preceding`, `preceding-sibling`, `ancestor`, and `ancestor-or-self`. For example, the XPath expression `preceding-sibling::*[1]` returns the immediately preceding sibling. This is the case even though the final result set is presented in document order.  \n  \n By contrast, all positional predicates in LINQ to XML are always expressed in terms of the order of the axis. For example, `anElement.ElementsBeforeSelf().ToList()[0]` returns the first child element of the parent of the queried element, not the immediate preceding sibling. Another example: `anElement.Ancestors().ToList()[0]` returns the parent element.  \n  \n Note that the above approach materializes the entire collection. This is not the most efficient way to write that query. It was written in that way to demonstrate the behavior of positional predicates. A more appropriate way to write the same query is to use the <xref:System.Linq.Enumerable.First%2A> method, as follows: `anElement.ElementsBeforeSelf().First()`.  \n  \n If you wanted to find the immediately preceding element in [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)], you would write the following expression:  \n  \n `ElementsBeforeSelf().Last()`  \n  \n## Performance Differences  \n XPath queries that use the XPath functionality in [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] will not perform as well as [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] queries.  \n  \n## Comparison of Composition  \n Composition of a [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] query is somewhat parallel to composition of an XPath expression, although very different in syntax.  \n  \n For example, if you have an element in a variable named `customers`, and you want to find a grandchild element named `CompanyName` under all child elements named `Customer`, you would write an XPath expression as follows:  \n  \n```csharp  \ncustomers.XPathSelectElements(\"./Customer/CompanyName\");  \n```  \n  \n The equivalent [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] query is:  \n  \n```csharp  \ncustomers.Element(\"Customer\").Elements(\"CompanyName\");  \n```  \n  \n There are similar parallels for each of the XPath axes.  \n  \n|XPath axis|LINQ to XML axis|  \n|----------------|----------------------|  \n|child (the default axis)|<xref:System.Xml.Linq.XContainer.Elements%2A?displayProperty=fullName>|  \n|Parent (..)|<xref:System.Xml.Linq.XObject.Parent%2A?displayProperty=fullName>|  \n|attribute axis (@)|<xref:System.Xml.Linq.XElement.Attribute%2A?displayProperty=fullName><br /><br /> or<br /><br /> <xref:System.Xml.Linq.XElement.Attributes%2A?displayProperty=fullName>|  \n|ancestor axis|<xref:System.Xml.Linq.XNode.Ancestors%2A?displayProperty=fullName>|  \n|ancestor-or-self axis|<xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A?displayProperty=fullName>|  \n|descendant axis (//)|<xref:System.Xml.Linq.XContainer.Descendants%2A?displayProperty=fullName><br /><br /> or<br /><br /> <xref:System.Xml.Linq.XContainer.DescendantNodes%2A?displayProperty=fullName>|  \n|descendant-or-self|<xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A?displayProperty=fullName><br /><br /> or<br /><br /> <xref:System.Xml.Linq.XElement.DescendantNodesAndSelf%2A?displayProperty=fullName>|  \n|following-sibling|<xref:System.Xml.Linq.XNode.ElementsAfterSelf%2A?displayProperty=fullName><br /><br /> or<br /><br /> <xref:System.Xml.Linq.XNode.NodesAfterSelf%2A?displayProperty=fullName>|  \n|preceding-sibling|<xref:System.Xml.Linq.XNode.ElementsBeforeSelf%2A?displayProperty=fullName><br /><br /> or<br /><br /> <xref:System.Xml.Linq.XNode.NodesBeforeSelf%2A?displayProperty=fullName>|  \n|following|No direct equivalent.|  \n|preceding|No direct equivalent.|  \n  \n## See Also  \n [LINQ to XML for XPath Users (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-for-xpath-users.md)","nodes":[{"pos":[12,65],"content":"Comparison of XPath and LINQ to XML2 | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Comparison of XPath and LINQ to XML2 | Microsoft Docs","pos":[0,53]}]},{"pos":[350,385],"content":"Comparison of XPath and LINQ to XML","linkify":"Comparison of XPath and LINQ to XML","nodes":[{"content":"Comparison of XPath and LINQ to XML","pos":[0,35]}]},{"content":"XPath and <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> offer some similar functionality.","pos":[386,532],"source":"XPath and [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] offer some similar functionality."},{"content":"Both can be used to query an XML tree, returning such results as a collection of elements, a collection of attributes, a collection of nodes, or the value of an element or attribute.","pos":[533,715]},{"content":"However, there are also some differences.","pos":[716,757]},{"pos":[766,807],"content":"Differences Between XPath and LINQ to XML","linkify":"Differences Between XPath and LINQ to XML","nodes":[{"content":"Differences Between XPath and LINQ to XML","pos":[0,41]}]},{"content":"XPath does not allow projection of new types.","pos":[811,856]},{"content":"It can only return collections of nodes from the tree, whereas <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> can execute a query and project an object graph or an XML tree in a new shape.","pos":[857,1101],"source":" It can only return collections of nodes from the tree, whereas [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] can execute a query and project an object graph or an XML tree in a new shape."},{"content":"<ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries encompass much more functionality and are much more powerful than XPath expressions.","pos":[1102,1297],"source":"[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] queries encompass much more functionality and are much more powerful than XPath expressions."},{"content":"XPath expressions exist in isolation within a string.","pos":[1304,1357]},{"content":"The C# compiler cannot help parse the XPath expression at compile time.","pos":[1358,1429]},{"content":"By contrast, <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries are parsed and compiled by the C# compiler.","pos":[1430,1597],"source":" By contrast, [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] queries are parsed and compiled by the C# compiler."},{"content":"The compiler is able to catch many query errors.","pos":[1598,1646]},{"content":"XPath results are not strongly typed.","pos":[1653,1690]},{"content":"In a number of circumstances, the result of evaluating an XPath expression is an object, and it is up to the developer to determine the proper type and cast the result as necessary.","pos":[1691,1872]},{"content":"By contrast, the projections from a <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query are strongly typed.","pos":[1873,2037],"source":" By contrast, the projections from a [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] query are strongly typed."},{"pos":[2046,2061],"content":"Result Ordering","linkify":"Result Ordering","nodes":[{"content":"Result Ordering","pos":[0,15]}]},{"content":"The XPath 1.0 Recommendation states that a collection that is the result of evaluating an XPath expression is unordered.","pos":[2065,2185]},{"content":"However, when iterating through a collection returned by a <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> XPath axis method, the nodes in the collection are returned in document order.","pos":[2192,2432],"source":"However, when iterating through a collection returned by a [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] XPath axis method, the nodes in the collection are returned in document order."},{"content":"This is the case even when accessing the XPath axes where predicates are expressed in terms of reverse document order, such as <ph id=\"ph1\">`preceding`</ph> and <ph id=\"ph2\">`preceding-sibling`</ph>.","pos":[2433,2596],"source":" This is the case even when accessing the XPath axes where predicates are expressed in terms of reverse document order, such as `preceding` and `preceding-sibling`."},{"content":"By contrast, most of the <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> axes return collections in document order, but two of them, <ph id=\"ph2\">&lt;xref:System.Xml.Linq.XNode.Ancestors%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A&gt;</ph>, return collections in reverse document order.","pos":[2603,2935],"source":"By contrast, most of the [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] axes return collections in document order, but two of them, <xref:System.Xml.Linq.XNode.Ancestors%2A> and <xref:System.Xml.Linq.XElement.AncestorsAndSelf%2A>, return collections in reverse document order."},{"content":"The following table enumerates the axes, and indicates collection order for each:","pos":[2936,3017]},{"content":"LINQ to XML axis","pos":[3024,3040]},{"content":"Ordering","pos":[3041,3049]},{"content":"XContainer.DescendantNodes","pos":[3096,3122]},{"content":"Document order","pos":[3123,3137]},{"content":"XContainer.Descendants","pos":[3142,3164]},{"content":"Document order","pos":[3165,3179]},{"content":"XContainer.Elements","pos":[3184,3203]},{"content":"Document order","pos":[3204,3218]},{"content":"XContainer.Nodes","pos":[3223,3239]},{"content":"Document order","pos":[3240,3254]},{"content":"XContainer.NodesAfterSelf","pos":[3259,3284]},{"content":"Document order","pos":[3285,3299]},{"content":"XContainer.NodesBeforeSelf","pos":[3304,3330]},{"content":"Document order","pos":[3331,3345]},{"content":"XElement.AncestorsAndSelf","pos":[3350,3375]},{"content":"Reverse document order","pos":[3376,3398]},{"content":"XElement.Attributes","pos":[3403,3422]},{"content":"Document order","pos":[3423,3437]},{"content":"XElement.DescendantNodesAndSelf","pos":[3442,3473]},{"content":"Document order","pos":[3474,3488]},{"content":"XElement.DescendantsAndSelf","pos":[3493,3520]},{"content":"Document order","pos":[3521,3535]},{"content":"XNode.Ancestors","pos":[3540,3555]},{"content":"Reverse document order","pos":[3556,3578]},{"content":"XNode.ElementsAfterSelf","pos":[3583,3606]},{"content":"Document order","pos":[3607,3621]},{"content":"XNode.ElementsBeforeSelf","pos":[3626,3650]},{"content":"Document order","pos":[3651,3665]},{"content":"XNode.NodesAfterSelf","pos":[3670,3690]},{"content":"Document order","pos":[3691,3705]},{"content":"XNode.NodesBeforeSelf","pos":[3710,3731]},{"content":"Document order","pos":[3732,3746]},{"pos":[3756,3777],"content":"Positional Predicates","linkify":"Positional Predicates","nodes":[{"content":"Positional Predicates","pos":[0,21]}]},{"content":"Within an XPath expression, positional predicates are expressed in terms of document order for many axes, but are expressed in reverse document order for reverse axes, which are <ph id=\"ph1\">`preceding`</ph>, <ph id=\"ph2\">`preceding-sibling`</ph>, <ph id=\"ph3\">`ancestor`</ph>, and <ph id=\"ph4\">`ancestor-or-self`</ph>.","pos":[3781,4028],"source":"Within an XPath expression, positional predicates are expressed in terms of document order for many axes, but are expressed in reverse document order for reverse axes, which are `preceding`, `preceding-sibling`, `ancestor`, and `ancestor-or-self`."},{"content":"For example, the XPath expression <ph id=\"ph1\">`preceding-sibling::*[1]`</ph> returns the immediately preceding sibling.","pos":[4029,4131],"source":" For example, the XPath expression `preceding-sibling::*[1]` returns the immediately preceding sibling."},{"content":"This is the case even though the final result set is presented in document order.","pos":[4132,4213]},{"content":"By contrast, all positional predicates in LINQ to XML are always expressed in terms of the order of the axis.","pos":[4220,4329]},{"content":"For example, <ph id=\"ph1\">`anElement.ElementsBeforeSelf().ToList()[0]`</ph> returns the first child element of the parent of the queried element, not the immediate preceding sibling.","pos":[4330,4494],"source":" For example, `anElement.ElementsBeforeSelf().ToList()[0]` returns the first child element of the parent of the queried element, not the immediate preceding sibling."},{"content":"Another example: <ph id=\"ph1\">`anElement.Ancestors().ToList()[0]`</ph> returns the parent element.","pos":[4495,4575],"source":" Another example: `anElement.Ancestors().ToList()[0]` returns the parent element."},{"content":"Note that the above approach materializes the entire collection.","pos":[4582,4646]},{"content":"This is not the most efficient way to write that query.","pos":[4647,4702]},{"content":"It was written in that way to demonstrate the behavior of positional predicates.","pos":[4703,4783]},{"content":"A more appropriate way to write the same query is to use the <ph id=\"ph1\">&lt;xref:System.Linq.Enumerable.First%2A&gt;</ph> method, as follows: <ph id=\"ph2\">`anElement.ElementsBeforeSelf().First()`</ph>.","pos":[4784,4945],"source":" A more appropriate way to write the same query is to use the <xref:System.Linq.Enumerable.First%2A> method, as follows: `anElement.ElementsBeforeSelf().First()`."},{"pos":[4952,5156],"content":"If you wanted to find the immediately preceding element in <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph>, you would write the following expression:","source":"If you wanted to find the immediately preceding element in [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)], you would write the following expression:"},{"pos":[5201,5224],"content":"Performance Differences","linkify":"Performance Differences","nodes":[{"content":"Performance Differences","pos":[0,23]}]},{"pos":[5228,5520],"content":"XPath queries that use the XPath functionality in <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> will not perform as well as <ph id=\"ph2\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> queries.","source":"XPath queries that use the XPath functionality in [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] will not perform as well as [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] queries."},{"pos":[5529,5554],"content":"Comparison of Composition","linkify":"Comparison of Composition","nodes":[{"content":"Comparison of Composition","pos":[0,25]}]},{"pos":[5558,5778],"content":"Composition of a <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query is somewhat parallel to composition of an XPath expression, although very different in syntax.","source":"Composition of a [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] query is somewhat parallel to composition of an XPath expression, although very different in syntax."},{"pos":[5785,6006],"content":"For example, if you have an element in a variable named <ph id=\"ph1\">`customers`</ph>, and you want to find a grandchild element named <ph id=\"ph2\">`CompanyName`</ph> under all child elements named <ph id=\"ph3\">`Customer`</ph>, you would write an XPath expression as follows:","source":"For example, if you have an element in a variable named `customers`, and you want to find a grandchild element named `CompanyName` under all child elements named `Customer`, you would write an XPath expression as follows:"},{"pos":[6093,6220],"content":"The equivalent <ph id=\"ph1\">[!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)]</ph> query is:","source":"The equivalent [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] query is:"},{"content":"There are similar parallels for each of the XPath axes.","pos":[6305,6360]},{"content":"XPath axis","pos":[6367,6377]},{"content":"LINQ to XML axis","pos":[6378,6394]},{"content":"child (the default axis)","pos":[6443,6467]},{"content":"Parent (..)","pos":[6543,6554]},{"content":"attribute axis (@)","pos":[6625,6643]},{"content":"or","pos":[6726,6728]},{"content":"ancestor axis","pos":[6816,6829]},{"content":"ancestor-or-self axis","pos":[6901,6922]},{"content":"descendant axis (//)","pos":[7004,7024]},{"content":"or","pos":[7111,7113]},{"content":"descendant-or-self","pos":[7208,7226]},{"content":"or","pos":[7318,7320]},{"content":"following-sibling","pos":[7420,7437]},{"content":"or","pos":[7525,7527]},{"content":"preceding-sibling","pos":[7616,7633]},{"content":"or","pos":[7722,7724]},{"content":"following","pos":[7814,7823]},{"content":"No direct equivalent.","pos":[7824,7845]},{"content":"preceding","pos":[7850,7859]},{"content":"No direct equivalent.","pos":[7860,7881]},{"pos":[7891,7899],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"pos":[7903,8020],"content":"<bpt id=\"p1\">[</bpt>LINQ to XML for XPath Users (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-for-xpath-users.md)</ept>","source":"[LINQ to XML for XPath Users (C#)](../../../../csharp/programming-guide/concepts/linq/linq-to-xml-for-xpath-users.md)"}]}