<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="csharp-7-3.md" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f97bda11d1da3f6deb4597c8d7742fd47e9cf15f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\whats-new\csharp-7-3.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">afff1da92b580ba2115989ed3068fa5e64d6be3b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3bb0bcb9e99da3d4d437126ababd0e390f2de8f3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's new in C# 7.3</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>An overview of new features in C# 7.3</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>What's new in C# 7.3</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>There are two main themes to the C# 7.3 release.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>One theme provides features that enable safe code to be as performant as unsafe code.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The second theme provides incremental improvements to existing features.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In addition, new compiler options were added in this release.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following new features support the theme of better performance for safe code:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can access fixed fields without pinning.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can reassign <ph id="ph1">`ref`</ph> local variables.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use initializers on <ph id="ph1">`stackalloc`</ph> arrays.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`fixed`</ph> statements with any type that supports a pattern.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can use additional generic constraints.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The following enhancements were made to existing features:</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You can test <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph> with tuple types.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use expression variables in more locations.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You may attach attributes to the backing field of auto-implemented properties.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Method resolution when arguments differ by <ph id="ph1">`in`</ph> has been improved.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Overload resolution now has fewer ambiguous cases.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The new compiler options are:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`-publicsign`</ph> to enable Open Source Software (OSS) signing of assemblies.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`-pathmap`</ph> to provide a mapping for source directories.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The remainder of this article provides details and links to learn more about each of the improvements.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enabling more efficient safe code</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You should be able to write C# code safely that performs as well as unsafe code.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Safe code avoids classes of errors, such as buffer overruns, stray pointers, and other memory access errors.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>These new features expand the capabilities of verifiable safe code.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Strive to write more of your code using safe constructs.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>These features make that easier.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Indexing <ph id="ph1">`fixed`</ph> fields does not require pinning</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Consider this struct:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In earlier versions of C#, you needed to pin a variable to access one of the integers that are part of <ph id="ph1">`myFixedField`</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Now, the following code compiles without pinning the variable <ph id="ph1">`p`</ph> inside a separate <ph id="ph2">`fixed`</ph> statement:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The variable <ph id="ph1">`p`</ph> accesses one element in <ph id="ph2">`myFixedField`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You don't need to declare a separate <ph id="ph1">`int*`</ph> variable.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Note that you still need an <ph id="ph1">`unsafe`</ph> context.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In earlier versions of C#, you need to declare a second fixed pointer:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For more information, see the article on the <bpt id="p1">[</bpt><ph id="ph1">`fixed`</ph> statement<ept id="p1">](../language-reference/keywords/fixed-statement.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ref`</ph> local variables may be reassigned</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Now, <ph id="ph1">`ref`</ph> locals may be reassigned to refer to different instances after being initialized.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The following code now compiles:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For more information, see the article on <bpt id="p1">[</bpt><ph id="ph1">`ref`</ph> returns and <ph id="ph2">`ref`</ph> locals<ept id="p1">](../programming-guide/classes-and-structs/ref-returns.md)</ept>, and the article on <bpt id="p2">[</bpt><ph id="ph3">`foreach`</ph><ept id="p2">](../language-reference/keywords/foreach-in.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`stackalloc`</ph> arrays support initializers</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You've been able to specify the values for elements in an array when you initialize it:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Now, that same syntax can be applied to arrays that are declared with <ph id="ph1">`stackalloc`</ph>:</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt><ph id="ph1">`stackalloc`</ph> statement<ept id="p1">](../language-reference/keywords/stackalloc.md)</ept> article in the language reference.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>More types support the <ph id="ph1">`fixed`</ph> statement</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`fixed`</ph> statement supported a limited set of types.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Starting with C# 7.3, any type that contains a <ph id="ph1">`GetPinnableReference()`</ph> method that returns a <ph id="ph2">`ref T`</ph> or <ph id="ph3">`ref readonly T`</ph> may be <ph id="ph4">`fixed`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Adding this feature means that <ph id="ph1">`fixed`</ph> can be used with <ph id="ph2">&lt;xref:System.Span%601?displayProperty=nameWithType&gt;</ph> and related types.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt><ph id="ph1">`fixed`</ph> statement<ept id="p1">](../language-reference/keywords/fixed-statement.md)</ept> article in the language reference.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Enhanced generic constraints</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can now specify the type <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Delegate?displayProperty=nameWithType&gt;</ph> as base class constraints for a type parameter.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You can also use the new <ph id="ph1">`unmanaged`</ph> constraint, to specify that a type parameter must be an <bpt id="p1">**</bpt>unmanaged type<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>unmanaged type<ept id="p1">**</ept> is a type that isn't a reference type and doesn't contain any reference type at any level of nesting.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information, see the articles on <bpt id="p1">[</bpt><ph id="ph1">`where`</ph> generic constraints<ept id="p1">](../language-reference/keywords/where-generic-type-constraint.md)</ept> and <bpt id="p2">[</bpt>constraints on type parameters<ept id="p2">](../programming-guide/generics/constraints-on-type-parameters.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Adding these constraints to existing types is an <bpt id="p1">[</bpt>incompatible change<ept id="p1">](version-update-considerations.md#incompatible-changes)</ept>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Closed generic types may no longer meet these new constraints.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Make existing features better</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The second theme provides improvements to features in the language.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These features improve productivity when writing C#.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Tuples support <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph></source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The C# tuple types now support <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For more information, see the section covering <bpt id="p1">[</bpt>equality<ept id="p1">](../tuples.md#equality-and-tuples)</ept> in the article on <bpt id="p2">[</bpt>tuples<ept id="p2">](../tuples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Attach attributes to the backing fields for auto-implemented properties</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This syntax is now supported:</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The attribute <ph id="ph1">`SomeThingAboutFieldAttribute`</ph> is applied to the compiler generated backing field for <ph id="ph2">`SomeProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>attributes<ept id="p1">](../programming-guide/concepts/attributes/index.md)</ept> in the C# programming guide.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`in`</ph> method overload resolution tiebreaker</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>When the <ph id="ph1">`in`</ph> argument modifier was added, these two methods would cause an ambiguity:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Now, the by value (first in the preceding example) overload is better than the by readonly reference version.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>To call the version with the readonly reference argument, you must include the <ph id="ph1">`in`</ph> modifier when calling the method.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This was implemented as a bug fix.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This no longer is ambiguous even with the language version set to "7.2".</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For more information, see the article on the <bpt id="p1">[</bpt><ph id="ph1">`in`</ph> parameter modifier<ept id="p1">](../language-reference/keywords/in-parameter-modifier.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Extend expression variables in initializers</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The syntax added in C# 7.0 to allow <ph id="ph1">`out`</ph> variable declarations has been extended to include field initializers, property initializers, constructor initializers, and query clauses.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>It enables code such as the following example:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Improved overload candidates</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In every release, the overload resolution rules get updated to address situations where ambiguous method invocations have an "obvious" choice.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This release adds three new rules to help the compiler pick the obvious choice:</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>When a method group contains both instance and static members, the compiler discards the instance members if the method was invoked without an instance receiver or context.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The compiler discards the static members if the method was invoked with an instance receiver.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When there is no receiver, the compiler includes only static members in a static context, otherwise both static and instance members.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When the receiver is ambiguously an instance or type, the compiler includes both.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A static context, where an implicit <ph id="ph1">`this`</ph> instance receiver cannot be used, includes the body of members where no <ph id="ph2">`this`</ph> is defined, such as static members, as well as places where <ph id="ph3">`this`</ph> cannot be used, such as field initializers and constructor-initializers.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When a method group contains some generic methods whose type arguments do not satisfy their constraints, these members are removed from the candidate set.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For a method group conversion, candidate methods whose return type doesn't match up with the delegate's return type are removed from the set.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>You'll only notice this change because you'll find fewer compiler errors for ambiguous method overloads when you are sure which method is better.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>New compiler options</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>New compiler options support new build and DevOps scenarios for C# programs.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Public or Open Source signing</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-publicsign`</ph> compiler option instructs the compiler to sign the assembly using a public key.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The assembly is marked as signed, but the signature is taken from the public key.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This option enables you to build signed assemblies from open-source projects using a public key.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>-publicsign compiler option<ept id="p1">](../language-reference/compiler-options/publicsign-compiler-option.md)</ept> article.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>pathmap</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-pathmap`</ph> compiler option instructs the compiler to replace source paths from the build environment with mapped source paths.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`-pathmap`</ph> option controls the source path written by the compiler to PDB files or for the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CallerFilePathAttribute&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>-pathmap compiler option<ept id="p1">](../language-reference/compiler-options/pathmap-compiler-option.md)</ept> article.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>