<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="using-properties.md" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f10f9aa17adf9a03b9b8905245983bdd9d865e39</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\programming-guide\classes-and-structs\using-properties.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_med-ht</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e0d983c1ac07b9b5baa48e1055d8b483d1b6ee91</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8b32f18e2e8edf8716d2ee77577eef3432399e28</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Using Properties - C# Programming Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Using Properties (C# Programming Guide)</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Properties combine aspects of both fields and methods.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>To the user of an object, a property appears to be a field, accessing the property requires the same syntax.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>To the implementer of a class, a property is one or two code blocks, representing a <bpt id="p1">[</bpt>get<ept id="p1">](../../../csharp/language-reference/keywords/get.md)</ept> accessor and/or a <bpt id="p2">[</bpt>set<ept id="p2">](../../../csharp/language-reference/keywords/set.md)</ept> accessor.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The code block for the <ph id="ph1">`get`</ph> accessor is executed when the property is read; the code block for the <ph id="ph2">`set`</ph> accessor is executed when the property is assigned a new value.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A property without a <ph id="ph1">`set`</ph> accessor is considered read-only.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A property without a <ph id="ph1">`get`</ph> accessor is considered write-only.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A property that has both accessors is read-write.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Unlike fields, properties are not classified as variables.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Therefore, you cannot pass a property as a <bpt id="p1">[</bpt>ref<ept id="p1">](../../../csharp/language-reference/keywords/ref.md)</ept> or <bpt id="p2">[</bpt>out<ept id="p2">](../../../csharp/language-reference/keywords/out-parameter-modifier.md)</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Properties have many uses: they can validate data before allowing a change; they can transparently expose data on a class where that data is actually retrieved from some other source, such as a database; they can take an action when data is changed, such as raising an event, or changing the value of other fields.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Properties are declared in the class block by specifying the access level of the field, followed by the type of the property, followed by the name of the property, and followed by a code block that declares a <ph id="ph1">`get`</ph>-accessor and/or a <ph id="ph2">`set`</ph> accessor.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In this example, <ph id="ph1">`Month`</ph> is declared as a property so that the <ph id="ph2">`set`</ph> accessor can make sure that the <ph id="ph3">`Month`</ph> value is set between 1 and 12.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Month`</ph> property uses a private field to track the actual value.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The real location of a property's data is often referred to as the property's "backing store."</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>It is common for properties to use private fields as a backing store.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The field is marked private in order to make sure that it can only be changed by calling the property.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more information about public and private access restrictions, see <bpt id="p1">[</bpt>Access Modifiers<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/access-modifiers.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Auto-implemented properties provide simplified syntax for simple property declarations.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Auto-Implemented Properties<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/auto-implemented-properties.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The get Accessor</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The body of the <ph id="ph1">`get`</ph> accessor resembles that of a method.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It must return a value of the property type.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The execution of the <ph id="ph1">`get`</ph> accessor is equivalent to reading the value of the field.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, when you are returning the private variable from the <ph id="ph1">`get`</ph> accessor and optimizations are enabled, the call to the <ph id="ph2">`get`</ph> accessor method is inlined by the compiler so there is no method-call overhead.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>However, a virtual <ph id="ph1">`get`</ph> accessor method cannot be inlined because the compiler does not know at compile-time which method may actually be called at run time.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The following is a <ph id="ph1">`get`</ph> accessor that returns the value of a private field <ph id="ph2">`name`</ph>:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>When you reference the property, except as the target of an assignment, the <ph id="ph1">`get`</ph> accessor is invoked to read the value of the property.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`get`</ph> accessor must end in a <bpt id="p1">[</bpt>return<ept id="p1">](../../../csharp/language-reference/keywords/return.md)</ept> or <bpt id="p2">[</bpt>throw<ept id="p2">](../../../csharp/language-reference/keywords/throw.md)</ept> statement, and control cannot flow off the accessor body.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>It is a bad programming style to change the state of the object by using the <ph id="ph1">`get`</ph> accessor.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, the following accessor produces the side effect of changing the state of the object every time that the <ph id="ph1">`number`</ph> field is accessed.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`get`</ph> accessor can be used to return the field value or to compute it and return it.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In the previous code segment, if you do not assign a value to the <ph id="ph1">`Name`</ph> property, it will return the value NA.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The set Accessor</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`set`</ph> accessor resembles a method whose return type is <bpt id="p1">[</bpt>void<ept id="p1">](../../../csharp/language-reference/keywords/void.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It uses an implicit parameter called <ph id="ph1">`value`</ph>, whose type is the type of the property.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In the following example, a <ph id="ph1">`set`</ph> accessor is added to the <ph id="ph2">`Name`</ph> property:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>When you assign a value to the property, the <ph id="ph1">`set`</ph> accessor is invoked by using an argument that provides the new value.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>It is an error to use the implicit parameter name, <ph id="ph1">`value`</ph>, for a local variable declaration in a <ph id="ph2">`set`</ph> accessor.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Remarks</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Properties can be marked as <ph id="ph1">`public`</ph>, <ph id="ph2">`private`</ph>, <ph id="ph3">`protected`</ph>, <ph id="ph4">`internal`</ph>, <ph id="ph5">`protected internal`</ph> or <ph id="ph6">`private protected`</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>These access modifiers define how users of the class can access the property.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors for the same property may have different access modifiers.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, the <ph id="ph1">`get`</ph> may be <ph id="ph2">`public`</ph> to allow read-only access from outside the type, and the <ph id="ph3">`set`</ph> may be <ph id="ph4">`private`</ph> or <ph id="ph5">`protected`</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Access Modifiers<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/access-modifiers.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A property may be declared as a static property by using the <ph id="ph1">`static`</ph> keyword.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This makes the property available to callers at any time, even if no instance of the class exists.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Static Classes and Static Class Members<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>A property may be marked as a virtual property by using the <bpt id="p1">[</bpt>virtual<ept id="p1">](../../../csharp/language-reference/keywords/virtual.md)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This enables derived classes to override the property behavior by using the <bpt id="p1">[</bpt>override<ept id="p1">](../../../csharp/language-reference/keywords/override.md)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>For more information about these options, see <bpt id="p1">[</bpt>Inheritance<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/inheritance.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>A property overriding a virtual property can also be <bpt id="p1">[</bpt>sealed<ept id="p1">](../../../csharp/language-reference/keywords/sealed.md)</ept>, specifying that for derived classes it is no longer virtual.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Lastly, a property can be declared <bpt id="p1">[</bpt>abstract<ept id="p1">](../../../csharp/language-reference/keywords/abstract.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This means that there is no implementation in the class, and derived classes must write their own implementation.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For more information about these options, see <bpt id="p1">[</bpt>Abstract and Sealed Classes and Class Members<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>It is an error to use a <bpt id="p1">[</bpt>virtual<ept id="p1">](../../../csharp/language-reference/keywords/virtual.md)</ept>, <bpt id="p2">[</bpt>abstract<ept id="p2">](../../../csharp/language-reference/keywords/abstract.md)</ept>, or <bpt id="p3">[</bpt>override<ept id="p3">](../../../csharp/language-reference/keywords/override.md)</ept> modifier on an accessor of a <bpt id="p4">[</bpt>static<ept id="p4">](../../../csharp/language-reference/keywords/static.md)</ept> property.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example demonstrates instance, static, and read-only properties.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It accepts the name of the employee from the keyboard, increments <ph id="ph1">`NumberOfEmployees`</ph> by 1, and displays the Employee name and number.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to access a property in a base class that is hidden by another property that has the same name in a derived class.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following are important points in the previous example:</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The property <ph id="ph1">`Name`</ph> in the derived class hides the property <ph id="ph2">`Name`</ph> in the base class.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In such a case, the <ph id="ph1">`new`</ph> modifier is used in the declaration of the property in the derived class:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The cast <ph id="ph1">`(Employee)`</ph> is used to access the hidden property in the base class:</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For more information about hiding members, see the <bpt id="p1">[</bpt>new Modifier<ept id="p1">](../../../csharp/language-reference/keywords/new-modifier.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In this example, two classes, <ph id="ph1">`Cube`</ph> and <ph id="ph2">`Square`</ph>, implement an abstract class, <ph id="ph3">`Shape`</ph>, and override its abstract <ph id="ph4">`Area`</ph> property.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Note the use of the <bpt id="p1">[</bpt>override<ept id="p1">](../../../csharp/language-reference/keywords/override.md)</ept> modifier on the properties.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The program accepts the side as an input and calculates the areas for the square and cube.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It also accepts the area as an input and calculates the corresponding side for the square and cube.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>See also</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>C# Programming Guide<ept id="p1">](../../../csharp/programming-guide/index.md)</ept></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Properties<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/properties.md)</ept></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Interface Properties<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/interface-properties.md)</ept></source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Auto-Implemented Properties<ept id="p1">](../../../csharp/programming-guide/classes-and-structs/auto-implemented-properties.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>