{"content":"---\ntitle: \"Finding Text in Word Documents (C#)\"\nms.date: 07/20/2015\nms.assetid: 82f86677-560b-49dc-a089-610409939b2a\n---\n# Finding Text in Word Documents (C#)\nThis topic extends the previous queries to do something useful: find all occurrences of a string in the document.  \n  \n## Example  \n This example processes a WordprocessingML document, to find all the occurrences of a specific piece of text in the document. To do this, we use a query that finds the string \"Hello\". This example builds on the previous examples in this tutorial. The new query is called out in comments in the code below.  \n  \n For instructions for creating the source document for this example, see [Creating the Source Office Open XML Document (C#)](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md).  \n  \n This example uses classes found in the WindowsBase assembly. It uses types in the <xref:System.IO.Packaging?displayProperty=nameWithType> namespace.  \n  \n```csharp  \npublic static class LocalExtensions  \n{  \n    public static string StringConcatenate(this IEnumerable<string> source)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item));  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate(this IEnumerable<string> source, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s).Append(separator);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item)).Append(separator);  \n        return sb.ToString();  \n    }  \n}  \n  \nclass Program  \n{  \n    public static string ParagraphText(XElement e)  \n    {  \n        XNamespace w = e.Name.Namespace;  \n        return e  \n               .Elements(w + \"r\")  \n               .Elements(w + \"t\")  \n               .StringConcatenate(element => (string)element);  \n    }  \n  \n    static void Main(string[] args)  \n    {  \n        const string fileName = \"SampleDoc.docx\";  \n  \n        const string documentRelationshipType =  \n          \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\";  \n        const string stylesRelationshipType =  \n          \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\";  \n        const string wordmlNamespace =  \n          \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\";  \n        XNamespace w = wordmlNamespace;  \n  \n        XDocument xDoc = null;  \n        XDocument styleDoc = null;  \n  \n        using (Package wdPackage = Package.Open(fileName, FileMode.Open, FileAccess.Read))  \n        {  \n            PackageRelationship docPackageRelationship =  \n              wdPackage.GetRelationshipsByType(documentRelationshipType).FirstOrDefault();  \n            if (docPackageRelationship != null)  \n            {  \n                Uri documentUri = PackUriHelper.ResolvePartUri(new Uri(\"/\", UriKind.Relative),  \n                  docPackageRelationship.TargetUri);  \n                PackagePart documentPart = wdPackage.GetPart(documentUri);  \n  \n                //  Load the document XML in the part into an XDocument instance.  \n                xDoc = XDocument.Load(XmlReader.Create(documentPart.GetStream()));  \n  \n                //  Find the styles part. There will only be one.  \n                PackageRelationship styleRelation =  \n                  documentPart.GetRelationshipsByType(stylesRelationshipType).FirstOrDefault();  \n                if (styleRelation != null)  \n                {  \n                    Uri styleUri =  \n                      PackUriHelper.ResolvePartUri(documentUri, styleRelation.TargetUri);  \n                    PackagePart stylePart = wdPackage.GetPart(styleUri);  \n  \n                    //  Load the style XML in the part into an XDocument instance.  \n                    styleDoc = XDocument.Load(XmlReader.Create(stylePart.GetStream()));  \n                }  \n            }  \n        }  \n  \n        string defaultStyle =  \n            (string)(  \n                from style in styleDoc.Root.Elements(w + \"style\")  \n                where (string)style.Attribute(w + \"type\") == \"paragraph\" &&  \n                      (string)style.Attribute(w + \"default\") == \"1\"  \n                select style  \n            ).First().Attribute(w + \"styleId\");  \n  \n        // Find all paragraphs in the document.  \n        var paragraphs =  \n            from para in xDoc  \n                         .Root  \n                         .Element(w + \"body\")  \n                         .Descendants(w + \"p\")  \n            let styleNode = para  \n                            .Elements(w + \"pPr\")  \n                            .Elements(w + \"pStyle\")  \n                            .FirstOrDefault()  \n            select new  \n            {  \n                ParagraphNode = para,  \n                StyleName = styleNode != null ?  \n                    (string)styleNode.Attribute(w + \"val\") :  \n                    defaultStyle  \n            };  \n  \n        // Retrieve the text of each paragraph.  \n        var paraWithText =  \n            from para in paragraphs  \n            select new  \n            {  \n                ParagraphNode = para.ParagraphNode,  \n                StyleName = para.StyleName,  \n                Text = ParagraphText(para.ParagraphNode)  \n            };  \n  \n        // Following is the new query that retrieves all paragraphs  \n        // that have specific text in them.  \n        var helloParagraphs =  \n            from para in paraWithText  \n            where para.Text.Contains(\"Hello\")  \n            select new  \n            {  \n                ParagraphNode = para.ParagraphNode,  \n                StyleName = para.StyleName,  \n                Text = para.Text  \n            };  \n  \n        foreach (var p in helloParagraphs)  \n            Console.WriteLine(\"StyleName:{0} >{1}<\", p.StyleName, p.Text);  \n    }  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nStyleName:Code >        Console.WriteLine(\"Hello World\");<  \nStyleName:Code >Hello World<  \n```  \n  \n You can, of course, modify the search so that it searches for lines with a specific style. The following query finds all blank lines that have the Code style:  \n  \n```csharp  \npublic static class LocalExtensions  \n{  \n    public static string StringConcatenate(this IEnumerable<string> source)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item));  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate(this IEnumerable<string> source, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s).Append(separator);  \n        return sb.ToString();  \n    }  \n  \n    public static string StringConcatenate<T>(this IEnumerable<T> source,  \n        Func<T, string> func, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item)).Append(separator);  \n        return sb.ToString();  \n    }  \n}  \n  \nclass Program  \n{  \n    public static string ParagraphText(XElement e)  \n    {  \n        XNamespace w = e.Name.Namespace;  \n        return e  \n               .Elements(w + \"r\")  \n               .Elements(w + \"t\")  \n               .StringConcatenate(element => (string)element);  \n    }  \n  \n    static void Main(string[] args)  \n    {  \n        const string fileName = \"SampleDoc.docx\";  \n  \n        const string documentRelationshipType = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\";  \n        const string stylesRelationshipType = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\";  \n        const string wordmlNamespace = \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\";  \n        XNamespace w = wordmlNamespace;  \n  \n        XDocument xDoc = null;  \n        XDocument styleDoc = null;  \n  \n        using (Package wdPackage = Package.Open(fileName, FileMode.Open, FileAccess.Read))  \n        {  \n            PackageRelationship docPackageRelationship = wdPackage.GetRelationshipsByType(documentRelationshipType).FirstOrDefault();  \n            if (docPackageRelationship != null)  \n            {  \n                Uri documentUri = PackUriHelper.ResolvePartUri(new Uri(\"/\", UriKind.Relative), docPackageRelationship.TargetUri);  \n                PackagePart documentPart = wdPackage.GetPart(documentUri);  \n  \n                //  Load the document XML in the part into an XDocument instance.  \n                xDoc = XDocument.Load(XmlReader.Create(documentPart.GetStream()));  \n  \n                //  Find the styles part. There will only be one.  \n                PackageRelationship styleRelation = documentPart.GetRelationshipsByType(stylesRelationshipType).FirstOrDefault();  \n                if (styleRelation != null)  \n                {  \n                    Uri styleUri = PackUriHelper.ResolvePartUri(documentUri, styleRelation.TargetUri);  \n                    PackagePart stylePart = wdPackage.GetPart(styleUri);  \n  \n                    //  Load the style XML in the part into an XDocument instance.  \n                    styleDoc = XDocument.Load(XmlReader.Create(stylePart.GetStream()));  \n                }  \n            }  \n        }  \n  \n        string defaultStyle =  \n            (string)(  \n                from style in styleDoc.Root.Elements(w + \"style\")  \n                where (string)style.Attribute(w + \"type\") == \"paragraph\" &&  \n                      (string)style.Attribute(w + \"default\") == \"1\"  \n                select style  \n            ).First().Attribute(w + \"styleId\");  \n  \n        // Find all paragraphs in the document.  \n        var paragraphs =  \n            from para in xDoc  \n                         .Root  \n                         .Element(w + \"body\")  \n                         .Descendants(w + \"p\")  \n            let styleNode = para  \n                            .Elements(w + \"pPr\")  \n                            .Elements(w + \"pStyle\")  \n                            .FirstOrDefault()  \n            select new  \n            {  \n                ParagraphNode = para,  \n                StyleName = styleNode != null ?  \n                    (string)styleNode.Attribute(w + \"val\") :  \n                    defaultStyle  \n            };  \n  \n        // Retrieve the text of each paragraph.  \n        var paraWithText =  \n            from para in paragraphs  \n            select new  \n            {  \n                ParagraphNode = para.ParagraphNode,  \n                StyleName = para.StyleName,  \n                Text = ParagraphText(para.ParagraphNode)  \n            };  \n  \n        // Retrieve all paragraphs that have no text and are styled Code.  \n        var blankCodeParagraphs =  \n            from para in paraWithText  \n            where para.Text == \"\" && para.StyleName == \"Code\"  \n            select new  \n            {  \n                ParagraphNode = para.ParagraphNode,  \n                StyleName = para.StyleName,  \n                Text = para.Text  \n            };  \n  \n        foreach (var p in blankCodeParagraphs)  \n            Console.WriteLine(\"StyleName:{0} >{1}<\", p.StyleName, p.Text);  \n    }  \n}  \n```  \n  \n This example produces the following output:  \n  \n```  \nStyleName:Code ><  \n```  \n  \n Of course, this example could be enhanced in a number of ways. For example, we could use regular expressions to search for text, we could iterate through all the Word files in a particular directory, and so on.  \n  \n Note that this example performs approximately as well as if it were written as a single query. Because each query is implemented in a lazy, deferred fashion, each query does not yield its results until the query is iterated. For more information about execution and lazy evaluation, see [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).  \n  \n## Next Steps  \n The next section provides more information about WordprocessingML documents:  \n  \n-   [Details of Office Open XML WordprocessingML Documents (C#)](../../../../csharp/programming-guide/concepts/linq/details-of-office-open-xml-wordprocessingml-documents.md)  \n  \n## See also\n\n- [Tutorial: Manipulating Content in a WordprocessingML Document (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)\n- [Refactoring Using a Pure Function (C#)](../../../../csharp/programming-guide/concepts/linq/refactoring-using-a-pure-function.md)\n- [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)\n","nodes":[{"pos":[4,117],"embed":true,"restype":"x-metadata","content":"title: \"Finding Text in Word Documents (C#)\"\nms.date: 07/20/2015\nms.assetid: 82f86677-560b-49dc-a089-610409939b2a","nodes":[{"content":"Finding Text in Word Documents (C#)","nodes":[{"pos":[0,35],"content":"Finding Text in Word Documents (C#)","nodes":[{"content":"Finding Text in Word Documents (C#)","pos":[0,35]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[124,159],"content":"Finding Text in Word Documents (C#)","linkify":"Finding Text in Word Documents (C#)","nodes":[{"content":"Finding Text in Word Documents (C#)","pos":[0,35]}]},{"content":"This topic extends the previous queries to do something useful: find all occurrences of a string in the document.","pos":[160,273]},{"pos":[282,289],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example processes a WordprocessingML document, to find all the occurrences of a specific piece of text in the document.","pos":[293,417]},{"content":"To do this, we use a query that finds the string \"Hello\".","pos":[418,475]},{"content":"This example builds on the previous examples in this tutorial.","pos":[476,538]},{"content":"The new query is called out in comments in the code below.","pos":[539,597]},{"pos":[604,828],"content":"For instructions for creating the source document for this example, see <bpt id=\"p1\">[</bpt>Creating the Source Office Open XML Document (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md)</ept>.","source":"For instructions for creating the source document for this example, see [Creating the Source Office Open XML Document (C#)](../../../../csharp/programming-guide/concepts/linq/creating-the-source-office-open-xml-document.md)."},{"content":"This example uses classes found in the WindowsBase assembly.","pos":[835,895]},{"content":"It uses types in the <ph id=\"ph1\">&lt;xref:System.IO.Packaging?displayProperty=nameWithType&gt;</ph> namespace.","pos":[896,983],"source":" It uses types in the <xref:System.IO.Packaging?displayProperty=nameWithType> namespace."},{"content":"This example produces the following output:","pos":[6480,6523]},{"content":"You can, of course, modify the search so that it searches for lines with a specific style.","pos":[6637,6727]},{"content":"The following query finds all blank lines that have the Code style:","pos":[6728,6795]},{"content":"This example produces the following output:","pos":[12160,12203]},{"content":"Of course, this example could be enhanced in a number of ways.","pos":[12245,12307]},{"content":"For example, we could use regular expressions to search for text, we could iterate through all the Word files in a particular directory, and so on.","pos":[12308,12455]},{"content":"Note that this example performs approximately as well as if it were written as a single query.","pos":[12462,12556]},{"content":"Because each query is implemented in a lazy, deferred fashion, each query does not yield its results until the query is iterated.","pos":[12557,12686]},{"content":"For more information about execution and lazy evaluation, see <bpt id=\"p1\">[</bpt>Deferred Execution and Lazy Evaluation in LINQ to XML (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)</ept>.","pos":[12687,12919],"source":" For more information about execution and lazy evaluation, see [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)."},{"pos":[12928,12938],"content":"Next Steps","linkify":"Next Steps","nodes":[{"content":"Next Steps","pos":[0,10]}]},{"content":"The next section provides more information about WordprocessingML documents:","pos":[12942,13018]},{"pos":[13028,13197],"content":"<bpt id=\"p1\">[</bpt>Details of Office Open XML WordprocessingML Documents (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/details-of-office-open-xml-wordprocessingml-documents.md)</ept>","source":"[Details of Office Open XML WordprocessingML Documents (C#)](../../../../csharp/programming-guide/concepts/linq/details-of-office-open-xml-wordprocessingml-documents.md)"},{"pos":[13206,13214],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[13218,13402],"content":"<bpt id=\"p1\">[</bpt>Tutorial: Manipulating Content in a WordprocessingML Document (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)</ept>","source":"[Tutorial: Manipulating Content in a WordprocessingML Document (C#)](../../../../csharp/programming-guide/concepts/linq/tutorial-manipulating-content-in-a-wordprocessingml-document.md)"},{"pos":[13405,13534],"content":"<bpt id=\"p1\">[</bpt>Refactoring Using a Pure Function (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/refactoring-using-a-pure-function.md)</ept>","source":"[Refactoring Using a Pure Function (C#)](../../../../csharp/programming-guide/concepts/linq/refactoring-using-a-pure-function.md)"},{"pos":[13537,13706],"content":"<bpt id=\"p1\">[</bpt>Deferred Execution and Lazy Evaluation in LINQ to XML (C#)<ept id=\"p1\">](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)</ept>","source":"[Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](../../../../csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)"}]}