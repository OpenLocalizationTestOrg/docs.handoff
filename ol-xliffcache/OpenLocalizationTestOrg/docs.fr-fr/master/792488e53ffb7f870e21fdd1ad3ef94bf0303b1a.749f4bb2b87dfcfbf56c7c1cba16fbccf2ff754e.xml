{"content":"---\ntitle: \"How to: Implement Dynamic Partitions\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"tasks, how to create a dynamic partitioner\"\nms.assetid: c875ad12-a161-43e6-ad1c-3d6927c536a7\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"\n---\n# How to: Implement Dynamic Partitions\nThe following example shows how to implement a custom <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> that implements dynamic partitioning and can be used from certain overloads <xref:System.Threading.Tasks.Parallel.ForEach%2A> and from PLINQ.  \n  \n## Example  \n Each time a partition calls <xref:System.Collections.IEnumerator.MoveNext%2A> on the enumerator, the enumerator provides the partition with one list element. In the case of PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A>, the partition is a <xref:System.Threading.Tasks.Task> instance. Because requests are happening concurrently on multiple threads, access to the current index is synchronized.  \n  \n [!code-csharp[TPL_Partitioners#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#04)]\n [!code-vb[TPL_Partitioners#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/dynamicpartitioner.vb#04)]  \n  \n This is an example of chunk partitioning, with each chunk consisting of one element. By providing more elements at a time, you could reduce the contention over the lock and theoretically achieve faster performance. However, at some point, larger chunks might require additional load-balancing logic in order to keep all threads busy until all the work is done.  \n  \n## See also\n\n- [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)\n- [How to: Implement a Partitioner for Static Partitioning](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)\n","nodes":[{"pos":[4,296],"embed":true,"restype":"x-metadata","content":"title: \"How to: Implement Dynamic Partitions\"\nms.date: \"03/30/2017\"\nms.technology: dotnet-standard\ndev_langs: \n  - \"csharp\"\n  - \"vb\"\nhelpviewer_keywords: \n  - \"tasks, how to create a dynamic partitioner\"\nms.assetid: c875ad12-a161-43e6-ad1c-3d6927c536a7\nauthor: \"rpetrusha\"\nms.author: \"ronpet\"","nodes":[{"content":"How to: Implement Dynamic Partitions","nodes":[{"pos":[0,36],"content":"How to: Implement Dynamic Partitions","nodes":[{"content":"How to: Implement Dynamic Partitions","pos":[0,36]}]}],"path":["title"],"nosxs":false}],"yml":true},{"pos":[303,339],"content":"How to: Implement Dynamic Partitions","linkify":"How to: Implement Dynamic Partitions","nodes":[{"content":"How to: Implement Dynamic Partitions","pos":[0,36]}]},{"pos":[340,626],"content":"The following example shows how to implement a custom <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType&gt;</ph> that implements dynamic partitioning and can be used from certain overloads <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A&gt;</ph> and from PLINQ.","source":"The following example shows how to implement a custom <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> that implements dynamic partitioning and can be used from certain overloads <xref:System.Threading.Tasks.Parallel.ForEach%2A> and from PLINQ."},{"pos":[635,642],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Each time a partition calls <ph id=\"ph1\">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> on the enumerator, the enumerator provides the partition with one list element.","pos":[646,803],"source":"Each time a partition calls <xref:System.Collections.IEnumerator.MoveNext%2A> on the enumerator, the enumerator provides the partition with one list element."},{"content":"In the case of PLINQ and <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A&gt;</ph>, the partition is a <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instance.","pos":[804,943],"source":" In the case of PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A>, the partition is a <xref:System.Threading.Tasks.Task> instance."},{"content":"Because requests are happening concurrently on multiple threads, access to the current index is synchronized.","pos":[944,1053]},{"content":"This is an example of chunk partitioning, with each chunk consisting of one element.","pos":[1326,1410]},{"content":"By providing more elements at a time, you could reduce the contention over the lock and theoretically achieve faster performance.","pos":[1411,1540]},{"content":"However, at some point, larger chunks might require additional load-balancing logic in order to keep all threads busy until all the work is done.","pos":[1541,1686]},{"pos":[1695,1703],"content":"See also","linkify":"See also","nodes":[{"content":"See also","pos":[0,8]}]},{"pos":[1707,1832],"content":"<bpt id=\"p1\">[</bpt>Custom Partitioners for PLINQ and TPL<ept id=\"p1\">](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)</ept>","source":"[Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)"},{"pos":[1835,1995],"content":"<bpt id=\"p1\">[</bpt>How to: Implement a Partitioner for Static Partitioning<ept id=\"p1\">](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)</ept>","source":"[How to: Implement a Partitioner for Static Partitioning](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)"}]}