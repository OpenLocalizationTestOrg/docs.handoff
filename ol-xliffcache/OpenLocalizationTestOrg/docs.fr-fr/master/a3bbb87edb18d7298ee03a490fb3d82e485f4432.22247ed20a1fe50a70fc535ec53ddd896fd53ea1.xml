{"content":"---\ntitle: Native interoperability\ndescription: Native interoperability\nkeywords: .NET, .NET Core\nauthor: blackdwarf\nms.author: ronpet\nms.date: 06/20/2016\nms.topic: article\nms.prod: .net\nms.technology: dotnet-standard\nms.devlang: dotnet\nms.assetid: 3c357112-35fb-44ba-a07b-6a1c140370ac\n---\n\n# Native Interoperability\n\nIn this document, we will dive a little bit deeper into all three ways of doing \"native interoperability\" that are available on the .NET platform.\n\nThere are a few of reasons why you would want to call into native code:\n\n*   Operating Systems come with a large volume of APIs that are not present in the managed class libraries. A prime example for this would be access to hardware or operating system management functions.\n*   Communicating with other components that have or can produce C-style ABIs (native ABIs). This covers, for example, Java code that is exposed via [Java Native Interface (JNI)](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/) or any other managed language that could produce a native component.\n*   On Windows, most of the software that gets installed, such as Microsoft Office suite, registers COM components that represent their programs and allow developers to automate them or use them. This also requires native interoperability.\n\nOf course, the list above does not cover all of the potential situations and scenarios in which the developer would want/like/need to interface with native components. .NET class library, for instance, uses the native interoperability support to implement a fair number of its APIs, like console support and manipulation, file system access and others. However, it is important to note that there is an option, should one need it.\n\n> [!NOTE]\n> Most of the examples in this document will be presented for all three supported platforms for .NET Core (Windows, Linux and macOS). However, for some short and illustrative examples, just one sample is shown that uses Windows filenames and extensions (that is, \"dll\" for libraries). This does not mean that those features are not available on Linux or macOS, it was done merely for convenience sake.\n\n## Platform Invoke (P/Invoke)\n\nP/Invoke is a technology that allows you to access structs, callbacks and functions in unmanaged libraries from your managed code. Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`. Using these two namespaces will allow you access to the attributes that describe how you want to communicate with the native component.\n\nLet’s start from the most common example, and that is calling unmanaged functions in your managed code. Let’s show a message box from a command-line application:\n\n```csharp\nusing System.Runtime.InteropServices;\n\npublic class Program {\n\n    // Import user32.dll (containing the function we need) and define\n    // the method corresponding to the native function.\n    [DllImport(\"user32.dll\")]\n    public static extern int MessageBox(IntPtr hWnd, String text, String caption, int options);\n\n    public static void Main(string[] args) {\n        // Invoke the function as a regular managed method.\n        MessageBox(IntPtr.Zero, \"Command-line message box\", \"Attention!\", 0);\n    }\n}\n\n```\n\nThe example above is pretty simple, but it does show off what is needed to invoke unmanaged functions from managed code. Let’s step through the example:\n\n*   Line #1 shows the using statement for the `System.Runtime.InteropServices` which is the namespace that holds all of the items we need.\n*   Line #5 introduces the `DllImport` attribute. This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL. This is the DLL into which we wish to invoke.\n*   Line #6 is the crux of the P/Invoke work. It defines a managed method that has the **exact same signature** as the unmanaged one. The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.\n\nThe rest of the example is just invoking the method as you would any other managed method.\n\nThe sample is similar for macOS. One thing that needs to change is, of course, the name of the library in the `DllImport` attribute, as macOS has a different scheme of naming dynamic libraries. The sample below uses the `getpid(2)` function to get the process ID of the application and print it out to the console.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace PInvokeSamples {\n    public static class Program {\n\n        // Import the libc and define the method corresponding to the native function.\n        [DllImport(\"libSystem.dylib\")]\n        private static extern int getpid();\n\n        public static void Main(string[] args){\n            // Invoke the function and get the process ID.\n            int pid = getpid();\n            Console.WriteLine(pid);\n        }\n    }\n}\n\n```\n\nIt is similar on Linux, of course. The function name is same, since `getpid(2)` is [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace PInvokeSamples {\n    public static class Program {\n\n        // Import the libc and define the method corresponding to the native function.\n        [DllImport(\"libc.so.6\")]\n        private static extern int getpid();\n\n        public static void Main(string[] args){\n            // Invoke the function and get the process ID.\n            int pid = getpid();\n            Console.WriteLine(pid);\n        }\n    }\n}\n\n```\n\n### Invoking managed code from unmanaged code\n\nOf course, the runtime allows communication to flow both ways which enables you to call into managed artifacts from native functions, using function pointers. The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.\n\nThe way to use this feature is similar to managed to native process described above. For a given callback, you define a delegate that matches the signature, and pass that into the external method. The runtime will take care of everything else.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace ConsoleApplication1 {\n\n    class Program {\n\n        // Define a delegate that corresponds to the unmanaged function.\n        delegate bool EnumWC(IntPtr hwnd, IntPtr lParam);\n\n        // Import user32.dll (containing the function we need) and define\n        // the method corresponding to the native function.\n        [DllImport(\"user32.dll\")]\n        static extern int EnumWindows(EnumWC lpEnumFunc, IntPtr lParam);\n\n        // Define the implementation of the delegate; here, we simply output the window handle.\n        static bool OutputWindow(IntPtr hwnd, IntPtr lParam) {\n            Console.WriteLine(hwnd.ToInt64());\n            return true;\n        }\n\n        static void Main(string[] args) {\n            // Invoke the method; note the delegate as a first parameter.\n            EnumWindows(OutputWindow, IntPtr.Zero);\n        }\n    }\n}\n\n```\n\nBefore we walk through our example, it is good to go over the signatures of the unmanaged functions we need to work with. The function we want to call to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`\n\nThe first parameter is a callback. The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`\n\nWith this in mind, let’s walk through the example:\n\n*   Line #8 in the example defines a delegate that matches the signature of the callback from unmanaged code. Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.\n*   Lines #10 and #11 introduce the `EnumWindows` function from the user32.dll library.\n*   Lines #13 - 16 implement the delegate. For this simple example, we just want to output the handle to the console.\n*   Finally, in line #19 we invoke the external method and pass in the delegate.\n\nThe Linux and macOS examples are shown below. For them, we use the `ftw` function that can be found in `libc`, the C library. This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters. The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace PInvokeSamples {\n    public static class Program {\n\n            // Define a delegate that has the same signature as the native function.\n            delegate int DirClbk(string fName, StatClass stat, int typeFlag);\n\n            // Import the libc and define the method to represent the native function.\n            [DllImport(\"libc.so.6\")]\n            static extern int ftw(string dirpath, DirClbk cl, int descriptors);\n\n            // Implement the above DirClbk delegate;\n            // this one just prints out the filename that is passed to it.\n            static int DisplayEntry(string fName, StatClass stat, int typeFlag) {\n                    Console.WriteLine(fName);\n                    return 0;\n            }\n\n            public static void Main(string[] args){\n                    // Call the native function.\n                    // Note the second parameter which represents the delegate (callback).\n                    ftw(\".\", DisplayEntry, 10);\n            }\n    }\n\n    // The native callback takes a pointer to a struct. The below class\n    // represents that struct in managed code. You can find more information\n    // about this in the section on marshalling below.\n    [StructLayout(LayoutKind.Sequential)]\n    public class StatClass {\n            public uint DeviceID;\n            public uint InodeNumber;\n            public uint Mode;\n            public uint HardLinks;\n            public uint UserID;\n            public uint GroupID;\n            public uint SpecialDeviceID;\n            public ulong Size;\n            public ulong BlockSize;\n            public uint Blocks;\n            public long TimeLastAccess;\n            public long TimeLastModification;\n            public long TimeLastStatusChange;\n    }\n}\n\n```\n\nmacOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace PInvokeSamples {\n        public static class Program {\n\n                // Define a delegate that has the same signature as the native function.\n                delegate int DirClbk(string fName, StatClass stat, int typeFlag);\n\n                // Import the libc and define the method to represent the native function.\n                [DllImport(\"libSystem.dylib\")]\n                static extern int ftw(string dirpath, DirClbk cl, int descriptors);\n\n                // Implement the above DirClbk delegate;\n                // this one just prints out the filename that is passed to it.\n                static int DisplayEntry(string fName, StatClass stat, int typeFlag) {\n                        Console.WriteLine(fName);\n                        return 0;\n                }\n\n                public static void Main(string[] args){\n                        // Call the native function.\n                        // Note the second parameter which represents the delegate (callback).\n                        ftw(\".\", DisplayEntry, 10);\n                }\n        }\n\n        // The native callback takes a pointer to a struct. The below class\n        // represents that struct in managed code. You can find more information\n        // about this in the section on marshalling below.\n        [StructLayout(LayoutKind.Sequential)]\n        public class StatClass {\n                public uint DeviceID;\n                public uint InodeNumber;\n                public uint Mode;\n                public uint HardLinks;\n                public uint UserID;\n                public uint GroupID;\n                public uint SpecialDeviceID;\n                public ulong Size;\n                public ulong BlockSize;\n                public uint Blocks;\n                public long TimeLastAccess;\n                public long TimeLastModification;\n                public long TimeLastStatusChange;\n        }\n}\n\n```\n\nBoth of the above examples depend on parameters, and in both cases, the parameters are given as managed types. Runtime does the \"right thing\" and processes these into its equivalents on the other side. Since this process is really important to writing quality native interop code, let’s take a look at what happens when the runtime _marshals_ the types.\n\n## Type marshalling\n\n**Marshalling** is the process of transforming types when they need to cross the managed boundary into native and vice versa.\n\nThe reason marshalling is needed is because the types in the managed and unmanaged code are different. In managed code, for instance, you have a `String`, while in the unmanaged world strings can be Unicode (\"wide\"), non-Unicode, null-terminated, ASCII, etc. By default, the P/Invoke subsystem will try to do the Right Thing based on the default behavior which you can see on [MSDN](https://msdn.microsoft.com/library/zah6xy75.aspx). However, for those situations where you need extra control, you can employ the `MarshalAs` attribute to specify what is the expected type on the unmanaged side. For instance, if we want the string to be sent as a null-terminated ANSI string, we could do it like this:\n\n```csharp\n[DllImport(\"somenativelibrary.dll\")]\nstatic extern int MethodA([MarshalAs(UnmanagedType.LPStr)] string parameter);\n\n```\n\n### Marshalling classes and structs\n\nAnother aspect of type marshalling is how to pass in a struct to an unmanaged method. For instance, some of the unmanaged methods require a struct as a parameter. In these cases, we need to create a corresponding struct or a class in managed part of the world to use it as a parameter. However, just defining the class is not enough, we also need to instruct the marshaler how to map fields in the class to the unmanaged struct. This is where the `StructLayout` attribute comes into play.\n\n```csharp\n[DllImport(\"kernel32.dll\")]\nstatic extern void GetSystemTime(SystemTime systemTime);\n\n[StructLayout(LayoutKind.Sequential)]\nclass SystemTime {\n    public ushort Year;\n    public ushort Month;\n    public ushort DayOfWeek;\n    public ushort Day;\n    public ushort Hour;\n    public ushort Minute;\n    public ushort Second;\n    public ushort Milsecond;\n}\n\npublic static void Main(string[] args) {\n    SystemTime st = new SystemTime();\n    GetSystemTime(st);\n    Console.WriteLine(st.Year);\n}\n\n```\n\nThe example above shows off a simple example of calling into `GetSystemTime()` function. The interesting bit is on line 4. The attribute specifies that the fields of the class should be mapped sequentially to the struct on the other (unmanaged) side. This means that the naming of the fields is not important, only their order is important, as it needs to correspond to the unmanaged struct, shown below:\n\n```c\ntypedef struct _SYSTEMTIME {\n  WORD wYear;\n  WORD wMonth;\n  WORD wDayOfWeek;\n  WORD wDay;\n  WORD wHour;\n  WORD wMinute;\n  WORD wSecond;\n  WORD wMilliseconds;\n} SYSTEMTIME, *PSYSTEMTIME*;\n\n```\n\nWe already saw the Linux and macOS example for this in the previous example. It is shown again below.\n\n```csharp\n[StructLayout(LayoutKind.Sequential)]\npublic class StatClass {\n        public uint DeviceID;\n        public uint InodeNumber;\n        public uint Mode;\n        public uint HardLinks;\n        public uint UserID;\n        public uint GroupID;\n        public uint SpecialDeviceID;\n        public ulong Size;\n        public ulong BlockSize;\n        public uint Blocks;\n        public long TimeLastAccess;\n        public long TimeLastModification;\n        public long TimeLastStatusChange;\n}\n\n```\n\nThe `StatClass` class represents a structure that is returned by the `stat` system call on UNIX systems. It represents information about a given file. The class above is the stat struct representation in managed code. Again, the fields in the class have to be in the same order as the native struct (you can find these by perusing man pages on your favorite UNIX implementation) and they have to be of the same underlying type.\n\n## More resources\n\n*   [PInvoke.net wiki](http://www.pinvoke.net) an excellent Wiki with information on common Win32 APIs and how to call them.\n*   [P/Invoke on MSDN](https://msdn.microsoft.com/library/zbz07712.aspx)\n*   [Mono documentation on P/Invoke](http://www.mono-project.com/docs/advanced/pinvoke/)\n","nodes":[{"pos":[11,34],"content":"Native interoperability","needQuote":true,"needEscape":true,"nodes":[{"content":"Native interoperability","pos":[0,23]}]},{"pos":[48,71],"content":"Native interoperability","needQuote":true,"needEscape":true,"nodes":[{"content":"Native interoperability","pos":[0,23]}]},{"pos":[82,97],"content":".NET, .NET Core","needQuote":true,"needEscape":true,"nodes":[{"content":".NET, .NET Core","pos":[0,15]}]},{"pos":[293,316],"content":"Native Interoperability","linkify":"Native Interoperability","nodes":[{"content":"Native Interoperability","pos":[0,23]}]},{"content":"In this document, we will dive a little bit deeper into all three ways of doing \"native interoperability\" that are available on the .NET platform.","pos":[318,464]},{"content":"There are a few of reasons why you would want to call into native code:","pos":[466,537]},{"content":"Operating Systems come with a large volume of APIs that are not present in the managed class libraries.","pos":[543,646]},{"content":"A prime example for this would be access to hardware or operating system management functions.","pos":[647,741]},{"content":"Communicating with other components that have or can produce C-style ABIs (native ABIs).","pos":[746,834]},{"content":"This covers, for example, Java code that is exposed via <bpt id=\"p1\">[</bpt>Java Native Interface (JNI)<ept id=\"p1\">](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/)</ept> or any other managed language that could produce a native component.","pos":[835,1049],"source":" This covers, for example, Java code that is exposed via [Java Native Interface (JNI)](http://docs.oracle.com/javase/8/docs/technotes/guides/jni/) or any other managed language that could produce a native component."},{"content":"On Windows, most of the software that gets installed, such as Microsoft Office suite, registers COM components that represent their programs and allow developers to automate them or use them.","pos":[1054,1245]},{"content":"This also requires native interoperability.","pos":[1246,1289]},{"content":"Of course, the list above does not cover all of the potential situations and scenarios in which the developer would want/like/need to interface with native components.","pos":[1291,1458]},{"content":".NET class library, for instance, uses the native interoperability support to implement a fair number of its APIs, like console support and manipulation, file system access and others.","pos":[1459,1643]},{"content":"However, it is important to note that there is an option, should one need it.","pos":[1644,1721]},{"pos":[1725,2134],"content":"[!NOTE]\nMost of the examples in this document will be presented for all three supported platforms for .NET Core (Windows, Linux and macOS). However, for some short and illustrative examples, just one sample is shown that uses Windows filenames and extensions (that is, \"dll\" for libraries). This does not mean that those features are not available on Linux or macOS, it was done merely for convenience sake.","leadings":["","> "],"nodes":[{"content":"Most of the examples in this document will be presented for all three supported platforms for .NET Core (Windows, Linux and macOS). However, for some short and illustrative examples, just one sample is shown that uses Windows filenames and extensions (that is, \"dll\" for libraries). This does not mean that those features are not available on Linux or macOS, it was done merely for convenience sake.","pos":[8,407],"nodes":[{"content":"Most of the examples in this document will be presented for all three supported platforms for .NET Core (Windows, Linux and macOS).","pos":[0,131]},{"content":"However, for some short and illustrative examples, just one sample is shown that uses Windows filenames and extensions (that is, \"dll\" for libraries).","pos":[132,282]},{"content":"This does not mean that those features are not available on Linux or macOS, it was done merely for convenience sake.","pos":[283,399]}]}]},{"pos":[2139,2165],"content":"Platform Invoke (P/Invoke)","linkify":"Platform Invoke (P/Invoke)","nodes":[{"content":"Platform Invoke (P/Invoke)","pos":[0,26]}]},{"content":"P/Invoke is a technology that allows you to access structs, callbacks and functions in unmanaged libraries from your managed code.","pos":[2167,2297]},{"content":"Most of the P/Invoke API is contained in two namespaces: <ph id=\"ph1\">`System`</ph> and <ph id=\"ph2\">`System.Runtime.InteropServices`</ph>.","pos":[2298,2401],"source":" Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`."},{"content":"Using these two namespaces will allow you access to the attributes that describe how you want to communicate with the native component.","pos":[2402,2537]},{"content":"Let’s start from the most common example, and that is calling unmanaged functions in your managed code.","pos":[2539,2642]},{"content":"Let’s show a message box from a command-line application:","pos":[2643,2700]},{"content":"The example above is pretty simple, but it does show off what is needed to invoke unmanaged functions from managed code.","pos":[3225,3345]},{"content":"Let’s step through the example:","pos":[3346,3377]},{"pos":[3383,3517],"content":"Line #1 shows the using statement for the <ph id=\"ph1\">`System.Runtime.InteropServices`</ph> which is the namespace that holds all of the items we need.","source":"Line #1 shows the using statement for the `System.Runtime.InteropServices` which is the namespace that holds all of the items we need."},{"content":"Line #5 introduces the <ph id=\"ph1\">`DllImport`</ph> attribute.","pos":[3522,3567],"source":"Line #5 introduces the `DllImport` attribute."},{"content":"This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.","pos":[3568,3657]},{"content":"This is the DLL into which we wish to invoke.","pos":[3658,3703]},{"content":"Line #6 is the crux of the P/Invoke work.","pos":[3708,3749]},{"content":"It defines a managed method that has the <bpt id=\"p1\">**</bpt>exact same signature<ept id=\"p1\">**</ept> as the unmanaged one.","pos":[3750,3837],"source":" It defines a managed method that has the **exact same signature** as the unmanaged one."},{"content":"The declaration has a new keyword that you can notice, <ph id=\"ph1\">`extern`</ph>, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in <ph id=\"ph2\">`DllImport`</ph> attribute.","pos":[3838,4057],"source":" The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute."},{"content":"The rest of the example is just invoking the method as you would any other managed method.","pos":[4059,4149]},{"content":"The sample is similar for macOS.","pos":[4151,4183]},{"content":"One thing that needs to change is, of course, the name of the library in the <ph id=\"ph1\">`DllImport`</ph> attribute, as macOS has a different scheme of naming dynamic libraries.","pos":[4184,4344],"source":" One thing that needs to change is, of course, the name of the library in the `DllImport` attribute, as macOS has a different scheme of naming dynamic libraries."},{"content":"The sample below uses the <ph id=\"ph1\">`getpid(2)`</ph> function to get the process ID of the application and print it out to the console.","pos":[4345,4465],"source":" The sample below uses the `getpid(2)` function to get the process ID of the application and print it out to the console."},{"content":"It is similar on Linux, of course.","pos":[4962,4996]},{"content":"The function name is same, since <ph id=\"ph1\">`getpid(2)`</ph> is <bpt id=\"p1\">[</bpt>POSIX<ept id=\"p1\">](https://en.wikipedia.org/wiki/POSIX)</ept> system call.","pos":[4997,5102],"source":" The function name is same, since `getpid(2)` is [POSIX](https://en.wikipedia.org/wiki/POSIX) system call."},{"pos":[5597,5638],"content":"Invoking managed code from unmanaged code","linkify":"Invoking managed code from unmanaged code","nodes":[{"content":"Invoking managed code from unmanaged code","pos":[0,41]}]},{"content":"Of course, the runtime allows communication to flow both ways which enables you to call into managed artifacts from native functions, using function pointers.","pos":[5640,5798]},{"content":"The closest thing to a function pointer in managed code is a <bpt id=\"p1\">**</bpt>delegate<ept id=\"p1\">**</ept>, so this is what is used to allow callbacks from native code into managed code.","pos":[5799,5952],"source":" The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code."},{"content":"The way to use this feature is similar to managed to native process described above.","pos":[5954,6038]},{"content":"For a given callback, you define a delegate that matches the signature, and pass that into the external method.","pos":[6039,6150]},{"content":"The runtime will take care of everything else.","pos":[6151,6197]},{"content":"Before we walk through our example, it is good to go over the signatures of the unmanaged functions we need to work with.","pos":[7124,7245]},{"content":"The function we want to call to enumerate all of the windows has the following signature: <ph id=\"ph1\">`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</ph>","pos":[7246,7395],"source":" The function we want to call to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`"},{"content":"The first parameter is a callback.","pos":[7397,7431]},{"content":"The said callback has the following signature: <ph id=\"ph1\">`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</ph>","pos":[7432,7538],"source":" The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`"},{"content":"With this in mind, let’s walk through the example:","pos":[7540,7590]},{"content":"Line #8 in the example defines a delegate that matches the signature of the callback from unmanaged code.","pos":[7596,7701]},{"content":"Notice how the LPARAM and HWND types are represented using <ph id=\"ph1\">`IntPtr`</ph> in the managed code.","pos":[7702,7790],"source":" Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code."},{"pos":[7795,7878],"content":"Lines #10 and #11 introduce the <ph id=\"ph1\">`EnumWindows`</ph> function from the user32.dll library.","source":"Lines #10 and #11 introduce the `EnumWindows` function from the user32.dll library."},{"content":"Lines #13 - 16 implement the delegate.","pos":[7883,7921]},{"content":"For this simple example, we just want to output the handle to the console.","pos":[7922,7996]},{"content":"Finally, in line #19 we invoke the external method and pass in the delegate.","pos":[8001,8077]},{"content":"The Linux and macOS examples are shown below.","pos":[8079,8124]},{"content":"For them, we use the <ph id=\"ph1\">`ftw`</ph> function that can be found in <ph id=\"ph2\">`libc`</ph>, the C library.","pos":[8125,8204],"source":" For them, we use the `ftw` function that can be found in `libc`, the C library."},{"content":"This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.","pos":[8205,8323]},{"content":"The said function has the following signature: <ph id=\"ph1\">`int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`</ph>.","pos":[8324,8440],"source":" The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`."},{"pos":[10260,10411],"content":"macOS example uses the same function, and the only difference is the argument to the <ph id=\"ph1\">`DllImport`</ph> attribute, as macOS keeps <ph id=\"ph2\">`libc`</ph> in a different place.","source":"macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place."},{"content":"Both of the above examples depend on parameters, and in both cases, the parameters are given as managed types.","pos":[12385,12495]},{"content":"Runtime does the \"right thing\" and processes these into its equivalents on the other side.","pos":[12496,12586]},{"content":"Since this process is really important to writing quality native interop code, let’s take a look at what happens when the runtime <bpt id=\"p1\">_</bpt>marshals<ept id=\"p1\">_</ept> the types.","pos":[12587,12738],"source":" Since this process is really important to writing quality native interop code, let’s take a look at what happens when the runtime _marshals_ the types."},{"pos":[12743,12759],"content":"Type marshalling","linkify":"Type marshalling","nodes":[{"content":"Type marshalling","pos":[0,16]}]},{"pos":[12761,12886],"content":"<bpt id=\"p1\">**</bpt>Marshalling<ept id=\"p1\">**</ept> is the process of transforming types when they need to cross the managed boundary into native and vice versa.","source":"**Marshalling** is the process of transforming types when they need to cross the managed boundary into native and vice versa."},{"content":"The reason marshalling is needed is because the types in the managed and unmanaged code are different.","pos":[12888,12990]},{"content":"In managed code, for instance, you have a <ph id=\"ph1\">`String`</ph>, while in the unmanaged world strings can be Unicode (\"wide\"), non-Unicode, null-terminated, ASCII, etc. By default, the P/Invoke subsystem will try to do the Right Thing based on the default behavior which you can see on <bpt id=\"p1\">[</bpt>MSDN<ept id=\"p1\">](https://msdn.microsoft.com/library/zah6xy75.aspx)</ept>.","pos":[12991,13321],"source":" In managed code, for instance, you have a `String`, while in the unmanaged world strings can be Unicode (\"wide\"), non-Unicode, null-terminated, ASCII, etc. By default, the P/Invoke subsystem will try to do the Right Thing based on the default behavior which you can see on [MSDN](https://msdn.microsoft.com/library/zah6xy75.aspx)."},{"content":"However, for those situations where you need extra control, you can employ the <ph id=\"ph1\">`MarshalAs`</ph> attribute to specify what is the expected type on the unmanaged side.","pos":[13322,13482],"source":" However, for those situations where you need extra control, you can employ the `MarshalAs` attribute to specify what is the expected type on the unmanaged side."},{"content":"For instance, if we want the string to be sent as a null-terminated ANSI string, we could do it like this:","pos":[13483,13589]},{"pos":[13726,13757],"content":"Marshalling classes and structs","linkify":"Marshalling classes and structs","nodes":[{"content":"Marshalling classes and structs","pos":[0,31]}]},{"content":"Another aspect of type marshalling is how to pass in a struct to an unmanaged method.","pos":[13759,13844]},{"content":"For instance, some of the unmanaged methods require a struct as a parameter.","pos":[13845,13921]},{"content":"In these cases, we need to create a corresponding struct or a class in managed part of the world to use it as a parameter.","pos":[13922,14044]},{"content":"However, just defining the class is not enough, we also need to instruct the marshaler how to map fields in the class to the unmanaged struct.","pos":[14045,14187]},{"content":"This is where the <ph id=\"ph1\">`StructLayout`</ph> attribute comes into play.","pos":[14188,14247],"source":" This is where the `StructLayout` attribute comes into play."},{"content":"The example above shows off a simple example of calling into <ph id=\"ph1\">`GetSystemTime()`</ph> function.","pos":[14753,14841],"source":"The example above shows off a simple example of calling into `GetSystemTime()` function."},{"content":"The interesting bit is on line 4.","pos":[14842,14875]},{"content":"The attribute specifies that the fields of the class should be mapped sequentially to the struct on the other (unmanaged) side.","pos":[14876,15003]},{"content":"This means that the naming of the fields is not important, only their order is important, as it needs to correspond to the unmanaged struct, shown below:","pos":[15004,15157]},{"content":"We already saw the Linux and macOS example for this in the previous example.","pos":[15357,15433]},{"content":"It is shown again below.","pos":[15434,15458]},{"content":"The <ph id=\"ph1\">`StatClass`</ph> class represents a structure that is returned by the <ph id=\"ph2\">`stat`</ph> system call on UNIX systems.","pos":[15962,16066],"source":"The `StatClass` class represents a structure that is returned by the `stat` system call on UNIX systems."},{"content":"It represents information about a given file.","pos":[16067,16112]},{"content":"The class above is the stat struct representation in managed code.","pos":[16113,16179]},{"content":"Again, the fields in the class have to be in the same order as the native struct (you can find these by perusing man pages on your favorite UNIX implementation) and they have to be of the same underlying type.","pos":[16180,16389]},{"pos":[16394,16408],"content":"More resources","linkify":"More resources","nodes":[{"content":"More resources","pos":[0,14]}]},{"pos":[16414,16534],"content":"<bpt id=\"p1\">[</bpt>PInvoke.net wiki<ept id=\"p1\">](http://www.pinvoke.net)</ept> an excellent Wiki with information on common Win32 APIs and how to call them.","source":"[PInvoke.net wiki](http://www.pinvoke.net) an excellent Wiki with information on common Win32 APIs and how to call them."},{"pos":[16539,16607],"content":"<bpt id=\"p1\">[</bpt>P/Invoke on MSDN<ept id=\"p1\">](https://msdn.microsoft.com/library/zbz07712.aspx)</ept>","source":"[P/Invoke on MSDN](https://msdn.microsoft.com/library/zbz07712.aspx)"},{"pos":[16612,16696],"content":"<bpt id=\"p1\">[</bpt>Mono documentation on P/Invoke<ept id=\"p1\">](http://www.mono-project.com/docs/advanced/pinvoke/)</ept>","source":"[Mono documentation on P/Invoke](http://www.mono-project.com/docs/advanced/pinvoke/)"}]}