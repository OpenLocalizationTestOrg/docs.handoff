{"content":"---\ntitle: \"Implementing the Event-based Asynchronous Pattern | Microsoft Docs\"\nms.custom: \"\"\nms.date: \"03/30/2017\"\nms.prod: \".net\"\nms.reviewer: \"\"\nms.suite: \"\"\nms.technology: dotnet-standard\nms.tgt_pltfrm: \"\"\nms.topic: \"article\"\nhelpviewer_keywords: \n  - \"Event-based Asynchronous Pattern\"\n  - \"ProgressChangedEventArgs class\"\n  - \"BackgroundWorker component\"\n  - \"events [.NET Framework], asynchronous\"\n  - \"Asynchronous Pattern\"\n  - \"AsyncOperationManager class\"\n  - \"threading [.NET Framework], asynchronous features\"\n  - \"components [.NET Framework], asynchronous\"\n  - \"AsyncOperation class\"\n  - \"AsyncCompletedEventArgs class\"\nms.assetid: 43402d19-8d30-426d-8785-1a4478233bfa\ncaps.latest.revision: 20\nauthor: dotnet-bot\nms.author: dotnetcontent\nmanager: \"wpickett\"\n---\n# Implementing the Event-based Asynchronous Pattern\nIf you are writing a class with some operations that may incur noticeable delays, consider giving it asynchronous functionality by implementing [Event-based Asynchronous Pattern Overview](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md).  \n  \n The Event-based Asynchronous Pattern provides a standardized way to package a class that has asynchronous features. If implemented with helper classes like <xref:System.ComponentModel.AsyncOperationManager>, your class will work correctly under any application model, including [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)], Console applications, and Windows Forms applications.  \n  \n For an example that implements the Event-based Asynchronous Pattern, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).  \n  \n For simple asynchronous operations, you may find the <xref:System.ComponentModel.BackgroundWorker> component suitable. For more information about <xref:System.ComponentModel.BackgroundWorker>, see [How to: Run an Operation in the Background](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  \n  \n The following list describes the features of the Event-based Asynchronous Pattern discussed in this topic.  \n  \n-   Opportunities for Implementing the Event-based Asynchronous Pattern  \n  \n-   Naming Asynchronous Methods  \n  \n-   Optionally Support Cancellation  \n  \n-   Optionally Support the IsBusy Property  \n  \n-   Optionally Provide Support for Progress Reporting  \n  \n-   Optionally Provide Support for Returning Incremental Results  \n  \n-   Handling Out and Ref Parameters in Methods  \n  \n## Opportunities for Implementing the Event-based Asynchronous Pattern  \n Consider implementing the Event-based Asynchronous Pattern when:  \n  \n-   Clients of your class do not need <xref:System.Threading.WaitHandle> and <xref:System.IAsyncResult> objects available for asynchronous operations, meaning that polling and <xref:System.Threading.WaitHandle.WaitAll%2A> or <xref:System.Threading.WaitHandle.WaitAny%2A> will need to be built up by the client.  \n  \n-   You want asynchronous operations to be managed by the client with the familiar event/delegate model.  \n  \n Any operation is a candidate for an asynchronous implementation, but those you expect to incur long latencies should be considered. Especially appropriate are operations in which clients call a method and are notified on completion, with no further intervention required. Also appropriate are operations which run continuously, periodically notifying clients of progress, incremental results, or state changes.  \n  \n For more information on deciding when to support the Event-based Asynchronous Pattern, see [Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md).  \n  \n## Naming Asynchronous Methods  \n For each synchronous method *MethodName* for which you want to provide an asynchronous counterpart:  \n  \n Define a *MethodName*`Async` method that:  \n  \n-   Returns `void`.  \n  \n-   Takes the same parameters as the *MethodName* method.  \n  \n-   Accepts multiple invocations.  \n  \n Optionally define a *MethodName*`Async` overload, identical to *MethodName*`Async`, but with an additional object-valued parameter called `userState`. Do this if you're prepared to manage multiple concurrent invocations of your method, in which case the `userState` value will be delivered back to all event handlers to distinguish invocations of the method. You may also choose to do this simply as a place to store user state for later retrieval.  \n  \n For each separate *MethodName*`Async` method signature:  \n  \n1.  Define the following event in the same class as the method:  \n  \n    ```vb  \n    Public Event MethodNameCompleted As MethodNameCompletedEventHandler  \n    ```  \n  \n    ```csharp  \n    public event MethodNameCompletedEventHandler MethodNameCompleted;  \n    ```  \n  \n2.  Define the following delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs>. These will likely be defined outside of the class itself, but in the same namespace.  \n  \n    ```vb  \n    Public Delegate Sub MethodNameCompletedEventHandler( _  \n        ByVal sender As Object, _  \n        ByVal e As MethodNameCompletedEventArgs)  \n  \n    Public Class MethodNameCompletedEventArgs  \n        Inherits System.ComponentModel.AsyncCompletedEventArgs  \n    Public ReadOnly Property Result() As MyReturnType  \n    End Property  \n    ```  \n  \n    ```csharp  \n    public delegate void MethodNameCompletedEventHandler(object sender,   \n        MethodNameCompletedEventArgs e);  \n  \n    public class MethodNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs  \n    {  \n        public MyReturnType Result { get; }  \n    }  \n    ```  \n  \n    -   Ensure that the *MethodName*`CompletedEventArgs` class exposes its members as read-only properties, and not fields, as fields prevent data binding.  \n  \n    -   Do not define any <xref:System.ComponentModel.AsyncCompletedEventArgs>-derived classes for methods that do not produce results. Simply use an instance of <xref:System.ComponentModel.AsyncCompletedEventArgs> itself.  \n  \n        > [!NOTE]\n        >  It is perfectly acceptable, when feasible and appropriate, to reuse delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> types. In this case, the naming will not be as consistent with the method name, since a given delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> won't be tied to a single method.  \n  \n## Optionally Support Cancellation  \n If your class will support canceling asynchronous operations, cancellation should be exposed to the client as described below. Note that there are two decision points that need to be reached before defining your cancellation support:  \n  \n-   Does your class, including future anticipated additions to it, have only one asynchronous operation that supports cancellation?  \n  \n-   Can the asynchronous operations that support cancellation support multiple pending operations? That is, does the *MethodName*`Async` method take a `userState` parameter, and does it allow multiple invocations before waiting for any to finish?  \n  \n Use the answers to these two questions in the table below to determine what the signature for your cancellation method should be.  \n  \n### Visual Basic  \n  \n||Multiple Simultaneous Operations Supported|Only One Operation at a Time|  \n|------|------------------------------------------------|----------------------------------|  \n|One Async Operation in entire class|`Sub MethodNameAsyncCancel(ByVal userState As Object)`|`Sub MethodNameAsyncCancel()`|  \n|Multiple Async Operations in class|`Sub CancelAsync(ByVal userState As Object)`|`Sub CancelAsync()`|  \n  \n### C#  \n  \n||Multiple Simultaneous Operations Supported|Only One Operation at a Time|  \n|------|------------------------------------------------|----------------------------------|  \n|One Async Operation in entire class|`void MethodNameAsyncCancel(object userState);`|`void MethodNameAsyncCancel();`|  \n|Multiple Async Operations in class|`void CancelAsync(object userState);`|`void CancelAsync();`|  \n  \n If you define the `CancelAsync(object userState)` method, clients must be careful when choosing their state values to make them capable of distinguishing among all asynchronous methods invoked on the object, and not just between all invocations of a single asynchronous method.  \n  \n The decision to name the single-async-operation version *MethodName*`AsyncCancel` is based on being able to more easily discover the method in a design environment like Visual Studio's IntelliSense. This groups the related members and distinguishes them from other members that have nothing to do with asynchronous functionality. If you expect that there may be additional asynchronous operations added in subsequent versions, it is better to define `CancelAsync`.  \n  \n Do not define multiple methods from the table above in the same class. That will not make sense, or it will clutter the class interface with a proliferation of methods.  \n  \n These methods typically will return immediately, and the operation may or may not actually cancel. In the event handler for the *MethodName*`Completed` event, the *MethodName*`CompletedEventArgs` object contains a `Cancelled` field, which clients can use to determine whether the cancellation occurred.  \n  \n Abide by the cancellation semantics described in [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md).  \n  \n## Optionally Support the IsBusy Property  \n If your class does not support multiple concurrent invocations, consider exposing an `IsBusy` property. This allows developers to determine whether a *MethodName*`Async` method is running without catching an exception from the *MethodName*`Async` method.  \n  \n Abide by the `IsBusy` semantics described in [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md).  \n  \n## Optionally Provide Support for Progress Reporting  \n It is frequently desirable for an asynchronous operation to report progress during its operation. The Event-based Asynchronous Pattern provides a guideline for doing so.  \n  \n-   Optionally define an event to be raised by the asynchronous operation and invoked on the appropriate thread. The <xref:System.ComponentModel.ProgressChangedEventArgs> object carries an integer-valued progress indicator that is expected to be between 0 and 100.  \n  \n-   Name this event as follows:  \n  \n    -   `ProgressChanged` if the class has multiple asynchronous operations (or is expected to grow to include multiple asynchronous operations in future versions);  \n  \n    -   *MethodName* `ProgressChanged` if the class has a single asynchronous operation.  \n  \n     This naming choice parallels that made for the cancellation method, as described in the Optionally Support Cancellation section.  \n  \n This event should use the <xref:System.ComponentModel.ProgressChangedEventHandler> delegate signature and the <xref:System.ComponentModel.ProgressChangedEventArgs> class. Alternatively, if a more domain-specific progress indicator can be provided (for instance, bytes read and total bytes for a download operation), then you should define a derived class of <xref:System.ComponentModel.ProgressChangedEventArgs>.  \n  \n Note that there is only one `ProgressChanged` or *MethodName*`ProgressChanged` event for the class, regardless of the number of asynchronous methods it supports. Clients are expected to use the `userState` object that is passed to the *MethodName*`Async` methods to distinguish among progress updates on multiple concurrent operations.  \n  \n There may be situations in which multiple operations support progress and each returns a different indicator for progress. In this case, a single `ProgressChanged` event is not appropriate, and you may consider supporting multiple `ProgressChanged` events. In this case use a naming pattern of *MethodName*`ProgressChanged` for each *MethodName*`Async` method.  \n  \n Abide by the progress-reporting semantics described [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md).  \n  \n## Optionally Provide Support for Returning Incremental Results  \n Sometimes an asynchronous operation can return incremental results prior to completion. There are a number of options that can be used to support this scenario. Some examples follow.  \n  \n### Single-operation Class  \n If your class only supports a single asynchronous operation, and that operation is able to return incremental results, then:  \n  \n-   Extend the <xref:System.ComponentModel.ProgressChangedEventArgs> type to carry the incremental result data, and define a *MethodName*`ProgressChanged` event with this extended data.  \n  \n-   Raise this *MethodName*`ProgressChanged` event when there is an incremental result to report.  \n  \n This solution applies specifically to a single-async-operation class because there is no problem with the same event occurring to return incremental results on \"all operations\", as the *MethodName*`ProgressChanged` event does.  \n  \n### Multiple-operation Class with Homogeneous Incremental Results  \n In this case, your class supports multiple asynchronous methods, each capable of returning incremental results, and these incremental results all have the same type of data.  \n  \n Follow the model described above for single-operation classes, as the same <xref:System.EventArgs> structure will work for all incremental results. Define a `ProgressChanged` event instead of a *MethodName*`ProgressChanged` event, since it applies to multiple asynchronous methods.  \n  \n### Multiple-operation Class with Heterogeneous Incremental Results  \n If your class supports multiple asynchronous methods, each returning a different type of data, you should:  \n  \n-   Separate your incremental result reporting from your progress reporting.  \n  \n-   Define a separate *MethodName*`ProgressChanged` event with appropriate <xref:System.EventArgs> for each asynchronous method to handle that method's incremental result data.  \n  \n Invoke that event handler on the appropriate thread as described in [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md).  \n  \n## Handling Out and Ref Parameters in Methods  \n Although the use of `out` and `ref` is, in general, discouraged in the .NET Framework, here are the rules to follow when they are present:  \n  \n Given a synchronous method *MethodName*:  \n  \n-   `out` parameters to *MethodName* should not be part of *MethodName*`Async`. Instead, they should be part of *MethodName*`CompletedEventArgs` with the same name as its parameter equivalent in *MethodName* (unless there is a more appropriate name).  \n  \n-   `ref` parameters to *MethodName* should appear as part of *MethodName*`Async`, and as part of *MethodName*`CompletedEventArgs` with the same name as its parameter equivalent in *MethodName* (unless there is a more appropriate name).  \n  \n For example, given:  \n  \n```vb  \nPublic Function MethodName(ByVal arg1 As String, ByRef arg2 As String, ByRef arg3 As String) As Integer  \n```  \n  \n```csharp  \npublic int MethodName(string arg1, ref string arg2, out string arg3);  \n```  \n  \n Your asynchronous method and its <xref:System.ComponentModel.AsyncCompletedEventArgs> class would look like this:  \n  \n```vb  \nPublic Sub MethodNameAsync(ByVal arg1 As String, ByVal arg2 As String)  \n  \nPublic Class MethodNameCompletedEventArgs  \n    Inherits System.ComponentModel.AsyncCompletedEventArgs  \n    Public ReadOnly Property Result() As Integer   \n    End Property  \n    Public ReadOnly Property Arg2() As String   \n    End Property  \n    Public ReadOnly Property Arg3() As String   \n    End Property  \nEnd Class  \n```  \n  \n```csharp  \npublic void MethodNameAsync(string arg1, string arg2);  \n  \npublic class MethodNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs  \n{  \n    public int Result { get; };  \n    public string Arg2 { get; };  \n    public string Arg3 { get; };  \n}  \n```  \n  \n## See Also  \n <xref:System.ComponentModel.ProgressChangedEventArgs>   \n <xref:System.ComponentModel.AsyncCompletedEventArgs>   \n [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)   \n [How to: Run an Operation in the Background](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)   \n [How to: Implement a Form That Uses a Background Operation](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)   \n [Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)   \n [Multithreaded Programming with the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md)   \n [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)","nodes":[{"pos":[12,78],"content":"Implementing the Event-based Asynchronous Pattern | Microsoft Docs","needQuote":false,"needEscape":true,"nodes":[{"content":"Implementing the Event-based Asynchronous Pattern | Microsoft Docs","pos":[0,66]}]},{"pos":[777,826],"content":"Implementing the Event-based Asynchronous Pattern","linkify":"Implementing the Event-based Asynchronous Pattern","nodes":[{"content":"Implementing the Event-based Asynchronous Pattern","pos":[0,49]}]},{"pos":[827,1118],"content":"If you are writing a class with some operations that may incur noticeable delays, consider giving it asynchronous functionality by implementing <bpt id=\"p1\">[</bpt>Event-based Asynchronous Pattern Overview<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)</ept>.","source":"If you are writing a class with some operations that may incur noticeable delays, consider giving it asynchronous functionality by implementing [Event-based Asynchronous Pattern Overview](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)."},{"content":"The Event-based Asynchronous Pattern provides a standardized way to package a class that has asynchronous features.","pos":[1125,1240]},{"content":"If implemented with helper classes like <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncOperationManager&gt;</ph>, your class will work correctly under any application model, including <ph id=\"ph2\">[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)]</ph>, Console applications, and Windows Forms applications.","pos":[1241,1512],"source":" If implemented with helper classes like <xref:System.ComponentModel.AsyncOperationManager>, your class will work correctly under any application model, including [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)], Console applications, and Windows Forms applications."},{"pos":[1519,1797],"content":"For an example that implements the Event-based Asynchronous Pattern, see <bpt id=\"p1\">[</bpt>How to: Implement a Component That Supports the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)</ept>.","source":"For an example that implements the Event-based Asynchronous Pattern, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)."},{"content":"For simple asynchronous operations, you may find the <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph> component suitable.","pos":[1804,1922],"source":"For simple asynchronous operations, you may find the <xref:System.ComponentModel.BackgroundWorker> component suitable."},{"content":"For more information about <ph id=\"ph1\">&lt;xref:System.ComponentModel.BackgroundWorker&gt;</ph>, see <bpt id=\"p1\">[</bpt>How to: Run an Operation in the Background<ept id=\"p1\">](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)</ept>.","pos":[1923,2134],"source":" For more information about <xref:System.ComponentModel.BackgroundWorker>, see [How to: Run an Operation in the Background](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)."},{"content":"The following list describes the features of the Event-based Asynchronous Pattern discussed in this topic.","pos":[2141,2247]},{"content":"Opportunities for Implementing the Event-based Asynchronous Pattern","pos":[2257,2324]},{"content":"Naming Asynchronous Methods","pos":[2334,2361]},{"content":"Optionally Support Cancellation","pos":[2371,2402]},{"content":"Optionally Support the IsBusy Property","pos":[2412,2450]},{"content":"Optionally Provide Support for Progress Reporting","pos":[2460,2509]},{"content":"Optionally Provide Support for Returning Incremental Results","pos":[2519,2579]},{"content":"Handling Out and Ref Parameters in Methods","pos":[2589,2631]},{"pos":[2640,2707],"content":"Opportunities for Implementing the Event-based Asynchronous Pattern","linkify":"Opportunities for Implementing the Event-based Asynchronous Pattern","nodes":[{"content":"Opportunities for Implementing the Event-based Asynchronous Pattern","pos":[0,67]}]},{"content":"Consider implementing the Event-based Asynchronous Pattern when:","pos":[2711,2775]},{"content":"Clients of your class do not need <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> objects available for asynchronous operations, meaning that polling and <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> will need to be built up by the client.","pos":[2785,3091],"source":"Clients of your class do not need <xref:System.Threading.WaitHandle> and <xref:System.IAsyncResult> objects available for asynchronous operations, meaning that polling and <xref:System.Threading.WaitHandle.WaitAll%2A> or <xref:System.Threading.WaitHandle.WaitAny%2A> will need to be built up by the client."},{"content":"You want asynchronous operations to be managed by the client with the familiar event/delegate model.","pos":[3101,3201]},{"content":"Any operation is a candidate for an asynchronous implementation, but those you expect to incur long latencies should be considered.","pos":[3208,3339]},{"content":"Especially appropriate are operations in which clients call a method and are notified on completion, with no further intervention required.","pos":[3340,3479]},{"content":"Also appropriate are operations which run continuously, periodically notifying clients of progress, incremental results, or state changes.","pos":[3480,3618]},{"pos":[3625,3907],"content":"For more information on deciding when to support the Event-based Asynchronous Pattern, see <bpt id=\"p1\">[</bpt>Deciding When to Implement the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)</ept>.","source":"For more information on deciding when to support the Event-based Asynchronous Pattern, see [Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)."},{"pos":[3916,3943],"content":"Naming Asynchronous Methods","linkify":"Naming Asynchronous Methods","nodes":[{"content":"Naming Asynchronous Methods","pos":[0,27]}]},{"pos":[3947,4046],"content":"For each synchronous method <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept> for which you want to provide an asynchronous counterpart:","source":"For each synchronous method *MethodName* for which you want to provide an asynchronous counterpart:"},{"pos":[4053,4094],"content":"Define a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> method that:","source":"Define a *MethodName*`Async` method that:"},{"pos":[4104,4119],"content":"Returns <ph id=\"ph1\">`void`</ph>.","source":"Returns `void`."},{"pos":[4129,4182],"content":"Takes the same parameters as the <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept> method.","source":"Takes the same parameters as the *MethodName* method."},{"content":"Accepts multiple invocations.","pos":[4192,4221]},{"content":"Optionally define a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> overload, identical to <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Async`</ph>, but with an additional object-valued parameter called <ph id=\"ph3\">`userState`</ph>.","pos":[4228,4378],"source":"Optionally define a *MethodName*`Async` overload, identical to *MethodName*`Async`, but with an additional object-valued parameter called `userState`."},{"content":"Do this if you're prepared to manage multiple concurrent invocations of your method, in which case the <ph id=\"ph1\">`userState`</ph> value will be delivered back to all event handlers to distinguish invocations of the method.","pos":[4379,4586],"source":" Do this if you're prepared to manage multiple concurrent invocations of your method, in which case the `userState` value will be delivered back to all event handlers to distinguish invocations of the method."},{"content":"You may also choose to do this simply as a place to store user state for later retrieval.","pos":[4587,4676]},{"pos":[4683,4738],"content":"For each separate <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> method signature:","source":"For each separate *MethodName*`Async` method signature:"},{"content":"Define the following event in the same class as the method:","pos":[4748,4807]},{"content":"Define the following delegate and <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph>.","pos":[5017,5104],"source":"Define the following delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs>."},{"content":"These will likely be defined outside of the class itself, but in the same namespace.","pos":[5105,5189]},{"pos":[5875,6022],"content":"Ensure that the <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`CompletedEventArgs`</ph> class exposes its members as read-only properties, and not fields, as fields prevent data binding.","source":"Ensure that the *MethodName*`CompletedEventArgs` class exposes its members as read-only properties, and not fields, as fields prevent data binding."},{"content":"Do not define any <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph>-derived classes for methods that do not produce results.","pos":[6036,6163],"source":"Do not define any <xref:System.ComponentModel.AsyncCompletedEventArgs>-derived classes for methods that do not produce results."},{"content":"Simply use an instance of <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> itself.","pos":[6164,6250],"source":" Simply use an instance of <xref:System.ComponentModel.AsyncCompletedEventArgs> itself."},{"pos":[6266,6612],"content":"[!NOTE]\nIt is perfectly acceptable, when feasible and appropriate, to reuse delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> types. In this case, the naming will not be as consistent with the method name, since a given delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> won't be tied to a single method.","leadings":["","        >  "],"nodes":[{"content":"It is perfectly acceptable, when feasible and appropriate, to reuse delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> types. In this case, the naming will not be as consistent with the method name, since a given delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> won't be tied to a single method.","pos":[8,335],"nodes":[{"content":"It is perfectly acceptable, when feasible and appropriate, to reuse delegate and <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> types.","pos":[0,140],"source":"It is perfectly acceptable, when feasible and appropriate, to reuse delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> types."},{"content":"In this case, the naming will not be as consistent with the method name, since a given delegate and <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> won't be tied to a single method.","pos":[141,327],"source":" In this case, the naming will not be as consistent with the method name, since a given delegate and <xref:System.ComponentModel.AsyncCompletedEventArgs> won't be tied to a single method."}]}]},{"pos":[6621,6652],"content":"Optionally Support Cancellation","linkify":"Optionally Support Cancellation","nodes":[{"content":"Optionally Support Cancellation","pos":[0,31]}]},{"content":"If your class will support canceling asynchronous operations, cancellation should be exposed to the client as described below.","pos":[6656,6782]},{"content":"Note that there are two decision points that need to be reached before defining your cancellation support:","pos":[6783,6889]},{"content":"Does your class, including future anticipated additions to it, have only one asynchronous operation that supports cancellation?","pos":[6899,7026]},{"content":"Can the asynchronous operations that support cancellation support multiple pending operations?","pos":[7036,7130]},{"content":"That is, does the <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> method take a <ph id=\"ph2\">`userState`</ph> parameter, and does it allow multiple invocations before waiting for any to finish?","pos":[7131,7278],"source":" That is, does the *MethodName*`Async` method take a `userState` parameter, and does it allow multiple invocations before waiting for any to finish?"},{"content":"Use the answers to these two questions in the table below to determine what the signature for your cancellation method should be.","pos":[7285,7414]},{"pos":[7424,7436],"content":"Visual Basic","linkify":"Visual Basic","nodes":[{"content":"Visual Basic","pos":[0,12]}]},{"content":"Multiple Simultaneous Operations Supported","pos":[7444,7486]},{"content":"Only One Operation at a Time","pos":[7487,7515]},{"content":"One Async Operation in entire class","pos":[7615,7650]},{"content":"Multiple Async Operations in class","pos":[7740,7774]},{"pos":[7850,7852],"content":"C#","linkify":"C#","nodes":[{"content":"C#","pos":[0,2]}]},{"content":"Multiple Simultaneous Operations Supported","pos":[7860,7902]},{"content":"Only One Operation at a Time","pos":[7903,7931]},{"content":"One Async Operation in entire class","pos":[8031,8066]},{"content":"Multiple Async Operations in class","pos":[8151,8185]},{"pos":[8253,8530],"content":"If you define the <ph id=\"ph1\">`CancelAsync(object userState)`</ph> method, clients must be careful when choosing their state values to make them capable of distinguishing among all asynchronous methods invoked on the object, and not just between all invocations of a single asynchronous method.","source":"If you define the `CancelAsync(object userState)` method, clients must be careful when choosing their state values to make them capable of distinguishing among all asynchronous methods invoked on the object, and not just between all invocations of a single asynchronous method."},{"content":"The decision to name the single-async-operation version <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`AsyncCancel`</ph> is based on being able to more easily discover the method in a design environment like Visual Studio's IntelliSense.","pos":[8537,8735],"source":"The decision to name the single-async-operation version *MethodName*`AsyncCancel` is based on being able to more easily discover the method in a design environment like Visual Studio's IntelliSense."},{"content":"This groups the related members and distinguishes them from other members that have nothing to do with asynchronous functionality.","pos":[8736,8866]},{"content":"If you expect that there may be additional asynchronous operations added in subsequent versions, it is better to define <ph id=\"ph1\">`CancelAsync`</ph>.","pos":[8867,9001],"source":" If you expect that there may be additional asynchronous operations added in subsequent versions, it is better to define `CancelAsync`."},{"content":"Do not define multiple methods from the table above in the same class.","pos":[9008,9078]},{"content":"That will not make sense, or it will clutter the class interface with a proliferation of methods.","pos":[9079,9176]},{"content":"These methods typically will return immediately, and the operation may or may not actually cancel.","pos":[9183,9281]},{"content":"In the event handler for the <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Completed`</ph> event, the <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`CompletedEventArgs`</ph> object contains a <ph id=\"ph3\">`Cancelled`</ph> field, which clients can use to determine whether the cancellation occurred.","pos":[9282,9485],"source":" In the event handler for the *MethodName*`Completed` event, the *MethodName*`CompletedEventArgs` object contains a `Cancelled` field, which clients can use to determine whether the cancellation occurred."},{"pos":[9492,9742],"content":"Abide by the cancellation semantics described in <bpt id=\"p1\">[</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept>.","source":"Abide by the cancellation semantics described in [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)."},{"pos":[9751,9789],"content":"Optionally Support the IsBusy Property","linkify":"Optionally Support the IsBusy Property","nodes":[{"content":"Optionally Support the IsBusy Property","pos":[0,38]}]},{"content":"If your class does not support multiple concurrent invocations, consider exposing an <ph id=\"ph1\">`IsBusy`</ph> property.","pos":[9793,9896],"source":"If your class does not support multiple concurrent invocations, consider exposing an `IsBusy` property."},{"content":"This allows developers to determine whether a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`Async`</ph> method is running without catching an exception from the <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Async`</ph> method.","pos":[9897,10047],"source":" This allows developers to determine whether a *MethodName*`Async` method is running without catching an exception from the *MethodName*`Async` method."},{"pos":[10054,10300],"content":"Abide by the <ph id=\"ph1\">`IsBusy`</ph> semantics described in <bpt id=\"p1\">[</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept>.","source":"Abide by the `IsBusy` semantics described in [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)."},{"pos":[10309,10358],"content":"Optionally Provide Support for Progress Reporting","linkify":"Optionally Provide Support for Progress Reporting","nodes":[{"content":"Optionally Provide Support for Progress Reporting","pos":[0,49]}]},{"content":"It is frequently desirable for an asynchronous operation to report progress during its operation.","pos":[10362,10459]},{"content":"The Event-based Asynchronous Pattern provides a guideline for doing so.","pos":[10460,10531]},{"content":"Optionally define an event to be raised by the asynchronous operation and invoked on the appropriate thread.","pos":[10541,10649]},{"content":"The <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> object carries an integer-valued progress indicator that is expected to be between 0 and 100.","pos":[10650,10801],"source":" The <xref:System.ComponentModel.ProgressChangedEventArgs> object carries an integer-valued progress indicator that is expected to be between 0 and 100."},{"content":"Name this event as follows:","pos":[10811,10838]},{"pos":[10852,11008],"content":"<ph id=\"ph1\">`ProgressChanged`</ph> if the class has multiple asynchronous operations (or is expected to grow to include multiple asynchronous operations in future versions);","source":"`ProgressChanged` if the class has multiple asynchronous operations (or is expected to grow to include multiple asynchronous operations in future versions);"},{"pos":[11022,11102],"content":"<bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept> <ph id=\"ph1\">`ProgressChanged`</ph> if the class has a single asynchronous operation.","source":"*MethodName* `ProgressChanged` if the class has a single asynchronous operation."},{"content":"This naming choice parallels that made for the cancellation method, as described in the Optionally Support Cancellation section.","pos":[11113,11241]},{"content":"This event should use the <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventHandler&gt;</ph> delegate signature and the <ph id=\"ph2\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> class.","pos":[11248,11418],"source":"This event should use the <xref:System.ComponentModel.ProgressChangedEventHandler> delegate signature and the <xref:System.ComponentModel.ProgressChangedEventArgs> class."},{"content":"Alternatively, if a more domain-specific progress indicator can be provided (for instance, bytes read and total bytes for a download operation), then you should define a derived class of <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph>.","pos":[11419,11660],"source":" Alternatively, if a more domain-specific progress indicator can be provided (for instance, bytes read and total bytes for a download operation), then you should define a derived class of <xref:System.ComponentModel.ProgressChangedEventArgs>."},{"content":"Note that there is only one <ph id=\"ph1\">`ProgressChanged`</ph> or <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph2\">`ProgressChanged`</ph> event for the class, regardless of the number of asynchronous methods it supports.","pos":[11667,11828],"source":"Note that there is only one `ProgressChanged` or *MethodName*`ProgressChanged` event for the class, regardless of the number of asynchronous methods it supports."},{"content":"Clients are expected to use the <ph id=\"ph1\">`userState`</ph> object that is passed to the <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph2\">`Async`</ph> methods to distinguish among progress updates on multiple concurrent operations.","pos":[11829,12002],"source":" Clients are expected to use the `userState` object that is passed to the *MethodName*`Async` methods to distinguish among progress updates on multiple concurrent operations."},{"content":"There may be situations in which multiple operations support progress and each returns a different indicator for progress.","pos":[12009,12131]},{"content":"In this case, a single <ph id=\"ph1\">`ProgressChanged`</ph> event is not appropriate, and you may consider supporting multiple <ph id=\"ph2\">`ProgressChanged`</ph> events.","pos":[12132,12265],"source":" In this case, a single `ProgressChanged` event is not appropriate, and you may consider supporting multiple `ProgressChanged` events."},{"content":"In this case use a naming pattern of <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`ProgressChanged`</ph> for each <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Async`</ph> method.","pos":[12266,12369],"source":" In this case use a naming pattern of *MethodName*`ProgressChanged` for each *MethodName*`Async` method."},{"pos":[12376,12629],"content":"Abide by the progress-reporting semantics described <bpt id=\"p1\">[</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept>.","source":"Abide by the progress-reporting semantics described [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)."},{"pos":[12638,12698],"content":"Optionally Provide Support for Returning Incremental Results","linkify":"Optionally Provide Support for Returning Incremental Results","nodes":[{"content":"Optionally Provide Support for Returning Incremental Results","pos":[0,60]}]},{"content":"Sometimes an asynchronous operation can return incremental results prior to completion.","pos":[12702,12789]},{"content":"There are a number of options that can be used to support this scenario.","pos":[12790,12862]},{"content":"Some examples follow.","pos":[12863,12884]},{"pos":[12894,12916],"content":"Single-operation Class","linkify":"Single-operation Class","nodes":[{"content":"Single-operation Class","pos":[0,22]}]},{"content":"If your class only supports a single asynchronous operation, and that operation is able to return incremental results, then:","pos":[12920,13044]},{"pos":[13054,13235],"content":"Extend the <ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph> type to carry the incremental result data, and define a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph2\">`ProgressChanged`</ph> event with this extended data.","source":"Extend the <xref:System.ComponentModel.ProgressChangedEventArgs> type to carry the incremental result data, and define a *MethodName*`ProgressChanged` event with this extended data."},{"pos":[13245,13338],"content":"Raise this <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`ProgressChanged`</ph> event when there is an incremental result to report.","source":"Raise this *MethodName*`ProgressChanged` event when there is an incremental result to report."},{"pos":[13345,13571],"content":"This solution applies specifically to a single-async-operation class because there is no problem with the same event occurring to return incremental results on \"all operations\", as the <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`ProgressChanged`</ph> event does.","source":"This solution applies specifically to a single-async-operation class because there is no problem with the same event occurring to return incremental results on \"all operations\", as the *MethodName*`ProgressChanged` event does."},{"pos":[13581,13642],"content":"Multiple-operation Class with Homogeneous Incremental Results","linkify":"Multiple-operation Class with Homogeneous Incremental Results","nodes":[{"content":"Multiple-operation Class with Homogeneous Incremental Results","pos":[0,61]}]},{"content":"In this case, your class supports multiple asynchronous methods, each capable of returning incremental results, and these incremental results all have the same type of data.","pos":[13646,13819]},{"content":"Follow the model described above for single-operation classes, as the same <ph id=\"ph1\">&lt;xref:System.EventArgs&gt;</ph> structure will work for all incremental results.","pos":[13826,13973],"source":"Follow the model described above for single-operation classes, as the same <xref:System.EventArgs> structure will work for all incremental results."},{"content":"Define a <ph id=\"ph1\">`ProgressChanged`</ph> event instead of a <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph2\">`ProgressChanged`</ph> event, since it applies to multiple asynchronous methods.","pos":[13974,14107],"source":" Define a `ProgressChanged` event instead of a *MethodName*`ProgressChanged` event, since it applies to multiple asynchronous methods."},{"pos":[14117,14180],"content":"Multiple-operation Class with Heterogeneous Incremental Results","linkify":"Multiple-operation Class with Heterogeneous Incremental Results","nodes":[{"content":"Multiple-operation Class with Heterogeneous Incremental Results","pos":[0,63]}]},{"content":"If your class supports multiple asynchronous methods, each returning a different type of data, you should:","pos":[14184,14290]},{"content":"Separate your incremental result reporting from your progress reporting.","pos":[14300,14372]},{"pos":[14382,14554],"content":"Define a separate <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`ProgressChanged`</ph> event with appropriate <ph id=\"ph2\">&lt;xref:System.EventArgs&gt;</ph> for each asynchronous method to handle that method's incremental result data.","source":"Define a separate *MethodName*`ProgressChanged` event with appropriate <xref:System.EventArgs> for each asynchronous method to handle that method's incremental result data."},{"pos":[14561,14830],"content":"Invoke that event handler on the appropriate thread as described in <bpt id=\"p1\">[</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept>.","source":"Invoke that event handler on the appropriate thread as described in [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)."},{"pos":[14839,14881],"content":"Handling Out and Ref Parameters in Methods","linkify":"Handling Out and Ref Parameters in Methods","nodes":[{"content":"Handling Out and Ref Parameters in Methods","pos":[0,42]}]},{"pos":[14885,15023],"content":"Although the use of <ph id=\"ph1\">`out`</ph> and <ph id=\"ph2\">`ref`</ph> is, in general, discouraged in the .NET Framework, here are the rules to follow when they are present:","source":"Although the use of `out` and `ref` is, in general, discouraged in the .NET Framework, here are the rules to follow when they are present:"},{"pos":[15030,15070],"content":"Given a synchronous method <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept>:","source":"Given a synchronous method *MethodName*:"},{"content":"<ph id=\"ph1\">`out`</ph> parameters to <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept> should not be part of <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Async`</ph>.","pos":[15080,15155],"source":"`out` parameters to *MethodName* should not be part of *MethodName*`Async`."},{"content":"Instead, they should be part of <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept><ph id=\"ph1\">`CompletedEventArgs`</ph> with the same name as its parameter equivalent in <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept> (unless there is a more appropriate name).","pos":[15156,15326],"source":" Instead, they should be part of *MethodName*`CompletedEventArgs` with the same name as its parameter equivalent in *MethodName* (unless there is a more appropriate name)."},{"pos":[15336,15568],"content":"<ph id=\"ph1\">`ref`</ph> parameters to <bpt id=\"p1\">*</bpt>MethodName<ept id=\"p1\">*</ept> should appear as part of <bpt id=\"p2\">*</bpt>MethodName<ept id=\"p2\">*</ept><ph id=\"ph2\">`Async`</ph>, and as part of <bpt id=\"p3\">*</bpt>MethodName<ept id=\"p3\">*</ept><ph id=\"ph3\">`CompletedEventArgs`</ph> with the same name as its parameter equivalent in <bpt id=\"p4\">*</bpt>MethodName<ept id=\"p4\">*</ept> (unless there is a more appropriate name).","source":"`ref` parameters to *MethodName* should appear as part of *MethodName*`Async`, and as part of *MethodName*`CompletedEventArgs` with the same name as its parameter equivalent in *MethodName* (unless there is a more appropriate name)."},{"content":"For example, given:","pos":[15575,15594]},{"content":"Your asynchronous method and its <ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph> class would look like this:","pos":[15817,15930],"source":"Your asynchronous method and its <xref:System.ComponentModel.AsyncCompletedEventArgs> class would look like this:"},{"pos":[16641,16649],"content":"See Also","linkify":"See Also","nodes":[{"content":"See Also","pos":[0,8]}]},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.ProgressChangedEventArgs&gt;</ph>","pos":[16653,16706],"source":"<xref:System.ComponentModel.ProgressChangedEventArgs> "},{"content":"<ph id=\"ph1\">&lt;xref:System.ComponentModel.AsyncCompletedEventArgs&gt;</ph>","pos":[16711,16763],"source":" <xref:System.ComponentModel.AsyncCompletedEventArgs> "},{"content":"<bpt id=\"p1\"> [</bpt>How to: Implement a Component That Supports the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)</ept><ph id=\"ph1\"> </ph>","pos":[16767,16973],"source":" [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md) "},{"content":"<bpt id=\"p1\"> [</bpt>How to: Run an Operation in the Background<ept id=\"p1\">](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md)</ept><ph id=\"ph1\"> </ph>","pos":[16976,17110],"source":" [How to: Run an Operation in the Background](../../../docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md) "},{"content":"<bpt id=\"p1\"> [</bpt>How to: Implement a Form That Uses a Background Operation<ept id=\"p1\">](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md)</ept><ph id=\"ph1\"> </ph>","pos":[17113,17277],"source":" [How to: Implement a Form That Uses a Background Operation](../../../docs/framework/winforms/controls/how-to-implement-a-form-that-uses-a-background-operation.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Deciding When to Implement the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)</ept><ph id=\"ph1\"> </ph>","pos":[17280,17472],"source":" [Deciding When to Implement the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Multithreaded Programming with the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md)</ept><ph id=\"ph1\"> </ph>","pos":[17475,17675],"source":" [Multithreaded Programming with the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/multithreaded-programming-with-the-event-based-asynchronous-pattern.md) "},{"content":"<bpt id=\"p1\"> [</bpt>Best Practices for Implementing the Event-based Asynchronous Pattern<ept id=\"p1\">](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)</ept>","pos":[17678,17879],"source":" [Best Practices for Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)"}]}