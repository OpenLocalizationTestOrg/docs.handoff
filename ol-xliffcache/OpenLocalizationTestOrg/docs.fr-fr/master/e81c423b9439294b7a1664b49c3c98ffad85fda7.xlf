<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b81d562" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e81c423b9439294b7a1664b49c3c98ffad85fda7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\framework\wcf\feature-details\uritemplate-and-uritemplatetable.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net-med-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Machine Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c22f3f36dc03c0a4896d267c936e5c49c609a763</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c15f35deb984ad389fa869d3a8dd8eb2582c3cfd</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>UriTemplate and UriTemplateTable | Microsoft Docs</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>UriTemplate and UriTemplateTable</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Web developers require the ability to describe the shape and layout of the URIs that their services respond to.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]</ph> added two new classes to give developers control over their URIs.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> and <ph id="ph2">&lt;xref:System.UriTemplateTable&gt;</ph> form the basis of the URI-based dispatch engine in <ph id="ph3">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>These classes can also be used on their own, allowing developers to take advantage of templates and the URI mapping mechanism without implementing a <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> service.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Templates</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A template is a way to describe a set of relative URIs.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The set of URI templates in the following table shows how a system that retrieves various types of weather information might be defined.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Data</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Template</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>National Forecast</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>weather/national</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>State Forecast</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>weather/{state}</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>City Forecast</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>weather/{state}/{city}</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Activity Forecast</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>weather/{state}/{city}/{activity}</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This table describes a set of structurally similar URIs.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Each entry is a URI template.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The segments in curly braces describe variables.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The segments not in curly braces describe literal strings.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]</ph> template classes allow a developer to take an incoming URI, for example, "/weather/wa/seattle/cycling", and match it to a template that describes it, "/weather/{state}/{city}/{activity}".</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>UriTemplate</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> is a class that encapsulates a URI template.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The constructor takes a string parameter that defines the template.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This string contains the template in the format described in the next section.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> class provides methods that allow you match an incoming URI to a template, generate a URI from a template, retrieve a collection of variable names used in the template, determine whether two templates are equivalent, and return the template's string.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate.Match%28System.Uri%2CSystem.Uri%29&gt;</ph> takes a base address and a candidate URI and attempts to match the URI to the template.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>If the match is successful, a <ph id="ph1">&lt;xref:System.UriTemplateMatch&gt;</ph> instance is returned.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.UriTemplateMatch&gt;</ph> object contains a base URI, the candidate URI, a name/value collection of the query parameters, an array of the relative path segments, a name/value collection of variables that were matched, the <ph id="ph2">&lt;xref:System.UriTemplate&gt;</ph> instance used to perform the match, a string that contains any unmatched portion of the candidate URI (used when the template has a wildcard), and an object that is associated with the template.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> class ignores the scheme and port number when matching a candidate URI to a template.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>There are two methods that allow you to generate a URI from a template, <ph id="ph1">&lt;xref:System.UriTemplate.BindByName%28System.Uri%2CSystem.Collections.Specialized.NameValueCollection%29&gt;</ph> and <ph id="ph2">&lt;xref:System.UriTemplate.BindByPosition%28System.Uri%2CSystem.String%5B%5D%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate.BindByName%28System.Uri%2CSystem.Collections.Specialized.NameValueCollection%29&gt;</ph> takes a base address and a name/value collection of parameters.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>These parameters are substituted for variables when the template is bound.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate.BindByPosition%28System.Uri%2CSystem.String%5B%5D%29&gt;</ph> takes the name/value pairs and substitutes them left to right.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate.ToString&gt;</ph> returns the template string.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.UriTemplate.PathSegmentVariableNames%2A&gt;</ph> property contains a collection of the names of the variables used within path segments in the template string.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate.IsEquivalentTo%28System.UriTemplate%29&gt;</ph> takes a <ph id="ph2">&lt;xref:System.UriTemplate&gt;</ph> as a parameter and returns a Boolean value that specifies whether the two templates are equivalent.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]</ph> the Template Equivalence section later in this topic.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> is designed to work with any URI scheme that conforms to the HTTP URI grammar.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following are examples of supported URI schemes.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>http://</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>https://</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>net.tcp://</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>net.pipe://</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>sb://</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Schemes like file:// and urn:// do not conform to the HTTP URI grammar and cause unpredictable results when used with URI templates.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Template String Syntax</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A template has three parts: a path, an optional query, and an optional fragment.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For an example, see the following template:</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The path consists of "/weather/{state}/{city}", the query consists of "?forecast={length}, and the fragment consists of "#frag1".</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Leading and trailing slashes are optional in the path expression.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Both the query and fragment expressions can be omitted entirely.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A path consists of a series of segments delimited by '/', each segment can have a literal value, a variable name (written in {curly braces}), or a wildcard (written as '<ph id="ph1">\*</ph>').</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the previous template the "\weather\ segment is a literal value while "{state}" and "{city}" are variables.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Variables take their name from the contents of their curly braces and they can later be replaced with a concrete value to create a <bpt id="p1">*</bpt>closed URI<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The wildcard is optional, but can only appear at the end of the URI, where it logically matches "the rest of the path".</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The query expression, if present, specifies a series of unordered name/value pairs delimited by '&amp;'.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Elements of the query expression can either be literal pairs (x=2) or a variable pair (x={var}).</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Only the right side of the query can have a variable expression.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>({someName} = {someValue} is not allowed.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Unpaired values (?x) are not permitted.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>There is no difference between an empty query expression and a query expression consisting of just a single '?' (both mean "any query").</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The fragment expression can consist of a literal value, no variables are allowed.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>All template variable names within a template string must be unique.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Template variable names are case-insensitive.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Examples of valid template strings:</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>""</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>"/shoe"</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>"/shoe/*"</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>"{shoe}/boat"</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>"{shoe}/{boat}/bed/{quilt}"</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>"shoe/{boat}"</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>"shoe/{boat}/*"</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>"shoe/boat?x=2"</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>"shoe/{boat}?x={bed}"</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>"shoe/{boat}?x={bed}&amp;y=band"</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>"?x={shoe}"</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>"shoe?x=3&amp;y={var}</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Examples of invalid template strings:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>"{shoe}/{SHOE}/x=2" – Duplicate variable names.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>"{shoe}/boat/?bed={shoe}" – Duplicate variable names.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>"?x=2&amp;x=3" – Name/value pairs within a query string must be unique, even if they are literals.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>"?x=2&amp;" – Query string is malformed.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>"?2&amp;x={shoe}" – Query string must be name/value pairs.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>"?y=2&amp;&amp;X=3" – Query string must be name value pairs, names cannot start with '&amp;'.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Compound Path Segments</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Compound path segments allow a single URI path segment to contain multiple variables as well as variables combined with literals.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The following are examples of valid compound path segments.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>/filename.{ext}/</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>/{filename}.jpg/</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>/{filename}.{ext}/</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>/{a}.{b}someLiteral{c}({d})/</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following are examples of invalid path segments.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>/{} - Variables must be named.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>/{shoe}{boat} - Variables must be separated by a literal.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Matching and Compound Path Segments</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Compound path segments allow you to define a UriTemplate that has multiple variables within a single path segment.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For example, in the following template string: "Addresses/{state}.{city}" two variables (state and city) are defined within the same segment.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This template would match a URL such as "http://example.com/Washington.Redmond" but it will also match an URL like "http://example.com/Washington.Redmond.Microsoft".</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In the latter case, the state variable will contain "Washington" and the city variable will contain "Redmond.Microsoft".</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In this case any text (except ‘/’) will match the {city} variable.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If you want a template that will not match the "extra" text, place the variable in a separate template segment, for example: "Addresses/{state}/{city}.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Named Wildcard Segments</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>A named wildcard segment is any path variable segment whose variable name begins with the wildcard character ‘*’.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following template string contains a named wildcard segment named "shoe".</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Wildcard segments must follow the following rules:</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>There can be at most one named wildcard segment for each template string.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A named wildcard segment must appear at the right-most segment in the path.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>A named wildcard segment cannot coexist with an anonymous wildcard segment within the same template string.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The name of a named wildcard segment must be unique.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Named wildcard segments cannot have default values.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Named wildcard segments cannot end with "/".</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Default Variable Values</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Default variable values allow you to specify default values for variables within a template.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Default variables can be specified with the curly braces that declare the variable or as a collection passed to the UriTemplate constructor.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The following template shows two ways to specify a <ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> with variables with default values.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This template declares a variable named <ph id="ph1">`a`</ph> with a default value of <ph id="ph2">`1`</ph> and a variable named <ph id="ph3">`b`</ph> with a default value of <ph id="ph4">`5`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Only path segment variables are allowed to have default values.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Query string variables, compound segment variables, and named wildcard variables are not permitted to have default values.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The following code shows how default variable values are handled when matching a candidate URI.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A URI such as http://localhost:8000/// does not match the template listed in the preceding code, however a URI such as http://localhost:8000/ does.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The following code shows how default variable values are handled when creating a URI with a template.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>When a variable is given a default value of <ph id="ph1">`null`</ph> there are some additional constraints.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>A variable can have a default value of <ph id="ph1">`null`</ph> if the variable is contained within the right most segment of the template string or if all segments to the right of the segment have default values of <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The following are valid template strings with default values of <ph id="ph1">`null`</ph>:</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The following are invalid template strings with  default values of <ph id="ph1">`null`</ph>:</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Default Values and Matching</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>When matching a candidate URI with a template that has default values, the default values are placed in the <ph id="ph1">&lt;xref:System.UriTemplateMatch.BoundVariables%2A&gt;</ph> collection if values are not specified in the candidate URI.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Template Equivalence</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Two templates are said to be <bpt id="p1">*</bpt>structurally equivalent<ept id="p1">*</ept> when all of the templates' literals match and they have variables in the same segments.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example the following templates are structurally equivalent:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>/a/{var1}/b b/{var2}?x=1&amp;y=2</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>a/{x}/b%20b/{var1}?y=2&amp;x=1</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>a/{y}/B%20B/{z}/?y=2&amp;x=1</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A few things to notice:</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If a template contains leading slashes, only the first one is ignored.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>When comparing template strings for structural equivalence, case is ignored for variable names and path segments, query strings are case sensitive.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Query strings are unordered.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>UriTemplateTable</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref:System.UriTemplateTable&gt;</ph> class represents an associative table of <ph id="ph2">&lt;xref:System.UriTemplate&gt;</ph> objects bound to an object of the developer's choosing.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref:System.UriTemplateTable&gt;</ph> must contain at least one <ph id="ph2">&lt;xref:System.UriTemplate&gt;</ph> prior to calling <ph id="ph3">&lt;xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The contents of a <ph id="ph1">&lt;xref:System.UriTemplateTable&gt;</ph> can be changed until <ph id="ph2">&lt;xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Validation is performed when <ph id="ph1">&lt;xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The type of validation performed depends upon the value of the <ph id="ph1">`allowMultiple`</ph> parameter to <ph id="ph2">&lt;xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">&lt;xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29&gt;</ph> is called passing in <ph id="ph2">`false`</ph>, the <ph id="ph3">&lt;xref:System.UriTemplateTable&gt;</ph> checks to make sure there are no templates in the table.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If it finds any structurally equivalent templates, it throws an exception.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This is used in conjunction with <ph id="ph1">&lt;xref:System.UriTemplateTable.MatchSingle%28System.Uri%29&gt;</ph> when you want to ensure only one template matches an incoming URI.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">&lt;xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29&gt;</ph> is called passing in <ph id="ph2">`true`</ph>, <ph id="ph3">&lt;xref:System.UriTemplateTable&gt;</ph> allows multiple, structurally-equivalent templates to be contained within a <ph id="ph4">&lt;xref:System.UriTemplateTable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If a set of <ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> objects added to a <ph id="ph2">&lt;xref:System.UriTemplateTable&gt;</ph> contain query strings they must not be ambiguous.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Identical query strings are allowed.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>While the <ph id="ph1">&lt;xref:System.UriTemplateTable&gt;</ph> allows base addresses that use schemes other than HTTP, the scheme and port number are ignored when matching candidate URIs to templates.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Query String Ambiguity</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Templates that share an equivalent path contain ambiguous query strings if there is a URI that matches more than one template.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following sets of query strings are unambiguous within themselves:</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>?x=1</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>?x=2</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>?x=3</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>?x=1&amp;y={var}</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>?x=2&amp;z={var}</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>?x=3</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>?x=1</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>x={var}</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>?m=get&amp;c=rss</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>?m=put&amp;c=rss</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>?m=get&amp;c=atom</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>?m=put&amp;c=atom</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The following sets of query string templates are ambiguous within themselves:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>?x=1</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>?x={var}</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>"x=1" - Matches both templates.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>?x=1</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>?y=2</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>"x=1&amp;y=2" matches both templates.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>This is because a query string may contain more query string variables then the template it matches.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>?x=1</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>?x=1&amp;y={var}</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>"x=1&amp;y=3" matches both templates.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>?x=3&amp;y=4</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>?x=3&amp;z=5</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The characters á and Á are considered to be different characters when they appear as part of a URI path or <ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> path segment literal (but the characters a and A are considered to be the same).</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>The characters á and Á are considered to be the same characters when they appear as part of a <ph id="ph1">&lt;xref:System.UriTemplate&gt;</ph> {variableName} or a query string (and a and A are also considered to be the same characters).</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>See Also</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>WCF Web HTTP Programming Model Overview<ept id="p1">](../../../../docs/framework/wcf/feature-details/wcf-web-http-programming-model-overview.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>WCF Web HTTP Programming Object Model<ept id="p1">](../../../../docs/framework/wcf/feature-details/wcf-web-http-programming-object-model.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>UriTemplate<ept id="p1">](../../../../docs/framework/wcf/samples/uritemplate-sample.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>UriTemplate Table<ept id="p1">](../../../../docs/framework/wcf/samples/uritemplate-table-sample.md)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source><bpt id="p1"> [</bpt>UriTemplate Table Dispatcher<ept id="p1">](../../../../docs/framework/wcf/samples/uritemplate-table-dispatcher-sample.md)</ept></source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>