<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="csharp-7.md" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0a91294" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">81d06d2e2079e04948ad5e93eefadb1bc11d855a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\csharp\whats-new\csharp-7.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">vbcs_lo-mt</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">MT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6fe938eb0149c34aed7eb485fc153c6c1c0f9ded</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">43659f52202e8bb845a0f564f7036c72f713e5c7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>What's New in C# 7.0 - C# Guide</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Get an overview of the new features in version 7.0 of the C# language.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>What's new in C# 7.0</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>C# 7.0 adds a number of new features to the C# language:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`out`</ph> variables<ept id="p1">](#out-variables)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can declare <ph id="ph1">`out`</ph> values inline as arguments to the method where they're used.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Tuples<ept id="p1">](#tuples)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can create lightweight, unnamed types that contain multiple public fields.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Compilers and IDE tools understand the semantics of these types.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Discards<ept id="p1">](#discards)</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Discards are temporary, write-only variables used in assignments when you don't care about the value assigned.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>They're most useful when deconstructing tuples and user-defined types, as well as when calling methods with <ph id="ph1">`out`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Pattern Matching<ept id="p1">](#pattern-matching)</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can create branching logic based on arbitrary types and values of the members of those types.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`ref`</ph> locals and returns<ept id="p1">](#ref-locals-and-returns)</ept></source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Method local variables and return values can be references to other storage.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Local Functions<ept id="p1">](#local-functions)</ept></source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can nest functions inside other functions to limit their scope and visibility.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>More expression-bodied members<ept id="p1">](#more-expression-bodied-members)</ept></source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The list of members that can be authored using expressions has grown.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">`throw`</ph> Expressions<ept id="p1">](#throw-expressions)</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can throw exceptions in code constructs that previously weren't allowed because <ph id="ph1">`throw`</ph> was a statement.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Generalized async return types<ept id="p1">](#generalized-async-return-types)</ept></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Methods declared with the <ph id="ph1">`async`</ph> modifier can return other types in addition to <ph id="ph2">`Task`</ph> and <ph id="ph3">`Task&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Numeric literal syntax improvements<ept id="p1">](#numeric-literal-syntax-improvements)</ept></source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>New tokens improve readability for numeric constants.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The remainder of this article provides an overview of each feature.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For each feature, you'll learn the reasoning behind it.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You'll learn the syntax.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can explore these features in our <bpt id="p1">[</bpt>interactive exploration<ept id="p1">](../tutorials/exploration/csharp-7.yml)</ept> of these features.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`out`</ph> variables</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The existing syntax that supports <ph id="ph1">`out`</ph> parameters has been improved in this version.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can now declare <ph id="ph1">`out`</ph> variables in the argument list of a method call, rather than writing a separate declaration statement:</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You may want to specify the type of the <ph id="ph1">`out`</ph> variable for clarity, as shown above.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>However, the language does support using an implicitly typed local variable:</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The code is easier to read.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You declare the out variable where you use it, not on another line above.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>No need to assign an initial value.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>By declaring the <ph id="ph1">`out`</ph> variable where it's used in a method call, you can't accidentally use it before it is assigned.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Tuples</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>C# provides a rich syntax for classes and structs that is used to explain your design intent.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>But sometimes that rich syntax requires extra work with minimal benefit.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You may often write methods that need a simple structure containing more than one data element.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>To support these scenarios <bpt id="p1">*</bpt>tuples<ept id="p1">*</ept> were added to C#.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Tuples are lightweight data structures that contain multiple fields to represent the data members.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The fields aren't validated, and you can't define your own methods</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Tuples were available before C# 7.0, but they were inefficient and had no language support.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This meant that tuple elements could only be referenced as <ph id="ph1">`Item1`</ph>, <ph id="ph2">`Item2`</ph> and so on.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new, more efficient tuple types.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can create a tuple by assigning a value to each member, and optionally providing semantic names to each of the members of the tuple:</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`namedLetters`</ph> tuple contains fields referred to as <ph id="ph2">`Alpha`</ph> and <ph id="ph3">`Beta`</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Those names exist only at compile time and aren't preserved, for example when inspecting the tuple using reflection at runtime.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>There may be times when you want to unpackage the members of a tuple that were returned from a method.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can do that by declaring separate variables for each of the values in the tuple.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This unpackaging is called <bpt id="p1">*</bpt>deconstructing<ept id="p1">*</ept> the tuple:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can also provide a similar deconstruction for any type in .NET.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You write a <ph id="ph1">`Deconstruct`</ph> method as a member of the class.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>That <ph id="ph1">`Deconstruct`</ph> method provides a set of <ph id="ph2">`out`</ph> arguments for each of the properties you want to extract.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Consider this <ph id="ph1">`Point`</ph> class that provides a deconstructor method that extracts the <ph id="ph2">`X`</ph> and <ph id="ph3">`Y`</ph> coordinates:</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can extract the individual fields by assigning a <ph id="ph1">`Point`</ph> to a tuple:</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can learn more in depth about tuples in the <bpt id="p1">[</bpt>tuples article<ept id="p1">](../tuples.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Discards</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Often when deconstructing a tuple or calling a method with <ph id="ph1">`out`</ph> parameters, you're forced to define a variable whose value you don't care about and don't intend to use.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>C# adds support for <bpt id="p1">*</bpt>discards<ept id="p1">*</ept> to handle this scenario.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>A discard is a write-only variable whose name is <ph id="ph1">`_`</ph> (the underscore character); you can assign all of the values that you intend to discard to the single variable.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>A discard is like an unassigned variable; apart from the assignment statement, the discard can't be used in code.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Discards are supported in the following scenarios:</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When deconstructing tuples or user-defined types.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>When calling methods with <bpt id="p1">[</bpt>out<ept id="p1">](../language-reference/keywords/out-parameter-modifier.md)</ept> parameters.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In a pattern matching operation with the <bpt id="p1">[</bpt>is<ept id="p1">](../language-reference/keywords/is.md)</ept> and <bpt id="p2">[</bpt>switch<ept id="p2">](../language-reference/keywords/switch.md)</ept> statements.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>As a standalone identifier when you want to explicitly identify the value of an assignment as a discard.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The following example defines a <ph id="ph1">`QueryCityDataForYears`</ph> method that returns a 6-tuple that contains a data for a city for two different years.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The method call in the example is concerned only with the two population values returned by the method and so treats the remaining values in the tuple as discards when it deconstructs the tuple.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Discards<ept id="p1">](../discards.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Pattern matching<ept id="p1">*</ept> is a feature that allows you to implement method dispatch on properties other than the type of an object.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You're probably already familiar with method dispatch based on the type of an object.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In object-oriented programming, virtual and override methods provide language syntax to implement method dispatching based on an object's type.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Base and Derived classes provide different implementations.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Pattern matching expressions extend this concept so that you can easily implement similar dispatch patterns for types and data elements that aren't related through an inheritance hierarchy.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Pattern matching supports <ph id="ph1">`is`</ph> expressions and <ph id="ph2">`switch`</ph> expressions.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Each enables inspecting an object and its properties to determine if that object satisfies the sought pattern.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You use the <ph id="ph1">`when`</ph> keyword to specify additional rules to the pattern.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`is`</ph> pattern expression extends the familiar <bpt id="p1">[</bpt><ph id="ph2">`is`</ph> operator<ept id="p1">](../language-reference/keywords/is.md#pattern-matching-with-is)</ept> to query an object about its type and assign the result in one instruction.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following code checks if a variable is an <ph id="ph1">`int`</ph>, and if so, adds it to the current sum:</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The preceding small example demonstrates the enhancements to the <ph id="ph1">`is`</ph> expression.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can test against value types as well as reference types, and you can assign the successful result to a new variable of the correct type.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The switch match expression has a familiar syntax, based on the <ph id="ph1">`switch`</ph> statement already part of the C# language.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The updated switch statement has several new constructs:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The governing type of a <ph id="ph1">`switch`</ph> expression is no longer restricted to integral types, <ph id="ph2">`Enum`</ph> types, <ph id="ph3">`string`</ph>, or a nullable type corresponding to one of those types.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Any type may be used.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You can test the type of the <ph id="ph1">`switch`</ph> expression in each <ph id="ph2">`case`</ph> label.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>As with the <ph id="ph1">`is`</ph> expression, you may assign a new variable to that type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You may add a <ph id="ph1">`when`</ph> clause to further test conditions on that variable.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The order of <ph id="ph1">`case`</ph> labels is now important.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The first branch to match is executed; others are skipped.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The following code demonstrates these new features:</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`case 0:`</ph> is the familiar constant pattern.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`case IEnumerable&lt;int&gt; childSequence:`</ph> is a type pattern.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`case int n when n &gt; 0:`</ph> is a type pattern with an additional <ph id="ph2">`when`</ph> condition.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`case null:`</ph> is the null pattern.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`default:`</ph> is the familiar default case.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>You can learn more about pattern matching in <bpt id="p1">[</bpt>Pattern Matching in C#<ept id="p1">](../pattern-matching.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Ref locals and returns</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>This feature enables algorithms that use and return references to variables defined elsewhere.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>One example is working with large matrices, and finding a single location with certain characteristics.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The following method returns a <bpt id="p1">**</bpt>reference<ept id="p1">**</ept> to that storage in the matrix:</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can declare the return value as a <ph id="ph1">`ref`</ph> and modify that value in the matrix, as shown in the following code:</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The C# language has several rules that protect you from misusing the <ph id="ph1">`ref`</ph> locals and returns:</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>You must add the <ph id="ph1">`ref`</ph> keyword to the method signature and to all <ph id="ph2">`return`</ph> statements in a method.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>That makes it clear the method returns by reference throughout the method.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`ref return`</ph> may be assigned to a value variable, or a <ph id="ph2">`ref`</ph> variable.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The caller controls whether the return value is copied or not.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Omitting the <ph id="ph1">`ref`</ph> modifier when assigning the return value indicates that the caller wants a copy of the value, not a reference to the storage.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>You can't assign a standard method return value to a <ph id="ph1">`ref`</ph> local variable.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>That disallows statements like <ph id="ph1">`ref int i = sequence.Count();`</ph></source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>You can't return a <ph id="ph1">`ref`</ph> to a variable whose lifetime doesn't extend beyond the execution of the method.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>That means you can't return a reference to a local variable or a variable with a similar scope.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`ref`</ph> locals and returns can't be used with async methods.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The compiler can't know if the referenced variable has been set to its final value when the async method returns.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The addition of ref locals and ref returns enables algorithms that are more efficient by avoiding copying values, or performing dereferencing operations multiple times.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Adding <ph id="ph1">`ref`</ph> to the return value is a <bpt id="p1">[</bpt>source compatible change<ept id="p1">](version-update-considerations.md#source-compatible-changes)</ept>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Existing code compiles, but the ref return value is copied when assigned.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Callers must update the storage for the return value to a <ph id="ph1">`ref`</ph> local variable to store the return as a reference.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For more information, see the <bpt id="p1">[</bpt>ref keyword<ept id="p1">](../language-reference/keywords/ref.md)</ept> article.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Local functions</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Many designs for classes include methods that are called from only one location.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>These additional private methods keep each method small and focused.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>Local functions<ept id="p1">*</ept> enable you to declare methods inside the context of another method.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Local functions make it easier for readers of the class to see that the local method is only called from the context in which is it declared.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>There are two common use cases for local functions: public iterator methods and public async methods.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Both types of methods generate code that reports errors later than programmers might expect.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In async methods, any exceptions are only observed when the returned <ph id="ph1">`Task`</ph> is awaited.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The following example demonstrates separating parameter validation from the iterator implementation using a local function:</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The same technique can be employed with <ph id="ph1">`async`</ph> methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Some of the designs that are supported by local functions could also be accomplished using <bpt id="p1">*</bpt>lambda expressions<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Those interested can <bpt id="p1">[</bpt>read more about the differences<ept id="p1">](../local-functions-vs-lambdas.md)</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>More expression-bodied members</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>C# 6 introduced <bpt id="p1">[</bpt>expression-bodied members<ept id="p1">](csharp-6.md#expression-bodied-function-members)</ept> for member functions, and read-only properties.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>C# 7.0 expands the allowed members that can be implemented as expressions.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>In C# 7.0, you can implement <bpt id="p1">*</bpt>constructors<ept id="p1">*</ept>, <bpt id="p2">*</bpt>finalizers<ept id="p2">*</ept>, and <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors on <bpt id="p3">*</bpt>properties<ept id="p3">*</ept> and <bpt id="p4">*</bpt>indexers<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The following code shows examples of each:</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This example does not need a finalizer, but it is shown to demonstrate the syntax.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You should not implement a finalizer in your class unless it is necessary to  release unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>You should also consider using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class instead of managing unmanaged resources directly.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>These new locations for expression-bodied members represent an important milestone for the C# language: These features were implemented by community members working on the open-source <bpt id="p1">[</bpt>Roslyn<ept id="p1">](https://github.com/dotnet/Roslyn)</ept> project.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Changing a method to an expression bodied member is a <bpt id="p1">[</bpt>binary compatible change<ept id="p1">](version-update-considerations.md#binary-compatible-changes)</ept>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Throw expressions</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>In C#, <ph id="ph1">`throw`</ph> has always been a statement.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Because <ph id="ph1">`throw`</ph> is a statement, not an expression, there were C# constructs where you couldn't use it.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>These included conditional expressions, null coalescing expressions, and some lambda expressions.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The addition of expression-bodied members adds more locations where <ph id="ph1">`throw`</ph> expressions would be useful.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>So that you can write any of these constructs, C# 7.0 introduces <bpt id="p1">*</bpt>throw expressions<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This addition makes it easier to write more expression-based code.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>You don't need additional statements for error checking.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Generalized async return types</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Returning a <ph id="ph1">`Task`</ph> object from async methods can introduce performance bottlenecks in certain paths.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Task`</ph> is a reference type, so using it means allocating an object.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>In cases where a method declared with the <ph id="ph1">`async`</ph> modifier returns a cached result, or completes synchronously, the extra allocations can become a significant time cost in performance critical sections of code.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>It can become costly if those allocations occur in tight loops.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The new language feature means that async method return types aren't limited to <ph id="ph1">`Task`</ph>, <ph id="ph2">`Task&lt;T&gt;`</ph>, and <ph id="ph3">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The returned type must still satisfy the async pattern, meaning a <ph id="ph1">`GetAwaiter`</ph> method must be accessible.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>As one concrete example, the <ph id="ph1">`ValueTask`</ph> type has been added to the .NET framework to make use of this new language feature:</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>You need to add the NuGet package <bpt id="p1">[</bpt><ph id="ph1">`System.Threading.Tasks.Extensions`</ph><ept id="p1">](https://www.nuget.org/packages/System.Threading.Tasks.Extensions/)</ept> in order to use the <ph id="ph2">&lt;xref:System.Threading.Tasks.ValueTask%601&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This enhancement is most useful for library authors to avoid allocating a <ph id="ph1">`Task`</ph> in performance critical code.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Numeric literal syntax improvements</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Misreading numeric constants can make it harder to understand code when reading it for the first time.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Bit masks or other symbolic values are prone to misunderstanding.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>C# 7.0 includes two new features to write numbers in the most readable fashion for the intended use: <bpt id="p1">*</bpt>binary literals<ept id="p1">*</ept>, and <bpt id="p2">*</bpt>digit separators<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For those times when you're creating bit masks, or whenever a binary representation of a number makes the most readable code, write that number in binary:</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`0b`</ph> at the beginning of the constant indicates that the number is written as a binary number.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Binary numbers can get long, so it's often easier to see the bit patterns by introducing the <ph id="ph1">`_`</ph> as a digit separator, as shown above in the binary constant.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The digit separator can appear anywhere in the constant.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>For base 10 numbers, it is common to use it as a thousands separator:</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The digit separator can be used with <ph id="ph1">`decimal`</ph>, <ph id="ph2">`float`</ph>, and <ph id="ph3">`double`</ph> types as well:</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Taken together, you can declare numeric constants with much more readability.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>